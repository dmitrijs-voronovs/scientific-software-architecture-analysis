id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/doc/master/TH1_8cxx_source.html:262057,Modifiability,extend,extendBitMask,262057," s[i] = c1*c1*s[i];; 6622 else s[i] = c1*s[i];; 6623 }; 6624 PutStats(s);; 6625 SetMinimum(); SetMaximum(); // minimum and maximum value will be recalculated the next time; 6626 }; 6627 ; 6628 // if contours set, must also scale contours; 6629 Int_t ncontours = GetContour();; 6630 if (ncontours == 0) return;; 6631 Double_t* levels = fContour.GetArray();; 6632 for (Int_t i = 0; i < ncontours; ++i) levels[i] *= c1;; 6633}; 6634 ; 6635////////////////////////////////////////////////////////////////////////////////; 6636/// Returns true if all axes are extendable.; 6637 ; 6638Bool_t TH1::CanExtendAllAxes() const; 6639{; 6640 Bool_t canExtend = fXaxis.CanExtend();; 6641 if (GetDimension() > 1) canExtend &= fYaxis.CanExtend();; 6642 if (GetDimension() > 2) canExtend &= fZaxis.CanExtend();; 6643 ; 6644 return canExtend;; 6645}; 6646 ; 6647////////////////////////////////////////////////////////////////////////////////; 6648/// Make the histogram axes extendable / not extendable according to the bit mask; 6649/// returns the previous bit mask specifying which axes are extendable; 6650 ; 6651UInt_t TH1::SetCanExtend(UInt_t extendBitMask); 6652{; 6653 UInt_t oldExtendBitMask = kNoAxis;; 6654 ; 6655 if (fXaxis.CanExtend()) oldExtendBitMask |= kXaxis;; 6656 if (extendBitMask & kXaxis) fXaxis.SetCanExtend(kTRUE);; 6657 else fXaxis.SetCanExtend(kFALSE);; 6658 ; 6659 if (GetDimension() > 1) {; 6660 if (fYaxis.CanExtend()) oldExtendBitMask |= kYaxis;; 6661 if (extendBitMask & kYaxis) fYaxis.SetCanExtend(kTRUE);; 6662 else fYaxis.SetCanExtend(kFALSE);; 6663 }; 6664 ; 6665 if (GetDimension() > 2) {; 6666 if (fZaxis.CanExtend()) oldExtendBitMask |= kZaxis;; 6667 if (extendBitMask & kZaxis) fZaxis.SetCanExtend(kTRUE);; 6668 else fZaxis.SetCanExtend(kFALSE);; 6669 }; 6670 ; 6671 return oldExtendBitMask;; 6672}; 6673 ; 6674///////////////////////////////////////////////////////////////////////////////; 6675/// Internal function used in TH1::Fill to see which axis is full alphanumeric,; 6",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:262195,Modifiability,extend,extendBitMask,262195,"= GetContour();; 6630 if (ncontours == 0) return;; 6631 Double_t* levels = fContour.GetArray();; 6632 for (Int_t i = 0; i < ncontours; ++i) levels[i] *= c1;; 6633}; 6634 ; 6635////////////////////////////////////////////////////////////////////////////////; 6636/// Returns true if all axes are extendable.; 6637 ; 6638Bool_t TH1::CanExtendAllAxes() const; 6639{; 6640 Bool_t canExtend = fXaxis.CanExtend();; 6641 if (GetDimension() > 1) canExtend &= fYaxis.CanExtend();; 6642 if (GetDimension() > 2) canExtend &= fZaxis.CanExtend();; 6643 ; 6644 return canExtend;; 6645}; 6646 ; 6647////////////////////////////////////////////////////////////////////////////////; 6648/// Make the histogram axes extendable / not extendable according to the bit mask; 6649/// returns the previous bit mask specifying which axes are extendable; 6650 ; 6651UInt_t TH1::SetCanExtend(UInt_t extendBitMask); 6652{; 6653 UInt_t oldExtendBitMask = kNoAxis;; 6654 ; 6655 if (fXaxis.CanExtend()) oldExtendBitMask |= kXaxis;; 6656 if (extendBitMask & kXaxis) fXaxis.SetCanExtend(kTRUE);; 6657 else fXaxis.SetCanExtend(kFALSE);; 6658 ; 6659 if (GetDimension() > 1) {; 6660 if (fYaxis.CanExtend()) oldExtendBitMask |= kYaxis;; 6661 if (extendBitMask & kYaxis) fYaxis.SetCanExtend(kTRUE);; 6662 else fYaxis.SetCanExtend(kFALSE);; 6663 }; 6664 ; 6665 if (GetDimension() > 2) {; 6666 if (fZaxis.CanExtend()) oldExtendBitMask |= kZaxis;; 6667 if (extendBitMask & kZaxis) fZaxis.SetCanExtend(kTRUE);; 6668 else fZaxis.SetCanExtend(kFALSE);; 6669 }; 6670 ; 6671 return oldExtendBitMask;; 6672}; 6673 ; 6674///////////////////////////////////////////////////////////////////////////////; 6675/// Internal function used in TH1::Fill to see which axis is full alphanumeric,; 6676/// i.e. can be extended and is alphanumeric; 6677UInt_t TH1::GetAxisLabelStatus() const; 6678{; 6679 UInt_t bitMask = kNoAxis;; 6680 if (fXaxis.CanExtend() && fXaxis.IsAlphanumeric() ) bitMask |= kXaxis;; 6681 if (GetDimension() > 1 && fYaxis.CanExtend() &",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:262394,Modifiability,extend,extendBitMask,262394,"/////////////////////////////////////////////////////////; 6636/// Returns true if all axes are extendable.; 6637 ; 6638Bool_t TH1::CanExtendAllAxes() const; 6639{; 6640 Bool_t canExtend = fXaxis.CanExtend();; 6641 if (GetDimension() > 1) canExtend &= fYaxis.CanExtend();; 6642 if (GetDimension() > 2) canExtend &= fZaxis.CanExtend();; 6643 ; 6644 return canExtend;; 6645}; 6646 ; 6647////////////////////////////////////////////////////////////////////////////////; 6648/// Make the histogram axes extendable / not extendable according to the bit mask; 6649/// returns the previous bit mask specifying which axes are extendable; 6650 ; 6651UInt_t TH1::SetCanExtend(UInt_t extendBitMask); 6652{; 6653 UInt_t oldExtendBitMask = kNoAxis;; 6654 ; 6655 if (fXaxis.CanExtend()) oldExtendBitMask |= kXaxis;; 6656 if (extendBitMask & kXaxis) fXaxis.SetCanExtend(kTRUE);; 6657 else fXaxis.SetCanExtend(kFALSE);; 6658 ; 6659 if (GetDimension() > 1) {; 6660 if (fYaxis.CanExtend()) oldExtendBitMask |= kYaxis;; 6661 if (extendBitMask & kYaxis) fYaxis.SetCanExtend(kTRUE);; 6662 else fYaxis.SetCanExtend(kFALSE);; 6663 }; 6664 ; 6665 if (GetDimension() > 2) {; 6666 if (fZaxis.CanExtend()) oldExtendBitMask |= kZaxis;; 6667 if (extendBitMask & kZaxis) fZaxis.SetCanExtend(kTRUE);; 6668 else fZaxis.SetCanExtend(kFALSE);; 6669 }; 6670 ; 6671 return oldExtendBitMask;; 6672}; 6673 ; 6674///////////////////////////////////////////////////////////////////////////////; 6675/// Internal function used in TH1::Fill to see which axis is full alphanumeric,; 6676/// i.e. can be extended and is alphanumeric; 6677UInt_t TH1::GetAxisLabelStatus() const; 6678{; 6679 UInt_t bitMask = kNoAxis;; 6680 if (fXaxis.CanExtend() && fXaxis.IsAlphanumeric() ) bitMask |= kXaxis;; 6681 if (GetDimension() > 1 && fYaxis.CanExtend() && fYaxis.IsAlphanumeric()); 6682 bitMask |= kYaxis;; 6683 if (GetDimension() > 2 && fZaxis.CanExtend() && fZaxis.IsAlphanumeric()); 6684 bitMask |= kZaxis;; 6685 ; 6686 return bitMask;; 6687}; 6688 ;",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:262601,Modifiability,extend,extendBitMask,262601,";; 6641 if (GetDimension() > 1) canExtend &= fYaxis.CanExtend();; 6642 if (GetDimension() > 2) canExtend &= fZaxis.CanExtend();; 6643 ; 6644 return canExtend;; 6645}; 6646 ; 6647////////////////////////////////////////////////////////////////////////////////; 6648/// Make the histogram axes extendable / not extendable according to the bit mask; 6649/// returns the previous bit mask specifying which axes are extendable; 6650 ; 6651UInt_t TH1::SetCanExtend(UInt_t extendBitMask); 6652{; 6653 UInt_t oldExtendBitMask = kNoAxis;; 6654 ; 6655 if (fXaxis.CanExtend()) oldExtendBitMask |= kXaxis;; 6656 if (extendBitMask & kXaxis) fXaxis.SetCanExtend(kTRUE);; 6657 else fXaxis.SetCanExtend(kFALSE);; 6658 ; 6659 if (GetDimension() > 1) {; 6660 if (fYaxis.CanExtend()) oldExtendBitMask |= kYaxis;; 6661 if (extendBitMask & kYaxis) fYaxis.SetCanExtend(kTRUE);; 6662 else fYaxis.SetCanExtend(kFALSE);; 6663 }; 6664 ; 6665 if (GetDimension() > 2) {; 6666 if (fZaxis.CanExtend()) oldExtendBitMask |= kZaxis;; 6667 if (extendBitMask & kZaxis) fZaxis.SetCanExtend(kTRUE);; 6668 else fZaxis.SetCanExtend(kFALSE);; 6669 }; 6670 ; 6671 return oldExtendBitMask;; 6672}; 6673 ; 6674///////////////////////////////////////////////////////////////////////////////; 6675/// Internal function used in TH1::Fill to see which axis is full alphanumeric,; 6676/// i.e. can be extended and is alphanumeric; 6677UInt_t TH1::GetAxisLabelStatus() const; 6678{; 6679 UInt_t bitMask = kNoAxis;; 6680 if (fXaxis.CanExtend() && fXaxis.IsAlphanumeric() ) bitMask |= kXaxis;; 6681 if (GetDimension() > 1 && fYaxis.CanExtend() && fYaxis.IsAlphanumeric()); 6682 bitMask |= kYaxis;; 6683 if (GetDimension() > 2 && fZaxis.CanExtend() && fZaxis.IsAlphanumeric()); 6684 bitMask |= kZaxis;; 6685 ; 6686 return bitMask;; 6687}; 6688 ; 6689////////////////////////////////////////////////////////////////////////////////; 6690/// Static function to set the default buffer size for automatic histograms.; 6691/// When a histogram is created wi",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:262944,Modifiability,extend,extended,262944,"tendable; 6650 ; 6651UInt_t TH1::SetCanExtend(UInt_t extendBitMask); 6652{; 6653 UInt_t oldExtendBitMask = kNoAxis;; 6654 ; 6655 if (fXaxis.CanExtend()) oldExtendBitMask |= kXaxis;; 6656 if (extendBitMask & kXaxis) fXaxis.SetCanExtend(kTRUE);; 6657 else fXaxis.SetCanExtend(kFALSE);; 6658 ; 6659 if (GetDimension() > 1) {; 6660 if (fYaxis.CanExtend()) oldExtendBitMask |= kYaxis;; 6661 if (extendBitMask & kYaxis) fYaxis.SetCanExtend(kTRUE);; 6662 else fYaxis.SetCanExtend(kFALSE);; 6663 }; 6664 ; 6665 if (GetDimension() > 2) {; 6666 if (fZaxis.CanExtend()) oldExtendBitMask |= kZaxis;; 6667 if (extendBitMask & kZaxis) fZaxis.SetCanExtend(kTRUE);; 6668 else fZaxis.SetCanExtend(kFALSE);; 6669 }; 6670 ; 6671 return oldExtendBitMask;; 6672}; 6673 ; 6674///////////////////////////////////////////////////////////////////////////////; 6675/// Internal function used in TH1::Fill to see which axis is full alphanumeric,; 6676/// i.e. can be extended and is alphanumeric; 6677UInt_t TH1::GetAxisLabelStatus() const; 6678{; 6679 UInt_t bitMask = kNoAxis;; 6680 if (fXaxis.CanExtend() && fXaxis.IsAlphanumeric() ) bitMask |= kXaxis;; 6681 if (GetDimension() > 1 && fYaxis.CanExtend() && fYaxis.IsAlphanumeric()); 6682 bitMask |= kYaxis;; 6683 if (GetDimension() > 2 && fZaxis.CanExtend() && fZaxis.IsAlphanumeric()); 6684 bitMask |= kZaxis;; 6685 ; 6686 return bitMask;; 6687}; 6688 ; 6689////////////////////////////////////////////////////////////////////////////////; 6690/// Static function to set the default buffer size for automatic histograms.; 6691/// When a histogram is created with one of its axis lower limit greater; 6692/// or equal to its upper limit, the function SetBuffer is automatically; 6693/// called with the default buffer size.; 6694 ; 6695void TH1::SetDefaultBufferSize(Int_t buffersize); 6696{; 6697 fgBufferSize = buffersize > 0 ? buffersize : 0;; 6698}; 6699 ; 6700////////////////////////////////////////////////////////////////////////////////; 6701/// When this static fun",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:277953,Modifiability,extend,extending,277953,"ent(bin);; 7077 e = GetBinError(bin);; 7078 if(fSumw2.fN) printf("" fSumw[%d][%d][%d]=%g, x=%g, y=%g, z=%g, error=%g\n"",binx,biny,binz,w,x,y,z,e);; 7079 else printf("" fSumw[%d][%d][%d]=%g, x=%g, y=%g, z=%g\n"",binx,biny,binz,w,x,y,z);; 7080 }; 7081 }; 7082 }; 7083 }; 7084}; 7085 ; 7086////////////////////////////////////////////////////////////////////////////////; 7087/// Using the current bin info, recompute the arrays for contents and errors; 7088 ; 7089void TH1::Rebuild(Option_t *); 7090{; 7091 SetBinsLength();; 7092 if (fSumw2.fN) {; 7093 fSumw2.Set(fNcells);; 7094 }; 7095}; 7096 ; 7097////////////////////////////////////////////////////////////////////////////////; 7098/// Reset this histogram: contents, errors, etc.; 7099/// \param[in] option; 7100/// - if ""ICE"" is specified, resets only Integral, Contents and Errors.; 7101/// - if ""ICES"" is specified, resets only Integral, Contents, Errors and Statistics; 7102/// This option is used; 7103/// - if ""M"" is specified, resets also Minimum and Maximum; 7104 ; 7105void TH1::Reset(Option_t *option); 7106{; 7107 // The option ""ICE"" is used when extending the histogram (in ExtendAxis, LabelInflate, etc..); 7108 // The option ""ICES is used in combination with the buffer (see BufferEmpty and BufferFill); 7109 ; 7110 TString opt = option;; 7111 opt.ToUpper();; 7112 fSumw2.Reset();; 7113 if (fIntegral) {; 7114 delete [] fIntegral;; 7115 fIntegral = nullptr;; 7116 }; 7117 ; 7118 if (opt.Contains(""M"")) {; 7119 SetMinimum();; 7120 SetMaximum();; 7121 }; 7122 ; 7123 if (opt.Contains(""ICE"") && !opt.Contains(""S"")) return;; 7124 ; 7125 // Setting fBuffer[0] = 0 is like resetting the buffer but not deleting it; 7126 // But what is the sense of calling BufferEmpty() ? For making the axes ?; 7127 // BufferEmpty will update contents that later will be; 7128 // reset in calling TH1D::Reset. For this we need to reset the stats afterwards; 7129 // It may be needed for computing the axis limits....; 7130 if (fBuffer) {BufferEmpty(); fBuffe",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:319294,Modifiability,adapt,adapted,319294,"119/// - ""D"" Put out a line of ""Debug"" printout; 8120/// - ""M"" Return the Maximum Kolmogorov distance instead of prob; 8121/// - ""X"" Run the pseudo experiments post-processor with the following procedure:; 8122/// make pseudoexperiments based on random values from the parent distribution,; 8123/// compare the KS distance of the pseudoexperiment to the parent; 8124/// distribution, and count all the KS values above the value; 8125/// obtained from the original data to Monte Carlo distribution.; 8126/// The number of pseudo-experiments nEXPT is by default 1000, and; 8127/// it can be changed by specifying the option as ""X=number"",; 8128/// for example ""X=10000"" for 10000 toys.; 8129/// The function returns the probability.; 8130/// (thanks to Ben Kilminster to submit this procedure). Note that; 8131/// this option ""X"" is much slower.; 8132///; 8133/// The returned function value is the probability of test; 8134/// (much less than one means NOT compatible); 8135///; 8136/// Code adapted by Rene Brun from original HBOOK routine HDIFF; 8137///; 8138/// NOTE1; 8139/// A good description of the Kolmogorov test can be seen at:; 8140/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; 8141///; 8142/// NOTE2; 8143/// see also alternative function TH1::Chi2Test; 8144/// The Kolmogorov test is assumed to give better results than Chi2Test; 8145/// in case of histograms with low statistics.; 8146///; 8147/// NOTE3 (Jan Conrad, Fred James); 8148/// ""The returned value PROB is calculated such that it will be; 8149/// uniformly distributed between zero and one for compatible histograms,; 8150/// provided the data are not binned (or the number of bins is very large; 8151/// compared with the number of events). Users who have access to unbinned; 8152/// data and wish exact confidence levels should therefore not put their data; 8153/// into histograms, but should call directly TMath::KolmogorovTest. On; 8154/// the other hand, since TH1 is a convenient way of collecting",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:341725,Modifiability,variab,variable,341725,"; 8710/// Retrieve the minimum and maximum values in the histogram; 8711///; 8712/// This will not return a cached value and will always search the; 8713/// histogram for the min and max values. The user can condition whether; 8714/// or not to call this with the GetMinimumStored() and GetMaximumStored(); 8715/// methods. If the cache is empty, then the value will be -1111. Users; 8716/// can then use the SetMinimum() or SetMaximum() methods to cache the results.; 8717/// For example, the following recipe will make efficient use of this method; 8718/// and the cached minimum and maximum values.; 8719//; 8720/// \code{.cpp}; 8721/// Double_t currentMin = pHist->GetMinimumStored();; 8722/// Double_t currentMax = pHist->GetMaximumStored();; 8723/// if ((currentMin == -1111) || (currentMax == -1111)) {; 8724/// pHist->GetMinimumAndMaximum(currentMin, currentMax);; 8725/// pHist->SetMinimum(currentMin);; 8726/// pHist->SetMaximum(currentMax);; 8727/// }; 8728/// \endcode; 8729///; 8730/// \param min reference to variable that will hold found minimum value; 8731/// \param max reference to variable that will hold found maximum value; 8732 ; 8733void TH1::GetMinimumAndMaximum(Double_t& min, Double_t& max) const; 8734{; 8735 // empty the buffer; 8736 if (fBuffer) ((TH1*)this)->BufferEmpty();; 8737 ; 8738 Int_t bin, binx, biny, binz;; 8739 Int_t xfirst = fXaxis.GetFirst();; 8740 Int_t xlast = fXaxis.GetLast();; 8741 Int_t yfirst = fYaxis.GetFirst();; 8742 Int_t ylast = fYaxis.GetLast();; 8743 Int_t zfirst = fZaxis.GetFirst();; 8744 Int_t zlast = fZaxis.GetLast();; 8745 min=TMath::Infinity();; 8746 max=-TMath::Infinity();; 8747 Double_t value;; 8748 for (binz=zfirst;binz<=zlast;binz++) {; 8749 for (biny=yfirst;biny<=ylast;biny++) {; 8750 for (binx=xfirst;binx<=xlast;binx++) {; 8751 bin = GetBin(binx,biny,binz);; 8752 value = RetrieveBinContent(bin);; 8753 if (value < min) min = value;; 8754 if (value > max) max = value;; 8755 }; 8756 }; 8757 }; 8758}; 8759 ; 8760//////////////",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:341802,Modifiability,variab,variable,341802,"; 8710/// Retrieve the minimum and maximum values in the histogram; 8711///; 8712/// This will not return a cached value and will always search the; 8713/// histogram for the min and max values. The user can condition whether; 8714/// or not to call this with the GetMinimumStored() and GetMaximumStored(); 8715/// methods. If the cache is empty, then the value will be -1111. Users; 8716/// can then use the SetMinimum() or SetMaximum() methods to cache the results.; 8717/// For example, the following recipe will make efficient use of this method; 8718/// and the cached minimum and maximum values.; 8719//; 8720/// \code{.cpp}; 8721/// Double_t currentMin = pHist->GetMinimumStored();; 8722/// Double_t currentMax = pHist->GetMaximumStored();; 8723/// if ((currentMin == -1111) || (currentMax == -1111)) {; 8724/// pHist->GetMinimumAndMaximum(currentMin, currentMax);; 8725/// pHist->SetMinimum(currentMin);; 8726/// pHist->SetMaximum(currentMax);; 8727/// }; 8728/// \endcode; 8729///; 8730/// \param min reference to variable that will hold found minimum value; 8731/// \param max reference to variable that will hold found maximum value; 8732 ; 8733void TH1::GetMinimumAndMaximum(Double_t& min, Double_t& max) const; 8734{; 8735 // empty the buffer; 8736 if (fBuffer) ((TH1*)this)->BufferEmpty();; 8737 ; 8738 Int_t bin, binx, biny, binz;; 8739 Int_t xfirst = fXaxis.GetFirst();; 8740 Int_t xlast = fXaxis.GetLast();; 8741 Int_t yfirst = fYaxis.GetFirst();; 8742 Int_t ylast = fYaxis.GetLast();; 8743 Int_t zfirst = fZaxis.GetFirst();; 8744 Int_t zlast = fZaxis.GetLast();; 8745 min=TMath::Infinity();; 8746 max=-TMath::Infinity();; 8747 Double_t value;; 8748 for (binz=zfirst;binz<=zlast;binz++) {; 8749 for (biny=yfirst;biny<=ylast;biny++) {; 8750 for (binx=xfirst;binx<=xlast;binx++) {; 8751 bin = GetBin(binx,biny,binz);; 8752 value = RetrieveBinContent(bin);; 8753 if (value < min) min = value;; 8754 if (value > max) max = value;; 8755 }; 8756 }; 8757 }; 8758}; 8759 ; 8760//////////////",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:343622,Modifiability,variab,variable,343622,"trieveBinContent(bin);; 8753 if (value < min) min = value;; 8754 if (value > max) max = value;; 8755 }; 8756 }; 8757 }; 8758}; 8759 ; 8760////////////////////////////////////////////////////////////////////////////////; 8761/// Redefine x axis parameters.; 8762///; 8763/// The X axis parameters are modified.; 8764/// The bins content array is resized; 8765/// if errors (Sumw2) the errors array is resized; 8766/// The previous bin contents are lost; 8767/// To change only the axis limits, see TAxis::SetRange; 8768 ; 8769void TH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); 8770{; 8771 if (GetDimension() != 1) {; 8772 Error(""SetBins"",""Operation only valid for 1-d histograms"");; 8773 return;; 8774 }; 8775 fXaxis.SetRange(0,0);; 8776 fXaxis.Set(nx,xmin,xmax);; 8777 fYaxis.Set(1,0,1);; 8778 fZaxis.Set(1,0,1);; 8779 fNcells = nx+2;; 8780 SetBinsLength(fNcells);; 8781 if (fSumw2.fN) {; 8782 fSumw2.Set(fNcells);; 8783 }; 8784}; 8785 ; 8786////////////////////////////////////////////////////////////////////////////////; 8787/// Redefine x axis parameters with variable bin sizes.; 8788///; 8789/// The X axis parameters are modified.; 8790/// The bins content array is resized; 8791/// if errors (Sumw2) the errors array is resized; 8792/// The previous bin contents are lost; 8793/// To change only the axis limits, see TAxis::SetRange; 8794/// xBins is supposed to be of length nx+1; 8795 ; 8796void TH1::SetBins(Int_t nx, const Double_t *xBins); 8797{; 8798 if (GetDimension() != 1) {; 8799 Error(""SetBins"",""Operation only valid for 1-d histograms"");; 8800 return;; 8801 }; 8802 fXaxis.SetRange(0,0);; 8803 fXaxis.Set(nx,xBins);; 8804 fYaxis.Set(1,0,1);; 8805 fZaxis.Set(1,0,1);; 8806 fNcells = nx+2;; 8807 SetBinsLength(fNcells);; 8808 if (fSumw2.fN) {; 8809 fSumw2.Set(fNcells);; 8810 }; 8811}; 8812 ; 8813////////////////////////////////////////////////////////////////////////////////; 8814/// Redefine x and y axis parameters.; 8815///; 8816/// The X and Y axis parameters are mod",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:345409,Modifiability,variab,variable,345409,"t(fNcells);; 8810 }; 8811}; 8812 ; 8813////////////////////////////////////////////////////////////////////////////////; 8814/// Redefine x and y axis parameters.; 8815///; 8816/// The X and Y axis parameters are modified.; 8817/// The bins content array is resized; 8818/// if errors (Sumw2) the errors array is resized; 8819/// The previous bin contents are lost; 8820/// To change only the axis limits, see TAxis::SetRange; 8821 ; 8822void TH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); 8823{; 8824 if (GetDimension() != 2) {; 8825 Error(""SetBins"",""Operation only valid for 2-D histograms"");; 8826 return;; 8827 }; 8828 fXaxis.SetRange(0,0);; 8829 fYaxis.SetRange(0,0);; 8830 fXaxis.Set(nx,xmin,xmax);; 8831 fYaxis.Set(ny,ymin,ymax);; 8832 fZaxis.Set(1,0,1);; 8833 fNcells = (nx+2)*(ny+2);; 8834 SetBinsLength(fNcells);; 8835 if (fSumw2.fN) {; 8836 fSumw2.Set(fNcells);; 8837 }; 8838}; 8839 ; 8840////////////////////////////////////////////////////////////////////////////////; 8841/// Redefine x and y axis parameters with variable bin sizes.; 8842///; 8843/// The X and Y axis parameters are modified.; 8844/// The bins content array is resized; 8845/// if errors (Sumw2) the errors array is resized; 8846/// The previous bin contents are lost; 8847/// To change only the axis limits, see TAxis::SetRange; 8848/// xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1; 8849 ; 8850void TH1::SetBins(Int_t nx, const Double_t *xBins, Int_t ny, const Double_t *yBins); 8851{; 8852 if (GetDimension() != 2) {; 8853 Error(""SetBins"",""Operation only valid for 2-D histograms"");; 8854 return;; 8855 }; 8856 fXaxis.SetRange(0,0);; 8857 fYaxis.SetRange(0,0);; 8858 fXaxis.Set(nx,xBins);; 8859 fYaxis.Set(ny,yBins);; 8860 fZaxis.Set(1,0,1);; 8861 fNcells = (nx+2)*(ny+2);; 8862 SetBinsLength(fNcells);; 8863 if (fSumw2.fN) {; 8864 fSumw2.Set(fNcells);; 8865 }; 8866}; 8867 ; 8868///////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:347406,Modifiability,variab,variable,347406,"//////////////////////////////; 8869/// Redefine x, y and z axis parameters.; 8870///; 8871/// The X, Y and Z axis parameters are modified.; 8872/// The bins content array is resized; 8873/// if errors (Sumw2) the errors array is resized; 8874/// The previous bin contents are lost; 8875/// To change only the axis limits, see TAxis::SetRange; 8876 ; 8877void TH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); 8878{; 8879 if (GetDimension() != 3) {; 8880 Error(""SetBins"",""Operation only valid for 3-D histograms"");; 8881 return;; 8882 }; 8883 fXaxis.SetRange(0,0);; 8884 fYaxis.SetRange(0,0);; 8885 fZaxis.SetRange(0,0);; 8886 fXaxis.Set(nx,xmin,xmax);; 8887 fYaxis.Set(ny,ymin,ymax);; 8888 fZaxis.Set(nz,zmin,zmax);; 8889 fNcells = (nx+2)*(ny+2)*(nz+2);; 8890 SetBinsLength(fNcells);; 8891 if (fSumw2.fN) {; 8892 fSumw2.Set(fNcells);; 8893 }; 8894}; 8895 ; 8896////////////////////////////////////////////////////////////////////////////////; 8897/// Redefine x, y and z axis parameters with variable bin sizes.; 8898///; 8899/// The X, Y and Z axis parameters are modified.; 8900/// The bins content array is resized; 8901/// if errors (Sumw2) the errors array is resized; 8902/// The previous bin contents are lost; 8903/// To change only the axis limits, see TAxis::SetRange; 8904/// xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1,; 8905/// zBins is supposed to be of length nz+1; 8906 ; 8907void TH1::SetBins(Int_t nx, const Double_t *xBins, Int_t ny, const Double_t *yBins, Int_t nz, const Double_t *zBins); 8908{; 8909 if (GetDimension() != 3) {; 8910 Error(""SetBins"",""Operation only valid for 3-D histograms"");; 8911 return;; 8912 }; 8913 fXaxis.SetRange(0,0);; 8914 fYaxis.SetRange(0,0);; 8915 fZaxis.SetRange(0,0);; 8916 fXaxis.Set(nx,xBins);; 8917 fYaxis.Set(ny,yBins);; 8918 fZaxis.Set(nz,zBins);; 8919 fNcells = (nx+2)*(ny+2)*(nz+2);; 8920 SetBinsLength(fNcells);; 8921 if",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:370219,Modifiability,variab,variable,370219,"________________; 9469 ; 9470ClassImp(TH1C);; 9471 ; 9472////////////////////////////////////////////////////////////////////////////////; 9473/// Constructor.; 9474 ; 9475TH1C::TH1C(); 9476{; 9477 fDimension = 1;; 9478 SetBinsLength(3);; 9479 if (fgDefaultSumw2) Sumw2();; 9480}; 9481 ; 9482////////////////////////////////////////////////////////////////////////////////; 9483/// Create a 1-Dim histogram with fix bins of type char (one byte per channel); 9484/// (see TH1::TH1 for explanation of parameters); 9485 ; 9486TH1C::TH1C(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup); 9487: TH1(name,title,nbins,xlow,xup); 9488{; 9489 fDimension = 1;; 9490 TArrayC::Set(fNcells);; 9491 ; 9492 if (xlow >= xup) SetBuffer(fgBufferSize);; 9493 if (fgDefaultSumw2) Sumw2();; 9494}; 9495 ; 9496////////////////////////////////////////////////////////////////////////////////; 9497/// Create a 1-Dim histogram with variable bins of type char (one byte per channel); 9498/// (see TH1::TH1 for explanation of parameters); 9499 ; 9500TH1C::TH1C(const char *name,const char *title,Int_t nbins,const Float_t *xbins); 9501: TH1(name,title,nbins,xbins); 9502{; 9503 fDimension = 1;; 9504 TArrayC::Set(fNcells);; 9505 if (fgDefaultSumw2) Sumw2();; 9506}; 9507 ; 9508////////////////////////////////////////////////////////////////////////////////; 9509/// Create a 1-Dim histogram with variable bins of type char (one byte per channel); 9510/// (see TH1::TH1 for explanation of parameters); 9511 ; 9512TH1C::TH1C(const char *name,const char *title,Int_t nbins,const Double_t *xbins); 9513: TH1(name,title,nbins,xbins); 9514{; 9515 fDimension = 1;; 9516 TArrayC::Set(fNcells);; 9517 if (fgDefaultSumw2) Sumw2();; 9518}; 9519 ; 9520////////////////////////////////////////////////////////////////////////////////; 9521/// Destructor.; 9522 ; 9523TH1C::~TH1C(); 9524{; 9525}; 9526 ; 9527////////////////////////////////////////////////////////////////////////////////; 9528/// Copy constructor",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:370682,Modifiability,variab,variable,370682,"________________; 9469 ; 9470ClassImp(TH1C);; 9471 ; 9472////////////////////////////////////////////////////////////////////////////////; 9473/// Constructor.; 9474 ; 9475TH1C::TH1C(); 9476{; 9477 fDimension = 1;; 9478 SetBinsLength(3);; 9479 if (fgDefaultSumw2) Sumw2();; 9480}; 9481 ; 9482////////////////////////////////////////////////////////////////////////////////; 9483/// Create a 1-Dim histogram with fix bins of type char (one byte per channel); 9484/// (see TH1::TH1 for explanation of parameters); 9485 ; 9486TH1C::TH1C(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup); 9487: TH1(name,title,nbins,xlow,xup); 9488{; 9489 fDimension = 1;; 9490 TArrayC::Set(fNcells);; 9491 ; 9492 if (xlow >= xup) SetBuffer(fgBufferSize);; 9493 if (fgDefaultSumw2) Sumw2();; 9494}; 9495 ; 9496////////////////////////////////////////////////////////////////////////////////; 9497/// Create a 1-Dim histogram with variable bins of type char (one byte per channel); 9498/// (see TH1::TH1 for explanation of parameters); 9499 ; 9500TH1C::TH1C(const char *name,const char *title,Int_t nbins,const Float_t *xbins); 9501: TH1(name,title,nbins,xbins); 9502{; 9503 fDimension = 1;; 9504 TArrayC::Set(fNcells);; 9505 if (fgDefaultSumw2) Sumw2();; 9506}; 9507 ; 9508////////////////////////////////////////////////////////////////////////////////; 9509/// Create a 1-Dim histogram with variable bins of type char (one byte per channel); 9510/// (see TH1::TH1 for explanation of parameters); 9511 ; 9512TH1C::TH1C(const char *name,const char *title,Int_t nbins,const Double_t *xbins); 9513: TH1(name,title,nbins,xbins); 9514{; 9515 fDimension = 1;; 9516 TArrayC::Set(fNcells);; 9517 if (fgDefaultSumw2) Sumw2();; 9518}; 9519 ; 9520////////////////////////////////////////////////////////////////////////////////; 9521/// Destructor.; 9522 ; 9523TH1C::~TH1C(); 9524{; 9525}; 9526 ; 9527////////////////////////////////////////////////////////////////////////////////; 9528/// Copy constructor",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:375931,Modifiability,variab,variable,375931,"_________________________________________________; 9655 ; 9656ClassImp(TH1S);; 9657 ; 9658////////////////////////////////////////////////////////////////////////////////; 9659/// Constructor.; 9660 ; 9661TH1S::TH1S(); 9662{; 9663 fDimension = 1;; 9664 SetBinsLength(3);; 9665 if (fgDefaultSumw2) Sumw2();; 9666}; 9667 ; 9668////////////////////////////////////////////////////////////////////////////////; 9669/// Create a 1-Dim histogram with fix bins of type short; 9670/// (see TH1::TH1 for explanation of parameters); 9671 ; 9672TH1S::TH1S(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup); 9673: TH1(name,title,nbins,xlow,xup); 9674{; 9675 fDimension = 1;; 9676 TArrayS::Set(fNcells);; 9677 ; 9678 if (xlow >= xup) SetBuffer(fgBufferSize);; 9679 if (fgDefaultSumw2) Sumw2();; 9680}; 9681 ; 9682////////////////////////////////////////////////////////////////////////////////; 9683/// Create a 1-Dim histogram with variable bins of type short; 9684/// (see TH1::TH1 for explanation of parameters); 9685 ; 9686TH1S::TH1S(const char *name,const char *title,Int_t nbins,const Float_t *xbins); 9687: TH1(name,title,nbins,xbins); 9688{; 9689 fDimension = 1;; 9690 TArrayS::Set(fNcells);; 9691 if (fgDefaultSumw2) Sumw2();; 9692}; 9693 ; 9694////////////////////////////////////////////////////////////////////////////////; 9695/// Create a 1-Dim histogram with variable bins of type short; 9696/// (see TH1::TH1 for explanation of parameters); 9697 ; 9698TH1S::TH1S(const char *name,const char *title,Int_t nbins,const Double_t *xbins); 9699: TH1(name,title,nbins,xbins); 9700{; 9701 fDimension = 1;; 9702 TArrayS::Set(fNcells);; 9703 if (fgDefaultSumw2) Sumw2();; 9704}; 9705 ; 9706////////////////////////////////////////////////////////////////////////////////; 9707/// Destructor.; 9708 ; 9709TH1S::~TH1S(); 9710{; 9711}; 9712 ; 9713////////////////////////////////////////////////////////////////////////////////; 9714/// Copy constructor.; 9715/// The list of functions ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:376372,Modifiability,variab,variable,376372,"_________________________________________________; 9655 ; 9656ClassImp(TH1S);; 9657 ; 9658////////////////////////////////////////////////////////////////////////////////; 9659/// Constructor.; 9660 ; 9661TH1S::TH1S(); 9662{; 9663 fDimension = 1;; 9664 SetBinsLength(3);; 9665 if (fgDefaultSumw2) Sumw2();; 9666}; 9667 ; 9668////////////////////////////////////////////////////////////////////////////////; 9669/// Create a 1-Dim histogram with fix bins of type short; 9670/// (see TH1::TH1 for explanation of parameters); 9671 ; 9672TH1S::TH1S(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup); 9673: TH1(name,title,nbins,xlow,xup); 9674{; 9675 fDimension = 1;; 9676 TArrayS::Set(fNcells);; 9677 ; 9678 if (xlow >= xup) SetBuffer(fgBufferSize);; 9679 if (fgDefaultSumw2) Sumw2();; 9680}; 9681 ; 9682////////////////////////////////////////////////////////////////////////////////; 9683/// Create a 1-Dim histogram with variable bins of type short; 9684/// (see TH1::TH1 for explanation of parameters); 9685 ; 9686TH1S::TH1S(const char *name,const char *title,Int_t nbins,const Float_t *xbins); 9687: TH1(name,title,nbins,xbins); 9688{; 9689 fDimension = 1;; 9690 TArrayS::Set(fNcells);; 9691 if (fgDefaultSumw2) Sumw2();; 9692}; 9693 ; 9694////////////////////////////////////////////////////////////////////////////////; 9695/// Create a 1-Dim histogram with variable bins of type short; 9696/// (see TH1::TH1 for explanation of parameters); 9697 ; 9698TH1S::TH1S(const char *name,const char *title,Int_t nbins,const Double_t *xbins); 9699: TH1(name,title,nbins,xbins); 9700{; 9701 fDimension = 1;; 9702 TArrayS::Set(fNcells);; 9703 if (fgDefaultSumw2) Sumw2();; 9704}; 9705 ; 9706////////////////////////////////////////////////////////////////////////////////; 9707/// Destructor.; 9708 ; 9709TH1S::~TH1S(); 9710{; 9711}; 9712 ; 9713////////////////////////////////////////////////////////////////////////////////; 9714/// Copy constructor.; 9715/// The list of functions ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:381648,Modifiability,variab,variable,381648,"______________________________________________; 9842 ; 9843ClassImp(TH1I);; 9844 ; 9845////////////////////////////////////////////////////////////////////////////////; 9846/// Constructor.; 9847 ; 9848TH1I::TH1I(); 9849{; 9850 fDimension = 1;; 9851 SetBinsLength(3);; 9852 if (fgDefaultSumw2) Sumw2();; 9853}; 9854 ; 9855////////////////////////////////////////////////////////////////////////////////; 9856/// Create a 1-Dim histogram with fix bins of type integer; 9857/// (see TH1::TH1 for explanation of parameters); 9858 ; 9859TH1I::TH1I(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup); 9860: TH1(name,title,nbins,xlow,xup); 9861{; 9862 fDimension = 1;; 9863 TArrayI::Set(fNcells);; 9864 ; 9865 if (xlow >= xup) SetBuffer(fgBufferSize);; 9866 if (fgDefaultSumw2) Sumw2();; 9867}; 9868 ; 9869////////////////////////////////////////////////////////////////////////////////; 9870/// Create a 1-Dim histogram with variable bins of type integer; 9871/// (see TH1::TH1 for explanation of parameters); 9872 ; 9873TH1I::TH1I(const char *name,const char *title,Int_t nbins,const Float_t *xbins); 9874: TH1(name,title,nbins,xbins); 9875{; 9876 fDimension = 1;; 9877 TArrayI::Set(fNcells);; 9878 if (fgDefaultSumw2) Sumw2();; 9879}; 9880 ; 9881////////////////////////////////////////////////////////////////////////////////; 9882/// Create a 1-Dim histogram with variable bins of type integer; 9883/// (see TH1::TH1 for explanation of parameters); 9884 ; 9885TH1I::TH1I(const char *name,const char *title,Int_t nbins,const Double_t *xbins); 9886: TH1(name,title,nbins,xbins); 9887{; 9888 fDimension = 1;; 9889 TArrayI::Set(fNcells);; 9890 if (fgDefaultSumw2) Sumw2();; 9891}; 9892 ; 9893////////////////////////////////////////////////////////////////////////////////; 9894/// Destructor.; 9895 ; 9896TH1I::~TH1I(); 9897{; 9898}; 9899 ; 9900////////////////////////////////////////////////////////////////////////////////; 9901/// Copy constructor.; 9902/// The list of functio",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:382091,Modifiability,variab,variable,382091,"______________________________________________; 9842 ; 9843ClassImp(TH1I);; 9844 ; 9845////////////////////////////////////////////////////////////////////////////////; 9846/// Constructor.; 9847 ; 9848TH1I::TH1I(); 9849{; 9850 fDimension = 1;; 9851 SetBinsLength(3);; 9852 if (fgDefaultSumw2) Sumw2();; 9853}; 9854 ; 9855////////////////////////////////////////////////////////////////////////////////; 9856/// Create a 1-Dim histogram with fix bins of type integer; 9857/// (see TH1::TH1 for explanation of parameters); 9858 ; 9859TH1I::TH1I(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup); 9860: TH1(name,title,nbins,xlow,xup); 9861{; 9862 fDimension = 1;; 9863 TArrayI::Set(fNcells);; 9864 ; 9865 if (xlow >= xup) SetBuffer(fgBufferSize);; 9866 if (fgDefaultSumw2) Sumw2();; 9867}; 9868 ; 9869////////////////////////////////////////////////////////////////////////////////; 9870/// Create a 1-Dim histogram with variable bins of type integer; 9871/// (see TH1::TH1 for explanation of parameters); 9872 ; 9873TH1I::TH1I(const char *name,const char *title,Int_t nbins,const Float_t *xbins); 9874: TH1(name,title,nbins,xbins); 9875{; 9876 fDimension = 1;; 9877 TArrayI::Set(fNcells);; 9878 if (fgDefaultSumw2) Sumw2();; 9879}; 9880 ; 9881////////////////////////////////////////////////////////////////////////////////; 9882/// Create a 1-Dim histogram with variable bins of type integer; 9883/// (see TH1::TH1 for explanation of parameters); 9884 ; 9885TH1I::TH1I(const char *name,const char *title,Int_t nbins,const Double_t *xbins); 9886: TH1(name,title,nbins,xbins); 9887{; 9888 fDimension = 1;; 9889 TArrayI::Set(fNcells);; 9890 if (fgDefaultSumw2) Sumw2();; 9891}; 9892 ; 9893////////////////////////////////////////////////////////////////////////////////; 9894/// Destructor.; 9895 ; 9896TH1I::~TH1I(); 9897{; 9898}; 9899 ; 9900////////////////////////////////////////////////////////////////////////////////; 9901/// Copy constructor.; 9902/// The list of functio",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:387479,Modifiability,variab,variable,387479,"_______________; 10030 ; 10031ClassImp(TH1L);; 10032 ; 10033////////////////////////////////////////////////////////////////////////////////; 10034/// Constructor.; 10035 ; 10036TH1L::TH1L(); 10037{; 10038 fDimension = 1;; 10039 SetBinsLength(3);; 10040 if (fgDefaultSumw2) Sumw2();; 10041}; 10042 ; 10043////////////////////////////////////////////////////////////////////////////////; 10044/// Create a 1-Dim histogram with fix bins of type long64; 10045/// (see TH1::TH1 for explanation of parameters); 10046 ; 10047TH1L::TH1L(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup); 10048: TH1(name,title,nbins,xlow,xup); 10049{; 10050 fDimension = 1;; 10051 TArrayL64::Set(fNcells);; 10052 ; 10053 if (xlow >= xup) SetBuffer(fgBufferSize);; 10054 if (fgDefaultSumw2) Sumw2();; 10055}; 10056 ; 10057////////////////////////////////////////////////////////////////////////////////; 10058/// Create a 1-Dim histogram with variable bins of type long64; 10059/// (see TH1::TH1 for explanation of parameters); 10060 ; 10061TH1L::TH1L(const char *name,const char *title,Int_t nbins,const Float_t *xbins); 10062: TH1(name,title,nbins,xbins); 10063{; 10064 fDimension = 1;; 10065 TArrayL64::Set(fNcells);; 10066 if (fgDefaultSumw2) Sumw2();; 10067}; 10068 ; 10069////////////////////////////////////////////////////////////////////////////////; 10070/// Create a 1-Dim histogram with variable bins of type long64; 10071/// (see TH1::TH1 for explanation of parameters); 10072 ; 10073TH1L::TH1L(const char *name,const char *title,Int_t nbins,const Double_t *xbins); 10074: TH1(name,title,nbins,xbins); 10075{; 10076 fDimension = 1;; 10077 TArrayL64::Set(fNcells);; 10078 if (fgDefaultSumw2) Sumw2();; 10079}; 10080 ; 10081////////////////////////////////////////////////////////////////////////////////; 10082/// Destructor.; 10083 ; 10084TH1L::~TH1L(); 10085{; 10086}; 10087 ; 10088////////////////////////////////////////////////////////////////////////////////; 10089/// Copy construc",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:387935,Modifiability,variab,variable,387935,"_______________; 10030 ; 10031ClassImp(TH1L);; 10032 ; 10033////////////////////////////////////////////////////////////////////////////////; 10034/// Constructor.; 10035 ; 10036TH1L::TH1L(); 10037{; 10038 fDimension = 1;; 10039 SetBinsLength(3);; 10040 if (fgDefaultSumw2) Sumw2();; 10041}; 10042 ; 10043////////////////////////////////////////////////////////////////////////////////; 10044/// Create a 1-Dim histogram with fix bins of type long64; 10045/// (see TH1::TH1 for explanation of parameters); 10046 ; 10047TH1L::TH1L(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup); 10048: TH1(name,title,nbins,xlow,xup); 10049{; 10050 fDimension = 1;; 10051 TArrayL64::Set(fNcells);; 10052 ; 10053 if (xlow >= xup) SetBuffer(fgBufferSize);; 10054 if (fgDefaultSumw2) Sumw2();; 10055}; 10056 ; 10057////////////////////////////////////////////////////////////////////////////////; 10058/// Create a 1-Dim histogram with variable bins of type long64; 10059/// (see TH1::TH1 for explanation of parameters); 10060 ; 10061TH1L::TH1L(const char *name,const char *title,Int_t nbins,const Float_t *xbins); 10062: TH1(name,title,nbins,xbins); 10063{; 10064 fDimension = 1;; 10065 TArrayL64::Set(fNcells);; 10066 if (fgDefaultSumw2) Sumw2();; 10067}; 10068 ; 10069////////////////////////////////////////////////////////////////////////////////; 10070/// Create a 1-Dim histogram with variable bins of type long64; 10071/// (see TH1::TH1 for explanation of parameters); 10072 ; 10073TH1L::TH1L(const char *name,const char *title,Int_t nbins,const Double_t *xbins); 10074: TH1(name,title,nbins,xbins); 10075{; 10076 fDimension = 1;; 10077 TArrayL64::Set(fNcells);; 10078 if (fgDefaultSumw2) Sumw2();; 10079}; 10080 ; 10081////////////////////////////////////////////////////////////////////////////////; 10082/// Destructor.; 10083 ; 10084TH1L::~TH1L(); 10085{; 10086}; 10087 ; 10088////////////////////////////////////////////////////////////////////////////////; 10089/// Copy construc",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:393438,Modifiability,variab,variable,393438,"//////////////////////////////////////////////////////////////; 10221/// Constructor.; 10222 ; 10223TH1F::TH1F(); 10224{; 10225 fDimension = 1;; 10226 SetBinsLength(3);; 10227 if (fgDefaultSumw2) Sumw2();; 10228}; 10229 ; 10230////////////////////////////////////////////////////////////////////////////////; 10231/// Create a 1-Dim histogram with fix bins of type float; 10232/// (see TH1::TH1 for explanation of parameters); 10233 ; 10234TH1F::TH1F(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup); 10235: TH1(name,title,nbins,xlow,xup); 10236{; 10237 fDimension = 1;; 10238 TArrayF::Set(fNcells);; 10239 ; 10240 if (xlow >= xup) SetBuffer(fgBufferSize);; 10241 if (fgDefaultSumw2) Sumw2();; 10242}; 10243 ; 10244////////////////////////////////////////////////////////////////////////////////; 10245/// Create a 1-Dim histogram with variable bins of type float; 10246/// (see TH1::TH1 for explanation of parameters); 10247 ; 10248TH1F::TH1F(const char *name,const char *title,Int_t nbins,const Float_t *xbins); 10249: TH1(name,title,nbins,xbins); 10250{; 10251 fDimension = 1;; 10252 TArrayF::Set(fNcells);; 10253 if (fgDefaultSumw2) Sumw2();; 10254}; 10255 ; 10256////////////////////////////////////////////////////////////////////////////////; 10257/// Create a 1-Dim histogram with variable bins of type float; 10258/// (see TH1::TH1 for explanation of parameters); 10259 ; 10260TH1F::TH1F(const char *name,const char *title,Int_t nbins,const Double_t *xbins); 10261: TH1(name,title,nbins,xbins); 10262{; 10263 fDimension = 1;; 10264 TArrayF::Set(fNcells);; 10265 if (fgDefaultSumw2) Sumw2();; 10266}; 10267 ; 10268////////////////////////////////////////////////////////////////////////////////; 10269/// Create a histogram from a TVectorF; 10270/// by default the histogram name is ""TVectorF"" and title = """"; 10271 ; 10272TH1F::TH1F(const TVectorF &v); 10273: TH1(""TVectorF"","""",v.GetNrows(),0,v.GetNrows()); 10274{; 10275 TArrayF::Set(fNcells);; 10276 fDimension = ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:393891,Modifiability,variab,variable,393891,"//////////////////////////////////////////////////////////////; 10221/// Constructor.; 10222 ; 10223TH1F::TH1F(); 10224{; 10225 fDimension = 1;; 10226 SetBinsLength(3);; 10227 if (fgDefaultSumw2) Sumw2();; 10228}; 10229 ; 10230////////////////////////////////////////////////////////////////////////////////; 10231/// Create a 1-Dim histogram with fix bins of type float; 10232/// (see TH1::TH1 for explanation of parameters); 10233 ; 10234TH1F::TH1F(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup); 10235: TH1(name,title,nbins,xlow,xup); 10236{; 10237 fDimension = 1;; 10238 TArrayF::Set(fNcells);; 10239 ; 10240 if (xlow >= xup) SetBuffer(fgBufferSize);; 10241 if (fgDefaultSumw2) Sumw2();; 10242}; 10243 ; 10244////////////////////////////////////////////////////////////////////////////////; 10245/// Create a 1-Dim histogram with variable bins of type float; 10246/// (see TH1::TH1 for explanation of parameters); 10247 ; 10248TH1F::TH1F(const char *name,const char *title,Int_t nbins,const Float_t *xbins); 10249: TH1(name,title,nbins,xbins); 10250{; 10251 fDimension = 1;; 10252 TArrayF::Set(fNcells);; 10253 if (fgDefaultSumw2) Sumw2();; 10254}; 10255 ; 10256////////////////////////////////////////////////////////////////////////////////; 10257/// Create a 1-Dim histogram with variable bins of type float; 10258/// (see TH1::TH1 for explanation of parameters); 10259 ; 10260TH1F::TH1F(const char *name,const char *title,Int_t nbins,const Double_t *xbins); 10261: TH1(name,title,nbins,xbins); 10262{; 10263 fDimension = 1;; 10264 TArrayF::Set(fNcells);; 10265 if (fgDefaultSumw2) Sumw2();; 10266}; 10267 ; 10268////////////////////////////////////////////////////////////////////////////////; 10269/// Create a histogram from a TVectorF; 10270/// by default the histogram name is ""TVectorF"" and title = """"; 10271 ; 10272TH1F::TH1F(const TVectorF &v); 10273: TH1(""TVectorF"","""",v.GetNrows(),0,v.GetNrows()); 10274{; 10275 TArrayF::Set(fNcells);; 10276 fDimension = ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:399035,Modifiability,variab,variable,399035,"/////////////////////////////////////////////////////////////; 10402/// Constructor.; 10403 ; 10404TH1D::TH1D(); 10405{; 10406 fDimension = 1;; 10407 SetBinsLength(3);; 10408 if (fgDefaultSumw2) Sumw2();; 10409}; 10410 ; 10411////////////////////////////////////////////////////////////////////////////////; 10412/// Create a 1-Dim histogram with fix bins of type double; 10413/// (see TH1::TH1 for explanation of parameters); 10414 ; 10415TH1D::TH1D(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup); 10416: TH1(name,title,nbins,xlow,xup); 10417{; 10418 fDimension = 1;; 10419 TArrayD::Set(fNcells);; 10420 ; 10421 if (xlow >= xup) SetBuffer(fgBufferSize);; 10422 if (fgDefaultSumw2) Sumw2();; 10423}; 10424 ; 10425////////////////////////////////////////////////////////////////////////////////; 10426/// Create a 1-Dim histogram with variable bins of type double; 10427/// (see TH1::TH1 for explanation of parameters); 10428 ; 10429TH1D::TH1D(const char *name,const char *title,Int_t nbins,const Float_t *xbins); 10430: TH1(name,title,nbins,xbins); 10431{; 10432 fDimension = 1;; 10433 TArrayD::Set(fNcells);; 10434 if (fgDefaultSumw2) Sumw2();; 10435}; 10436 ; 10437////////////////////////////////////////////////////////////////////////////////; 10438/// Create a 1-Dim histogram with variable bins of type double; 10439/// (see TH1::TH1 for explanation of parameters); 10440 ; 10441TH1D::TH1D(const char *name,const char *title,Int_t nbins,const Double_t *xbins); 10442: TH1(name,title,nbins,xbins); 10443{; 10444 fDimension = 1;; 10445 TArrayD::Set(fNcells);; 10446 if (fgDefaultSumw2) Sumw2();; 10447}; 10448 ; 10449////////////////////////////////////////////////////////////////////////////////; 10450/// Create a histogram from a TVectorD; 10451/// by default the histogram name is ""TVectorD"" and title = """"; 10452 ; 10453TH1D::TH1D(const TVectorD &v); 10454: TH1(""TVectorD"","""",v.GetNrows(),0,v.GetNrows()); 10455{; 10456 TArrayD::Set(fNcells);; 10457 fDimension =",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:399489,Modifiability,variab,variable,399489,"/////////////////////////////////////////////////////////////; 10402/// Constructor.; 10403 ; 10404TH1D::TH1D(); 10405{; 10406 fDimension = 1;; 10407 SetBinsLength(3);; 10408 if (fgDefaultSumw2) Sumw2();; 10409}; 10410 ; 10411////////////////////////////////////////////////////////////////////////////////; 10412/// Create a 1-Dim histogram with fix bins of type double; 10413/// (see TH1::TH1 for explanation of parameters); 10414 ; 10415TH1D::TH1D(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup); 10416: TH1(name,title,nbins,xlow,xup); 10417{; 10418 fDimension = 1;; 10419 TArrayD::Set(fNcells);; 10420 ; 10421 if (xlow >= xup) SetBuffer(fgBufferSize);; 10422 if (fgDefaultSumw2) Sumw2();; 10423}; 10424 ; 10425////////////////////////////////////////////////////////////////////////////////; 10426/// Create a 1-Dim histogram with variable bins of type double; 10427/// (see TH1::TH1 for explanation of parameters); 10428 ; 10429TH1D::TH1D(const char *name,const char *title,Int_t nbins,const Float_t *xbins); 10430: TH1(name,title,nbins,xbins); 10431{; 10432 fDimension = 1;; 10433 TArrayD::Set(fNcells);; 10434 if (fgDefaultSumw2) Sumw2();; 10435}; 10436 ; 10437////////////////////////////////////////////////////////////////////////////////; 10438/// Create a 1-Dim histogram with variable bins of type double; 10439/// (see TH1::TH1 for explanation of parameters); 10440 ; 10441TH1D::TH1D(const char *name,const char *title,Int_t nbins,const Double_t *xbins); 10442: TH1(name,title,nbins,xbins); 10443{; 10444 fDimension = 1;; 10445 TArrayD::Set(fNcells);; 10446 if (fgDefaultSumw2) Sumw2();; 10447}; 10448 ; 10449////////////////////////////////////////////////////////////////////////////////; 10450/// Create a histogram from a TVectorD; 10451/// by default the histogram name is ""TVectorD"" and title = """"; 10452 ; 10453TH1D::TH1D(const TVectorD &v); 10454: TH1(""TVectorD"","""",v.GetNrows(),0,v.GetNrows()); 10455{; 10456 TArrayD::Set(fNcells);; 10457 fDimension =",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:440542,Modifiability,extend,extendable,440542,"onvirtual Int_t GetDimension() constDefinition TH1.h:283; TH1::Streamervoid Streamer(TBuffer &) overrideStream a class object.Definition TH1.cxx:6933; TH1::AddDirectorystatic void AddDirectory(Bool_t add=kTRUE)Sets the flag controlling the automatic add of histograms in memory.Definition TH1.cxx:1294; TH1::kIsAverage@ kIsAverageBin contents are average (used by Add)Definition TH1.h:171; TH1::kUserContour@ kUserContourUser specified contour levels.Definition TH1.h:166; TH1::kNoStats@ kNoStatsDon't draw stats box.Definition TH1.h:165; TH1::kAutoBinPTwo@ kAutoBinPTwodifferent than 1.Definition TH1.h:174; TH1::kIsNotW@ kIsNotWHistogram is forced to be not weighted even when the histogram is filled with weighted.Definition TH1.h:172; TH1::kIsHighlight@ kIsHighlightbit set if histo is highlightDefinition TH1.h:175; TH1::SetContourLevelvirtual void SetContourLevel(Int_t level, Double_t value)Set value for one contour level.Definition TH1.cxx:8522; TH1::CanExtendAllAxesvirtual Bool_t CanExtendAllAxes() constReturns true if all axes are extendable.Definition TH1.cxx:6636; TH1::fDirectoryTDirectory * fDirectory! Pointer to directory holding this histogramDefinition TH1.h:109; TH1::Resetvirtual void Reset(Option_t *option="""")Reset this histogram: contents, errors, etc.Definition TH1.cxx:7103; TH1::SetNameTitlevoid SetNameTitle(const char *name, const char *title) overrideChange the name and title of this histogram.Definition TH1.cxx:8974; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetBinXYZvirtual void GetBinXYZ(Int_t binglobal, Int_t &binx, Int_t &biny, Int_t &binz) constReturn binx, biny, binz corresponding to the global bin number globalbin see TH1::GetBin function abo...Definition TH1.cxx:4974; TH1::GetCumulativeTH1 * GetCumulative(Bool_t forward=kTRUE, const char *suffix=""_cumulative"") constReturn a pointer to a histogram containing the cumulative content.Definition TH1.cxx:2616; TH1::AutoP2GetPower2static Double_t AutoP2GetPower2(Double_t x, Bool_t next=kT",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:450125,Modifiability,extend,extendBitMask,450125," bin) constReturn bin lower edge for 1D histogram.Definition TH1.cxx:9152; TH1::Buildvoid Build()Creates histogram basic data structure.Definition TH1.cxx:771; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::GetFunctionvirtual TF1 * GetFunction(const char *name) constReturn pointer to function with name.Definition TH1.cxx:9051; TH1::Rebinvirtual TH1 * Rebin(Int_t ngroup=2, const char *newname="""", const Double_t *xbins=nullptr)Rebin this histogram.Definition TH1.cxx:6275; TH1::BufferFillvirtual Int_t BufferFill(Double_t x, Double_t w)accumulate arguments in buffer.Definition TH1.cxx:1506; TH1::GetBinWithContentvirtual Double_t GetBinWithContent(Double_t c, Int_t &binx, Int_t firstx=0, Int_t lastx=0, Double_t maxdiff=0) constCompute first binx in the range [firstx,lastx] for which diff = abs(bin_content-c) <= maxdiff.Definition TH1.cxx:5086; TH1::SetCanExtendvirtual UInt_t SetCanExtend(UInt_t extendBitMask)Make the histogram axes extendable / not extendable according to the bit mask returns the previous bi...Definition TH1.cxx:6649; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::DrawCopyvirtual TH1 * DrawCopy(Option_t *option="""", const char *name_postfix=""_copy"") constCopy this histogram and Draw in the current pad.Definition TH1.cxx:3113; TH1::IsEmptyBool_t IsEmpty() constCheck if a histogram is empty (this is a protected method used mainly by TH1Merger )Definition TH1.cxx:5164; TH1::GetMeanErrorvirtual Double_t GetMeanError(Int_t axis=1) constReturn standard error of mean of this histogram along the X axis.Definition TH1.cxx:7575; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::AndersonDarlingTestvirtual Double_t AndersonDarlingTest(const TH1 *h2, Option_t *option="""") constSt",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:450163,Modifiability,extend,extendable,450163," bin) constReturn bin lower edge for 1D histogram.Definition TH1.cxx:9152; TH1::Buildvoid Build()Creates histogram basic data structure.Definition TH1.cxx:771; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::GetFunctionvirtual TF1 * GetFunction(const char *name) constReturn pointer to function with name.Definition TH1.cxx:9051; TH1::Rebinvirtual TH1 * Rebin(Int_t ngroup=2, const char *newname="""", const Double_t *xbins=nullptr)Rebin this histogram.Definition TH1.cxx:6275; TH1::BufferFillvirtual Int_t BufferFill(Double_t x, Double_t w)accumulate arguments in buffer.Definition TH1.cxx:1506; TH1::GetBinWithContentvirtual Double_t GetBinWithContent(Double_t c, Int_t &binx, Int_t firstx=0, Int_t lastx=0, Double_t maxdiff=0) constCompute first binx in the range [firstx,lastx] for which diff = abs(bin_content-c) <= maxdiff.Definition TH1.cxx:5086; TH1::SetCanExtendvirtual UInt_t SetCanExtend(UInt_t extendBitMask)Make the histogram axes extendable / not extendable according to the bit mask returns the previous bi...Definition TH1.cxx:6649; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::DrawCopyvirtual TH1 * DrawCopy(Option_t *option="""", const char *name_postfix=""_copy"") constCopy this histogram and Draw in the current pad.Definition TH1.cxx:3113; TH1::IsEmptyBool_t IsEmpty() constCheck if a histogram is empty (this is a protected method used mainly by TH1Merger )Definition TH1.cxx:5164; TH1::GetMeanErrorvirtual Double_t GetMeanError(Int_t axis=1) constReturn standard error of mean of this histogram along the X axis.Definition TH1.cxx:7575; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::AndersonDarlingTestvirtual Double_t AndersonDarlingTest(const TH1 *h2, Option_t *option="""") constSt",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:450180,Modifiability,extend,extendable,450180," bin) constReturn bin lower edge for 1D histogram.Definition TH1.cxx:9152; TH1::Buildvoid Build()Creates histogram basic data structure.Definition TH1.cxx:771; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::GetFunctionvirtual TF1 * GetFunction(const char *name) constReturn pointer to function with name.Definition TH1.cxx:9051; TH1::Rebinvirtual TH1 * Rebin(Int_t ngroup=2, const char *newname="""", const Double_t *xbins=nullptr)Rebin this histogram.Definition TH1.cxx:6275; TH1::BufferFillvirtual Int_t BufferFill(Double_t x, Double_t w)accumulate arguments in buffer.Definition TH1.cxx:1506; TH1::GetBinWithContentvirtual Double_t GetBinWithContent(Double_t c, Int_t &binx, Int_t firstx=0, Int_t lastx=0, Double_t maxdiff=0) constCompute first binx in the range [firstx,lastx] for which diff = abs(bin_content-c) <= maxdiff.Definition TH1.cxx:5086; TH1::SetCanExtendvirtual UInt_t SetCanExtend(UInt_t extendBitMask)Make the histogram axes extendable / not extendable according to the bit mask returns the previous bi...Definition TH1.cxx:6649; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::DrawCopyvirtual TH1 * DrawCopy(Option_t *option="""", const char *name_postfix=""_copy"") constCopy this histogram and Draw in the current pad.Definition TH1.cxx:3113; TH1::IsEmptyBool_t IsEmpty() constCheck if a histogram is empty (this is a protected method used mainly by TH1Merger )Definition TH1.cxx:5164; TH1::GetMeanErrorvirtual Double_t GetMeanError(Int_t axis=1) constReturn standard error of mean of this histogram along the X axis.Definition TH1.cxx:7575; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::AndersonDarlingTestvirtual Double_t AndersonDarlingTest(const TH1 *h2, Option_t *option="""") constSt",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:465953,Modifiability,inherit,inherits,465953," constReturn the unique object id.Definition TObject.cxx:462; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::UseCurrentStylevirtual void UseCurrentStyle()Set current style settings in this object This function is called when either TCanvas::UseCurrentStyl...Definition TObject.cxx:807; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SaveAsvirtual void SaveAs(const char *filename="""", Option_t *option="""") constSave this object in the file specified by filename.Definition TObject.cxx:692; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPluginHandlerDefinition TPluginManager.h:103; TPluginHandler::ExecPluginLongptr_t ExecPlugin(int nargs)Definition TPluginManager.h:231; TPluginHandler::",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:466951,Modifiability,plugin,plugin,466951,"kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPluginHandlerDefinition TPluginManager.h:103; TPluginHandler::ExecPluginLongptr_t ExecPlugin(int nargs)Definition TPluginManager.h:231; TPluginHandler::LoadPluginInt_t LoadPlugin()Load the plugin library for this handler.Definition TPluginManager.cxx:293; TProfile::Classstatic TClass * Class(); TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TRandom::PoissonDvirtual Double_t PoissonD(Double_t mean)Generates a random number according to a Poisson law.Definition TRandom.cxx:461; TRandom::Poissonvirtual ULong64_t Poisson(Double_t mean)Generates a random integer N according to a Poisson law.Definition TRandom.cxx:404; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::EndsWithBool_t EndsWith(const char *pat, ECaseCompare cmp=kExact) constReturn true if string ends with the specified string.Definition TString.cxx:2244; TString::Clearvoid Clear()Clear stri",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:130969,Performance,perform,performance,130969,"t; 3263/// - option of transform type; 3264/// - ""R2C"" - real to complex transforms - default; 3265/// - ""R2HC"" - real to halfcomplex (special format of storing output data,; 3266/// results the same as for R2C); 3267/// - ""DHT"" - discrete Hartley transform; 3268/// real to real transforms (sine and cosine):; 3269/// - ""R2R_0"", ""R2R_1"", ""R2R_2"", ""R2R_3"" - discrete cosine transforms of types I-IV; 3270/// - ""R2R_4"", ""R2R_5"", ""R2R_6"", ""R2R_7"" - discrete sine transforms of types I-IV; 3271/// To specify the type of each dimension of a 2-dimensional real to real; 3272/// transform, use options of form ""R2R_XX"", for example, ""R2R_02"" for a transform,; 3273/// which is of type ""R2R_0"" in 1st dimension and ""R2R_2"" in the 2nd.; 3274/// - option of transform flag; 3275/// - ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; 3276/// performance; 3277/// - ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; 3278/// - ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; 3279/// - ""EX"" (from ""exhaustive"") - the most optimal way is found; 3280/// This option should be chosen depending on how many transforms of the same size and; 3281/// type are going to be done. Planning is only done once, for the first transform of this; 3282/// size and type. Default is ""ES"".; 3283///; 3284/// Examples of valid options: ""Mag R2C M"" ""Re R2R_11"" ""Im R2C ES"" ""PH R2HC EX""; 3285 ; 3286TH1* TH1::FFT(TH1* h_output, Option_t *option); 3287{; 3288 ; 3289 Int_t ndim[3];; 3290 ndim[0] = this->GetNbinsX();; 3291 ndim[1] = this->GetNbinsY();; 3292 ndim[2] = this->GetNbinsZ();; 3293 ; 3294 TVirtualFFT *fft;; 3295 TString opt = option;; 3296 opt.ToUpper();; 3297 if (!opt.Contains(""2R"")){; 3298 if (!opt.Contains(""2C"") && !opt.Contains(""2HC"") && !opt.Contains(""DHT"")) {; 3299 //no type specified, ""R2C"" by default; 3300 opt.Append(""R2C"");; 3301 }; 3302 fft = TVirtualFFT::FFT(this->GetDimension(), ndim, opt.Da",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:159370,Performance,multi-thread,multi-thread,159370,"eters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits will be used.; 3963/// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; 3964/// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; 3965/// ""WIDTH"" | Scales the histogran bin content by the bin width (useful for variable bins histograms); 3966/// ""SERIAL"" | Runs in serial mode. By defult if ROOT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; 3967/// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; 3968///; 3969/// The default fitting of an histogram (when no option is given) is perfomed as following:; 3970/// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; 3971/// - the full range of the histogram is used;; 3972/// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; 3973/// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; 3974/// - only the status of the fit is returned;; 3975/// - the fit is performed in Multithread whenever is enabled in ROOT;; 3976/// - only the last fitted function is saved in the histogram;; 3977/// - the histogram is drawn after fitting overalyed with the resulting fitting function; 3978///; 3979/// \anchor HFitMinimizer; 3980/// ### Minimizer Configuration; 3981///; 3982/// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; 3983/// It is possible to change the default minimizer and its configuration parameters by calling thes",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:159485,Performance,multi-thread,multi-thread,159485,"eters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits will be used.; 3963/// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; 3964/// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; 3965/// ""WIDTH"" | Scales the histogran bin content by the bin width (useful for variable bins histograms); 3966/// ""SERIAL"" | Runs in serial mode. By defult if ROOT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; 3967/// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; 3968///; 3969/// The default fitting of an histogram (when no option is given) is perfomed as following:; 3970/// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; 3971/// - the full range of the histogram is used;; 3972/// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; 3973/// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; 3974/// - only the status of the fit is returned;; 3975/// - the fit is performed in Multithread whenever is enabled in ROOT;; 3976/// - only the last fitted function is saved in the histogram;; 3977/// - the histogram is drawn after fitting overalyed with the resulting fitting function; 3978///; 3979/// \anchor HFitMinimizer; 3980/// ### Minimizer Configuration; 3981///; 3982/// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; 3983/// It is possible to change the default minimizer and its configuration parameters by calling thes",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:160177,Performance,perform,performed,160177," the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; 3967/// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; 3968///; 3969/// The default fitting of an histogram (when no option is given) is perfomed as following:; 3970/// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; 3971/// - the full range of the histogram is used;; 3972/// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; 3973/// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; 3974/// - only the status of the fit is returned;; 3975/// - the fit is performed in Multithread whenever is enabled in ROOT;; 3976/// - only the last fitted function is saved in the histogram;; 3977/// - the histogram is drawn after fitting overalyed with the resulting fitting function; 3978///; 3979/// \anchor HFitMinimizer; 3980/// ### Minimizer Configuration; 3981///; 3982/// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; 3983/// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1::Fit`):; 3984/// - `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(minimizerName, minimizerAgorithm)` for changing the minmizer and/or the corresponding algorithm.; 3985/// For example `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS"");` will set the usage of the BFGS algorithm of the GSL multi-dimensional minimization; 3986/// The current defaults are (""Minuit"",""Migrad"").; 3987/// See the documentation of the `ROOT::Math::MinimizerOptions` for the available minimizers in ROOT and their corresponding algorithms.; 3988/// - `ROOT::Math::MinimizerOptions::SetDefaultTo",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:162117,Performance,perform,performed,162117," of the GSL multi-dimensional minimization; 3986/// The current defaults are (""Minuit"",""Migrad"").; 3987/// See the documentation of the `ROOT::Math::MinimizerOptions` for the available minimizers in ROOT and their corresponding algorithms.; 3988/// - `ROOT::Math::MinimizerOptions::SetDefaultTolerance` for setting a different tolerance value for the minimization.; 3989/// - `ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls` for setting the maximum number of function calls.; 3990/// - `ROOT::Math::MinimizerOptions::SetDefaultPrintLevel` for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing; 3991///; 3992/// Other options are possible depending on the Minimizer used, see the corresponding documentation.; 3993/// The default minimizer can be also set in the resource file in etc/system.rootrc. For example; 3994///; 3995/// ~~~ {.cpp}; 3996/// Root.Fitter: Minuit2; 3997/// ~~~; 3998///; 3999/// \anchor HFitChi2; 4000/// ### Chi-square Fits; 4001///; 4002/// By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method; 4003/// is used where the residual for each bin is computed using as error the observed value (the bin error) returned by `TH1::GetBinError`; 4004///; 4005/// \f[; 4006/// Chi2 = \sum_{i}{ \left(\frac{y(i) - f(x(i) | p )}{e(i)} \right)^2 }; 4007/// \f]; 4008///; 4009/// where `y(i)` is the bin content for each bin `i`, `x(i)` is the bin center and `e(i)` is the bin error (`sqrt(y(i)` for; 4010/// an un-weighted histogram). Bins with zero errors are excluded from the fit. See also later the note on the treatment; 4011/// of empty bins. When using option ""I"" the residual is computed not using the function value at the bin center, `f(x(i)|p)`,; 4012/// but the integral of the function in the bin, Integral{ f(x|p)dx }, divided by the bin volume.; 4013/// When using option `P` (Pearson chi2), the expected error computed as `e(i) = sqrt(f(x(i)|p))` is used.",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:165054,Performance,perform,perform,165054,"ograms,”; 4031/// Nucl. Instrum. Meth. 221 (1984) 437.; 4032///; 4033/// \f[; 4034/// NLL = \sum_{i}{( f(x(i) | p ) + y(i)\log(y(i)/ f(x(i) | p )) - y(i)) }; 4035/// \f]; 4036/// By using this formulation, `2*NLL` can be interpreted as the chi-square resulting from the fit.; 4037///; 4038/// This method should be always used when the bin content represents counts (i.e. errors are sqrt(N) ).; 4039/// The likelihood method has the advantage of treating correctly bins with low statistics. In case of high; 4040/// statistics/bin the distribution of the bin content becomes a normal distribution and the likelihood and the chi2 fit; 4041/// give the same result.; 4042///; 4043/// The likelihood method, although a bit slower, it is therefore the recommended method,; 4044/// when the histogram represent counts (Poisson statistics), where the chi-square methods may; 4045/// give incorrect results, especially in case of low statistics.; 4046/// In case of a weighted histogram, it is possible to perform also a likelihood fit by using the; 4047/// option ""WL"". Note a weighted histogram is a histogram which has been filled with weights and it; 4048/// has the information on the sum of the weight square for each bin ( TH1::Sumw2() has been called).; 4049/// The bin error for a weighted histogram is the square root of the sum of the weight square.; 4050///; 4051/// \anchor HFitRes; 4052/// ### Fit Result; 4053///; 4054/// The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; 4055/// By default the TFitResultPtr contains only the status of the fit which is return by an; 4056/// automatic conversion of the TFitResultPtr to an integer. One can write in this case directly:; 4057///; 4058/// ~~~ {.cpp}; 4059/// Int_t fitStatus = h->Fit(myFunc);; 4060/// ~~~; 4061///; 4062/// If the option ""S"" is instead used, TFitResultPtr behaves as a smart; 4063/// pointer to the TFitResult object. This is useful for retrieving the full result information from the fit, ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:168265,Performance,perform,performed,168265,"on first parameter; 4085/// ~~~; 4086///; 4087/// ##### Associated functions; 4088///; 4089/// One or more object ( can be added to the list; 4090/// of functions (fFunctions) associated to each histogram.; 4091/// When TH1::Fit is invoked, the fitted function is added to the histogram list of functions (fFunctions).; 4092/// If the histogram is made persistent, the list of associated functions is also persistent.; 4093/// Given a histogram h, one can retrieve an associated function with:; 4094///; 4095/// ~~~ {.cpp}; 4096/// TF1 *myfunc = h->GetFunction(""myfunc"");; 4097/// ~~~; 4098/// or by quering directly the list obtained by calling `TH1::GetListOfFunctions`.; 4099///; 4100/// \anchor HFitStatus; 4101/// ### Fit status; 4102///; 4103/// The status of the fit is obtained converting the TFitResultPtr to an integer; 4104/// independently if the fit option ""S"" is used or not:; 4105///; 4106/// ~~~ {.cpp}; 4107/// TFitResultPtr r = h->Fit(myFunc,opt);; 4108/// Int_t fitStatus = r;; 4109/// ~~~; 4110///; 4111/// - `status = 0` : the fit has been performed successfully (i.e no error occurred).; 4112/// - `status < 0` : there is an error not connected with the minimization procedure, for example when a wrong function is used.; 4113/// - `status > 0` : return status from Minimizer, depends on used Minimizer. For example for TMinuit and Minuit2 we have:; 4114/// - `status = migradStatus + 10*minosStatus + 100*hesseStatus + 1000*improveStatus`.; 4115/// TMinuit returns 0 (for migrad, minos, hesse or improve) in case of success and 4 in case of error (see the documentation of TMinuit::mnexcm). For example, for an error; 4116/// only in Minos but not in Migrad a fitStatus of 40 will be returned.; 4117/// Minuit2 returns 0 in case of success and different values in migrad,minos or; 4118/// hesse depending on the error. See in this case the documentation of; 4119/// Minuit2Minimizer::Minimize for the migrad return status, Minuit2Minimizer::GetMinosError for the; 4120/// minos ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:216222,Performance,perform,performed,216222,"bin,ibin,binx,biny,binz;; 5349 for (ibin =0; ibin < hold->fNcells; ibin++) {; 5350 // get the binx,y,z values . The x-y-z (axis) bin values will stay the same between new-old after the expanding; 5351 hold->GetBinXYZ(ibin,binx,biny,binz);; 5352 bin = GetBin(binx,biny,binz);; 5353 ; 5354 // underflow and overflow will be cleaned up because their meaning has been altered; 5355 if (hold->IsBinUnderflow(ibin,iaxis) || hold->IsBinOverflow(ibin,iaxis)) {; 5356 continue;; 5357 }; 5358 else {; 5359 AddBinContent(bin, hold->RetrieveBinContent(ibin));; 5360 if (errors) fSumw2.fArray[bin] += hold->fSumw2.fArray[ibin];; 5361 }; 5362 }; 5363 fEntries = oldEntries;; 5364 delete hold;; 5365}; 5366 ; 5367////////////////////////////////////////////////////////////////////////////////; 5368/// Sort bins with labels or set option(s) to draw axis with labels; 5369/// \param[in] option; 5370/// - ""a"" sort by alphabetic order; 5371/// - "">"" sort by decreasing values; 5372/// - ""<"" sort by increasing values; 5373/// - ""h"" draw labels horizontal; 5374/// - ""v"" draw labels vertical; 5375/// - ""u"" draw labels up (end of label right adjusted); 5376/// - ""d"" draw labels down (start of label left adjusted); 5377///; 5378/// In case not all bins have labels sorting will work only in the case; 5379/// the first `n` consecutive bins have all labels and sorting will be performed on; 5380/// those label bins.; 5381///; 5382/// \param[in] ax axis; 5383 ; 5384void TH1::LabelsOption(Option_t *option, Option_t *ax); 5385{; 5386 Int_t iaxis = AxisChoice(ax);; 5387 TAxis *axis = nullptr;; 5388 if (iaxis == 1); 5389 axis = GetXaxis();; 5390 if (iaxis == 2); 5391 axis = GetYaxis();; 5392 if (iaxis == 3); 5393 axis = GetZaxis();; 5394 if (!axis); 5395 return;; 5396 THashList *labels = axis->GetLabels();; 5397 if (!labels) {; 5398 Warning(""LabelsOption"", ""Axis %s has no labels!"",axis->GetName());; 5399 return;; 5400 }; 5401 TString opt = option;; 5402 opt.ToLower();; 5403 Int_t iopt = -1;; 5404 if (opt.Conta",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:237308,Performance,perform,perform,237308,"xmin, xmax);; 5973 ; 5974 //std::cout << ""New re-computed axis : [ "" << xmin << "" , "" << xmax << "" ] width = "" << width << "" nbins "" << destAxis.GetNbins() << std::endl;; 5975 ; 5976 return kTRUE;; 5977}; 5978 ; 5979////////////////////////////////////////////////////////////////////////////////; 5980/// Add all histograms in the collection to this histogram.; 5981/// This function computes the min/max for the x axis,; 5982/// compute a new number of bins, if necessary,; 5983/// add bin contents, errors and statistics.; 5984/// If all histograms have bin labels, bins with identical labels; 5985/// will be merged, no matter what their order is.; 5986/// If overflows are present and limits are different the function will fail.; 5987/// The function returns the total number of entries in the result histogram; 5988/// if the merge is successful, -1 otherwise.; 5989///; 5990/// Possible option:; 5991/// -NOL : the merger will ignore the labels and merge the histograms bin by bin using bin center values to match bins; 5992/// -NOCHECK: the histogram will not perform a check for duplicate labels in case of axes with labels. The check; 5993/// (enabled by default) slows down the merging; 5994///; 5995/// IMPORTANT remark. The axis x may have different number; 5996/// of bins and different limits, BUT the largest bin width must be; 5997/// a multiple of the smallest bin width and the upper limit must also; 5998/// be a multiple of the bin width.; 5999/// Example:; 6000///; 6001/// ~~~ {.cpp}; 6002/// void atest() {; 6003/// TH1F *h1 = new TH1F(""h1"",""h1"",110,-110,0);; 6004/// TH1F *h2 = new TH1F(""h2"",""h2"",220,0,110);; 6005/// TH1F *h3 = new TH1F(""h3"",""h3"",330,-55,55);; 6006/// TRandom r;; 6007/// for (Int_t i=0;i<10000;i++) {; 6008/// h1->Fill(r.Gaus(-55,10));; 6009/// h2->Fill(r.Gaus(55,10));; 6010/// h3->Fill(r.Gaus(0,10));; 6011/// }; 6012///; 6013/// TList *list = new TList;; 6014/// list->Add(h1);; 6015/// list->Add(h2);; 6016/// list->Add(h3);; 6017/// TH1F *h = (TH1F*)h",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:340810,Performance,cache,cached,340810," 8672 ; 8673////////////////////////////////////////////////////////////////////////////////; 8674/// Return location of bin with minimum value in the range.; 8675 ; 8676Int_t TH1::GetMinimumBin(Int_t &locmix, Int_t &locmiy, Int_t &locmiz) const; 8677{; 8678 // empty the buffer; 8679 if (fBuffer) ((TH1*)this)->BufferEmpty();; 8680 ; 8681 Int_t bin, binx, biny, binz;; 8682 Int_t locm;; 8683 Int_t xfirst = fXaxis.GetFirst();; 8684 Int_t xlast = fXaxis.GetLast();; 8685 Int_t yfirst = fYaxis.GetFirst();; 8686 Int_t ylast = fYaxis.GetLast();; 8687 Int_t zfirst = fZaxis.GetFirst();; 8688 Int_t zlast = fZaxis.GetLast();; 8689 Double_t minimum = FLT_MAX, value;; 8690 locm = locmix = locmiy = locmiz = 0;; 8691 for (binz=zfirst;binz<=zlast;binz++) {; 8692 for (biny=yfirst;biny<=ylast;biny++) {; 8693 for (binx=xfirst;binx<=xlast;binx++) {; 8694 bin = GetBin(binx,biny,binz);; 8695 value = RetrieveBinContent(bin);; 8696 if (value < minimum) {; 8697 minimum = value;; 8698 locm = bin;; 8699 locmix = binx;; 8700 locmiy = biny;; 8701 locmiz = binz;; 8702 }; 8703 }; 8704 }; 8705 }; 8706 return locm;; 8707}; 8708 ; 8709///////////////////////////////////////////////////////////////////////////////; 8710/// Retrieve the minimum and maximum values in the histogram; 8711///; 8712/// This will not return a cached value and will always search the; 8713/// histogram for the min and max values. The user can condition whether; 8714/// or not to call this with the GetMinimumStored() and GetMaximumStored(); 8715/// methods. If the cache is empty, then the value will be -1111. Users; 8716/// can then use the SetMinimum() or SetMaximum() methods to cache the results.; 8717/// For example, the following recipe will make efficient use of this method; 8718/// and the cached minimum and maximum values.; 8719//; 8720/// \code{.cpp}; 8721/// Double_t currentMin = pHist->GetMinimumStored();; 8722/// Double_t currentMax = pHist->GetMaximumStored();; 8723/// if ((currentMin == -1111) || (currentMax == -111",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:341033,Performance,cache,cache,341033,"87 Int_t zfirst = fZaxis.GetFirst();; 8688 Int_t zlast = fZaxis.GetLast();; 8689 Double_t minimum = FLT_MAX, value;; 8690 locm = locmix = locmiy = locmiz = 0;; 8691 for (binz=zfirst;binz<=zlast;binz++) {; 8692 for (biny=yfirst;biny<=ylast;biny++) {; 8693 for (binx=xfirst;binx<=xlast;binx++) {; 8694 bin = GetBin(binx,biny,binz);; 8695 value = RetrieveBinContent(bin);; 8696 if (value < minimum) {; 8697 minimum = value;; 8698 locm = bin;; 8699 locmix = binx;; 8700 locmiy = biny;; 8701 locmiz = binz;; 8702 }; 8703 }; 8704 }; 8705 }; 8706 return locm;; 8707}; 8708 ; 8709///////////////////////////////////////////////////////////////////////////////; 8710/// Retrieve the minimum and maximum values in the histogram; 8711///; 8712/// This will not return a cached value and will always search the; 8713/// histogram for the min and max values. The user can condition whether; 8714/// or not to call this with the GetMinimumStored() and GetMaximumStored(); 8715/// methods. If the cache is empty, then the value will be -1111. Users; 8716/// can then use the SetMinimum() or SetMaximum() methods to cache the results.; 8717/// For example, the following recipe will make efficient use of this method; 8718/// and the cached minimum and maximum values.; 8719//; 8720/// \code{.cpp}; 8721/// Double_t currentMin = pHist->GetMinimumStored();; 8722/// Double_t currentMax = pHist->GetMaximumStored();; 8723/// if ((currentMin == -1111) || (currentMax == -1111)) {; 8724/// pHist->GetMinimumAndMaximum(currentMin, currentMax);; 8725/// pHist->SetMinimum(currentMin);; 8726/// pHist->SetMaximum(currentMax);; 8727/// }; 8728/// \endcode; 8729///; 8730/// \param min reference to variable that will hold found minimum value; 8731/// \param max reference to variable that will hold found maximum value; 8732 ; 8733void TH1::GetMinimumAndMaximum(Double_t& min, Double_t& max) const; 8734{; 8735 // empty the buffer; 8736 if (fBuffer) ((TH1*)this)->BufferEmpty();; 8737 ; 8738 Int_t bin, binx, biny, binz;; 873",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:341151,Performance,cache,cache,341151,");; 8689 Double_t minimum = FLT_MAX, value;; 8690 locm = locmix = locmiy = locmiz = 0;; 8691 for (binz=zfirst;binz<=zlast;binz++) {; 8692 for (biny=yfirst;biny<=ylast;biny++) {; 8693 for (binx=xfirst;binx<=xlast;binx++) {; 8694 bin = GetBin(binx,biny,binz);; 8695 value = RetrieveBinContent(bin);; 8696 if (value < minimum) {; 8697 minimum = value;; 8698 locm = bin;; 8699 locmix = binx;; 8700 locmiy = biny;; 8701 locmiz = binz;; 8702 }; 8703 }; 8704 }; 8705 }; 8706 return locm;; 8707}; 8708 ; 8709///////////////////////////////////////////////////////////////////////////////; 8710/// Retrieve the minimum and maximum values in the histogram; 8711///; 8712/// This will not return a cached value and will always search the; 8713/// histogram for the min and max values. The user can condition whether; 8714/// or not to call this with the GetMinimumStored() and GetMaximumStored(); 8715/// methods. If the cache is empty, then the value will be -1111. Users; 8716/// can then use the SetMinimum() or SetMaximum() methods to cache the results.; 8717/// For example, the following recipe will make efficient use of this method; 8718/// and the cached minimum and maximum values.; 8719//; 8720/// \code{.cpp}; 8721/// Double_t currentMin = pHist->GetMinimumStored();; 8722/// Double_t currentMax = pHist->GetMaximumStored();; 8723/// if ((currentMin == -1111) || (currentMax == -1111)) {; 8724/// pHist->GetMinimumAndMaximum(currentMin, currentMax);; 8725/// pHist->SetMinimum(currentMin);; 8726/// pHist->SetMaximum(currentMax);; 8727/// }; 8728/// \endcode; 8729///; 8730/// \param min reference to variable that will hold found minimum value; 8731/// \param max reference to variable that will hold found maximum value; 8732 ; 8733void TH1::GetMinimumAndMaximum(Double_t& min, Double_t& max) const; 8734{; 8735 // empty the buffer; 8736 if (fBuffer) ((TH1*)this)->BufferEmpty();; 8737 ; 8738 Int_t bin, binx, biny, binz;; 8739 Int_t xfirst = fXaxis.GetFirst();; 8740 Int_t xlast = fXaxis.GetLast()",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:341269,Performance,cache,cached,341269,"z<=zlast;binz++) {; 8692 for (biny=yfirst;biny<=ylast;biny++) {; 8693 for (binx=xfirst;binx<=xlast;binx++) {; 8694 bin = GetBin(binx,biny,binz);; 8695 value = RetrieveBinContent(bin);; 8696 if (value < minimum) {; 8697 minimum = value;; 8698 locm = bin;; 8699 locmix = binx;; 8700 locmiy = biny;; 8701 locmiz = binz;; 8702 }; 8703 }; 8704 }; 8705 }; 8706 return locm;; 8707}; 8708 ; 8709///////////////////////////////////////////////////////////////////////////////; 8710/// Retrieve the minimum and maximum values in the histogram; 8711///; 8712/// This will not return a cached value and will always search the; 8713/// histogram for the min and max values. The user can condition whether; 8714/// or not to call this with the GetMinimumStored() and GetMaximumStored(); 8715/// methods. If the cache is empty, then the value will be -1111. Users; 8716/// can then use the SetMinimum() or SetMaximum() methods to cache the results.; 8717/// For example, the following recipe will make efficient use of this method; 8718/// and the cached minimum and maximum values.; 8719//; 8720/// \code{.cpp}; 8721/// Double_t currentMin = pHist->GetMinimumStored();; 8722/// Double_t currentMax = pHist->GetMaximumStored();; 8723/// if ((currentMin == -1111) || (currentMax == -1111)) {; 8724/// pHist->GetMinimumAndMaximum(currentMin, currentMax);; 8725/// pHist->SetMinimum(currentMin);; 8726/// pHist->SetMaximum(currentMax);; 8727/// }; 8728/// \endcode; 8729///; 8730/// \param min reference to variable that will hold found minimum value; 8731/// \param max reference to variable that will hold found maximum value; 8732 ; 8733void TH1::GetMinimumAndMaximum(Double_t& min, Double_t& max) const; 8734{; 8735 // empty the buffer; 8736 if (fBuffer) ((TH1*)this)->BufferEmpty();; 8737 ; 8738 Int_t bin, binx, biny, binz;; 8739 Int_t xfirst = fXaxis.GetFirst();; 8740 Int_t xlast = fXaxis.GetLast();; 8741 Int_t yfirst = fYaxis.GetFirst();; 8742 Int_t ylast = fYaxis.GetLast();; 8743 Int_t zfirst = fZaxis.GetF",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:28430,Safety,avoid,avoid,28430,"c to support the case where the same object is; 658 //added multiple times in fFunctions.; 659 //This case happens when the same object is added with different; 660 //drawing modes; 661 //In the loop below we must be careful with objects (eg TCutG) that may; 662 // have been added to the list of functions of several histograms; 663 //and may have been already deleted.; 664 while ((obj = fFunctions->First())) {; 665 while(fFunctions->Remove(obj)) { }; 666 if (ROOT::Detail::HasBeenDeleted(obj)) {; 667 break;; 668 }; 669 delete obj;; 670 obj = nullptr;; 671 }; 672 delete fFunctions;; 673 fFunctions = nullptr;; 674 }; 675 if (fDirectory) {; 676 fDirectory->Remove(this);; 677 fDirectory = nullptr;; 678 }; 679 delete fPainter;; 680 fPainter = nullptr;; 681}; 682 ; 683////////////////////////////////////////////////////////////////////////////////; 684/// Constructor for fix bin size histograms.; 685/// Creates the main histogram structure.; 686///; 687/// \param[in] name name of histogram (avoid blanks); 688/// \param[in] title histogram title.; 689/// If title is of the form `stringt;stringx;stringy;stringz`,; 690/// the histogram title is set to `stringt`,; 691/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 692/// \param[in] nbins number of bins; 693/// \param[in] xlow low edge of first bin; 694/// \param[in] xup upper edge of last bin (not included in last bin); 695 ; 696 ; 697TH1::TH1(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup); 698 :TNamed(name,title); 699{; 700 Build();; 701 if (nbins <= 0) {Warning(""TH1"",""nbins is <=0 - set to nbins = 1""); nbins = 1; }; 702 fXaxis.Set(nbins,xlow,xup);; 703 fNcells = fXaxis.GetNbins()+2;; 704}; 705 ; 706////////////////////////////////////////////////////////////////////////////////; 707/// Constructor for variable bin size histograms using an input array of type float.; 708/// Creates the main histogram structure.; 709///; 710/// \param[in] name name of histogram (avoid blanks);",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:29418,Safety,avoid,avoid,29418,"histogram (avoid blanks); 688/// \param[in] title histogram title.; 689/// If title is of the form `stringt;stringx;stringy;stringz`,; 690/// the histogram title is set to `stringt`,; 691/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 692/// \param[in] nbins number of bins; 693/// \param[in] xlow low edge of first bin; 694/// \param[in] xup upper edge of last bin (not included in last bin); 695 ; 696 ; 697TH1::TH1(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup); 698 :TNamed(name,title); 699{; 700 Build();; 701 if (nbins <= 0) {Warning(""TH1"",""nbins is <=0 - set to nbins = 1""); nbins = 1; }; 702 fXaxis.Set(nbins,xlow,xup);; 703 fNcells = fXaxis.GetNbins()+2;; 704}; 705 ; 706////////////////////////////////////////////////////////////////////////////////; 707/// Constructor for variable bin size histograms using an input array of type float.; 708/// Creates the main histogram structure.; 709///; 710/// \param[in] name name of histogram (avoid blanks); 711/// \param[in] title histogram title.; 712/// If title is of the form `stringt;stringx;stringy;stringz`; 713/// the histogram title is set to `stringt`,; 714/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 715/// \param[in] nbins number of bins; 716/// \param[in] xbins array of low-edges for each bin.; 717/// This is an array of type float and size nbins+1; 718 ; 719TH1::TH1(const char *name,const char *title,Int_t nbins,const Float_t *xbins); 720 :TNamed(name,title); 721{; 722 Build();; 723 if (nbins <= 0) {Warning(""TH1"",""nbins is <=0 - set to nbins = 1""); nbins = 1; }; 724 if (xbins) fXaxis.Set(nbins,xbins);; 725 else fXaxis.Set(nbins,0,1);; 726 fNcells = fXaxis.GetNbins()+2;; 727}; 728 ; 729////////////////////////////////////////////////////////////////////////////////; 730/// Constructor for variable bin size histograms using an input array of type double.; 731///; 732/// \param[in] name name of histogram (avoid blanks); 733/// \param[in] tit",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:30384,Safety,avoid,avoid,30384,"aram[in] name name of histogram (avoid blanks); 711/// \param[in] title histogram title.; 712/// If title is of the form `stringt;stringx;stringy;stringz`; 713/// the histogram title is set to `stringt`,; 714/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 715/// \param[in] nbins number of bins; 716/// \param[in] xbins array of low-edges for each bin.; 717/// This is an array of type float and size nbins+1; 718 ; 719TH1::TH1(const char *name,const char *title,Int_t nbins,const Float_t *xbins); 720 :TNamed(name,title); 721{; 722 Build();; 723 if (nbins <= 0) {Warning(""TH1"",""nbins is <=0 - set to nbins = 1""); nbins = 1; }; 724 if (xbins) fXaxis.Set(nbins,xbins);; 725 else fXaxis.Set(nbins,0,1);; 726 fNcells = fXaxis.GetNbins()+2;; 727}; 728 ; 729////////////////////////////////////////////////////////////////////////////////; 730/// Constructor for variable bin size histograms using an input array of type double.; 731///; 732/// \param[in] name name of histogram (avoid blanks); 733/// \param[in] title histogram title.; 734/// If title is of the form `stringt;stringx;stringy;stringz`; 735/// the histogram title is set to `stringt`,; 736/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 737/// \param[in] nbins number of bins; 738/// \param[in] xbins array of low-edges for each bin.; 739/// This is an array of type double and size nbins+1; 740 ; 741TH1::TH1(const char *name,const char *title,Int_t nbins,const Double_t *xbins); 742 :TNamed(name,title); 743{; 744 Build();; 745 if (nbins <= 0) {Warning(""TH1"",""nbins is <=0 - set to nbins = 1""); nbins = 1; }; 746 if (xbins) fXaxis.Set(nbins,xbins);; 747 else fXaxis.Set(nbins,0,1);; 748 fNcells = fXaxis.GetNbins()+2;; 749}; 750 ; 751////////////////////////////////////////////////////////////////////////////////; 752/// Static function: cannot be inlined on Windows/NT.; 753 ; 754Bool_t TH1::AddDirectoryStatus(); 755{; 756 return fgAddDirectory;; 757}; 758 ; 759////////////////////////",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:39731,Safety,risk,risks,39731,"there is an inconsistency, we try to use merging; 972 if(inconsistency > kFullyConsistent) {; 973 useMerge = considerMerge;; 974 }; 975 ; 976 if (useMerge) {; 977 TList l;; 978 l.Add(const_cast<TH1*>(h1));; 979 auto iret = Merge(&l);; 980 return (iret >= 0);; 981 }; 982 ; 983 // Create Sumw2 if h1 has Sumw2 set; 984 if (fSumw2.fN == 0 && h1->GetSumw2N() != 0) Sumw2();; 985 ; 986 // - Add statistics; 987 Double_t entries = TMath::Abs( GetEntries() + c1 * h1->GetEntries() );; 988 ; 989 // statistics can be preserved only in case of positive coefficients; 990 // otherwise with negative c1 (histogram subtraction) one risks to get negative variances; 991 Bool_t resetStats = (c1 < 0);; 992 Double_t s1[kNstat] = {0};; 993 Double_t s2[kNstat] = {0};; 994 if (!resetStats) {; 995 // need to initialize to zero s1 and s2 since; 996 // GetStats fills only used elements depending on dimension and type; 997 GetStats(s1);; 998 h1->GetStats(s2);; 999 }; 1000 ; 1001 SetMinimum();; 1002 SetMaximum();; 1003 ; 1004 // - Loop on bins (including underflows/overflows); 1005 Double_t factor = 1;; 1006 if (h1->GetNormFactor() != 0) factor = h1->GetNormFactor()/h1->GetSumOfWeights();; 1007 Double_t c1sq = c1 * c1;; 1008 Double_t factsq = factor * factor;; 1009 ; 1010 for (Int_t bin = 0; bin < fNcells; ++bin) {; 1011 //special case where histograms have the kIsAverage bit set; 1012 if (this->TestBit(kIsAverage) && h1->TestBit(kIsAverage)) {; 1013 Double_t y1 = h1->RetrieveBinContent(bin);; 1014 Double_t y2 = this->RetrieveBinContent(bin);; 1015 Double_t e1sq = h1->GetBinErrorSqUnchecked(bin);; 1016 Double_t e2sq = this->GetBinErrorSqUnchecked(bin);; 1017 Double_t w1 = 1., w2 = 1.;; 1018 ; 1019 // consider all special cases when bin errors are zero; 1020 // see http://root-forum.cern.ch/viewtopic.php?f=3&t=13299; 1021 if (e1sq) w1 = 1. / e1sq;; 1022 else if (h1->fSumw2.fN) {; 1023 w1 = 1.E200; // use an arbitrary huge value; 1024 if (y1 == 0) {; 1025 // use an estimated error from the global hi",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:42046,Safety,avoid,avoid,42046,"31 else if (fSumw2.fN) {; 1032 w2 = 1.E200; // use an arbitrary huge value; 1033 if (y2 == 0) {; 1034 // use an estimated error from the global histogram scale; 1035 double sf = (s1[0] != 0) ? s1[1]/s1[0] : 1;; 1036 w2 = 1./(sf*sf);; 1037 }; 1038 }; 1039 ; 1040 double y = (w1*y1 + w2*y2)/(w1 + w2);; 1041 UpdateBinContent(bin, y);; 1042 if (fSumw2.fN) {; 1043 double err2 = 1./(w1 + w2);; 1044 if (err2 < 1.E-200) err2 = 0; // to remove arbitrary value when e1=0 AND e2=0; 1045 fSumw2.fArray[bin] = err2;; 1046 }; 1047 } else { // normal case of addition between histograms; 1048 AddBinContent(bin, c1 * factor * h1->RetrieveBinContent(bin));; 1049 if (fSumw2.fN) fSumw2.fArray[bin] += c1sq * factsq * h1->GetBinErrorSqUnchecked(bin);; 1050 }; 1051 }; 1052 ; 1053 // update statistics (do here to avoid changes by SetBinContent); 1054 if (resetStats) {; 1055 // statistics need to be reset in case coefficient are negative; 1056 ResetStats();; 1057 }; 1058 else {; 1059 for (Int_t i=0;i<kNstat;i++) {; 1060 if (i == 1) s1[i] += c1*c1*s2[i];; 1061 else s1[i] += c1*s2[i];; 1062 }; 1063 PutStats(s1);; 1064 SetEntries(entries);; 1065 }; 1066 return kTRUE;; 1067}; 1068 ; 1069////////////////////////////////////////////////////////////////////////////////; 1070/// Replace contents of this histogram by the addition of h1 and h2.; 1071///; 1072/// `this = c1*h1 + c2*h2`; 1073/// if errors are defined (see TH1::Sumw2), errors are also recalculated; 1074///; 1075/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 1076/// if not already set.; 1077///; 1078/// Note also that adding histogram with labels is not supported, histogram will be; 1079/// added merging them by bin number independently of the labels.; 1080/// For adding histogram ith labels one should use TH1::Merge; 1081///; 1082/// SPECIAL CASE (Average/Efficiency histograms); 1083/// For histograms representing averages or efficiencies, one should compute the average; 1084/// of the two histograms and ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:46123,Safety,risk,risks,46123,"w2 if h1 or h2 have Sumw2 set; 1148 if (fSumw2.fN == 0 && (h1->GetSumw2N() != 0 || h2->GetSumw2N() != 0)) Sumw2();; 1149 ; 1150 // - Add statistics; 1151 Double_t nEntries = TMath::Abs( c1*h1->GetEntries() + c2*h2->GetEntries() );; 1152 ; 1153 // TODO remove; 1154 // statistics can be preserved only in case of positive coefficients; 1155 // otherwise with negative c1 (histogram subtraction) one risks to get negative variances; 1156 // also in case of scaling with the width we cannot preserve the statistics; 1157 Double_t s1[kNstat] = {0};; 1158 Double_t s2[kNstat] = {0};; 1159 Double_t s3[kNstat];; 1160 ; 1161 ; 1162 Bool_t resetStats = (c1*c2 < 0) || normWidth;; 1163 if (!resetStats) {; 1164 // need to initialize to zero s1 and s2 since; 1165 // GetStats fills only used elements depending on dimension and type; 1166 h1->GetStats(s1);; 1167 h2->GetStats(s2);; 1168 for (Int_t i=0;i<kNstat;i++) {; 1169 if (i == 1) s3[i] = c1*c1*s1[i] + c2*c2*s2[i];; 1170 //else s3[i] = TMath::Abs(c1)*s1[i] + TMath::Abs(c2)*s2[i];; 1171 else s3[i] = c1*s1[i] + c2*s2[i];; 1172 }; 1173 }; 1174 ; 1175 SetMinimum();; 1176 SetMaximum();; 1177 ; 1178 if (normWidth) { // DEPRECATED CASE: belongs to fitting / drawing modules; 1179 ; 1180 Int_t nbinsx = GetNbinsX() + 2; // normal bins + underflow, overflow; 1181 Int_t nbinsy = GetNbinsY() + 2;; 1182 Int_t nbinsz = GetNbinsZ() + 2;; 1183 ; 1184 if (fDimension < 2) nbinsy = 1;; 1185 if (fDimension < 3) nbinsz = 1;; 1186 ; 1187 Int_t bin, binx, biny, binz;; 1188 for (binz = 0; binz < nbinsz; ++binz) {; 1189 Double_t wz = h1->GetZaxis()->GetBinWidth(binz);; 1190 for (biny = 0; biny < nbinsy; ++biny) {; 1191 Double_t wy = h1->GetYaxis()->GetBinWidth(biny);; 1192 for (binx = 0; binx < nbinsx; ++binx) {; 1193 Double_t wx = h1->GetXaxis()->GetBinWidth(binx);; 1194 bin = GetBin(binx, biny, binz);; 1195 Double_t w = wx*wy*wz;; 1196 UpdateBinContent(bin, c1 * h1->RetrieveBinContent(bin) / w);; 1197 if (fSumw2.fN) {; 1198 Double_t e1 = h1->GetBinError(bin)/",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:49871,Safety,avoid,avoid,49871,"obal histogram scale; 1227 double sf = (s2[0] != 0) ? s2[1]/s2[0] : 1;; 1228 w2 = 1./(sf*sf);; 1229 }; 1230 }; 1231 ; 1232 double y = (w1*y1 + w2*y2)/(w1 + w2);; 1233 UpdateBinContent(i, y);; 1234 if (fSumw2.fN) {; 1235 double err2 = 1./(w1 + w2);; 1236 if (err2 < 1.E-200) err2 = 0; // to remove arbitrary value when e1=0 AND e2=0; 1237 fSumw2.fArray[i] = err2;; 1238 }; 1239 }; 1240 } else { // case of simple histogram addition; 1241 Double_t c1sq = c1 * c1;; 1242 Double_t c2sq = c2 * c2;; 1243 for (Int_t i = 0; i < fNcells; ++i) { // Loop on cells (bins including underflows/overflows); 1244 UpdateBinContent(i, c1 * h1->RetrieveBinContent(i) + c2 * h2->RetrieveBinContent(i));; 1245 if (fSumw2.fN) {; 1246 fSumw2.fArray[i] = c1sq * h1->GetBinErrorSqUnchecked(i) + c2sq * h2->GetBinErrorSqUnchecked(i);; 1247 }; 1248 }; 1249 }; 1250 ; 1251 if (resetStats) {; 1252 // statistics need to be reset in case coefficient are negative; 1253 ResetStats();; 1254 }; 1255 else {; 1256 // update statistics (do here to avoid changes by SetBinContent) FIXME remove???; 1257 PutStats(s3);; 1258 SetEntries(nEntries);; 1259 }; 1260 ; 1261 return kTRUE;; 1262}; 1263 ; 1264////////////////////////////////////////////////////////////////////////////////; 1265/// Increment bin content by 1.; 1266/// Passing an out-of-range bin leads to undefined behavior; 1267 ; 1268void TH1::AddBinContent(Int_t); 1269{; 1270 AbstractMethod(""AddBinContent"");; 1271}; 1272 ; 1273////////////////////////////////////////////////////////////////////////////////; 1274/// Increment bin content by a weight w.; 1275/// Passing an out-of-range bin leads to undefined behavior; 1276 ; 1277void TH1::AddBinContent(Int_t, Double_t); 1278{; 1279 AbstractMethod(""AddBinContent"");; 1280}; 1281 ; 1282////////////////////////////////////////////////////////////////////////////////; 1283/// Sets the flag controlling the automatic add of histograms in memory; 1284///; 1285/// By default (fAddDirectory = kTRUE), histograms are automatic",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:55964,Safety,avoid,avoid,55964,"illed from the buffer. When the histogram is filled from the; 1406/// buffer the value fBuffer[0] is set to a negative number (= - number of entries); 1407/// When calling with action == 0 the histogram is NOT refilled when fBuffer[0] is < 0; 1408/// While when calling with action = -1 the histogram is reset and ALWAYS refilled independently if; 1409/// the histogram was filled before. This is needed when drawing the histogram; 1410/// - action = 1 histogram is filled and buffer is deleted; 1411/// The buffer is automatically deleted when filling the histogram and the entries is; 1412/// larger than the buffer size; 1413 ; 1414Int_t TH1::BufferEmpty(Int_t action); 1415{; 1416 // do we need to compute the bin size?; 1417 if (!fBuffer) return 0;; 1418 Int_t nbentries = (Int_t)fBuffer[0];; 1419 ; 1420 // nbentries correspond to the number of entries of histogram; 1421 ; 1422 if (nbentries == 0) {; 1423 // if action is 1 we delete the buffer; 1424 // this will avoid infinite recursion; 1425 if (action > 0) {; 1426 delete [] fBuffer;; 1427 fBuffer = nullptr;; 1428 fBufferSize = 0;; 1429 }; 1430 return 0;; 1431 }; 1432 if (nbentries < 0 && action == 0) return 0; // case histogram has been already filled from the buffer; 1433 ; 1434 Double_t *buffer = fBuffer;; 1435 if (nbentries < 0) {; 1436 nbentries = -nbentries;; 1437 // a reset might call BufferEmpty() giving an infinite recursion; 1438 // Protect it by setting fBuffer = nullptr; 1439 fBuffer = nullptr;; 1440 //do not reset the list of functions; 1441 Reset(""ICES"");; 1442 fBuffer = buffer;; 1443 }; 1444 if (CanExtendAllAxes() || (fXaxis.GetXmax() <= fXaxis.GetXmin())) {; 1445 //find min, max of entries in buffer; 1446 Double_t xmin = TMath::Infinity();; 1447 Double_t xmax = -TMath::Infinity();; 1448 for (Int_t i=0;i<nbentries;i++) {; 1449 Double_t x = fBuffer[2*i+2];; 1450 // skip infinity or NaN values; 1451 if (!std::isfinite(x)) continue;; 1452 if (x < xmin) xmin = x;; 1453 if (x > xmax) xmax = x;; 1454 }; 1455 if ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:57763,Safety,avoid,avoid,57763,"uble_t xmin = TMath::Infinity();; 1447 Double_t xmax = -TMath::Infinity();; 1448 for (Int_t i=0;i<nbentries;i++) {; 1449 Double_t x = fBuffer[2*i+2];; 1450 // skip infinity or NaN values; 1451 if (!std::isfinite(x)) continue;; 1452 if (x < xmin) xmin = x;; 1453 if (x > xmax) xmax = x;; 1454 }; 1455 if (fXaxis.GetXmax() <= fXaxis.GetXmin()) {; 1456 Int_t rc = -1;; 1457 if (TestBit(TH1::kAutoBinPTwo)) {; 1458 if ((rc = AutoP2FindLimits(xmin, xmax)) < 0); 1459 Warning(""BufferEmpty"",; 1460 ""inconsistency found by power-of-2 autobin algorithm: fallback to standard method"");; 1461 }; 1462 if (rc < 0); 1463 THLimitsFinder::GetLimitsFinder()->FindGoodLimits(this, xmin, xmax);; 1464 } else {; 1465 fBuffer = nullptr;; 1466 Int_t keep = fBufferSize; fBufferSize = 0;; 1467 if (xmin < fXaxis.GetXmin()) ExtendAxis(xmin, &fXaxis);; 1468 if (xmax >= fXaxis.GetXmax()) ExtendAxis(xmax, &fXaxis);; 1469 fBuffer = buffer;; 1470 fBufferSize = keep;; 1471 }; 1472 }; 1473 ; 1474 // call DoFillN which will not put entries in the buffer as FillN does; 1475 // set fBuffer to zero to avoid re-emptying the buffer from functions called; 1476 // by DoFillN (e.g Sumw2); 1477 buffer = fBuffer; fBuffer = nullptr;; 1478 DoFillN(nbentries,&buffer[2],&buffer[1],2);; 1479 fBuffer = buffer;; 1480 ; 1481 // if action == 1 - delete the buffer; 1482 if (action > 0) {; 1483 delete [] fBuffer;; 1484 fBuffer = nullptr;; 1485 fBufferSize = 0;; 1486 } else {; 1487 // if number of entries is consistent with buffer - set it negative to avoid; 1488 // refilling the histogram every time BufferEmpty(0) is called; 1489 // In case it is not consistent, by setting fBuffer[0]=0 is like resetting the buffer; 1490 // (it will not be used anymore the next time BufferEmpty is called); 1491 if (nbentries == (Int_t)fEntries); 1492 fBuffer[0] = -nbentries;; 1493 else; 1494 fBuffer[0] = 0;; 1495 }; 1496 return nbentries;; 1497}; 1498 ; 1499////////////////////////////////////////////////////////////////////////////////; 1500/// ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:58203,Safety,avoid,avoid,58203," if (rc < 0); 1463 THLimitsFinder::GetLimitsFinder()->FindGoodLimits(this, xmin, xmax);; 1464 } else {; 1465 fBuffer = nullptr;; 1466 Int_t keep = fBufferSize; fBufferSize = 0;; 1467 if (xmin < fXaxis.GetXmin()) ExtendAxis(xmin, &fXaxis);; 1468 if (xmax >= fXaxis.GetXmax()) ExtendAxis(xmax, &fXaxis);; 1469 fBuffer = buffer;; 1470 fBufferSize = keep;; 1471 }; 1472 }; 1473 ; 1474 // call DoFillN which will not put entries in the buffer as FillN does; 1475 // set fBuffer to zero to avoid re-emptying the buffer from functions called; 1476 // by DoFillN (e.g Sumw2); 1477 buffer = fBuffer; fBuffer = nullptr;; 1478 DoFillN(nbentries,&buffer[2],&buffer[1],2);; 1479 fBuffer = buffer;; 1480 ; 1481 // if action == 1 - delete the buffer; 1482 if (action > 0) {; 1483 delete [] fBuffer;; 1484 fBuffer = nullptr;; 1485 fBufferSize = 0;; 1486 } else {; 1487 // if number of entries is consistent with buffer - set it negative to avoid; 1488 // refilling the histogram every time BufferEmpty(0) is called; 1489 // In case it is not consistent, by setting fBuffer[0]=0 is like resetting the buffer; 1490 // (it will not be used anymore the next time BufferEmpty is called); 1491 if (nbentries == (Int_t)fEntries); 1492 fBuffer[0] = -nbentries;; 1493 else; 1494 fBuffer[0] = 0;; 1495 }; 1496 return nbentries;; 1497}; 1498 ; 1499////////////////////////////////////////////////////////////////////////////////; 1500/// accumulate arguments in buffer. When buffer is full, empty the buffer; 1501///; 1502/// - `fBuffer[0]` = number of entries in buffer; 1503/// - `fBuffer[1]` = w of first entry; 1504/// - `fBuffer[2]` = x of first entry; 1505 ; 1506Int_t TH1::BufferFill(Double_t x, Double_t w); 1507{; 1508 if (!fBuffer) return -2;; 1509 Int_t nbentries = (Int_t)fBuffer[0];; 1510 ; 1511 ; 1512 if (nbentries < 0) {; 1513 // reset nbentries to a positive value so next time BufferEmpty() is called; 1514 // the histogram will be refilled; 1515 nbentries = -nbentries;; 1516 fBuffer[0] = nbentries;; 1517 if",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:59329,Safety,avoid,avoid,59329,"like resetting the buffer; 1490 // (it will not be used anymore the next time BufferEmpty is called); 1491 if (nbentries == (Int_t)fEntries); 1492 fBuffer[0] = -nbentries;; 1493 else; 1494 fBuffer[0] = 0;; 1495 }; 1496 return nbentries;; 1497}; 1498 ; 1499////////////////////////////////////////////////////////////////////////////////; 1500/// accumulate arguments in buffer. When buffer is full, empty the buffer; 1501///; 1502/// - `fBuffer[0]` = number of entries in buffer; 1503/// - `fBuffer[1]` = w of first entry; 1504/// - `fBuffer[2]` = x of first entry; 1505 ; 1506Int_t TH1::BufferFill(Double_t x, Double_t w); 1507{; 1508 if (!fBuffer) return -2;; 1509 Int_t nbentries = (Int_t)fBuffer[0];; 1510 ; 1511 ; 1512 if (nbentries < 0) {; 1513 // reset nbentries to a positive value so next time BufferEmpty() is called; 1514 // the histogram will be refilled; 1515 nbentries = -nbentries;; 1516 fBuffer[0] = nbentries;; 1517 if (fEntries > 0) {; 1518 // set fBuffer to zero to avoid calling BufferEmpty in Reset; 1519 Double_t *buffer = fBuffer; fBuffer=nullptr;; 1520 Reset(""ICES""); // do not reset list of functions; 1521 fBuffer = buffer;; 1522 }; 1523 }; 1524 if (2*nbentries+2 >= fBufferSize) {; 1525 BufferEmpty(1);; 1526 if (!fBuffer); 1527 // to avoid infinite recursion Fill->BufferFill->Fill; 1528 return Fill(x,w);; 1529 // this cannot happen; 1530 R__ASSERT(0);; 1531 }; 1532 fBuffer[2*nbentries+1] = w;; 1533 fBuffer[2*nbentries+2] = x;; 1534 fBuffer[0] += 1;; 1535 return -2;; 1536}; 1537 ; 1538////////////////////////////////////////////////////////////////////////////////; 1539/// Check bin limits.; 1540 ; 1541bool TH1::CheckBinLimits(const TAxis* a1, const TAxis * a2); 1542{; 1543 const TArrayD * h1Array = a1->GetXbins();; 1544 const TArrayD * h2Array = a2->GetXbins();; 1545 Int_t fN = h1Array->fN;; 1546 if ( fN != 0 ) {; 1547 if ( h2Array->fN != fN ) {; 1548 return false;; 1549 }; 1550 else {; 1551 for ( int i = 0; i < fN; ++i ) {; 1552 // for i==fN (nbin+1) a->GetB",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:59606,Safety,avoid,avoid,59606,"like resetting the buffer; 1490 // (it will not be used anymore the next time BufferEmpty is called); 1491 if (nbentries == (Int_t)fEntries); 1492 fBuffer[0] = -nbentries;; 1493 else; 1494 fBuffer[0] = 0;; 1495 }; 1496 return nbentries;; 1497}; 1498 ; 1499////////////////////////////////////////////////////////////////////////////////; 1500/// accumulate arguments in buffer. When buffer is full, empty the buffer; 1501///; 1502/// - `fBuffer[0]` = number of entries in buffer; 1503/// - `fBuffer[1]` = w of first entry; 1504/// - `fBuffer[2]` = x of first entry; 1505 ; 1506Int_t TH1::BufferFill(Double_t x, Double_t w); 1507{; 1508 if (!fBuffer) return -2;; 1509 Int_t nbentries = (Int_t)fBuffer[0];; 1510 ; 1511 ; 1512 if (nbentries < 0) {; 1513 // reset nbentries to a positive value so next time BufferEmpty() is called; 1514 // the histogram will be refilled; 1515 nbentries = -nbentries;; 1516 fBuffer[0] = nbentries;; 1517 if (fEntries > 0) {; 1518 // set fBuffer to zero to avoid calling BufferEmpty in Reset; 1519 Double_t *buffer = fBuffer; fBuffer=nullptr;; 1520 Reset(""ICES""); // do not reset list of functions; 1521 fBuffer = buffer;; 1522 }; 1523 }; 1524 if (2*nbentries+2 >= fBufferSize) {; 1525 BufferEmpty(1);; 1526 if (!fBuffer); 1527 // to avoid infinite recursion Fill->BufferFill->Fill; 1528 return Fill(x,w);; 1529 // this cannot happen; 1530 R__ASSERT(0);; 1531 }; 1532 fBuffer[2*nbentries+1] = w;; 1533 fBuffer[2*nbentries+2] = x;; 1534 fBuffer[0] += 1;; 1535 return -2;; 1536}; 1537 ; 1538////////////////////////////////////////////////////////////////////////////////; 1539/// Check bin limits.; 1540 ; 1541bool TH1::CheckBinLimits(const TAxis* a1, const TAxis * a2); 1542{; 1543 const TArrayD * h1Array = a1->GetXbins();; 1544 const TArrayD * h2Array = a2->GetXbins();; 1545 Int_t fN = h1Array->fN;; 1546 if ( fN != 0 ) {; 1547 if ( h2Array->fN != fN ) {; 1548 return false;; 1549 }; 1550 else {; 1551 for ( int i = 0; i < fN; ++i ) {; 1552 // for i==fN (nbin+1) a->GetB",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:89535,Safety,avoid,avoid,89535,"1) >= 1) {; 2182 Warning(""Chi2TestX"",""First histogram is not unweighted and option UW has been requested"");; 2183 }; 2184 }; 2185 if ( (!scaledHistogram && comparisonUU) ) {; 2186 if ( ( TMath::Abs(sumBinContent1 - effEntries1) >= 1) || (TMath::Abs(sumBinContent2 - effEntries2) >= 1) ) {; 2187 Warning(""Chi2TestX"",""Both histograms are not unweighted and option UU has been requested"");; 2188 }; 2189 }; 2190 ; 2191 ; 2192 //get number of events in histogram; 2193 if (comparisonUU && scaledHistogram) {; 2194 for (Int_t i = i_start; i <= i_end; ++i) {; 2195 for (Int_t j = j_start; j <= j_end; ++j) {; 2196 for (Int_t k = k_start; k <= k_end; ++k) {; 2197 ; 2198 Int_t bin = GetBin(i, j, k);; 2199 ; 2200 Double_t cnt1 = RetrieveBinContent(bin);; 2201 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2202 Double_t e1sq = GetBinErrorSqUnchecked(bin);; 2203 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2204 ; 2205 if (e1sq > 0.0) cnt1 = TMath::Floor(cnt1 * cnt1 / e1sq + 0.5); // avoid rounding errors; 2206 else cnt1 = 0.0;; 2207 ; 2208 if (e2sq > 0.0) cnt2 = TMath::Floor(cnt2 * cnt2 / e2sq + 0.5); // avoid rounding errors; 2209 else cnt2 = 0.0;; 2210 ; 2211 // sum contents; 2212 sum1 += cnt1;; 2213 sum2 += cnt2;; 2214 sumw1 += e1sq;; 2215 sumw2 += e2sq;; 2216 }; 2217 }; 2218 }; 2219 if (sumw1 <= 0.0 || sumw2 <= 0.0) {; 2220 Error(""Chi2TestX"", ""Cannot use option NORM when one histogram has all zero errors"");; 2221 return 0.0;; 2222 }; 2223 ; 2224 } else {; 2225 for (Int_t i = i_start; i <= i_end; ++i) {; 2226 for (Int_t j = j_start; j <= j_end; ++j) {; 2227 for (Int_t k = k_start; k <= k_end; ++k) {; 2228 ; 2229 Int_t bin = GetBin(i, j, k);; 2230 ; 2231 sum1 += RetrieveBinContent(bin);; 2232 sum2 += h2->RetrieveBinContent(bin);; 2233 ; 2234 if ( comparisonWW ) sumw1 += GetBinErrorSqUnchecked(bin);; 2235 if ( comparisonUW || comparisonWW ) sumw2 += h2->GetBinErrorSqUnchecked(bin);; 2236 }; 2237 }; 2238 }; 2239 }; 2240 //checks that the histograms are not empty; 2241 if (sum1 == 0",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:89659,Safety,avoid,avoid,89659," 2185 if ( (!scaledHistogram && comparisonUU) ) {; 2186 if ( ( TMath::Abs(sumBinContent1 - effEntries1) >= 1) || (TMath::Abs(sumBinContent2 - effEntries2) >= 1) ) {; 2187 Warning(""Chi2TestX"",""Both histograms are not unweighted and option UU has been requested"");; 2188 }; 2189 }; 2190 ; 2191 ; 2192 //get number of events in histogram; 2193 if (comparisonUU && scaledHistogram) {; 2194 for (Int_t i = i_start; i <= i_end; ++i) {; 2195 for (Int_t j = j_start; j <= j_end; ++j) {; 2196 for (Int_t k = k_start; k <= k_end; ++k) {; 2197 ; 2198 Int_t bin = GetBin(i, j, k);; 2199 ; 2200 Double_t cnt1 = RetrieveBinContent(bin);; 2201 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2202 Double_t e1sq = GetBinErrorSqUnchecked(bin);; 2203 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2204 ; 2205 if (e1sq > 0.0) cnt1 = TMath::Floor(cnt1 * cnt1 / e1sq + 0.5); // avoid rounding errors; 2206 else cnt1 = 0.0;; 2207 ; 2208 if (e2sq > 0.0) cnt2 = TMath::Floor(cnt2 * cnt2 / e2sq + 0.5); // avoid rounding errors; 2209 else cnt2 = 0.0;; 2210 ; 2211 // sum contents; 2212 sum1 += cnt1;; 2213 sum2 += cnt2;; 2214 sumw1 += e1sq;; 2215 sumw2 += e2sq;; 2216 }; 2217 }; 2218 }; 2219 if (sumw1 <= 0.0 || sumw2 <= 0.0) {; 2220 Error(""Chi2TestX"", ""Cannot use option NORM when one histogram has all zero errors"");; 2221 return 0.0;; 2222 }; 2223 ; 2224 } else {; 2225 for (Int_t i = i_start; i <= i_end; ++i) {; 2226 for (Int_t j = j_start; j <= j_end; ++j) {; 2227 for (Int_t k = k_start; k <= k_end; ++k) {; 2228 ; 2229 Int_t bin = GetBin(i, j, k);; 2230 ; 2231 sum1 += RetrieveBinContent(bin);; 2232 sum2 += h2->RetrieveBinContent(bin);; 2233 ; 2234 if ( comparisonWW ) sumw1 += GetBinErrorSqUnchecked(bin);; 2235 if ( comparisonUW || comparisonWW ) sumw2 += h2->GetBinErrorSqUnchecked(bin);; 2236 }; 2237 }; 2238 }; 2239 }; 2240 //checks that the histograms are not empty; 2241 if (sum1 == 0.0 || sum2 == 0.0) {; 2242 Error(""Chi2TestX"",""one histogram is empty"");; 2243 return 0.0;; 2244 }; 2245 ; 2246 if ( comparis",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:91542,Safety,avoid,avoid,91542,"X"",""one histogram is empty"");; 2243 return 0.0;; 2244 }; 2245 ; 2246 if ( comparisonWW && ( sumw1 <= 0.0 && sumw2 <= 0.0 ) ){; 2247 Error(""Chi2TestX"",""Hist1 and Hist2 have both all zero errors\n"");; 2248 return 0.0;; 2249 }; 2250 ; 2251 //THE TEST; 2252 Int_t m = 0, n = 0;; 2253 ; 2254 //Experiment - experiment comparison; 2255 if (comparisonUU) {; 2256 Double_t sum = sum1 + sum2;; 2257 for (Int_t i = i_start; i <= i_end; ++i) {; 2258 for (Int_t j = j_start; j <= j_end; ++j) {; 2259 for (Int_t k = k_start; k <= k_end; ++k) {; 2260 ; 2261 Int_t bin = GetBin(i, j, k);; 2262 ; 2263 Double_t cnt1 = RetrieveBinContent(bin);; 2264 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2265 ; 2266 if (scaledHistogram) {; 2267 // scale bin value to effective bin entries; 2268 Double_t e1sq = GetBinErrorSqUnchecked(bin);; 2269 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2270 ; 2271 if (e1sq > 0) cnt1 = TMath::Floor(cnt1 * cnt1 / e1sq + 0.5); // avoid rounding errors; 2272 else cnt1 = 0;; 2273 ; 2274 if (e2sq > 0) cnt2 = TMath::Floor(cnt2 * cnt2 / e2sq + 0.5); // avoid rounding errors; 2275 else cnt2 = 0;; 2276 }; 2277 ; 2278 if (Int_t(cnt1) == 0 && Int_t(cnt2) == 0) --ndf; // no data means one degree of freedom less; 2279 else {; 2280 ; 2281 Double_t cntsum = cnt1 + cnt2;; 2282 Double_t nexp1 = cntsum * sum1 / sum;; 2283 //Double_t nexp2 = binsum*sum2/sum;; 2284 ; 2285 if (res) res[i - i_start] = (cnt1 - nexp1) / TMath::Sqrt(nexp1);; 2286 ; 2287 if (cnt1 < 1) ++m;; 2288 if (cnt2 < 1) ++n;; 2289 ; 2290 //Habermann correction for residuals; 2291 Double_t correc = (1. - sum1 / sum) * (1. - cntsum / sum);; 2292 if (res) res[i - i_start] /= TMath::Sqrt(correc);; 2293 ; 2294 Double_t delta = sum2 * cnt1 - sum1 * cnt2;; 2295 chi2 += delta * delta / cntsum;; 2296 }; 2297 }; 2298 }; 2299 }; 2300 chi2 /= sum1 * sum2;; 2301 ; 2302 // flag error only when of the two histogram is zero; 2303 if (m) {; 2304 igood += 1;; 2305 Info(""Chi2TestX"",""There is a bin in h1 with less than 1 event.\n"");;",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:91662,Safety,avoid,avoid,91662,"ison; 2255 if (comparisonUU) {; 2256 Double_t sum = sum1 + sum2;; 2257 for (Int_t i = i_start; i <= i_end; ++i) {; 2258 for (Int_t j = j_start; j <= j_end; ++j) {; 2259 for (Int_t k = k_start; k <= k_end; ++k) {; 2260 ; 2261 Int_t bin = GetBin(i, j, k);; 2262 ; 2263 Double_t cnt1 = RetrieveBinContent(bin);; 2264 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2265 ; 2266 if (scaledHistogram) {; 2267 // scale bin value to effective bin entries; 2268 Double_t e1sq = GetBinErrorSqUnchecked(bin);; 2269 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2270 ; 2271 if (e1sq > 0) cnt1 = TMath::Floor(cnt1 * cnt1 / e1sq + 0.5); // avoid rounding errors; 2272 else cnt1 = 0;; 2273 ; 2274 if (e2sq > 0) cnt2 = TMath::Floor(cnt2 * cnt2 / e2sq + 0.5); // avoid rounding errors; 2275 else cnt2 = 0;; 2276 }; 2277 ; 2278 if (Int_t(cnt1) == 0 && Int_t(cnt2) == 0) --ndf; // no data means one degree of freedom less; 2279 else {; 2280 ; 2281 Double_t cntsum = cnt1 + cnt2;; 2282 Double_t nexp1 = cntsum * sum1 / sum;; 2283 //Double_t nexp2 = binsum*sum2/sum;; 2284 ; 2285 if (res) res[i - i_start] = (cnt1 - nexp1) / TMath::Sqrt(nexp1);; 2286 ; 2287 if (cnt1 < 1) ++m;; 2288 if (cnt2 < 1) ++n;; 2289 ; 2290 //Habermann correction for residuals; 2291 Double_t correc = (1. - sum1 / sum) * (1. - cntsum / sum);; 2292 if (res) res[i - i_start] /= TMath::Sqrt(correc);; 2293 ; 2294 Double_t delta = sum2 * cnt1 - sum1 * cnt2;; 2295 chi2 += delta * delta / cntsum;; 2296 }; 2297 }; 2298 }; 2299 }; 2300 chi2 /= sum1 * sum2;; 2301 ; 2302 // flag error only when of the two histogram is zero; 2303 if (m) {; 2304 igood += 1;; 2305 Info(""Chi2TestX"",""There is a bin in h1 with less than 1 event.\n"");; 2306 }; 2307 if (n) {; 2308 igood += 2;; 2309 Info(""Chi2TestX"",""There is a bin in h2 with less than 1 event.\n"");; 2310 }; 2311 ; 2312 Double_t prob = TMath::Prob(chi2,ndf);; 2313 return prob;; 2314 ; 2315 }; 2316 ; 2317 // unweighted - weighted comparison; 2318 // case of error = 0 and content not zero is treated wit",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:96860,Safety,avoid,avoid,96860,"exp1);; 2407 }; 2408 }; 2409 }; 2410 }; 2411 ; 2412 if (m) {; 2413 igood += 1;; 2414 Info(""Chi2TestX"",""There is a bin in h1 with less than 1 event.\n"");; 2415 }; 2416 if (n) {; 2417 igood += 2;; 2418 Info(""Chi2TestX"",""There is a bin in h2 with less than 10 effective events.\n"");; 2419 }; 2420 ; 2421 Double_t prob = TMath::Prob(chi2, ndf);; 2422 ; 2423 return prob;; 2424 }; 2425 ; 2426 // weighted - weighted comparison; 2427 if (comparisonWW) {; 2428 for (Int_t i = i_start; i <= i_end; ++i) {; 2429 for (Int_t j = j_start; j <= j_end; ++j) {; 2430 for (Int_t k = k_start; k <= k_end; ++k) {; 2431 ; 2432 Int_t bin = GetBin(i, j, k);; 2433 Double_t cnt1 = RetrieveBinContent(bin);; 2434 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2435 Double_t e1sq = GetBinErrorSqUnchecked(bin);; 2436 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2437 ; 2438 // case both histogram have zero bin contents; 2439 // (use square of content to avoid numerical errors); 2440 if (cnt1 * cnt1 == 0 && cnt2 * cnt2 == 0) {; 2441 --ndf; //no data means one degree of freedom less; 2442 continue;; 2443 }; 2444 ; 2445 if (e1sq == 0 && e2sq == 0) {; 2446 // cannot treat case of booth histogram have zero zero errors; 2447 Error(""Chi2TestX"",""h1 and h2 both have bin %d,%d,%d with all zero errors\n"", i,j,k);; 2448 chi2 = 0; return 0;; 2449 }; 2450 ; 2451 Double_t sigma = sum1 * sum1 * e2sq + sum2 * sum2 * e1sq;; 2452 Double_t delta = sum2 * cnt1 - sum1 * cnt2;; 2453 chi2 += delta * delta / sigma;; 2454 ; 2455 if (res) {; 2456 Double_t temp = cnt1 * sum1 * e2sq + cnt2 * sum2 * e1sq;; 2457 Double_t probb = temp / sigma;; 2458 Double_t z = 0;; 2459 if (e1sq > e2sq) {; 2460 Double_t d1 = cnt1 - sum1 * probb;; 2461 Double_t s1 = e1sq * ( 1. - e2sq * sum1 * sum1 / sigma );; 2462 z = d1 / TMath::Sqrt(s1);; 2463 }; 2464 else {; 2465 Double_t d2 = cnt2 - sum2 * probb;; 2466 Double_t s2 = e2sq * ( 1. - e1sq * sum2 * sum2 / sigma );; 2467 z = -d2 / TMath::Sqrt(s2);; 2468 }; 2469 res[i - i_start] = z;; 2470 }; 2471 ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:219196,Safety,avoid,avoid,219196,"ant to support this special case; 5447 // Int_t n = TMath::Min(axis->GetNbins(), labels->GetSize());; 5448 ; 5449 // support only cases where each bin has a labels (should be when axis is alphanumeric); 5450 Int_t n = labels->GetSize();; 5451 if (n != axis->GetNbins()) {; 5452 // check if labels are all consecutive and starts from the first bin; 5453 // in that case the current code will work fine; 5454 Int_t firstLabelBin = axis->GetNbins()+1;; 5455 Int_t lastLabelBin = -1;; 5456 for (Int_t i = 0; i < n; ++i) {; 5457 Int_t bin = labels->At(i)->GetUniqueID();; 5458 if (bin < firstLabelBin) firstLabelBin = bin;; 5459 if (bin > lastLabelBin) lastLabelBin = bin;; 5460 }; 5461 if (firstLabelBin != 1 || lastLabelBin-firstLabelBin +1 != n) {; 5462 Error(""LabelsOption"", ""%s of Histogram %s contains bins without labels. Sorting will not work correctly - return"",; 5463 axis->GetName(), GetName());; 5464 return;; 5465 }; 5466 // case where label bins are consecutive starting from first bin will work; 5467 // calling before a TH1::LabelsDeflate() will avoid this error message; 5468 Warning(""LabelsOption"", ""axis %s of Histogram %s has extra following bins without labels. Sorting will work only for first label bins"",; 5469 axis->GetName(), GetName());; 5470 }; 5471 std::vector<Int_t> a(n);; 5472 std::vector<Int_t> b(n);; 5473 ; 5474 ; 5475 Int_t i, j, k;; 5476 std::vector<Double_t> cont;; 5477 std::vector<Double_t> errors2;; 5478 THashList *labold = new THashList(labels->GetSize(), 1);; 5479 TIter nextold(labels);; 5480 TObject *obj = nullptr;; 5481 labold->AddAll(labels);; 5482 labels->Clear();; 5483 ; 5484 // delete buffer if it is there since bins will be reordered.; 5485 if (fBuffer); 5486 BufferEmpty(1);; 5487 ; 5488 if (sort > 0) {; 5489 //---sort by values of bins; 5490 if (GetDimension() == 1) {; 5491 cont.resize(n);; 5492 if (fSumw2.fN); 5493 errors2.resize(n);; 5494 for (i = 0; i < n; i++) {; 5495 cont[i] = RetrieveBinContent(i + 1);; 5496 if (!errors2.empty()); 5497 e",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:250110,Safety,avoid,avoid,250110,"t entries = fEntries;; 6314 Double_t *oldBins = new Double_t[nbins+2];; 6315 Int_t bin, i;; 6316 for (bin=0;bin<nbins+2;bin++) oldBins[bin] = RetrieveBinContent(bin);; 6317 Double_t *oldErrors = nullptr;; 6318 if (fSumw2.fN != 0) {; 6319 oldErrors = new Double_t[nbins+2];; 6320 for (bin=0;bin<nbins+2;bin++) oldErrors[bin] = GetBinError(bin);; 6321 }; 6322 // rebin will not include underflow/overflow if new axis range is larger than old axis range; 6323 if (xbins) {; 6324 if (xbins[0] < fXaxis.GetXmin() && oldBins[0] != 0 ); 6325 Warning(""Rebin"",""underflow entries will not be used when rebinning"");; 6326 if (xbins[newbins] > fXaxis.GetXmax() && oldBins[nbins+1] != 0 ); 6327 Warning(""Rebin"",""overflow entries will not be used when rebinning"");; 6328 }; 6329 ; 6330 ; 6331 // create a clone of the old histogram if newname is specified; 6332 TH1 *hnew = this;; 6333 if ((newname && strlen(newname) > 0) || xbins) {; 6334 hnew = (TH1*)Clone(newname);; 6335 }; 6336 ; 6337 //reset can extend bit to avoid an axis extension in SetBinContent; 6338 UInt_t oldExtendBitMask = hnew->SetCanExtend(kNoAxis);; 6339 ; 6340 // save original statistics; 6341 Double_t stat[kNstat];; 6342 GetStats(stat);; 6343 bool resetStat = false;; 6344 // change axis specs and rebuild bin contents array::RebinAx; 6345 if(!xbins && (newbins*ngroup != nbins)) {; 6346 xmax = fXaxis.GetBinUpEdge(newbins*ngroup);; 6347 resetStat = true; //stats must be reset because top bins will be moved to overflow bin; 6348 }; 6349 // save the TAttAxis members (reset by SetBins); 6350 Int_t nDivisions = fXaxis.GetNdivisions();; 6351 Color_t axisColor = fXaxis.GetAxisColor();; 6352 Color_t labelColor = fXaxis.GetLabelColor();; 6353 Style_t labelFont = fXaxis.GetLabelFont();; 6354 Float_t labelOffset = fXaxis.GetLabelOffset();; 6355 Float_t labelSize = fXaxis.GetLabelSize();; 6356 Float_t tickLength = fXaxis.GetTickLength();; 6357 Float_t titleOffset = fXaxis.GetTitleOffset();; 6358 Float_t titleSize = fXaxis.GetTitleSize();; ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:425304,Safety,safe,safe,425304,"umbers.Definition TAxis.cxx:1052; TAxis::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width.Definition TAxis.cxx:540; TAxis::GetBinUpEdgevirtual Double_t GetBinUpEdge(Int_t bin) constReturn up edge of bin.Definition TAxis.cxx:528; TAxis::GetFirstInt_t GetFirst() constReturn first bin on the axis i.e.Definition TAxis.cxx:458; TAxis::GetLabelsTHashList * GetLabels() constDefinition TAxis.h:121; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::GetNewROOT::NewFunc_t GetNew() constReturn the wrapper around new ThisClass().Definition TClass.cxx:7514; TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::AddAllvirtual void AddAll(const TCollection *col)Add all objects from collection col to this collection.Definition TCollection.cxx:195; TCollection::IsEmptyvirtual Bool_t IsEmpty() constDefinition TCollection.h:188; TCollection::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an collection using the Streamer facility.Definition TCollection.cxx:263; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::Appendvirtual void Append(TObject *obj, Bool_t replace=kFALSE)Append object to this directory.Definition TDirectory.cxx:199; TDirectory::Removevirtual TObject * Remove(TObject *)Remove an object from the in-memory list.Definition TDirectory.cxx:1212; TEnv::GetValuevirtual Int_t GetValue(const c",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:9835,Security,access,access,9835,"Axis"", 100, 0, 1);; 188~~~; 189 The histogram title and the axis titles can be any TLatex string, and; 190 are persisted if a histogram is written to a file.; 191 ; 192 Any title can be omitted:; 193~~~ {.cpp}; 194 TH1F* h=new TH1F(""h"", ""Histogram title;;Y Axis"", 100, 0, 1);; 195 TH1F* h=new TH1F(""h"", "";;Y Axis"", 100, 0, 1);; 196~~~; 197 The method SetTitle() has the same syntax:; 198~~~ {.cpp}; 199 h->SetTitle(""Histogram title;Another X title Axis"");; 200~~~; 201Alternatively, the title of each axis can be set directly:; 202~~~ {.cpp}; 203 h->GetXaxis()->SetTitle(""X axis title"");; 204 h->GetYaxis()->SetTitle(""Y axis title"");; 205~~~; 206For bin labels see \ref binning.; 207 ; 208\anchor binning; 209## Binning; 210 ; 211\anchor fix-var; 212### Fix or variable bin size; 213 ; 214 All histogram types support either fix or variable bin sizes.; 215 2-D histograms may have fix size bins along X and variable size bins; 216 along Y or vice-versa. The functions to fill, manipulate, draw or access; 217 histograms are identical in both cases.; 218 ; 219 Each histogram always contains 3 axis objects of type TAxis: fXaxis, fYaxis and fZaxis.; 220 To access the axis parameters, use:; 221~~~ {.cpp}; 222 TAxis *xaxis = h->GetXaxis(); etc.; 223 Double_t binCenter = xaxis->GetBinCenter(bin), etc.; 224~~~; 225 See class TAxis for a description of all the access functions.; 226 The axis range is always stored internally in double precision.; 227 ; 228\anchor convention; 229### Convention for numbering bins; 230 ; 231 For all histogram types: nbins, xlow, xup; 232~~~ {.cpp}; 233 bin = 0; underflow bin; 234 bin = 1; first bin with low-edge xlow INCLUDED; 235 bin = nbins; last bin with upper-edge xup EXCLUDED; 236 bin = nbins+1; overflow bin; 237~~~; 238 In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; 239 For example, assuming a 3-D histogram with (binx, biny, binz), the function; 240~~~ {.cpp}; 241 Int_t gbin = h->GetBin(binx, biny, binz);; 242~~~; 243 returns a glob",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:9994,Security,access,access,9994,"title can be omitted:; 193~~~ {.cpp}; 194 TH1F* h=new TH1F(""h"", ""Histogram title;;Y Axis"", 100, 0, 1);; 195 TH1F* h=new TH1F(""h"", "";;Y Axis"", 100, 0, 1);; 196~~~; 197 The method SetTitle() has the same syntax:; 198~~~ {.cpp}; 199 h->SetTitle(""Histogram title;Another X title Axis"");; 200~~~; 201Alternatively, the title of each axis can be set directly:; 202~~~ {.cpp}; 203 h->GetXaxis()->SetTitle(""X axis title"");; 204 h->GetYaxis()->SetTitle(""Y axis title"");; 205~~~; 206For bin labels see \ref binning.; 207 ; 208\anchor binning; 209## Binning; 210 ; 211\anchor fix-var; 212### Fix or variable bin size; 213 ; 214 All histogram types support either fix or variable bin sizes.; 215 2-D histograms may have fix size bins along X and variable size bins; 216 along Y or vice-versa. The functions to fill, manipulate, draw or access; 217 histograms are identical in both cases.; 218 ; 219 Each histogram always contains 3 axis objects of type TAxis: fXaxis, fYaxis and fZaxis.; 220 To access the axis parameters, use:; 221~~~ {.cpp}; 222 TAxis *xaxis = h->GetXaxis(); etc.; 223 Double_t binCenter = xaxis->GetBinCenter(bin), etc.; 224~~~; 225 See class TAxis for a description of all the access functions.; 226 The axis range is always stored internally in double precision.; 227 ; 228\anchor convention; 229### Convention for numbering bins; 230 ; 231 For all histogram types: nbins, xlow, xup; 232~~~ {.cpp}; 233 bin = 0; underflow bin; 234 bin = 1; first bin with low-edge xlow INCLUDED; 235 bin = nbins; last bin with upper-edge xup EXCLUDED; 236 bin = nbins+1; overflow bin; 237~~~; 238 In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; 239 For example, assuming a 3-D histogram with (binx, biny, binz), the function; 240~~~ {.cpp}; 241 Int_t gbin = h->GetBin(binx, biny, binz);; 242~~~; 243 returns a global/linearized gbin number. This global gbin is useful; 244 to access the bin content/error information independently of the dimension.; 245 Note that to access the informat",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:10197,Security,access,access,10197,"7 The method SetTitle() has the same syntax:; 198~~~ {.cpp}; 199 h->SetTitle(""Histogram title;Another X title Axis"");; 200~~~; 201Alternatively, the title of each axis can be set directly:; 202~~~ {.cpp}; 203 h->GetXaxis()->SetTitle(""X axis title"");; 204 h->GetYaxis()->SetTitle(""Y axis title"");; 205~~~; 206For bin labels see \ref binning.; 207 ; 208\anchor binning; 209## Binning; 210 ; 211\anchor fix-var; 212### Fix or variable bin size; 213 ; 214 All histogram types support either fix or variable bin sizes.; 215 2-D histograms may have fix size bins along X and variable size bins; 216 along Y or vice-versa. The functions to fill, manipulate, draw or access; 217 histograms are identical in both cases.; 218 ; 219 Each histogram always contains 3 axis objects of type TAxis: fXaxis, fYaxis and fZaxis.; 220 To access the axis parameters, use:; 221~~~ {.cpp}; 222 TAxis *xaxis = h->GetXaxis(); etc.; 223 Double_t binCenter = xaxis->GetBinCenter(bin), etc.; 224~~~; 225 See class TAxis for a description of all the access functions.; 226 The axis range is always stored internally in double precision.; 227 ; 228\anchor convention; 229### Convention for numbering bins; 230 ; 231 For all histogram types: nbins, xlow, xup; 232~~~ {.cpp}; 233 bin = 0; underflow bin; 234 bin = 1; first bin with low-edge xlow INCLUDED; 235 bin = nbins; last bin with upper-edge xup EXCLUDED; 236 bin = nbins+1; overflow bin; 237~~~; 238 In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; 239 For example, assuming a 3-D histogram with (binx, biny, binz), the function; 240~~~ {.cpp}; 241 Int_t gbin = h->GetBin(binx, biny, binz);; 242~~~; 243 returns a global/linearized gbin number. This global gbin is useful; 244 to access the bin content/error information independently of the dimension.; 245 Note that to access the information other than bin content and errors; 246 one should use the TAxis object directly with e.g.:; 247~~~ {.cpp}; 248 Double_t xcenter = h3->GetZaxis()->GetBinCenter(27",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:10901,Security,access,access,10901," contains 3 axis objects of type TAxis: fXaxis, fYaxis and fZaxis.; 220 To access the axis parameters, use:; 221~~~ {.cpp}; 222 TAxis *xaxis = h->GetXaxis(); etc.; 223 Double_t binCenter = xaxis->GetBinCenter(bin), etc.; 224~~~; 225 See class TAxis for a description of all the access functions.; 226 The axis range is always stored internally in double precision.; 227 ; 228\anchor convention; 229### Convention for numbering bins; 230 ; 231 For all histogram types: nbins, xlow, xup; 232~~~ {.cpp}; 233 bin = 0; underflow bin; 234 bin = 1; first bin with low-edge xlow INCLUDED; 235 bin = nbins; last bin with upper-edge xup EXCLUDED; 236 bin = nbins+1; overflow bin; 237~~~; 238 In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; 239 For example, assuming a 3-D histogram with (binx, biny, binz), the function; 240~~~ {.cpp}; 241 Int_t gbin = h->GetBin(binx, biny, binz);; 242~~~; 243 returns a global/linearized gbin number. This global gbin is useful; 244 to access the bin content/error information independently of the dimension.; 245 Note that to access the information other than bin content and errors; 246 one should use the TAxis object directly with e.g.:; 247~~~ {.cpp}; 248 Double_t xcenter = h3->GetZaxis()->GetBinCenter(27);; 249~~~; 250 returns the center along z of bin number 27 (not the global bin); 251 in the 3-D histogram h3.; 252 ; 253\anchor alpha; 254### Alphanumeric Bin Labels; 255 ; 256 By default, a histogram axis is drawn with its numeric bin labels.; 257 One can specify alphanumeric labels instead with:; 258 ; 259 - call TAxis::SetBinLabel(bin, label);; 260 This can always be done before or after filling.; 261 When the histogram is drawn, bin labels will be automatically drawn.; 262 See examples labels1.C and labels2.C; 263 - call to a Fill function with one of the arguments being a string, e.g.; 264~~~ {.cpp}; 265 hist1->Fill(somename, weight);; 266 hist2->Fill(x, somename, weight);; 267 hist2->Fill(somename, y, weight);; 268 hist2->Fill",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:10992,Security,access,access,10992,"cpp}; 222 TAxis *xaxis = h->GetXaxis(); etc.; 223 Double_t binCenter = xaxis->GetBinCenter(bin), etc.; 224~~~; 225 See class TAxis for a description of all the access functions.; 226 The axis range is always stored internally in double precision.; 227 ; 228\anchor convention; 229### Convention for numbering bins; 230 ; 231 For all histogram types: nbins, xlow, xup; 232~~~ {.cpp}; 233 bin = 0; underflow bin; 234 bin = 1; first bin with low-edge xlow INCLUDED; 235 bin = nbins; last bin with upper-edge xup EXCLUDED; 236 bin = nbins+1; overflow bin; 237~~~; 238 In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; 239 For example, assuming a 3-D histogram with (binx, biny, binz), the function; 240~~~ {.cpp}; 241 Int_t gbin = h->GetBin(binx, biny, binz);; 242~~~; 243 returns a global/linearized gbin number. This global gbin is useful; 244 to access the bin content/error information independently of the dimension.; 245 Note that to access the information other than bin content and errors; 246 one should use the TAxis object directly with e.g.:; 247~~~ {.cpp}; 248 Double_t xcenter = h3->GetZaxis()->GetBinCenter(27);; 249~~~; 250 returns the center along z of bin number 27 (not the global bin); 251 in the 3-D histogram h3.; 252 ; 253\anchor alpha; 254### Alphanumeric Bin Labels; 255 ; 256 By default, a histogram axis is drawn with its numeric bin labels.; 257 One can specify alphanumeric labels instead with:; 258 ; 259 - call TAxis::SetBinLabel(bin, label);; 260 This can always be done before or after filling.; 261 When the histogram is drawn, bin labels will be automatically drawn.; 262 See examples labels1.C and labels2.C; 263 - call to a Fill function with one of the arguments being a string, e.g.; 264~~~ {.cpp}; 265 hist1->Fill(somename, weight);; 266 hist2->Fill(x, somename, weight);; 267 hist2->Fill(somename, y, weight);; 268 hist2->Fill(somenamex, somenamey, weight);; 269~~~; 270 See examples hlabels1.C and hlabels2.C; 271 - via TTree::Draw. see for exa",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:15357,Security,access,access,15357,"rebinning.; 326 ; 327 ; 328\anchor filling-histograms; 329## Filling histograms; 330 ; 331 A histogram is typically filled with statements like:; 332~~~ {.cpp}; 333 h1->Fill(x);; 334 h1->Fill(x, w); //fill with weight; 335 h2->Fill(x, y); 336 h2->Fill(x, y, w); 337 h3->Fill(x, y, z); 338 h3->Fill(x, y, z, w); 339~~~; 340 or via one of the Fill functions accepting names described above.; 341 The Fill functions compute the bin number corresponding to the given; 342 x, y or z argument and increment this bin by the given weight.; 343 The Fill functions return the bin number for 1-D histograms or global; 344 bin number for 2-D and 3-D histograms.; 345 If TH1::Sumw2 has been called before filling, the sum of squares of; 346 weights is also stored.; 347 One can also increment directly a bin number via TH1::AddBinContent; 348 or replace the existing content via TH1::SetBinContent. Passing an; 349 out-of-range bin to TH1::AddBinContent leads to undefined behavior.; 350 To access the bin content of a given bin, do:; 351~~~ {.cpp}; 352 Double_t binContent = h->GetBinContent(bin);; 353~~~; 354 ; 355 By default, the bin number is computed using the current axis ranges.; 356 If the automatic binning option has been set via; 357~~~ {.cpp}; 358 h->SetCanExtend(TH1::kAllAxes);; 359~~~; 360 then, the Fill Function will automatically extend the axis range to; 361 accomodate the new value specified in the Fill argument. The method; 362 used is to double the bin size until the new value fits in the range,; 363 merging bins two by two. This automatic binning options is extensively; 364 used by the TTree::Draw function when histogramming Tree variables; 365 with an unknown range.; 366 This automatic binning option is supported for 1-D, 2-D and 3-D histograms.; 367 ; 368 During filling, some statistics parameters are incremented to compute; 369 the mean value and Root Mean Square with the maximum precision.; 370 ; 371 In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S; 372 a ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:106733,Security,hash,hash,106733,";; 2650 sum += RetrieveBinContent(bin);; 2651 hintegrated->AddBinContent(bin, sum);; 2652 if (fSumw2.fN) {; 2653 esum += GetBinErrorSqUnchecked(bin);; 2654 hintegrated->fSumw2.fArray[bin] = esum;; 2655 }; 2656 }; 2657 }; 2658 }; 2659 }; 2660 return hintegrated;; 2661}; 2662 ; 2663////////////////////////////////////////////////////////////////////////////////; 2664/// Copy this histogram structure to newth1.; 2665///; 2666/// Note that this function does not copy the list of associated functions.; 2667/// Use TObject::Clone to make a full copy of a histogram.; 2668///; 2669/// Note also that the histogram it will be created in gDirectory (if AddDirectoryStatus()=true); 2670/// or will not be added to any directory if AddDirectoryStatus()=false; 2671/// independently of the current directory stored in the original histogram; 2672 ; 2673void TH1::Copy(TObject &obj) const; 2674{; 2675 if (((TH1&)obj).fDirectory) {; 2676 // We are likely to change the hash value of this object; 2677 // with TNamed::Copy, to keep things correct, we need to; 2678 // clean up its existing entries.; 2679 ((TH1&)obj).fDirectory->Remove(&obj);; 2680 ((TH1&)obj).fDirectory = nullptr;; 2681 }; 2682 TNamed::Copy(obj);; 2683 ((TH1&)obj).fDimension = fDimension;; 2684 ((TH1&)obj).fNormFactor= fNormFactor;; 2685 ((TH1&)obj).fNcells = fNcells;; 2686 ((TH1&)obj).fBarOffset = fBarOffset;; 2687 ((TH1&)obj).fBarWidth = fBarWidth;; 2688 ((TH1&)obj).fOption = fOption;; 2689 ((TH1&)obj).fBinStatErrOpt = fBinStatErrOpt;; 2690 ((TH1&)obj).fBufferSize= fBufferSize;; 2691 // copy the Buffer; 2692 // delete first a previously existing buffer; 2693 if (((TH1&)obj).fBuffer != nullptr) {; 2694 delete [] ((TH1&)obj).fBuffer;; 2695 ((TH1&)obj).fBuffer = nullptr;; 2696 }; 2697 if (fBuffer) {; 2698 Double_t *buf = new Double_t[fBufferSize];; 2699 for (Int_t i=0;i<fBufferSize;i++) buf[i] = fBuffer[i];; 2700 // obj.fBuffer has been deleted before; 2701 ((TH1&)obj).fBuffer = buf;; 2702 }; 2703 ; 2704 // copy bin contents ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:166262,Security,access,access,166262,"urns a TFitResultPtr which can hold a pointer to a TFitResult object.; 4055/// By default the TFitResultPtr contains only the status of the fit which is return by an; 4056/// automatic conversion of the TFitResultPtr to an integer. One can write in this case directly:; 4057///; 4058/// ~~~ {.cpp}; 4059/// Int_t fitStatus = h->Fit(myFunc);; 4060/// ~~~; 4061///; 4062/// If the option ""S"" is instead used, TFitResultPtr behaves as a smart; 4063/// pointer to the TFitResult object. This is useful for retrieving the full result information from the fit, such as the covariance matrix,; 4064/// as shown in this example code:; 4065///; 4066/// ~~~ {.cpp}; 4067/// TFitResultPtr r = h->Fit(myFunc,""S"");; 4068/// TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; 4069/// Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; 4070/// Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; 4071/// Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; 4072/// r->Print(""V""); // print full information of fit including covariance matrix; 4073/// r->Write(); // store the result in a file; 4074/// ~~~; 4075///; 4076/// The fit parameters, error and chi-square (but not covariance matrix) can be retrieved also; 4077/// directly from the fitted function that is passed to this call.; 4078/// Given a pointer to an associated fitted function `myfunc`, one can retrieve the function/fit; 4079/// parameters with calls such as:; 4080///; 4081/// ~~~ {.cpp}; 4082/// Double_t chi2 = myfunc->GetChisquare();; 4083/// Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; 4084/// Double_t err0 = myfunc->GetParError(0); //error on first parameter; 4085/// ~~~; 4086///; 4087/// ##### Associated functions; 4088///; 4089/// One or more object ( can be added to the list; 4090/// of functions (fFunctions) associated to each histogram.; 4091/// When TH1::Fit is invoked, the fitted function is added to the histogram list of fu",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:201209,Security,access,access,201209,"ms are represented with a one dimensional; 4937/// structure.; 4938/// This has the advantage that all existing functions, such as; 4939/// GetBinContent, GetBinError, GetBinFunction work for all dimensions.; 4940///; 4941/// In case of a TH1x, returns binx directly.; 4942/// see TH1::GetBinXYZ for the inverse transformation.; 4943///; 4944/// Convention for numbering bins; 4945///; 4946/// For all histogram types: nbins, xlow, xup; 4947///; 4948/// - bin = 0; underflow bin; 4949/// - bin = 1; first bin with low-edge xlow INCLUDED; 4950/// - bin = nbins; last bin with upper-edge xup EXCLUDED; 4951/// - bin = nbins+1; overflow bin; 4952///; 4953/// In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; 4954/// For example, assuming a 3-D histogram with binx,biny,binz, the function; 4955///; 4956/// ~~~ {.cpp}; 4957/// Int_t bin = h->GetBin(binx,biny,binz);; 4958/// ~~~; 4959///; 4960/// returns a global/linearized bin number. This global bin is useful; 4961/// to access the bin information independently of the dimension.; 4962 ; 4963Int_t TH1::GetBin(Int_t binx, Int_t, Int_t) const; 4964{; 4965 Int_t ofx = fXaxis.GetNbins() + 1; // overflow bin; 4966 if (binx < 0) binx = 0;; 4967 if (binx > ofx) binx = ofx;; 4968 ; 4969 return binx;; 4970}; 4971 ; 4972////////////////////////////////////////////////////////////////////////////////; 4973/// Return binx, biny, binz corresponding to the global bin number globalbin; 4974/// see TH1::GetBin function above; 4975 ; 4976void TH1::GetBinXYZ(Int_t binglobal, Int_t &binx, Int_t &biny, Int_t &binz) const; 4977{; 4978 Int_t nx = fXaxis.GetNbins()+2;; 4979 Int_t ny = fYaxis.GetNbins()+2;; 4980 ; 4981 if (GetDimension() == 1) {; 4982 binx = binglobal%nx;; 4983 biny = 0;; 4984 binz = 0;; 4985 return;; 4986 }; 4987 if (GetDimension() == 2) {; 4988 binx = binglobal%nx;; 4989 biny = ((binglobal-binx)/nx)%ny;; 4990 binz = 0;; 4991 return;; 4992 }; 4993 if (GetDimension() == 3) {; 4994 binx = binglobal%nx;; 4995 biny = ((bin",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:204879,Security,access,access,204879,";; 5034 if (r1 > fIntegral[ibin]) x +=; 5035 GetBinWidth(ibin+1)*(r1-fIntegral[ibin])/(fIntegral[ibin+1] - fIntegral[ibin]);; 5036 return x;; 5037}; 5038 ; 5039////////////////////////////////////////////////////////////////////////////////; 5040/// Return content of bin number bin.; 5041///; 5042/// Implemented in TH1C,S,F,D; 5043///; 5044/// Convention for numbering bins; 5045///; 5046/// For all histogram types: nbins, xlow, xup; 5047///; 5048/// - bin = 0; underflow bin; 5049/// - bin = 1; first bin with low-edge xlow INCLUDED; 5050/// - bin = nbins; last bin with upper-edge xup EXCLUDED; 5051/// - bin = nbins+1; overflow bin; 5052///; 5053/// In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; 5054/// For example, assuming a 3-D histogram with binx,biny,binz, the function; 5055///; 5056/// ~~~ {.cpp}; 5057/// Int_t bin = h->GetBin(binx,biny,binz);; 5058/// ~~~; 5059///; 5060/// returns a global/linearized bin number. This global bin is useful; 5061/// to access the bin information independently of the dimension.; 5062 ; 5063Double_t TH1::GetBinContent(Int_t bin) const; 5064{; 5065 if (fBuffer) const_cast<TH1*>(this)->BufferEmpty();; 5066 if (bin < 0) bin = 0;; 5067 if (bin >= fNcells) bin = fNcells-1;; 5068 ; 5069 return RetrieveBinContent(bin);; 5070}; 5071 ; 5072////////////////////////////////////////////////////////////////////////////////; 5073/// Compute first binx in the range [firstx,lastx] for which; 5074/// diff = abs(bin_content-c) <= maxdiff; 5075///; 5076/// In case several bins in the specified range with diff=0 are found; 5077/// the first bin found is returned in binx.; 5078/// In case several bins in the specified range satisfy diff <=maxdiff; 5079/// the bin with the smallest difference is returned in binx.; 5080/// In all cases the function returns the smallest difference.; 5081///; 5082/// NOTE1: if firstx <= 0, firstx is set to bin 1; 5083/// if (lastx < firstx then firstx is set to the number of bins; 5084/// ie if firstx=0",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:320056,Security,access,access,320056,"uch slower.; 8132///; 8133/// The returned function value is the probability of test; 8134/// (much less than one means NOT compatible); 8135///; 8136/// Code adapted by Rene Brun from original HBOOK routine HDIFF; 8137///; 8138/// NOTE1; 8139/// A good description of the Kolmogorov test can be seen at:; 8140/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; 8141///; 8142/// NOTE2; 8143/// see also alternative function TH1::Chi2Test; 8144/// The Kolmogorov test is assumed to give better results than Chi2Test; 8145/// in case of histograms with low statistics.; 8146///; 8147/// NOTE3 (Jan Conrad, Fred James); 8148/// ""The returned value PROB is calculated such that it will be; 8149/// uniformly distributed between zero and one for compatible histograms,; 8150/// provided the data are not binned (or the number of bins is very large; 8151/// compared with the number of events). Users who have access to unbinned; 8152/// data and wish exact confidence levels should therefore not put their data; 8153/// into histograms, but should call directly TMath::KolmogorovTest. On; 8154/// the other hand, since TH1 is a convenient way of collecting data and; 8155/// saving space, this function has been provided. However, the values of; 8156/// PROB for binned data will be shifted slightly higher than expected,; 8157/// depending on the effects of the binning. For example, when comparing two; 8158/// uniform distributions of 500 events in 100 bins, the values of PROB,; 8159/// instead of being exactly uniformly distributed between zero and one, have; 8160/// a mean value of about 0.56. We can apply a useful; 8161/// rule: As long as the bin width is small compared with any significant; 8162/// physical effect (for example the experimental resolution) then the binning; 8163/// cannot have an important effect. Therefore, we believe that for all; 8164/// practical purposes, the probability value PROB is calculated correctly; 8165/// provided the user is aware that:; 81",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:349998,Security,hash,hashlist,349998,"Directory == dir) return;; 8942 if (fDirectory) fDirectory->Remove(this);; 8943 fDirectory = dir;; 8944 if (fDirectory) {; 8945 fFunctions->UseRWLock();; 8946 fDirectory->Append(this);; 8947 }; 8948}; 8949 ; 8950////////////////////////////////////////////////////////////////////////////////; 8951/// Replace bin errors by values in array error.; 8952 ; 8953void TH1::SetError(const Double_t *error); 8954{; 8955 for (Int_t i = 0; i < fNcells; ++i) SetBinError(i, error[i]);; 8956}; 8957 ; 8958////////////////////////////////////////////////////////////////////////////////; 8959/// Change the name of this histogram; 8960///; 8961 ; 8962void TH1::SetName(const char *name); 8963{; 8964 // Histograms are named objects in a THashList.; 8965 // We must update the hashlist if we change the name; 8966 // We protect this operation; 8967 R__LOCKGUARD(gROOTMutex);; 8968 if (fDirectory) fDirectory->Remove(this);; 8969 fName = name;; 8970 if (fDirectory) fDirectory->Append(this);; 8971}; 8972 ; 8973////////////////////////////////////////////////////////////////////////////////; 8974/// Change the name and title of this histogram; 8975 ; 8976void TH1::SetNameTitle(const char *name, const char *title); 8977{; 8978 // Histograms are named objects in a THashList.; 8979 // We must update the hashlist if we change the name; 8980 SetName(name);; 8981 SetTitle(title);; 8982}; 8983 ; 8984////////////////////////////////////////////////////////////////////////////////; 8985/// Set statistics option on/off.; 8986///; 8987/// By default, the statistics box is drawn.; 8988/// The paint options can be selected via gStyle->SetOptStat.; 8989/// This function sets/resets the kNoStats bit in the histogram object.; 8990/// It has priority over the Style option.; 8991 ; 8992void TH1::SetStats(Bool_t stats); 8993{; 8994 ResetBit(kNoStats);; 8995 if (!stats) {; 8996 SetBit(kNoStats);; 8997 //remove the ""stats"" object from the list of functions; 8998 if (fFunctions) {; 8999 TObject *obj = fFunctions->Fi",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:350526,Security,hash,hashlist,350526,"ouble_t *error); 8954{; 8955 for (Int_t i = 0; i < fNcells; ++i) SetBinError(i, error[i]);; 8956}; 8957 ; 8958////////////////////////////////////////////////////////////////////////////////; 8959/// Change the name of this histogram; 8960///; 8961 ; 8962void TH1::SetName(const char *name); 8963{; 8964 // Histograms are named objects in a THashList.; 8965 // We must update the hashlist if we change the name; 8966 // We protect this operation; 8967 R__LOCKGUARD(gROOTMutex);; 8968 if (fDirectory) fDirectory->Remove(this);; 8969 fName = name;; 8970 if (fDirectory) fDirectory->Append(this);; 8971}; 8972 ; 8973////////////////////////////////////////////////////////////////////////////////; 8974/// Change the name and title of this histogram; 8975 ; 8976void TH1::SetNameTitle(const char *name, const char *title); 8977{; 8978 // Histograms are named objects in a THashList.; 8979 // We must update the hashlist if we change the name; 8980 SetName(name);; 8981 SetTitle(title);; 8982}; 8983 ; 8984////////////////////////////////////////////////////////////////////////////////; 8985/// Set statistics option on/off.; 8986///; 8987/// By default, the statistics box is drawn.; 8988/// The paint options can be selected via gStyle->SetOptStat.; 8989/// This function sets/resets the kNoStats bit in the histogram object.; 8990/// It has priority over the Style option.; 8991 ; 8992void TH1::SetStats(Bool_t stats); 8993{; 8994 ResetBit(kNoStats);; 8995 if (!stats) {; 8996 SetBit(kNoStats);; 8997 //remove the ""stats"" object from the list of functions; 8998 if (fFunctions) {; 8999 TObject *obj = fFunctions->FindObject(""stats"");; 9000 if (obj) {; 9001 fFunctions->Remove(obj);; 9002 delete obj;; 9003 }; 9004 }; 9005 }; 9006}; 9007 ; 9008////////////////////////////////////////////////////////////////////////////////; 9009/// Create structure to store sum of squares of weights.; 9010///; 9011/// if histogram is already filled, the sum of squares of weights; 9012/// is filled with the existi",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:425279,Security,access,access,425279,"umbers.Definition TAxis.cxx:1052; TAxis::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width.Definition TAxis.cxx:540; TAxis::GetBinUpEdgevirtual Double_t GetBinUpEdge(Int_t bin) constReturn up edge of bin.Definition TAxis.cxx:528; TAxis::GetFirstInt_t GetFirst() constReturn first bin on the axis i.e.Definition TAxis.cxx:458; TAxis::GetLabelsTHashList * GetLabels() constDefinition TAxis.h:121; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::GetNewROOT::NewFunc_t GetNew() constReturn the wrapper around new ThisClass().Definition TClass.cxx:7514; TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::AddAllvirtual void AddAll(const TCollection *col)Add all objects from collection col to this collection.Definition TCollection.cxx:195; TCollection::IsEmptyvirtual Bool_t IsEmpty() constDefinition TCollection.h:188; TCollection::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an collection using the Streamer facility.Definition TCollection.cxx:263; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::Appendvirtual void Append(TObject *obj, Bool_t replace=kFALSE)Append object to this directory.Definition TDirectory.cxx:199; TDirectory::Removevirtual TObject * Remove(TObject *)Remove an object from the in-memory list.Definition TDirectory.cxx:1212; TEnv::GetValuevirtual Int_t GetValue(const c",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:462213,Security,hash,hash,462213,"t the center of bins of this histogram.Definition TH1.cxx:3192; TH1::SetBarWidthvirtual void SetBarWidth(Float_t width=0.5)Set the width of bars as fraction of the bin width for drawing mode ""B"".Definition TH1.h:365; TH1::BufferEmptyvirtual Int_t BufferEmpty(Int_t action=0)Fill histogram with all entries in the buffer.Definition TH1.cxx:1414; TH1::SetStatsvirtual void SetStats(Bool_t stats=kTRUE)Set statistics option on/off.Definition TH1.cxx:8990; TH1::GetKurtosisvirtual Double_t GetKurtosis(Int_t axis=1) constDefinition TH1.cxx:7744; TH2D2-D histogram with a double per channel (see TH1 documentation)Definition TH2.h:357; THLimitsFinder::GetLimitsFinderstatic THLimitsFinder * GetLimitsFinder()Return pointer to the current finder.Definition THLimitsFinder.cxx:153; THLimitsFinder::FindGoodLimitsvirtual Int_t FindGoodLimits(TH1 *h, Double_t xmin, Double_t xmax)Compute the best axis limits for the X axis.Definition THLimitsFinder.cxx:53; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashList::Clearvoid Clear(Option_t *option="""") overrideRemove all objects from the list.Definition THashList.cxx:189; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TList::Streamervoid Streamer(TBuffer &) overrideStream all objects in the collection to or from the I/O buffer.Definition TList.cxx:1189; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TList.cxx:762; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition TList.cxx:820; TList::FirstTObject * First() const overrideReturn the first object",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:24107,Testability,test,test,24107,"38 ; 539 The following statements create a ROOT file and store a histogram; 540 on the file. Because TH1 derives from TNamed, the key identifier on; 541 the file is the histogram name:; 542~~~ {.cpp}; 543 TFile f(""histos.root"", ""new"");; 544 TH1F h1(""hgaus"", ""histo from a gaussian"", 100, -3, 3);; 545 h1.FillRandom(""gaus"", 10000);; 546 h1->Write();; 547~~~; 548 To read this histogram in another Root session, do:; 549~~~ {.cpp}; 550 TFile f(""histos.root"");; 551 TH1F *h = (TH1F*)f.Get(""hgaus"");; 552~~~; 553 One can save all histograms in memory to the file by:; 554~~~ {.cpp}; 555 file->Write();; 556~~~; 557 ; 558 ; 559\anchor misc; 560## Miscellaneous operations; 561 ; 562~~~ {.cpp}; 563 TH1::KolmogorovTest(): statistical test of compatibility in shape; 564 between two histograms; 565 TH1::Smooth() smooths the bin contents of a 1-d histogram; 566 TH1::Integral() returns the integral of bin contents in a given bin range; 567 TH1::GetMean(int axis) returns the mean value along axis; 568 TH1::GetStdDev(int axis) returns the sigma distribution along axis; 569 TH1::GetEntries() returns the number of entries; 570 TH1::Reset() resets the bin contents and errors of a histogram; 571~~~; 572 IMPORTANT NOTE: The returned values for GetMean and GetStdDev depend on how the; 573 histogram statistics are calculated. By default, if no range has been set, the; 574 returned values are the (unbinned) ones calculated at fill time. If a range has been; 575 set, however, the values are calculated using the bins in range; THIS IS TRUE EVEN; 576 IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset the range.; 577 To ensure that the returned values are always those of the binned data stored in the; 578 histogram, call TH1::ResetStats. See TH1::GetStats.; 579*/; 580 ; 581TF1 *gF1=nullptr; //left for back compatibility (use TVirtualFitter::GetUserFunc instead); 582 ; 583Int_t TH1::fgBufferSize = 1000;; 584Bool_t TH1::fgAddDirectory = kTRUE;; 585Bool_t TH1::fgDefaultSumw2 = kFALSE;; 5",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:27427,Testability,log,logic,27427,"13/// Histogram default constructor.; 614 ; 615TH1::TH1(); 616{; 617 fDirectory = nullptr;; 618 fFunctions = new TList;; 619 fNcells = 0;; 620 fIntegral = nullptr;; 621 fPainter = nullptr;; 622 fEntries = 0;; 623 fNormFactor = 0;; 624 fTsumw = fTsumw2=fTsumwx=fTsumwx2=0;; 625 fMaximum = -1111;; 626 fMinimum = -1111;; 627 fBufferSize = 0;; 628 fBuffer = nullptr;; 629 fBinStatErrOpt = kNormal;; 630 fStatOverflows = EStatOverflows::kNeutral;; 631 fXaxis.SetName(""xaxis"");; 632 fYaxis.SetName(""yaxis"");; 633 fZaxis.SetName(""zaxis"");; 634 fXaxis.SetParent(this);; 635 fYaxis.SetParent(this);; 636 fZaxis.SetParent(this);; 637 UseCurrentStyle();; 638}; 639 ; 640////////////////////////////////////////////////////////////////////////////////; 641/// Histogram default destructor.; 642 ; 643TH1::~TH1(); 644{; 645 if (ROOT::Detail::HasBeenDeleted(this)) {; 646 return;; 647 }; 648 delete[] fIntegral;; 649 fIntegral = nullptr;; 650 delete[] fBuffer;; 651 fBuffer = nullptr;; 652 if (fFunctions) {; 653 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 654 ; 655 fFunctions->SetBit(kInvalidObject);; 656 TObject* obj = nullptr;; 657 //special logic to support the case where the same object is; 658 //added multiple times in fFunctions.; 659 //This case happens when the same object is added with different; 660 //drawing modes; 661 //In the loop below we must be careful with objects (eg TCutG) that may; 662 // have been added to the list of functions of several histograms; 663 //and may have been already deleted.; 664 while ((obj = fFunctions->First())) {; 665 while(fFunctions->Remove(obj)) { }; 666 if (ROOT::Detail::HasBeenDeleted(obj)) {; 667 break;; 668 }; 669 delete obj;; 670 obj = nullptr;; 671 }; 672 delete fFunctions;; 673 fFunctions = nullptr;; 674 }; 675 if (fDirectory) {; 676 fDirectory->Remove(this);; 677 fDirectory = nullptr;; 678 }; 679 delete fPainter;; 680 fPainter = nullptr;; 681}; 682 ; 683////////////////////////////////////////////////////////////////////////////////; 684/// Constr",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:66382,Testability,test,test,66382,";; 1683 }; 1684 Int_t dim = h1->GetDimension();; 1685 ; 1686 // returns kTRUE if number of bins and bin limits are identical; 1687 Int_t nbinsx = h1->GetNbinsX();; 1688 Int_t nbinsy = h1->GetNbinsY();; 1689 Int_t nbinsz = h1->GetNbinsZ();; 1690 ; 1691 // Check whether the histograms have the same number of bins.; 1692 if (nbinsx != h2->GetNbinsX() ||; 1693 (dim > 1 && nbinsy != h2->GetNbinsY()) ||; 1694 (dim > 2 && nbinsz != h2->GetNbinsZ()) ) {; 1695 return kDifferentNumberOfBins;; 1696 }; 1697 ; 1698 bool ret = true;; 1699 ; 1700 // check axis limits; 1701 ret &= CheckAxisLimits(h1->GetXaxis(), h2->GetXaxis());; 1702 if (dim > 1) ret &= CheckAxisLimits(h1->GetYaxis(), h2->GetYaxis());; 1703 if (dim > 2) ret &= CheckAxisLimits(h1->GetZaxis(), h2->GetZaxis());; 1704 if (!ret) return kDifferentAxisLimits;; 1705 ; 1706 // check bin limits; 1707 ret &= CheckBinLimits(h1->GetXaxis(), h2->GetXaxis());; 1708 if (dim > 1) ret &= CheckBinLimits(h1->GetYaxis(), h2->GetYaxis());; 1709 if (dim > 2) ret &= CheckBinLimits(h1->GetZaxis(), h2->GetZaxis());; 1710 if (!ret) return kDifferentBinLimits;; 1711 ; 1712 // check labels if histograms are both not empty; 1713 if ( !h1->IsEmpty() && !h2->IsEmpty() ) {; 1714 ret &= CheckBinLabels(h1->GetXaxis(), h2->GetXaxis());; 1715 if (dim > 1) ret &= CheckBinLabels(h1->GetYaxis(), h2->GetYaxis());; 1716 if (dim > 2) ret &= CheckBinLabels(h1->GetZaxis(), h2->GetZaxis());; 1717 if (!ret) return kDifferentLabels;; 1718 }; 1719 ; 1720 return kFullyConsistent;; 1721}; 1722 ; 1723////////////////////////////////////////////////////////////////////////////////; 1724/// \f$ \chi^{2} \f$ test for comparing weighted and unweighted histograms.; 1725///; 1726/// Compares the histograms' adjusted (normalized) residuals.; 1727/// Function: Returns p-value. Other return values are specified by the 3rd parameter; 1728///; 1729/// \param[in] h2 the second histogram; 1730/// \param[in] option; 1731/// - ""UU"" = experiment experiment comparison (unweighted-un",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:67545,Testability,test,test,67545,"//////////////////////////////////////////////////////////////////////////; 1724/// \f$ \chi^{2} \f$ test for comparing weighted and unweighted histograms.; 1725///; 1726/// Compares the histograms' adjusted (normalized) residuals.; 1727/// Function: Returns p-value. Other return values are specified by the 3rd parameter; 1728///; 1729/// \param[in] h2 the second histogram; 1730/// \param[in] option; 1731/// - ""UU"" = experiment experiment comparison (unweighted-unweighted); 1732/// - ""UW"" = experiment MC comparison (unweighted-weighted). Note that; 1733/// the first histogram should be unweighted; 1734/// - ""WW"" = MC MC comparison (weighted-weighted); 1735/// - ""NORM"" = to be used when one or both of the histograms is scaled; 1736/// but the histogram originally was unweighted; 1737/// - by default underflows and overflows are not included:; 1738/// * ""OF"" = overflows included; 1739/// * ""UF"" = underflows included; 1740/// - ""P"" = print chi2, ndf, p_value, igood; 1741/// - ""CHI2"" = returns chi2 instead of p-value; 1742/// - ""CHI2/NDF"" = returns \f$ \chi^{2} \f$/ndf; 1743/// \param[in] res not empty - computes normalized residuals and returns them in this array; 1744///; 1745/// The current implementation is based on the papers \f$ \chi^{2} \f$ test for comparison; 1746/// of weighted and unweighted histograms"" in Proceedings of PHYSTAT05 and; 1747/// ""Comparison weighted and unweighted histograms"", arXiv:physics/0605123; 1748/// by N.Gagunashvili. This function has been implemented by Daniel Haertl in August 2006.; 1749///; 1750/// #### Introduction:; 1751///; 1752/// A frequently used technique in data analysis is the comparison of; 1753/// histograms. First suggested by Pearson [1] the \f$ \chi^{2} \f$ test of; 1754/// homogeneity is used widely for comparing usual (unweighted) histograms.; 1755/// This paper describes the implementation modified \f$ \chi^{2} \f$ tests; 1756/// for comparison of weighted and unweighted histograms and two weighted; 1757/// histogram",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:68015,Testability,test,test,68015," histogram originally was unweighted; 1737/// - by default underflows and overflows are not included:; 1738/// * ""OF"" = overflows included; 1739/// * ""UF"" = underflows included; 1740/// - ""P"" = print chi2, ndf, p_value, igood; 1741/// - ""CHI2"" = returns chi2 instead of p-value; 1742/// - ""CHI2/NDF"" = returns \f$ \chi^{2} \f$/ndf; 1743/// \param[in] res not empty - computes normalized residuals and returns them in this array; 1744///; 1745/// The current implementation is based on the papers \f$ \chi^{2} \f$ test for comparison; 1746/// of weighted and unweighted histograms"" in Proceedings of PHYSTAT05 and; 1747/// ""Comparison weighted and unweighted histograms"", arXiv:physics/0605123; 1748/// by N.Gagunashvili. This function has been implemented by Daniel Haertl in August 2006.; 1749///; 1750/// #### Introduction:; 1751///; 1752/// A frequently used technique in data analysis is the comparison of; 1753/// histograms. First suggested by Pearson [1] the \f$ \chi^{2} \f$ test of; 1754/// homogeneity is used widely for comparing usual (unweighted) histograms.; 1755/// This paper describes the implementation modified \f$ \chi^{2} \f$ tests; 1756/// for comparison of weighted and unweighted histograms and two weighted; 1757/// histograms [2] as well as usual Pearson's \f$ \chi^{2} \f$ test for; 1758/// comparison two usual (unweighted) histograms.; 1759///; 1760/// #### Overview:; 1761///; 1762/// Comparison of two histograms expect hypotheses that two histograms; 1763/// represent identical distributions. To make a decision p-value should; 1764/// be calculated. The hypotheses of identity is rejected if the p-value is; 1765/// lower then some significance level. Traditionally significance levels; 1766/// 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; 1767/// analysis of the residuals which is often helpful in identifying the; 1768/// bins of histograms responsible for a significant overall \f$ \chi^{2} \f$ value.; 1769/// Residuals are the differ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:68179,Testability,test,tests,68179,"e, igood; 1741/// - ""CHI2"" = returns chi2 instead of p-value; 1742/// - ""CHI2/NDF"" = returns \f$ \chi^{2} \f$/ndf; 1743/// \param[in] res not empty - computes normalized residuals and returns them in this array; 1744///; 1745/// The current implementation is based on the papers \f$ \chi^{2} \f$ test for comparison; 1746/// of weighted and unweighted histograms"" in Proceedings of PHYSTAT05 and; 1747/// ""Comparison weighted and unweighted histograms"", arXiv:physics/0605123; 1748/// by N.Gagunashvili. This function has been implemented by Daniel Haertl in August 2006.; 1749///; 1750/// #### Introduction:; 1751///; 1752/// A frequently used technique in data analysis is the comparison of; 1753/// histograms. First suggested by Pearson [1] the \f$ \chi^{2} \f$ test of; 1754/// homogeneity is used widely for comparing usual (unweighted) histograms.; 1755/// This paper describes the implementation modified \f$ \chi^{2} \f$ tests; 1756/// for comparison of weighted and unweighted histograms and two weighted; 1757/// histograms [2] as well as usual Pearson's \f$ \chi^{2} \f$ test for; 1758/// comparison two usual (unweighted) histograms.; 1759///; 1760/// #### Overview:; 1761///; 1762/// Comparison of two histograms expect hypotheses that two histograms; 1763/// represent identical distributions. To make a decision p-value should; 1764/// be calculated. The hypotheses of identity is rejected if the p-value is; 1765/// lower then some significance level. Traditionally significance levels; 1766/// 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; 1767/// analysis of the residuals which is often helpful in identifying the; 1768/// bins of histograms responsible for a significant overall \f$ \chi^{2} \f$ value.; 1769/// Residuals are the difference between bin contents and expected bin; 1770/// contents. Most convenient for analysis are the normalized residuals. If; 1771/// hypotheses of identity are valid then normalized residuals are; 1772/// approximate",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:68332,Testability,test,test,68332,"e, igood; 1741/// - ""CHI2"" = returns chi2 instead of p-value; 1742/// - ""CHI2/NDF"" = returns \f$ \chi^{2} \f$/ndf; 1743/// \param[in] res not empty - computes normalized residuals and returns them in this array; 1744///; 1745/// The current implementation is based on the papers \f$ \chi^{2} \f$ test for comparison; 1746/// of weighted and unweighted histograms"" in Proceedings of PHYSTAT05 and; 1747/// ""Comparison weighted and unweighted histograms"", arXiv:physics/0605123; 1748/// by N.Gagunashvili. This function has been implemented by Daniel Haertl in August 2006.; 1749///; 1750/// #### Introduction:; 1751///; 1752/// A frequently used technique in data analysis is the comparison of; 1753/// histograms. First suggested by Pearson [1] the \f$ \chi^{2} \f$ test of; 1754/// homogeneity is used widely for comparing usual (unweighted) histograms.; 1755/// This paper describes the implementation modified \f$ \chi^{2} \f$ tests; 1756/// for comparison of weighted and unweighted histograms and two weighted; 1757/// histograms [2] as well as usual Pearson's \f$ \chi^{2} \f$ test for; 1758/// comparison two usual (unweighted) histograms.; 1759///; 1760/// #### Overview:; 1761///; 1762/// Comparison of two histograms expect hypotheses that two histograms; 1763/// represent identical distributions. To make a decision p-value should; 1764/// be calculated. The hypotheses of identity is rejected if the p-value is; 1765/// lower then some significance level. Traditionally significance levels; 1766/// 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; 1767/// analysis of the residuals which is often helpful in identifying the; 1768/// bins of histograms responsible for a significant overall \f$ \chi^{2} \f$ value.; 1769/// Residuals are the difference between bin contents and expected bin; 1770/// contents. Most convenient for analysis are the normalized residuals. If; 1771/// hypotheses of identity are valid then normalized residuals are; 1772/// approximate",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:69375,Testability,test,test,69375,"ograms.; 1759///; 1760/// #### Overview:; 1761///; 1762/// Comparison of two histograms expect hypotheses that two histograms; 1763/// represent identical distributions. To make a decision p-value should; 1764/// be calculated. The hypotheses of identity is rejected if the p-value is; 1765/// lower then some significance level. Traditionally significance levels; 1766/// 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; 1767/// analysis of the residuals which is often helpful in identifying the; 1768/// bins of histograms responsible for a significant overall \f$ \chi^{2} \f$ value.; 1769/// Residuals are the difference between bin contents and expected bin; 1770/// contents. Most convenient for analysis are the normalized residuals. If; 1771/// hypotheses of identity are valid then normalized residuals are; 1772/// approximately independent and identically distributed random variables; 1773/// having N(0,1) distribution. Analysis of residuals expect test of above; 1774/// mentioned properties of residuals. Notice that indirectly the analysis; 1775/// of residuals increase the power of \f$ \chi^{2} \f$ test.; 1776///; 1777/// #### Methods of comparison:; 1778///; 1779/// \f$ \chi^{2} \f$ test for comparison two (unweighted) histograms:; 1780/// Let us consider two histograms with the same binning and the number; 1781/// of bins equal to r. Let us denote the number of events in the ith bin; 1782/// in the first histogram as ni and as mi in the second one. The total; 1783/// number of events in the first histogram is equal to:; 1784/// \f[; 1785/// N = \sum_{i=1}^{r} n_{i}; 1786/// \f]; 1787/// and; 1788/// \f[; 1789/// M = \sum_{i=1}^{r} m_{i}; 1790/// \f]; 1791/// in the second histogram. The hypothesis of identity (homogeneity) [3]; 1792/// is that the two histograms represent random values with identical; 1793/// distributions. It is equivalent that there exist r constants p1,...,pr,; 1794/// such that; 1795/// \f[; 1796///\sum_{i=1}^{r} p_{i}",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:69530,Testability,test,test,69530,"hypotheses that two histograms; 1763/// represent identical distributions. To make a decision p-value should; 1764/// be calculated. The hypotheses of identity is rejected if the p-value is; 1765/// lower then some significance level. Traditionally significance levels; 1766/// 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; 1767/// analysis of the residuals which is often helpful in identifying the; 1768/// bins of histograms responsible for a significant overall \f$ \chi^{2} \f$ value.; 1769/// Residuals are the difference between bin contents and expected bin; 1770/// contents. Most convenient for analysis are the normalized residuals. If; 1771/// hypotheses of identity are valid then normalized residuals are; 1772/// approximately independent and identically distributed random variables; 1773/// having N(0,1) distribution. Analysis of residuals expect test of above; 1774/// mentioned properties of residuals. Notice that indirectly the analysis; 1775/// of residuals increase the power of \f$ \chi^{2} \f$ test.; 1776///; 1777/// #### Methods of comparison:; 1778///; 1779/// \f$ \chi^{2} \f$ test for comparison two (unweighted) histograms:; 1780/// Let us consider two histograms with the same binning and the number; 1781/// of bins equal to r. Let us denote the number of events in the ith bin; 1782/// in the first histogram as ni and as mi in the second one. The total; 1783/// number of events in the first histogram is equal to:; 1784/// \f[; 1785/// N = \sum_{i=1}^{r} n_{i}; 1786/// \f]; 1787/// and; 1788/// \f[; 1789/// M = \sum_{i=1}^{r} m_{i}; 1790/// \f]; 1791/// in the second histogram. The hypothesis of identity (homogeneity) [3]; 1792/// is that the two histograms represent random values with identical; 1793/// distributions. It is equivalent that there exist r constants p1,...,pr,; 1794/// such that; 1795/// \f[; 1796///\sum_{i=1}^{r} p_{i}=1; 1797/// \f]; 1798/// and the probability of belonging to the ith bin for some measured valu",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:69617,Testability,test,test,69617,"d if the p-value is; 1765/// lower then some significance level. Traditionally significance levels; 1766/// 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; 1767/// analysis of the residuals which is often helpful in identifying the; 1768/// bins of histograms responsible for a significant overall \f$ \chi^{2} \f$ value.; 1769/// Residuals are the difference between bin contents and expected bin; 1770/// contents. Most convenient for analysis are the normalized residuals. If; 1771/// hypotheses of identity are valid then normalized residuals are; 1772/// approximately independent and identically distributed random variables; 1773/// having N(0,1) distribution. Analysis of residuals expect test of above; 1774/// mentioned properties of residuals. Notice that indirectly the analysis; 1775/// of residuals increase the power of \f$ \chi^{2} \f$ test.; 1776///; 1777/// #### Methods of comparison:; 1778///; 1779/// \f$ \chi^{2} \f$ test for comparison two (unweighted) histograms:; 1780/// Let us consider two histograms with the same binning and the number; 1781/// of bins equal to r. Let us denote the number of events in the ith bin; 1782/// in the first histogram as ni and as mi in the second one. The total; 1783/// number of events in the first histogram is equal to:; 1784/// \f[; 1785/// N = \sum_{i=1}^{r} n_{i}; 1786/// \f]; 1787/// and; 1788/// \f[; 1789/// M = \sum_{i=1}^{r} m_{i}; 1790/// \f]; 1791/// in the second histogram. The hypothesis of identity (homogeneity) [3]; 1792/// is that the two histograms represent random values with identical; 1793/// distributions. It is equivalent that there exist r constants p1,...,pr,; 1794/// such that; 1795/// \f[; 1796///\sum_{i=1}^{r} p_{i}=1; 1797/// \f]; 1798/// and the probability of belonging to the ith bin for some measured value; 1799/// in both experiments is equal to pi. The number of events in the ith; 1800/// bin is a random variable with a distribution approximated by a Poisson; 1801/// p",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:72081,Testability,test,test,72081,"nd then; 1815/// \f[; 1816/// X^{2} = \sum_{i=1}^{r}\frac{(n_{i}-N\hat{p}_{i})^{2}}{N\hat{p}_{i}} + \sum_{i=1}^{r}\frac{(m_{i}-M\hat{p}_{i})^{2}}{M\hat{p}_{i}} =\frac{1}{MN} \sum_{i=1}^{r}\frac{(Mn_{i}-Nm_{i})^{2}}{n_{i}+m_{i}}; 1817/// \f]; 1818/// has approximately a \f$ \chi^{2}_{(r-1)} \f$ distribution [3].; 1819/// The comparison procedure can include an analysis of the residuals which; 1820/// is often helpful in identifying the bins of histograms responsible for; 1821/// a significant overall \f$ \chi^{2} \f$ value. Most convenient for; 1822/// analysis are the adjusted (normalized) residuals [4]; 1823/// \f[; 1824/// r_{i} = \frac{n_{i}-N\hat{p}_{i}}{\sqrt{N\hat{p}_{i}}\sqrt{(1-N/(N+M))(1-(n_{i}+m_{i})/(N+M))}}; 1825/// \f]; 1826/// If hypotheses of homogeneity are valid then residuals ri are; 1827/// approximately independent and identically distributed random variables; 1828/// having N(0,1) distribution. The application of the \f$ \chi^{2} \f$ test has; 1829/// restrictions related to the value of the expected frequencies Npi,; 1830/// Mpi, i=1,...,r. A conservative rule formulated in [5] is that all the; 1831/// expectations must be 1 or greater for both histograms. In practical; 1832/// cases when expected frequencies are not known the estimated expected; 1833/// frequencies \f$ M\hat{p}_{i}, N\hat{p}_{i}, i=1,...,r \f$ can be used.; 1834///; 1835/// #### Unweighted and weighted histograms comparison:; 1836///; 1837/// A simple modification of the ideas described above can be used for the; 1838/// comparison of the usual (unweighted) and weighted histograms. Let us; 1839/// denote the number of events in the ith bin in the unweighted; 1840/// histogram as ni and the common weight of events in the ith bin of the; 1841/// weighted histogram as wi. The total number of events in the; 1842/// unweighted histogram is equal to; 1843///\f[; 1844/// N = \sum_{i=1}^{r} n_{i}; 1845///\f]; 1846/// and the total weight of events in the weighted histogram is equal to;",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:74095,Testability,test,test,74095,"sum_{i=1}^{r} w_{i}; 1849///\f]; 1850/// Let us formulate the hypothesis of identity of an unweighted histogram; 1851/// to a weighted histogram so that there exist r constants p1,...,pr, such; 1852/// that; 1853///\f[; 1854/// \sum_{i=1}^{r} p_{i} = 1; 1855///\f]; 1856/// for the unweighted histogram. The weight wi is a random variable with a; 1857/// distribution approximated by the normal probability distribution; 1858/// \f$ N(Wp_{i},\sigma_{i}^{2}) \f$ where \f$ \sigma_{i}^{2} \f$ is the variance of the weight wi.; 1859/// If we replace the variance \f$ \sigma_{i}^{2} \f$; 1860/// with estimate \f$ s_{i}^{2} \f$ (sum of squares of weights of; 1861/// events in the ith bin) and the hypothesis of identity is valid, then the; 1862/// maximum likelihood estimator of pi,i=1,...,r, is; 1863///\f[; 1864/// \hat{p}_{i} = \frac{Ww_{i}-Ns_{i}^{2}+\sqrt{(Ww_{i}-Ns_{i}^{2})^{2}+4W^{2}s_{i}^{2}n_{i}}}{2W^{2}}; 1865///\f]; 1866/// We may then use the test statistic; 1867///\f[; 1868/// X^{2} = \sum_{i=1}^{r} \frac{(n_{i}-N\hat{p}_{i})^{2}}{N\hat{p}_{i}} + \sum_{i=1}^{r} \frac{(w_{i}-W\hat{p}_{i})^{2}}{s_{i}^{2}}; 1869///\f]; 1870/// and it has approximately a \f$ \sigma^{2}_{(r-1)} \f$ distribution [2]. This test, as well; 1871/// as the original one [3], has a restriction on the expected frequencies. The; 1872/// expected frequencies recommended for the weighted histogram is more than 25.; 1873/// The value of the minimal expected frequency can be decreased down to 10 for; 1874/// the case when the weights of the events are close to constant. In the case; 1875/// of a weighted histogram if the number of events is unknown, then we can; 1876/// apply this recommendation for the equivalent number of events as; 1877///\f[; 1878/// n_{i}^{equiv} = \frac{ w_{i}^{2} }{ s_{i}^{2} }; 1879///\f]; 1880/// The minimal expected frequency for an unweighted histogram must be 1. Notice; 1881/// that any usual (unweighted) histogram can be considered as a weighted; 1882/// histogram with eve",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:74358,Testability,test,test,74358,"]; 1856/// for the unweighted histogram. The weight wi is a random variable with a; 1857/// distribution approximated by the normal probability distribution; 1858/// \f$ N(Wp_{i},\sigma_{i}^{2}) \f$ where \f$ \sigma_{i}^{2} \f$ is the variance of the weight wi.; 1859/// If we replace the variance \f$ \sigma_{i}^{2} \f$; 1860/// with estimate \f$ s_{i}^{2} \f$ (sum of squares of weights of; 1861/// events in the ith bin) and the hypothesis of identity is valid, then the; 1862/// maximum likelihood estimator of pi,i=1,...,r, is; 1863///\f[; 1864/// \hat{p}_{i} = \frac{Ww_{i}-Ns_{i}^{2}+\sqrt{(Ww_{i}-Ns_{i}^{2})^{2}+4W^{2}s_{i}^{2}n_{i}}}{2W^{2}}; 1865///\f]; 1866/// We may then use the test statistic; 1867///\f[; 1868/// X^{2} = \sum_{i=1}^{r} \frac{(n_{i}-N\hat{p}_{i})^{2}}{N\hat{p}_{i}} + \sum_{i=1}^{r} \frac{(w_{i}-W\hat{p}_{i})^{2}}{s_{i}^{2}}; 1869///\f]; 1870/// and it has approximately a \f$ \sigma^{2}_{(r-1)} \f$ distribution [2]. This test, as well; 1871/// as the original one [3], has a restriction on the expected frequencies. The; 1872/// expected frequencies recommended for the weighted histogram is more than 25.; 1873/// The value of the minimal expected frequency can be decreased down to 10 for; 1874/// the case when the weights of the events are close to constant. In the case; 1875/// of a weighted histogram if the number of events is unknown, then we can; 1876/// apply this recommendation for the equivalent number of events as; 1877///\f[; 1878/// n_{i}^{equiv} = \frac{ w_{i}^{2} }{ s_{i}^{2} }; 1879///\f]; 1880/// The minimal expected frequency for an unweighted histogram must be 1. Notice; 1881/// that any usual (unweighted) histogram can be considered as a weighted; 1882/// histogram with events that have constant weights equal to 1.; 1883/// The variance \f$ z_{i}^{2} \f$ of the difference between the weight wi; 1884/// and the estimated expectation value of the weight is approximately equal to:; 1885///\f[; 1886/// z_{i}^{2} = Var(w_{i}-W\hat{p}_{",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:77414,Testability,test,test,77414,"/// and also expectation value of weight w1i equal to W1pi and expectation value; 1913/// of weight w2i equal to W2pi. Weights in both the histograms are random; 1914/// variables with distributions which can be approximated by a normal; 1915/// probability distribution \f$ N(W_{1}p_{i},\sigma_{1i}^{2}) \f$ for the first histogram; 1916/// and by a distribution \f$ N(W_{2}p_{i},\sigma_{2i}^{2}) \f$ for the second.; 1917/// Here \f$ \sigma_{1i}^{2} \f$ and \f$ \sigma_{2i}^{2} \f$ are the variances; 1918/// of w1i and w2i with estimators \f$ s_{1i}^{2} \f$ and \f$ s_{2i}^{2} \f$ respectively.; 1919/// If the hypothesis of identity is valid, then the maximum likelihood and; 1920/// Least Square Method estimator of pi,i=1,...,r, is; 1921///\f[; 1922/// \hat{p}_{i} = \frac{w_{1i}W_{1}/s_{1i}^{2}+w_{2i}W_{2} /s_{2i}^{2}}{W_{1}^{2}/s_{1i}^{2}+W_{2}^{2}/s_{2i}^{2}}; 1923///\f]; 1924/// We may then use the test statistic; 1925///\f[; 1926/// X^{2} = \sum_{i=1}^{r} \frac{(w_{1i}-W_{1}\hat{p}_{i})^{2}}{s_{1i}^{2}} + \sum_{i=1}^{r} \frac{(w_{2i}-W_{2}\hat{p}_{i})^{2}}{s_{2i}^{2}} = \sum_{i=1}^{r} \frac{(W_{1}w_{2i}-W_{2}w_{1i})^{2}}{W_{1}^{2}s_{2i}^{2}+W_{2}^{2}s_{1i}^{2}}; 1927///\f]; 1928/// and it has approximately a \f$ \chi^{2}_{(r-1)} \f$ distribution [2].; 1929/// The normalized or studentised residuals [6]; 1930///\f[; 1931/// r_{i} = \frac{w_{1i}-W_{1}\hat{p}_{i}}{s_{1i}\sqrt{1 - \frac{1}{(1+W_{2}^{2}s_{1i}^{2}/W_{1}^{2}s_{2i}^{2})}}}; 1932///\f]; 1933/// have approximately a normal distribution with mean equal to 0 and standard; 1934/// deviation 1. A recommended minimal expected frequency is equal to 10 for; 1935/// the proposed test.; 1936///; 1937/// #### Numerical examples:; 1938///; 1939/// The method described herein is now illustrated with an example.; 1940/// We take a distribution; 1941///\f[; 1942/// \phi(x) = \frac{2}{(x-10)^{2}+1} + \frac{1}{(x-14)^{2}+1} (1); 1943///\f]; 1944/// defined on the interval [4,16]. Events distributed according to the formula; 1",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:78159,Testability,test,test,78159,"othesis of identity is valid, then the maximum likelihood and; 1920/// Least Square Method estimator of pi,i=1,...,r, is; 1921///\f[; 1922/// \hat{p}_{i} = \frac{w_{1i}W_{1}/s_{1i}^{2}+w_{2i}W_{2} /s_{2i}^{2}}{W_{1}^{2}/s_{1i}^{2}+W_{2}^{2}/s_{2i}^{2}}; 1923///\f]; 1924/// We may then use the test statistic; 1925///\f[; 1926/// X^{2} = \sum_{i=1}^{r} \frac{(w_{1i}-W_{1}\hat{p}_{i})^{2}}{s_{1i}^{2}} + \sum_{i=1}^{r} \frac{(w_{2i}-W_{2}\hat{p}_{i})^{2}}{s_{2i}^{2}} = \sum_{i=1}^{r} \frac{(W_{1}w_{2i}-W_{2}w_{1i})^{2}}{W_{1}^{2}s_{2i}^{2}+W_{2}^{2}s_{1i}^{2}}; 1927///\f]; 1928/// and it has approximately a \f$ \chi^{2}_{(r-1)} \f$ distribution [2].; 1929/// The normalized or studentised residuals [6]; 1930///\f[; 1931/// r_{i} = \frac{w_{1i}-W_{1}\hat{p}_{i}}{s_{1i}\sqrt{1 - \frac{1}{(1+W_{2}^{2}s_{1i}^{2}/W_{1}^{2}s_{2i}^{2})}}}; 1932///\f]; 1933/// have approximately a normal distribution with mean equal to 0 and standard; 1934/// deviation 1. A recommended minimal expected frequency is equal to 10 for; 1935/// the proposed test.; 1936///; 1937/// #### Numerical examples:; 1938///; 1939/// The method described herein is now illustrated with an example.; 1940/// We take a distribution; 1941///\f[; 1942/// \phi(x) = \frac{2}{(x-10)^{2}+1} + \frac{1}{(x-14)^{2}+1} (1); 1943///\f]; 1944/// defined on the interval [4,16]. Events distributed according to the formula; 1945/// (1) are simulated to create the unweighted histogram. Uniformly distributed; 1946/// events are simulated for the weighted histogram with weights calculated by; 1947/// formula (1). Each histogram has the same number of bins: 20. Fig.1 shows; 1948/// the result of comparison of the unweighted histogram with 200 events; 1949/// (minimal expected frequency equal to one) and the weighted histogram with; 1950/// 500 events (minimal expected frequency equal to 25); 1951/// Begin_Macro; 1952/// ../../../tutorials/math/chi2test.C; 1953/// End_Macro; 1954/// Fig 1. An example of comparison of the unweighted hi",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:79379,Testability,test,test,79379,"-14)^{2}+1} (1); 1943///\f]; 1944/// defined on the interval [4,16]. Events distributed according to the formula; 1945/// (1) are simulated to create the unweighted histogram. Uniformly distributed; 1946/// events are simulated for the weighted histogram with weights calculated by; 1947/// formula (1). Each histogram has the same number of bins: 20. Fig.1 shows; 1948/// the result of comparison of the unweighted histogram with 200 events; 1949/// (minimal expected frequency equal to one) and the weighted histogram with; 1950/// 500 events (minimal expected frequency equal to 25); 1951/// Begin_Macro; 1952/// ../../../tutorials/math/chi2test.C; 1953/// End_Macro; 1954/// Fig 1. An example of comparison of the unweighted histogram with 200 events; 1955/// and the weighted histogram with 500 events:; 1956/// 1. unweighted histogram;; 1957/// 2. weighted histogram;; 1958/// 3. normalized residuals plot;; 1959/// 4. normal Q-Q plot of residuals.; 1960///; 1961/// The value of the test statistic \f$ \chi^{2} \f$ is equal to; 1962/// 21.09 with p-value equal to 0.33, therefore the hypothesis of identity of; 1963/// the two histograms can be accepted for 0.05 significant level. The behavior; 1964/// of the normalized residuals plot (see Fig. 1c) and the normal Q-Q plot; 1965/// (see Fig. 1d) of residuals are regular and we cannot identify the outliers; 1966/// or bins with a big influence on \f$ \chi^{2} \f$.; 1967///; 1968/// The second example presents the same two histograms but 17 events was added; 1969/// to content of bin number 15 in unweighted histogram. Fig.2 shows the result; 1970/// of comparison of the unweighted histogram with 217 events (minimal expected; 1971/// frequency equal to one) and the weighted histogram with 500 events (minimal; 1972/// expected frequency equal to 25); 1973/// Begin_Macro; 1974/// ../../../tutorials/math/chi2test.C(17); 1975/// End_Macro; 1976/// Fig 2. An example of comparison of the unweighted histogram with 217 events; 1977/// and",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:80612,Testability,test,test,80612,"duals plot (see Fig. 1c) and the normal Q-Q plot; 1965/// (see Fig. 1d) of residuals are regular and we cannot identify the outliers; 1966/// or bins with a big influence on \f$ \chi^{2} \f$.; 1967///; 1968/// The second example presents the same two histograms but 17 events was added; 1969/// to content of bin number 15 in unweighted histogram. Fig.2 shows the result; 1970/// of comparison of the unweighted histogram with 217 events (minimal expected; 1971/// frequency equal to one) and the weighted histogram with 500 events (minimal; 1972/// expected frequency equal to 25); 1973/// Begin_Macro; 1974/// ../../../tutorials/math/chi2test.C(17); 1975/// End_Macro; 1976/// Fig 2. An example of comparison of the unweighted histogram with 217 events; 1977/// and the weighted histogram with 500 events:; 1978/// 1. unweighted histogram;; 1979/// 2. weighted histogram;; 1980/// 3. normalized residuals plot;; 1981/// 4. normal Q-Q plot of residuals.; 1982///; 1983/// The value of the test statistic \f$ \chi^{2} \f$ is equal to; 1984/// 32.33 with p-value equal to 0.029, therefore the hypothesis of identity of; 1985/// the two histograms is rejected for 0.05 significant level. The behavior of; 1986/// the normalized residuals plot (see Fig. 2c) and the normal Q-Q plot (see; 1987/// Fig. 2d) of residuals are not regular and we can identify the outlier or; 1988/// bin with a big influence on \f$ \chi^{2} \f$.; 1989///; 1990/// #### References:; 1991///; 1992/// - [1] Pearson, K., 1904. On the Theory of Contingency and Its Relation to; 1993/// Association and Normal Correlation. Drapers' Co. Memoirs, Biometric; 1994/// Series No. 1, London.; 1995/// - [2] Gagunashvili, N., 2006. \f$ \sigma^{2} \f$ test for comparison; 1996/// of weighted and unweighted histograms. Statistical Problems in Particle; 1997/// Physics, Astrophysics and Cosmology, Proceedings of PHYSTAT05,; 1998/// Oxford, UK, 12-15 September 2005, Imperial College Press, London, 43-44.; 1999/// Gagunashvili,N., Compa",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:81336,Testability,test,test,81336,"m with 217 events; 1977/// and the weighted histogram with 500 events:; 1978/// 1. unweighted histogram;; 1979/// 2. weighted histogram;; 1980/// 3. normalized residuals plot;; 1981/// 4. normal Q-Q plot of residuals.; 1982///; 1983/// The value of the test statistic \f$ \chi^{2} \f$ is equal to; 1984/// 32.33 with p-value equal to 0.029, therefore the hypothesis of identity of; 1985/// the two histograms is rejected for 0.05 significant level. The behavior of; 1986/// the normalized residuals plot (see Fig. 2c) and the normal Q-Q plot (see; 1987/// Fig. 2d) of residuals are not regular and we can identify the outlier or; 1988/// bin with a big influence on \f$ \chi^{2} \f$.; 1989///; 1990/// #### References:; 1991///; 1992/// - [1] Pearson, K., 1904. On the Theory of Contingency and Its Relation to; 1993/// Association and Normal Correlation. Drapers' Co. Memoirs, Biometric; 1994/// Series No. 1, London.; 1995/// - [2] Gagunashvili, N., 2006. \f$ \sigma^{2} \f$ test for comparison; 1996/// of weighted and unweighted histograms. Statistical Problems in Particle; 1997/// Physics, Astrophysics and Cosmology, Proceedings of PHYSTAT05,; 1998/// Oxford, UK, 12-15 September 2005, Imperial College Press, London, 43-44.; 1999/// Gagunashvili,N., Comparison of weighted and unweighted histograms,; 2000/// arXiv:physics/0605123, 2006.; 2001/// - [3] Cramer, H., 1946. Mathematical methods of statistics.; 2002/// Princeton University Press, Princeton.; 2003/// - [4] Haberman, S.J., 1973. The analysis of residuals in cross-classified tables.; 2004/// Biometrics 29, 205-220.; 2005/// - [5] Lewontin, R.C. and Felsenstein, J., 1965. The robustness of homogeneity; 2006/// test in 2xN tables. Biometrics 21, 19-33.; 2007/// - [6] Seber, G.A.F., Lee, A.J., 2003, Linear Regression Analysis.; 2008/// John Wiley & Sons Inc., New York.; 2009 ; 2010Double_t TH1::Chi2Test(const TH1* h2, Option_t *option, Double_t *res) const; 2011{; 2012 Double_t chi2 = 0;; 2013 Int_t ndf = 0, igood = 0;; 2014",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:82042,Testability,test,test,82042,"hi^{2} \f$.; 1989///; 1990/// #### References:; 1991///; 1992/// - [1] Pearson, K., 1904. On the Theory of Contingency and Its Relation to; 1993/// Association and Normal Correlation. Drapers' Co. Memoirs, Biometric; 1994/// Series No. 1, London.; 1995/// - [2] Gagunashvili, N., 2006. \f$ \sigma^{2} \f$ test for comparison; 1996/// of weighted and unweighted histograms. Statistical Problems in Particle; 1997/// Physics, Astrophysics and Cosmology, Proceedings of PHYSTAT05,; 1998/// Oxford, UK, 12-15 September 2005, Imperial College Press, London, 43-44.; 1999/// Gagunashvili,N., Comparison of weighted and unweighted histograms,; 2000/// arXiv:physics/0605123, 2006.; 2001/// - [3] Cramer, H., 1946. Mathematical methods of statistics.; 2002/// Princeton University Press, Princeton.; 2003/// - [4] Haberman, S.J., 1973. The analysis of residuals in cross-classified tables.; 2004/// Biometrics 29, 205-220.; 2005/// - [5] Lewontin, R.C. and Felsenstein, J., 1965. The robustness of homogeneity; 2006/// test in 2xN tables. Biometrics 21, 19-33.; 2007/// - [6] Seber, G.A.F., Lee, A.J., 2003, Linear Regression Analysis.; 2008/// John Wiley & Sons Inc., New York.; 2009 ; 2010Double_t TH1::Chi2Test(const TH1* h2, Option_t *option, Double_t *res) const; 2011{; 2012 Double_t chi2 = 0;; 2013 Int_t ndf = 0, igood = 0;; 2014 ; 2015 TString opt = option;; 2016 opt.ToUpper();; 2017 ; 2018 Double_t prob = Chi2TestX(h2,chi2,ndf,igood,option,res);; 2019 ; 2020 if(opt.Contains(""P"")) {; 2021 printf(""Chi2 = %f, Prob = %g, NDF = %d, igood = %d\n"", chi2,prob,ndf,igood);; 2022 }; 2023 if(opt.Contains(""CHI2/NDF"")) {; 2024 if (ndf == 0) return 0;; 2025 return chi2/ndf;; 2026 }; 2027 if(opt.Contains(""CHI2"")) {; 2028 return chi2;; 2029 }; 2030 ; 2031 return prob;; 2032}; 2033 ; 2034////////////////////////////////////////////////////////////////////////////////; 2035/// The computation routine of the Chisquare test. For the method description,; 2036/// see Chi2Test() function.; 2037///; 2038/// \re",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:82943,Testability,test,test,82943,"4] Haberman, S.J., 1973. The analysis of residuals in cross-classified tables.; 2004/// Biometrics 29, 205-220.; 2005/// - [5] Lewontin, R.C. and Felsenstein, J., 1965. The robustness of homogeneity; 2006/// test in 2xN tables. Biometrics 21, 19-33.; 2007/// - [6] Seber, G.A.F., Lee, A.J., 2003, Linear Regression Analysis.; 2008/// John Wiley & Sons Inc., New York.; 2009 ; 2010Double_t TH1::Chi2Test(const TH1* h2, Option_t *option, Double_t *res) const; 2011{; 2012 Double_t chi2 = 0;; 2013 Int_t ndf = 0, igood = 0;; 2014 ; 2015 TString opt = option;; 2016 opt.ToUpper();; 2017 ; 2018 Double_t prob = Chi2TestX(h2,chi2,ndf,igood,option,res);; 2019 ; 2020 if(opt.Contains(""P"")) {; 2021 printf(""Chi2 = %f, Prob = %g, NDF = %d, igood = %d\n"", chi2,prob,ndf,igood);; 2022 }; 2023 if(opt.Contains(""CHI2/NDF"")) {; 2024 if (ndf == 0) return 0;; 2025 return chi2/ndf;; 2026 }; 2027 if(opt.Contains(""CHI2"")) {; 2028 return chi2;; 2029 }; 2030 ; 2031 return prob;; 2032}; 2033 ; 2034////////////////////////////////////////////////////////////////////////////////; 2035/// The computation routine of the Chisquare test. For the method description,; 2036/// see Chi2Test() function.; 2037///; 2038/// \return p-value; 2039/// \param[in] h2 the second histogram; 2040/// \param[in] option; 2041/// - ""UU"" = experiment experiment comparison (unweighted-unweighted); 2042/// - ""UW"" = experiment MC comparison (unweighted-weighted). Note that the first; 2043/// histogram should be unweighted; 2044/// - ""WW"" = MC MC comparison (weighted-weighted); 2045/// - ""NORM"" = if one or both histograms is scaled; 2046/// - ""OF"" = overflows included; 2047/// - ""UF"" = underflows included; 2048/// by default underflows and overflows are not included; 2049/// \param[out] igood test output; 2050/// - igood=0 - no problems; 2051/// - For unweighted unweighted comparison; 2052/// - igood=1'There is a bin in the 1st histogram with less than 1 event'; 2053/// - igood=2'There is a bin in the 2nd histogram with less than ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:83592,Testability,test,test,83592,"comparison (unweighted-unweighted); 2042/// - ""UW"" = experiment MC comparison (unweighted-weighted). Note that the first; 2043/// histogram should be unweighted; 2044/// - ""WW"" = MC MC comparison (weighted-weighted); 2045/// - ""NORM"" = if one or both histograms is scaled; 2046/// - ""OF"" = overflows included; 2047/// - ""UF"" = underflows included; 2048/// by default underflows and overflows are not included; 2049/// \param[out] igood test output; 2050/// - igood=0 - no problems; 2051/// - For unweighted unweighted comparison; 2052/// - igood=1'There is a bin in the 1st histogram with less than 1 event'; 2053/// - igood=2'There is a bin in the 2nd histogram with less than 1 event'; 2054/// - igood=3'when the conditions for igood=1 and igood=2 are satisfied'; 2055/// - For unweighted weighted comparison; 2056/// - igood=1'There is a bin in the 1st histogram with less then 1 event'; 2057/// - igood=2'There is a bin in the 2nd histogram with less then 10 effective number of events'; 2058/// - igood=3'when the conditions for igood=1 and igood=2 are satisfied'; 2059/// - For weighted weighted comparison; 2060/// - igood=1'There is a bin in the 1st histogram with less then 10 effective; 2061/// number of events'; 2062/// - igood=2'There is a bin in the 2nd histogram with less then 10 effective; 2063/// number of events'; 2064/// - igood=3'when the conditions for igood=1 and igood=2 are satisfied'; 2065/// \param[out] chi2 chisquare of the test; 2066/// \param[out] ndf number of degrees of freedom (important, when both histograms have the same empty bins); 2067/// \param[out] res normalized residuals for further analysis; 2068 ; 2069Double_t TH1::Chi2TestX(const TH1* h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option, Double_t *res) const; 2070{; 2071 ; 2072 Int_t i_start, i_end;; 2073 Int_t j_start, j_end;; 2074 Int_t k_start, k_end;; 2075 ; 2076 Double_t sum1 = 0.0, sumw1 = 0.0;; 2077 Double_t sum2 = 0.0, sumw2 = 0.0;; 2078 ; 2079 chi2 = 0.0;; 2080 ndf = 0;; 208",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:84610,Testability,test,test,84610,"comparison (unweighted-unweighted); 2042/// - ""UW"" = experiment MC comparison (unweighted-weighted). Note that the first; 2043/// histogram should be unweighted; 2044/// - ""WW"" = MC MC comparison (weighted-weighted); 2045/// - ""NORM"" = if one or both histograms is scaled; 2046/// - ""OF"" = overflows included; 2047/// - ""UF"" = underflows included; 2048/// by default underflows and overflows are not included; 2049/// \param[out] igood test output; 2050/// - igood=0 - no problems; 2051/// - For unweighted unweighted comparison; 2052/// - igood=1'There is a bin in the 1st histogram with less than 1 event'; 2053/// - igood=2'There is a bin in the 2nd histogram with less than 1 event'; 2054/// - igood=3'when the conditions for igood=1 and igood=2 are satisfied'; 2055/// - For unweighted weighted comparison; 2056/// - igood=1'There is a bin in the 1st histogram with less then 1 event'; 2057/// - igood=2'There is a bin in the 2nd histogram with less then 10 effective number of events'; 2058/// - igood=3'when the conditions for igood=1 and igood=2 are satisfied'; 2059/// - For weighted weighted comparison; 2060/// - igood=1'There is a bin in the 1st histogram with less then 10 effective; 2061/// number of events'; 2062/// - igood=2'There is a bin in the 2nd histogram with less then 10 effective; 2063/// number of events'; 2064/// - igood=3'when the conditions for igood=1 and igood=2 are satisfied'; 2065/// \param[out] chi2 chisquare of the test; 2066/// \param[out] ndf number of degrees of freedom (important, when both histograms have the same empty bins); 2067/// \param[out] res normalized residuals for further analysis; 2068 ; 2069Double_t TH1::Chi2TestX(const TH1* h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option, Double_t *res) const; 2070{; 2071 ; 2072 Int_t i_start, i_end;; 2073 Int_t j_start, j_end;; 2074 Int_t k_start, k_end;; 2075 ; 2076 Double_t sum1 = 0.0, sumw1 = 0.0;; 2077 Double_t sum2 = 0.0, sumw2 = 0.0;; 2078 ; 2079 chi2 = 0.0;; 2080 ndf = 0;; 208",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:101023,Testability,test,test,101023,"andom functions.; 2531/// This function is automatically called by GetRandom when the fIntegral; 2532/// array does not exist or when the number of entries in the histogram; 2533/// has changed since the previous call to GetRandom.; 2534/// The resulting integral is normalized to 1.; 2535/// If the routine is called with the onlyPositive flag set an error will; 2536/// be produced in case of negative bin content and a NaN value returned; 2537/// \return 1 if success, 0 if integral is zero, NAN if onlyPositive-test fails; 2538 ; 2539Double_t TH1::ComputeIntegral(Bool_t onlyPositive); 2540{; 2541 if (fBuffer) BufferEmpty();; 2542 ; 2543 // delete previously computed integral (if any); 2544 if (fIntegral) delete [] fIntegral;; 2545 ; 2546 // - Allocate space to store the integral and compute integral; 2547 Int_t nbinsx = GetNbinsX();; 2548 Int_t nbinsy = GetNbinsY();; 2549 Int_t nbinsz = GetNbinsZ();; 2550 Int_t nbins = nbinsx * nbinsy * nbinsz;; 2551 ; 2552 fIntegral = new Double_t[nbins + 2];; 2553 Int_t ibin = 0; fIntegral[ibin] = 0;; 2554 ; 2555 for (Int_t binz=1; binz <= nbinsz; ++binz) {; 2556 for (Int_t biny=1; biny <= nbinsy; ++biny) {; 2557 for (Int_t binx=1; binx <= nbinsx; ++binx) {; 2558 ++ibin;; 2559 Double_t y = RetrieveBinContent(GetBin(binx, biny, binz));; 2560 if (onlyPositive && y < 0) {; 2561 Error(""ComputeIntegral"",""Bin content is negative - return a NaN value"");; 2562 fIntegral[nbins] = TMath::QuietNaN();; 2563 break;; 2564 }; 2565 fIntegral[ibin] = fIntegral[ibin - 1] + y;; 2566 }; 2567 }; 2568 }; 2569 ; 2570 // - Normalize integral to 1; 2571 if (fIntegral[nbins] == 0 ) {; 2572 Error(""ComputeIntegral"", ""Integral = 0, no hits in histogram bins (excluding over/underflow)."");; 2573 return 0;; 2574 }; 2575 for (Int_t bin=1; bin <= nbins; ++bin) fIntegral[bin] /= fIntegral[nbins];; 2576 fIntegral[nbins+1] = fEntries;; 2577 return fIntegral[nbins];; 2578}; 2579 ; 2580////////////////////////////////////////////////////////////////////////////////; 2581/",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:156254,Testability,log,log,156254,"on: %s"",fname); return -1; }; 3922 return Fit(f1,option,goption,xxmin,xxmax);; 3923 }; 3924}; 3925 ; 3926////////////////////////////////////////////////////////////////////////////////; 3927/// Fit histogram with the function pointer f1.; 3928///; 3929/// \param[in] f1 pointer to the function object; 3930/// \param[in] option string defining the fit options (see table below).; 3931/// \param[in] goption specify a list of graphics options. See TH1::Draw for a complete list of these options.; 3932/// \param[in] xxmin lower fitting range; 3933/// \param[in] xxmax upper fitting range; 3934/// \return A smart pointer to the TFitResult class; 3935///; 3936/// \anchor HFitOpt; 3937/// ### Histogram Fitting Options; 3938///; 3939/// Here is the full list of fit options that can be given in the parameter `option`.; 3940/// Several options can be used together by concatanating the strings without the need of any delimiters.; 3941///; 3942/// option | description; 3943/// -------|------------; 3944/// ""L"" | Uses a log likelihood method (default is chi-square method). To be used when the histogram represents counts.; 3945/// ""WL"" | Weighted log likelihood method. To be used when the histogram has been filled with weights different than 1. This is needed for getting correct parameter uncertainties for weighted fits.; 3946/// ""P"" | Uses Pearson chi-square method. Uses expected errors instead of the observed one (default case). The expected error is instead estimated from the square-root of the bin function value.; 3947/// ""MULTI"" | Uses Loglikelihood method based on multi-nomial distribution. In this case the function must be normalized and one fits only the function shape.; 3948/// ""W"" | Fit using the chi-square method and ignoring the bin uncertainties and skip empty bins.; 3949/// ""WW"" | Fit using the chi-square method and ignoring the bin uncertainties and include the empty bins.; 3950/// ""I"" | Uses the integral of function in the bin instead of the default bin center value.;",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:156382,Testability,log,log,156382,"///////////////////////////////////////; 3927/// Fit histogram with the function pointer f1.; 3928///; 3929/// \param[in] f1 pointer to the function object; 3930/// \param[in] option string defining the fit options (see table below).; 3931/// \param[in] goption specify a list of graphics options. See TH1::Draw for a complete list of these options.; 3932/// \param[in] xxmin lower fitting range; 3933/// \param[in] xxmax upper fitting range; 3934/// \return A smart pointer to the TFitResult class; 3935///; 3936/// \anchor HFitOpt; 3937/// ### Histogram Fitting Options; 3938///; 3939/// Here is the full list of fit options that can be given in the parameter `option`.; 3940/// Several options can be used together by concatanating the strings without the need of any delimiters.; 3941///; 3942/// option | description; 3943/// -------|------------; 3944/// ""L"" | Uses a log likelihood method (default is chi-square method). To be used when the histogram represents counts.; 3945/// ""WL"" | Weighted log likelihood method. To be used when the histogram has been filled with weights different than 1. This is needed for getting correct parameter uncertainties for weighted fits.; 3946/// ""P"" | Uses Pearson chi-square method. Uses expected errors instead of the observed one (default case). The expected error is instead estimated from the square-root of the bin function value.; 3947/// ""MULTI"" | Uses Loglikelihood method based on multi-nomial distribution. In this case the function must be normalized and one fits only the function shape.; 3948/// ""W"" | Fit using the chi-square method and ignoring the bin uncertainties and skip empty bins.; 3949/// ""WW"" | Fit using the chi-square method and ignoring the bin uncertainties and include the empty bins.; 3950/// ""I"" | Uses the integral of function in the bin instead of the default bin center value.; 3951/// ""F"" | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.; 3952/// ""U"" | U",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:163582,Testability,log,log-likelihood,163582,"; 4011/// of empty bins. When using option ""I"" the residual is computed not using the function value at the bin center, `f(x(i)|p)`,; 4012/// but the integral of the function in the bin, Integral{ f(x|p)dx }, divided by the bin volume.; 4013/// When using option `P` (Pearson chi2), the expected error computed as `e(i) = sqrt(f(x(i)|p))` is used.; 4014/// In this case empty bins are considered in the fit.; 4015/// Both chi-square methods should not be used when the bin content represent counts, especially in case of low bin statistics,; 4016/// because they could return a biased result.; 4017///; 4018/// \anchor HFitNLL; 4019/// ### Likelihood Fits; 4020///; 4021/// When using option ""L"" a likelihood fit is used instead of the default chi-square fit.; 4022/// The likelihood is built assuming a Poisson probability density function for each bin.; 4023/// The negative log-likelihood to be minimized is; 4024///; 4025/// \f[; 4026/// NLL = - \sum_{i}{ \log {\mathrm P} ( y(i) | f(x(i) | p ) ) }; 4027/// \f]; 4028/// where `P(y|f)` is the Poisson distribution of observing a count `y(i)` in the bin when the expected count is `f(x(i)|p)`.; 4029/// The exact likelihood used is the Poisson likelihood described in this paper:; 4030/// S. Baker and R. D. Cousins, “Clarification of the use of chi-square and likelihood functions in fits to histograms,”; 4031/// Nucl. Instrum. Meth. 221 (1984) 437.; 4032///; 4033/// \f[; 4034/// NLL = \sum_{i}{( f(x(i) | p ) + y(i)\log(y(i)/ f(x(i) | p )) - y(i)) }; 4035/// \f]; 4036/// By using this formulation, `2*NLL` can be interpreted as the chi-square resulting from the fit.; 4037///; 4038/// This method should be always used when the bin content represents counts (i.e. errors are sqrt(N) ).; 4039/// The likelihood method has the advantage of treating correctly bins with low statistics. In case of high; 4040/// statistics/bin the distribution of the bin content becomes a normal distribution and the likelihood and the chi2 fit; 4041/// give the",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:163666,Testability,log,log,163666,"; 4011/// of empty bins. When using option ""I"" the residual is computed not using the function value at the bin center, `f(x(i)|p)`,; 4012/// but the integral of the function in the bin, Integral{ f(x|p)dx }, divided by the bin volume.; 4013/// When using option `P` (Pearson chi2), the expected error computed as `e(i) = sqrt(f(x(i)|p))` is used.; 4014/// In this case empty bins are considered in the fit.; 4015/// Both chi-square methods should not be used when the bin content represent counts, especially in case of low bin statistics,; 4016/// because they could return a biased result.; 4017///; 4018/// \anchor HFitNLL; 4019/// ### Likelihood Fits; 4020///; 4021/// When using option ""L"" a likelihood fit is used instead of the default chi-square fit.; 4022/// The likelihood is built assuming a Poisson probability density function for each bin.; 4023/// The negative log-likelihood to be minimized is; 4024///; 4025/// \f[; 4026/// NLL = - \sum_{i}{ \log {\mathrm P} ( y(i) | f(x(i) | p ) ) }; 4027/// \f]; 4028/// where `P(y|f)` is the Poisson distribution of observing a count `y(i)` in the bin when the expected count is `f(x(i)|p)`.; 4029/// The exact likelihood used is the Poisson likelihood described in this paper:; 4030/// S. Baker and R. D. Cousins, “Clarification of the use of chi-square and likelihood functions in fits to histograms,”; 4031/// Nucl. Instrum. Meth. 221 (1984) 437.; 4032///; 4033/// \f[; 4034/// NLL = \sum_{i}{( f(x(i) | p ) + y(i)\log(y(i)/ f(x(i) | p )) - y(i)) }; 4035/// \f]; 4036/// By using this formulation, `2*NLL` can be interpreted as the chi-square resulting from the fit.; 4037///; 4038/// This method should be always used when the bin content represents counts (i.e. errors are sqrt(N) ).; 4039/// The likelihood method has the advantage of treating correctly bins with low statistics. In case of high; 4040/// statistics/bin the distribution of the bin content becomes a normal distribution and the likelihood and the chi2 fit; 4041/// give the",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:164178,Testability,log,log,164178,"ase of low bin statistics,; 4016/// because they could return a biased result.; 4017///; 4018/// \anchor HFitNLL; 4019/// ### Likelihood Fits; 4020///; 4021/// When using option ""L"" a likelihood fit is used instead of the default chi-square fit.; 4022/// The likelihood is built assuming a Poisson probability density function for each bin.; 4023/// The negative log-likelihood to be minimized is; 4024///; 4025/// \f[; 4026/// NLL = - \sum_{i}{ \log {\mathrm P} ( y(i) | f(x(i) | p ) ) }; 4027/// \f]; 4028/// where `P(y|f)` is the Poisson distribution of observing a count `y(i)` in the bin when the expected count is `f(x(i)|p)`.; 4029/// The exact likelihood used is the Poisson likelihood described in this paper:; 4030/// S. Baker and R. D. Cousins, “Clarification of the use of chi-square and likelihood functions in fits to histograms,”; 4031/// Nucl. Instrum. Meth. 221 (1984) 437.; 4032///; 4033/// \f[; 4034/// NLL = \sum_{i}{( f(x(i) | p ) + y(i)\log(y(i)/ f(x(i) | p )) - y(i)) }; 4035/// \f]; 4036/// By using this formulation, `2*NLL` can be interpreted as the chi-square resulting from the fit.; 4037///; 4038/// This method should be always used when the bin content represents counts (i.e. errors are sqrt(N) ).; 4039/// The likelihood method has the advantage of treating correctly bins with low statistics. In case of high; 4040/// statistics/bin the distribution of the bin content becomes a normal distribution and the likelihood and the chi2 fit; 4041/// give the same result.; 4042///; 4043/// The likelihood method, although a bit slower, it is therefore the recommended method,; 4044/// when the histogram represent counts (Poisson statistics), where the chi-square methods may; 4045/// give incorrect results, especially in case of low statistics.; 4046/// In case of a weighted histogram, it is possible to perform also a likelihood fit by using the; 4047/// option ""WL"". Note a weighted histogram is a histogram which has been filled with weights and it; 4048/// has the ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:229351,Testability,test,tested,229351,"2.resize(nx * ny);; 5741 // copy old bin contents and then set to new ordered bins; 5742 // N.B. bin in histograms starts from 1, but in y we consider under/overflows; 5743 for (i = 0; i < nx; i++) {; 5744 for (j = 0; j < ny; j++) { // ny is nbins+2; 5745 Int_t bin = GetBin(i, j);; 5746 cont[i + nx * j] = RetrieveBinContent(bin);; 5747 if (!errors2.empty()); 5748 errors2[i + nx * j] = GetBinErrorSqUnchecked(bin);; 5749 }; 5750 }; 5751 if (axis == GetXaxis()) {; 5752 for (i = 0; i < n; i++) {; 5753 for (j = 0; j < ny; j++) {; 5754 Int_t bin = GetBin(i + 1 , j);; 5755 UpdateBinContent(bin, cont[b[a[i]] + nx * j]);; 5756 if (!errors2.empty()); 5757 fSumw2.fArray[bin] = errors2[b[a[i]] + nx * j];; 5758 }; 5759 }; 5760 } else {; 5761 for (i = 0; i < nx; i++) {; 5762 for (j = 0; j < n; j++) {; 5763 Int_t bin = GetBin(i, j + 1);; 5764 UpdateBinContent(bin, cont[i + nx * b[a[j]]]);; 5765 if (!errors2.empty()); 5766 fSumw2.fArray[bin] = errors2[i + nx * b[a[j]]];; 5767 }; 5768 }; 5769 }; 5770 } else {; 5771 // case of 3D (needs to be tested); 5772 Int_t nx = fXaxis.GetNbins() + 2;; 5773 Int_t ny = fYaxis.GetNbins() + 2;; 5774 Int_t nz = fZaxis.GetNbins() + 2;; 5775 cont.resize(nx * ny * nz);; 5776 if (fSumw2.fN); 5777 errors2.resize(nx * ny * nz);; 5778 for (i = 0; i < nx; i++) {; 5779 for (j = 0; j < ny; j++) {; 5780 for (k = 0; k < nz; k++) {; 5781 Int_t bin = GetBin(i, j, k);; 5782 cont[i + nx * (j + ny * k)] = RetrieveBinContent(bin);; 5783 if (!errors2.empty()); 5784 errors2[i + nx * (j + ny * k)] = GetBinErrorSqUnchecked(bin);; 5785 }; 5786 }; 5787 }; 5788 if (axis == GetXaxis()) {; 5789 // labels on x axis; 5790 for (i = 0; i < n; i++) { // for x we loop only on bins with the labels; 5791 for (j = 0; j < ny; j++) {; 5792 for (k = 0; k < nz; k++) {; 5793 Int_t bin = GetBin(i + 1, j, k);; 5794 UpdateBinContent(bin, cont[b[a[i]] + nx * (j + ny * k)]);; 5795 if (!errors2.empty()); 5796 fSumw2.fArray[bin] = errors2[b[a[i]] + nx * (j + ny * k)];; 5797 }; 5798 }; 5799 }; 5800",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:279218,Testability,log,logic,279218,"ation with the buffer (see BufferEmpty and BufferFill); 7109 ; 7110 TString opt = option;; 7111 opt.ToUpper();; 7112 fSumw2.Reset();; 7113 if (fIntegral) {; 7114 delete [] fIntegral;; 7115 fIntegral = nullptr;; 7116 }; 7117 ; 7118 if (opt.Contains(""M"")) {; 7119 SetMinimum();; 7120 SetMaximum();; 7121 }; 7122 ; 7123 if (opt.Contains(""ICE"") && !opt.Contains(""S"")) return;; 7124 ; 7125 // Setting fBuffer[0] = 0 is like resetting the buffer but not deleting it; 7126 // But what is the sense of calling BufferEmpty() ? For making the axes ?; 7127 // BufferEmpty will update contents that later will be; 7128 // reset in calling TH1D::Reset. For this we need to reset the stats afterwards; 7129 // It may be needed for computing the axis limits....; 7130 if (fBuffer) {BufferEmpty(); fBuffer[0] = 0;}; 7131 ; 7132 // need to reset also the statistics; 7133 // (needs to be done after calling BufferEmpty() ); 7134 fTsumw = 0;; 7135 fTsumw2 = 0;; 7136 fTsumwx = 0;; 7137 fTsumwx2 = 0;; 7138 fEntries = 0;; 7139 ; 7140 if (opt == ""ICES"") return;; 7141 ; 7142 ; 7143 TObject *stats = fFunctions->FindObject(""stats"");; 7144 fFunctions->Remove(stats);; 7145 //special logic to support the case where the same object is; 7146 //added multiple times in fFunctions.; 7147 //This case happens when the same object is added with different; 7148 //drawing modes; 7149 TObject *obj;; 7150 while ((obj = fFunctions->First())) {; 7151 while(fFunctions->Remove(obj)) { }; 7152 delete obj;; 7153 }; 7154 if(stats) fFunctions->Add(stats);; 7155 fContour.Set(0);; 7156}; 7157 ; 7158////////////////////////////////////////////////////////////////////////////////; 7159/// Save the histogram as .csv, .tsv or .txt. In case of any other extension, fall; 7160/// back to TObject::SaveAs, which saves as a .C macro (but with the file name; 7161/// extension specified by the user); 7162///; 7163/// The Under/Overflow bins are also exported (as first and last lines); 7164/// The fist 2 columns are the lower and upper edges ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:315025,Testability,test,test,315025,"= 0; binz2 = 0;; 8002 }; 8003 ; 8004 // - Loop on bins in specified range; 8005 TString opt = option;; 8006 opt.ToLower();; 8007 Bool_t width = kFALSE;; 8008 if (opt.Contains(""width"")) width = kTRUE;; 8009 ; 8010 ; 8011 Double_t dx = 1., dy = .1, dz =.1;; 8012 Double_t integral = 0;; 8013 Double_t igerr2 = 0;; 8014 for (Int_t binx = binx1; binx <= binx2; ++binx) {; 8015 if (width) dx = fXaxis.GetBinWidth(binx);; 8016 for (Int_t biny = biny1; biny <= biny2; ++biny) {; 8017 if (width) dy = fYaxis.GetBinWidth(biny);; 8018 for (Int_t binz = binz1; binz <= binz2; ++binz) {; 8019 Int_t bin = GetBin(binx, biny, binz);; 8020 Double_t dv = 0.0;; 8021 if (width) {; 8022 dz = fZaxis.GetBinWidth(binz);; 8023 dv = dx * dy * dz;; 8024 integral += RetrieveBinContent(bin) * dv;; 8025 } else {; 8026 integral += RetrieveBinContent(bin);; 8027 }; 8028 if (doError) {; 8029 if (width) igerr2 += GetBinErrorSqUnchecked(bin) * dv * dv;; 8030 else igerr2 += GetBinErrorSqUnchecked(bin);; 8031 }; 8032 }; 8033 }; 8034 }; 8035 ; 8036 if (doError) error = TMath::Sqrt(igerr2);; 8037 return integral;; 8038}; 8039 ; 8040////////////////////////////////////////////////////////////////////////////////; 8041/// Statistical test of compatibility in shape between; 8042/// this histogram and h2, using the Anderson-Darling 2 sample test.; 8043///; 8044/// The AD 2 sample test formula are derived from the paper; 8045/// F.W Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; 8046///; 8047/// The test is implemented in root in the ROOT::Math::GoFTest class; 8048/// It is the same formula ( (6) in the paper), and also shown in; 8049/// [this preprint](http://arxiv.org/pdf/0804.0380v1.pdf); 8050///; 8051/// Binned data are considered as un-binned data; 8052/// with identical observation happening in the bin center.; 8053///; 8054/// \param[in] h2 Pointer to 1D histogram; 8055/// \param[in] option is a character string to specify options; 8056/// - ""D"" Put out a line of ""Debug"" printout; 8057/// - ""T"" Ret",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:315132,Testability,test,test,315132,"= 0; binz2 = 0;; 8002 }; 8003 ; 8004 // - Loop on bins in specified range; 8005 TString opt = option;; 8006 opt.ToLower();; 8007 Bool_t width = kFALSE;; 8008 if (opt.Contains(""width"")) width = kTRUE;; 8009 ; 8010 ; 8011 Double_t dx = 1., dy = .1, dz =.1;; 8012 Double_t integral = 0;; 8013 Double_t igerr2 = 0;; 8014 for (Int_t binx = binx1; binx <= binx2; ++binx) {; 8015 if (width) dx = fXaxis.GetBinWidth(binx);; 8016 for (Int_t biny = biny1; biny <= biny2; ++biny) {; 8017 if (width) dy = fYaxis.GetBinWidth(biny);; 8018 for (Int_t binz = binz1; binz <= binz2; ++binz) {; 8019 Int_t bin = GetBin(binx, biny, binz);; 8020 Double_t dv = 0.0;; 8021 if (width) {; 8022 dz = fZaxis.GetBinWidth(binz);; 8023 dv = dx * dy * dz;; 8024 integral += RetrieveBinContent(bin) * dv;; 8025 } else {; 8026 integral += RetrieveBinContent(bin);; 8027 }; 8028 if (doError) {; 8029 if (width) igerr2 += GetBinErrorSqUnchecked(bin) * dv * dv;; 8030 else igerr2 += GetBinErrorSqUnchecked(bin);; 8031 }; 8032 }; 8033 }; 8034 }; 8035 ; 8036 if (doError) error = TMath::Sqrt(igerr2);; 8037 return integral;; 8038}; 8039 ; 8040////////////////////////////////////////////////////////////////////////////////; 8041/// Statistical test of compatibility in shape between; 8042/// this histogram and h2, using the Anderson-Darling 2 sample test.; 8043///; 8044/// The AD 2 sample test formula are derived from the paper; 8045/// F.W Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; 8046///; 8047/// The test is implemented in root in the ROOT::Math::GoFTest class; 8048/// It is the same formula ( (6) in the paper), and also shown in; 8049/// [this preprint](http://arxiv.org/pdf/0804.0380v1.pdf); 8050///; 8051/// Binned data are considered as un-binned data; 8052/// with identical observation happening in the bin center.; 8053///; 8054/// \param[in] h2 Pointer to 1D histogram; 8055/// \param[in] option is a character string to specify options; 8056/// - ""D"" Put out a line of ""Debug"" printout; 8057/// - ""T"" Ret",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:315172,Testability,test,test,315172,"x) {; 8015 if (width) dx = fXaxis.GetBinWidth(binx);; 8016 for (Int_t biny = biny1; biny <= biny2; ++biny) {; 8017 if (width) dy = fYaxis.GetBinWidth(biny);; 8018 for (Int_t binz = binz1; binz <= binz2; ++binz) {; 8019 Int_t bin = GetBin(binx, biny, binz);; 8020 Double_t dv = 0.0;; 8021 if (width) {; 8022 dz = fZaxis.GetBinWidth(binz);; 8023 dv = dx * dy * dz;; 8024 integral += RetrieveBinContent(bin) * dv;; 8025 } else {; 8026 integral += RetrieveBinContent(bin);; 8027 }; 8028 if (doError) {; 8029 if (width) igerr2 += GetBinErrorSqUnchecked(bin) * dv * dv;; 8030 else igerr2 += GetBinErrorSqUnchecked(bin);; 8031 }; 8032 }; 8033 }; 8034 }; 8035 ; 8036 if (doError) error = TMath::Sqrt(igerr2);; 8037 return integral;; 8038}; 8039 ; 8040////////////////////////////////////////////////////////////////////////////////; 8041/// Statistical test of compatibility in shape between; 8042/// this histogram and h2, using the Anderson-Darling 2 sample test.; 8043///; 8044/// The AD 2 sample test formula are derived from the paper; 8045/// F.W Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; 8046///; 8047/// The test is implemented in root in the ROOT::Math::GoFTest class; 8048/// It is the same formula ( (6) in the paper), and also shown in; 8049/// [this preprint](http://arxiv.org/pdf/0804.0380v1.pdf); 8050///; 8051/// Binned data are considered as un-binned data; 8052/// with identical observation happening in the bin center.; 8053///; 8054/// \param[in] h2 Pointer to 1D histogram; 8055/// \param[in] option is a character string to specify options; 8056/// - ""D"" Put out a line of ""Debug"" printout; 8057/// - ""T"" Return the normalized A-D test statistic; 8058///; 8059/// - Note1: Underflow and overflow are not considered in the test; 8060/// - Note2: The test works only for un-weighted histogram (i.e. representing counts); 8061/// - Note3: The histograms are not required to have the same X axis; 8062/// - Note4: The test works only for 1-dimensional histograms; 8063 ; 806",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:315303,Testability,test,test,315303,"binz2; ++binz) {; 8019 Int_t bin = GetBin(binx, biny, binz);; 8020 Double_t dv = 0.0;; 8021 if (width) {; 8022 dz = fZaxis.GetBinWidth(binz);; 8023 dv = dx * dy * dz;; 8024 integral += RetrieveBinContent(bin) * dv;; 8025 } else {; 8026 integral += RetrieveBinContent(bin);; 8027 }; 8028 if (doError) {; 8029 if (width) igerr2 += GetBinErrorSqUnchecked(bin) * dv * dv;; 8030 else igerr2 += GetBinErrorSqUnchecked(bin);; 8031 }; 8032 }; 8033 }; 8034 }; 8035 ; 8036 if (doError) error = TMath::Sqrt(igerr2);; 8037 return integral;; 8038}; 8039 ; 8040////////////////////////////////////////////////////////////////////////////////; 8041/// Statistical test of compatibility in shape between; 8042/// this histogram and h2, using the Anderson-Darling 2 sample test.; 8043///; 8044/// The AD 2 sample test formula are derived from the paper; 8045/// F.W Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; 8046///; 8047/// The test is implemented in root in the ROOT::Math::GoFTest class; 8048/// It is the same formula ( (6) in the paper), and also shown in; 8049/// [this preprint](http://arxiv.org/pdf/0804.0380v1.pdf); 8050///; 8051/// Binned data are considered as un-binned data; 8052/// with identical observation happening in the bin center.; 8053///; 8054/// \param[in] h2 Pointer to 1D histogram; 8055/// \param[in] option is a character string to specify options; 8056/// - ""D"" Put out a line of ""Debug"" printout; 8057/// - ""T"" Return the normalized A-D test statistic; 8058///; 8059/// - Note1: Underflow and overflow are not considered in the test; 8060/// - Note2: The test works only for un-weighted histogram (i.e. representing counts); 8061/// - Note3: The histograms are not required to have the same X axis; 8062/// - Note4: The test works only for 1-dimensional histograms; 8063 ; 8064Double_t TH1::AndersonDarlingTest(const TH1 *h2, Option_t *option) const; 8065{; 8066 Double_t advalue = 0;; 8067 Double_t pvalue = AndersonDarlingTest(h2, advalue);; 8068 ; 8069 TString opt = opt",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:315841,Testability,test,test,315841,"3 }; 8034 }; 8035 ; 8036 if (doError) error = TMath::Sqrt(igerr2);; 8037 return integral;; 8038}; 8039 ; 8040////////////////////////////////////////////////////////////////////////////////; 8041/// Statistical test of compatibility in shape between; 8042/// this histogram and h2, using the Anderson-Darling 2 sample test.; 8043///; 8044/// The AD 2 sample test formula are derived from the paper; 8045/// F.W Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; 8046///; 8047/// The test is implemented in root in the ROOT::Math::GoFTest class; 8048/// It is the same formula ( (6) in the paper), and also shown in; 8049/// [this preprint](http://arxiv.org/pdf/0804.0380v1.pdf); 8050///; 8051/// Binned data are considered as un-binned data; 8052/// with identical observation happening in the bin center.; 8053///; 8054/// \param[in] h2 Pointer to 1D histogram; 8055/// \param[in] option is a character string to specify options; 8056/// - ""D"" Put out a line of ""Debug"" printout; 8057/// - ""T"" Return the normalized A-D test statistic; 8058///; 8059/// - Note1: Underflow and overflow are not considered in the test; 8060/// - Note2: The test works only for un-weighted histogram (i.e. representing counts); 8061/// - Note3: The histograms are not required to have the same X axis; 8062/// - Note4: The test works only for 1-dimensional histograms; 8063 ; 8064Double_t TH1::AndersonDarlingTest(const TH1 *h2, Option_t *option) const; 8065{; 8066 Double_t advalue = 0;; 8067 Double_t pvalue = AndersonDarlingTest(h2, advalue);; 8068 ; 8069 TString opt = option;; 8070 opt.ToUpper();; 8071 if (opt.Contains(""D"") ) {; 8072 printf("" AndersonDarlingTest Prob = %g, AD TestStatistic = %g\n"",pvalue,advalue);; 8073 }; 8074 if (opt.Contains(""T"") ) return advalue;; 8075 ; 8076 return pvalue;; 8077}; 8078 ; 8079////////////////////////////////////////////////////////////////////////////////; 8080/// Same function as above but returning also the test statistic value; 8081 ; 8082Double_t TH1::Anderson",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:315932,Testability,test,test,315932,"3 }; 8034 }; 8035 ; 8036 if (doError) error = TMath::Sqrt(igerr2);; 8037 return integral;; 8038}; 8039 ; 8040////////////////////////////////////////////////////////////////////////////////; 8041/// Statistical test of compatibility in shape between; 8042/// this histogram and h2, using the Anderson-Darling 2 sample test.; 8043///; 8044/// The AD 2 sample test formula are derived from the paper; 8045/// F.W Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; 8046///; 8047/// The test is implemented in root in the ROOT::Math::GoFTest class; 8048/// It is the same formula ( (6) in the paper), and also shown in; 8049/// [this preprint](http://arxiv.org/pdf/0804.0380v1.pdf); 8050///; 8051/// Binned data are considered as un-binned data; 8052/// with identical observation happening in the bin center.; 8053///; 8054/// \param[in] h2 Pointer to 1D histogram; 8055/// \param[in] option is a character string to specify options; 8056/// - ""D"" Put out a line of ""Debug"" printout; 8057/// - ""T"" Return the normalized A-D test statistic; 8058///; 8059/// - Note1: Underflow and overflow are not considered in the test; 8060/// - Note2: The test works only for un-weighted histogram (i.e. representing counts); 8061/// - Note3: The histograms are not required to have the same X axis; 8062/// - Note4: The test works only for 1-dimensional histograms; 8063 ; 8064Double_t TH1::AndersonDarlingTest(const TH1 *h2, Option_t *option) const; 8065{; 8066 Double_t advalue = 0;; 8067 Double_t pvalue = AndersonDarlingTest(h2, advalue);; 8068 ; 8069 TString opt = option;; 8070 opt.ToUpper();; 8071 if (opt.Contains(""D"") ) {; 8072 printf("" AndersonDarlingTest Prob = %g, AD TestStatistic = %g\n"",pvalue,advalue);; 8073 }; 8074 if (opt.Contains(""T"") ) return advalue;; 8075 ; 8076 return pvalue;; 8077}; 8078 ; 8079////////////////////////////////////////////////////////////////////////////////; 8080/// Same function as above but returning also the test statistic value; 8081 ; 8082Double_t TH1::Anderson",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:315959,Testability,test,test,315959,"3 }; 8034 }; 8035 ; 8036 if (doError) error = TMath::Sqrt(igerr2);; 8037 return integral;; 8038}; 8039 ; 8040////////////////////////////////////////////////////////////////////////////////; 8041/// Statistical test of compatibility in shape between; 8042/// this histogram and h2, using the Anderson-Darling 2 sample test.; 8043///; 8044/// The AD 2 sample test formula are derived from the paper; 8045/// F.W Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; 8046///; 8047/// The test is implemented in root in the ROOT::Math::GoFTest class; 8048/// It is the same formula ( (6) in the paper), and also shown in; 8049/// [this preprint](http://arxiv.org/pdf/0804.0380v1.pdf); 8050///; 8051/// Binned data are considered as un-binned data; 8052/// with identical observation happening in the bin center.; 8053///; 8054/// \param[in] h2 Pointer to 1D histogram; 8055/// \param[in] option is a character string to specify options; 8056/// - ""D"" Put out a line of ""Debug"" printout; 8057/// - ""T"" Return the normalized A-D test statistic; 8058///; 8059/// - Note1: Underflow and overflow are not considered in the test; 8060/// - Note2: The test works only for un-weighted histogram (i.e. representing counts); 8061/// - Note3: The histograms are not required to have the same X axis; 8062/// - Note4: The test works only for 1-dimensional histograms; 8063 ; 8064Double_t TH1::AndersonDarlingTest(const TH1 *h2, Option_t *option) const; 8065{; 8066 Double_t advalue = 0;; 8067 Double_t pvalue = AndersonDarlingTest(h2, advalue);; 8068 ; 8069 TString opt = option;; 8070 opt.ToUpper();; 8071 if (opt.Contains(""D"") ) {; 8072 printf("" AndersonDarlingTest Prob = %g, AD TestStatistic = %g\n"",pvalue,advalue);; 8073 }; 8074 if (opt.Contains(""T"") ) return advalue;; 8075 ; 8076 return pvalue;; 8077}; 8078 ; 8079////////////////////////////////////////////////////////////////////////////////; 8080/// Same function as above but returning also the test statistic value; 8081 ; 8082Double_t TH1::Anderson",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:316124,Testability,test,test,316124,"om the paper; 8045/// F.W Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; 8046///; 8047/// The test is implemented in root in the ROOT::Math::GoFTest class; 8048/// It is the same formula ( (6) in the paper), and also shown in; 8049/// [this preprint](http://arxiv.org/pdf/0804.0380v1.pdf); 8050///; 8051/// Binned data are considered as un-binned data; 8052/// with identical observation happening in the bin center.; 8053///; 8054/// \param[in] h2 Pointer to 1D histogram; 8055/// \param[in] option is a character string to specify options; 8056/// - ""D"" Put out a line of ""Debug"" printout; 8057/// - ""T"" Return the normalized A-D test statistic; 8058///; 8059/// - Note1: Underflow and overflow are not considered in the test; 8060/// - Note2: The test works only for un-weighted histogram (i.e. representing counts); 8061/// - Note3: The histograms are not required to have the same X axis; 8062/// - Note4: The test works only for 1-dimensional histograms; 8063 ; 8064Double_t TH1::AndersonDarlingTest(const TH1 *h2, Option_t *option) const; 8065{; 8066 Double_t advalue = 0;; 8067 Double_t pvalue = AndersonDarlingTest(h2, advalue);; 8068 ; 8069 TString opt = option;; 8070 opt.ToUpper();; 8071 if (opt.Contains(""D"") ) {; 8072 printf("" AndersonDarlingTest Prob = %g, AD TestStatistic = %g\n"",pvalue,advalue);; 8073 }; 8074 if (opt.Contains(""T"") ) return advalue;; 8075 ; 8076 return pvalue;; 8077}; 8078 ; 8079////////////////////////////////////////////////////////////////////////////////; 8080/// Same function as above but returning also the test statistic value; 8081 ; 8082Double_t TH1::AndersonDarlingTest(const TH1 *h2, Double_t & advalue) const; 8083{; 8084 if (GetDimension() != 1 || h2->GetDimension() != 1) {; 8085 Error(""AndersonDarlingTest"",""Histograms must be 1-D"");; 8086 return -1;; 8087 }; 8088 ; 8089 // empty the buffer. Probably we could add as an unbinned test; 8090 if (fBuffer) ((TH1*)this)->BufferEmpty();; 8091 ; 8092 // use the BinData class; 8093 ROOT::Fit:",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:316760,Testability,test,test,316760,"; 8057/// - ""T"" Return the normalized A-D test statistic; 8058///; 8059/// - Note1: Underflow and overflow are not considered in the test; 8060/// - Note2: The test works only for un-weighted histogram (i.e. representing counts); 8061/// - Note3: The histograms are not required to have the same X axis; 8062/// - Note4: The test works only for 1-dimensional histograms; 8063 ; 8064Double_t TH1::AndersonDarlingTest(const TH1 *h2, Option_t *option) const; 8065{; 8066 Double_t advalue = 0;; 8067 Double_t pvalue = AndersonDarlingTest(h2, advalue);; 8068 ; 8069 TString opt = option;; 8070 opt.ToUpper();; 8071 if (opt.Contains(""D"") ) {; 8072 printf("" AndersonDarlingTest Prob = %g, AD TestStatistic = %g\n"",pvalue,advalue);; 8073 }; 8074 if (opt.Contains(""T"") ) return advalue;; 8075 ; 8076 return pvalue;; 8077}; 8078 ; 8079////////////////////////////////////////////////////////////////////////////////; 8080/// Same function as above but returning also the test statistic value; 8081 ; 8082Double_t TH1::AndersonDarlingTest(const TH1 *h2, Double_t & advalue) const; 8083{; 8084 if (GetDimension() != 1 || h2->GetDimension() != 1) {; 8085 Error(""AndersonDarlingTest"",""Histograms must be 1-D"");; 8086 return -1;; 8087 }; 8088 ; 8089 // empty the buffer. Probably we could add as an unbinned test; 8090 if (fBuffer) ((TH1*)this)->BufferEmpty();; 8091 ; 8092 // use the BinData class; 8093 ROOT::Fit::BinData data1;; 8094 ROOT::Fit::BinData data2;; 8095 ; 8096 ROOT::Fit::FillData(data1, this, nullptr);; 8097 ROOT::Fit::FillData(data2, h2, nullptr);; 8098 ; 8099 double pvalue;; 8100 ROOT::Math::GoFTest::AndersonDarling2SamplesTest(data1,data2, pvalue,advalue);; 8101 ; 8102 return pvalue;; 8103}; 8104 ; 8105////////////////////////////////////////////////////////////////////////////////; 8106/// Statistical test of compatibility in shape between; 8107/// this histogram and h2, using Kolmogorov test.; 8108/// Note that the KolmogorovTest (KS) test should in theory be used only for unbinned dat",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:317092,Testability,test,test,317092,"n;; 8070 opt.ToUpper();; 8071 if (opt.Contains(""D"") ) {; 8072 printf("" AndersonDarlingTest Prob = %g, AD TestStatistic = %g\n"",pvalue,advalue);; 8073 }; 8074 if (opt.Contains(""T"") ) return advalue;; 8075 ; 8076 return pvalue;; 8077}; 8078 ; 8079////////////////////////////////////////////////////////////////////////////////; 8080/// Same function as above but returning also the test statistic value; 8081 ; 8082Double_t TH1::AndersonDarlingTest(const TH1 *h2, Double_t & advalue) const; 8083{; 8084 if (GetDimension() != 1 || h2->GetDimension() != 1) {; 8085 Error(""AndersonDarlingTest"",""Histograms must be 1-D"");; 8086 return -1;; 8087 }; 8088 ; 8089 // empty the buffer. Probably we could add as an unbinned test; 8090 if (fBuffer) ((TH1*)this)->BufferEmpty();; 8091 ; 8092 // use the BinData class; 8093 ROOT::Fit::BinData data1;; 8094 ROOT::Fit::BinData data2;; 8095 ; 8096 ROOT::Fit::FillData(data1, this, nullptr);; 8097 ROOT::Fit::FillData(data2, h2, nullptr);; 8098 ; 8099 double pvalue;; 8100 ROOT::Math::GoFTest::AndersonDarling2SamplesTest(data1,data2, pvalue,advalue);; 8101 ; 8102 return pvalue;; 8103}; 8104 ; 8105////////////////////////////////////////////////////////////////////////////////; 8106/// Statistical test of compatibility in shape between; 8107/// this histogram and h2, using Kolmogorov test.; 8108/// Note that the KolmogorovTest (KS) test should in theory be used only for unbinned data; 8109/// and not for binned data as in the case of the histogram (see NOTE 3 below).; 8110/// So, before using this method blindly, read the NOTE 3.; 8111///; 8112/// Default: Ignore under- and overflow bins in comparison; 8113///; 8114/// \param[in] h2 histogram; 8115/// \param[in] option is a character string to specify options; 8116/// - ""U"" include Underflows in test (also for 2-dim); 8117/// - ""O"" include Overflows (also valid for 2-dim); 8118/// - ""N"" include comparison of normalizations; 8119/// - ""D"" Put out a line of ""Debug"" printout; 8120/// - ""M"" Return the Max",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:317612,Testability,test,test,317612,"n;; 8070 opt.ToUpper();; 8071 if (opt.Contains(""D"") ) {; 8072 printf("" AndersonDarlingTest Prob = %g, AD TestStatistic = %g\n"",pvalue,advalue);; 8073 }; 8074 if (opt.Contains(""T"") ) return advalue;; 8075 ; 8076 return pvalue;; 8077}; 8078 ; 8079////////////////////////////////////////////////////////////////////////////////; 8080/// Same function as above but returning also the test statistic value; 8081 ; 8082Double_t TH1::AndersonDarlingTest(const TH1 *h2, Double_t & advalue) const; 8083{; 8084 if (GetDimension() != 1 || h2->GetDimension() != 1) {; 8085 Error(""AndersonDarlingTest"",""Histograms must be 1-D"");; 8086 return -1;; 8087 }; 8088 ; 8089 // empty the buffer. Probably we could add as an unbinned test; 8090 if (fBuffer) ((TH1*)this)->BufferEmpty();; 8091 ; 8092 // use the BinData class; 8093 ROOT::Fit::BinData data1;; 8094 ROOT::Fit::BinData data2;; 8095 ; 8096 ROOT::Fit::FillData(data1, this, nullptr);; 8097 ROOT::Fit::FillData(data2, h2, nullptr);; 8098 ; 8099 double pvalue;; 8100 ROOT::Math::GoFTest::AndersonDarling2SamplesTest(data1,data2, pvalue,advalue);; 8101 ; 8102 return pvalue;; 8103}; 8104 ; 8105////////////////////////////////////////////////////////////////////////////////; 8106/// Statistical test of compatibility in shape between; 8107/// this histogram and h2, using Kolmogorov test.; 8108/// Note that the KolmogorovTest (KS) test should in theory be used only for unbinned data; 8109/// and not for binned data as in the case of the histogram (see NOTE 3 below).; 8110/// So, before using this method blindly, read the NOTE 3.; 8111///; 8112/// Default: Ignore under- and overflow bins in comparison; 8113///; 8114/// \param[in] h2 histogram; 8115/// \param[in] option is a character string to specify options; 8116/// - ""U"" include Underflows in test (also for 2-dim); 8117/// - ""O"" include Overflows (also valid for 2-dim); 8118/// - ""N"" include comparison of normalizations; 8119/// - ""D"" Put out a line of ""Debug"" printout; 8120/// - ""M"" Return the Max",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:317700,Testability,test,test,317700,"n;; 8070 opt.ToUpper();; 8071 if (opt.Contains(""D"") ) {; 8072 printf("" AndersonDarlingTest Prob = %g, AD TestStatistic = %g\n"",pvalue,advalue);; 8073 }; 8074 if (opt.Contains(""T"") ) return advalue;; 8075 ; 8076 return pvalue;; 8077}; 8078 ; 8079////////////////////////////////////////////////////////////////////////////////; 8080/// Same function as above but returning also the test statistic value; 8081 ; 8082Double_t TH1::AndersonDarlingTest(const TH1 *h2, Double_t & advalue) const; 8083{; 8084 if (GetDimension() != 1 || h2->GetDimension() != 1) {; 8085 Error(""AndersonDarlingTest"",""Histograms must be 1-D"");; 8086 return -1;; 8087 }; 8088 ; 8089 // empty the buffer. Probably we could add as an unbinned test; 8090 if (fBuffer) ((TH1*)this)->BufferEmpty();; 8091 ; 8092 // use the BinData class; 8093 ROOT::Fit::BinData data1;; 8094 ROOT::Fit::BinData data2;; 8095 ; 8096 ROOT::Fit::FillData(data1, this, nullptr);; 8097 ROOT::Fit::FillData(data2, h2, nullptr);; 8098 ; 8099 double pvalue;; 8100 ROOT::Math::GoFTest::AndersonDarling2SamplesTest(data1,data2, pvalue,advalue);; 8101 ; 8102 return pvalue;; 8103}; 8104 ; 8105////////////////////////////////////////////////////////////////////////////////; 8106/// Statistical test of compatibility in shape between; 8107/// this histogram and h2, using Kolmogorov test.; 8108/// Note that the KolmogorovTest (KS) test should in theory be used only for unbinned data; 8109/// and not for binned data as in the case of the histogram (see NOTE 3 below).; 8110/// So, before using this method blindly, read the NOTE 3.; 8111///; 8112/// Default: Ignore under- and overflow bins in comparison; 8113///; 8114/// \param[in] h2 histogram; 8115/// \param[in] option is a character string to specify options; 8116/// - ""U"" include Underflows in test (also for 2-dim); 8117/// - ""O"" include Overflows (also valid for 2-dim); 8118/// - ""N"" include comparison of normalizations; 8119/// - ""D"" Put out a line of ""Debug"" printout; 8120/// - ""M"" Return the Max",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:317749,Testability,test,test,317749,"uble_t TH1::AndersonDarlingTest(const TH1 *h2, Double_t & advalue) const; 8083{; 8084 if (GetDimension() != 1 || h2->GetDimension() != 1) {; 8085 Error(""AndersonDarlingTest"",""Histograms must be 1-D"");; 8086 return -1;; 8087 }; 8088 ; 8089 // empty the buffer. Probably we could add as an unbinned test; 8090 if (fBuffer) ((TH1*)this)->BufferEmpty();; 8091 ; 8092 // use the BinData class; 8093 ROOT::Fit::BinData data1;; 8094 ROOT::Fit::BinData data2;; 8095 ; 8096 ROOT::Fit::FillData(data1, this, nullptr);; 8097 ROOT::Fit::FillData(data2, h2, nullptr);; 8098 ; 8099 double pvalue;; 8100 ROOT::Math::GoFTest::AndersonDarling2SamplesTest(data1,data2, pvalue,advalue);; 8101 ; 8102 return pvalue;; 8103}; 8104 ; 8105////////////////////////////////////////////////////////////////////////////////; 8106/// Statistical test of compatibility in shape between; 8107/// this histogram and h2, using Kolmogorov test.; 8108/// Note that the KolmogorovTest (KS) test should in theory be used only for unbinned data; 8109/// and not for binned data as in the case of the histogram (see NOTE 3 below).; 8110/// So, before using this method blindly, read the NOTE 3.; 8111///; 8112/// Default: Ignore under- and overflow bins in comparison; 8113///; 8114/// \param[in] h2 histogram; 8115/// \param[in] option is a character string to specify options; 8116/// - ""U"" include Underflows in test (also for 2-dim); 8117/// - ""O"" include Overflows (also valid for 2-dim); 8118/// - ""N"" include comparison of normalizations; 8119/// - ""D"" Put out a line of ""Debug"" printout; 8120/// - ""M"" Return the Maximum Kolmogorov distance instead of prob; 8121/// - ""X"" Run the pseudo experiments post-processor with the following procedure:; 8122/// make pseudoexperiments based on random values from the parent distribution,; 8123/// compare the KS distance of the pseudoexperiment to the parent; 8124/// distribution, and count all the KS values above the value; 8125/// obtained from the original data to Monte Carlo distribut",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:318171,Testability,test,test,318171,"e;; 8100 ROOT::Math::GoFTest::AndersonDarling2SamplesTest(data1,data2, pvalue,advalue);; 8101 ; 8102 return pvalue;; 8103}; 8104 ; 8105////////////////////////////////////////////////////////////////////////////////; 8106/// Statistical test of compatibility in shape between; 8107/// this histogram and h2, using Kolmogorov test.; 8108/// Note that the KolmogorovTest (KS) test should in theory be used only for unbinned data; 8109/// and not for binned data as in the case of the histogram (see NOTE 3 below).; 8110/// So, before using this method blindly, read the NOTE 3.; 8111///; 8112/// Default: Ignore under- and overflow bins in comparison; 8113///; 8114/// \param[in] h2 histogram; 8115/// \param[in] option is a character string to specify options; 8116/// - ""U"" include Underflows in test (also for 2-dim); 8117/// - ""O"" include Overflows (also valid for 2-dim); 8118/// - ""N"" include comparison of normalizations; 8119/// - ""D"" Put out a line of ""Debug"" printout; 8120/// - ""M"" Return the Maximum Kolmogorov distance instead of prob; 8121/// - ""X"" Run the pseudo experiments post-processor with the following procedure:; 8122/// make pseudoexperiments based on random values from the parent distribution,; 8123/// compare the KS distance of the pseudoexperiment to the parent; 8124/// distribution, and count all the KS values above the value; 8125/// obtained from the original data to Monte Carlo distribution.; 8126/// The number of pseudo-experiments nEXPT is by default 1000, and; 8127/// it can be changed by specifying the option as ""X=number"",; 8128/// for example ""X=10000"" for 10000 toys.; 8129/// The function returns the probability.; 8130/// (thanks to Ben Kilminster to submit this procedure). Note that; 8131/// this option ""X"" is much slower.; 8132///; 8133/// The returned function value is the probability of test; 8134/// (much less than one means NOT compatible); 8135///; 8136/// Code adapted by Rene Brun from original HBOOK routine HDIFF; 8137///; 8138/// NOTE1; 8",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:319215,Testability,test,test,319215,"119/// - ""D"" Put out a line of ""Debug"" printout; 8120/// - ""M"" Return the Maximum Kolmogorov distance instead of prob; 8121/// - ""X"" Run the pseudo experiments post-processor with the following procedure:; 8122/// make pseudoexperiments based on random values from the parent distribution,; 8123/// compare the KS distance of the pseudoexperiment to the parent; 8124/// distribution, and count all the KS values above the value; 8125/// obtained from the original data to Monte Carlo distribution.; 8126/// The number of pseudo-experiments nEXPT is by default 1000, and; 8127/// it can be changed by specifying the option as ""X=number"",; 8128/// for example ""X=10000"" for 10000 toys.; 8129/// The function returns the probability.; 8130/// (thanks to Ben Kilminster to submit this procedure). Note that; 8131/// this option ""X"" is much slower.; 8132///; 8133/// The returned function value is the probability of test; 8134/// (much less than one means NOT compatible); 8135///; 8136/// Code adapted by Rene Brun from original HBOOK routine HDIFF; 8137///; 8138/// NOTE1; 8139/// A good description of the Kolmogorov test can be seen at:; 8140/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; 8141///; 8142/// NOTE2; 8143/// see also alternative function TH1::Chi2Test; 8144/// The Kolmogorov test is assumed to give better results than Chi2Test; 8145/// in case of histograms with low statistics.; 8146///; 8147/// NOTE3 (Jan Conrad, Fred James); 8148/// ""The returned value PROB is calculated such that it will be; 8149/// uniformly distributed between zero and one for compatible histograms,; 8150/// provided the data are not binned (or the number of bins is very large; 8151/// compared with the number of events). Users who have access to unbinned; 8152/// data and wish exact confidence levels should therefore not put their data; 8153/// into histograms, but should call directly TMath::KolmogorovTest. On; 8154/// the other hand, since TH1 is a convenient way of collecting",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:319419,Testability,test,test,319419,"119/// - ""D"" Put out a line of ""Debug"" printout; 8120/// - ""M"" Return the Maximum Kolmogorov distance instead of prob; 8121/// - ""X"" Run the pseudo experiments post-processor with the following procedure:; 8122/// make pseudoexperiments based on random values from the parent distribution,; 8123/// compare the KS distance of the pseudoexperiment to the parent; 8124/// distribution, and count all the KS values above the value; 8125/// obtained from the original data to Monte Carlo distribution.; 8126/// The number of pseudo-experiments nEXPT is by default 1000, and; 8127/// it can be changed by specifying the option as ""X=number"",; 8128/// for example ""X=10000"" for 10000 toys.; 8129/// The function returns the probability.; 8130/// (thanks to Ben Kilminster to submit this procedure). Note that; 8131/// this option ""X"" is much slower.; 8132///; 8133/// The returned function value is the probability of test; 8134/// (much less than one means NOT compatible); 8135///; 8136/// Code adapted by Rene Brun from original HBOOK routine HDIFF; 8137///; 8138/// NOTE1; 8139/// A good description of the Kolmogorov test can be seen at:; 8140/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; 8141///; 8142/// NOTE2; 8143/// see also alternative function TH1::Chi2Test; 8144/// The Kolmogorov test is assumed to give better results than Chi2Test; 8145/// in case of histograms with low statistics.; 8146///; 8147/// NOTE3 (Jan Conrad, Fred James); 8148/// ""The returned value PROB is calculated such that it will be; 8149/// uniformly distributed between zero and one for compatible histograms,; 8150/// provided the data are not binned (or the number of bins is very large; 8151/// compared with the number of events). Users who have access to unbinned; 8152/// data and wish exact confidence levels should therefore not put their data; 8153/// into histograms, but should call directly TMath::KolmogorovTest. On; 8154/// the other hand, since TH1 is a convenient way of collecting",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:319614,Testability,test,test,319614," KS distance of the pseudoexperiment to the parent; 8124/// distribution, and count all the KS values above the value; 8125/// obtained from the original data to Monte Carlo distribution.; 8126/// The number of pseudo-experiments nEXPT is by default 1000, and; 8127/// it can be changed by specifying the option as ""X=number"",; 8128/// for example ""X=10000"" for 10000 toys.; 8129/// The function returns the probability.; 8130/// (thanks to Ben Kilminster to submit this procedure). Note that; 8131/// this option ""X"" is much slower.; 8132///; 8133/// The returned function value is the probability of test; 8134/// (much less than one means NOT compatible); 8135///; 8136/// Code adapted by Rene Brun from original HBOOK routine HDIFF; 8137///; 8138/// NOTE1; 8139/// A good description of the Kolmogorov test can be seen at:; 8140/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; 8141///; 8142/// NOTE2; 8143/// see also alternative function TH1::Chi2Test; 8144/// The Kolmogorov test is assumed to give better results than Chi2Test; 8145/// in case of histograms with low statistics.; 8146///; 8147/// NOTE3 (Jan Conrad, Fred James); 8148/// ""The returned value PROB is calculated such that it will be; 8149/// uniformly distributed between zero and one for compatible histograms,; 8150/// provided the data are not binned (or the number of bins is very large; 8151/// compared with the number of events). Users who have access to unbinned; 8152/// data and wish exact confidence levels should therefore not put their data; 8153/// into histograms, but should call directly TMath::KolmogorovTest. On; 8154/// the other hand, since TH1 is a convenient way of collecting data and; 8155/// saving space, this function has been provided. However, the values of; 8156/// PROB for binned data will be shifted slightly higher than expected,; 8157/// depending on the effects of the binning. For example, when comparing two; 8158/// uniform distributions of 500 events in 100 bins, the v",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:321725,Testability,test,test,321725,"0.56. We can apply a useful; 8161/// rule: As long as the bin width is small compared with any significant; 8162/// physical effect (for example the experimental resolution) then the binning; 8163/// cannot have an important effect. Therefore, we believe that for all; 8164/// practical purposes, the probability value PROB is calculated correctly; 8165/// provided the user is aware that:; 8166///; 8167/// 1. The value of PROB should not be expected to have exactly the correct; 8168/// distribution for binned data.; 8169/// 2. The user is responsible for seeing to it that the bin widths are; 8170/// small compared with any physical phenomena of interest.; 8171/// 3. The effect of binning (if any) is always to make the value of PROB; 8172/// slightly too big. That is, setting an acceptance criterion of (PROB>0.05; 8173/// will assure that at most 5% of truly compatible histograms are rejected,; 8174/// and usually somewhat less.""; 8175///; 8176/// Note also that for GoF test of unbinned data ROOT provides also the class; 8177/// ROOT::Math::GoFTest. The class has also method for doing one sample tests; 8178/// (i.e. comparing the data with a given distribution).; 8179 ; 8180Double_t TH1::KolmogorovTest(const TH1 *h2, Option_t *option) const; 8181{; 8182 TString opt = option;; 8183 opt.ToUpper();; 8184 ; 8185 Double_t prob = 0;; 8186 TH1 *h1 = (TH1*)this;; 8187 if (h2 == nullptr) return 0;; 8188 const TAxis *axis1 = h1->GetXaxis();; 8189 const TAxis *axis2 = h2->GetXaxis();; 8190 Int_t ncx1 = axis1->GetNbins();; 8191 Int_t ncx2 = axis2->GetNbins();; 8192 ; 8193 // Check consistency of dimensions; 8194 if (h1->GetDimension() != 1 || h2->GetDimension() != 1) {; 8195 Error(""KolmogorovTest"",""Histograms must be 1-D\n"");; 8196 return 0;; 8197 }; 8198 ; 8199 // Check consistency in number of channels; 8200 if (ncx1 != ncx2) {; 8201 Error(""KolmogorovTest"",""Histograms have different number of bins, %d and %d\n"",ncx1,ncx2);; 8202 return 0;; 8203 }; 8204 ; 8205 // empty the buffer.",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:321853,Testability,test,tests,321853,"significant; 8162/// physical effect (for example the experimental resolution) then the binning; 8163/// cannot have an important effect. Therefore, we believe that for all; 8164/// practical purposes, the probability value PROB is calculated correctly; 8165/// provided the user is aware that:; 8166///; 8167/// 1. The value of PROB should not be expected to have exactly the correct; 8168/// distribution for binned data.; 8169/// 2. The user is responsible for seeing to it that the bin widths are; 8170/// small compared with any physical phenomena of interest.; 8171/// 3. The effect of binning (if any) is always to make the value of PROB; 8172/// slightly too big. That is, setting an acceptance criterion of (PROB>0.05; 8173/// will assure that at most 5% of truly compatible histograms are rejected,; 8174/// and usually somewhat less.""; 8175///; 8176/// Note also that for GoF test of unbinned data ROOT provides also the class; 8177/// ROOT::Math::GoFTest. The class has also method for doing one sample tests; 8178/// (i.e. comparing the data with a given distribution).; 8179 ; 8180Double_t TH1::KolmogorovTest(const TH1 *h2, Option_t *option) const; 8181{; 8182 TString opt = option;; 8183 opt.ToUpper();; 8184 ; 8185 Double_t prob = 0;; 8186 TH1 *h1 = (TH1*)this;; 8187 if (h2 == nullptr) return 0;; 8188 const TAxis *axis1 = h1->GetXaxis();; 8189 const TAxis *axis2 = h2->GetXaxis();; 8190 Int_t ncx1 = axis1->GetNbins();; 8191 Int_t ncx2 = axis2->GetNbins();; 8192 ; 8193 // Check consistency of dimensions; 8194 if (h1->GetDimension() != 1 || h2->GetDimension() != 1) {; 8195 Error(""KolmogorovTest"",""Histograms must be 1-D\n"");; 8196 return 0;; 8197 }; 8198 ; 8199 // Check consistency in number of channels; 8200 if (ncx1 != ncx2) {; 8201 Error(""KolmogorovTest"",""Histograms have different number of bins, %d and %d\n"",ncx1,ncx2);; 8202 return 0;; 8203 }; 8204 ; 8205 // empty the buffer. Probably we could add as an unbinned test; 8206 if (fBuffer) ((TH1*)this)->BufferEmpty();; 82",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:322782,Testability,test,test,322782,"g the data with a given distribution).; 8179 ; 8180Double_t TH1::KolmogorovTest(const TH1 *h2, Option_t *option) const; 8181{; 8182 TString opt = option;; 8183 opt.ToUpper();; 8184 ; 8185 Double_t prob = 0;; 8186 TH1 *h1 = (TH1*)this;; 8187 if (h2 == nullptr) return 0;; 8188 const TAxis *axis1 = h1->GetXaxis();; 8189 const TAxis *axis2 = h2->GetXaxis();; 8190 Int_t ncx1 = axis1->GetNbins();; 8191 Int_t ncx2 = axis2->GetNbins();; 8192 ; 8193 // Check consistency of dimensions; 8194 if (h1->GetDimension() != 1 || h2->GetDimension() != 1) {; 8195 Error(""KolmogorovTest"",""Histograms must be 1-D\n"");; 8196 return 0;; 8197 }; 8198 ; 8199 // Check consistency in number of channels; 8200 if (ncx1 != ncx2) {; 8201 Error(""KolmogorovTest"",""Histograms have different number of bins, %d and %d\n"",ncx1,ncx2);; 8202 return 0;; 8203 }; 8204 ; 8205 // empty the buffer. Probably we could add as an unbinned test; 8206 if (fBuffer) ((TH1*)this)->BufferEmpty();; 8207 ; 8208 // Check consistency in bin edges; 8209 for(Int_t i = 1; i <= axis1->GetNbins() + 1; ++i) {; 8210 if(!TMath::AreEqualRel(axis1->GetBinLowEdge(i), axis2->GetBinLowEdge(i), 1.E-15)) {; 8211 Error(""KolmogorovTest"",""Histograms are not consistent: they have different bin edges"");; 8212 return 0;; 8213 }; 8214 }; 8215 ; 8216 Bool_t afunc1 = kFALSE;; 8217 Bool_t afunc2 = kFALSE;; 8218 Double_t sum1 = 0, sum2 = 0;; 8219 Double_t ew1, ew2, w1 = 0, w2 = 0;; 8220 Int_t bin;; 8221 Int_t ifirst = 1;; 8222 Int_t ilast = ncx1;; 8223 // integral of all bins (use underflow/overflow if option); 8224 if (opt.Contains(""U"")) ifirst = 0;; 8225 if (opt.Contains(""O"")) ilast = ncx1 +1;; 8226 for (bin = ifirst; bin <= ilast; bin++) {; 8227 sum1 += h1->RetrieveBinContent(bin);; 8228 sum2 += h2->RetrieveBinContent(bin);; 8229 ew1 = h1->GetBinError(bin);; 8230 ew2 = h2->GetBinError(bin);; 8231 w1 += ew1*ew1;; 8232 w2 += ew2*ew2;; 8233 }; 8234 if (sum1 == 0) {; 8235 Error(""KolmogorovTest"",""Histogram1 %s integral is zero\n"",h1->GetName());; 8236 retu",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:331474,Testability,log,log,331474,"to return one contour only; 8412 ; 8413Int_t TH1::GetContour(Double_t *levels); 8414{; 8415 Int_t nlevels = fContour.fN;; 8416 if (levels) {; 8417 if (nlevels == 0) {; 8418 nlevels = 20;; 8419 SetContour(nlevels);; 8420 } else {; 8421 if (TestBit(kUserContour) == 0) SetContour(nlevels);; 8422 }; 8423 for (Int_t level=0; level<nlevels; level++) levels[level] = fContour.fArray[level];; 8424 }; 8425 return nlevels;; 8426}; 8427 ; 8428////////////////////////////////////////////////////////////////////////////////; 8429/// Return value of contour number level.; 8430/// Use GetContour to return the array of all contour levels; 8431 ; 8432Double_t TH1::GetContourLevel(Int_t level) const; 8433{; 8434 return (level >= 0 && level < fContour.fN) ? fContour.fArray[level] : 0.0;; 8435}; 8436 ; 8437////////////////////////////////////////////////////////////////////////////////; 8438/// Return the value of contour number ""level"" in Pad coordinates.; 8439/// ie: if the Pad is in log scale along Z it returns le log of the contour level; 8440/// value. See GetContour to return the array of all contour levels; 8441 ; 8442Double_t TH1::GetContourLevelPad(Int_t level) const; 8443{; 8444 if (level <0 || level >= fContour.fN) return 0;; 8445 Double_t zlevel = fContour.fArray[level];; 8446 ; 8447 // In case of user defined contours and Pad in log scale along Z,; 8448 // fContour.fArray doesn't contain the log of the contour whereas it does; 8449 // in case of equidistant contours.; 8450 if (gPad && gPad->GetLogz() && TestBit(kUserContour)) {; 8451 if (zlevel <= 0) return 0;; 8452 zlevel = TMath::Log10(zlevel);; 8453 }; 8454 return zlevel;; 8455}; 8456 ; 8457////////////////////////////////////////////////////////////////////////////////; 8458/// Set the maximum number of entries to be kept in the buffer.; 8459 ; 8460void TH1::SetBuffer(Int_t buffersize, Option_t * /*option*/); 8461{; 8462 if (fBuffer) {; 8463 BufferEmpty();; 8464 delete [] fBuffer;; 8465 fBuffer = nullptr;; 8466 }; 8467 i",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:331506,Testability,log,log,331506,"to return one contour only; 8412 ; 8413Int_t TH1::GetContour(Double_t *levels); 8414{; 8415 Int_t nlevels = fContour.fN;; 8416 if (levels) {; 8417 if (nlevels == 0) {; 8418 nlevels = 20;; 8419 SetContour(nlevels);; 8420 } else {; 8421 if (TestBit(kUserContour) == 0) SetContour(nlevels);; 8422 }; 8423 for (Int_t level=0; level<nlevels; level++) levels[level] = fContour.fArray[level];; 8424 }; 8425 return nlevels;; 8426}; 8427 ; 8428////////////////////////////////////////////////////////////////////////////////; 8429/// Return value of contour number level.; 8430/// Use GetContour to return the array of all contour levels; 8431 ; 8432Double_t TH1::GetContourLevel(Int_t level) const; 8433{; 8434 return (level >= 0 && level < fContour.fN) ? fContour.fArray[level] : 0.0;; 8435}; 8436 ; 8437////////////////////////////////////////////////////////////////////////////////; 8438/// Return the value of contour number ""level"" in Pad coordinates.; 8439/// ie: if the Pad is in log scale along Z it returns le log of the contour level; 8440/// value. See GetContour to return the array of all contour levels; 8441 ; 8442Double_t TH1::GetContourLevelPad(Int_t level) const; 8443{; 8444 if (level <0 || level >= fContour.fN) return 0;; 8445 Double_t zlevel = fContour.fArray[level];; 8446 ; 8447 // In case of user defined contours and Pad in log scale along Z,; 8448 // fContour.fArray doesn't contain the log of the contour whereas it does; 8449 // in case of equidistant contours.; 8450 if (gPad && gPad->GetLogz() && TestBit(kUserContour)) {; 8451 if (zlevel <= 0) return 0;; 8452 zlevel = TMath::Log10(zlevel);; 8453 }; 8454 return zlevel;; 8455}; 8456 ; 8457////////////////////////////////////////////////////////////////////////////////; 8458/// Set the maximum number of entries to be kept in the buffer.; 8459 ; 8460void TH1::SetBuffer(Int_t buffersize, Option_t * /*option*/); 8461{; 8462 if (fBuffer) {; 8463 BufferEmpty();; 8464 delete [] fBuffer;; 8465 fBuffer = nullptr;; 8466 }; 8467 i",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:331837,Testability,log,log,331837,"vel<nlevels; level++) levels[level] = fContour.fArray[level];; 8424 }; 8425 return nlevels;; 8426}; 8427 ; 8428////////////////////////////////////////////////////////////////////////////////; 8429/// Return value of contour number level.; 8430/// Use GetContour to return the array of all contour levels; 8431 ; 8432Double_t TH1::GetContourLevel(Int_t level) const; 8433{; 8434 return (level >= 0 && level < fContour.fN) ? fContour.fArray[level] : 0.0;; 8435}; 8436 ; 8437////////////////////////////////////////////////////////////////////////////////; 8438/// Return the value of contour number ""level"" in Pad coordinates.; 8439/// ie: if the Pad is in log scale along Z it returns le log of the contour level; 8440/// value. See GetContour to return the array of all contour levels; 8441 ; 8442Double_t TH1::GetContourLevelPad(Int_t level) const; 8443{; 8444 if (level <0 || level >= fContour.fN) return 0;; 8445 Double_t zlevel = fContour.fArray[level];; 8446 ; 8447 // In case of user defined contours and Pad in log scale along Z,; 8448 // fContour.fArray doesn't contain the log of the contour whereas it does; 8449 // in case of equidistant contours.; 8450 if (gPad && gPad->GetLogz() && TestBit(kUserContour)) {; 8451 if (zlevel <= 0) return 0;; 8452 zlevel = TMath::Log10(zlevel);; 8453 }; 8454 return zlevel;; 8455}; 8456 ; 8457////////////////////////////////////////////////////////////////////////////////; 8458/// Set the maximum number of entries to be kept in the buffer.; 8459 ; 8460void TH1::SetBuffer(Int_t buffersize, Option_t * /*option*/); 8461{; 8462 if (fBuffer) {; 8463 BufferEmpty();; 8464 delete [] fBuffer;; 8465 fBuffer = nullptr;; 8466 }; 8467 if (buffersize <= 0) {; 8468 fBufferSize = 0;; 8469 return;; 8470 }; 8471 if (buffersize < 100) buffersize = 100;; 8472 fBufferSize = 1 + buffersize*(fDimension+1);; 8473 fBuffer = new Double_t[fBufferSize];; 8474 memset(fBuffer, 0, sizeof(Double_t)*fBufferSize);; 8475}; 8476 ; 8477/////////////////////////////////////////",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:331901,Testability,log,log,331901,"8428////////////////////////////////////////////////////////////////////////////////; 8429/// Return value of contour number level.; 8430/// Use GetContour to return the array of all contour levels; 8431 ; 8432Double_t TH1::GetContourLevel(Int_t level) const; 8433{; 8434 return (level >= 0 && level < fContour.fN) ? fContour.fArray[level] : 0.0;; 8435}; 8436 ; 8437////////////////////////////////////////////////////////////////////////////////; 8438/// Return the value of contour number ""level"" in Pad coordinates.; 8439/// ie: if the Pad is in log scale along Z it returns le log of the contour level; 8440/// value. See GetContour to return the array of all contour levels; 8441 ; 8442Double_t TH1::GetContourLevelPad(Int_t level) const; 8443{; 8444 if (level <0 || level >= fContour.fN) return 0;; 8445 Double_t zlevel = fContour.fArray[level];; 8446 ; 8447 // In case of user defined contours and Pad in log scale along Z,; 8448 // fContour.fArray doesn't contain the log of the contour whereas it does; 8449 // in case of equidistant contours.; 8450 if (gPad && gPad->GetLogz() && TestBit(kUserContour)) {; 8451 if (zlevel <= 0) return 0;; 8452 zlevel = TMath::Log10(zlevel);; 8453 }; 8454 return zlevel;; 8455}; 8456 ; 8457////////////////////////////////////////////////////////////////////////////////; 8458/// Set the maximum number of entries to be kept in the buffer.; 8459 ; 8460void TH1::SetBuffer(Int_t buffersize, Option_t * /*option*/); 8461{; 8462 if (fBuffer) {; 8463 BufferEmpty();; 8464 delete [] fBuffer;; 8465 fBuffer = nullptr;; 8466 }; 8467 if (buffersize <= 0) {; 8468 fBufferSize = 0;; 8469 return;; 8470 }; 8471 if (buffersize < 100) buffersize = 100;; 8472 fBufferSize = 1 + buffersize*(fDimension+1);; 8473 fBuffer = new Double_t[fBufferSize];; 8474 memset(fBuffer, 0, sizeof(Double_t)*fBufferSize);; 8475}; 8476 ; 8477////////////////////////////////////////////////////////////////////////////////; 8478/// Set the number and values of contour levels.; 8479///; 8480",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:414017,Testability,test,testStat,414017,"3; gROOT#define gROOTDefinition TROOT.h:406; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; Printfvoid Printf(const char *fmt,...)Formats a string in a circular formatting buffer and prints the string.Definition TString.cxx:2503; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TVectorD.h; TVectorF.h; TVirtualFFT.h; TVirtualFitter.h; TVirtualHistPainter.h; R__LOCKGUARD#define R__LOCKGUARD(mutex)Definition TVirtualMutex.h:95; TVirtualPad.h; gPad#define gPadDefinition TVirtualPad.h:308; TVirtualPaveStats.h; R__WRITE_LOCKGUARD#define R__WRITE_LOCKGUARD(mutex)Definition TVirtualRWMutex.h:157; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::DataRangeclass describing the range in the coordinates it supports multiple range in a coordinate.Definition DataRange.h:35; ROOT::Math::GoFTest::AndersonDarling2SamplesTestvoid AndersonDarling2SamplesTest(Double_t &pvalue, Double_t &testStat) constPerforms the Anderson-Darling 2-Sample Test.Definition GoFTest.cxx:646; ROOT::Math::MinimizerOptionsMinimizer options.Definition MinimizerOptions.h:40; TArrayCArray of chars or bytes (8 bits per element).Definition TArrayC.h:27; TArrayC::fArrayChar_t * fArrayDefinition TArrayC.h:30; TArrayC::Resetvoid Reset(Char_t val=0)Definition TArrayC.h:47; TArrayC::Setvoid Set(Int_t n) overrideSet size of this array to n chars.Definition TArrayC.cxx:105; TArrayDArray of doubles (64 bits per element).Definition TArrayD.h:27; TArrayD::GetAtDouble_t GetAt(Int_t i) const overrideDefinition TArrayD.h:45; TArrayD::fArrayDouble_t * fArrayDefinition TArrayD.h:30; TArrayD::Streamervoid Streamer(TBuffer &) overrideStream a TArrayD object.Definition TArrayD.cxx:149; TArrayD::Copyvoid Copy(TArrayD &array) constDefinition TArrayD.h:42; TArrayD::Setvoid Set(Int_t n) overrideSet size of this array to n doubles.Definition TArrayD.cxx:106; TArrayD::GetArrayconst Double_t ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:426526,Testability,test,tested,426526,"ion.Definition TCollection.cxx:195; TCollection::IsEmptyvirtual Bool_t IsEmpty() constDefinition TCollection.h:188; TCollection::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an collection using the Streamer facility.Definition TCollection.cxx:263; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::Appendvirtual void Append(TObject *obj, Bool_t replace=kFALSE)Append object to this directory.Definition TDirectory.cxx:199; TDirectory::Removevirtual TObject * Remove(TObject *)Remove an object from the in-memory list.Definition TDirectory.cxx:1212; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TF11-Dim function classDefinition TF1.h:233; TF1::RejectPointstatic void RejectPoint(Bool_t reject=kTRUE)Static function to set the global flag to reject points the fgRejectPoint global flag is tested by al...Definition TF1.cxx:3683; TF1::GetHistogramvirtual TH1 * GetHistogram() constReturn a pointer to the histogram used to visualise the function Note that this histogram is managed ...Definition TF1.cxx:1584; TF1::Classstatic TClass * Class(); TF1::GetNparvirtual Int_t GetNpar() constDefinition TF1.h:509; TF1::Integralvirtual Double_t Integral(Double_t a, Double_t b, Double_t epsrel=1.e-12)IntegralOneDim or analytical integral.Definition TF1.cxx:2531; TF1::InitArgsvirtual void InitArgs(const Double_t *x, const Double_t *params)Initialize parameters addresses.Definition TF1.cxx:2482; TF1::GetRangevirtual void GetRange(Double_t *xmin, Double_t *xmax) constReturn range of a generic N-D function.Definition TF1.cxx:2281; TF1::EvalParvirtual Double_t EvalPar(const Double_t *x, const Double_t *params=nullptr)Evaluate function with given coordinates and parameters.Definition TF1.cxx:1468; TF1::SetParLimitsvirtual",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:437944,Testability,test,test,437944," of weight*X*X.Definition TH1.h:99; TH1::GetStdDevvirtual Double_t GetStdDev(Int_t axis=1) constReturns the Standard Deviation (Sigma).Definition TH1.cxx:7607; TH1::TH1TH1()Histogram default constructor.Definition TH1.cxx:615; TH1::TransformHistostatic TH1 * TransformHisto(TVirtualFFT *fft, TH1 *h_output, Option_t *option)For a given transform (first parameter), fills the histogram (second parameter) with the transform ou...Definition TH1.cxx:9319; TH1::UseCurrentStylevoid UseCurrentStyle() overrideCopy current attributes from/to current style.Definition TH1.cxx:7469; TH1::LabelsOptionvirtual void LabelsOption(Option_t *option=""h"", Option_t *axis=""X"")Sort bins with labels or set option(s) to draw axis with labels.Definition TH1.cxx:5382; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::fBarOffsetShort_t fBarOffset(1000*offset) for bar charts or legosDefinition TH1.h:93; TH1::Chi2TestXvirtual Double_t Chi2TestX(const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) constThe computation routine of the Chisquare test.Definition TH1.cxx:2067; TH1::CheckBinLimitsstatic bool CheckBinLimits(const TAxis *a1, const TAxis *a2)Check bin limits.Definition TH1.cxx:1541; TH1::AddBinContentvirtual void AddBinContent(Int_t bin)Increment bin content by 1.Definition TH1.cxx:1268; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associated to bin number bin.Definition TH1.cxx:9063; TH1::FitOptionsMakestatic Int_t FitOptionsMake(Option_t *option, Foption_t &Foption)Decode string choptin and fill fitOption structure.Definition TH1.cxx:4652; TH1::GetNbinsZvirtual Int_t GetNbinsZ() constDefinition TH1.h:299; TH1::GetNormFactorvirtual Double_t GetNormFactor() constDefinition TH1.h:301; TH1::GetMeanvirtual Double_t GetMean(Int_t axis=1) constFor axis = 1,2 or 3 returns the mean value of the histogram along X,Y or Z axis.Definition TH1.cxx:7535; TH1::GetSkewnessvirtual Double_t GetSkewness",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:451162,Testability,test,test,451162,"he histogram axes extendable / not extendable according to the bit mask returns the previous bi...Definition TH1.cxx:6649; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::DrawCopyvirtual TH1 * DrawCopy(Option_t *option="""", const char *name_postfix=""_copy"") constCopy this histogram and Draw in the current pad.Definition TH1.cxx:3113; TH1::IsEmptyBool_t IsEmpty() constCheck if a histogram is empty (this is a protected method used mainly by TH1Merger )Definition TH1.cxx:5164; TH1::GetMeanErrorvirtual Double_t GetMeanError(Int_t axis=1) constReturn standard error of mean of this histogram along the X axis.Definition TH1.cxx:7575; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::AndersonDarlingTestvirtual Double_t AndersonDarlingTest(const TH1 *h2, Option_t *option="""") constStatistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling ...Definition TH1.cxx:8062; TH1::ResetStatsvirtual void ResetStats()Reset the statistics including the number of entries and replace with values calculated from bin cont...Definition TH1.cxx:7902; TH1::SetDefaultBufferSizestatic void SetDefaultBufferSize(Int_t buffersize=1000)Static function to set the default buffer size for automatic histograms.Definition TH1.cxx:6693; TH1::SetBinErrorOptionvirtual void SetBinErrorOption(EBinErrorOpt type)Definition TH1.h:381; TH1::SetBuffervirtual void SetBuffer(Int_t buffersize, Option_t *option="""")Set the maximum number of entries to be kept in the buffer.Definition TH1.cxx:8458; TH1::DrawPanelvirtual void DrawPanel()Display a panel with all histogram drawing options.Definition TH1.cxx:3175; TH1::GetRandomvirtual Double_t GetRandom(TRandom *rng=nullptr) constReturn a random number distributed according the histogram bin contents.Definition TH1",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:458736,Testability,test,test,458736,"*f1, Double_t c1=1)Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:2840; TH1::GetMinimumvirtual Double_t GetMinimum(Double_t minval=-FLT_MAX) constReturn minimum value larger than minval of bins in the range, unless the value has been overridden by...Definition TH1.cxx:8635; TH1::LoggedInconsistencyint LoggedInconsistency(const char *name, const TH1 *h1, const TH1 *h2, bool useMerge=false) constDefinition TH1.cxx:883; TH1::CheckConsistentSubAxesstatic bool CheckConsistentSubAxes(const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0)Check that two sub axis are the same.Definition TH1.cxx:1640; TH1::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove object from the list of functions.Definition TH1.cxx:6576; TH1::fYaxisTAxis fYaxisY axis descriptor.Definition TH1.h:91; TH1::KolmogorovTestvirtual Double_t KolmogorovTest(const TH1 *h2, Option_t *option="""") constStatistical test of compatibility in shape between this histogram and h2, using Kolmogorov test.Definition TH1.cxx:8178; TH1::GetSumOfWeightsvirtual Double_t GetSumOfWeights() constReturn the sum of weights excluding under/overflows.Definition TH1.cxx:7917; TH1::SmoothArraystatic void SmoothArray(Int_t NN, Double_t *XX, Int_t ntimes=1)Smooth array xx, translation of Hbook routine hsmoof.F.Definition TH1.cxx:6768; TH1::GetCentervirtual void GetCenter(Double_t *center) constFill array with center of bins for 1D histogram Better to use h1.GetXaxis()->GetCenter(center)Definition TH1.cxx:9174; TH1::fPainterTVirtualHistPainter * fPainter! Pointer to histogram painterDefinition TH1.h:112; TH1::SetBinsvirtual void SetBins(Int_t nx, Double_t xmin, Double_t xmax)Redefine x axis parameters.Definition TH1.cxx:8767; TH1::FindFixBinvirtual Int_t FindFixBin(Double_t x, Double_t y=0, Double_t z=0) constReturn Global bin number corresponding to x,y,z.Definition TH1.cxx:3705; TH1::Sumw2virtual void Sum",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:458815,Testability,test,test,458815,"*f1, Double_t c1=1)Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:2840; TH1::GetMinimumvirtual Double_t GetMinimum(Double_t minval=-FLT_MAX) constReturn minimum value larger than minval of bins in the range, unless the value has been overridden by...Definition TH1.cxx:8635; TH1::LoggedInconsistencyint LoggedInconsistency(const char *name, const TH1 *h1, const TH1 *h2, bool useMerge=false) constDefinition TH1.cxx:883; TH1::CheckConsistentSubAxesstatic bool CheckConsistentSubAxes(const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0)Check that two sub axis are the same.Definition TH1.cxx:1640; TH1::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove object from the list of functions.Definition TH1.cxx:6576; TH1::fYaxisTAxis fYaxisY axis descriptor.Definition TH1.h:91; TH1::KolmogorovTestvirtual Double_t KolmogorovTest(const TH1 *h2, Option_t *option="""") constStatistical test of compatibility in shape between this histogram and h2, using Kolmogorov test.Definition TH1.cxx:8178; TH1::GetSumOfWeightsvirtual Double_t GetSumOfWeights() constReturn the sum of weights excluding under/overflows.Definition TH1.cxx:7917; TH1::SmoothArraystatic void SmoothArray(Int_t NN, Double_t *XX, Int_t ntimes=1)Smooth array xx, translation of Hbook routine hsmoof.F.Definition TH1.cxx:6768; TH1::GetCentervirtual void GetCenter(Double_t *center) constFill array with center of bins for 1D histogram Better to use h1.GetXaxis()->GetCenter(center)Definition TH1.cxx:9174; TH1::fPainterTVirtualHistPainter * fPainter! Pointer to histogram painterDefinition TH1.h:112; TH1::SetBinsvirtual void SetBins(Int_t nx, Double_t xmin, Double_t xmax)Redefine x axis parameters.Definition TH1.cxx:8767; TH1::FindFixBinvirtual Int_t FindFixBin(Double_t x, Double_t y=0, Double_t z=0) constReturn Global bin number corresponding to x,y,z.Definition TH1.cxx:3705; TH1::Sumw2virtual void Sum",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:476704,Testability,log,logarithm,476704,"MathBase.h:250; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf...Definition TMath.cxx:637; TMath::MedianDouble_t Median(Long64_t n, const T *a, const Double_t *w=nullptr, Long64_t *work=nullptr)Same as RMS.Definition TMath.h:1272; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::ATanDouble_t ATan(Double_t)Returns the principal value of the arc tangent of x, expressed in radians.Definition TMath.h:640; TMath::CeilDouble_t Ceil(Double_t x)Rounds x upward, returning the smallest integral value that is not less than x.Definition TMath.h:668; TMath::MinElementT MinElement(Long64_t n, const T *a)Returns minimum of array a of length n.Definition TMath.h:960; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::AreEqualRelBool_t AreEqualRel(Double_t af, Double_t bf, Double_t relPrec)Comparing floating points.Definition TMath.h:426; TMath::AreEqualAbsBool_t AreEqualAbs(Double_t af, Double_t bf, Double_t epsilon)Comparing floating points.Definition TMath.h:418; TMath::KolmogorovProbDouble_t KolmogorovProb(Double_t z)Calculates the Kolmogorov distribution function,.Definition TMath.cxx:679; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:477902,Testability,log,logarithm,477902,"x.Definition TMath.h:668; TMath::MinElementT MinElement(Long64_t n, const T *a)Returns minimum of array a of length n.Definition TMath.h:960; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::AreEqualRelBool_t AreEqualRel(Double_t af, Double_t bf, Double_t relPrec)Comparing floating points.Definition TMath.h:426; TMath::AreEqualAbsBool_t AreEqualAbs(Double_t af, Double_t bf, Double_t epsilon)Comparing floating points.Definition TMath.h:418; TMath::KolmogorovProbDouble_t KolmogorovProb(Double_t z)Calculates the Kolmogorov distribution function,.Definition TMath.cxx:679; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TMath::InfinityDouble_t Infinity()Returns an infinity as defined by the IEEE standard.Definition TMath.h:917; v@ vDefinition rootcling_impl.cxx:3699; Foption_tDefinition Foption.h:24; Drawth1 Draw(); mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. histhistsrcTH1.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:20399,Usability,usab,usable,20399,"rom a gaussian"", 100, -3, 3);; 446 h1.FillRandom(""gaus"", 10000);; 447~~~; 448 TH1::GetRandom can be used to return a random number distributed; 449 according to the contents of a histogram.; 450 ; 451\anchor making-a-copy; 452### Making a copy of a histogram; 453 Like for any other ROOT object derived from TObject, one can use; 454 the Clone() function. This makes an identical copy of the original; 455 histogram including all associated errors and functions, e.g.:; 456~~~ {.cpp}; 457 TH1F *hnew = (TH1F*)h->Clone(""hnew"");; 458~~~; 459 ; 460\anchor normalizing; 461### Normalizing histograms; 462 ; 463 One can scale a histogram such that the bins integral is equal to; 464 the normalization parameter via TH1::Scale(Double_t norm), where norm; 465 is the desired normalization divided by the integral of the histogram.; 466 ; 467 ; 468\anchor drawing-histograms; 469## Drawing histograms; 470 ; 471 Histograms are drawn via the THistPainter class. Each histogram has; 472 a pointer to its own painter (to be usable in a multithreaded program).; 473 Many drawing options are supported.; 474 See THistPainter::Paint() for more details.; 475 ; 476 The same histogram can be drawn with different options in different pads.; 477 When a histogram drawn in a pad is deleted, the histogram is; 478 automatically removed from the pad or pads where it was drawn.; 479 If a histogram is drawn in a pad, then filled again, the new status; 480 of the histogram will be automatically shown in the pad next time; 481 the pad is updated. One does not need to redraw the histogram.; 482 To draw the current version of a histogram in a pad, one can use; 483~~~ {.cpp}; 484 h->DrawCopy();; 485~~~; 486 This makes a clone (see Clone below) of the histogram. Once the clone; 487 is drawn, the original histogram may be modified or deleted without; 488 affecting the aspect of the clone.; 489 ; 490 One can use TH1::SetMaximum() and TH1::SetMinimum() to force a particular; 491 value for the maximum or the minimum sc",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:49262,Usability,simpl,simple,49262,"ewtopic.php?f=3&t=13299; 1215 if (e1sq) w1 = 1./ e1sq;; 1216 else if (h1->fSumw2.fN) {; 1217 w1 = 1.E200; // use an arbitrary huge value; 1218 if (y1 == 0 ) { // use an estimated error from the global histogram scale; 1219 double sf = (s1[0] != 0) ? s1[1]/s1[0] : 1;; 1220 w1 = 1./(sf*sf);; 1221 }; 1222 }; 1223 if (e2sq) w2 = 1./ e2sq;; 1224 else if (h2->fSumw2.fN) {; 1225 w2 = 1.E200; // use an arbitrary huge value; 1226 if (y2 == 0) { // use an estimated error from the global histogram scale; 1227 double sf = (s2[0] != 0) ? s2[1]/s2[0] : 1;; 1228 w2 = 1./(sf*sf);; 1229 }; 1230 }; 1231 ; 1232 double y = (w1*y1 + w2*y2)/(w1 + w2);; 1233 UpdateBinContent(i, y);; 1234 if (fSumw2.fN) {; 1235 double err2 = 1./(w1 + w2);; 1236 if (err2 < 1.E-200) err2 = 0; // to remove arbitrary value when e1=0 AND e2=0; 1237 fSumw2.fArray[i] = err2;; 1238 }; 1239 }; 1240 } else { // case of simple histogram addition; 1241 Double_t c1sq = c1 * c1;; 1242 Double_t c2sq = c2 * c2;; 1243 for (Int_t i = 0; i < fNcells; ++i) { // Loop on cells (bins including underflows/overflows); 1244 UpdateBinContent(i, c1 * h1->RetrieveBinContent(i) + c2 * h2->RetrieveBinContent(i));; 1245 if (fSumw2.fN) {; 1246 fSumw2.fArray[i] = c1sq * h1->GetBinErrorSqUnchecked(i) + c2sq * h2->GetBinErrorSqUnchecked(i);; 1247 }; 1248 }; 1249 }; 1250 ; 1251 if (resetStats) {; 1252 // statistics need to be reset in case coefficient are negative; 1253 ResetStats();; 1254 }; 1255 else {; 1256 // update statistics (do here to avoid changes by SetBinContent) FIXME remove???; 1257 PutStats(s3);; 1258 SetEntries(nEntries);; 1259 }; 1260 ; 1261 return kTRUE;; 1262}; 1263 ; 1264////////////////////////////////////////////////////////////////////////////////; 1265/// Increment bin content by 1.; 1266/// Passing an out-of-range bin leads to undefined behavior; 1267 ; 1268void TH1::AddBinContent(Int_t); 1269{; 1270 AbstractMethod(""AddBinContent"");; 1271}; 1272 ; 1273////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:72570,Usability,simpl,simple,72570," a significant overall \f$ \chi^{2} \f$ value. Most convenient for; 1822/// analysis are the adjusted (normalized) residuals [4]; 1823/// \f[; 1824/// r_{i} = \frac{n_{i}-N\hat{p}_{i}}{\sqrt{N\hat{p}_{i}}\sqrt{(1-N/(N+M))(1-(n_{i}+m_{i})/(N+M))}}; 1825/// \f]; 1826/// If hypotheses of homogeneity are valid then residuals ri are; 1827/// approximately independent and identically distributed random variables; 1828/// having N(0,1) distribution. The application of the \f$ \chi^{2} \f$ test has; 1829/// restrictions related to the value of the expected frequencies Npi,; 1830/// Mpi, i=1,...,r. A conservative rule formulated in [5] is that all the; 1831/// expectations must be 1 or greater for both histograms. In practical; 1832/// cases when expected frequencies are not known the estimated expected; 1833/// frequencies \f$ M\hat{p}_{i}, N\hat{p}_{i}, i=1,...,r \f$ can be used.; 1834///; 1835/// #### Unweighted and weighted histograms comparison:; 1836///; 1837/// A simple modification of the ideas described above can be used for the; 1838/// comparison of the usual (unweighted) and weighted histograms. Let us; 1839/// denote the number of events in the ith bin in the unweighted; 1840/// histogram as ni and the common weight of events in the ith bin of the; 1841/// weighted histogram as wi. The total number of events in the; 1842/// unweighted histogram is equal to; 1843///\f[; 1844/// N = \sum_{i=1}^{r} n_{i}; 1845///\f]; 1846/// and the total weight of events in the weighted histogram is equal to; 1847///\f[; 1848/// W = \sum_{i=1}^{r} w_{i}; 1849///\f]; 1850/// Let us formulate the hypothesis of identity of an unweighted histogram; 1851/// to a weighted histogram so that there exist r constants p1,...,pr, such; 1852/// that; 1853///\f[; 1854/// \sum_{i=1}^{r} p_{i} = 1; 1855///\f]; 1856/// for the unweighted histogram. The weight wi is a random variable with a; 1857/// distribution approximated by the normal probability distribution; 1858/// \f$ N(Wp_{i},\sigma_{i}^{2",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:99962,Usability,clear,cleared,99962,"Option_t *option) const; 2499{; 2500 if (!func) {; 2501 Error(""Chisquare"",""Function pointer is Null - return -1"");; 2502 return -1;; 2503 }; 2504 ; 2505 TString opt(option); opt.ToUpper();; 2506 bool useRange = opt.Contains(""R"");; 2507 ROOT::Fit::EChisquareType type = ROOT::Fit::EChisquareType::kNeyman; // default chi2 with observed error; 2508 if (opt.Contains(""L"")) type = ROOT::Fit::EChisquareType::kPLikeRatio;; 2509 else if (opt.Contains(""P"")) type = ROOT::Fit::EChisquareType::kPearson;; 2510 ; 2511 return ROOT::Fit::Chisquare(*this, *func, useRange, type);; 2512}; 2513 ; 2514////////////////////////////////////////////////////////////////////////////////; 2515/// Remove all the content from the underflow and overflow bins, without changing the number of entries; 2516/// After calling this method, every undeflow and overflow bins will have content 0.0; 2517/// The Sumw2 is also cleared, since there is no more content in the bins; 2518 ; 2519void TH1::ClearUnderflowAndOverflow(); 2520{; 2521 for (Int_t bin = 0; bin < fNcells; ++bin); 2522 if (IsBinUnderflow(bin) || IsBinOverflow(bin)) {; 2523 UpdateBinContent(bin, 0.0);; 2524 if (fSumw2.fN) fSumw2.fArray[bin] = 0.0;; 2525 }; 2526}; 2527 ; 2528////////////////////////////////////////////////////////////////////////////////; 2529/// Compute integral (normalized cumulative sum of bins) w/o under/overflows; 2530/// The result is stored in fIntegral and used by the GetRandom functions.; 2531/// This function is automatically called by GetRandom when the fIntegral; 2532/// array does not exist or when the number of entries in the histogram; 2533/// has changed since the previous call to GetRandom.; 2534/// The resulting integral is normalized to 1.; 2535/// If the routine is called with the onlyPositive flag set an error will; 2536/// be produced in case of negative bin content and a NaN value returned; 2537/// \return 1 if success, 0 if integral is zero, NAN if onlyPositive-test fails; 2538 ; 2539Double_t TH1::ComputeIn",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:112111,Usability,simpl,simple,112111,"3 return obj;; 2794}; 2795 ; 2796////////////////////////////////////////////////////////////////////////////////; 2797/// Perform the automatic addition of the histogram to the given directory; 2798///; 2799/// Note this function is called in place when the semantic requires; 2800/// this object to be added to a directory (I.e. when being read from; 2801/// a TKey or being Cloned); 2802 ; 2803void TH1::DirectoryAutoAdd(TDirectory *dir); 2804{; 2805 Bool_t addStatus = TH1::AddDirectoryStatus();; 2806 if (addStatus) {; 2807 SetDirectory(dir);; 2808 if (dir) {; 2809 ResetBit(kCanDelete);; 2810 }; 2811 }; 2812}; 2813 ; 2814////////////////////////////////////////////////////////////////////////////////; 2815/// Compute distance from point px,py to a line.; 2816///; 2817/// Compute the closest distance of approach from point px,py to elements; 2818/// of a histogram.; 2819/// The distance is computed in pixels units.; 2820///; 2821/// #### Algorithm:; 2822/// Currently, this simple model computes the distance from the mouse; 2823/// to the histogram contour only.; 2824 ; 2825Int_t TH1::DistancetoPrimitive(Int_t px, Int_t py); 2826{; 2827 if (!fPainter) return 9999;; 2828 return fPainter->DistancetoPrimitive(px,py);; 2829}; 2830 ; 2831////////////////////////////////////////////////////////////////////////////////; 2832/// Performs the operation: `this = this/(c1*f1)`; 2833/// if errors are defined (see TH1::Sumw2), errors are also recalculated.; 2834///; 2835/// Only bins inside the function range are recomputed.; 2836/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 2837/// you should call Sumw2 before making this operation.; 2838/// This is particularly important if you fit the histogram after TH1::Divide; 2839///; 2840/// The function return kFALSE if the divide operation failed; 2841 ; 2842Bool_t TH1::Divide(TF1 *f1, Double_t c1); 2843{; 2844 if (!f1) {; 2845 Error(""Divide"",""Attempt to divide by a non-existing function"");; 2846 return kFALS",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:120756,Usability,usab,usable,120756,"; // old formula from G. Flucke; 3018 // formula which works also for weighted histogram (see http://root-forum.cern.ch/viewtopic.php?t=3753 ); 3019 fSumw2.fArray[i] = TMath::Abs( ( (1. - 2.* b1 / b2) * e1sq + b1sq * e2sq / b2sq ) / b2sq );; 3020 } else {; 3021 //in case b1=b2 error is zero; 3022 //use TGraphAsymmErrors::BayesDivide for getting the asymmetric error not equal to zero; 3023 fSumw2.fArray[i] = 0;; 3024 }; 3025 } else {; 3026 fSumw2.fArray[i] = c1sq * c2sq * (e1sq * b2sq + e2sq * b1sq) / (c2sq * c2sq * b2sq * b2sq);; 3027 }; 3028 }; 3029 }; 3030 ResetStats();; 3031 if (binomial); 3032 // in case of binomial division use denominator for number of entries; 3033 SetEntries ( h2->GetEntries() );; 3034 ; 3035 return kTRUE;; 3036}; 3037 ; 3038////////////////////////////////////////////////////////////////////////////////; 3039/// Draw this histogram with options.; 3040///; 3041/// Histograms are drawn via the THistPainter class. Each histogram has; 3042/// a pointer to its own painter (to be usable in a multithreaded program).; 3043/// The same histogram can be drawn with different options in different pads.; 3044/// When a histogram drawn in a pad is deleted, the histogram is; 3045/// automatically removed from the pad or pads where it was drawn.; 3046/// If a histogram is drawn in a pad, then filled again, the new status; 3047/// of the histogram will be automatically shown in the pad next time; 3048/// the pad is updated. One does not need to redraw the histogram.; 3049/// To draw the current version of a histogram in a pad, one can use; 3050/// `h->DrawCopy();`; 3051/// This makes a clone of the histogram. Once the clone is drawn, the original; 3052/// histogram may be modified or deleted without affecting the aspect of the; 3053/// clone.; 3054/// By default, TH1::Draw clears the current pad.; 3055///; 3056/// One can use TH1::SetMaximum and TH1::SetMinimum to force a particular; 3057/// value for the maximum or the minimum scale on the plot.; 3058///; ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:121554,Usability,clear,clears,121554,"////////////////////////////////; 3039/// Draw this histogram with options.; 3040///; 3041/// Histograms are drawn via the THistPainter class. Each histogram has; 3042/// a pointer to its own painter (to be usable in a multithreaded program).; 3043/// The same histogram can be drawn with different options in different pads.; 3044/// When a histogram drawn in a pad is deleted, the histogram is; 3045/// automatically removed from the pad or pads where it was drawn.; 3046/// If a histogram is drawn in a pad, then filled again, the new status; 3047/// of the histogram will be automatically shown in the pad next time; 3048/// the pad is updated. One does not need to redraw the histogram.; 3049/// To draw the current version of a histogram in a pad, one can use; 3050/// `h->DrawCopy();`; 3051/// This makes a clone of the histogram. Once the clone is drawn, the original; 3052/// histogram may be modified or deleted without affecting the aspect of the; 3053/// clone.; 3054/// By default, TH1::Draw clears the current pad.; 3055///; 3056/// One can use TH1::SetMaximum and TH1::SetMinimum to force a particular; 3057/// value for the maximum or the minimum scale on the plot.; 3058///; 3059/// TH1::UseCurrentStyle can be used to change all histogram graphics; 3060/// attributes to correspond to the current selected style.; 3061/// This function must be called for each histogram.; 3062/// In case one reads and draws many histograms from a file, one can force; 3063/// the histograms to inherit automatically the current graphics style; 3064/// by calling before gROOT->ForceStyle();; 3065///; 3066/// See the THistPainter class for a description of all the drawing options.; 3067 ; 3068void TH1::Draw(Option_t *option); 3069{; 3070 TString opt1 = option; opt1.ToLower();; 3071 TString opt2 = option;; 3072 Int_t index = opt1.Index(""same"");; 3073 ; 3074 // Check if the string ""same"" is part of a TCutg name.; 3075 if (index>=0) {; 3076 Int_t indb = opt1.Index(""["");; 3077 if (indb>=0) {; 307",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:125209,Usability,clear,cleared,125209,"stfix);; 3122 TH1 *newth1 = (TH1 *)Clone(newName.Data());; 3123 newth1->SetDirectory(nullptr);; 3124 newth1->SetBit(kCanDelete);; 3125 if (gPad) gPad->IncrementPaletteColor(1, opt);; 3126 ; 3127 newth1->AppendPad(option);; 3128 return newth1;; 3129}; 3130 ; 3131////////////////////////////////////////////////////////////////////////////////; 3132/// Draw a normalized copy of this histogram.; 3133///; 3134/// A clone of this histogram is normalized to norm and drawn with option.; 3135/// A pointer to the normalized histogram is returned.; 3136/// The contents of the histogram copy are scaled such that the new; 3137/// sum of weights (excluding under and overflow) is equal to norm.; 3138/// Note that the returned normalized histogram is not added to the list; 3139/// of histograms in the current directory in memory.; 3140/// It is the user's responsibility to delete this histogram.; 3141/// The kCanDelete bit is set for the returned object. If a pad containing; 3142/// this copy is cleared, the histogram will be automatically deleted.; 3143///; 3144/// See Draw for the list of options; 3145 ; 3146TH1 *TH1::DrawNormalized(Option_t *option, Double_t norm) const; 3147{; 3148 Double_t sum = GetSumOfWeights();; 3149 if (sum == 0) {; 3150 Error(""DrawNormalized"",""Sum of weights is null. Cannot normalize histogram: %s"",GetName());; 3151 return nullptr;; 3152 }; 3153 Bool_t addStatus = TH1::AddDirectoryStatus();; 3154 TH1::AddDirectory(kFALSE);; 3155 TH1 *h = (TH1*)Clone();; 3156 h->SetBit(kCanDelete);; 3157 // in case of drawing with error options - scale correctly the error; 3158 TString opt(option); opt.ToUpper();; 3159 if (fSumw2.fN == 0) {; 3160 h->Sumw2();; 3161 // do not use in this case the ""Error option "" for drawing which is enabled by default since the normalized histogram has now errors; 3162 if (opt.IsNull() || opt == ""SAME"") opt += ""HIST"";; 3163 }; 3164 h->Scale(norm/sum);; 3165 if (TMath::Abs(fMaximum+1111) > 1e-3) h->SetMaximum(fMaximum*norm/sum);; 3166 if (TMa",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:142960,Usability,simpl,simply,142960,"lete [] integral;; 3570}; 3571 ; 3572////////////////////////////////////////////////////////////////////////////////; 3573/// Fill histogram following distribution in histogram h.; 3574///; 3575/// @param h : Histogram pointer used for sampling random number; 3576/// @param ntimes : number of times the histogram is filled; 3577/// @param rng : (optional) Random number generator used for sampling; 3578///; 3579/// The distribution contained in the histogram h (TH1) is integrated; 3580/// over the channel contents for the bin range of this histogram.; 3581/// It is normalized to 1.; 3582///; 3583/// Getting one random number implies:; 3584/// - Generating a random number between 0 and 1 (say r1); 3585/// - Look in which bin in the normalized integral r1 corresponds to; 3586/// - Fill histogram channel ntimes random numbers are generated; 3587///; 3588/// SPECIAL CASE when the target histogram has the same binning as the source.; 3589/// in this case we simply use a poisson distribution where; 3590/// the mean value per bin = bincontent/integral.; 3591 ; 3592void TH1::FillRandom(TH1 *h, Int_t ntimes, TRandom * rng); 3593{; 3594 if (!h) { Error(""FillRandom"", ""Null histogram""); return; }; 3595 if (fDimension != h->GetDimension()) {; 3596 Error(""FillRandom"", ""Histograms with different dimensions""); return;; 3597 }; 3598 if (std::isnan(h->ComputeIntegral(true))) {; 3599 Error(""FillRandom"", ""Histograms contains negative bins, does not represent probabilities"");; 3600 return;; 3601 }; 3602 ; 3603 //in case the target histogram has the same binning and ntimes much greater; 3604 //than the number of bins we can use a fast method; 3605 Int_t first = fXaxis.GetFirst();; 3606 Int_t last = fXaxis.GetLast();; 3607 Int_t nbins = last-first+1;; 3608 if (ntimes > 10*nbins) {; 3609 auto inconsistency = CheckConsistency(this,h);; 3610 if (inconsistency != kFullyConsistent) return; // do nothing; 3611 Double_t sumw = h->Integral(first,last);; 3612 if (sumw == 0) return;; 3613 Double_t s",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:176108,Usability,undo,undo,176108,"s a weight=1 for each bin (it is an unweighted least-square; 4238/// fit). When using option ""WW"" the empty bins will be also considered in the chi-square fit with an error of 1.; 4239/// Note that in this fitting case (option ""W"" or ""WW"") the resulting fitted parameter errors; 4240/// are corrected by the obtained chi2 value using this scaling expression:; 4241/// `errorp *= sqrt(chisquare/(ndf-1))` as it is done when fitting a TGraph with; 4242/// no point errors.; 4243///; 4244/// #### Excluding points; 4245///; 4246/// You can use TF1::RejectPoint inside your fitting function to exclude some points; 4247/// within a certain range from the fit. See the tutorial `fit/fitExclude.C`.; 4248///; 4249///; 4250/// #### Warning when using the option ""0""; 4251///; 4252/// When selecting the option ""0"", the fitted function is added to; 4253/// the list of functions of the histogram, but it is not drawn when the histogram is drawn.; 4254/// You can undo this behaviour resetting its corresponding bit in the TF1 object as following:; 4255///; 4256/// ~~~ {.cpp}; 4257/// h.Fit(""myFunction"", ""0""); // fit, store function but do not draw; 4258/// h.Draw(); // function is not drawn; 4259/// h.GetFunction(""myFunction"")->ResetBit(TF1::kNotDraw);; 4260/// h.Draw(); // function is visible again; 4261/// ~~~; 4262///; 4263 ; 4264TFitResultPtr TH1::Fit(TF1 *f1 ,Option_t *option ,Option_t *goption, Double_t xxmin, Double_t xxmax); 4265{; 4266 // implementation of Fit method is in file hist/src/HFitImpl.cxx; 4267 Foption_t fitOption;; 4268 ROOT::Fit::FitOptionsMake(ROOT::Fit::EFitObjectType::kHistogram,option,fitOption);; 4269 ; 4270 // create range and minimizer options with default values; 4271 ROOT::Fit::DataRange range(xxmin,xxmax);; 4272 ROOT::Math::MinimizerOptions minOption;; 4273 ; 4274 // need to empty the buffer before; 4275 // (t.b.d. do a ML unbinned fit with buffer data); 4276 if (fBuffer) BufferEmpty();; 4277 ; 4278 return ROOT::Fit::FitObject(this, f1 , fitOption , minOptio",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:306192,Usability,simpl,simply,306192,"785 Double_t w = GetBinContent(binx,biny,binz);; 7786 np+=w;; 7787 sum+=w*(x-mean)*(x-mean)*(x-mean)*(x-mean);; 7788 }; 7789 }; 7790 }; 7791 sum/=(np*stddev4);; 7792 return sum-3;; 7793 ; 7794 } else if (axis > 10 && axis <= 13) {; 7795 //compute standard error of skewness; 7796 // assume parent normal distribution use formula from Kendall-Stuart, Vol 1 pag 243, second edition; 7797 Double_t neff = GetEffectiveEntries();; 7798 return ( neff > 0 ? TMath::Sqrt(24./neff ) : 0. );; 7799 }; 7800 else {; 7801 Error(""GetKurtosis"", ""illegal value of parameter"");; 7802 return 0;; 7803 }; 7804}; 7805 ; 7806////////////////////////////////////////////////////////////////////////////////; 7807/// fill the array stats from the contents of this histogram; 7808/// The array stats must be correctly dimensioned in the calling program.; 7809///; 7810/// ~~~ {.cpp}; 7811/// stats[0] = sumw; 7812/// stats[1] = sumw2; 7813/// stats[2] = sumwx; 7814/// stats[3] = sumwx2; 7815/// ~~~; 7816///; 7817/// If no axis-subrange is specified (via TAxis::SetRange), the array stats; 7818/// is simply a copy of the statistics quantities computed at filling time.; 7819/// If a sub-range is specified, the function recomputes these quantities; 7820/// from the bin contents in the current axis range.; 7821///; 7822/// IMPORTANT NOTE: This means that the returned statistics are context-dependent.; 7823/// If TAxis::kAxisRange, the returned statistics are dependent on the binning;; 7824/// otherwise, they are a copy of the histogram statistics computed at fill time,; 7825/// which are unbinned by default (calling TH1::ResetStats forces them to use; 7826/// binned statistics). You can reset TAxis::kAxisRange using TAxis::SetRange(0, 0).; 7827///; 7828/// Note that the mean value/StdDev is computed using the bins in the currently; 7829/// defined range (see TAxis::SetRange). By default the range includes; 7830/// all bins from 1 to nbins included, excluding underflows and overflows.; 7831/// To force the un",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:352153,Usability,clear,clear,352153,""" object from the list of functions; 8998 if (fFunctions) {; 8999 TObject *obj = fFunctions->FindObject(""stats"");; 9000 if (obj) {; 9001 fFunctions->Remove(obj);; 9002 delete obj;; 9003 }; 9004 }; 9005 }; 9006}; 9007 ; 9008////////////////////////////////////////////////////////////////////////////////; 9009/// Create structure to store sum of squares of weights.; 9010///; 9011/// if histogram is already filled, the sum of squares of weights; 9012/// is filled with the existing bin contents; 9013///; 9014/// The error per bin will be computed as sqrt(sum of squares of weight); 9015/// for each bin.; 9016///; 9017/// This function is automatically called when the histogram is created; 9018/// if the static function TH1::SetDefaultSumw2 has been called before.; 9019/// If flag = false the structure containing the sum of the square of weights; 9020/// is rest and it will be empty, but it is not deleted (i.e. GetSumw2()->fN = 0); 9021 ; 9022void TH1::Sumw2(Bool_t flag); 9023{; 9024 if (!flag) {; 9025 // clear the array if existing - do nothing otherwise; 9026 if (fSumw2.fN > 0 ) fSumw2.Set(0);; 9027 return;; 9028 }; 9029 ; 9030 if (fSumw2.fN == fNcells) {; 9031 if (!fgDefaultSumw2 ); 9032 Warning(""Sumw2"",""Sum of squares of weights structure already created"");; 9033 return;; 9034 }; 9035 ; 9036 fSumw2.Set(fNcells);; 9037 ; 9038 // empty the buffer; 9039 if (fBuffer) BufferEmpty();; 9040 ; 9041 if (fEntries > 0); 9042 for (Int_t i = 0; i < fNcells; ++i); 9043 fSumw2.fArray[i] = TMath::Abs(RetrieveBinContent(i));; 9044}; 9045 ; 9046////////////////////////////////////////////////////////////////////////////////; 9047/// Return pointer to function with name.; 9048///; 9049///; 9050/// Functions such as TH1::Fit store the fitted function in the list of; 9051/// functions of this histogram.; 9052 ; 9053TF1 *TH1::GetFunction(const char *name) const; 9054{; 9055 return (TF1*)fFunctions->FindObject(name);; 9056}; 9057 ; 9058////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8h.html:543,Integrability,depend,dependency,543,". ROOT: hist/hist/inc/TH1.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Functions ; TH1.h File Reference. #include ""TAxis.h""; #include ""TAttLine.h""; #include ""TAttFill.h""; #include ""TAttMarker.h""; #include ""TArrayC.h""; #include ""TArrayS.h""; #include ""TArrayI.h""; #include ""TArrayL64.h""; #include ""TArrayF.h""; #include ""TArrayD.h""; #include ""Foption.h""; #include ""TVectorFfwd.h""; #include ""TVectorDfwd.h""; #include ""TFitResultPtr.h""; #include <cfloat>; #include <string>. Include dependency graph for TH1.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TH1;  TH1 is the base class of all histogram classes in ROOT. More...;  ; class  TH1C;  1-D histogram with a byte per channel (see TH1 documentation) More...;  ; class  TH1D;  1-D histogram with a double per channel (see TH1 documentation) More...;  ; class  TH1F;  1-D histogram with a float per channel (see TH1 documentation) More...;  ; class  TH1I;  1-D histogram with an int per channel (see TH1 documentation) More...;  ; class  TH1L;  1-D histogram with a long64 per channel (see TH1 documentation) More...;  ; class  TH1S;  1-D histogram with a short per channel (see TH1 documentation) More...;  . Functions; TH1C operator* (const TH1C &h1, const TH1C &h2);  Operator *. ;  ; TH1C operator* (const TH1C &h1, Double_t c1);  ; TH1D operator* (const TH1D &h1, const TH1D &h2);  Operator *. ;  ; TH1D operator* (const TH1D &h1, Double_t c1);  ; TH1F operator* (const TH1F &h1, const TH1F &h2);  Operator *. ;  ; TH1F operator* (const TH1F &h1, Double_t c1);  ; TH1I operator* (const TH1I &h1, const TH1I &h2);  Operator *. ;  ; TH1I operator* (const TH1I &h1, Double_t c1);  ; TH1L operator* (const TH1L &h1, const TH1L &h2);  Operator *. ;  ; TH1L operator* (const",MatchSource.WIKI,doc/master/TH1_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h.html
https://root.cern/doc/master/TH1_8h_source.html:1678,Availability,error,errors,1678,"*******************************/; 11 ; 12#ifndef ROOT_TH1; 13#define ROOT_TH1; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TH1 //; 19// //; 20// 1-Dim histogram base class. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TAxis.h""; 25 ; 26#include ""TAttLine.h""; 27 ; 28#include ""TAttFill.h""; 29 ; 30#include ""TAttMarker.h""; 31 ; 32#include ""TArrayC.h""; 33#include ""TArrayS.h""; 34#include ""TArrayI.h""; 35#include ""TArrayL64.h""; 36#include ""TArrayF.h""; 37#include ""TArrayD.h""; 38#include ""Foption.h""; 39 ; 40#include ""TVectorFfwd.h""; 41#include ""TVectorDfwd.h""; 42 ; 43#include ""TFitResultPtr.h""; 44 ; 45#include <cfloat>; 46#include <string>; 47 ; 48class TF1;; 49class TH1D;; 50class TBrowser;; 51class TDirectory;; 52class TList;; 53class TCollection;; 54class TVirtualFFT;; 55class TVirtualHistPainter;; 56class TRandom;; 57 ; 58 ; 59class TH1 : public TNamed, public TAttLine, public TAttFill, public TAttMarker {; 60 ; 61public:; 62 ; 63 /// Enumeration specifying type of statistics for bin errors; 64 enum EBinErrorOpt {; 65 kNormal = 0, ///< Errors with Normal (Wald) approximation: errorUp=errorLow= sqrt(N); 66 kPoisson = 1 , ///< Errors from Poisson interval at 68.3% (1 sigma); 67 kPoisson2 = 2 ///< Errors from Poisson interval at 95% CL (~ 2 sigma); 68 };; 69 ; 70 /// Enumeration specifying which axes can be extended; 71 enum {; 72 kNoAxis = 0, ///< NOTE: Must always be 0 !!!; 73 kXaxis = BIT(0),; 74 kYaxis = BIT(1),; 75 kZaxis = BIT(2),; 76 kAllAxes = kXaxis | kYaxis | kZaxis; 77 };; 78 ; 79 /// Enumeration specifying the way to treat statoverflow; 80 enum EStatOverflows {; 81 kIgnore = 0, ///< Override global flag ignoring the overflows; 82 kConsider = 1, ///< Override global flag considering the overflows; 83 kNeutral = 2, ///< Adapt to the global flag; 84 };; 85 ; 86 friend class TH1Merger;; 87 ; 88protected:; 89 Int_t fNcells; ///< Number of bins(1D), c",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:1772,Availability,error,errorUp,1772,"*******************************/; 11 ; 12#ifndef ROOT_TH1; 13#define ROOT_TH1; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TH1 //; 19// //; 20// 1-Dim histogram base class. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TAxis.h""; 25 ; 26#include ""TAttLine.h""; 27 ; 28#include ""TAttFill.h""; 29 ; 30#include ""TAttMarker.h""; 31 ; 32#include ""TArrayC.h""; 33#include ""TArrayS.h""; 34#include ""TArrayI.h""; 35#include ""TArrayL64.h""; 36#include ""TArrayF.h""; 37#include ""TArrayD.h""; 38#include ""Foption.h""; 39 ; 40#include ""TVectorFfwd.h""; 41#include ""TVectorDfwd.h""; 42 ; 43#include ""TFitResultPtr.h""; 44 ; 45#include <cfloat>; 46#include <string>; 47 ; 48class TF1;; 49class TH1D;; 50class TBrowser;; 51class TDirectory;; 52class TList;; 53class TCollection;; 54class TVirtualFFT;; 55class TVirtualHistPainter;; 56class TRandom;; 57 ; 58 ; 59class TH1 : public TNamed, public TAttLine, public TAttFill, public TAttMarker {; 60 ; 61public:; 62 ; 63 /// Enumeration specifying type of statistics for bin errors; 64 enum EBinErrorOpt {; 65 kNormal = 0, ///< Errors with Normal (Wald) approximation: errorUp=errorLow= sqrt(N); 66 kPoisson = 1 , ///< Errors from Poisson interval at 68.3% (1 sigma); 67 kPoisson2 = 2 ///< Errors from Poisson interval at 95% CL (~ 2 sigma); 68 };; 69 ; 70 /// Enumeration specifying which axes can be extended; 71 enum {; 72 kNoAxis = 0, ///< NOTE: Must always be 0 !!!; 73 kXaxis = BIT(0),; 74 kYaxis = BIT(1),; 75 kZaxis = BIT(2),; 76 kAllAxes = kXaxis | kYaxis | kZaxis; 77 };; 78 ; 79 /// Enumeration specifying the way to treat statoverflow; 80 enum EStatOverflows {; 81 kIgnore = 0, ///< Override global flag ignoring the overflows; 82 kConsider = 1, ///< Override global flag considering the overflows; 83 kNeutral = 2, ///< Adapt to the global flag; 84 };; 85 ; 86 friend class TH1Merger;; 87 ; 88protected:; 89 Int_t fNcells; ///< Number of bins(1D), c",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:1780,Availability,error,errorLow,1780,"*******************************/; 11 ; 12#ifndef ROOT_TH1; 13#define ROOT_TH1; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TH1 //; 19// //; 20// 1-Dim histogram base class. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TAxis.h""; 25 ; 26#include ""TAttLine.h""; 27 ; 28#include ""TAttFill.h""; 29 ; 30#include ""TAttMarker.h""; 31 ; 32#include ""TArrayC.h""; 33#include ""TArrayS.h""; 34#include ""TArrayI.h""; 35#include ""TArrayL64.h""; 36#include ""TArrayF.h""; 37#include ""TArrayD.h""; 38#include ""Foption.h""; 39 ; 40#include ""TVectorFfwd.h""; 41#include ""TVectorDfwd.h""; 42 ; 43#include ""TFitResultPtr.h""; 44 ; 45#include <cfloat>; 46#include <string>; 47 ; 48class TF1;; 49class TH1D;; 50class TBrowser;; 51class TDirectory;; 52class TList;; 53class TCollection;; 54class TVirtualFFT;; 55class TVirtualHistPainter;; 56class TRandom;; 57 ; 58 ; 59class TH1 : public TNamed, public TAttLine, public TAttFill, public TAttMarker {; 60 ; 61public:; 62 ; 63 /// Enumeration specifying type of statistics for bin errors; 64 enum EBinErrorOpt {; 65 kNormal = 0, ///< Errors with Normal (Wald) approximation: errorUp=errorLow= sqrt(N); 66 kPoisson = 1 , ///< Errors from Poisson interval at 68.3% (1 sigma); 67 kPoisson2 = 2 ///< Errors from Poisson interval at 95% CL (~ 2 sigma); 68 };; 69 ; 70 /// Enumeration specifying which axes can be extended; 71 enum {; 72 kNoAxis = 0, ///< NOTE: Must always be 0 !!!; 73 kXaxis = BIT(0),; 74 kYaxis = BIT(1),; 75 kZaxis = BIT(2),; 76 kAllAxes = kXaxis | kYaxis | kZaxis; 77 };; 78 ; 79 /// Enumeration specifying the way to treat statoverflow; 80 enum EStatOverflows {; 81 kIgnore = 0, ///< Override global flag ignoring the overflows; 82 kConsider = 1, ///< Override global flag considering the overflows; 83 kNeutral = 2, ///< Adapt to the global flag; 84 };; 85 ; 86 friend class TH1Merger;; 87 ; 88protected:; 89 Int_t fNcells; ///< Number of bins(1D), c",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:3947,Availability,error,errors,3947,"Tsumw2; ///< Total Sum of squares of weights; 98 Double_t fTsumwx; ///< Total Sum of weight*X; 99 Double_t fTsumwx2; ///< Total Sum of weight*X*X; 100 Double_t fMaximum; ///< Maximum value for plotting; 101 Double_t fMinimum; ///< Minimum value for plotting; 102 Double_t fNormFactor; ///< Normalization factor; 103 TArrayD fContour; ///< Array to display contour levels; 104 TArrayD fSumw2; ///< Array of sum of squares of weights; 105 TString fOption; ///< Histogram options; 106 TList *fFunctions; ///<->Pointer to list of functions (fits and user); 107 Int_t fBufferSize; ///< fBuffer size; 108 Double_t *fBuffer; ///<[fBufferSize] entry buffer; 109 TDirectory *fDirectory; ///<! Pointer to directory holding this histogram; 110 Int_t fDimension; ///<! Histogram dimension (1, 2 or 3 dim); 111 Double_t *fIntegral; ///<! Integral of bins used by GetRandom; 112 TVirtualHistPainter *fPainter; ///<! Pointer to histogram painter; 113 EBinErrorOpt fBinStatErrOpt; ///< Option for bin statistical errors; 114 EStatOverflows fStatOverflows; ///< Per object flag to use under/overflows in statistics; 115 static Int_t fgBufferSize; ///<! Default buffer size for automatic histograms; 116 static Bool_t fgAddDirectory; ///<! Flag to add histograms to the directory; 117 static Bool_t fgStatOverflows; ///<! Flag to use under/overflows in statistics; 118 static Bool_t fgDefaultSumw2; ///<! Flag to call TH1::Sumw2 automatically at histogram creation time; 119 ; 120public:; 121 static Int_t FitOptionsMake(Option_t *option, Foption_t &Foption);; 122 ; 123private:; 124 void Build();; 125 ; 126 TH1(const TH1&) = delete;; 127 TH1& operator=(const TH1&) = delete;; 128 ; 129protected:; 130 TH1();; 131 TH1(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup);; 132 TH1(const char *name,const char *title,Int_t nbinsx,const Float_t *xbins);; 133 TH1(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins);; 134 ; 135 Int_t AxisChoice(Option_t *axis) const;; 136 virtua",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:19982,Availability,error,error,19982,,MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:20053,Availability,error,error,20053,,MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:20136,Availability,error,error,20136,,MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:21608,Availability,error,error,21608,"t content) { SetBinContent(bin, content); }; 369 virtual void SetBinError(Int_t bin, Double_t error);; 370 virtual void SetBinError(Int_t binx, Int_t biny, Double_t error);; 371 virtual void SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error);; 372 virtual void SetBins(Int_t nx, Double_t xmin, Double_t xmax);; 373 virtual void SetBins(Int_t nx, const Double_t *xBins);; 374 virtual void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax);; 375 virtual void SetBins(Int_t nx, const Double_t *xBins, Int_t ny, const Double_t *yBins);; 376 virtual void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax,; 377 Int_t nz, Double_t zmin, Double_t zmax);; 378 virtual void SetBins(Int_t nx, const Double_t *xBins, Int_t ny, const Double_t * yBins, Int_t nz,; 379 const Double_t *zBins);; 380 virtual void SetBinsLength(Int_t = -1) { } //redefined in derived classes; 381 virtual void SetBinErrorOption(EBinErrorOpt type) { fBinStatErrOpt = type; }; 382 virtual void SetBuffer(Int_t buffersize, Option_t *option="""");; 383 virtual UInt_t SetCanExtend(UInt_t extendBitMask);; 384 virtual void SetContent(const Double_t *content);; 385 virtual void SetContour(Int_t nlevels, const Double_t *levels = nullptr);; 386 virtual void SetContourLevel(Int_t level, Double_t value);; 387 virtual void SetColors(Color_t linecolor = -1, Color_t markercolor = -1, Color_t fillcolor = -1);; 388 static void SetDefaultBufferSize(Int_t buffersize=1000);; 389 static void SetDefaultSumw2(Bool_t sumw2=kTRUE);; 390 virtual void SetDirectory(TDirectory *dir);; 391 virtual void SetEntries(Double_t n) { fEntries = n; }; 392 virtual void SetError(const Double_t *error);; 393 virtual void SetHighlight(Bool_t set = kTRUE); // *TOGGLE* *GETTER=IsHighlight; 394 virtual void SetLabelColor(Color_t color=1, Option_t *axis=""X"");; 395 virtual void SetLabelFont(Style_t font=62, Option_t *axis=""X"");; 396 virtual void SetLabelOffset(Float_t offset=0.",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:51125,Availability,error,error,51125,"l data structure see convention for numbering bins in TH1::Get...Definition TH1.h:526; TH1S::operator=TH1S & operator=(const TH1S &h1)Operator =.Definition TH1.cxx:9773; TH1S::Copyvoid Copy(TObject &hnew) const overrideCopy this to newth1.Definition TH1.cxx:9745; TH1S::TH1STH1S()Constructor.Definition TH1.cxx:9659; TH1S::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH1.cxx:9763; TH1S::~TH1S~TH1S() overrideDestructor.Definition TH1.cxx:9707; TH1S::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH1.cxx:9724; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::~TH1~TH1() overrideHistogram default destructor.Definition TH1.cxx:643; TH1::SetLabelFontvirtual void SetLabelFont(Style_t font=62, Option_t *axis=""X"")Set font number used to draw axis labels.Definition Haxis.cxx:249; TH1::SetErrorvirtual void SetError(const Double_t *error)Replace bin errors by values in array error.Definition TH1.cxx:8951; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::FitPanelvirtual void FitPanel()Display a panel with all histogram fit options.Definition TH1.cxx:4284; TH1::fBufferDouble_t * fBuffer[fBufferSize] entry bufferDefinition TH1.h:108; TH1::AutoP2FindLimitsvirtual Int_t AutoP2FindLimits(Double_t min, Double_t max)Buffer-based estimate of the histogram range using the power of 2 algorithm.Definition TH1.cxx:1343; TH1::SetStatOverflowsvoid SetStatOverflows(EStatOverflows statOverflows)See GetStatOverflows for more information.Definition TH1.h:417; TH1::GetEffectiveEntriesvirtual Double_t GetEffectiveEntries() constNumber of effective entries of the histogram.Definition TH1.cxx:4448; TH1::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideRedefines TObject::",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:51143,Availability,error,errors,51143,"l data structure see convention for numbering bins in TH1::Get...Definition TH1.h:526; TH1S::operator=TH1S & operator=(const TH1S &h1)Operator =.Definition TH1.cxx:9773; TH1S::Copyvoid Copy(TObject &hnew) const overrideCopy this to newth1.Definition TH1.cxx:9745; TH1S::TH1STH1S()Constructor.Definition TH1.cxx:9659; TH1S::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH1.cxx:9763; TH1S::~TH1S~TH1S() overrideDestructor.Definition TH1.cxx:9707; TH1S::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH1.cxx:9724; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::~TH1~TH1() overrideHistogram default destructor.Definition TH1.cxx:643; TH1::SetLabelFontvirtual void SetLabelFont(Style_t font=62, Option_t *axis=""X"")Set font number used to draw axis labels.Definition Haxis.cxx:249; TH1::SetErrorvirtual void SetError(const Double_t *error)Replace bin errors by values in array error.Definition TH1.cxx:8951; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::FitPanelvirtual void FitPanel()Display a panel with all histogram fit options.Definition TH1.cxx:4284; TH1::fBufferDouble_t * fBuffer[fBufferSize] entry bufferDefinition TH1.h:108; TH1::AutoP2FindLimitsvirtual Int_t AutoP2FindLimits(Double_t min, Double_t max)Buffer-based estimate of the histogram range using the power of 2 algorithm.Definition TH1.cxx:1343; TH1::SetStatOverflowsvoid SetStatOverflows(EStatOverflows statOverflows)See GetStatOverflows for more information.Definition TH1.h:417; TH1::GetEffectiveEntriesvirtual Double_t GetEffectiveEntries() constNumber of effective entries of the histogram.Definition TH1.cxx:4448; TH1::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideRedefines TObject::",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:51169,Availability,error,error,51169,"l data structure see convention for numbering bins in TH1::Get...Definition TH1.h:526; TH1S::operator=TH1S & operator=(const TH1S &h1)Operator =.Definition TH1.cxx:9773; TH1S::Copyvoid Copy(TObject &hnew) const overrideCopy this to newth1.Definition TH1.cxx:9745; TH1S::TH1STH1S()Constructor.Definition TH1.cxx:9659; TH1S::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH1.cxx:9763; TH1S::~TH1S~TH1S() overrideDestructor.Definition TH1.cxx:9707; TH1S::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH1.cxx:9724; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::~TH1~TH1() overrideHistogram default destructor.Definition TH1.cxx:643; TH1::SetLabelFontvirtual void SetLabelFont(Style_t font=62, Option_t *axis=""X"")Set font number used to draw axis labels.Definition Haxis.cxx:249; TH1::SetErrorvirtual void SetError(const Double_t *error)Replace bin errors by values in array error.Definition TH1.cxx:8951; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::FitPanelvirtual void FitPanel()Display a panel with all histogram fit options.Definition TH1.cxx:4284; TH1::fBufferDouble_t * fBuffer[fBufferSize] entry bufferDefinition TH1.h:108; TH1::AutoP2FindLimitsvirtual Int_t AutoP2FindLimits(Double_t min, Double_t max)Buffer-based estimate of the histogram range using the power of 2 algorithm.Definition TH1.cxx:1343; TH1::SetStatOverflowsvoid SetStatOverflows(EStatOverflows statOverflows)See GetStatOverflows for more information.Definition TH1.h:417; TH1::GetEffectiveEntriesvirtual Double_t GetEffectiveEntries() constNumber of effective entries of the histogram.Definition TH1.cxx:4448; TH1::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideRedefines TObject::",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:52616,Availability,error,errors,52616,"inition TH1.h:108; TH1::AutoP2FindLimitsvirtual Int_t AutoP2FindLimits(Double_t min, Double_t max)Buffer-based estimate of the histogram range using the power of 2 algorithm.Definition TH1.cxx:1343; TH1::SetStatOverflowsvoid SetStatOverflows(EStatOverflows statOverflows)See GetStatOverflows for more information.Definition TH1.h:417; TH1::GetEffectiveEntriesvirtual Double_t GetEffectiveEntries() constNumber of effective entries of the histogram.Definition TH1.cxx:4448; TH1::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideRedefines TObject::GetObjectInfo.Definition TH1.cxx:4502; TH1::Smoothvirtual void Smooth(Int_t ntimes=1, Option_t *option="""")Smooth bin contents of this histogram.Definition TH1.cxx:6879; TH1::SetNormFactorvirtual void SetNormFactor(Double_t factor=1)Definition TH1.h:410; TH1::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn bin center for 1D histogram.Definition TH1.cxx:9141; TH1::Rebuildvirtual void Rebuild(Option_t *option="""")Using the current bin info, recompute the arrays for contents and errors.Definition TH1.cxx:7087; TH1::SetBarOffsetvirtual void SetBarOffset(Float_t offset=0.25)Set the bar offset as fraction of the bin width for drawing mode ""B"".Definition TH1.h:364; TH1::GetLabelColorvirtual Color_t GetLabelColor(Option_t *axis=""X"") constReturn the ""axis"" label color.Definition Haxis.cxx:53; TH1::fgStatOverflowsstatic Bool_t fgStatOverflows! Flag to use under/overflows in statisticsDefinition TH1.h:117; TH1::FindLastBinAbovevirtual Int_t FindLastBinAbove(Double_t threshold=0, Int_t axis=1, Int_t firstBin=1, Int_t lastBin=-1) constFind last bin with content > threshold for axis (1=x, 2=y, 3=z) if no bins with content > threshold i...Definition TH1.cxx:3797; TH1::SetTitleSizevirtual void SetTitleSize(Float_t size=0.02, Option_t *axis=""X"")Set the axis' title size.Definition Haxis.cxx:365; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:56571,Availability,error,error,56571,"GetBarOffsetvirtual Float_t GetBarOffset() constDefinition TH1.h:256; TH1::fFunctionsTList * fFunctions->Pointer to list of functions (fits and user)Definition TH1.h:106; TH1::RebinAxisvirtual void RebinAxis(Double_t x, TAxis *axis)Definition TH1.h:437; TH1::GetStatOverflowsEStatOverflows GetStatOverflows() constGet the behaviour adopted by the object about the statoverflows. See EStatOverflows for more informat...Definition TH1.h:323; TH1::fgAddDirectorystatic Bool_t fgAddDirectory! Flag to add histograms to the directoryDefinition TH1.h:116; TH1::CheckConsistencystatic int CheckConsistency(const TH1 *h1, const TH1 *h2)Check histogram compatibility.Definition TH1.cxx:1677; TH1::GetDefaultBufferSizestatic Int_t GetDefaultBufferSize()Static function return the default buffer size for automatic histograms the parameter fgBufferSize ma...Definition TH1.cxx:4406; TH1::DoIntegralvirtual Double_t DoIntegral(Int_t ix1, Int_t ix2, Int_t iy1, Int_t iy2, Int_t iz1, Int_t iz2, Double_t &err, Option_t *opt, Bool_t doerr=kFALSE) constInternal function compute integral and optionally the error between the limits specified by the bin n...Definition TH1.cxx:7977; TH1::fTsumwx2Double_t fTsumwx2Total Sum of weight*X*X.Definition TH1.h:99; TH1::GetStdDevvirtual Double_t GetStdDev(Int_t axis=1) constReturns the Standard Deviation (Sigma).Definition TH1.cxx:7607; TH1::TH1TH1()Histogram default constructor.Definition TH1.cxx:615; TH1::TransformHistostatic TH1 * TransformHisto(TVirtualFFT *fft, TH1 *h_output, Option_t *option)For a given transform (first parameter), fills the histogram (second parameter) with the transform ou...Definition TH1.cxx:9319; TH1::UseCurrentStylevoid UseCurrentStyle() overrideCopy current attributes from/to current style.Definition TH1.cxx:7469; TH1::LabelsOptionvirtual void LabelsOption(Option_t *option=""h"", Option_t *axis=""X"")Sort bins with labels or set option(s) to draw axis with labels.Definition TH1.cxx:5382; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDef",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:58116,Availability,error,error,58116,"ith the transform ou...Definition TH1.cxx:9319; TH1::UseCurrentStylevoid UseCurrentStyle() overrideCopy current attributes from/to current style.Definition TH1.cxx:7469; TH1::LabelsOptionvirtual void LabelsOption(Option_t *option=""h"", Option_t *axis=""X"")Sort bins with labels or set option(s) to draw axis with labels.Definition TH1.cxx:5382; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::fBarOffsetShort_t fBarOffset(1000*offset) for bar charts or legosDefinition TH1.h:93; TH1::Chi2TestXvirtual Double_t Chi2TestX(const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) constThe computation routine of the Chisquare test.Definition TH1.cxx:2067; TH1::CheckBinLimitsstatic bool CheckBinLimits(const TAxis *a1, const TAxis *a2)Check bin limits.Definition TH1.cxx:1541; TH1::AddBinContentvirtual void AddBinContent(Int_t bin)Increment bin content by 1.Definition TH1.cxx:1268; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associated to bin number bin.Definition TH1.cxx:9063; TH1::FitOptionsMakestatic Int_t FitOptionsMake(Option_t *option, Foption_t &Foption)Decode string choptin and fill fitOption structure.Definition TH1.cxx:4652; TH1::GetNbinsZvirtual Int_t GetNbinsZ() constDefinition TH1.h:299; TH1::GetNormFactorvirtual Double_t GetNormFactor() constDefinition TH1.h:301; TH1::GetMeanvirtual Double_t GetMean(Int_t axis=1) constFor axis = 1,2 or 3 returns the mean value of the histogram along X,Y or Z axis.Definition TH1.cxx:7535; TH1::TH1TH1(const TH1 &)=delete; TH1::GetSkewnessvirtual Double_t GetSkewness(Int_t axis=1) constDefinition TH1.cxx:7671; TH1::ClearUnderflowAndOverflowvirtual void ClearUnderflowAndOverflow()Remove all the content from the underflow and overflow bins, without changing the number of entries A...Definition TH1.cxx:2517; TH1::GetContourLevelPadvirtual Double_t GetContourLevelPad(Int_t level) constReturn the value of contour number ""level"" in Pad ",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:61349,Availability,error,errors,61349,"TH1.h:170; TH1::kUserContour@ kUserContourUser specified contour levels.Definition TH1.h:166; TH1::kNoStats@ kNoStatsDon't draw stats box.Definition TH1.h:165; TH1::kIsZoomed@ kIsZoomedBit set when zooming on Y axis.Definition TH1.h:169; TH1::kAutoBinPTwo@ kAutoBinPTwodifferent than 1.Definition TH1.h:174; TH1::kIsNotW@ kIsNotWHistogram is forced to be not weighted even when the histogram is filled with weighted.Definition TH1.h:172; TH1::kIsHighlight@ kIsHighlightbit set if histo is highlightDefinition TH1.h:175; TH1::SetContourLevelvirtual void SetContourLevel(Int_t level, Double_t value)Set value for one contour level.Definition TH1.cxx:8522; TH1::CanExtendAllAxesvirtual Bool_t CanExtendAllAxes() constReturns true if all axes are extendable.Definition TH1.cxx:6636; TH1::fDirectoryTDirectory * fDirectory! Pointer to directory holding this histogramDefinition TH1.h:109; TH1::GetOptionOption_t * GetOption() const overrideDefinition TH1.h:303; TH1::Resetvirtual void Reset(Option_t *option="""")Reset this histogram: contents, errors, etc.Definition TH1.cxx:7103; TH1::SetNameTitlevoid SetNameTitle(const char *name, const char *title) overrideChange the name and title of this histogram.Definition TH1.cxx:8974; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetBinXYZvirtual void GetBinXYZ(Int_t binglobal, Int_t &binx, Int_t &biny, Int_t &binz) constReturn binx, biny, binz corresponding to the global bin number globalbin see TH1::GetBin function abo...Definition TH1.cxx:4974; TH1::GetCumulativeTH1 * GetCumulative(Bool_t forward=kTRUE, const char *suffix=""_cumulative"") constReturn a pointer to a histogram containing the cumulative content.Definition TH1.cxx:2616; TH1::AutoP2GetPower2static Double_t AutoP2GetPower2(Double_t x, Bool_t next=kTRUE)Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x.Definition TH1.cxx:1308; TH1::GetNcellsvirtual Int_t GetNcells() constDefinition TH1.h:300; TH1::ShowPeaksvirtual Int_t ShowPeaks(Double_",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:66106,Availability,error,errors,66106,"ouble_t GetRMSError(Int_t axis=1) constDefinition TH1.h:320; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Definition TH1.h:404; TH1::FFTvirtual TH1 * FFT(TH1 *h_output, Option_t *option)This function allows to do discrete Fourier transforms of TH1 and TH2.Definition TH1.cxx:3284; TH1::LabelsInflatevirtual void LabelsInflate(Option_t *axis=""X"")Double the number of bins for axis.Definition TH1.cxx:5315; TH1::ShowBackgroundvirtual TH1 * ShowBackground(Int_t niter=20, Option_t *option=""same"")This function calculates the background spectrum in this histogram.Definition TH1.cxx:9287; TH1::FillNvirtual void FillN(Int_t, const Double_t *, const Double_t *, const Double_t *, Int_t)Definition TH1.h:224; TH1::SameLimitsAndNBinsstatic Bool_t SameLimitsAndNBins(const TAxis &axis1, const TAxis &axis2)Same limits and bins.Definition TH1.cxx:5898; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; TH1::fMaximumDouble_t fMaximumMaximum value for plotting.Definition TH1.h:100; TH1::fBufferSizeInt_t fBufferSizefBuffer sizeDefinition TH1.h:107; TH1::RetrieveBinContentvirtual Double_t RetrieveBinContent(Int_t bin) constRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.cxx:9439; TH1::IntegralAndErrorvirtual Double_t IntegralAndError(Int_t binx1, Int_t binx2, Double_t &err, Option_t *option="""") constReturn integral of bin contents in range [binx1,binx2] and its error.Definition TH1.cxx:7968; TH1::fDimensionInt_t fDimension! Histogram dimension (1, 2 or 3 dim)Definition TH1.h:110; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::fBinStatErrOptEBinErrorOpt fBinStat",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:66704,Availability,error,error,66704,"20, Option_t *option=""same"")This function calculates the background spectrum in this histogram.Definition TH1.cxx:9287; TH1::FillNvirtual void FillN(Int_t, const Double_t *, const Double_t *, const Double_t *, Int_t)Definition TH1.h:224; TH1::SameLimitsAndNBinsstatic Bool_t SameLimitsAndNBins(const TAxis &axis1, const TAxis &axis2)Same limits and bins.Definition TH1.cxx:5898; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; TH1::fMaximumDouble_t fMaximumMaximum value for plotting.Definition TH1.h:100; TH1::fBufferSizeInt_t fBufferSizefBuffer sizeDefinition TH1.h:107; TH1::RetrieveBinContentvirtual Double_t RetrieveBinContent(Int_t bin) constRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.cxx:9439; TH1::IntegralAndErrorvirtual Double_t IntegralAndError(Int_t binx1, Int_t binx2, Double_t &err, Option_t *option="""") constReturn integral of bin contents in range [binx1,binx2] and its error.Definition TH1.cxx:7968; TH1::fDimensionInt_t fDimension! Histogram dimension (1, 2 or 3 dim)Definition TH1.h:110; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::fBinStatErrOptEBinErrorOpt fBinStatErrOptOption for bin statistical errors.Definition TH1.h:113; TH1::fgBufferSizestatic Int_t fgBufferSize! Default buffer size for automatic histogramsDefinition TH1.h:115; TH1::SetBinsLengthvirtual void SetBinsLength(Int_t=-1)Definition TH1.h:380; TH1::fNormFactorDouble_t fNormFactorNormalization factor.Definition TH1.h:102; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::fContourTArrayD fContourArray to display contour levels.Definitio",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:66886,Availability,error,error,66886,"st TAxis &axis1, const TAxis &axis2)Same limits and bins.Definition TH1.cxx:5898; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; TH1::fMaximumDouble_t fMaximumMaximum value for plotting.Definition TH1.h:100; TH1::fBufferSizeInt_t fBufferSizefBuffer sizeDefinition TH1.h:107; TH1::RetrieveBinContentvirtual Double_t RetrieveBinContent(Int_t bin) constRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.cxx:9439; TH1::IntegralAndErrorvirtual Double_t IntegralAndError(Int_t binx1, Int_t binx2, Double_t &err, Option_t *option="""") constReturn integral of bin contents in range [binx1,binx2] and its error.Definition TH1.cxx:7968; TH1::fDimensionInt_t fDimension! Histogram dimension (1, 2 or 3 dim)Definition TH1.h:110; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::fBinStatErrOptEBinErrorOpt fBinStatErrOptOption for bin statistical errors.Definition TH1.h:113; TH1::fgBufferSizestatic Int_t fgBufferSize! Default buffer size for automatic histogramsDefinition TH1.h:115; TH1::SetBinsLengthvirtual void SetBinsLength(Int_t=-1)Definition TH1.h:380; TH1::fNormFactorDouble_t fNormFactorNormalization factor.Definition TH1.h:102; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::fContourTArrayD fContourArray to display contour levels.Definition TH1.h:103; TH1::GetBinErrorLowvirtual Double_t GetBinErrorLow(Int_t bin) constReturn lower error associated to bin number bin.Definition TH1.cxx:9079; TH1::RebinXvirtual TH1 * RebinX(Int_t ngroup=2, const char *newname="""")Definition TH1.h:354; TH1::Browsevoid Browse(TBrowser *b) overrideBrowse",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:67094,Availability,error,errors,67094,""""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; TH1::fMaximumDouble_t fMaximumMaximum value for plotting.Definition TH1.h:100; TH1::fBufferSizeInt_t fBufferSizefBuffer sizeDefinition TH1.h:107; TH1::RetrieveBinContentvirtual Double_t RetrieveBinContent(Int_t bin) constRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.cxx:9439; TH1::IntegralAndErrorvirtual Double_t IntegralAndError(Int_t binx1, Int_t binx2, Double_t &err, Option_t *option="""") constReturn integral of bin contents in range [binx1,binx2] and its error.Definition TH1.cxx:7968; TH1::fDimensionInt_t fDimension! Histogram dimension (1, 2 or 3 dim)Definition TH1.h:110; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::fBinStatErrOptEBinErrorOpt fBinStatErrOptOption for bin statistical errors.Definition TH1.h:113; TH1::fgBufferSizestatic Int_t fgBufferSize! Default buffer size for automatic histogramsDefinition TH1.h:115; TH1::SetBinsLengthvirtual void SetBinsLength(Int_t=-1)Definition TH1.h:380; TH1::fNormFactorDouble_t fNormFactorNormalization factor.Definition TH1.h:102; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::fContourTArrayD fContourArray to display contour levels.Definition TH1.h:103; TH1::GetBinErrorLowvirtual Double_t GetBinErrorLow(Int_t bin) constReturn lower error associated to bin number bin.Definition TH1.cxx:9079; TH1::RebinXvirtual TH1 * RebinX(Int_t ngroup=2, const char *newname="""")Definition TH1.h:354; TH1::Browsevoid Browse(TBrowser *b) overrideBrowse the Histogram object.Definition TH1.cxx:762; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin, Int_t, Int_t) constDefinition TH1.h:267; TH1",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:67703,Availability,error,error,67703,"ange [binx1,binx2] and its error.Definition TH1.cxx:7968; TH1::fDimensionInt_t fDimension! Histogram dimension (1, 2 or 3 dim)Definition TH1.h:110; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::fBinStatErrOptEBinErrorOpt fBinStatErrOptOption for bin statistical errors.Definition TH1.h:113; TH1::fgBufferSizestatic Int_t fgBufferSize! Default buffer size for automatic histogramsDefinition TH1.h:115; TH1::SetBinsLengthvirtual void SetBinsLength(Int_t=-1)Definition TH1.h:380; TH1::fNormFactorDouble_t fNormFactorNormalization factor.Definition TH1.h:102; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::fContourTArrayD fContourArray to display contour levels.Definition TH1.h:103; TH1::GetBinErrorLowvirtual Double_t GetBinErrorLow(Int_t bin) constReturn lower error associated to bin number bin.Definition TH1.cxx:9079; TH1::RebinXvirtual TH1 * RebinX(Int_t ngroup=2, const char *newname="""")Definition TH1.h:354; TH1::Browsevoid Browse(TBrowser *b) overrideBrowse the Histogram object.Definition TH1.cxx:762; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin, Int_t, Int_t) constDefinition TH1.h:267; TH1::SetContentvirtual void SetContent(const Double_t *content)Replace bin contents by the contents of array content.Definition TH1.cxx:8398; TH1::GetLabelSizevirtual Float_t GetLabelSize(Option_t *axis=""X"") constReturn the ""axis"" label size.Definition Haxis.cxx:92; TH1::SavePrimitiveHelpvirtual void SavePrimitiveHelp(std::ostream &out, const char *hname, Option_t *option="""")Helper function for the SavePrimitive functions from TH1 or classes derived from TH1,...Definition TH1.cxx:7379; TH1::fBarWidthShort_t fBarWidth(1000*width) for bar charts or legosDefinition TH1.h:94; TH1::GetBinErrorSqUncheckedvirtual Double_t G",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:72517,Availability,mask,mask,72517,"tion TH1.cxx:771; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::GetZaxisconst TAxis * GetZaxis() constDefinition TH1.h:329; TH1::SetZTitlevirtual void SetZTitle(const char *title)Definition TH1.h:421; TH1::GetFunctionvirtual TF1 * GetFunction(const char *name) constReturn pointer to function with name.Definition TH1.cxx:9051; TH1::Rebinvirtual TH1 * Rebin(Int_t ngroup=2, const char *newname="""", const Double_t *xbins=nullptr)Rebin this histogram.Definition TH1.cxx:6275; TH1::BufferFillvirtual Int_t BufferFill(Double_t x, Double_t w)accumulate arguments in buffer.Definition TH1.cxx:1506; TH1::GetBinWithContentvirtual Double_t GetBinWithContent(Double_t c, Int_t &binx, Int_t firstx=0, Int_t lastx=0, Double_t maxdiff=0) constCompute first binx in the range [firstx,lastx] for which diff = abs(bin_content-c) <= maxdiff.Definition TH1.cxx:5086; TH1::SetCanExtendvirtual UInt_t SetCanExtend(UInt_t extendBitMask)Make the histogram axes extendable / not extendable according to the bit mask returns the previous bi...Definition TH1.cxx:6649; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::DrawCopyvirtual TH1 * DrawCopy(Option_t *option="""", const char *name_postfix=""_copy"") constCopy this histogram and Draw in the current pad.Definition TH1.cxx:3113; TH1::GetTitleOffsetvirtual Float_t GetTitleOffset(Option_t *axis=""X"") constReturn the ""axis"" title offset.Definition Haxis.cxx:131; TH1::IsEmptyBool_t IsEmpty() constCheck if a histogram is empty (this is a protected method used mainly by TH1Merger )Definition TH1.cxx:5164; TH1::GetMeanErrorvirtual Double_t GetMeanError(Int_t axis=1) constReturn standard error of mean of this histogram along the X axis.Definition TH1.cxx:7575; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histogra",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:73288,Availability,error,error,73288," first binx in the range [firstx,lastx] for which diff = abs(bin_content-c) <= maxdiff.Definition TH1.cxx:5086; TH1::SetCanExtendvirtual UInt_t SetCanExtend(UInt_t extendBitMask)Make the histogram axes extendable / not extendable according to the bit mask returns the previous bi...Definition TH1.cxx:6649; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::DrawCopyvirtual TH1 * DrawCopy(Option_t *option="""", const char *name_postfix=""_copy"") constCopy this histogram and Draw in the current pad.Definition TH1.cxx:3113; TH1::GetTitleOffsetvirtual Float_t GetTitleOffset(Option_t *axis=""X"") constReturn the ""axis"" title offset.Definition Haxis.cxx:131; TH1::IsEmptyBool_t IsEmpty() constCheck if a histogram is empty (this is a protected method used mainly by TH1Merger )Definition TH1.cxx:5164; TH1::GetMeanErrorvirtual Double_t GetMeanError(Int_t axis=1) constReturn standard error of mean of this histogram along the X axis.Definition TH1.cxx:7575; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::AndersonDarlingTestvirtual Double_t AndersonDarlingTest(const TH1 *h2, Option_t *option="""") constStatistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling ...Definition TH1.cxx:8062; TH1::ResetStatsvirtual void ResetStats()Reset the statistics including the number of entries and replace with values calculated from bin cont...Definition TH1.cxx:7902; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Int_t, Int_t, Double_t content)Definition TH1.h:368; TH1::SetDefaultBufferSizestatic void SetDefaultBufferSize(Int_t buffersize=1000)Static function to set the default buffer size for automatic histograms.Definition TH1.cxx:6693; TH1::SetBinErrorOptionvirtual void SetBinErrorOption(EBinErrorOpt type)Definition TH1.h:381; TH1",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:77583,Availability,error,errors,77583,"cxx:3240; TH1::GetIntegralvirtual Double_t * GetIntegral()Return a pointer to the array of bins integral.Definition TH1.cxx:2586; TH1::fZaxisTAxis fZaxisZ axis descriptor.Definition TH1.h:92; TH1::fStatOverflowsEStatOverflows fStatOverflowsPer object flag to use under/overflows in statistics.Definition TH1.h:114; TH1::FillNvirtual void FillN(Int_t ntimes, const Double_t *x, const Double_t *w, Int_t stride=1)Fill this histogram with an array x and weights w.Definition TH1.cxx:3447; TH1::UpdateBinContentvirtual void UpdateBinContent(Int_t bin, Double_t content)Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH1.cxx:9449; TH1::GetLabelOffsetvirtual Float_t GetLabelOffset(Option_t *axis=""X"") constReturn the ""axis"" label offset.Definition Haxis.cxx:79; TH1::CheckEqualAxesstatic bool CheckEqualAxes(const TAxis *a1, const TAxis *a2)Check that the axis are the same.Definition TH1.cxx:1611; TH1::EBinErrorOptEBinErrorOptEnumeration specifying type of statistics for bin errors.Definition TH1.h:64; TH1::kPoisson2@ kPoisson2Errors from Poisson interval at 95% CL (~ 2 sigma)Definition TH1.h:67; TH1::kNormal@ kNormalErrors with Normal (Wald) approximation: errorUp=errorLow= sqrt(N)Definition TH1.h:65; TH1::kPoisson@ kPoissonErrors from Poisson interval at 68.3% (1 sigma)Definition TH1.h:66; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetSumw2virtual TArrayD * GetSumw2()Definition TH1.h:313; TH1::GetContourvirtual Int_t GetContour(Double_t *levels=nullptr)Return contour values into array levels if pointer levels is non zero.Definition TH1.cxx:8411; TH1::fXaxisTAxis fXaxisX axis descriptor.Definition TH1.h:90; TH1::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1, Option_t *axis=""X"")Specify a parameter offset to control the distance between the axis and the axis' title.Definition Haxis.cxx:345; TH1::GetBufferconst Double_t *",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:77769,Availability,error,errorUp,77769,"tatOverflows fStatOverflowsPer object flag to use under/overflows in statistics.Definition TH1.h:114; TH1::FillNvirtual void FillN(Int_t ntimes, const Double_t *x, const Double_t *w, Int_t stride=1)Fill this histogram with an array x and weights w.Definition TH1.cxx:3447; TH1::UpdateBinContentvirtual void UpdateBinContent(Int_t bin, Double_t content)Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH1.cxx:9449; TH1::GetLabelOffsetvirtual Float_t GetLabelOffset(Option_t *axis=""X"") constReturn the ""axis"" label offset.Definition Haxis.cxx:79; TH1::CheckEqualAxesstatic bool CheckEqualAxes(const TAxis *a1, const TAxis *a2)Check that the axis are the same.Definition TH1.cxx:1611; TH1::EBinErrorOptEBinErrorOptEnumeration specifying type of statistics for bin errors.Definition TH1.h:64; TH1::kPoisson2@ kPoisson2Errors from Poisson interval at 95% CL (~ 2 sigma)Definition TH1.h:67; TH1::kNormal@ kNormalErrors with Normal (Wald) approximation: errorUp=errorLow= sqrt(N)Definition TH1.h:65; TH1::kPoisson@ kPoissonErrors from Poisson interval at 68.3% (1 sigma)Definition TH1.h:66; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetSumw2virtual TArrayD * GetSumw2()Definition TH1.h:313; TH1::GetContourvirtual Int_t GetContour(Double_t *levels=nullptr)Return contour values into array levels if pointer levels is non zero.Definition TH1.cxx:8411; TH1::fXaxisTAxis fXaxisX axis descriptor.Definition TH1.h:90; TH1::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1, Option_t *axis=""X"")Specify a parameter offset to control the distance between the axis and the axis' title.Definition Haxis.cxx:345; TH1::GetBufferconst Double_t * GetBuffer() constDefinition TH1.h:239; TH1::IsHighlightvirtual Bool_t IsHighlight() constDefinition TH1.h:338; TH1::SetLabelColorvirtual void SetLabelColor(Color_t color=1, Option_t *axis=""X"")Set axis labels colo",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:77777,Availability,error,errorLow,77777,"tatOverflows fStatOverflowsPer object flag to use under/overflows in statistics.Definition TH1.h:114; TH1::FillNvirtual void FillN(Int_t ntimes, const Double_t *x, const Double_t *w, Int_t stride=1)Fill this histogram with an array x and weights w.Definition TH1.cxx:3447; TH1::UpdateBinContentvirtual void UpdateBinContent(Int_t bin, Double_t content)Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH1.cxx:9449; TH1::GetLabelOffsetvirtual Float_t GetLabelOffset(Option_t *axis=""X"") constReturn the ""axis"" label offset.Definition Haxis.cxx:79; TH1::CheckEqualAxesstatic bool CheckEqualAxes(const TAxis *a1, const TAxis *a2)Check that the axis are the same.Definition TH1.cxx:1611; TH1::EBinErrorOptEBinErrorOptEnumeration specifying type of statistics for bin errors.Definition TH1.h:64; TH1::kPoisson2@ kPoisson2Errors from Poisson interval at 95% CL (~ 2 sigma)Definition TH1.h:67; TH1::kNormal@ kNormalErrors with Normal (Wald) approximation: errorUp=errorLow= sqrt(N)Definition TH1.h:65; TH1::kPoisson@ kPoissonErrors from Poisson interval at 68.3% (1 sigma)Definition TH1.h:66; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetSumw2virtual TArrayD * GetSumw2()Definition TH1.h:313; TH1::GetContourvirtual Int_t GetContour(Double_t *levels=nullptr)Return contour values into array levels if pointer levels is non zero.Definition TH1.cxx:8411; TH1::fXaxisTAxis fXaxisX axis descriptor.Definition TH1.h:90; TH1::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1, Option_t *axis=""X"")Specify a parameter offset to control the distance between the axis and the axis' title.Definition Haxis.cxx:345; TH1::GetBufferconst Double_t * GetBuffer() constDefinition TH1.h:239; TH1::IsHighlightvirtual Bool_t IsHighlight() constDefinition TH1.h:338; TH1::SetLabelColorvirtual void SetLabelColor(Color_t color=1, Option_t *axis=""X"")Set axis labels colo",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:80427,Availability,error,error,80427,"Sumw2Array of sum of squares of weights.Definition TH1.h:104; TH1::SetOptionvirtual void SetOption(Option_t *option="" "")Definition TH1.h:412; TH1::GetAsymmetryTH1 * GetAsymmetry(TH1 *h2, Double_t c2=1, Double_t dc2=0)Return a histogram containing the asymmetry of this histogram with h2, where the asymmetry is defined...Definition TH1.cxx:4339; TH1::GetContourLevelvirtual Double_t GetContourLevel(Int_t level) constReturn value of contour number level.Definition TH1.cxx:8430; TH1::SetContourvirtual void SetContour(Int_t nlevels, const Double_t *levels=nullptr)Set the number and values of contour levels.Definition TH1.cxx:8483; TH1::SetHighlightvirtual void SetHighlight(Bool_t set=kTRUE)Set highlight (enable/disable) mode for the histogram by default highlight mode is disable.Definition TH1.cxx:4482; TH1::SetAxisRangevirtual void SetAxisRange(Double_t xmin, Double_t xmax, Option_t *axis=""X"")Set the ""axis"" range.Definition Haxis.cxx:201; TH1::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t bin) constReturn upper error associated to bin number bin.Definition TH1.cxx:9110; TH1::SetYTitlevirtual void SetYTitle(const char *title)Definition TH1.h:420; TH1::Scalevirtual void Scale(Double_t c1=1, Option_t *option="""")Multiply this histogram by a constant c1.Definition TH1.cxx:6604; TH1::GetMinimumBinvirtual Int_t GetMinimumBin() constReturn location of bin with minimum value in the range.Definition TH1.cxx:8665; TH1::GetSumw2Nvirtual Int_t GetSumw2N() constDefinition TH1.h:315; TH1::SetCellErrorvirtual void SetCellError(Int_t binx, Int_t biny, Double_t content)Definition TH1.h:441; TH1::FindBinvirtual Int_t FindBin(Double_t x, Double_t y=0, Double_t z=0)Return Global bin number corresponding to x,y,z.Definition TH1.cxx:3672; TH1::GetStatOverflowsBehaviourBool_t GetStatOverflowsBehaviour() constDefinition TH1.h:152; TH1::SaveAsvoid SaveAs(const char *filename=""hist"", Option_t *option="""") const overrideSave the histogram as .csv, .tsv or .txt.Definition TH1.cxx:7181; TH1::SetTi",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:82093,Availability,error,error,82093,"lobal bin number corresponding to x,y,z.Definition TH1.cxx:3672; TH1::GetStatOverflowsBehaviourBool_t GetStatOverflowsBehaviour() constDefinition TH1.h:152; TH1::SaveAsvoid SaveAs(const char *filename=""hist"", Option_t *option="""") const overrideSave the histogram as .csv, .tsv or .txt.Definition TH1.cxx:7181; TH1::SetTitleFontvirtual void SetTitleFont(Style_t font=62, Option_t *axis=""X"")Set the axis' title font.Definition Haxis.cxx:323; TH1::GetQuantilesvirtual Int_t GetQuantiles(Int_t n, Double_t *xp, const Double_t *p=nullptr)Compute Quantiles for this histogram Quantile x_p := Q(p) is defined as the value x_p such that the c...Definition TH1.cxx:4611; TH1::GetAxisColorvirtual Color_t GetAxisColor(Option_t *axis=""X"") constReturn the number of divisions for ""axis"".Definition Haxis.cxx:40; TH1::CloneTObject * Clone(const char *newname="""") const overrideMake a complete copy of the underlying object.Definition TH1.cxx:2752; TH1::GetStdDevErrorvirtual Double_t GetStdDevError(Int_t axis=1) constReturn error of standard deviation estimation for Normal distribution.Definition TH1.cxx:7655; TH1::Dividevirtual Bool_t Divide(TF1 *f1, Double_t c1=1)Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:2840; TH1::GetMinimumvirtual Double_t GetMinimum(Double_t minval=-FLT_MAX) constReturn minimum value larger than minval of bins in the range, unless the value has been overridden by...Definition TH1.cxx:8635; TH1::LoggedInconsistencyint LoggedInconsistency(const char *name, const TH1 *h1, const TH1 *h2, bool useMerge=false) constDefinition TH1.cxx:883; TH1::CheckConsistentSubAxesstatic bool CheckConsistentSubAxes(const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0)Check that two sub axis are the same.Definition TH1.cxx:1640; TH1::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove object from the list of functions.Definition TH1.cxx:6576; TH1::fYaxisTAxis",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:82284,Availability,error,errors,82284,"eAsvoid SaveAs(const char *filename=""hist"", Option_t *option="""") const overrideSave the histogram as .csv, .tsv or .txt.Definition TH1.cxx:7181; TH1::SetTitleFontvirtual void SetTitleFont(Style_t font=62, Option_t *axis=""X"")Set the axis' title font.Definition Haxis.cxx:323; TH1::GetQuantilesvirtual Int_t GetQuantiles(Int_t n, Double_t *xp, const Double_t *p=nullptr)Compute Quantiles for this histogram Quantile x_p := Q(p) is defined as the value x_p such that the c...Definition TH1.cxx:4611; TH1::GetAxisColorvirtual Color_t GetAxisColor(Option_t *axis=""X"") constReturn the number of divisions for ""axis"".Definition Haxis.cxx:40; TH1::CloneTObject * Clone(const char *newname="""") const overrideMake a complete copy of the underlying object.Definition TH1.cxx:2752; TH1::GetStdDevErrorvirtual Double_t GetStdDevError(Int_t axis=1) constReturn error of standard deviation estimation for Normal distribution.Definition TH1.cxx:7655; TH1::Dividevirtual Bool_t Divide(TF1 *f1, Double_t c1=1)Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:2840; TH1::GetMinimumvirtual Double_t GetMinimum(Double_t minval=-FLT_MAX) constReturn minimum value larger than minval of bins in the range, unless the value has been overridden by...Definition TH1.cxx:8635; TH1::LoggedInconsistencyint LoggedInconsistency(const char *name, const TH1 *h1, const TH1 *h2, bool useMerge=false) constDefinition TH1.cxx:883; TH1::CheckConsistentSubAxesstatic bool CheckConsistentSubAxes(const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0)Check that two sub axis are the same.Definition TH1.cxx:1640; TH1::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove object from the list of functions.Definition TH1.cxx:6576; TH1::fYaxisTAxis fYaxisY axis descriptor.Definition TH1.h:91; TH1::KolmogorovTestvirtual Double_t KolmogorovTest(const TH1 *h2, Option_t *option="""") constStatistical test of compati",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:44978,Deployability,update,update,44978,"a byte per channel (see TH1 documentation)Definition TH1.h:458; TH1C::~TH1C~TH1C() overrideDestructor.Definition TH1.cxx:9521; TH1C::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH1.cxx:9577; TH1C::operator=TH1C & operator=(const TH1C &h1)Operator =.Definition TH1.cxx:9587; TH1C::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.h:485; TH1C::TH1CTH1C()Constructor.Definition TH1.cxx:9473; TH1C::Copyvoid Copy(TObject &hnew) const overrideCopy this to newth1.Definition TH1.cxx:9559; TH1C::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH1.cxx:9538; TH1C::Resetvoid Reset(Option_t *option="""") overrideReset.Definition TH1.cxx:9567; TH1C::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH1.h:486; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1D::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.h:703; TH1D::~TH1D~TH1D() overrideDestructor.Definition TH1.cxx:10467; TH1D::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH1.cxx:10501; TH1D::Copyvoid Copy(TObject &hnew) const overrideCopy this to newth1.Definition TH1.cxx:10483; TH1D::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH1.h:704; TH1D::TH1DTH1D()Constructor.Definition TH1.cxx:10402; TH1D",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:45800,Deployability,update,update,45800,"cxx:9538; TH1C::Resetvoid Reset(Option_t *option="""") overrideReset.Definition TH1.cxx:9567; TH1C::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH1.h:486; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1D::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.h:703; TH1D::~TH1D~TH1D() overrideDestructor.Definition TH1.cxx:10467; TH1D::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH1.cxx:10501; TH1D::Copyvoid Copy(TObject &hnew) const overrideCopy this to newth1.Definition TH1.cxx:10483; TH1D::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH1.h:704; TH1D::TH1DTH1D()Constructor.Definition TH1.cxx:10402; TH1D::operator=TH1D & operator=(const TH1D &h1)Operator =.Definition TH1.cxx:10511; TH1D::AddBinContentvoid AddBinContent(Int_t bin, Double_t w) overrideIncrement bin content by a weight w Passing an out-of-range bin leads to undefined behavior.Definition TH1.h:687; TH1D::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH1.h:684; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1F::AddBinContentvoid AddBinContent(Int_t bin, Double_t w) overrideIncrement bin content by a weight w.Definition TH1.h:640; TH1F::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH1.h:636; TH1F::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structur",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:47042,Deployability,update,update,47042,"n TH1.cxx:10511; TH1D::AddBinContentvoid AddBinContent(Int_t bin, Double_t w) overrideIncrement bin content by a weight w Passing an out-of-range bin leads to undefined behavior.Definition TH1.h:687; TH1D::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH1.h:684; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1F::AddBinContentvoid AddBinContent(Int_t bin, Double_t w) overrideIncrement bin content by a weight w.Definition TH1.h:640; TH1F::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH1.h:636; TH1F::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.h:656; TH1F::operator=TH1F & operator=(const TH1F &h1)Operator =.Definition TH1.cxx:10330; TH1F::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH1.h:657; TH1F::Copyvoid Copy(TObject &hnew) const overrideCopy this to newth1.Definition TH1.cxx:10302; TH1F::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH1.cxx:10320; TH1F::~TH1F~TH1F() overrideDestructor.Definition TH1.cxx:10295; TH1F::TH1FTH1F()Constructor.Definition TH1.cxx:10221; TH1I1-D histogram with an int per channel (see TH1 documentation)Definition TH1.h:540; TH1I::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH1.cxx:9950; TH1I::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH1.cxx:9911; TH1I::~TH1I~TH1I() overrideDestructor.Definition TH1.cxx:9894; TH1I::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrid",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:48048,Deployability,update,update,48048,"of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH1.h:657; TH1F::Copyvoid Copy(TObject &hnew) const overrideCopy this to newth1.Definition TH1.cxx:10302; TH1F::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH1.cxx:10320; TH1F::~TH1F~TH1F() overrideDestructor.Definition TH1.cxx:10295; TH1F::TH1FTH1F()Constructor.Definition TH1.cxx:10221; TH1I1-D histogram with an int per channel (see TH1 documentation)Definition TH1.h:540; TH1I::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH1.cxx:9950; TH1I::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH1.cxx:9911; TH1I::~TH1I~TH1I() overrideDestructor.Definition TH1.cxx:9894; TH1I::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH1.h:568; TH1I::TH1ITH1I()Constructor.Definition TH1.cxx:9846; TH1I::Copyvoid Copy(TObject &hnew) const overrideCopy this to newth1.Definition TH1.cxx:9932; TH1I::operator=TH1I & operator=(const TH1I &h1)Operator =.Definition TH1.cxx:9960; TH1I::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.h:567; TH1L1-D histogram with a long64 per channel (see TH1 documentation)Definition TH1.h:581; TH1L::operator=TH1L & operator=(const TH1L &h1)Operator =.Definition TH1.cxx:10148; TH1L::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.h:608; TH1L::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin ",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:49551,Deployability,update,update,49551,"numbering bins in TH1::Get...Definition TH1.h:567; TH1L1-D histogram with a long64 per channel (see TH1 documentation)Definition TH1.h:581; TH1L::operator=TH1L & operator=(const TH1L &h1)Operator =.Definition TH1.cxx:10148; TH1L::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.h:608; TH1L::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH1.cxx:10099; TH1L::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH1.cxx:10138; TH1L::~TH1L~TH1L() overrideDestructor.Definition TH1.cxx:10082; TH1L::TH1LTH1L()Constructor.Definition TH1.cxx:10034; TH1L::Copyvoid Copy(TObject &hnew) const overrideCopy this to newth1.Definition TH1.cxx:10120; TH1L::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH1.h:609; TH1MergerDefinition TH1Merger.h:20; TH1S1-D histogram with a short per channel (see TH1 documentation)Definition TH1.h:499; TH1S::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH1.h:527; TH1S::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.h:526; TH1S::operator=TH1S & operator=(const TH1S &h1)Operator =.Definition TH1.cxx:9773; TH1S::Copyvoid Copy(TObject &hnew) const overrideCopy this to newth1.Definition TH1.cxx:9745; TH1S::TH1STH1S()Constructor.Definition TH1.cxx:9659; TH1S::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Realloc",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:49882,Deployability,update,update,49882,"internal data structure see convention for numbering bins in TH1::Get...Definition TH1.h:608; TH1L::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH1.cxx:10099; TH1L::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH1.cxx:10138; TH1L::~TH1L~TH1L() overrideDestructor.Definition TH1.cxx:10082; TH1L::TH1LTH1L()Constructor.Definition TH1.cxx:10034; TH1L::Copyvoid Copy(TObject &hnew) const overrideCopy this to newth1.Definition TH1.cxx:10120; TH1L::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH1.h:609; TH1MergerDefinition TH1Merger.h:20; TH1S1-D histogram with a short per channel (see TH1 documentation)Definition TH1.h:499; TH1S::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH1.h:527; TH1S::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.h:526; TH1S::operator=TH1S & operator=(const TH1S &h1)Operator =.Definition TH1.cxx:9773; TH1S::Copyvoid Copy(TObject &hnew) const overrideCopy this to newth1.Definition TH1.cxx:9745; TH1S::TH1STH1S()Constructor.Definition TH1.cxx:9659; TH1S::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH1.cxx:9763; TH1S::~TH1S~TH1S() overrideDestructor.Definition TH1.cxx:9707; TH1S::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH1.cxx:9724; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::~TH1~TH1() overrideHistogram ",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:77111,Deployability,update,update,77111,"of entries.Definition TH1.h:95; TH1::Mergevirtual Long64_t Merge(TCollection *list)Definition TH1.h:345; TH1::SetColorsvirtual void SetColors(Color_t linecolor=-1, Color_t markercolor=-1, Color_t fillcolor=-1)Shortcut to set the three histogram colors with a single call.Definition TH1.cxx:4467; TH1::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TH1.cxx:3240; TH1::GetIntegralvirtual Double_t * GetIntegral()Return a pointer to the array of bins integral.Definition TH1.cxx:2586; TH1::fZaxisTAxis fZaxisZ axis descriptor.Definition TH1.h:92; TH1::fStatOverflowsEStatOverflows fStatOverflowsPer object flag to use under/overflows in statistics.Definition TH1.h:114; TH1::FillNvirtual void FillN(Int_t ntimes, const Double_t *x, const Double_t *w, Int_t stride=1)Fill this histogram with an array x and weights w.Definition TH1.cxx:3447; TH1::UpdateBinContentvirtual void UpdateBinContent(Int_t bin, Double_t content)Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH1.cxx:9449; TH1::GetLabelOffsetvirtual Float_t GetLabelOffset(Option_t *axis=""X"") constReturn the ""axis"" label offset.Definition Haxis.cxx:79; TH1::CheckEqualAxesstatic bool CheckEqualAxes(const TAxis *a1, const TAxis *a2)Check that the axis are the same.Definition TH1.cxx:1611; TH1::EBinErrorOptEBinErrorOptEnumeration specifying type of statistics for bin errors.Definition TH1.h:64; TH1::kPoisson2@ kPoisson2Errors from Poisson interval at 95% CL (~ 2 sigma)Definition TH1.h:67; TH1::kNormal@ kNormalErrors with Normal (Wald) approximation: errorUp=errorLow= sqrt(N)Definition TH1.h:65; TH1::kPoisson@ kPoissonErrors from Poisson interval at 68.3% (1 sigma)Definition TH1.h:66; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetSumw2virtual TArrayD * GetSumw2()Definition TH1.h:313; TH1::GetContourvirtual",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:51708,Energy Efficiency,power,power,51708," TH1.cxx:9707; TH1S::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH1.cxx:9724; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::~TH1~TH1() overrideHistogram default destructor.Definition TH1.cxx:643; TH1::SetLabelFontvirtual void SetLabelFont(Style_t font=62, Option_t *axis=""X"")Set font number used to draw axis labels.Definition Haxis.cxx:249; TH1::SetErrorvirtual void SetError(const Double_t *error)Replace bin errors by values in array error.Definition TH1.cxx:8951; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::FitPanelvirtual void FitPanel()Display a panel with all histogram fit options.Definition TH1.cxx:4284; TH1::fBufferDouble_t * fBuffer[fBufferSize] entry bufferDefinition TH1.h:108; TH1::AutoP2FindLimitsvirtual Int_t AutoP2FindLimits(Double_t min, Double_t max)Buffer-based estimate of the histogram range using the power of 2 algorithm.Definition TH1.cxx:1343; TH1::SetStatOverflowsvoid SetStatOverflows(EStatOverflows statOverflows)See GetStatOverflows for more information.Definition TH1.h:417; TH1::GetEffectiveEntriesvirtual Double_t GetEffectiveEntries() constNumber of effective entries of the histogram.Definition TH1.cxx:4448; TH1::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideRedefines TObject::GetObjectInfo.Definition TH1.cxx:4502; TH1::Smoothvirtual void Smooth(Int_t ntimes=1, Option_t *option="""")Smooth bin contents of this histogram.Definition TH1.cxx:6879; TH1::SetNormFactorvirtual void SetNormFactor(Double_t factor=1)Definition TH1.h:410; TH1::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn bin center for 1D histogram.Definition TH1.cxx:9141; TH1::Rebuildvirtual void Rebuild(Option_t *option="""")Using the current bin info, recompute the arrays for contents and errors.Definition TH1.cxx:7087; ",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:62117,Energy Efficiency,power,power,62117,"6636; TH1::fDirectoryTDirectory * fDirectory! Pointer to directory holding this histogramDefinition TH1.h:109; TH1::GetOptionOption_t * GetOption() const overrideDefinition TH1.h:303; TH1::Resetvirtual void Reset(Option_t *option="""")Reset this histogram: contents, errors, etc.Definition TH1.cxx:7103; TH1::SetNameTitlevoid SetNameTitle(const char *name, const char *title) overrideChange the name and title of this histogram.Definition TH1.cxx:8974; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetBinXYZvirtual void GetBinXYZ(Int_t binglobal, Int_t &binx, Int_t &biny, Int_t &binz) constReturn binx, biny, binz corresponding to the global bin number globalbin see TH1::GetBin function abo...Definition TH1.cxx:4974; TH1::GetCumulativeTH1 * GetCumulative(Bool_t forward=kTRUE, const char *suffix=""_cumulative"") constReturn a pointer to a histogram containing the cumulative content.Definition TH1.cxx:2616; TH1::AutoP2GetPower2static Double_t AutoP2GetPower2(Double_t x, Bool_t next=kTRUE)Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x.Definition TH1.cxx:1308; TH1::GetNcellsvirtual Int_t GetNcells() constDefinition TH1.h:300; TH1::ShowPeaksvirtual Int_t ShowPeaks(Double_t sigma=2, Option_t *option="""", Double_t threshold=0.05)Interface to TSpectrum::Search.Definition TH1.cxx:9301; TH1::GetBufferLengthInt_t GetBufferLength() constDefinition TH1.h:237; TH1::RecomputeAxisLimitsstatic Bool_t RecomputeAxisLimits(TAxis &destAxis, const TAxis &anAxis)Finds new limits for the axis for the Merge function.Definition TH1.cxx:5908; TH1::GetTitleFontvirtual Style_t GetTitleFont(Option_t *axis=""X"") constReturn the ""axis"" title font.Definition Haxis.cxx:118; TH1::SetNdivisionsvirtual void SetNdivisions(Int_t n=510, Option_t *axis=""X"")Set the number of divisions to draw an axis.Definition Haxis.cxx:170; TH1::GetLabelFontvirtual Style_t GetLabelFont(Option_t *axis=""X"") constReturn the ""axis"" label font.Definition Haxis.cxx:66; TH1::GetTickLengthvi",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:76012,Energy Efficiency,power,power,76012,"estvirtual Double_t Chi2Test(const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) consttest for comparing weighted and unweighted histograms.Definition TH1.cxx:2008; TH1::GetMaximumStoredvirtual Double_t GetMaximumStored() constDefinition TH1.h:289; TH1::DoFillNvirtual void DoFillN(Int_t ntimes, const Double_t *x, const Double_t *w, Int_t stride=1)Internal method to fill histogram content from a vector called directly by TH1::BufferEmpty.Definition TH1.cxx:3473; TH1::GetMinimumAndMaximumvirtual void GetMinimumAndMaximum(Double_t &min, Double_t &max) constRetrieve the minimum and maximum values in the histogram.Definition TH1.cxx:8731; TH1::kNstat@ kNstatSize of statistics data (up to TProfile3D)Definition TH1.h:184; TH1::GetSumw2virtual const TArrayD * GetSumw2() constDefinition TH1.h:314; TH1::GetMaximumBinvirtual Int_t GetMaximumBin() constReturn location of bin with maximum value in the range.Definition TH1.cxx:8577; TH1::AutoP2GetBinsstatic Int_t AutoP2GetBins(Int_t n)Auxiliary function to get the next power of 2 integer value larger then n.Definition TH1.cxx:1321; TH1::fEntriesDouble_t fEntriesNumber of entries.Definition TH1.h:95; TH1::Mergevirtual Long64_t Merge(TCollection *list)Definition TH1.h:345; TH1::SetColorsvirtual void SetColors(Color_t linecolor=-1, Color_t markercolor=-1, Color_t fillcolor=-1)Shortcut to set the three histogram colors with a single call.Definition TH1.cxx:4467; TH1::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TH1.cxx:3240; TH1::GetIntegralvirtual Double_t * GetIntegral()Return a pointer to the array of bins integral.Definition TH1.cxx:2586; TH1::fZaxisTAxis fZaxisZ axis descriptor.Definition TH1.h:92; TH1::fStatOverflowsEStatOverflows fStatOverflowsPer object flag to use under/overflows in statistics.Definition TH1.h:114; TH1::FillNvirtual void FillN(Int_t ntimes, const Double_t *x, const Double_t *w, Int_t stride=1)Fill this histogram with an ar",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:57756,Integrability,rout,routine,57756," of weight*X*X.Definition TH1.h:99; TH1::GetStdDevvirtual Double_t GetStdDev(Int_t axis=1) constReturns the Standard Deviation (Sigma).Definition TH1.cxx:7607; TH1::TH1TH1()Histogram default constructor.Definition TH1.cxx:615; TH1::TransformHistostatic TH1 * TransformHisto(TVirtualFFT *fft, TH1 *h_output, Option_t *option)For a given transform (first parameter), fills the histogram (second parameter) with the transform ou...Definition TH1.cxx:9319; TH1::UseCurrentStylevoid UseCurrentStyle() overrideCopy current attributes from/to current style.Definition TH1.cxx:7469; TH1::LabelsOptionvirtual void LabelsOption(Option_t *option=""h"", Option_t *axis=""X"")Sort bins with labels or set option(s) to draw axis with labels.Definition TH1.cxx:5382; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::fBarOffsetShort_t fBarOffset(1000*offset) for bar charts or legosDefinition TH1.h:93; TH1::Chi2TestXvirtual Double_t Chi2TestX(const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) constThe computation routine of the Chisquare test.Definition TH1.cxx:2067; TH1::CheckBinLimitsstatic bool CheckBinLimits(const TAxis *a1, const TAxis *a2)Check bin limits.Definition TH1.cxx:1541; TH1::AddBinContentvirtual void AddBinContent(Int_t bin)Increment bin content by 1.Definition TH1.cxx:1268; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associated to bin number bin.Definition TH1.cxx:9063; TH1::FitOptionsMakestatic Int_t FitOptionsMake(Option_t *option, Foption_t &Foption)Decode string choptin and fill fitOption structure.Definition TH1.cxx:4652; TH1::GetNbinsZvirtual Int_t GetNbinsZ() constDefinition TH1.h:299; TH1::GetNormFactorvirtual Double_t GetNormFactor() constDefinition TH1.h:301; TH1::GetMeanvirtual Double_t GetMean(Int_t axis=1) constFor axis = 1,2 or 3 returns the mean value of the histogram along X,Y or Z axis.Definition TH1.cxx:7535; TH1::TH1TH1(const TH1 &)=delete; TH1::GetSke",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:73420,Integrability,rout,routine,73420,"t_t SetCanExtend(UInt_t extendBitMask)Make the histogram axes extendable / not extendable according to the bit mask returns the previous bi...Definition TH1.cxx:6649; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::DrawCopyvirtual TH1 * DrawCopy(Option_t *option="""", const char *name_postfix=""_copy"") constCopy this histogram and Draw in the current pad.Definition TH1.cxx:3113; TH1::GetTitleOffsetvirtual Float_t GetTitleOffset(Option_t *axis=""X"") constReturn the ""axis"" title offset.Definition Haxis.cxx:131; TH1::IsEmptyBool_t IsEmpty() constCheck if a histogram is empty (this is a protected method used mainly by TH1Merger )Definition TH1.cxx:5164; TH1::GetMeanErrorvirtual Double_t GetMeanError(Int_t axis=1) constReturn standard error of mean of this histogram along the X axis.Definition TH1.cxx:7575; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::AndersonDarlingTestvirtual Double_t AndersonDarlingTest(const TH1 *h2, Option_t *option="""") constStatistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling ...Definition TH1.cxx:8062; TH1::ResetStatsvirtual void ResetStats()Reset the statistics including the number of entries and replace with values calculated from bin cont...Definition TH1.cxx:7902; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Int_t, Int_t, Double_t content)Definition TH1.h:368; TH1::SetDefaultBufferSizestatic void SetDefaultBufferSize(Int_t buffersize=1000)Static function to set the default buffer size for automatic histograms.Definition TH1.cxx:6693; TH1::SetBinErrorOptionvirtual void SetBinErrorOption(EBinErrorOpt type)Definition TH1.h:381; TH1::SetBuffervirtual void SetBuffer(Int_t buffersize, Option_t *option="""")Set the maximum number of entries to be kept in the buffer.Definiti",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:83594,Integrability,rout,routine,83594,"H1.cxx:8635; TH1::LoggedInconsistencyint LoggedInconsistency(const char *name, const TH1 *h1, const TH1 *h2, bool useMerge=false) constDefinition TH1.cxx:883; TH1::CheckConsistentSubAxesstatic bool CheckConsistentSubAxes(const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0)Check that two sub axis are the same.Definition TH1.cxx:1640; TH1::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove object from the list of functions.Definition TH1.cxx:6576; TH1::fYaxisTAxis fYaxisY axis descriptor.Definition TH1.h:91; TH1::KolmogorovTestvirtual Double_t KolmogorovTest(const TH1 *h2, Option_t *option="""") constStatistical test of compatibility in shape between this histogram and h2, using Kolmogorov test.Definition TH1.cxx:8178; TH1::GetSumOfWeightsvirtual Double_t GetSumOfWeights() constReturn the sum of weights excluding under/overflows.Definition TH1.cxx:7917; TH1::SmoothArraystatic void SmoothArray(Int_t NN, Double_t *XX, Int_t ntimes=1)Smooth array xx, translation of Hbook routine hsmoof.F.Definition TH1.cxx:6768; TH1::GetCentervirtual void GetCenter(Double_t *center) constFill array with center of bins for 1D histogram Better to use h1.GetXaxis()->GetCenter(center)Definition TH1.cxx:9174; TH1::fPainterTVirtualHistPainter * fPainter! Pointer to histogram painterDefinition TH1.h:112; TH1::SetBinsvirtual void SetBins(Int_t nx, Double_t xmin, Double_t xmax)Redefine x axis parameters.Definition TH1.cxx:8767; TH1::FindFixBinvirtual Int_t FindFixBin(Double_t x, Double_t y=0, Double_t z=0) constReturn Global bin number corresponding to x,y,z.Definition TH1.cxx:3705; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Int_t, Double_t content)Definition TH1.h:367; TH1::SetLabelSizevirtual void SetLabelSize(Float_t size=0.02, Option_t *axis=""X"")Set size of axis' labels.Definition Haxis.cxx:285; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create structure to store sum of squares of weights.Definition TH",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:87471,Integrability,interface,interface,87471,"::SetStatsvirtual void SetStats(Bool_t stats=kTRUE)Set statistics option on/off.Definition TH1.cxx:8990; TH1::SetTickLengthvirtual void SetTickLength(Float_t length=0.02, Option_t *axis=""X"")Set the axis' tick marks length.Definition Haxis.cxx:302; TH1::GetKurtosisvirtual Double_t GetKurtosis(Int_t axis=1) constDefinition TH1.cxx:7744; TListA doubly linked list.Definition TList.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Obsoletevoid Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) constUse this method to declare a method obsolete.Definition TObject.cxx:1055; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TVectorTTVectorT.Definition TVectorT.h:27; TVirtualFFTTVirtualFFT is an interface class for Fast Fourier Transforms.Definition TVirtualFFT.h:88; TVirtualHistPainterAbstract interface to a histogram painter.Definition TVirtualHistPainter.h:30; bool; double; int; unsigned int; Interpolate#define Interpolate(a, x, b, y)Definition geom.c:179; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; h1TH1F * h1Definition legend1.C:5; f1TF1 * f1Definition legend1.C:11; c2return c2Definition legend2.C:14; v@ vDefinition rootcling_impl.cxx:3699; Foption_tDefinition Foption.h:24; Drawth1 Draw(). histhistincTH1.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:87572,Integrability,interface,interface,87572,"::SetStatsvirtual void SetStats(Bool_t stats=kTRUE)Set statistics option on/off.Definition TH1.cxx:8990; TH1::SetTickLengthvirtual void SetTickLength(Float_t length=0.02, Option_t *axis=""X"")Set the axis' tick marks length.Definition Haxis.cxx:302; TH1::GetKurtosisvirtual Double_t GetKurtosis(Int_t axis=1) constDefinition TH1.cxx:7744; TListA doubly linked list.Definition TList.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Obsoletevoid Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) constUse this method to declare a method obsolete.Definition TObject.cxx:1055; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TVectorTTVectorT.Definition TVectorT.h:27; TVirtualFFTTVirtualFFT is an interface class for Fast Fourier Transforms.Definition TVirtualFFT.h:88; TVirtualHistPainterAbstract interface to a histogram painter.Definition TVirtualHistPainter.h:30; bool; double; int; unsigned int; Interpolate#define Interpolate(a, x, b, y)Definition geom.c:179; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; h1TH1F * h1Definition legend1.C:5; f1TF1 * f1Definition legend1.C:11; c2return c2Definition legend2.C:14; v@ vDefinition rootcling_impl.cxx:3699; Foption_tDefinition Foption.h:24; Drawth1 Draw(). histhistincTH1.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:2005,Modifiability,extend,extended,2005,3% (1 sigma); 67 kPoisson2 = 2 ///< Errors from Poisson interval at 95% CL (~ 2 sigma); 68 };; 69 ; 70 /// Enumeration specifying which axes can,MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:21024,Modifiability,extend,extendBitMask,21024,"t content) { SetBinContent(bin, content); }; 369 virtual void SetBinError(Int_t bin, Double_t error);; 370 virtual void SetBinError(Int_t binx, Int_t biny, Double_t error);; 371 virtual void SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error);; 372 virtual void SetBins(Int_t nx, Double_t xmin, Double_t xmax);; 373 virtual void SetBins(Int_t nx, const Double_t *xBins);; 374 virtual void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax);; 375 virtual void SetBins(Int_t nx, const Double_t *xBins, Int_t ny, const Double_t *yBins);; 376 virtual void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax,; 377 Int_t nz, Double_t zmin, Double_t zmax);; 378 virtual void SetBins(Int_t nx, const Double_t *xBins, Int_t ny, const Double_t * yBins, Int_t nz,; 379 const Double_t *zBins);; 380 virtual void SetBinsLength(Int_t = -1) { } //redefined in derived classes; 381 virtual void SetBinErrorOption(EBinErrorOpt type) { fBinStatErrOpt = type; }; 382 virtual void SetBuffer(Int_t buffersize, Option_t *option="""");; 383 virtual UInt_t SetCanExtend(UInt_t extendBitMask);; 384 virtual void SetContent(const Double_t *content);; 385 virtual void SetContour(Int_t nlevels, const Double_t *levels = nullptr);; 386 virtual void SetContourLevel(Int_t level, Double_t value);; 387 virtual void SetColors(Color_t linecolor = -1, Color_t markercolor = -1, Color_t fillcolor = -1);; 388 static void SetDefaultBufferSize(Int_t buffersize=1000);; 389 static void SetDefaultSumw2(Bool_t sumw2=kTRUE);; 390 virtual void SetDirectory(TDirectory *dir);; 391 virtual void SetEntries(Double_t n) { fEntries = n; }; 392 virtual void SetError(const Double_t *error);; 393 virtual void SetHighlight(Bool_t set = kTRUE); // *TOGGLE* *GETTER=IsHighlight; 394 virtual void SetLabelColor(Color_t color=1, Option_t *axis=""X"");; 395 virtual void SetLabelFont(Style_t font=62, Option_t *axis=""X"");; 396 virtual void SetLabelOffset(Float_t offset=0.",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:61054,Modifiability,extend,extendable,61054,"nstDefinition TH1.h:266; TH1::EStatusBitsEStatusBitsTH1 status bits.Definition TH1.h:164; TH1::kLogX@ kLogXX-axis in log scale.Definition TH1.h:168; TH1::kIsAverage@ kIsAverageBin contents are average (used by Add)Definition TH1.h:171; TH1::kNoTitle@ kNoTitleDon't draw the histogram title.Definition TH1.h:170; TH1::kUserContour@ kUserContourUser specified contour levels.Definition TH1.h:166; TH1::kNoStats@ kNoStatsDon't draw stats box.Definition TH1.h:165; TH1::kIsZoomed@ kIsZoomedBit set when zooming on Y axis.Definition TH1.h:169; TH1::kAutoBinPTwo@ kAutoBinPTwodifferent than 1.Definition TH1.h:174; TH1::kIsNotW@ kIsNotWHistogram is forced to be not weighted even when the histogram is filled with weighted.Definition TH1.h:172; TH1::kIsHighlight@ kIsHighlightbit set if histo is highlightDefinition TH1.h:175; TH1::SetContourLevelvirtual void SetContourLevel(Int_t level, Double_t value)Set value for one contour level.Definition TH1.cxx:8522; TH1::CanExtendAllAxesvirtual Bool_t CanExtendAllAxes() constReturns true if all axes are extendable.Definition TH1.cxx:6636; TH1::fDirectoryTDirectory * fDirectory! Pointer to directory holding this histogramDefinition TH1.h:109; TH1::GetOptionOption_t * GetOption() const overrideDefinition TH1.h:303; TH1::Resetvirtual void Reset(Option_t *option="""")Reset this histogram: contents, errors, etc.Definition TH1.cxx:7103; TH1::SetNameTitlevoid SetNameTitle(const char *name, const char *title) overrideChange the name and title of this histogram.Definition TH1.cxx:8974; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetBinXYZvirtual void GetBinXYZ(Int_t binglobal, Int_t &binx, Int_t &biny, Int_t &binz) constReturn binx, biny, binz corresponding to the global bin number globalbin see TH1::GetBin function abo...Definition TH1.cxx:4974; TH1::GetCumulativeTH1 * GetCumulative(Bool_t forward=kTRUE, const char *suffix=""_cumulative"") constReturn a pointer to a histogram containing the cumulative content.Definition TH1.cxx:2616; TH1::",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:72430,Modifiability,extend,extendBitMask,72430,"tion TH1.cxx:771; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::GetZaxisconst TAxis * GetZaxis() constDefinition TH1.h:329; TH1::SetZTitlevirtual void SetZTitle(const char *title)Definition TH1.h:421; TH1::GetFunctionvirtual TF1 * GetFunction(const char *name) constReturn pointer to function with name.Definition TH1.cxx:9051; TH1::Rebinvirtual TH1 * Rebin(Int_t ngroup=2, const char *newname="""", const Double_t *xbins=nullptr)Rebin this histogram.Definition TH1.cxx:6275; TH1::BufferFillvirtual Int_t BufferFill(Double_t x, Double_t w)accumulate arguments in buffer.Definition TH1.cxx:1506; TH1::GetBinWithContentvirtual Double_t GetBinWithContent(Double_t c, Int_t &binx, Int_t firstx=0, Int_t lastx=0, Double_t maxdiff=0) constCompute first binx in the range [firstx,lastx] for which diff = abs(bin_content-c) <= maxdiff.Definition TH1.cxx:5086; TH1::SetCanExtendvirtual UInt_t SetCanExtend(UInt_t extendBitMask)Make the histogram axes extendable / not extendable according to the bit mask returns the previous bi...Definition TH1.cxx:6649; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::DrawCopyvirtual TH1 * DrawCopy(Option_t *option="""", const char *name_postfix=""_copy"") constCopy this histogram and Draw in the current pad.Definition TH1.cxx:3113; TH1::GetTitleOffsetvirtual Float_t GetTitleOffset(Option_t *axis=""X"") constReturn the ""axis"" title offset.Definition Haxis.cxx:131; TH1::IsEmptyBool_t IsEmpty() constCheck if a histogram is empty (this is a protected method used mainly by TH1Merger )Definition TH1.cxx:5164; TH1::GetMeanErrorvirtual Double_t GetMeanError(Int_t axis=1) constReturn standard error of mean of this histogram along the X axis.Definition TH1.cxx:7575; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histogra",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:72468,Modifiability,extend,extendable,72468,"tion TH1.cxx:771; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::GetZaxisconst TAxis * GetZaxis() constDefinition TH1.h:329; TH1::SetZTitlevirtual void SetZTitle(const char *title)Definition TH1.h:421; TH1::GetFunctionvirtual TF1 * GetFunction(const char *name) constReturn pointer to function with name.Definition TH1.cxx:9051; TH1::Rebinvirtual TH1 * Rebin(Int_t ngroup=2, const char *newname="""", const Double_t *xbins=nullptr)Rebin this histogram.Definition TH1.cxx:6275; TH1::BufferFillvirtual Int_t BufferFill(Double_t x, Double_t w)accumulate arguments in buffer.Definition TH1.cxx:1506; TH1::GetBinWithContentvirtual Double_t GetBinWithContent(Double_t c, Int_t &binx, Int_t firstx=0, Int_t lastx=0, Double_t maxdiff=0) constCompute first binx in the range [firstx,lastx] for which diff = abs(bin_content-c) <= maxdiff.Definition TH1.cxx:5086; TH1::SetCanExtendvirtual UInt_t SetCanExtend(UInt_t extendBitMask)Make the histogram axes extendable / not extendable according to the bit mask returns the previous bi...Definition TH1.cxx:6649; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::DrawCopyvirtual TH1 * DrawCopy(Option_t *option="""", const char *name_postfix=""_copy"") constCopy this histogram and Draw in the current pad.Definition TH1.cxx:3113; TH1::GetTitleOffsetvirtual Float_t GetTitleOffset(Option_t *axis=""X"") constReturn the ""axis"" title offset.Definition Haxis.cxx:131; TH1::IsEmptyBool_t IsEmpty() constCheck if a histogram is empty (this is a protected method used mainly by TH1Merger )Definition TH1.cxx:5164; TH1::GetMeanErrorvirtual Double_t GetMeanError(Int_t axis=1) constReturn standard error of mean of this histogram along the X axis.Definition TH1.cxx:7575; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histogra",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:72485,Modifiability,extend,extendable,72485,"tion TH1.cxx:771; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::GetZaxisconst TAxis * GetZaxis() constDefinition TH1.h:329; TH1::SetZTitlevirtual void SetZTitle(const char *title)Definition TH1.h:421; TH1::GetFunctionvirtual TF1 * GetFunction(const char *name) constReturn pointer to function with name.Definition TH1.cxx:9051; TH1::Rebinvirtual TH1 * Rebin(Int_t ngroup=2, const char *newname="""", const Double_t *xbins=nullptr)Rebin this histogram.Definition TH1.cxx:6275; TH1::BufferFillvirtual Int_t BufferFill(Double_t x, Double_t w)accumulate arguments in buffer.Definition TH1.cxx:1506; TH1::GetBinWithContentvirtual Double_t GetBinWithContent(Double_t c, Int_t &binx, Int_t firstx=0, Int_t lastx=0, Double_t maxdiff=0) constCompute first binx in the range [firstx,lastx] for which diff = abs(bin_content-c) <= maxdiff.Definition TH1.cxx:5086; TH1::SetCanExtendvirtual UInt_t SetCanExtend(UInt_t extendBitMask)Make the histogram axes extendable / not extendable according to the bit mask returns the previous bi...Definition TH1.cxx:6649; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::DrawCopyvirtual TH1 * DrawCopy(Option_t *option="""", const char *name_postfix=""_copy"") constCopy this histogram and Draw in the current pad.Definition TH1.cxx:3113; TH1::GetTitleOffsetvirtual Float_t GetTitleOffset(Option_t *axis=""X"") constReturn the ""axis"" title offset.Definition Haxis.cxx:131; TH1::IsEmptyBool_t IsEmpty() constCheck if a histogram is empty (this is a protected method used mainly by TH1Merger )Definition TH1.cxx:5164; TH1::GetMeanErrorvirtual Double_t GetMeanError(Int_t axis=1) constReturn standard error of mean of this histogram along the X axis.Definition TH1.cxx:7575; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histogra",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:6990,Testability,log,log,6990,"s& axis1, const TAxis& axis2);; 141 Bool_t IsEmpty() const;; 142 UInt_t GetAxisLabelStatus() const;; 143 ; 144 inline static Double_t AutoP2GetPower2(Double_t x, Bool_t next = kTRUE);; 145 inline static Int_t AutoP2GetBins(Int_t n);; 146 virtual Int_t AutoP2FindLimits(Double_t min, Double_t max);; 147 ; 148 virtual Double_t DoIntegral(Int_t ix1, Int_t ix2, Int_t iy1, Int_t iy2, Int_t iz1, Int_t iz2, Double_t & err,; 149 Option_t * opt, Bool_t doerr = kFALSE) const;; 150 ; 151 virtual void DoFillN(Int_t ntimes, const Double_t *x, const Double_t *w, Int_t stride=1);; 152 Bool_t GetStatOverflowsBehaviour() const { return EStatOverflows::kNeutral == fStatOverflows ? fgStatOverflows : EStatOverflows::kConsider == fStatOverflows; }; 153 ; 154 static bool CheckAxisLimits(const TAxis* a1, const TAxis* a2);; 155 static bool CheckBinLimits(const TAxis* a1, const TAxis* a2);; 156 static bool CheckBinLabels(const TAxis* a1, const TAxis* a2);; 157 static bool CheckEqualAxes(const TAxis* a1, const TAxis* a2);; 158 static bool CheckConsistentSubAxes(const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0);; 159 static int CheckConsistency(const TH1* h1, const TH1* h2);; 160 int LoggedInconsistency(const char* name, const TH1* h1, const TH1* h2, bool useMerge=false) const;; 161 ; 162public:; 163 /// TH1 status bits; 164 enum EStatusBits {; 165 kNoStats = BIT(9), ///< Don't draw stats box; 166 kUserContour = BIT(10), ///< User specified contour levels; 167 // kCanRebin = BIT(11), ///< FIXME DEPRECATED - to be removed, replaced by SetCanExtend / CanExtendAllAxes; 168 kLogX = BIT(15), ///< X-axis in log scale; 169 kIsZoomed = BIT(16), ///< Bit set when zooming on Y axis; 170 kNoTitle = BIT(17), ///< Don't draw the histogram title; 171 kIsAverage = BIT(18), ///< Bin contents are average (used by Add); 172 kIsNotW = BIT(19), ///< Histogram is forced to be not weighted even when the histogram is filled with weighted; 173 /// different than 1.",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:57781,Testability,test,test,57781," of weight*X*X.Definition TH1.h:99; TH1::GetStdDevvirtual Double_t GetStdDev(Int_t axis=1) constReturns the Standard Deviation (Sigma).Definition TH1.cxx:7607; TH1::TH1TH1()Histogram default constructor.Definition TH1.cxx:615; TH1::TransformHistostatic TH1 * TransformHisto(TVirtualFFT *fft, TH1 *h_output, Option_t *option)For a given transform (first parameter), fills the histogram (second parameter) with the transform ou...Definition TH1.cxx:9319; TH1::UseCurrentStylevoid UseCurrentStyle() overrideCopy current attributes from/to current style.Definition TH1.cxx:7469; TH1::LabelsOptionvirtual void LabelsOption(Option_t *option=""h"", Option_t *axis=""X"")Sort bins with labels or set option(s) to draw axis with labels.Definition TH1.cxx:5382; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::fBarOffsetShort_t fBarOffset(1000*offset) for bar charts or legosDefinition TH1.h:93; TH1::Chi2TestXvirtual Double_t Chi2TestX(const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) constThe computation routine of the Chisquare test.Definition TH1.cxx:2067; TH1::CheckBinLimitsstatic bool CheckBinLimits(const TAxis *a1, const TAxis *a2)Check bin limits.Definition TH1.cxx:1541; TH1::AddBinContentvirtual void AddBinContent(Int_t bin)Increment bin content by 1.Definition TH1.cxx:1268; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associated to bin number bin.Definition TH1.cxx:9063; TH1::FitOptionsMakestatic Int_t FitOptionsMake(Option_t *option, Foption_t &Foption)Decode string choptin and fill fitOption structure.Definition TH1.cxx:4652; TH1::GetNbinsZvirtual Int_t GetNbinsZ() constDefinition TH1.h:299; TH1::GetNormFactorvirtual Double_t GetNormFactor() constDefinition TH1.h:301; TH1::GetMeanvirtual Double_t GetMean(Int_t axis=1) constFor axis = 1,2 or 3 returns the mean value of the histogram along X,Y or Z axis.Definition TH1.cxx:7535; TH1::TH1TH1(const TH1 &)=delete; TH1::GetSke",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:60127,Testability,log,log,60127,"1.cxx:8440; TH1::SetXTitlevirtual void SetXTitle(const char *title)Definition TH1.h:419; TH1::DrawNormalizedvirtual TH1 * DrawNormalized(Option_t *option="""", Double_t norm=1) constDraw a normalized copy of this histogram.Definition TH1.cxx:3144; TH1::EStatOverflowsEStatOverflowsEnumeration specifying the way to treat statoverflow.Definition TH1.h:80; TH1::kNeutral@ kNeutralAdapt to the global flag.Definition TH1.h:83; TH1::kIgnore@ kIgnoreOverride global flag ignoring the overflows.Definition TH1.h:81; TH1::kConsider@ kConsiderOverride global flag considering the overflows.Definition TH1.h:82; TH1::GetDimensionvirtual Int_t GetDimension() constDefinition TH1.h:283; TH1::AddDirectorystatic void AddDirectory(Bool_t add=kTRUE)Sets the flag controlling the automatic add of histograms in memory.Definition TH1.cxx:1294; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin, Int_t) constDefinition TH1.h:266; TH1::EStatusBitsEStatusBitsTH1 status bits.Definition TH1.h:164; TH1::kLogX@ kLogXX-axis in log scale.Definition TH1.h:168; TH1::kIsAverage@ kIsAverageBin contents are average (used by Add)Definition TH1.h:171; TH1::kNoTitle@ kNoTitleDon't draw the histogram title.Definition TH1.h:170; TH1::kUserContour@ kUserContourUser specified contour levels.Definition TH1.h:166; TH1::kNoStats@ kNoStatsDon't draw stats box.Definition TH1.h:165; TH1::kIsZoomed@ kIsZoomedBit set when zooming on Y axis.Definition TH1.h:169; TH1::kAutoBinPTwo@ kAutoBinPTwodifferent than 1.Definition TH1.h:174; TH1::kIsNotW@ kIsNotWHistogram is forced to be not weighted even when the histogram is filled with weighted.Definition TH1.h:172; TH1::kIsHighlight@ kIsHighlightbit set if histo is highlightDefinition TH1.h:175; TH1::SetContourLevelvirtual void SetContourLevel(Int_t level, Double_t value)Set value for one contour level.Definition TH1.cxx:8522; TH1::CanExtendAllAxesvirtual Bool_t CanExtendAllAxes() constReturns true if all axes are extendable.Definition TH1.cxx:6636; TH1::fDirectoryTDirectory",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:73599,Testability,test,test,73599,"istOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::DrawCopyvirtual TH1 * DrawCopy(Option_t *option="""", const char *name_postfix=""_copy"") constCopy this histogram and Draw in the current pad.Definition TH1.cxx:3113; TH1::GetTitleOffsetvirtual Float_t GetTitleOffset(Option_t *axis=""X"") constReturn the ""axis"" title offset.Definition Haxis.cxx:131; TH1::IsEmptyBool_t IsEmpty() constCheck if a histogram is empty (this is a protected method used mainly by TH1Merger )Definition TH1.cxx:5164; TH1::GetMeanErrorvirtual Double_t GetMeanError(Int_t axis=1) constReturn standard error of mean of this histogram along the X axis.Definition TH1.cxx:7575; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::AndersonDarlingTestvirtual Double_t AndersonDarlingTest(const TH1 *h2, Option_t *option="""") constStatistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling ...Definition TH1.cxx:8062; TH1::ResetStatsvirtual void ResetStats()Reset the statistics including the number of entries and replace with values calculated from bin cont...Definition TH1.cxx:7902; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Int_t, Int_t, Double_t content)Definition TH1.h:368; TH1::SetDefaultBufferSizestatic void SetDefaultBufferSize(Int_t buffersize=1000)Static function to set the default buffer size for automatic histograms.Definition TH1.cxx:6693; TH1::SetBinErrorOptionvirtual void SetBinErrorOption(EBinErrorOpt type)Definition TH1.h:381; TH1::SetBuffervirtual void SetBuffer(Int_t buffersize, Option_t *option="""")Set the maximum number of entries to be kept in the buffer.Definition TH1.cxx:8458; TH1::DrawPanelvirtual void DrawPanel()Display a panel with all histogram drawing options.Definition TH1.cxx:3175; TH1::GetRandomvirtual Double_t GetRandom(TRan",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:83231,Testability,test,test,83231,"*f1, Double_t c1=1)Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:2840; TH1::GetMinimumvirtual Double_t GetMinimum(Double_t minval=-FLT_MAX) constReturn minimum value larger than minval of bins in the range, unless the value has been overridden by...Definition TH1.cxx:8635; TH1::LoggedInconsistencyint LoggedInconsistency(const char *name, const TH1 *h1, const TH1 *h2, bool useMerge=false) constDefinition TH1.cxx:883; TH1::CheckConsistentSubAxesstatic bool CheckConsistentSubAxes(const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0)Check that two sub axis are the same.Definition TH1.cxx:1640; TH1::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove object from the list of functions.Definition TH1.cxx:6576; TH1::fYaxisTAxis fYaxisY axis descriptor.Definition TH1.h:91; TH1::KolmogorovTestvirtual Double_t KolmogorovTest(const TH1 *h2, Option_t *option="""") constStatistical test of compatibility in shape between this histogram and h2, using Kolmogorov test.Definition TH1.cxx:8178; TH1::GetSumOfWeightsvirtual Double_t GetSumOfWeights() constReturn the sum of weights excluding under/overflows.Definition TH1.cxx:7917; TH1::SmoothArraystatic void SmoothArray(Int_t NN, Double_t *XX, Int_t ntimes=1)Smooth array xx, translation of Hbook routine hsmoof.F.Definition TH1.cxx:6768; TH1::GetCentervirtual void GetCenter(Double_t *center) constFill array with center of bins for 1D histogram Better to use h1.GetXaxis()->GetCenter(center)Definition TH1.cxx:9174; TH1::fPainterTVirtualHistPainter * fPainter! Pointer to histogram painterDefinition TH1.h:112; TH1::SetBinsvirtual void SetBins(Int_t nx, Double_t xmin, Double_t xmax)Redefine x axis parameters.Definition TH1.cxx:8767; TH1::FindFixBinvirtual Int_t FindFixBin(Double_t x, Double_t y=0, Double_t z=0) constReturn Global bin number corresponding to x,y,z.Definition TH1.cxx:3705; TH1::SetBinContentvirtual ",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/TH1_8h_source.html:83310,Testability,test,test,83310,"*f1, Double_t c1=1)Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:2840; TH1::GetMinimumvirtual Double_t GetMinimum(Double_t minval=-FLT_MAX) constReturn minimum value larger than minval of bins in the range, unless the value has been overridden by...Definition TH1.cxx:8635; TH1::LoggedInconsistencyint LoggedInconsistency(const char *name, const TH1 *h1, const TH1 *h2, bool useMerge=false) constDefinition TH1.cxx:883; TH1::CheckConsistentSubAxesstatic bool CheckConsistentSubAxes(const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0)Check that two sub axis are the same.Definition TH1.cxx:1640; TH1::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove object from the list of functions.Definition TH1.cxx:6576; TH1::fYaxisTAxis fYaxisY axis descriptor.Definition TH1.h:91; TH1::KolmogorovTestvirtual Double_t KolmogorovTest(const TH1 *h2, Option_t *option="""") constStatistical test of compatibility in shape between this histogram and h2, using Kolmogorov test.Definition TH1.cxx:8178; TH1::GetSumOfWeightsvirtual Double_t GetSumOfWeights() constReturn the sum of weights excluding under/overflows.Definition TH1.cxx:7917; TH1::SmoothArraystatic void SmoothArray(Int_t NN, Double_t *XX, Int_t ntimes=1)Smooth array xx, translation of Hbook routine hsmoof.F.Definition TH1.cxx:6768; TH1::GetCentervirtual void GetCenter(Double_t *center) constFill array with center of bins for 1D histogram Better to use h1.GetXaxis()->GetCenter(center)Definition TH1.cxx:9174; TH1::fPainterTVirtualHistPainter * fPainter! Pointer to histogram painterDefinition TH1.h:112; TH1::SetBinsvirtual void SetBins(Int_t nx, Double_t xmin, Double_t xmax)Redefine x axis parameters.Definition TH1.cxx:8767; TH1::FindFixBinvirtual Int_t FindFixBin(Double_t x, Double_t y=0, Double_t z=0) constReturn Global bin number corresponding to x,y,z.Definition TH1.cxx:3705; TH1::SetBinContentvirtual ",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
https://root.cern/doc/master/th2polyEurope_8C.html:595,Availability,down,downloaded,595,". ROOT: tutorials/hist/th2polyEurope.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. th2polyEurope.C File ReferenceTutorials » Histograms tutorials. Detailed Description; This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it. ; The initial data are stored in TMultiGraphs. They represent the european countries. The histogram filling is done according to a Mercator projection, therefore the bin contains should be proportional to the real surface of the countries.; The initial data have been downloaded from: http://www.maproom.psu.edu/dcw/ This database was developed in 1991/1992 and national boundaries reflect political reality as of that time.; The script is shooting npoints (script argument) randomly over the Europe area. The number of points inside the countries should be proportional to the country surface The estimated surface is compared to the surfaces taken from wikipedia. ; Partitioning: Real Time = 1.31 seconds Cpu Time = 1.31 seconds; Filling : Real Time = 4.01 seconds Cpu Time = 4.01 seconds; THPoly Europe surface estimation error wrt wikipedia = 1.260096 per cent when using 500000 points; ; void th2polyEurope(Int_t npoints=500000); {; Int_t i,j;; Double_t lon1 = -25;; Double_t lon2 = 35;; Double_t lat1 = 34;; Double_t lat2 = 72;; Double_t R = (lat2-lat1)/(lon2-lon1);; Int_t W = 800;; Int_t H = (Int_t)(R*800);; gStyle->SetStatX(0.28);; gStyle->SetStatY(0.45);; gStyle->SetStatW(0.15);; ; // Canvas used to draw TH2Poly (the map); TCanvas *ce = new TCanvas(""ce"", ""ce"",0,0,W,H);; ce->ToggleEventStatus();; ce->SetGridx();; ce->SetGridy();; ; // Real surfaces taken from Wikipedia.; const Int_t nx = 36;; // see http://en.wikipedia.org/wiki/Area_and_population_of_European_countries; const char *countries[nx] = {; ""france"", ""spain"", ""sweden"", ""germany"", ""finland"",; ""norway"", ""poland"", ""italy"", ""yugoslavia"", ""united_kingdom"",; ""romania"", ""belarus"",""greece"", ""czechoslov",MatchSource.WIKI,doc/master/th2polyEurope_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyEurope_8C.html
https://root.cern/doc/master/th2polyEurope_8C.html:1152,Availability,error,error,1152,"lyEurope.C File ReferenceTutorials » Histograms tutorials. Detailed Description; This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it. ; The initial data are stored in TMultiGraphs. They represent the european countries. The histogram filling is done according to a Mercator projection, therefore the bin contains should be proportional to the real surface of the countries.; The initial data have been downloaded from: http://www.maproom.psu.edu/dcw/ This database was developed in 1991/1992 and national boundaries reflect political reality as of that time.; The script is shooting npoints (script argument) randomly over the Europe area. The number of points inside the countries should be proportional to the country surface The estimated surface is compared to the surfaces taken from wikipedia. ; Partitioning: Real Time = 1.31 seconds Cpu Time = 1.31 seconds; Filling : Real Time = 4.01 seconds Cpu Time = 4.01 seconds; THPoly Europe surface estimation error wrt wikipedia = 1.260096 per cent when using 500000 points; ; void th2polyEurope(Int_t npoints=500000); {; Int_t i,j;; Double_t lon1 = -25;; Double_t lon2 = 35;; Double_t lat1 = 34;; Double_t lat2 = 72;; Double_t R = (lat2-lat1)/(lon2-lon1);; Int_t W = 800;; Int_t H = (Int_t)(R*800);; gStyle->SetStatX(0.28);; gStyle->SetStatY(0.45);; gStyle->SetStatW(0.15);; ; // Canvas used to draw TH2Poly (the map); TCanvas *ce = new TCanvas(""ce"", ""ce"",0,0,W,H);; ce->ToggleEventStatus();; ce->SetGridx();; ce->SetGridy();; ; // Real surfaces taken from Wikipedia.; const Int_t nx = 36;; // see http://en.wikipedia.org/wiki/Area_and_population_of_European_countries; const char *countries[nx] = {; ""france"", ""spain"", ""sweden"", ""germany"", ""finland"",; ""norway"", ""poland"", ""italy"", ""yugoslavia"", ""united_kingdom"",; ""romania"", ""belarus"",""greece"", ""czechoslovakia"",""bulgaria"",; ""iceland"", ""hungary"",""portugal"",""austria"", ""ireland"",; ""lithuania"", ""latvia"", ""estonia"", ""denmark"", ""netherlands"",; ""switz",MatchSource.WIKI,doc/master/th2polyEurope_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyEurope_8C.html
https://root.cern/doc/master/th2polyEurope_8C.html:5355,Availability,error,errors,5355,"etBinContent(i+1));; ; gStyle->SetOptStat(1111);; p->Draw(""COLZ"");; ; TCanvas *c1 = new TCanvas(""c1"", ""c1"",W+10,0,W-20,H);; c1->SetRightMargin(0.047);; ; scale = h->GetMaximum()/h2->GetMaximum();; ; h->SetStats(0);; h->SetLineColor(kRed-3);; h->SetLineWidth(2);; h->SetMarkerStyle(20);; h->SetMarkerColor(kBlue);; h->SetMarkerSize(0.8);; h->Draw(""LP"");; h->GetXaxis()->SetLabelFont(42);; h->GetXaxis()->SetLabelSize(0.03);; h->GetYaxis()->SetLabelFont(42);; ; h2->Scale(scale);; Double_t scale2=TMath::Sqrt(scale);; for (i=0; i<nx; i++) h2->SetBinError(i+1, scale2*h2->GetBinError(i+1));; h2->Draw(""E SAME"");; h2->SetMarkerStyle(20);; h2->SetMarkerSize(0.8);; ; TLegend *leg = new TLegend(0.5,0.67,0.92,0.8,nullptr,""NDC"");; leg->SetTextFont(42);; leg->SetTextSize(0.025);; leg->AddEntry(h,""Real countries surfaces from Wikipedia (in km^{2})"",""lp"");; leg->AddEntry(h2,""Countries surfaces from TH2Poly (with errors)"",""lp"");; leg->Draw();; leg->Draw();; ; Double_t wikiSum = h->Integral();; Double_t polySum = h2->Integral();; Double_t error = TMath::Abs(wikiSum-polySum)/wikiSum;; printf(""THPoly Europe surface estimation error wrt wikipedia = %f per cent when using %d points\n"",100*error,npoints);; }; f#define f(i)Definition RSha256.hxx:104; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; gBenchmarkR__EXTERN TBenchmark * gBenchmarkDefinition TBenchmark.h:59; gDirectory#define gDirectoryDefinition TDirectory.h:384; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gStyleR__EXTERN TStyle * gStyleDefiniti",MatchSource.WIKI,doc/master/th2polyEurope_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyEurope_8C.html
https://root.cern/doc/master/th2polyEurope_8C.html:5482,Availability,error,error,5482,"etBinContent(i+1));; ; gStyle->SetOptStat(1111);; p->Draw(""COLZ"");; ; TCanvas *c1 = new TCanvas(""c1"", ""c1"",W+10,0,W-20,H);; c1->SetRightMargin(0.047);; ; scale = h->GetMaximum()/h2->GetMaximum();; ; h->SetStats(0);; h->SetLineColor(kRed-3);; h->SetLineWidth(2);; h->SetMarkerStyle(20);; h->SetMarkerColor(kBlue);; h->SetMarkerSize(0.8);; h->Draw(""LP"");; h->GetXaxis()->SetLabelFont(42);; h->GetXaxis()->SetLabelSize(0.03);; h->GetYaxis()->SetLabelFont(42);; ; h2->Scale(scale);; Double_t scale2=TMath::Sqrt(scale);; for (i=0; i<nx; i++) h2->SetBinError(i+1, scale2*h2->GetBinError(i+1));; h2->Draw(""E SAME"");; h2->SetMarkerStyle(20);; h2->SetMarkerSize(0.8);; ; TLegend *leg = new TLegend(0.5,0.67,0.92,0.8,nullptr,""NDC"");; leg->SetTextFont(42);; leg->SetTextSize(0.025);; leg->AddEntry(h,""Real countries surfaces from Wikipedia (in km^{2})"",""lp"");; leg->AddEntry(h2,""Countries surfaces from TH2Poly (with errors)"",""lp"");; leg->Draw();; leg->Draw();; ; Double_t wikiSum = h->Integral();; Double_t polySum = h2->Integral();; Double_t error = TMath::Abs(wikiSum-polySum)/wikiSum;; printf(""THPoly Europe surface estimation error wrt wikipedia = %f per cent when using %d points\n"",100*error,npoints);; }; f#define f(i)Definition RSha256.hxx:104; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; gBenchmarkR__EXTERN TBenchmark * gBenchmarkDefinition TBenchmark.h:59; gDirectory#define gDirectoryDefinition TDirectory.h:384; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gStyleR__EXTERN TStyle * gStyleDefiniti",MatchSource.WIKI,doc/master/th2polyEurope_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyEurope_8C.html
https://root.cern/doc/master/th2polyEurope_8C.html:5569,Availability,error,error,5569,"etBinContent(i+1));; ; gStyle->SetOptStat(1111);; p->Draw(""COLZ"");; ; TCanvas *c1 = new TCanvas(""c1"", ""c1"",W+10,0,W-20,H);; c1->SetRightMargin(0.047);; ; scale = h->GetMaximum()/h2->GetMaximum();; ; h->SetStats(0);; h->SetLineColor(kRed-3);; h->SetLineWidth(2);; h->SetMarkerStyle(20);; h->SetMarkerColor(kBlue);; h->SetMarkerSize(0.8);; h->Draw(""LP"");; h->GetXaxis()->SetLabelFont(42);; h->GetXaxis()->SetLabelSize(0.03);; h->GetYaxis()->SetLabelFont(42);; ; h2->Scale(scale);; Double_t scale2=TMath::Sqrt(scale);; for (i=0; i<nx; i++) h2->SetBinError(i+1, scale2*h2->GetBinError(i+1));; h2->Draw(""E SAME"");; h2->SetMarkerStyle(20);; h2->SetMarkerSize(0.8);; ; TLegend *leg = new TLegend(0.5,0.67,0.92,0.8,nullptr,""NDC"");; leg->SetTextFont(42);; leg->SetTextSize(0.025);; leg->AddEntry(h,""Real countries surfaces from Wikipedia (in km^{2})"",""lp"");; leg->AddEntry(h2,""Countries surfaces from TH2Poly (with errors)"",""lp"");; leg->Draw();; leg->Draw();; ; Double_t wikiSum = h->Integral();; Double_t polySum = h2->Integral();; Double_t error = TMath::Abs(wikiSum-polySum)/wikiSum;; printf(""THPoly Europe surface estimation error wrt wikipedia = %f per cent when using %d points\n"",100*error,npoints);; }; f#define f(i)Definition RSha256.hxx:104; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; gBenchmarkR__EXTERN TBenchmark * gBenchmarkDefinition TBenchmark.h:59; gDirectory#define gDirectoryDefinition TDirectory.h:384; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gStyleR__EXTERN TStyle * gStyleDefiniti",MatchSource.WIKI,doc/master/th2polyEurope_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyEurope_8C.html
https://root.cern/doc/master/th2polyEurope_8C.html:5631,Availability,error,error,5631,"etBinContent(i+1));; ; gStyle->SetOptStat(1111);; p->Draw(""COLZ"");; ; TCanvas *c1 = new TCanvas(""c1"", ""c1"",W+10,0,W-20,H);; c1->SetRightMargin(0.047);; ; scale = h->GetMaximum()/h2->GetMaximum();; ; h->SetStats(0);; h->SetLineColor(kRed-3);; h->SetLineWidth(2);; h->SetMarkerStyle(20);; h->SetMarkerColor(kBlue);; h->SetMarkerSize(0.8);; h->Draw(""LP"");; h->GetXaxis()->SetLabelFont(42);; h->GetXaxis()->SetLabelSize(0.03);; h->GetYaxis()->SetLabelFont(42);; ; h2->Scale(scale);; Double_t scale2=TMath::Sqrt(scale);; for (i=0; i<nx; i++) h2->SetBinError(i+1, scale2*h2->GetBinError(i+1));; h2->Draw(""E SAME"");; h2->SetMarkerStyle(20);; h2->SetMarkerSize(0.8);; ; TLegend *leg = new TLegend(0.5,0.67,0.92,0.8,nullptr,""NDC"");; leg->SetTextFont(42);; leg->SetTextSize(0.025);; leg->AddEntry(h,""Real countries surfaces from Wikipedia (in km^{2})"",""lp"");; leg->AddEntry(h2,""Countries surfaces from TH2Poly (with errors)"",""lp"");; leg->Draw();; leg->Draw();; ; Double_t wikiSum = h->Integral();; Double_t polySum = h2->Integral();; Double_t error = TMath::Abs(wikiSum-polySum)/wikiSum;; printf(""THPoly Europe surface estimation error wrt wikipedia = %f per cent when using %d points\n"",100*error,npoints);; }; f#define f(i)Definition RSha256.hxx:104; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; gBenchmarkR__EXTERN TBenchmark * gBenchmarkDefinition TBenchmark.h:59; gDirectory#define gDirectoryDefinition TDirectory.h:384; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gStyleR__EXTERN TStyle * gStyleDefiniti",MatchSource.WIKI,doc/master/th2polyEurope_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyEurope_8C.html
https://root.cern/doc/master/th2polyEurope_8C.html:8224,Modifiability,inherit,inherits,8224,"=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH2Poly2D Histogram with Polygonal BinsDefinition TH2Poly.h:66; TIterDefinition TCollection.h:235; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TKey::ReadObjvirtual TObject * ReadObj()To read a TObject* from the file.Definition TKey.cxx:759; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects.Definition TMultiGraph.h:34; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPad::SetGridxvoid SetGridx(Int_t value=1) overrideDefinition TPad.h:336; TPad::SetGridyvoid SetGridy(Int_t value=1) overrideDefinition TPad.h:337; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; TStyle::SetStatXvoid SetStatX(Float_t x=0)Definition TStyle.h:397; TStyle::SetStatWvoid SetStatW(Float_t w=0.19)Definition TStyle.h:399; TStyle::SetStatYvoid SetStatY(Float_t y=0)Definition TStyle.h:398; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; leglegDefinition legend1.C:34; H#define H(x, y, z)",MatchSource.WIKI,doc/master/th2polyEurope_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyEurope_8C.html
https://root.cern/doc/master/th2polyEurope_8C.html:2800,Performance,cache,cacheread,2800," *countries[nx] = {; ""france"", ""spain"", ""sweden"", ""germany"", ""finland"",; ""norway"", ""poland"", ""italy"", ""yugoslavia"", ""united_kingdom"",; ""romania"", ""belarus"",""greece"", ""czechoslovakia"",""bulgaria"",; ""iceland"", ""hungary"",""portugal"",""austria"", ""ireland"",; ""lithuania"", ""latvia"", ""estonia"", ""denmark"", ""netherlands"",; ""switzerland"",""moldova"",""belgium"", ""albania"", ""cyprus"",; ""luxembourg"", ""andorra"",""malta"", ""liechtenstein"", ""san_marino"", ""monaco"" };; Float_t surfaces[nx] = {; 547030, 505580, 449964, 357021, 338145,; 324220, 312685, 301230, 255438, 244820,; 237500, 207600, 131940, 127711, 110910,; 103000, 93030, 89242, 83870, 70280,; 65200, 64589, 45226, 43094, 41526,; 41290, 33843, 30528, 28748, 9250,; 2586, 468, 316, 160, 61, 2};; ; TH1F *h = new TH1F(""h"",""Countries surfaces (in km^{2})"",3,0,3);; for (i=0; i<nx; i++) h->Fill(countries[i], surfaces[i]);; h->LabelsDeflate();; ; TFile::SetCacheFileDir(""."");; TFile *f;; f = TFile::Open(""http://root.cern/files/europe.root"",""cacheread"");; ; if (!f) {; printf(""Cannot access europe.root. Is internet working ?\n"");; return;; }; ; TH2Poly *p = new TH2Poly(; ""Europe"",; ""Europe (bin contents are normalized to the surfaces in km^{2})"",; lon1,lon2,lat1,lat2);; p->GetXaxis()->SetNdivisions(520);; p->GetXaxis()->SetTitle(""longitude"");; p->GetYaxis()->SetTitle(""latitude"");; ; p->SetContour(100);; ; TMultiGraph *mg;; TKey *key;; TIter nextkey(gDirectory->GetListOfKeys());; while ((key = (TKey*)nextkey())) {; TObject *obj = key->ReadObj();; if (obj->InheritsFrom(""TMultiGraph"")) {; mg = (TMultiGraph*)obj;; p->AddBin(mg);; }; }; ; TRandom r;; Double_t longitude, latitude;; Double_t x, y, pi4 = TMath::Pi()/4, alpha = TMath::Pi()/360;; ; gBenchmark->Start(""Partitioning"");; p->ChangePartition(100, 100);; gBenchmark->Show(""Partitioning"");; ; // Fill TH2Poly according to a Mercator projection.; gBenchmark->Start(""Filling"");; for (i=0; i<npoints; i++) {; longitude = r.Uniform(lon1,lon2);; latitude = r.Uniform(lat1,lat2);; x = longitude;; y = 38*TMath:",MatchSource.WIKI,doc/master/th2polyEurope_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyEurope_8C.html
https://root.cern/doc/master/th2polyEurope_8C.html:7306,Performance,cache,cacheDir,7306,"angle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; R; TBenchmark::Startvirtual void Start(const char *name)Starts Benchmark with the specified name.Definition TBenchmark.cxx:172; TBenchmark::Showvirtual void Show(const char *name)Stops Benchmark name and Prints results.Definition TBenchmark.cxx:155; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::ToggleEventStatusvirtual void ToggleEventStatus()Toggle event statusbar.Definition TCanvas.cxx:2431; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH2Poly2D Histogram with Polygonal BinsDefinition TH2Poly.h:66; TIterDefinition TCollection.h:235; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TKey::ReadObjvirtual TObject * ReadObj()To read a TObject* from the file.Definition TKey.cxx:759; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects.Definition TMultiGraph.h:34; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Drawvirtual void Draw(Option_t *option=""""",MatchSource.WIKI,doc/master/th2polyEurope_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyEurope_8C.html
https://root.cern/doc/master/th2polyEurope_8C.html:7421,Performance,cache,cache,7421,"angle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; R; TBenchmark::Startvirtual void Start(const char *name)Starts Benchmark with the specified name.Definition TBenchmark.cxx:172; TBenchmark::Showvirtual void Show(const char *name)Stops Benchmark name and Prints results.Definition TBenchmark.cxx:155; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::ToggleEventStatusvirtual void ToggleEventStatus()Toggle event statusbar.Definition TCanvas.cxx:2431; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH2Poly2D Histogram with Polygonal BinsDefinition TH2Poly.h:66; TIterDefinition TCollection.h:235; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TKey::ReadObjvirtual TObject * ReadObj()To read a TObject* from the file.Definition TKey.cxx:759; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects.Definition TMultiGraph.h:34; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Drawvirtual void Draw(Option_t *option=""""",MatchSource.WIKI,doc/master/th2polyEurope_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyEurope_8C.html
https://root.cern/doc/master/th2polyEurope_8C.html:2842,Security,access,access,2842," *countries[nx] = {; ""france"", ""spain"", ""sweden"", ""germany"", ""finland"",; ""norway"", ""poland"", ""italy"", ""yugoslavia"", ""united_kingdom"",; ""romania"", ""belarus"",""greece"", ""czechoslovakia"",""bulgaria"",; ""iceland"", ""hungary"",""portugal"",""austria"", ""ireland"",; ""lithuania"", ""latvia"", ""estonia"", ""denmark"", ""netherlands"",; ""switzerland"",""moldova"",""belgium"", ""albania"", ""cyprus"",; ""luxembourg"", ""andorra"",""malta"", ""liechtenstein"", ""san_marino"", ""monaco"" };; Float_t surfaces[nx] = {; 547030, 505580, 449964, 357021, 338145,; 324220, 312685, 301230, 255438, 244820,; 237500, 207600, 131940, 127711, 110910,; 103000, 93030, 89242, 83870, 70280,; 65200, 64589, 45226, 43094, 41526,; 41290, 33843, 30528, 28748, 9250,; 2586, 468, 316, 160, 61, 2};; ; TH1F *h = new TH1F(""h"",""Countries surfaces (in km^{2})"",3,0,3);; for (i=0; i<nx; i++) h->Fill(countries[i], surfaces[i]);; h->LabelsDeflate();; ; TFile::SetCacheFileDir(""."");; TFile *f;; f = TFile::Open(""http://root.cern/files/europe.root"",""cacheread"");; ; if (!f) {; printf(""Cannot access europe.root. Is internet working ?\n"");; return;; }; ; TH2Poly *p = new TH2Poly(; ""Europe"",; ""Europe (bin contents are normalized to the surfaces in km^{2})"",; lon1,lon2,lat1,lat2);; p->GetXaxis()->SetNdivisions(520);; p->GetXaxis()->SetTitle(""longitude"");; p->GetYaxis()->SetTitle(""latitude"");; ; p->SetContour(100);; ; TMultiGraph *mg;; TKey *key;; TIter nextkey(gDirectory->GetListOfKeys());; while ((key = (TKey*)nextkey())) {; TObject *obj = key->ReadObj();; if (obj->InheritsFrom(""TMultiGraph"")) {; mg = (TMultiGraph*)obj;; p->AddBin(mg);; }; }; ; TRandom r;; Double_t longitude, latitude;; Double_t x, y, pi4 = TMath::Pi()/4, alpha = TMath::Pi()/360;; ; gBenchmark->Start(""Partitioning"");; p->ChangePartition(100, 100);; gBenchmark->Show(""Partitioning"");; ; // Fill TH2Poly according to a Mercator projection.; gBenchmark->Start(""Filling"");; for (i=0; i<npoints; i++) {; longitude = r.Uniform(lon1,lon2);; latitude = r.Uniform(lat1,lat2);; x = longitude;; y = 38*TMath:",MatchSource.WIKI,doc/master/th2polyEurope_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyEurope_8C.html
https://root.cern/doc/master/th2polyEurope_8C.html:9310,Testability,log,logarithm,9310,"entries.Definition TLegend.h:23; TMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects.Definition TMultiGraph.h:34; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPad::SetGridxvoid SetGridx(Int_t value=1) overrideDefinition TPad.h:336; TPad::SetGridyvoid SetGridy(Int_t value=1) overrideDefinition TPad.h:337; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; TStyle::SetStatXvoid SetStatX(Float_t x=0)Definition TStyle.h:397; TStyle::SetStatWvoid SetStatW(Float_t w=0.19)Definition TStyle.h:399; TStyle::SetStatYvoid SetStatY(Float_t y=0)Definition TStyle.h:398; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; leglegDefinition legend1.C:34; H#define H(x, y, z); TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::TanDouble_t Tan(Double_t)Returns the tangent of an angle of x radians.Definition TMath.h:600; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; surfacesDefinition surfaces.py:1; AuthorOlivier Couet ; Definition in file th2polyEurope.C. tutorialshistth2polyEurope.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/th2polyEurope_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyEurope_8C.html
https://root.cern/doc/master/th2polyUSA_8C.html:508,Availability,down,downloaded,508,". ROOT: tutorials/hist/th2polyUSA.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. th2polyUSA.C File ReferenceTutorials » Histograms tutorials. Detailed Description; This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option. ; The initial data are stored in TMultiGraphs. They represent the USA map. Such histograms can be rendered in 3D using the option legogl.; The initial data have been downloaded from: http://www.maproom.psu.edu/dcw/ This database was developed in 1991/1992 and national boundaries reflect political reality as of that time.; ; void th2polyUSA(); {; Int_t i, bin;; const Int_t nx = 48;; const char *states [nx] = {; ""alabama"", ""arizona"", ""arkansas"", ""california"",; ""colorado"", ""connecticut"", ""delaware"", ""florida"",; ""georgia"", ""idaho"", ""illinois"", ""indiana"",; ""iowa"", ""kansas"", ""kentucky"", ""louisiana"",; ""maine"", ""maryland"", ""massachusetts"", ""michigan"",; ""minnesota"", ""mississippi"", ""missouri"", ""montana"",; ""nebraska"", ""nevada"", ""new_hampshire"", ""new_jersey"",; ""new_mexico"", ""new_york"", ""north_carolina"", ""north_dakota"",; ""ohio"", ""oklahoma"", ""oregon"", ""pennsylvania"",; ""rhode_island"", ""south_carolina"", ""south_dakota"", ""tennessee"",; ""texas"", ""utah"", ""vermont"", ""virginia"",; ""washington"", ""west_virginia"", ""wisconsin"", ""wyoming""; };; Double_t pop[nx] = {; 4708708, 6595778, 2889450, 36961664, 5024748, 3518288, 885122, 18537969,; 9829211, 1545801, 12910409, 6423113, 3007856, 2818747, 4314113, 4492076,; 1318301, 5699478, 6593587, 9969727, 5266214, 2951996, 5987580, 974989,; 1796619, 2643085, 1324575, 8707739, 2009671, 19541453, 9380884, 646844,; 11542645, 3687050, 3825657, 12604767, 1053209, 4561242, 812383, 6296254,; 24782302, 2784572, 621760, 7882590, 6664195, 1819777, 5654774, 544270; };; ; TCanvas *usa = new TCanvas(""USA"", ""USA"");; usa->ToggleEventStatus();; Double_t lon1 = -130;; Double_t lon2 = -65;; Double_t lat1 = 24;; Double_t lat2 = 50;; TH2Po",MatchSource.WIKI,doc/master/th2polyUSA_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyUSA_8C.html
https://root.cern/doc/master/th2polyUSA_8C.html:4499,Modifiability,inherit,inherits,4499,"finition TDirectory.h:384; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TH2Poly2D Histogram with Polygonal BinsDefinition TH2Poly.h:66; TIterDefinition TCollection.h:235; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TKey::ReadObjvirtual TObject * ReadObj()To read a TObject* from the file.Definition TKey.cxx:759; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects.Definition TMultiGraph.h:34; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; usaDefinition civetweb.c:1823; . AuthorOlivier Couet ; Definition in file th2polyUSA.C. tutorialshistth2polyUSA.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/th2polyUSA_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyUSA_8C.html
https://root.cern/doc/master/th2polyUSA_8C.html:3721,Performance,cache,cacheDir,3721," the population; TLatex pupulationRef(-128, 27, ""#scale[.55]{#splitline{Source:}{http://eadiv.state.wy.us/pop/st-09est.htm}}"");; pupulationRef.DrawClone();; }; f#define f(i)Definition RSha256.hxx:104; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; gDirectory#define gDirectoryDefinition TDirectory.h:384; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TH2Poly2D Histogram with Polygonal BinsDefinition TH2Poly.h:66; TIterDefinition TCollection.h:235; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TKey::ReadObjvirtual TObject * ReadObj()To read a TObject* from the file.Definition TKey.cxx:759; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects.Definition TMultiGraph.h:34; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information prin",MatchSource.WIKI,doc/master/th2polyUSA_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyUSA_8C.html
https://root.cern/doc/master/th2polyUSA_8C.html:3836,Performance,cache,cache,3836," the population; TLatex pupulationRef(-128, 27, ""#scale[.55]{#splitline{Source:}{http://eadiv.state.wy.us/pop/st-09est.htm}}"");; pupulationRef.DrawClone();; }; f#define f(i)Definition RSha256.hxx:104; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; gDirectory#define gDirectoryDefinition TDirectory.h:384; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TH2Poly2D Histogram with Polygonal BinsDefinition TH2Poly.h:66; TIterDefinition TCollection.h:235; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TKey::ReadObjvirtual TObject * ReadObj()To read a TObject* from the file.Definition TKey.cxx:759; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects.Definition TMultiGraph.h:34; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information prin",MatchSource.WIKI,doc/master/th2polyUSA_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyUSA_8C.html
https://root.cern/doc/master/th2polyUSA_8C.html:2235,Security,access,access,2235,"_island"", ""south_carolina"", ""south_dakota"", ""tennessee"",; ""texas"", ""utah"", ""vermont"", ""virginia"",; ""washington"", ""west_virginia"", ""wisconsin"", ""wyoming""; };; Double_t pop[nx] = {; 4708708, 6595778, 2889450, 36961664, 5024748, 3518288, 885122, 18537969,; 9829211, 1545801, 12910409, 6423113, 3007856, 2818747, 4314113, 4492076,; 1318301, 5699478, 6593587, 9969727, 5266214, 2951996, 5987580, 974989,; 1796619, 2643085, 1324575, 8707739, 2009671, 19541453, 9380884, 646844,; 11542645, 3687050, 3825657, 12604767, 1053209, 4561242, 812383, 6296254,; 24782302, 2784572, 621760, 7882590, 6664195, 1819777, 5654774, 544270; };; ; TCanvas *usa = new TCanvas(""USA"", ""USA"");; usa->ToggleEventStatus();; Double_t lon1 = -130;; Double_t lon2 = -65;; Double_t lat1 = 24;; Double_t lat2 = 50;; TH2Poly *p = new TH2Poly(""Lower48"",""Lower 48 Population (2009);Latitude;Longitude"",lon1,lon2,lat1,lat2);; ; TFile::SetCacheFileDir(""."");; TFile *f = TFile::Open(""http://root.cern/files/usa.root"", ""CACHEREAD"");; ; if (!f) {; printf(""Cannot access usa.root. Is internet working ?\n"");; return;; }; ; // Define the TH2Poly bins.; TMultiGraph *mg;; TKey *key;; TIter nextkey(gDirectory->GetListOfKeys());; while ((key = (TKey*)nextkey())) {; TObject *obj = key->ReadObj();; if (obj->InheritsFrom(""TMultiGraph"")) {; mg = (TMultiGraph*)obj;; bin = p->AddBin(mg);; }; }; ; // Fill TH2Poly, with capital letters for the states names; for (i=0; i<nx; i++) p->Fill(states[i], pop[i]);; ; gStyle->SetOptStat(0);; p->Draw(""colz textn"");; ; // Add the reference for the population; TLatex pupulationRef(-128, 27, ""#scale[.55]{#splitline{Source:}{http://eadiv.state.wy.us/pop/st-09est.htm}}"");; pupulationRef.DrawClone();; }; f#define f(i)Definition RSha256.hxx:104; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; gDirectory#define gDirectoryDefinition TDirectory.h:384; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; gStyleR__EXTERN TStyle * gStyle",MatchSource.WIKI,doc/master/th2polyUSA_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyUSA_8C.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:21960,Availability,error,errors,21960,"AddBinToPartition((TH2PolyBin*) obj);; 547 }; 548}; 549 ; 550////////////////////////////////////////////////////////////////////////////////; 551/// Make a complete copy of the underlying object. If 'newname' is set,; 552/// the copy's name will be set to that name.; 553 ; 554TObject* TH2Poly::Clone(const char* newname) const; 555{; 556 // TH1::Clone relies on ::Copy to implemented by the derived class.; 557 // Until this is implemented, revert to the much slower default version; 558 // (and possibly non-thread safe).; 559 ; 560 return TNamed::Clone(newname);; 561}; 562 ; 563////////////////////////////////////////////////////////////////////////////////; 564/// Clears the contents of all bins in the histogram.; 565 ; 566void TH2Poly::ClearBinContents(); 567{; 568 TIter next(fBins);; 569 TObject *obj;; 570 TH2PolyBin *bin;; 571 ; 572 // Clears the bin contents; 573 while ((obj = next())) {; 574 bin = (TH2PolyBin*) obj;; 575 bin->ClearContent();; 576 }; 577 ; 578 // Clears the statistics; 579 fTsumw = 0;; 580 fTsumw2 = 0;; 581 fTsumwx = 0;; 582 fTsumwx2 = 0;; 583 fTsumwy = 0;; 584 fTsumwy2 = 0;; 585 fEntries = 0;; 586}; 587 ; 588////////////////////////////////////////////////////////////////////////////////; 589/// Reset this histogram: contents, errors, etc.; 590 ; 591void TH2Poly::Reset(Option_t *opt); 592{; 593 TIter next(fBins);; 594 TObject *obj;; 595 TH2PolyBin *bin;; 596 ; 597 // Clears the bin contents; 598 while ((obj = next())) {; 599 bin = (TH2PolyBin*) obj;; 600 bin->ClearContent();; 601 }; 602 ; 603 TH2::Reset(opt);; 604}; 605 ; 606////////////////////////////////////////////////////////////////////////////////; 607/// Returns the bin number of the bin at the given coordinate. -1 to -9 are; 608/// the overflow and underflow bins. overflow bin -5 is the unbinned areas in; 609/// the histogram (also called ""the sea""). The third parameter can be left; 610/// blank.; 611/// The overflow/underflow bins are:; 612///~~~ {.cpp}; 613/// -1 | -2 | -3; 614/// ----",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:29985,Availability,error,error,29985,"bj;; 814 w = bin->GetArea();; 815 integral += w * (bin->GetContent());; 816 }; 817 } else {; 818 // need to recompute integral in case SetBinContent was called.; 819 // fTsumw cannot be used since it is not updated in that case; 820 while ((obj = next())) {; 821 bin = (TH2PolyBin *)obj;; 822 integral += (bin->GetContent());; 823 }; 824 }; 825 return integral;; 826}; 827 ; 828////////////////////////////////////////////////////////////////////////////////; 829/// Returns the content of the input bin; 830/// Bin numbers are from [1,nbins] and; 831/// for the overflow/underflow/sea bins the range is [-9,-1]:; 832///~~~ {.cpp}; 833/// -1 | -2 | -3; 834/// ---+----+----; 835/// -4 | -5 | -6; 836/// ---+----+----; 837/// -7 | -8 | -9; 838///~~~; 839/// where -5 is the ""sea"" bin (i.e. unbinned areas); 840 ; 841Double_t TH2Poly::GetBinContent(Int_t bin) const; 842{; 843 if (bin > GetNumberOfBins() || bin == 0 || bin < -kNOverflow) return 0;; 844 if (bin<0) return fOverflow[-bin - 1];; 845 return ((TH2PolyBin*) fBins->At(bin-1))->GetContent();; 846}; 847 ; 848////////////////////////////////////////////////////////////////////////////////; 849/// Returns the value of error associated to bin number bin.; 850/// If the sum of squares of weights has been defined (via Sumw2),; 851/// this function returns the sqrt(sum of w2).; 852/// otherwise it returns the sqrt(contents) for this bin.; 853/// Bins are in range [1:nbins] and for bin < 0 in range [-9:-1] it returns errors for overflow bins.; 854/// See also TH2Poly::GetBinContent; 855 ; 856Double_t TH2Poly::GetBinError(Int_t bin) const; 857{; 858 if (bin == 0 || bin > GetNumberOfBins() || bin < - kNOverflow) return 0;; 859 if (fBuffer) ((TH1*)this)->BufferEmpty();; 860 // in case of weighted events the sum of the weights are stored in a different way than; 861 // a normal histogram; 862 // fSumw2.fArray[0:kNOverflow-1] : sum of weight squares for the overflow bins (; 863 // fSumw2.fArray[kNOverflow:fNcells] : sum of weight squar",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:30285,Availability,error,errors,30285,"/////////; 829/// Returns the content of the input bin; 830/// Bin numbers are from [1,nbins] and; 831/// for the overflow/underflow/sea bins the range is [-9,-1]:; 832///~~~ {.cpp}; 833/// -1 | -2 | -3; 834/// ---+----+----; 835/// -4 | -5 | -6; 836/// ---+----+----; 837/// -7 | -8 | -9; 838///~~~; 839/// where -5 is the ""sea"" bin (i.e. unbinned areas); 840 ; 841Double_t TH2Poly::GetBinContent(Int_t bin) const; 842{; 843 if (bin > GetNumberOfBins() || bin == 0 || bin < -kNOverflow) return 0;; 844 if (bin<0) return fOverflow[-bin - 1];; 845 return ((TH2PolyBin*) fBins->At(bin-1))->GetContent();; 846}; 847 ; 848////////////////////////////////////////////////////////////////////////////////; 849/// Returns the value of error associated to bin number bin.; 850/// If the sum of squares of weights has been defined (via Sumw2),; 851/// this function returns the sqrt(sum of w2).; 852/// otherwise it returns the sqrt(contents) for this bin.; 853/// Bins are in range [1:nbins] and for bin < 0 in range [-9:-1] it returns errors for overflow bins.; 854/// See also TH2Poly::GetBinContent; 855 ; 856Double_t TH2Poly::GetBinError(Int_t bin) const; 857{; 858 if (bin == 0 || bin > GetNumberOfBins() || bin < - kNOverflow) return 0;; 859 if (fBuffer) ((TH1*)this)->BufferEmpty();; 860 // in case of weighted events the sum of the weights are stored in a different way than; 861 // a normal histogram; 862 // fSumw2.fArray[0:kNOverflow-1] : sum of weight squares for the overflow bins (; 863 // fSumw2.fArray[kNOverflow:fNcells] : sum of weight squares for the standard bins; 864 // fNcells = kNOverflow (9) + Number of bins; 865 if (fSumw2.fN) {; 866 Int_t binIndex = (bin > 0) ? bin+kNOverflow-1 : -(bin+1);; 867 Double_t err2 = fSumw2.fArray[binIndex];; 868 return TMath::Sqrt(err2);; 869 }; 870 Double_t error2 = TMath::Abs(GetBinContent(bin));; 871 return TMath::Sqrt(error2);; 872}; 873 ; 874////////////////////////////////////////////////////////////////////////////////; 875/// Return the n",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:31767,Availability,error,error,31767,"or the overflow bins (; 863 // fSumw2.fArray[kNOverflow:fNcells] : sum of weight squares for the standard bins; 864 // fNcells = kNOverflow (9) + Number of bins; 865 if (fSumw2.fN) {; 866 Int_t binIndex = (bin > 0) ? bin+kNOverflow-1 : -(bin+1);; 867 Double_t err2 = fSumw2.fArray[binIndex];; 868 return TMath::Sqrt(err2);; 869 }; 870 Double_t error2 = TMath::Abs(GetBinContent(bin));; 871 return TMath::Sqrt(error2);; 872}; 873 ; 874////////////////////////////////////////////////////////////////////////////////; 875/// Return the number of bins :; 876/// it should be the size of the bin list; 877Int_t TH2Poly::GetNumberOfBins() const {; 878 Int_t nbins = fNcells-kNOverflow;; 879 if (nbins != (fBins ? fBins->GetSize() : 0)); 880 Fatal(""GetNumberOfBins"",""Object has an invalid number of bins"");; 881 return nbins;; 882}; 883 ; 884////////////////////////////////////////////////////////////////////////////////; 885/// Set the bin Error.; 886/// Re-implementation for TH2Poly given the different bin indexing in the; 887/// stored squared error array.; 888/// See also notes in TH1::SetBinError; 889///; 890/// Bins are in range [1:nbins] and for bin < 0 in the range [-9:-1] the errors is set for the overflow bins; 891 ; 892 ; 893void TH2Poly::SetBinError(Int_t bin, Double_t error); 894{; 895 if (bin == 0 || bin > GetNumberOfBins() || bin < - kNOverflow) return;; 896 if (!fSumw2.fN) Sumw2();; 897 SetBinErrorOption(kNormal);; 898 // see comment in GetBinError for special convention of bin index in fSumw2 array; 899 Int_t binIndex = (bin > 0) ? bin+kNOverflow-1 : -(bin+1);; 900 fSumw2.fArray[binIndex] = error * error;; 901}; 902 ; 903 ; 904 ; 905////////////////////////////////////////////////////////////////////////////////; 906/// Returns the bin name.; 907 ; 908const char *TH2Poly::GetBinName(Int_t bin) const; 909{; 910 if (bin > GetNumberOfBins()) return """";; 911 if (bin <= 0) return """";; 912 return ((TH2PolyBin*) fBins->At(bin-1))->GetPolygon()->GetName();; 913}; 914 ; 915//",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:31908,Availability,error,errors,31908,"Overflow-1 : -(bin+1);; 867 Double_t err2 = fSumw2.fArray[binIndex];; 868 return TMath::Sqrt(err2);; 869 }; 870 Double_t error2 = TMath::Abs(GetBinContent(bin));; 871 return TMath::Sqrt(error2);; 872}; 873 ; 874////////////////////////////////////////////////////////////////////////////////; 875/// Return the number of bins :; 876/// it should be the size of the bin list; 877Int_t TH2Poly::GetNumberOfBins() const {; 878 Int_t nbins = fNcells-kNOverflow;; 879 if (nbins != (fBins ? fBins->GetSize() : 0)); 880 Fatal(""GetNumberOfBins"",""Object has an invalid number of bins"");; 881 return nbins;; 882}; 883 ; 884////////////////////////////////////////////////////////////////////////////////; 885/// Set the bin Error.; 886/// Re-implementation for TH2Poly given the different bin indexing in the; 887/// stored squared error array.; 888/// See also notes in TH1::SetBinError; 889///; 890/// Bins are in range [1:nbins] and for bin < 0 in the range [-9:-1] the errors is set for the overflow bins; 891 ; 892 ; 893void TH2Poly::SetBinError(Int_t bin, Double_t error); 894{; 895 if (bin == 0 || bin > GetNumberOfBins() || bin < - kNOverflow) return;; 896 if (!fSumw2.fN) Sumw2();; 897 SetBinErrorOption(kNormal);; 898 // see comment in GetBinError for special convention of bin index in fSumw2 array; 899 Int_t binIndex = (bin > 0) ? bin+kNOverflow-1 : -(bin+1);; 900 fSumw2.fArray[binIndex] = error * error;; 901}; 902 ; 903 ; 904 ; 905////////////////////////////////////////////////////////////////////////////////; 906/// Returns the bin name.; 907 ; 908const char *TH2Poly::GetBinName(Int_t bin) const; 909{; 910 if (bin > GetNumberOfBins()) return """";; 911 if (bin <= 0) return """";; 912 return ((TH2PolyBin*) fBins->At(bin-1))->GetPolygon()->GetName();; 913}; 914 ; 915////////////////////////////////////////////////////////////////////////////////; 916/// Returns the bin title.; 917 ; 918const char *TH2Poly::GetBinTitle(Int_t bin) const; 919{; 920 if (bin > GetNumberOfBins()) return """";; 92",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:32006,Availability,error,error,32006,"Overflow-1 : -(bin+1);; 867 Double_t err2 = fSumw2.fArray[binIndex];; 868 return TMath::Sqrt(err2);; 869 }; 870 Double_t error2 = TMath::Abs(GetBinContent(bin));; 871 return TMath::Sqrt(error2);; 872}; 873 ; 874////////////////////////////////////////////////////////////////////////////////; 875/// Return the number of bins :; 876/// it should be the size of the bin list; 877Int_t TH2Poly::GetNumberOfBins() const {; 878 Int_t nbins = fNcells-kNOverflow;; 879 if (nbins != (fBins ? fBins->GetSize() : 0)); 880 Fatal(""GetNumberOfBins"",""Object has an invalid number of bins"");; 881 return nbins;; 882}; 883 ; 884////////////////////////////////////////////////////////////////////////////////; 885/// Set the bin Error.; 886/// Re-implementation for TH2Poly given the different bin indexing in the; 887/// stored squared error array.; 888/// See also notes in TH1::SetBinError; 889///; 890/// Bins are in range [1:nbins] and for bin < 0 in the range [-9:-1] the errors is set for the overflow bins; 891 ; 892 ; 893void TH2Poly::SetBinError(Int_t bin, Double_t error); 894{; 895 if (bin == 0 || bin > GetNumberOfBins() || bin < - kNOverflow) return;; 896 if (!fSumw2.fN) Sumw2();; 897 SetBinErrorOption(kNormal);; 898 // see comment in GetBinError for special convention of bin index in fSumw2 array; 899 Int_t binIndex = (bin > 0) ? bin+kNOverflow-1 : -(bin+1);; 900 fSumw2.fArray[binIndex] = error * error;; 901}; 902 ; 903 ; 904 ; 905////////////////////////////////////////////////////////////////////////////////; 906/// Returns the bin name.; 907 ; 908const char *TH2Poly::GetBinName(Int_t bin) const; 909{; 910 if (bin > GetNumberOfBins()) return """";; 911 if (bin <= 0) return """";; 912 return ((TH2PolyBin*) fBins->At(bin-1))->GetPolygon()->GetName();; 913}; 914 ; 915////////////////////////////////////////////////////////////////////////////////; 916/// Returns the bin title.; 917 ; 918const char *TH2Poly::GetBinTitle(Int_t bin) const; 919{; 920 if (bin > GetNumberOfBins()) return """";; 92",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:32339,Availability,error,error,32339,"9 if (nbins != (fBins ? fBins->GetSize() : 0)); 880 Fatal(""GetNumberOfBins"",""Object has an invalid number of bins"");; 881 return nbins;; 882}; 883 ; 884////////////////////////////////////////////////////////////////////////////////; 885/// Set the bin Error.; 886/// Re-implementation for TH2Poly given the different bin indexing in the; 887/// stored squared error array.; 888/// See also notes in TH1::SetBinError; 889///; 890/// Bins are in range [1:nbins] and for bin < 0 in the range [-9:-1] the errors is set for the overflow bins; 891 ; 892 ; 893void TH2Poly::SetBinError(Int_t bin, Double_t error); 894{; 895 if (bin == 0 || bin > GetNumberOfBins() || bin < - kNOverflow) return;; 896 if (!fSumw2.fN) Sumw2();; 897 SetBinErrorOption(kNormal);; 898 // see comment in GetBinError for special convention of bin index in fSumw2 array; 899 Int_t binIndex = (bin > 0) ? bin+kNOverflow-1 : -(bin+1);; 900 fSumw2.fArray[binIndex] = error * error;; 901}; 902 ; 903 ; 904 ; 905////////////////////////////////////////////////////////////////////////////////; 906/// Returns the bin name.; 907 ; 908const char *TH2Poly::GetBinName(Int_t bin) const; 909{; 910 if (bin > GetNumberOfBins()) return """";; 911 if (bin <= 0) return """";; 912 return ((TH2PolyBin*) fBins->At(bin-1))->GetPolygon()->GetName();; 913}; 914 ; 915////////////////////////////////////////////////////////////////////////////////; 916/// Returns the bin title.; 917 ; 918const char *TH2Poly::GetBinTitle(Int_t bin) const; 919{; 920 if (bin > GetNumberOfBins()) return """";; 921 if (bin <= 0) return """";; 922 return ((TH2PolyBin*) fBins->At(bin-1))->GetPolygon()->GetTitle();; 923}; 924 ; 925////////////////////////////////////////////////////////////////////////////////; 926/// Returns the maximum value of the histogram.; 927 ; 928Double_t TH2Poly::GetMaximum() const; 929{; 930 if (fNcells <= kNOverflow) return 0;; 931 if (fMaximum != -1111) return fMaximum;; 932 ; 933 TH2PolyBin *b;; 934 ; 935 TIter next(fBins);; 936 TObject *ob",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:32347,Availability,error,error,32347,"9 if (nbins != (fBins ? fBins->GetSize() : 0)); 880 Fatal(""GetNumberOfBins"",""Object has an invalid number of bins"");; 881 return nbins;; 882}; 883 ; 884////////////////////////////////////////////////////////////////////////////////; 885/// Set the bin Error.; 886/// Re-implementation for TH2Poly given the different bin indexing in the; 887/// stored squared error array.; 888/// See also notes in TH1::SetBinError; 889///; 890/// Bins are in range [1:nbins] and for bin < 0 in the range [-9:-1] the errors is set for the overflow bins; 891 ; 892 ; 893void TH2Poly::SetBinError(Int_t bin, Double_t error); 894{; 895 if (bin == 0 || bin > GetNumberOfBins() || bin < - kNOverflow) return;; 896 if (!fSumw2.fN) Sumw2();; 897 SetBinErrorOption(kNormal);; 898 // see comment in GetBinError for special convention of bin index in fSumw2 array; 899 Int_t binIndex = (bin > 0) ? bin+kNOverflow-1 : -(bin+1);; 900 fSumw2.fArray[binIndex] = error * error;; 901}; 902 ; 903 ; 904 ; 905////////////////////////////////////////////////////////////////////////////////; 906/// Returns the bin name.; 907 ; 908const char *TH2Poly::GetBinName(Int_t bin) const; 909{; 910 if (bin > GetNumberOfBins()) return """";; 911 if (bin <= 0) return """";; 912 return ((TH2PolyBin*) fBins->At(bin-1))->GetPolygon()->GetName();; 913}; 914 ; 915////////////////////////////////////////////////////////////////////////////////; 916/// Returns the bin title.; 917 ; 918const char *TH2Poly::GetBinTitle(Int_t bin) const; 919{; 920 if (bin > GetNumberOfBins()) return """";; 921 if (bin <= 0) return """";; 922 return ((TH2PolyBin*) fBins->At(bin-1))->GetPolygon()->GetTitle();; 923}; 924 ; 925////////////////////////////////////////////////////////////////////////////////; 926/// Returns the maximum value of the histogram.; 927 ; 928Double_t TH2Poly::GetMaximum() const; 929{; 930 if (fNcells <= kNOverflow) return 0;; 931 if (fMaximum != -1111) return fMaximum;; 932 ; 933 TH2PolyBin *b;; 934 ; 935 TIter next(fBins);; 936 TObject *ob",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:47508,Availability,error,errors,47508," 1342 TString histName = GetName();; 1343 if (!fDirectory && !histName.Contains(""Graph"")) {; 1344 hcounter++;; 1345 histName += ""__"";; 1346 histName += hcounter;; 1347 }; 1348 ; 1349 TString hname = gInterpreter->MapCppName(histName.Data());; 1350 ; 1351 //Construct the class initialization; 1352 out << hname << "" = new "" << ClassName() << ""(\"""" << hname << ""\"", \""""; 1353 << GetTitle() << ""\"", "" << fCellX << "", "" << fXaxis.GetXmin(); 1354 << "", "" << fXaxis.GetXmax(); 1355 << "", "" << fCellY << "", "" << fYaxis.GetXmin() << "", ""; 1356 << fYaxis.GetXmax() << "");"" << std::endl;; 1357 ; 1358 // Save Bins; 1359 TIter next(fBins);; 1360 TObject *obj;; 1361 TH2PolyBin *th2pBin;; 1362 ; 1363 while((obj = next())){; 1364 th2pBin = (TH2PolyBin*) obj;; 1365 th2pBin->GetPolygon()->SavePrimitive(out, TString::Format(""th2poly%s"",hname.Data()));; 1366 }; 1367 ; 1368 // save bin contents; 1369 out<<"" ""<<std::endl;; 1370 Int_t bin;; 1371 for (bin=1;bin<=GetNumberOfBins();bin++) {; 1372 Double_t bc = GetBinContent(bin);; 1373 if (bc) {; 1374 out<<"" ""<<hname<<""->SetBinContent(""<<bin<<"",""<<bc<<"");""<<std::endl;; 1375 }; 1376 }; 1377 ; 1378 // save bin errors; 1379 if (fSumw2.fN) {; 1380 for (bin=1;bin<=GetNumberOfBins();bin++) {; 1381 Double_t be = GetBinError(bin);; 1382 if (be) {; 1383 out<<"" ""<<hname<<""->SetBinError(""<<bin<<"",""<<be<<"");""<<std::endl;; 1384 }; 1385 }; 1386 }; 1387 TH1::SavePrimitiveHelp(out, hname, option);; 1388}; 1389 ; 1390////////////////////////////////////////////////////////////////////////////////; 1391/// Multiply this histogram by a constant c1.; 1392 ; 1393void TH2Poly::Scale(Double_t c1, Option_t*); 1394{; 1395 for( int i = 0; i < this->GetNumberOfBins(); i++ ) {; 1396 this->SetBinContent(i+1, c1*this->GetBinContent(i+1));; 1397 }; 1398 for( int i = 0; i < kNOverflow; i++ ) {; 1399 this->SetBinContent(-i-1, c1*this->GetBinContent(-i-1) );; 1400 }; 1401}; 1402 ; 1403////////////////////////////////////////////////////////////////////////////////; 1404/// Sets t",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:63518,Availability,error,errorUp,63518,"ption_t *option="""")Helper function for the SavePrimitive functions from TH1 or classes derived from TH1,...Definition TH1.cxx:7379; TH1::GetBinErrorSqUncheckedvirtual Double_t GetBinErrorSqUnchecked(Int_t bin) constDefinition TH1.h:449; TH1::fMinimumDouble_t fMinimumMinimum value for plotting.Definition TH1.h:101; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::ResetStatsvirtual void ResetStats()Reset the statistics including the number of entries and replace with values calculated from bin cont...Definition TH1.cxx:7902; TH1::SetBinErrorOptionvirtual void SetBinErrorOption(EBinErrorOpt type)Definition TH1.h:381; TH1::kNstat@ kNstatSize of statistics data (up to TProfile3D)Definition TH1.h:184; TH1::fEntriesDouble_t fEntriesNumber of entries.Definition TH1.h:95; TH1::kNormal@ kNormalErrors with Normal (Wald) approximation: errorUp=errorLow= sqrt(N)Definition TH1.h:65; TH1::fXaxisTAxis fXaxisX axis descriptor.Definition TH1.h:90; TH1::fSumw2TArrayD fSumw2Array of sum of squares of weights.Definition TH1.h:104; TH1::GetSumw2Nvirtual Int_t GetSumw2N() constDefinition TH1.h:315; TH1::fYaxisTAxis fYaxisY axis descriptor.Definition TH1.h:91; TH1::GetSumOfWeightsvirtual Double_t GetSumOfWeights() constReturn the sum of weights excluding under/overflows.Definition TH1.cxx:7917; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create structure to store sum of squares of weights.Definition TH1.cxx:9020; TH1::SetEntriesvirtual void SetEntries(Double_t n)Definition TH1.h:391; TH1::fTsumwxDouble_t fTsumwxTotal Sum of weight*X.Definition TH1.h:98; TH2PolyBinHelper class to represent a bin in the TH2Poly histogram.Definition TH2Poly.h:25; TH2PolyBin::GetXMinDouble_t GetXMin()Returns the minimum value for the x coordinates of the bin.Definition TH2Poly.cxx:1565; TH2PolyBin::~TH2PolyBin~TH2PolyBin() overrideD",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:63526,Availability,error,errorLow,63526,"ption_t *option="""")Helper function for the SavePrimitive functions from TH1 or classes derived from TH1,...Definition TH1.cxx:7379; TH1::GetBinErrorSqUncheckedvirtual Double_t GetBinErrorSqUnchecked(Int_t bin) constDefinition TH1.h:449; TH1::fMinimumDouble_t fMinimumMinimum value for plotting.Definition TH1.h:101; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::ResetStatsvirtual void ResetStats()Reset the statistics including the number of entries and replace with values calculated from bin cont...Definition TH1.cxx:7902; TH1::SetBinErrorOptionvirtual void SetBinErrorOption(EBinErrorOpt type)Definition TH1.h:381; TH1::kNstat@ kNstatSize of statistics data (up to TProfile3D)Definition TH1.h:184; TH1::fEntriesDouble_t fEntriesNumber of entries.Definition TH1.h:95; TH1::kNormal@ kNormalErrors with Normal (Wald) approximation: errorUp=errorLow= sqrt(N)Definition TH1.h:65; TH1::fXaxisTAxis fXaxisX axis descriptor.Definition TH1.h:90; TH1::fSumw2TArrayD fSumw2Array of sum of squares of weights.Definition TH1.h:104; TH1::GetSumw2Nvirtual Int_t GetSumw2N() constDefinition TH1.h:315; TH1::fYaxisTAxis fYaxisY axis descriptor.Definition TH1.h:91; TH1::GetSumOfWeightsvirtual Double_t GetSumOfWeights() constReturn the sum of weights excluding under/overflows.Definition TH1.cxx:7917; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create structure to store sum of squares of weights.Definition TH1.cxx:9020; TH1::SetEntriesvirtual void SetEntries(Double_t n)Definition TH1.h:391; TH1::fTsumwxDouble_t fTsumwxTotal Sum of weight*X.Definition TH1.h:98; TH2PolyBinHelper class to represent a bin in the TH2Poly histogram.Definition TH2Poly.h:25; TH2PolyBin::GetXMinDouble_t GetXMin()Returns the minimum value for the x coordinates of the bin.Definition TH2Poly.cxx:1565; TH2PolyBin::~TH2PolyBin~TH2PolyBin() overrideD",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:70237,Availability,error,error,70237," bin list.Definition TH2Poly.cxx:877; TH2Poly::SetBinContentChangedvoid SetBinContentChanged(Bool_t flag)Definition TH2Poly.h:122; TH2Poly::GetStatsvoid GetStats(Double_t *stats) const overrideFill the array stats from the contents of this histogram The array stats must be correctly dimensione...Definition TH2Poly.cxx:1440; TH2Poly::fCompletelyInsideBool_t * fCompletelyInside[fNCells] The array that returns true if the cell at the given coordinate is completely inside a binDefinition TH2Poly.h:166; TH2Poly::TH2PolyTH2Poly()Default Constructor. No boundaries specified.Definition TH2Poly.cxx:148; TH2Poly::IsInsideBinBool_t IsInsideBin(Int_t binnr, Double_t x, Double_t y)Return ""true"" if the point (x,y) is inside the bin of binnr.Definition TH2Poly.cxx:1432; TH2Poly::fNewBinAddedBool_t fNewBinAdded!For the 3D PainterDefinition TH2Poly.h:168; TH2Poly::Copyvoid Copy(TObject &newth2p) const overrideCopy function for TH2Poly.Definition TH2Poly.cxx:212; TH2Poly::SetBinErrorvoid SetBinError(Int_t bin, Double_t error) overrideSet the bin Error.Definition TH2Poly.cxx:893; TH2Poly::GetBinTitleconst char * GetBinTitle(Int_t bin) constReturns the bin title.Definition TH2Poly.cxx:918; TH2Poly::SetNewBinAddedvoid SetNewBinAdded(Bool_t flag)Definition TH2Poly.h:124; TH2Poly::Scalevoid Scale(Double_t c1=1, Option_t *option="""") overrideMultiply this histogram by a constant c1.Definition TH2Poly.cxx:1393; TH2Poly::ChangePartitionvoid ChangePartition(Int_t n, Int_t m)Changes the number of partition cells in the histogram.Definition TH2Poly.cxx:515; TH2Poly::Interpolatevirtual Double_t Interpolate(Double_t, Double_t)NOT IMPLEMENTED for TH2Poly.Definition TH2Poly.cxx:1749; TH2Poly::GetMinimumDouble_t GetMinimum() constReturns the minimum value of the histogram.Definition TH2Poly.cxx:976; TH2Poly::GetBinNameconst char * GetBinName(Int_t bin) constReturns the bin name.Definition TH2Poly.cxx:908; TH2Poly::fStepXDouble_t fStepXDefinition TH2Poly.h:164; TH2Poly::FillNvoid FillN(Int_t ntimes, co",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:72496,Availability,error,error,72496,"lete copy of the underlying object.Definition TH2Poly.cxx:554; TH2Poly::fNCellsInt_t fNCellsNumber of partition cells: fCellX*fCellY.Definition TH2Poly.h:162; TH2Poly::FindBinInt_t FindBin(Double_t x, Double_t y, Double_t z=0) overrideReturns the bin number of the bin at the given coordinate.Definition TH2Poly.cxx:621; TH2Poly::DivideBool_t Divide(TF1 *, Double_t) overrideNOT IMPLEMENTED for TH2Poly.Definition TH2Poly.cxx:1713; TH2Poly::Initializevoid Initialize(Double_t xlow, Double_t xup, Double_t ylow, Double_t yup, Int_t n, Int_t m)Initializes the TH2Poly object. This method is called by the constructor.Definition TH2Poly.cxx:1113; TH2Poly::fCellXInt_t fCellXNumber of partition cells in the x-direction of the histogram.Definition TH2Poly.h:160; TH2Poly::~TH2Poly~TH2Poly() overrideDestructor.Definition TH2Poly.cxx:192; TH2Poly::AddBinvirtual Int_t AddBin(TObject *poly)Adds a new bin to the histogram.Definition TH2Poly.cxx:297; TH2Poly::GetBinErrorDouble_t GetBinError(Int_t bin) const overrideReturns the value of error associated to bin number bin.Definition TH2Poly.cxx:856; TH2Poly::IsIntersectingPolygonBool_t IsIntersectingPolygon(Int_t bn, Double_t *x, Double_t *y, Double_t xclipl, Double_t xclipr, Double_t yclipb, Double_t yclipt)Returns kTRUE if the input polygon (bn, x, y) is intersecting with the input rectangle (xclipl,...Definition TH2Poly.cxx:1205; TH2Poly::AddBool_t Add(const TH1 *h1, Double_t c1) overridePerforms the operation: this = this + c1*h1.Definition TH2Poly.cxx:365; TH2Poly::GetAsymmetryvirtual TH1 * GetAsymmetry(TH1 *, Double_t, Double_t)NOT IMPLEMENTED for TH2Poly.Definition TH2Poly.cxx:1742; TH2Poly::Honeycombvoid Honeycomb(Double_t xstart, Double_t ystart, Double_t a, Int_t k, Int_t s, Option_t *option=""v"")Bins the histogram using a honeycomb structure If the option ""v"" is specified, the hexagons are drawn...Definition TH2Poly.cxx:1026; TH2Poly::MergeLong64_t Merge(TCollection *) overrideMerge TH2Polys Given the special nature of the TH2Pol",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:73957,Availability,error,errors,73957,"he operation: this = this + c1*h1.Definition TH2Poly.cxx:365; TH2Poly::GetAsymmetryvirtual TH1 * GetAsymmetry(TH1 *, Double_t, Double_t)NOT IMPLEMENTED for TH2Poly.Definition TH2Poly.cxx:1742; TH2Poly::Honeycombvoid Honeycomb(Double_t xstart, Double_t ystart, Double_t a, Int_t k, Int_t s, Option_t *option=""v"")Bins the histogram using a honeycomb structure If the option ""v"" is specified, the hexagons are drawn...Definition TH2Poly.cxx:1026; TH2Poly::MergeLong64_t Merge(TCollection *) overrideMerge TH2Polys Given the special nature of the TH2Poly, the merge is implemented in terms of subseque...Definition TH2Poly.cxx:1319; TH2Poly::SetBinContentvoid SetBinContent(Int_t bin, Double_t content) overrideSets the contents of the input bin to the input content Negative values between -1 and -9 are for the...Definition TH2Poly.cxx:1407; TH2Poly::GetMaximumDouble_t GetMaximum() constReturns the maximum value of the histogram.Definition TH2Poly.cxx:928; TH2Poly::Resetvoid Reset(Option_t *option) overrideReset this histogram: contents, errors, etc.Definition TH2Poly.cxx:591; TH2Poly::fStepYDouble_t fStepYDimensions of a partition cell.Definition TH2Poly.h:164; TH2Poly::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TH2Poly.cxx:1333; TH2Poly::FFTTH1 * FFT(TH1 *, Option_t *) overrideNOT IMPLEMENTED for TH2Poly.Definition TH2Poly.cxx:1735; TH2Poly::fCellsTList * fCells[fNCells] The array of TLists that store the bins that intersect with each cell. List do not own the ...Definition TH2Poly.h:163; TH2Poly::fCellYInt_t fCellYNumber of partition cells in the y-direction of the histogram.Definition TH2Poly.h:161; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TH2::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH2.cxx:380; TH2::fTsumwxyDouble_t fTsumwxyTotal Sum of weight*X*Y.Definition TH2.h:36; TH2::Resetvoid Reset(Option_t *option="""") overrideReset this ",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:74938,Availability,error,errors,74938,"ption_t *option) overrideReset this histogram: contents, errors, etc.Definition TH2Poly.cxx:591; TH2Poly::fStepYDouble_t fStepYDimensions of a partition cell.Definition TH2Poly.h:164; TH2Poly::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TH2Poly.cxx:1333; TH2Poly::FFTTH1 * FFT(TH1 *, Option_t *) overrideNOT IMPLEMENTED for TH2Poly.Definition TH2Poly.cxx:1735; TH2Poly::fCellsTList * fCells[fNCells] The array of TLists that store the bins that intersect with each cell. List do not own the ...Definition TH2Poly.h:163; TH2Poly::fCellYInt_t fCellYNumber of partition cells in the y-direction of the histogram.Definition TH2Poly.h:161; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TH2::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH2.cxx:380; TH2::fTsumwxyDouble_t fTsumwxyTotal Sum of weight*X*Y.Definition TH2.h:36; TH2::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH2.cxx:2600; TH2::fTsumwy2Double_t fTsumwy2Total Sum of weight*Y*Y.Definition TH2.h:35; TH2::fTsumwyDouble_t fTsumwyTotal Sum of weight*Y.Definition TH2.h:34; TH2::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TH2.cxx:2485; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::AtTObject * At(Int_t idx) const overrideReturns the object at position idx. Returns 0 if idx is out of range.Definition TList.cxx:355; TMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects.Definition TMultiGraph.h:34; TMultiGraph::GetListOfGraphsTList * GetListOfGraphs() constDefinition TMultiGraph.h:68; TMultiGraph::Classstatic TClass * Class(); TMultiGraph::IsInsidevirtual Int_t IsInside(Double_t x, Double_t y) constReturn 1 if the point (x,y) is inside one of the ",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:77086,Availability,error,error,77086,"med.cxx:74; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::CompareToint CompareTo(const char *cs, ECaseCompare cmp=kExact) constCompare a string to char *cs2.Definition TString.cxx:457; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:77222,Availability,error,error,77222,"char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::CompareToint CompareTo(const char *cs, ECaseCompare cmp=kExact) constCompare a string to char *cs2.Definition TString.cxx:457; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; h1TH1F * h1Definition legend1.C:5; TMath::IsInsideBool_t IsInside(T xp, T yp, Int_t np, T",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:3046,Deployability,update,updated,3046,"cation is binned later.; 52 ; 53If there are two overlapping bins, the first one in the list will be incremented; 54by `Fill()`.; 55 ; 56The histogram may automatically extends its limits if a bin outside the; 57histogram limits is added. This is done when the default constructor (with no; 58arguments) is used. It generates a histogram with no limits along the X and Y; 59axis. Adding bins to it will extend it up to a proper size.; 60 ; 61`TH2Poly` implements a partitioning algorithm to speed up bins' filling; 62(see the ""Partitioning Algorithm"" section for details).; 63The partitioning algorithm divides the histogram into regions called cells.; 64The bins that each cell intersects are recorded in an array of `TList`s.; 65When a coordinate in the histogram is to be filled; the method (quickly) finds; 66which cell the coordinate belongs. It then only loops over the bins; 67intersecting that cell to find the bin the input coordinate corresponds to.; 68The partitioning of the histogram is updated continuously as each bin is added.; 69The default number of cells on each axis is 25. This number could be set to; 70another value in the constructor or adjusted later by calling the; 71`ChangePartition(Int_t, Int_t)` method. The partitioning algorithm is; 72considerably faster than the brute force algorithm (i.e. checking if each bin; 73contains the input coordinates), especially if the histogram is to be filled; 74many times.; 75 ; 76The following very simple macro shows how to build and fill a `TH2Poly`:; 77~~~ {.cpp}; 78{; 79 auto h2p = new TH2Poly();; 80 ; 81 Double_t x1[] = {0, 5, 6};; 82 Double_t y1[] = {0, 0, 5};; 83 Double_t x2[] = {0, -1, -1, 0};; 84 Double_t y2[] = {0, 0, -1, 3};; 85 Double_t x3[] = {4, 3, 0, 1, 2.4};; 86 Double_t y3[] = {4, 3.7, 1, 3.7, 2.5};; 87 ; 88 h2p->AddBin(3, x1, y1);; 89 h2p->AddBin(4, x2, y2);; 90 h2p->AddBin(5, x3, y3);; 91 ; 92 h2p->Fill(0.1, 0.01, 3);; 93 h2p->Fill(-0.5, -0.5, 7);; 94 h2p->Fill(-0.7, -0.5, 1);; 95 h2p->Fill(1, 3, 1.5);; 9",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:3054,Deployability,continuous,continuously,3054,"cation is binned later.; 52 ; 53If there are two overlapping bins, the first one in the list will be incremented; 54by `Fill()`.; 55 ; 56The histogram may automatically extends its limits if a bin outside the; 57histogram limits is added. This is done when the default constructor (with no; 58arguments) is used. It generates a histogram with no limits along the X and Y; 59axis. Adding bins to it will extend it up to a proper size.; 60 ; 61`TH2Poly` implements a partitioning algorithm to speed up bins' filling; 62(see the ""Partitioning Algorithm"" section for details).; 63The partitioning algorithm divides the histogram into regions called cells.; 64The bins that each cell intersects are recorded in an array of `TList`s.; 65When a coordinate in the histogram is to be filled; the method (quickly) finds; 66which cell the coordinate belongs. It then only loops over the bins; 67intersecting that cell to find the bin the input coordinate corresponds to.; 68The partitioning of the histogram is updated continuously as each bin is added.; 69The default number of cells on each axis is 25. This number could be set to; 70another value in the constructor or adjusted later by calling the; 71`ChangePartition(Int_t, Int_t)` method. The partitioning algorithm is; 72considerably faster than the brute force algorithm (i.e. checking if each bin; 73contains the input coordinates), especially if the histogram is to be filled; 74many times.; 75 ; 76The following very simple macro shows how to build and fill a `TH2Poly`:; 77~~~ {.cpp}; 78{; 79 auto h2p = new TH2Poly();; 80 ; 81 Double_t x1[] = {0, 5, 6};; 82 Double_t y1[] = {0, 0, 5};; 83 Double_t x2[] = {0, -1, -1, 0};; 84 Double_t y2[] = {0, 0, -1, 3};; 85 Double_t x3[] = {4, 3, 0, 1, 2.4};; 86 Double_t y3[] = {4, 3.7, 1, 3.7, 2.5};; 87 ; 88 h2p->AddBin(3, x1, y1);; 89 h2p->AddBin(4, x2, y2);; 90 h2p->AddBin(5, x3, y3);; 91 ; 92 h2p->Fill(0.1, 0.01, 3);; 93 h2p->Fill(-0.5, -0.5, 7);; 94 h2p->Fill(-0.7, -0.5, 1);; 95 h2p->Fill(1, 3, 1.5);; 9",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:16287,Deployability,update,update,16287,"s fills only used elements depending on dimension and type; 404 GetStats(s1);; 405 h1->GetStats(s2);; 406 }; 407 // get number of entries now because afterwards UpdateBinContent will change it; 408 Double_t entries = TMath::Abs( GetEntries() + c1 * h1->GetEntries() );; 409 ; 410 ; 411 // Perform the Add.; 412 Double_t factor = 1;; 413 if (h1p->GetNormFactor() != 0); 414 factor = h1p->GetNormFactor() / h1p->GetSumOfWeights();; 415 for (bin = 0; bin < fNcells; bin++) {; 416 Double_t y = this->RetrieveBinContent(bin) + c1 * h1p->RetrieveBinContent(bin);; 417 UpdateBinContent(bin, y);; 418 if (fSumw2.fN) {; 419 Double_t esq = factor * factor * h1p->GetBinErrorSqUnchecked(bin);; 420 fSumw2.fArray[bin] += c1 * c1 * factor * factor * esq;; 421 }; 422 }; 423 ; 424 // update statistics (do here to avoid changes by SetBinContent); 425 if (resetStats) {; 426 // statistics need to be reset in case coefficient are negative; 427 ResetStats();; 428 } else {; 429 for (Int_t i = 0; i < kNstat; i++) {; 430 if (i == 1) s1[i] += c1 * c1 * s2[i];; 431 else s1[i] += c1 * s2[i];; 432 }; 433 PutStats(s1);; 434 SetEntries(entries);; 435 }; 436 return kTRUE;; 437}; 438 ; 439////////////////////////////////////////////////////////////////////////////////; 440/// Adds the input bin into the partition cell matrix. This method is called; 441/// in AddBin() and ChangePartition().; 442 ; 443void TH2Poly::AddBinToPartition(TH2PolyBin *bin); 444{; 445 // Cell Info; 446 Int_t nl, nr, mb, mt; // Max/min indices of the cells that contain the bin; 447 Double_t xclipl, xclipr, yclipb, yclipt; // x and y coordinates of a cell; 448 Double_t binXmax, binXmin, binYmax, binYmin; // The max/min bin coordinates; 449 ; 450 binXmax = bin->GetXMax();; 451 binXmin = bin->GetXMin();; 452 binYmax = bin->GetYMax();; 453 binYmin = bin->GetYMin();; 454 nl = (Int_t)(floor((binXmin - fXaxis.GetXmin())/fStepX));; 455 nr = (Int_t)(floor((binXmax - fXaxis.GetXmin())/fStepX));; 456 mb = (Int_t)(floor((binYmin - fYaxis.GetXmin",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:29015,Deployability,update,updated,29015,"5/// Returns the integral of bin contents.; 796/// By default the integral is computed as the sum of bin contents.; 797/// If option ""width"" or ""area"" is specified, the integral is the sum of; 798/// the bin contents multiplied by the area of the bin.; 799 ; 800Double_t TH2Poly::Integral(Option_t* option) const; 801{; 802 TString opt = option;; 803 opt.ToLower();; 804 ; 805 Double_t w;; 806 Double_t integral = 0.;; 807 ; 808 TIter next(fBins);; 809 TObject *obj;; 810 TH2PolyBin *bin;; 811 if ((opt.Contains(""width"")) || (opt.Contains(""area""))) {; 812 while ((obj = next())) {; 813 bin = (TH2PolyBin *)obj;; 814 w = bin->GetArea();; 815 integral += w * (bin->GetContent());; 816 }; 817 } else {; 818 // need to recompute integral in case SetBinContent was called.; 819 // fTsumw cannot be used since it is not updated in that case; 820 while ((obj = next())) {; 821 bin = (TH2PolyBin *)obj;; 822 integral += (bin->GetContent());; 823 }; 824 }; 825 return integral;; 826}; 827 ; 828////////////////////////////////////////////////////////////////////////////////; 829/// Returns the content of the input bin; 830/// Bin numbers are from [1,nbins] and; 831/// for the overflow/underflow/sea bins the range is [-9,-1]:; 832///~~~ {.cpp}; 833/// -1 | -2 | -3; 834/// ---+----+----; 835/// -4 | -5 | -6; 836/// ---+----+----; 837/// -7 | -8 | -9; 838///~~~; 839/// where -5 is the ""sea"" bin (i.e. unbinned areas); 840 ; 841Double_t TH2Poly::GetBinContent(Int_t bin) const; 842{; 843 if (bin > GetNumberOfBins() || bin == 0 || bin < -kNOverflow) return 0;; 844 if (bin<0) return fOverflow[-bin - 1];; 845 return ((TH2PolyBin*) fBins->At(bin-1))->GetContent();; 846}; 847 ; 848////////////////////////////////////////////////////////////////////////////////; 849/// Returns the value of error associated to bin number bin.; 850/// If the sum of squares of weights has been defined (via Sumw2),; 851/// this function returns the sqrt(sum of w2).; 852/// otherwise it returns the sqrt(contents) for this b",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:66548,Deployability,update,update,66548,"2PolyBin::fYmaxDouble_t fYmaxY maximum value.Definition TH2Poly.h:56; TH2PolyBin::GetXMaxDouble_t GetXMax()Returns the maximum value for the x coordinates of the bin.Definition TH2Poly.cxx:1529; TH2PolyBin::GetContentDouble_t GetContent() constDefinition TH2Poly.h:35; TH2PolyBin::fYminDouble_t fYminY minimum value.Definition TH2Poly.h:54; TH2PolyBin::SetChangedvoid SetChanged(Bool_t flag)Definition TH2Poly.h:44; TH2PolyBin::GetBinNumberInt_t GetBinNumber() constDefinition TH2Poly.h:37; TH2PolyBin::fXminDouble_t fXminX minimum value.Definition TH2Poly.h:53; TH2PolyBin::GetPolygonTObject * GetPolygon() constDefinition TH2Poly.h:38; TH2PolyBin::fPolyTObject * fPolyObject holding the polygon definition.Definition TH2Poly.h:50; TH2Poly2D Histogram with Polygonal BinsDefinition TH2Poly.h:66; TH2Poly::MultiplyBool_t Multiply(TF1 *, Double_t) overrideNOT IMPLEMENTED for TH2Poly.Definition TH2Poly.cxx:1721; TH2Poly::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH2Poly.h:180; TH2Poly::operator=TH2Poly & operator=(const TH2Poly &rhs)Assignment operator.Definition TH2Poly.cxx:203; TH2Poly::GetBinsTList * GetBins()Returns the TList of all bins in the histogram.Definition TH2Poly.h:101; TH2Poly::ClearBinContentsvoid ClearBinContents()Clears the contents of all bins in the histogram.Definition TH2Poly.cxx:566; TH2Poly::fOverflowDouble_t fOverflow[kNOverflow]Overflow bins.Definition TH2Poly.h:159; TH2Poly::kNOverflow@ kNOverflowDefinition TH2Poly.h:157; TH2Poly::fFloatBool_t fFloatWhen set to kTRUE, allows the histogram to expand if a bin outside the limits is added.Definition TH2Poly.h:167; TH2Poly::ComputeIntegralDouble_t ComputeIntegral(Bool_t) overrideNOT IMPLEMENTED for TH2Poly.Definition TH2Poly.cxx:1728; TH2Poly::IsIntersectingBool_t IsIntersecting(TH2PolyBin *bin, Double_t xclipl, Double_t xclipr, Double_t yclipb, Double_t yclipt)R",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:5138,Energy Efficiency,reduce,reduces,5138,"s an essential part of the `TH2Poly`; 104class. It is implemented to speed up the filling of bins.; 105 ; 106With the brute force approach, the filling is done in the following way: An; 107iterator loops over all bins in the `TH2Poly` and invokes the; 108method `IsInside()` for each of them.; 109This method checks if the input location is in that bin. If the filling; 110coordinate is inside, the bin is filled. Looping over all the bin is; 111very slow.; 112 ; 113The alternative is to divide the histogram into virtual rectangular regions; 114called ""cells"". Each cell stores the pointers of the bins intersecting it.; 115When a coordinate is to be filled, the method finds which cell the coordinate; 116falls into. Since the cells are rectangular, this can be done very quickly.; 117It then only loops over the bins associated with that cell and calls `IsInside()`; 118only on that bins. This reduces considerably the number of bins on which `IsInside()`; 119is called and therefore speed up by a huge factor the filling compare to the brute force; 120approach where `IsInside()` is called for all bins.; 121 ; 122The addition of bins to the appropriate cells is done when the bin is added; 123to the histogram. To do this, `AddBin()` calls the; 124`AddBinToPartition()` method.; 125This method adds the input bin to the partitioning matrix.; 126 ; 127The number of partition cells per axis can be specified in the constructor.; 128If it is not specified, the default value of 25 along each axis will be; 129assigned. This value was chosen because it is small enough to avoid slowing; 130down AddBin(), while being large enough to enhance Fill() by a considerable; 131amount. Regardless of how it is initialized at construction time, it can be; 132changed later with the `ChangePartition()` method.; 133`ChangePartition()` deletes the; 134old partition matrix and generates a new one with the specified number of cells; 135on each axis.; 136 ; 137The optimum number of partition cells per axis c",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:6461,Energy Efficiency,efficient,efficient,6461,"his, `AddBin()` calls the; 124`AddBinToPartition()` method.; 125This method adds the input bin to the partitioning matrix.; 126 ; 127The number of partition cells per axis can be specified in the constructor.; 128If it is not specified, the default value of 25 along each axis will be; 129assigned. This value was chosen because it is small enough to avoid slowing; 130down AddBin(), while being large enough to enhance Fill() by a considerable; 131amount. Regardless of how it is initialized at construction time, it can be; 132changed later with the `ChangePartition()` method.; 133`ChangePartition()` deletes the; 134old partition matrix and generates a new one with the specified number of cells; 135on each axis.; 136 ; 137The optimum number of partition cells per axis changes with the number of; 138times `Fill()` will be called. Although partitioning greatly speeds up; 139filling, it also adds a constant time delay into the code. When `Fill()`; 140is to be called many times, it is more efficient to divide the histogram into; 141a large number cells. However, if the histogram is to be filled only a few; 142times, it is better to divide into a small number of cells.; 143*/; 144 ; 145////////////////////////////////////////////////////////////////////////////////; 146/// Default Constructor. No boundaries specified.; 147 ; 148TH2Poly::TH2Poly(); 149{; 150 Initialize(0., 0., 0., 0., 25, 25);; 151 SetName(""NoName"");; 152 SetTitle(""NoTitle"");; 153 SetFloat();; 154}; 155 ; 156////////////////////////////////////////////////////////////////////////////////; 157/// Constructor with specified name and boundaries,; 158/// but no partition cell number.; 159 ; 160TH2Poly::TH2Poly(const char *name,const char *title, Double_t xlow,Double_t xup; 161 , Double_t ylow,Double_t yup); 162{; 163 Initialize(xlow, xup, ylow, yup, 25, 25);; 164 SetName(name);; 165 SetTitle(title);; 166 SetFloat(kFALSE);; 167}; 168 ; 169////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:9357,Energy Efficiency,allocate,allocate,9357," the bin List since it owns the objects; 198 delete fBins;; 199}; 200 ; 201/////////////////////////////////////////////////////////////////////////////////; 202/// Assignment operator; 203TH2Poly & TH2Poly::operator=(const TH2Poly & rhs) {; 204 if (this != &rhs); 205 rhs.Copy(*this);; 206 return *this;; 207}; 208 ; 209////////////////////////////////////////////////////////////////////////////////; 210/// Copy function for TH2Poly; 211 ; 212void TH2Poly::Copy(TObject &newobj) const; 213{; 214 // copy first TH2 information; 215 TH2::Copy(newobj);; 216 auto & newth2p = dynamic_cast<TH2Poly &>(newobj);; 217 newth2p.SetName(GetName());; 218 newth2p.SetTitle(GetTitle());; 219 ; 220 newth2p.fCellX = fCellX;; 221 newth2p.fCellY = fCellY;; 222 newth2p.fNCells = fNCells;; 223 newth2p.fStepX = fStepX;; 224 newth2p.fStepY = fStepY;; 225 ; 226 // deallocate previous arrays, if existing; 227 delete[] newth2p.fCells;; 228 delete[] newth2p.fIsEmpty;; 229 delete[] newth2p.fCompletelyInside;; 230 // allocate arrays; 231 newth2p.fCells = new TList [fNCells];; 232 newth2p.fIsEmpty = new Bool_t [fNCells]; // Empty partition; 233 newth2p.fCompletelyInside = new Bool_t [fNCells]; // Cell is completely inside bin; 234 // Initializes the flags; 235 for (int i = 0; i<fNCells; i++) {; 236 newth2p.fIsEmpty[i] = fIsEmpty[i];; 237 newth2p.fCompletelyInside[i] = fCompletelyInside[i];; 238 }; 239 // need to use Clone to copy the contained bin list; 240 delete newth2p.fBins; // in case there was something before there; 241 if (!fBins) {; 242 newth2p.fBins = nullptr;; 243 }; 244 else {; 245 newth2p.fBins = dynamic_cast<TList *>(fBins->Clone());; 246 if (!newth2p.fBins); 247 Error(""Copy"",""Error cloning the TH2Poly bin list"");; 248 else {; 249 // add bins in the fCells partition. We need to add the TH2PolyBin objects; 250 // of the new copied histograms. For this we call AddBinToPartition; 251 // we could probably optimize this by implementing a copy of the partition; 252 for (auto bin : *(newth2p.f",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:15544,Integrability,depend,depending,15544,"76 ; 377 // Check if the bins are the same.; 378 TList *h1pBins = h1p->GetBins();; 379 TH2PolyBin *thisBin, *h1pBin;; 380 for (bin = 1; bin <= GetNumberOfBins(); bin++) {; 381 thisBin = (TH2PolyBin *)fBins->At(bin - 1);; 382 h1pBin = (TH2PolyBin *)h1pBins->At(bin - 1);; 383 if (thisBin->GetXMin() != h1pBin->GetXMin() ||; 384 thisBin->GetXMax() != h1pBin->GetXMax() ||; 385 thisBin->GetYMin() != h1pBin->GetYMin() ||; 386 thisBin->GetYMax() != h1pBin->GetYMax()) {; 387 Error(""Add"", ""Attempt to add histograms with different bin limits"");; 388 return kFALSE;; 389 }; 390 }; 391 ; 392 ; 393 // Create Sumw2 if h1p has Sumw2 set; 394 if (fSumw2.fN == 0 && h1p->GetSumw2N() != 0) Sumw2();; 395 ; 396 // statistics can be preserved only in case of positive coefficients; 397 // otherwise with negative c1 (histogram subtraction) one risks to get negative variances; 398 Bool_t resetStats = (c1 < 0);; 399 Double_t s1[kNstat] = {0};; 400 Double_t s2[kNstat] = {0};; 401 if (!resetStats) {; 402 // need to initialize to zero s1 and s2 since; 403 // GetStats fills only used elements depending on dimension and type; 404 GetStats(s1);; 405 h1->GetStats(s2);; 406 }; 407 // get number of entries now because afterwards UpdateBinContent will change it; 408 Double_t entries = TMath::Abs( GetEntries() + c1 * h1->GetEntries() );; 409 ; 410 ; 411 // Perform the Add.; 412 Double_t factor = 1;; 413 if (h1p->GetNormFactor() != 0); 414 factor = h1p->GetNormFactor() / h1p->GetSumOfWeights();; 415 for (bin = 0; bin < fNcells; bin++) {; 416 Double_t y = this->RetrieveBinContent(bin) + c1 * h1p->RetrieveBinContent(bin);; 417 UpdateBinContent(bin, y);; 418 if (fSumw2.fN) {; 419 Double_t esq = factor * factor * h1p->GetBinErrorSqUnchecked(bin);; 420 fSumw2.fArray[bin] += c1 * c1 * factor * factor * esq;; 421 }; 422 }; 423 ; 424 // update statistics (do here to avoid changes by SetBinContent); 425 if (resetStats) {; 426 // statistics need to be reset in case coefficient are negative; 427 ResetStats();; 428 }",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:76784,Integrability,message,message,76784," TMultiGraph::IsInsidevirtual Int_t IsInside(Double_t x, Double_t y) constReturn 1 if the point (x,y) is inside one of the graphs 0 otherwise.Definition TMultiGraph.cxx:989; TNamed::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an object using the Streamer facility.Definition TNamed.cxx:74; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::CompareToint CompareTo(const char *cs, ECaseCompare cmp=kExact) constCompare a string to char *cs2.Definition TString.cxx:457; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:77092,Integrability,message,message,77092,"med.cxx:74; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::CompareToint CompareTo(const char *cs, ECaseCompare cmp=kExact) constCompare a string to char *cs2.Definition TString.cxx:457; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:77228,Integrability,message,message,77228,"char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::CompareToint CompareTo(const char *cs, ECaseCompare cmp=kExact) constCompare a string to char *cs2.Definition TString.cxx:457; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; h1TH1F * h1Definition legend1.C:5; TMath::IsInsideBool_t IsInside(T xp, T yp, Int_t np, T",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:2215,Modifiability,extend,extends,2215,"d; 34as `TGraph`s or `TMultiGraph`s ) and contents of the polygonal; 35bin as well as several related functions.; 36 ; 37Essentially, a `TH2Poly` is a TList of `TH2PolyBin` objects; 38with methods to manipulate them.; 39 ; 40Bins are defined using one of the `AddBin()` methods. The bin definition; 41should be done before filling.; 42 ; 43The histogram can be filled with `Fill(Double_t x, Double_t y, Double_t w); 44`. `w` is the weight.; 45If no weight is specified, it is assumed to be 1.; 46 ; 47Not all histogram's area need to be binned. Filling an area without bins,; 48will falls into the overflows. Adding a bin is not retroactive; it doesn't; 49affect previous fillings. A `Fill()` call, that; 50was previously ignored due to the lack of a bin at the specified location, is; 51not reconsidered when that location is binned later.; 52 ; 53If there are two overlapping bins, the first one in the list will be incremented; 54by `Fill()`.; 55 ; 56The histogram may automatically extends its limits if a bin outside the; 57histogram limits is added. This is done when the default constructor (with no; 58arguments) is used. It generates a histogram with no limits along the X and Y; 59axis. Adding bins to it will extend it up to a proper size.; 60 ; 61`TH2Poly` implements a partitioning algorithm to speed up bins' filling; 62(see the ""Partitioning Algorithm"" section for details).; 63The partitioning algorithm divides the histogram into regions called cells.; 64The bins that each cell intersects are recorded in an array of `TList`s.; 65When a coordinate in the histogram is to be filled; the method (quickly) finds; 66which cell the coordinate belongs. It then only loops over the bins; 67intersecting that cell to find the bin the input coordinate corresponds to.; 68The partitioning of the histogram is updated continuously as each bin is added.; 69The default number of cells on each axis is 25. This number could be set to; 70another value in the constructor or adjusted later by call",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:2449,Modifiability,extend,extend,2449,"40Bins are defined using one of the `AddBin()` methods. The bin definition; 41should be done before filling.; 42 ; 43The histogram can be filled with `Fill(Double_t x, Double_t y, Double_t w); 44`. `w` is the weight.; 45If no weight is specified, it is assumed to be 1.; 46 ; 47Not all histogram's area need to be binned. Filling an area without bins,; 48will falls into the overflows. Adding a bin is not retroactive; it doesn't; 49affect previous fillings. A `Fill()` call, that; 50was previously ignored due to the lack of a bin at the specified location, is; 51not reconsidered when that location is binned later.; 52 ; 53If there are two overlapping bins, the first one in the list will be incremented; 54by `Fill()`.; 55 ; 56The histogram may automatically extends its limits if a bin outside the; 57histogram limits is added. This is done when the default constructor (with no; 58arguments) is used. It generates a histogram with no limits along the X and Y; 59axis. Adding bins to it will extend it up to a proper size.; 60 ; 61`TH2Poly` implements a partitioning algorithm to speed up bins' filling; 62(see the ""Partitioning Algorithm"" section for details).; 63The partitioning algorithm divides the histogram into regions called cells.; 64The bins that each cell intersects are recorded in an array of `TList`s.; 65When a coordinate in the histogram is to be filled; the method (quickly) finds; 66which cell the coordinate belongs. It then only loops over the bins; 67intersecting that cell to find the bin the input coordinate corresponds to.; 68The partitioning of the histogram is updated continuously as each bin is added.; 69The default number of cells on each axis is 25. This number could be set to; 70another value in the constructor or adjusted later by calling the; 71`ChangePartition(Int_t, Int_t)` method. The partitioning algorithm is; 72considerably faster than the brute force algorithm (i.e. checking if each bin; 73contains the input coordinates), especially if the histogr",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:5876,Modifiability,enhance,enhance,5876,"ins intersecting it.; 115When a coordinate is to be filled, the method finds which cell the coordinate; 116falls into. Since the cells are rectangular, this can be done very quickly.; 117It then only loops over the bins associated with that cell and calls `IsInside()`; 118only on that bins. This reduces considerably the number of bins on which `IsInside()`; 119is called and therefore speed up by a huge factor the filling compare to the brute force; 120approach where `IsInside()` is called for all bins.; 121 ; 122The addition of bins to the appropriate cells is done when the bin is added; 123to the histogram. To do this, `AddBin()` calls the; 124`AddBinToPartition()` method.; 125This method adds the input bin to the partitioning matrix.; 126 ; 127The number of partition cells per axis can be specified in the constructor.; 128If it is not specified, the default value of 25 along each axis will be; 129assigned. This value was chosen because it is small enough to avoid slowing; 130down AddBin(), while being large enough to enhance Fill() by a considerable; 131amount. Regardless of how it is initialized at construction time, it can be; 132changed later with the `ChangePartition()` method.; 133`ChangePartition()` deletes the; 134old partition matrix and generates a new one with the specified number of cells; 135on each axis.; 136 ; 137The optimum number of partition cells per axis changes with the number of; 138times `Fill()` will be called. Although partitioning greatly speeds up; 139filling, it also adds a constant time delay into the code. When `Fill()`; 140is to be called many times, it is more efficient to divide the histogram into; 141a large number cells. However, if the histogram is to be filled only a few; 142times, it is better to divide into a small number of cells.; 143*/; 144 ; 145////////////////////////////////////////////////////////////////////////////////; 146/// Default Constructor. No boundaries specified.; 147 ; 148TH2Poly::TH2Poly(); 149{; 150 Initia",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:11412,Modifiability,extend,extend,11412," objects; 250 // of the new copied histograms. For this we call AddBinToPartition; 251 // we could probably optimize this by implementing a copy of the partition; 252 for (auto bin : *(newth2p.fBins)) {; 253 newth2p.AddBinToPartition(dynamic_cast<TH2PolyBin*>(bin));; 254 }; 255 }; 256 }; 257 // copy overflow contents; 258 for(int i = 0; i < kNOverflow; i++ ) {; 259 newth2p.fOverflow[i] = fOverflow[i];; 260 }; 261 // copy other data members; 262 newth2p.fFloat = fFloat;; 263 newth2p.fNewBinAdded = fNewBinAdded;; 264 newth2p.fBinContentChanged = fBinContentChanged;; 265}; 266 ; 267 ; 268////////////////////////////////////////////////////////////////////////////////; 269/// Create appropriate histogram bin.; 270/// e.g. TH2Poly creates TH2PolyBin,; 271/// TProfile2Poly creates TProfile2PolyBin; 272/// This is done so that TH2Poly::AddBin does not have to be duplicated,; 273/// but only create needs to be reimplemented for additional histogram types; 274 ; 275TH2PolyBin *TH2Poly::CreateBin(TObject *poly); 276{; 277 if (!poly) return nullptr;; 278 ; 279 if (fBins == nullptr) {; 280 fBins = new TList();; 281 fBins->SetOwner();; 282 }; 283 ; 284 fNcells++;; 285 Int_t ibin = fNcells - kNOverflow;; 286 // if structure fsumw2 is created extend it; 287 if (fSumw2.fN) fSumw2.Set(fNcells);; 288 return new TH2PolyBin(poly, ibin);; 289}; 290 ; 291////////////////////////////////////////////////////////////////////////////////; 292/// Adds a new bin to the histogram. It can be any object having the method; 293/// IsInside(). It returns the bin number in the histogram. It returns 0 if; 294/// it failed to add. To allow the histogram limits to expand when a bin; 295/// outside the limits is added, call SetFloat() before adding the bin.; 296 ; 297Int_t TH2Poly::AddBin(TObject *poly); 298{; 299 auto *bin = CreateBin(poly);; 300 Int_t ibin = fNcells-kNOverflow;; 301 if(!bin) return 0;; 302 ; 303 // If the bin lies outside histogram boundaries, then extends the boundaries.; 304 // Also c",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:12127,Modifiability,extend,extends,12127," duplicated,; 273/// but only create needs to be reimplemented for additional histogram types; 274 ; 275TH2PolyBin *TH2Poly::CreateBin(TObject *poly); 276{; 277 if (!poly) return nullptr;; 278 ; 279 if (fBins == nullptr) {; 280 fBins = new TList();; 281 fBins->SetOwner();; 282 }; 283 ; 284 fNcells++;; 285 Int_t ibin = fNcells - kNOverflow;; 286 // if structure fsumw2 is created extend it; 287 if (fSumw2.fN) fSumw2.Set(fNcells);; 288 return new TH2PolyBin(poly, ibin);; 289}; 290 ; 291////////////////////////////////////////////////////////////////////////////////; 292/// Adds a new bin to the histogram. It can be any object having the method; 293/// IsInside(). It returns the bin number in the histogram. It returns 0 if; 294/// it failed to add. To allow the histogram limits to expand when a bin; 295/// outside the limits is added, call SetFloat() before adding the bin.; 296 ; 297Int_t TH2Poly::AddBin(TObject *poly); 298{; 299 auto *bin = CreateBin(poly);; 300 Int_t ibin = fNcells-kNOverflow;; 301 if(!bin) return 0;; 302 ; 303 // If the bin lies outside histogram boundaries, then extends the boundaries.; 304 // Also changes the partition information accordingly; 305 Bool_t flag = kFALSE;; 306 if (fFloat) {; 307 if (fXaxis.GetXmin() > bin->GetXMin()) {; 308 fXaxis.Set(100, bin->GetXMin(), fXaxis.GetXmax());; 309 flag = kTRUE;; 310 }; 311 if (fXaxis.GetXmax() < bin->GetXMax()) {; 312 fXaxis.Set(100, fXaxis.GetXmin(), bin->GetXMax());; 313 flag = kTRUE;; 314 }; 315 if (fYaxis.GetXmin() > bin->GetYMin()) {; 316 fYaxis.Set(100, bin->GetYMin(), fYaxis.GetXmax());; 317 flag = kTRUE;; 318 }; 319 if (fYaxis.GetXmax() < bin->GetYMax()) {; 320 fYaxis.Set(100, fYaxis.GetXmin(), bin->GetYMax());; 321 flag = kTRUE;; 322 }; 323 if (flag) ChangePartition(fCellX, fCellY);; 324 } else {; 325 /*Implement polygon clipping code here*/; 326 }; 327 ; 328 fBins->Add((TObject*) bin);; 329 SetNewBinAdded(kTRUE);; 330 ; 331 // Adds the bin to the partition matrix; 332 AddBinToPartition(bin);; ",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:10272,Performance,optimiz,optimize,10272,"lete[] newth2p.fIsEmpty;; 229 delete[] newth2p.fCompletelyInside;; 230 // allocate arrays; 231 newth2p.fCells = new TList [fNCells];; 232 newth2p.fIsEmpty = new Bool_t [fNCells]; // Empty partition; 233 newth2p.fCompletelyInside = new Bool_t [fNCells]; // Cell is completely inside bin; 234 // Initializes the flags; 235 for (int i = 0; i<fNCells; i++) {; 236 newth2p.fIsEmpty[i] = fIsEmpty[i];; 237 newth2p.fCompletelyInside[i] = fCompletelyInside[i];; 238 }; 239 // need to use Clone to copy the contained bin list; 240 delete newth2p.fBins; // in case there was something before there; 241 if (!fBins) {; 242 newth2p.fBins = nullptr;; 243 }; 244 else {; 245 newth2p.fBins = dynamic_cast<TList *>(fBins->Clone());; 246 if (!newth2p.fBins); 247 Error(""Copy"",""Error cloning the TH2Poly bin list"");; 248 else {; 249 // add bins in the fCells partition. We need to add the TH2PolyBin objects; 250 // of the new copied histograms. For this we call AddBinToPartition; 251 // we could probably optimize this by implementing a copy of the partition; 252 for (auto bin : *(newth2p.fBins)) {; 253 newth2p.AddBinToPartition(dynamic_cast<TH2PolyBin*>(bin));; 254 }; 255 }; 256 }; 257 // copy overflow contents; 258 for(int i = 0; i < kNOverflow; i++ ) {; 259 newth2p.fOverflow[i] = fOverflow[i];; 260 }; 261 // copy other data members; 262 newth2p.fFloat = fFloat;; 263 newth2p.fNewBinAdded = fNewBinAdded;; 264 newth2p.fBinContentChanged = fBinContentChanged;; 265}; 266 ; 267 ; 268////////////////////////////////////////////////////////////////////////////////; 269/// Create appropriate histogram bin.; 270/// e.g. TH2Poly creates TH2PolyBin,; 271/// TProfile2Poly creates TProfile2PolyBin; 272/// This is done so that TH2Poly::AddBin does not have to be duplicated,; 273/// but only create needs to be reimplemented for additional histogram types; 274 ; 275TH2PolyBin *TH2Poly::CreateBin(TObject *poly); 276{; 277 if (!poly) return nullptr;; 278 ; 279 if (fBins == nullptr) {; 280 fBins = new TList();; 281",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:5815,Safety,avoid,avoid,5815,"ins intersecting it.; 115When a coordinate is to be filled, the method finds which cell the coordinate; 116falls into. Since the cells are rectangular, this can be done very quickly.; 117It then only loops over the bins associated with that cell and calls `IsInside()`; 118only on that bins. This reduces considerably the number of bins on which `IsInside()`; 119is called and therefore speed up by a huge factor the filling compare to the brute force; 120approach where `IsInside()` is called for all bins.; 121 ; 122The addition of bins to the appropriate cells is done when the bin is added; 123to the histogram. To do this, `AddBin()` calls the; 124`AddBinToPartition()` method.; 125This method adds the input bin to the partitioning matrix.; 126 ; 127The number of partition cells per axis can be specified in the constructor.; 128If it is not specified, the default value of 25 along each axis will be; 129assigned. This value was chosen because it is small enough to avoid slowing; 130down AddBin(), while being large enough to enhance Fill() by a considerable; 131amount. Regardless of how it is initialized at construction time, it can be; 132changed later with the `ChangePartition()` method.; 133`ChangePartition()` deletes the; 134old partition matrix and generates a new one with the specified number of cells; 135on each axis.; 136 ; 137The optimum number of partition cells per axis changes with the number of; 138times `Fill()` will be called. Although partitioning greatly speeds up; 139filling, it also adds a constant time delay into the code. When `Fill()`; 140is to be called many times, it is more efficient to divide the histogram into; 141a large number cells. However, if the histogram is to be filled only a few; 142times, it is better to divide into a small number of cells.; 143*/; 144 ; 145////////////////////////////////////////////////////////////////////////////////; 146/// Default Constructor. No boundaries specified.; 147 ; 148TH2Poly::TH2Poly(); 149{; 150 Initia",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:15296,Safety,risk,risks,15296,"76 ; 377 // Check if the bins are the same.; 378 TList *h1pBins = h1p->GetBins();; 379 TH2PolyBin *thisBin, *h1pBin;; 380 for (bin = 1; bin <= GetNumberOfBins(); bin++) {; 381 thisBin = (TH2PolyBin *)fBins->At(bin - 1);; 382 h1pBin = (TH2PolyBin *)h1pBins->At(bin - 1);; 383 if (thisBin->GetXMin() != h1pBin->GetXMin() ||; 384 thisBin->GetXMax() != h1pBin->GetXMax() ||; 385 thisBin->GetYMin() != h1pBin->GetYMin() ||; 386 thisBin->GetYMax() != h1pBin->GetYMax()) {; 387 Error(""Add"", ""Attempt to add histograms with different bin limits"");; 388 return kFALSE;; 389 }; 390 }; 391 ; 392 ; 393 // Create Sumw2 if h1p has Sumw2 set; 394 if (fSumw2.fN == 0 && h1p->GetSumw2N() != 0) Sumw2();; 395 ; 396 // statistics can be preserved only in case of positive coefficients; 397 // otherwise with negative c1 (histogram subtraction) one risks to get negative variances; 398 Bool_t resetStats = (c1 < 0);; 399 Double_t s1[kNstat] = {0};; 400 Double_t s2[kNstat] = {0};; 401 if (!resetStats) {; 402 // need to initialize to zero s1 and s2 since; 403 // GetStats fills only used elements depending on dimension and type; 404 GetStats(s1);; 405 h1->GetStats(s2);; 406 }; 407 // get number of entries now because afterwards UpdateBinContent will change it; 408 Double_t entries = TMath::Abs( GetEntries() + c1 * h1->GetEntries() );; 409 ; 410 ; 411 // Perform the Add.; 412 Double_t factor = 1;; 413 if (h1p->GetNormFactor() != 0); 414 factor = h1p->GetNormFactor() / h1p->GetSumOfWeights();; 415 for (bin = 0; bin < fNcells; bin++) {; 416 Double_t y = this->RetrieveBinContent(bin) + c1 * h1p->RetrieveBinContent(bin);; 417 UpdateBinContent(bin, y);; 418 if (fSumw2.fN) {; 419 Double_t esq = factor * factor * h1p->GetBinErrorSqUnchecked(bin);; 420 fSumw2.fArray[bin] += c1 * c1 * factor * factor * esq;; 421 }; 422 }; 423 ; 424 // update statistics (do here to avoid changes by SetBinContent); 425 if (resetStats) {; 426 // statistics need to be reset in case coefficient are negative; 427 ResetStats();; 428 }",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:16317,Safety,avoid,avoid,16317,"s fills only used elements depending on dimension and type; 404 GetStats(s1);; 405 h1->GetStats(s2);; 406 }; 407 // get number of entries now because afterwards UpdateBinContent will change it; 408 Double_t entries = TMath::Abs( GetEntries() + c1 * h1->GetEntries() );; 409 ; 410 ; 411 // Perform the Add.; 412 Double_t factor = 1;; 413 if (h1p->GetNormFactor() != 0); 414 factor = h1p->GetNormFactor() / h1p->GetSumOfWeights();; 415 for (bin = 0; bin < fNcells; bin++) {; 416 Double_t y = this->RetrieveBinContent(bin) + c1 * h1p->RetrieveBinContent(bin);; 417 UpdateBinContent(bin, y);; 418 if (fSumw2.fN) {; 419 Double_t esq = factor * factor * h1p->GetBinErrorSqUnchecked(bin);; 420 fSumw2.fArray[bin] += c1 * c1 * factor * factor * esq;; 421 }; 422 }; 423 ; 424 // update statistics (do here to avoid changes by SetBinContent); 425 if (resetStats) {; 426 // statistics need to be reset in case coefficient are negative; 427 ResetStats();; 428 } else {; 429 for (Int_t i = 0; i < kNstat; i++) {; 430 if (i == 1) s1[i] += c1 * c1 * s2[i];; 431 else s1[i] += c1 * s2[i];; 432 }; 433 PutStats(s1);; 434 SetEntries(entries);; 435 }; 436 return kTRUE;; 437}; 438 ; 439////////////////////////////////////////////////////////////////////////////////; 440/// Adds the input bin into the partition cell matrix. This method is called; 441/// in AddBin() and ChangePartition().; 442 ; 443void TH2Poly::AddBinToPartition(TH2PolyBin *bin); 444{; 445 // Cell Info; 446 Int_t nl, nr, mb, mt; // Max/min indices of the cells that contain the bin; 447 Double_t xclipl, xclipr, yclipb, yclipt; // x and y coordinates of a cell; 448 Double_t binXmax, binXmin, binYmax, binYmin; // The max/min bin coordinates; 449 ; 450 binXmax = bin->GetXMax();; 451 binXmin = bin->GetXMin();; 452 binYmax = bin->GetYMax();; 453 binYmin = bin->GetYMin();; 454 nl = (Int_t)(floor((binXmin - fXaxis.GetXmin())/fStepX));; 455 nr = (Int_t)(floor((binXmax - fXaxis.GetXmin())/fStepX));; 456 mb = (Int_t)(floor((binYmin - fYaxis.GetXmin",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:21210,Safety,safe,safe,21210,"is.GetXmin())/fCellX;; 528 fStepY = (fYaxis.GetXmax() - fYaxis.GetXmin())/fCellY;; 529 ; 530 delete [] fIsEmpty;; 531 delete [] fCompletelyInside;; 532 fIsEmpty = new Bool_t [fNCells];; 533 fCompletelyInside = new Bool_t [fNCells];; 534 ; 535 // Initializes the flags; 536 for (int i = 0; i<fNCells; i++) {; 537 fIsEmpty[i] = kTRUE;; 538 fCompletelyInside[i] = kFALSE;; 539 }; 540 ; 541 // TList iterator; 542 TIter next(fBins);; 543 TObject *obj;; 544 ; 545 while((obj = next())){ // Loop over bins and add them to the partition; 546 AddBinToPartition((TH2PolyBin*) obj);; 547 }; 548}; 549 ; 550////////////////////////////////////////////////////////////////////////////////; 551/// Make a complete copy of the underlying object. If 'newname' is set,; 552/// the copy's name will be set to that name.; 553 ; 554TObject* TH2Poly::Clone(const char* newname) const; 555{; 556 // TH1::Clone relies on ::Copy to implemented by the derived class.; 557 // Until this is implemented, revert to the much slower default version; 558 // (and possibly non-thread safe).; 559 ; 560 return TNamed::Clone(newname);; 561}; 562 ; 563////////////////////////////////////////////////////////////////////////////////; 564/// Clears the contents of all bins in the histogram.; 565 ; 566void TH2Poly::ClearBinContents(); 567{; 568 TIter next(fBins);; 569 TObject *obj;; 570 TH2PolyBin *bin;; 571 ; 572 // Clears the bin contents; 573 while ((obj = next())) {; 574 bin = (TH2PolyBin*) obj;; 575 bin->ClearContent();; 576 }; 577 ; 578 // Clears the statistics; 579 fTsumw = 0;; 580 fTsumw2 = 0;; 581 fTsumwx = 0;; 582 fTsumwx2 = 0;; 583 fTsumwy = 0;; 584 fTsumwy2 = 0;; 585 fEntries = 0;; 586}; 587 ; 588////////////////////////////////////////////////////////////////////////////////; 589/// Reset this histogram: contents, errors, etc.; 590 ; 591void TH2Poly::Reset(Option_t *opt); 592{; 593 TIter next(fBins);; 594 TObject *obj;; 595 TH2PolyBin *bin;; 596 ; 597 // Clears the bin contents; 598 while ((obj = next())) {; ",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:46287,Safety,safe,safer,46287," 1314 ; 1315////////////////////////////////////////////////////////////////////////////////; 1316/// Merge TH2Polys; 1317/// Given the special nature of the TH2Poly, the merge is implemented in; 1318/// terms of subsequent TH2Poly::Add calls.; 1319Long64_t TH2Poly::Merge(TCollection *coll); 1320{; 1321 for (auto h2pAsObj : *coll) {; 1322 if (!Add((TH1*)h2pAsObj, 1.)) {; 1323 Warning(""Merge"", ""An issue was encountered during the merge operation."");; 1324 return 0L;; 1325 }; 1326 }; 1327 return GetEntries();; 1328}; 1329 ; 1330////////////////////////////////////////////////////////////////////////////////; 1331/// Save primitive as a C++ statement(s) on output stream out; 1332 ; 1333void TH2Poly::SavePrimitive(std::ostream &out, Option_t *option); 1334{; 1335 out <<"" ""<<std::endl;; 1336 out <<"" ""<< ClassName() <<"" *"";; 1337 ; 1338 //histogram pointer has by default the histogram name.; 1339 //however, in case histogram has no directory, it is safer to add a; 1340 //incremental suffix; 1341 static Int_t hcounter = 0;; 1342 TString histName = GetName();; 1343 if (!fDirectory && !histName.Contains(""Graph"")) {; 1344 hcounter++;; 1345 histName += ""__"";; 1346 histName += hcounter;; 1347 }; 1348 ; 1349 TString hname = gInterpreter->MapCppName(histName.Data());; 1350 ; 1351 //Construct the class initialization; 1352 out << hname << "" = new "" << ClassName() << ""(\"""" << hname << ""\"", \""""; 1353 << GetTitle() << ""\"", "" << fCellX << "", "" << fXaxis.GetXmin(); 1354 << "", "" << fXaxis.GetXmax(); 1355 << "", "" << fCellY << "", "" << fYaxis.GetXmin() << "", ""; 1356 << fYaxis.GetXmax() << "");"" << std::endl;; 1357 ; 1358 // Save Bins; 1359 TIter next(fBins);; 1360 TObject *obj;; 1361 TH2PolyBin *th2pBin;; 1362 ; 1363 while((obj = next())){; 1364 th2pBin = (TH2PolyBin*) obj;; 1365 th2pBin->GetPolygon()->SavePrimitive(out, TString::Format(""th2poly%s"",hname.Data()));; 1366 }; 1367 ; 1368 // save bin contents; 1369 out<<"" ""<<std::endl;; 1370 Int_t bin;; 1371 for (bin=1;bin<=GetNumberOfBins();bi",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:56309,Safety,avoid,avoid,56309,,MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:26558,Testability,assert,assert,26558," coordinates belong to; 700 Int_t n = (Int_t)(floor((x-fXaxis.GetXmin())/fStepX));; 701 Int_t m = (Int_t)(floor((y-fYaxis.GetXmin())/fStepY));; 702 ; 703 // Make sure the array indices are correct.; 704 if (n>=fCellX) n = fCellX-1;; 705 if (m>=fCellY) m = fCellY-1;; 706 if (n<0) n = 0;; 707 if (m<0) m = 0;; 708 ; 709 if (fIsEmpty[n+fCellX*m]) {; 710 fOverflow[4]+= w;; 711 if (fSumw2.fN) fSumw2.fArray[4] += w*w;; 712 return -5;; 713 }; 714 ; 715 TH2PolyBin *bin;; 716 Int_t bi;; 717 ; 718 TIter next(&fCells[n+fCellX*m]);; 719 TObject *obj;; 720 ; 721 while ((obj=next())) {; 722 bin = (TH2PolyBin*)obj;; 723 // needs to account offset in array for overflow bins; 724 bi = bin->GetBinNumber()-1+kNOverflow;; 725 if (bin->IsInside(x,y)) {; 726 bin->Fill(w);; 727 ; 728 // Statistics; 729 fTsumw = fTsumw + w;; 730 fTsumw2 = fTsumw2 + w*w;; 731 fTsumwx = fTsumwx + w*x;; 732 fTsumwx2 = fTsumwx2 + w*x*x;; 733 fTsumwy = fTsumwy + w*y;; 734 fTsumwy2 = fTsumwy2 + w*y*y;; 735 if (fSumw2.fN) {; 736 assert(bi < fSumw2.fN);; 737 fSumw2.fArray[bi] += w*w;; 738 }; 739 fEntries++;; 740 ; 741 SetBinContentChanged(kTRUE);; 742 ; 743 return bin->GetBinNumber();; 744 }; 745 }; 746 ; 747 fOverflow[4]+= w;; 748 if (fSumw2.fN) fSumw2.fArray[4] += w*w;; 749 return -5;; 750}; 751 ; 752////////////////////////////////////////////////////////////////////////////////; 753/// Increment the bin named ""name"" by w.; 754 ; 755Int_t TH2Poly::Fill(const char* name, Double_t w); 756{; 757 TString sname(name);; 758 ; 759 TIter next(fBins);; 760 TObject *obj;; 761 TH2PolyBin *bin;; 762 ; 763 while ((obj = next())) {; 764 bin = (TH2PolyBin*) obj;; 765 if (!sname.CompareTo(bin->GetPolygon()->GetName())) {; 766 bin->Fill(w);; 767 fEntries++;; 768 SetBinContentChanged(kTRUE);; 769 return bin->GetBinNumber();; 770 }; 771 }; 772 ; 773 return 0;; 774}; 775 ; 776////////////////////////////////////////////////////////////////////////////////; 777/// Fills a 2-D histogram with an array of values and weights.; 778///; 7",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:1186,Usability,simpl,simple,1186,"niz Gunceler, Danilo Piparo; 4 ; 5/*************************************************************************; 6 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 7 * All rights reserved. *; 8 * *; 9 * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 *************************************************************************/; 12 ; 13#include ""TH2Poly.h""; 14#include ""TMultiGraph.h""; 15#include ""TGraph.h""; 16#include ""TInterpreter.h""; 17#include ""Riostream.h""; 18#include ""TList.h""; 19#include ""TMath.h""; 20#include <cassert>; 21 ; 22ClassImp(TH2Poly);; 23 ; 24/** \class TH2Poly; 25 \ingroup Histograms; 262D Histogram with Polygonal Bins; 27 ; 28## Overview; 29`TH2Poly` is a 2D Histogram class (TH2) allowing to define polygonal; 30bins of arbitrary shape.; 31 ; 32Each bin in the `TH2Poly` histogram is a `TH2PolyBin` object.; 33`TH2PolyBin` is a very simple class containing the vertices (stored; 34as `TGraph`s or `TMultiGraph`s ) and contents of the polygonal; 35bin as well as several related functions.; 36 ; 37Essentially, a `TH2Poly` is a TList of `TH2PolyBin` objects; 38with methods to manipulate them.; 39 ; 40Bins are defined using one of the `AddBin()` methods. The bin definition; 41should be done before filling.; 42 ; 43The histogram can be filled with `Fill(Double_t x, Double_t y, Double_t w); 44`. `w` is the weight.; 45If no weight is specified, it is assumed to be 1.; 46 ; 47Not all histogram's area need to be binned. Filling an area without bins,; 48will falls into the overflows. Adding a bin is not retroactive; it doesn't; 49affect previous fillings. A `Fill()` call, that; 50was previously ignored due to the lack of a bin at the specified location, is; 51not reconsidered when that location is binned later.; 52 ; 53If there are two overlapping bins, the first one in the list will be incremented; 54by `Fill()`.; 55 ; 56The histogram may automatically extends its limits if a bin outside",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8cxx_source.html:3513,Usability,simpl,simple,3513,"thm to speed up bins' filling; 62(see the ""Partitioning Algorithm"" section for details).; 63The partitioning algorithm divides the histogram into regions called cells.; 64The bins that each cell intersects are recorded in an array of `TList`s.; 65When a coordinate in the histogram is to be filled; the method (quickly) finds; 66which cell the coordinate belongs. It then only loops over the bins; 67intersecting that cell to find the bin the input coordinate corresponds to.; 68The partitioning of the histogram is updated continuously as each bin is added.; 69The default number of cells on each axis is 25. This number could be set to; 70another value in the constructor or adjusted later by calling the; 71`ChangePartition(Int_t, Int_t)` method. The partitioning algorithm is; 72considerably faster than the brute force algorithm (i.e. checking if each bin; 73contains the input coordinates), especially if the histogram is to be filled; 74many times.; 75 ; 76The following very simple macro shows how to build and fill a `TH2Poly`:; 77~~~ {.cpp}; 78{; 79 auto h2p = new TH2Poly();; 80 ; 81 Double_t x1[] = {0, 5, 6};; 82 Double_t y1[] = {0, 0, 5};; 83 Double_t x2[] = {0, -1, -1, 0};; 84 Double_t y2[] = {0, 0, -1, 3};; 85 Double_t x3[] = {4, 3, 0, 1, 2.4};; 86 Double_t y3[] = {4, 3.7, 1, 3.7, 2.5};; 87 ; 88 h2p->AddBin(3, x1, y1);; 89 h2p->AddBin(4, x2, y2);; 90 h2p->AddBin(5, x3, y3);; 91 ; 92 h2p->Fill(0.1, 0.01, 3);; 93 h2p->Fill(-0.5, -0.5, 7);; 94 h2p->Fill(-0.7, -0.5, 1);; 95 h2p->Fill(1, 3, 1.5);; 96}; 97~~~; 98 ; 99More examples can be found in th2polyBoxes.C, th2polyEurope.C, th2polyHoneycomb.C; 100and th2polyUSA.C.; 101 ; 102## Partitioning Algorithm; 103The partitioning algorithm forms an essential part of the `TH2Poly`; 104class. It is implemented to speed up the filling of bins.; 105 ; 106With the brute force approach, the filling is done in the following way: An; 107iterator loops over all bins in the `TH2Poly` and invokes the; 108method `IsInside()` for each of them",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
https://root.cern/doc/master/TH2Poly_8h_source.html:5284,Availability,error,error,5284,"return fBinContentChanged;}; 104 Double_t GetBinError(Int_t bin) const override;; 105 const char *GetBinName(Int_t bin) const;; 106 const char *GetBinTitle(Int_t bin) const;; 107 Bool_t GetFloat(){return fFloat;}; 108 Double_t GetMaximum() const;; 109 Double_t GetMaximum(Double_t maxval) const override;; 110 Double_t GetMinimum() const;; 111 Double_t GetMinimum(Double_t minval) const override;; 112 Bool_t GetNewBinAdded() const{return fNewBinAdded;}; 113 Int_t GetNumberOfBins() const;; 114 void Honeycomb(Double_t xstart, Double_t ystart, Double_t a, Int_t k, Int_t s, Option_t* option = ""v"");; 115 Double_t Integral(Option_t* option = """") const override;; 116 Long64_t Merge(TCollection *) override;; 117 void Reset(Option_t *option) override;; 118 void Scale(Double_t c1 = 1, Option_t* option = """") override;; 119 void SavePrimitive(std::ostream& out, Option_t* option = """") override;; 120 void SetBinContent(Int_t bin, Double_t content) override;; 121 void SetBinError(Int_t bin, Double_t error) override;; 122 void SetBinContentChanged(Bool_t flag){fBinContentChanged = flag;}; 123 void SetFloat(Bool_t flag = true);; 124 void SetNewBinAdded(Bool_t flag){fNewBinAdded = flag;}; 125 Bool_t IsInsideBin(Int_t binnr, Double_t x, Double_t y);; 126 void GetStats(Double_t *stats) const override;; 127 ; 128 ; 129protected:; 130 ; 131 //functions not to be used for TH2Poly; 132 ; 133 Int_t Fill(Double_t) override{return -1;} ///< NOT IMPLEMENTED for TH2Poly; 134 Int_t Fill(Double_t , const char *, Double_t) override{return -1;} ///< NOT IMPLEMENTED for TH2Poly; 135 Int_t Fill(const char *, Double_t , Double_t ) override{return -1;} ///< NOT IMPLEMENTED for TH2Poly; 136 Int_t Fill(const char *, const char *, Double_t ) override{return -1;} ///< NOT IMPLEMENTED for TH2Poly; 137 void FillN(Int_t, const Double_t*, const Double_t*, Int_t) override{return;} ///< NOT IMPLEMENTED for TH2Poly; 138 ; 139 Double_t Integral(Int_t, Int_t, const Option_t*) const override{return 0;} ///< NOT IMPLEME",MatchSource.WIKI,doc/master/TH2Poly_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8h_source.html
https://root.cern/doc/master/TH2Poly_8h_source.html:10901,Availability,error,errors,10901,"ion Rtypes.h:346; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; x1Option_t Option_t TPoint TPoint const char x1Definition TGWin32VirtualXProxy.cxx:70; y2Option_t Option_t TPoint TPoint const char y2Definition TGWin32VirtualXProxy.cxx:70; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; namechar name[80]Definition TGX11.cxx:110; TH2.h; TCollectionCollection abstract base class.Definition TCollection.h:65; TF11-Dim function classDefinition TF1.h:233; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::Multiplyvirtual Bool_t Multiply(TF1 *f1, Double_t c1=1)Performs the operation:Definition TH1.cxx:6049; TH1::Dividevirtual Bool_t Divide(TF1 *f1, Double_t c1=1)Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:2840; TH2PolyBinHelper class to represent a bin in the TH2Poly histogram.Definition TH2Poly.h:25; TH2PolyBin::GetXMinDouble_t GetXMin()Returns the minimum value for the x coordinates of the bin.Definition TH2Poly.cxx:1565; TH2PolyBin::GetChangedBool_t GetChanged() constDefinition TH2Poly.h:36; TH2PolyBin::~TH2PolyBin~TH2PolyBin() overrideDestructor.Definition TH2Poly.cxx:1491; TH2PolyBin::GetYMaxDouble_t GetYMax()Returns the maximum value for the y coordinates of the bin.Definition TH2Poly.cxx:1601; TH2PolyBin::GetAreaDouble_t GetArea()Returns the area of the bin.Definition TH2Poly.cxx:1499; TH2PolyBin::ClearContentvoid ClearContent()Definition TH2Poly.h:32; TH2PolyBin::Fillvoid Fill(Double_t w)Definition TH2Poly.h:33; TH2PolyBin::GetYMinDouble_t GetYMin()Returns the minimum value for the y coordinates of the bin.Definition TH2Poly.cxx:1637; TH2PolyBin::fAreaDouble_t fAreaBin area.Definition",MatchSource.WIKI,doc/master/TH2Poly_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8h_source.html
https://root.cern/doc/master/TH2Poly_8h_source.html:17712,Availability,error,error,17712,"Changedvoid SetBinContentChanged(Bool_t flag)Definition TH2Poly.h:122; TH2Poly::GetStatsvoid GetStats(Double_t *stats) const overrideFill the array stats from the contents of this histogram The array stats must be correctly dimensione...Definition TH2Poly.cxx:1440; TH2Poly::fCompletelyInsideBool_t * fCompletelyInside[fNCells] The array that returns true if the cell at the given coordinate is completely inside a binDefinition TH2Poly.h:166; TH2Poly::GetFloatBool_t GetFloat()Definition TH2Poly.h:107; TH2Poly::TH2PolyTH2Poly()Default Constructor. No boundaries specified.Definition TH2Poly.cxx:148; TH2Poly::IsInsideBinBool_t IsInsideBin(Int_t binnr, Double_t x, Double_t y)Return ""true"" if the point (x,y) is inside the bin of binnr.Definition TH2Poly.cxx:1432; TH2Poly::fNewBinAddedBool_t fNewBinAdded!For the 3D PainterDefinition TH2Poly.h:168; TH2Poly::Copyvoid Copy(TObject &newth2p) const overrideCopy function for TH2Poly.Definition TH2Poly.cxx:212; TH2Poly::SetBinErrorvoid SetBinError(Int_t bin, Double_t error) overrideSet the bin Error.Definition TH2Poly.cxx:893; TH2Poly::GetBinTitleconst char * GetBinTitle(Int_t bin) constReturns the bin title.Definition TH2Poly.cxx:918; TH2Poly::SetBinContentvoid SetBinContent(Int_t, Int_t, Int_t, Double_t) overrideNOT IMPLEMENTED for TH2Poly.Definition TH2Poly.h:150; TH2Poly::SetBinErrorvoid SetBinError(Int_t, Int_t, Double_t) overrideNOT IMPLEMENTED for TH2Poly.Definition TH2Poly.h:151; TH2Poly::SetNewBinAddedvoid SetNewBinAdded(Bool_t flag)Definition TH2Poly.h:124; TH2Poly::Scalevoid Scale(Double_t c1=1, Option_t *option="""") overrideMultiply this histogram by a constant c1.Definition TH2Poly.cxx:1393; TH2Poly::ChangePartitionvoid ChangePartition(Int_t n, Int_t m)Changes the number of partition cells in the histogram.Definition TH2Poly.cxx:515; TH2Poly::IntegralDouble_t Integral(Int_t, Int_t, Int_t, Int_t, Int_t, Int_t, const Option_t *) const overrideNOT IMPLEMENTED for TH2Poly.Definition TH2Poly.h:141; TH2Poly::FillNvoid FillN(In",MatchSource.WIKI,doc/master/TH2Poly_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8h_source.html
https://root.cern/doc/master/TH2Poly_8h_source.html:20682,Availability,error,error,20682,"lete copy of the underlying object.Definition TH2Poly.cxx:554; TH2Poly::fNCellsInt_t fNCellsNumber of partition cells: fCellX*fCellY.Definition TH2Poly.h:162; TH2Poly::FindBinInt_t FindBin(Double_t x, Double_t y, Double_t z=0) overrideReturns the bin number of the bin at the given coordinate.Definition TH2Poly.cxx:621; TH2Poly::DivideBool_t Divide(TF1 *, Double_t) overrideNOT IMPLEMENTED for TH2Poly.Definition TH2Poly.cxx:1713; TH2Poly::Initializevoid Initialize(Double_t xlow, Double_t xup, Double_t ylow, Double_t yup, Int_t n, Int_t m)Initializes the TH2Poly object. This method is called by the constructor.Definition TH2Poly.cxx:1113; TH2Poly::fCellXInt_t fCellXNumber of partition cells in the x-direction of the histogram.Definition TH2Poly.h:160; TH2Poly::~TH2Poly~TH2Poly() overrideDestructor.Definition TH2Poly.cxx:192; TH2Poly::AddBinvirtual Int_t AddBin(TObject *poly)Adds a new bin to the histogram.Definition TH2Poly.cxx:297; TH2Poly::GetBinErrorDouble_t GetBinError(Int_t bin) const overrideReturns the value of error associated to bin number bin.Definition TH2Poly.cxx:856; TH2Poly::IsIntersectingPolygonBool_t IsIntersectingPolygon(Int_t bn, Double_t *x, Double_t *y, Double_t xclipl, Double_t xclipr, Double_t yclipb, Double_t yclipt)Returns kTRUE if the input polygon (bn, x, y) is intersecting with the input rectangle (xclipl,...Definition TH2Poly.cxx:1205; TH2Poly::AddBool_t Add(const TH1 *h1, Double_t c1) overridePerforms the operation: this = this + c1*h1.Definition TH2Poly.cxx:365; TH2Poly::IntegralDouble_t Integral(Int_t, Int_t, const Option_t *) const overrideNOT IMPLEMENTED for TH2Poly.Definition TH2Poly.h:139; TH2Poly::GetAsymmetryvirtual TH1 * GetAsymmetry(TH1 *, Double_t, Double_t)NOT IMPLEMENTED for TH2Poly.Definition TH2Poly.cxx:1742; TH2Poly::Honeycombvoid Honeycomb(Double_t xstart, Double_t ystart, Double_t a, Int_t k, Int_t s, Option_t *option=""v"")Bins the histogram using a honeycomb structure If the option ""v"" is specified, the hexagons are drawn..",MatchSource.WIKI,doc/master/TH2Poly_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8h_source.html
https://root.cern/doc/master/TH2Poly_8h_source.html:22408,Availability,error,errors,22408,"ble_t)NOT IMPLEMENTED for TH2Poly.Definition TH2Poly.cxx:1742; TH2Poly::Honeycombvoid Honeycomb(Double_t xstart, Double_t ystart, Double_t a, Int_t k, Int_t s, Option_t *option=""v"")Bins the histogram using a honeycomb structure If the option ""v"" is specified, the hexagons are drawn...Definition TH2Poly.cxx:1026; TH2Poly::GetBinErrorDouble_t GetBinError(Int_t, Int_t, Int_t) const overrideNOT IMPLEMENTED for TH2Poly.Definition TH2Poly.h:147; TH2Poly::MergeLong64_t Merge(TCollection *) overrideMerge TH2Polys Given the special nature of the TH2Poly, the merge is implemented in terms of subseque...Definition TH2Poly.cxx:1319; TH2Poly::SetBinContentvoid SetBinContent(Int_t bin, Double_t content) overrideSets the contents of the input bin to the input content Negative values between -1 and -9 are for the...Definition TH2Poly.cxx:1407; TH2Poly::GetMaximumDouble_t GetMaximum() constReturns the maximum value of the histogram.Definition TH2Poly.cxx:928; TH2Poly::Resetvoid Reset(Option_t *option) overrideReset this histogram: contents, errors, etc.Definition TH2Poly.cxx:591; TH2Poly::GetNewBinAddedBool_t GetNewBinAdded() constDefinition TH2Poly.h:112; TH2Poly::FillInt_t Fill(const char *, const char *, Double_t) overrideNOT IMPLEMENTED for TH2Poly.Definition TH2Poly.h:136; TH2Poly::GetBinContentDouble_t GetBinContent(Int_t, Int_t, Int_t) const overrideNOT IMPLEMENTED for TH2Poly.Definition TH2Poly.h:144; TH2Poly::fStepYDouble_t fStepYDimensions of a partition cell.Definition TH2Poly.h:164; TH2Poly::SetBinContentvoid SetBinContent(Int_t, Int_t, Double_t) overrideNOT IMPLEMENTED for TH2Poly.Definition TH2Poly.h:149; TH2Poly::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TH2Poly.cxx:1333; TH2Poly::FFTTH1 * FFT(TH1 *, Option_t *) overrideNOT IMPLEMENTED for TH2Poly.Definition TH2Poly.cxx:1735; TH2Poly::FillInt_t Fill(Double_t, const char *, Double_t) overrideNOT IMPLEMENTED for TH",MatchSource.WIKI,doc/master/TH2Poly_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8h_source.html
https://root.cern/doc/master/TH2Poly_8h_source.html:13503,Deployability,update,update,13503,"n::GetXMaxDouble_t GetXMax()Returns the maximum value for the x coordinates of the bin.Definition TH2Poly.cxx:1529; TH2PolyBin::GetContentDouble_t GetContent() constDefinition TH2Poly.h:35; TH2PolyBin::fYminDouble_t fYminY minimum value.Definition TH2Poly.h:54; TH2PolyBin::SetChangedvoid SetChanged(Bool_t flag)Definition TH2Poly.h:44; TH2PolyBin::GetBinNumberInt_t GetBinNumber() constDefinition TH2Poly.h:37; TH2PolyBin::fXminDouble_t fXminX minimum value.Definition TH2Poly.h:53; TH2PolyBin::GetPolygonTObject * GetPolygon() constDefinition TH2Poly.h:38; TH2PolyBin::fPolyTObject * fPolyObject holding the polygon definition.Definition TH2Poly.h:50; TH2PolyBin::fChangedBool_t fChangedFor the 3D Painter.Definition TH2Poly.h:48; TH2Poly2D Histogram with Polygonal BinsDefinition TH2Poly.h:66; TH2Poly::MultiplyBool_t Multiply(TF1 *, Double_t) overrideNOT IMPLEMENTED for TH2Poly.Definition TH2Poly.cxx:1721; TH2Poly::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH2Poly.h:180; TH2Poly::GetBinErrorDouble_t GetBinError(Int_t, Int_t) const overrideNOT IMPLEMENTED for TH2Poly.Definition TH2Poly.h:146; TH2Poly::operator=TH2Poly & operator=(const TH2Poly &rhs)Assignment operator.Definition TH2Poly.cxx:203; TH2Poly::GetBinsTList * GetBins()Returns the TList of all bins in the histogram.Definition TH2Poly.h:101; TH2Poly::ClearBinContentsvoid ClearBinContents()Clears the contents of all bins in the histogram.Definition TH2Poly.cxx:566; TH2Poly::fOverflowDouble_t fOverflow[kNOverflow]Overflow bins.Definition TH2Poly.h:159; TH2Poly::kNOverflow@ kNOverflowDefinition TH2Poly.h:157; TH2Poly::fFloatBool_t fFloatWhen set to kTRUE, allows the histogram to expand if a bin outside the limits is added.Definition TH2Poly.h:167; TH2Poly::FillInt_t Fill(const char *, Double_t, Double_t) overrideNOT IMPLEMENTED for TH2Poly.Definition TH2Poly.h:135; TH2Poly::",MatchSource.WIKI,doc/master/TH2Poly_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8h_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:22441,Availability,mask,mask,22441,"e of the sum of squares of; 546/// weights is automatically triggered and the sum of the squares of weights is incremented; 547/// by w^2 in the bin corresponding to namex,y; 548///; 549/// The function returns the corresponding global bin number which has its content; 550/// incremented by w; 551 ; 552Int_t TH2::Fill(const char *namex, Double_t y, Double_t w); 553{; 554 Int_t binx, biny, bin;; 555 fEntries++;; 556 binx = fXaxis.FindBin(namex);; 557 biny = fYaxis.FindBin(y);; 558 if (binx <0 || biny <0) return -1;; 559 bin = biny*(fXaxis.GetNbins()+2) + binx;; 560 if (!fSumw2.fN && w != 1.0 && !TestBit(TH1::kIsNotW)) Sumw2(); // must be called before AddBinContent; 561 if (fSumw2.fN) fSumw2.fArray[bin] += w*w;; 562 AddBinContent(bin,w);; 563 if (binx == 0 || binx > fXaxis.GetNbins()) return -1;; 564 if (biny == 0 || biny > fYaxis.GetNbins()) {; 565 if (!GetStatOverflowsBehaviour()) return -1;; 566 }; 567 Double_t z= w; //(w > 0 ? w : -w);; 568 fTsumw += z;; 569 fTsumw2 += z*z;; 570 fTsumwy += z*y;; 571 fTsumwy2 += z*y*y;; 572 // skip statistics along x axis, for only one axis no need to use bit mask from GetAxisLabelStatus; 573 if (!fXaxis.CanExtend() || !fXaxis.IsAlphanumeric()) {; 574 Double_t x = fXaxis.GetBinCenter(binx);; 575 fTsumwx += z * x;; 576 fTsumwx2 += z * x * x;; 577 fTsumwxy += z * x * y;; 578 }; 579 return bin;; 580}; 581 ; 582 ; 583////////////////////////////////////////////////////////////////////////////////; 584/// Increment cell defined by x,namey by a weight w; 585///; 586/// - if x or/and y is less than the low-edge of the corresponding axis first bin,; 587/// the Underflow cell is incremented.; 588/// - if x or/and y is equal to or greater than the upper edge of corresponding axis last bin,; 589/// the Overflow cell is incremented.; 590///; 591/// - If the weight is not equal to 1, the storage of the sum of squares of; 592/// weights is automatically triggered and the sum of the squares of weights is incremented; 593/// by w^2 in the bin cor",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:54291,Availability,error,error,54291,"),fYaxis.GetLast(),option);; 1321}; 1322 ; 1323 ; 1324////////////////////////////////////////////////////////////////////////////////; 1325/// Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin]; 1326/// for a 2-D histogram; 1327/// By default the integral is computed as the sum of bin contents in the range.; 1328/// if option ""width"" is specified, the integral is the sum of; 1329/// the bin contents multiplied by the bin width in x and in y.; 1330 ; 1331Double_t TH2::Integral(Int_t firstxbin, Int_t lastxbin, Int_t firstybin, Int_t lastybin, Option_t *option) const; 1332{; 1333 double err = 0;; 1334 return DoIntegral(firstxbin,lastxbin,firstybin,lastybin,-1,0,err,option);; 1335}; 1336 ; 1337////////////////////////////////////////////////////////////////////////////////; 1338/// Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin]; 1339/// for a 2-D histogram. Calculates also the integral error using error propagation; 1340/// from the bin errors assuming that all the bins are uncorrelated.; 1341/// By default the integral is computed as the sum of bin contents in the range.; 1342/// if option ""width"" is specified, the integral is the sum of; 1343/// the bin contents multiplied by the bin width in x and in y.; 1344 ; 1345Double_t TH2::IntegralAndError(Int_t firstxbin, Int_t lastxbin, Int_t firstybin, Int_t lastybin, Double_t & error, Option_t *option) const; 1346{; 1347 return DoIntegral(firstxbin,lastxbin,firstybin,lastybin,-1,0,error,option,kTRUE);; 1348}; 1349 ; 1350////////////////////////////////////////////////////////////////////////////////; 1351///illegal for a TH2; 1352 ; 1353Double_t TH2::Interpolate(Double_t) const; 1354{; 1355 Error(""Interpolate"",""This function must be called with 2 arguments for a TH2"");; 1356 return 0;; 1357}; 1358 ; 1359////////////////////////////////////////////////////////////////////////////////; 1360/// Given a point P(x,y), Interpolate approximates the value via bilin",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:54303,Availability,error,error,54303,"),fYaxis.GetLast(),option);; 1321}; 1322 ; 1323 ; 1324////////////////////////////////////////////////////////////////////////////////; 1325/// Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin]; 1326/// for a 2-D histogram; 1327/// By default the integral is computed as the sum of bin contents in the range.; 1328/// if option ""width"" is specified, the integral is the sum of; 1329/// the bin contents multiplied by the bin width in x and in y.; 1330 ; 1331Double_t TH2::Integral(Int_t firstxbin, Int_t lastxbin, Int_t firstybin, Int_t lastybin, Option_t *option) const; 1332{; 1333 double err = 0;; 1334 return DoIntegral(firstxbin,lastxbin,firstybin,lastybin,-1,0,err,option);; 1335}; 1336 ; 1337////////////////////////////////////////////////////////////////////////////////; 1338/// Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin]; 1339/// for a 2-D histogram. Calculates also the integral error using error propagation; 1340/// from the bin errors assuming that all the bins are uncorrelated.; 1341/// By default the integral is computed as the sum of bin contents in the range.; 1342/// if option ""width"" is specified, the integral is the sum of; 1343/// the bin contents multiplied by the bin width in x and in y.; 1344 ; 1345Double_t TH2::IntegralAndError(Int_t firstxbin, Int_t lastxbin, Int_t firstybin, Int_t lastybin, Double_t & error, Option_t *option) const; 1346{; 1347 return DoIntegral(firstxbin,lastxbin,firstybin,lastybin,-1,0,error,option,kTRUE);; 1348}; 1349 ; 1350////////////////////////////////////////////////////////////////////////////////; 1351///illegal for a TH2; 1352 ; 1353Double_t TH2::Interpolate(Double_t) const; 1354{; 1355 Error(""Interpolate"",""This function must be called with 2 arguments for a TH2"");; 1356 return 0;; 1357}; 1358 ; 1359////////////////////////////////////////////////////////////////////////////////; 1360/// Given a point P(x,y), Interpolate approximates the value via bilin",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:54343,Availability,error,errors,54343,"),fYaxis.GetLast(),option);; 1321}; 1322 ; 1323 ; 1324////////////////////////////////////////////////////////////////////////////////; 1325/// Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin]; 1326/// for a 2-D histogram; 1327/// By default the integral is computed as the sum of bin contents in the range.; 1328/// if option ""width"" is specified, the integral is the sum of; 1329/// the bin contents multiplied by the bin width in x and in y.; 1330 ; 1331Double_t TH2::Integral(Int_t firstxbin, Int_t lastxbin, Int_t firstybin, Int_t lastybin, Option_t *option) const; 1332{; 1333 double err = 0;; 1334 return DoIntegral(firstxbin,lastxbin,firstybin,lastybin,-1,0,err,option);; 1335}; 1336 ; 1337////////////////////////////////////////////////////////////////////////////////; 1338/// Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin]; 1339/// for a 2-D histogram. Calculates also the integral error using error propagation; 1340/// from the bin errors assuming that all the bins are uncorrelated.; 1341/// By default the integral is computed as the sum of bin contents in the range.; 1342/// if option ""width"" is specified, the integral is the sum of; 1343/// the bin contents multiplied by the bin width in x and in y.; 1344 ; 1345Double_t TH2::IntegralAndError(Int_t firstxbin, Int_t lastxbin, Int_t firstybin, Int_t lastybin, Double_t & error, Option_t *option) const; 1346{; 1347 return DoIntegral(firstxbin,lastxbin,firstybin,lastybin,-1,0,error,option,kTRUE);; 1348}; 1349 ; 1350////////////////////////////////////////////////////////////////////////////////; 1351///illegal for a TH2; 1352 ; 1353Double_t TH2::Interpolate(Double_t) const; 1354{; 1355 Error(""Interpolate"",""This function must be called with 2 arguments for a TH2"");; 1356 return 0;; 1357}; 1358 ; 1359////////////////////////////////////////////////////////////////////////////////; 1360/// Given a point P(x,y), Interpolate approximates the value via bilin",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:54738,Availability,error,error,54738,"////////////////////////////////////////////////////////////////////////////////; 1338/// Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin]; 1339/// for a 2-D histogram. Calculates also the integral error using error propagation; 1340/// from the bin errors assuming that all the bins are uncorrelated.; 1341/// By default the integral is computed as the sum of bin contents in the range.; 1342/// if option ""width"" is specified, the integral is the sum of; 1343/// the bin contents multiplied by the bin width in x and in y.; 1344 ; 1345Double_t TH2::IntegralAndError(Int_t firstxbin, Int_t lastxbin, Int_t firstybin, Int_t lastybin, Double_t & error, Option_t *option) const; 1346{; 1347 return DoIntegral(firstxbin,lastxbin,firstybin,lastybin,-1,0,error,option,kTRUE);; 1348}; 1349 ; 1350////////////////////////////////////////////////////////////////////////////////; 1351///illegal for a TH2; 1352 ; 1353Double_t TH2::Interpolate(Double_t) const; 1354{; 1355 Error(""Interpolate"",""This function must be called with 2 arguments for a TH2"");; 1356 return 0;; 1357}; 1358 ; 1359////////////////////////////////////////////////////////////////////////////////; 1360/// Given a point P(x,y), Interpolate approximates the value via bilinear; 1361/// interpolation based on the four nearest bin centers; 1362/// see Wikipedia, Bilinear Interpolation; 1363/// Andy Mastbaum 10/8/2008; 1364/// vaguely based on R.Raja 6-Sep-2008; 1365 ; 1366 Double_t TH2::Interpolate(Double_t x, Double_t y) const; 1367{; 1368 Double_t f=0;; 1369 Double_t x1=0,x2=0,y1=0,y2=0;; 1370 Double_t dx,dy;; 1371 Int_t bin_x = fXaxis.FindFixBin(x);; 1372 Int_t bin_y = fYaxis.FindFixBin(y);; 1373 if(bin_x<1 || bin_x>GetNbinsX() || bin_y<1 || bin_y>GetNbinsY()) {; 1374 Error(""Interpolate"",""Cannot interpolate outside histogram domain."");; 1375 return 0;; 1376 }; 1377 Int_t quadrant = 0; // CCW from UR 1,2,3,4; 1378 // which quadrant of the bin (bin_P) are we in?; 1379 dx = fXaxis.GetBinUpEdg",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:54843,Availability,error,error,54843,"////////////////////////////////////////////////////////////////////////////////; 1338/// Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin]; 1339/// for a 2-D histogram. Calculates also the integral error using error propagation; 1340/// from the bin errors assuming that all the bins are uncorrelated.; 1341/// By default the integral is computed as the sum of bin contents in the range.; 1342/// if option ""width"" is specified, the integral is the sum of; 1343/// the bin contents multiplied by the bin width in x and in y.; 1344 ; 1345Double_t TH2::IntegralAndError(Int_t firstxbin, Int_t lastxbin, Int_t firstybin, Int_t lastybin, Double_t & error, Option_t *option) const; 1346{; 1347 return DoIntegral(firstxbin,lastxbin,firstybin,lastybin,-1,0,error,option,kTRUE);; 1348}; 1349 ; 1350////////////////////////////////////////////////////////////////////////////////; 1351///illegal for a TH2; 1352 ; 1353Double_t TH2::Interpolate(Double_t) const; 1354{; 1355 Error(""Interpolate"",""This function must be called with 2 arguments for a TH2"");; 1356 return 0;; 1357}; 1358 ; 1359////////////////////////////////////////////////////////////////////////////////; 1360/// Given a point P(x,y), Interpolate approximates the value via bilinear; 1361/// interpolation based on the four nearest bin centers; 1362/// see Wikipedia, Bilinear Interpolation; 1363/// Andy Mastbaum 10/8/2008; 1364/// vaguely based on R.Raja 6-Sep-2008; 1365 ; 1366 Double_t TH2::Interpolate(Double_t x, Double_t y) const; 1367{; 1368 Double_t f=0;; 1369 Double_t x1=0,x2=0,y1=0,y2=0;; 1370 Double_t dx,dy;; 1371 Int_t bin_x = fXaxis.FindFixBin(x);; 1372 Int_t bin_y = fYaxis.FindFixBin(y);; 1373 if(bin_x<1 || bin_x>GetNbinsX() || bin_y<1 || bin_y>GetNbinsY()) {; 1374 Error(""Interpolate"",""Cannot interpolate outside histogram domain."");; 1375 return 0;; 1376 }; 1377 Int_t quadrant = 0; // CCW from UR 1,2,3,4; 1378 // which quadrant of the bin (bin_P) are we in?; 1379 dx = fXaxis.GetBinUpEdg",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:62543,Availability,error,errors,62543,"t_t ibeg = 1, jbeg = 1;; 1522 Int_t iend = ncx1, jend = ncy1;; 1523 if (opt.Contains(""U"")) {ibeg = 0; jbeg = 0;}; 1524 if (opt.Contains(""O"")) {iend = ncx1+1; jend = ncy1+1;}; 1525 ; 1526 Int_t i,j;; 1527 Double_t sum1 = 0;; 1528 Double_t sum2 = 0;; 1529 Double_t w1 = 0;; 1530 Double_t w2 = 0;; 1531 for (i = ibeg; i <= iend; i++) {; 1532 for (j = jbeg; j <= jend; j++) {; 1533 sum1 += h1->GetBinContent(i,j);; 1534 sum2 += h2->GetBinContent(i,j);; 1535 Double_t ew1 = h1->GetBinError(i,j);; 1536 Double_t ew2 = h2->GetBinError(i,j);; 1537 w1 += ew1*ew1;; 1538 w2 += ew2*ew2;; 1539 ; 1540 }; 1541 }; 1542 ; 1543 // Check that both scatterplots contain events; 1544 if (sum1 == 0) {; 1545 Error(""KolmogorovTest"",""Integral is zero for h1=%s\n"",h1->GetName());; 1546 return 0;; 1547 }; 1548 if (sum2 == 0) {; 1549 Error(""KolmogorovTest"",""Integral is zero for h2=%s\n"",h2->GetName());; 1550 return 0;; 1551 }; 1552 // calculate the effective entries.; 1553 // the case when errors are zero (w1 == 0 or w2 ==0) are equivalent to; 1554 // compare to a function. In that case the rescaling is done only on sqrt(esum2) or sqrt(esum1); 1555 Double_t esum1 = 0, esum2 = 0;; 1556 if (w1 > 0); 1557 esum1 = sum1 * sum1 / w1;; 1558 else; 1559 afunc1 = kTRUE; // use later for calculating z; 1560 ; 1561 if (w2 > 0); 1562 esum2 = sum2 * sum2 / w2;; 1563 else; 1564 afunc2 = kTRUE; // use later for calculating z; 1565 ; 1566 if (afunc2 && afunc1) {; 1567 Error(""KolmogorovTest"",""Errors are zero for both histograms\n"");; 1568 return 0;; 1569 }; 1570 ; 1571 // Find first Kolmogorov distance; 1572 Double_t s1 = 1/sum1;; 1573 Double_t s2 = 1/sum2;; 1574 Double_t dfmax1 = 0;; 1575 Double_t rsum1=0, rsum2=0;; 1576 for (i=ibeg;i<=iend;i++) {; 1577 for (j=jbeg;j<=jend;j++) {; 1578 rsum1 += s1*h1->GetBinContent(i,j);; 1579 rsum2 += s2*h2->GetBinContent(i,j);; 1580 dfmax1 = TMath::Max(dfmax1, TMath::Abs(rsum1-rsum2));; 1581 }; 1582 }; 1583 ; 1584 // Find second Kolmogorov distance; 1585 Double_t dfmax2 = 0;; 1586 r",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:65210,Availability,error,error,65210,".5*(dfmax1+dfmax2);; 1603 Double_t z = dfmax*factnm;; 1604 ; 1605 prb = TMath::KolmogorovProb(z);; 1606 ; 1607 Double_t prb1 = 0, prb2 = 0;; 1608 // option N to combine normalization makes sense if both afunc1 and afunc2 are false; 1609 if (opt.Contains(""N"") && !(afunc1 || afunc2 ) ) {; 1610 // Combine probabilities for shape and normalization; 1611 prb1 = prb;; 1612 Double_t d12 = esum1-esum2;; 1613 Double_t chi2 = d12*d12/(esum1+esum2);; 1614 prb2 = TMath::Prob(chi2,1);; 1615 // see Eadie et al., section 11.6.2; 1616 if (prb > 0 && prb2 > 0) prb = prb*prb2*(1-TMath::Log(prb*prb2));; 1617 else prb = 0;; 1618 }; 1619 ; 1620 // debug printout; 1621 if (opt.Contains(""D"")) {; 1622 printf("" Kolmo Prob h1 = %s, sum1=%g\n"",h1->GetName(),sum1);; 1623 printf("" Kolmo Prob h2 = %s, sum2=%g\n"",h2->GetName(),sum2);; 1624 printf("" Kolmo Probabil = %f, Max Dist = %g\n"",prb,dfmax);; 1625 if (opt.Contains(""N"")); 1626 printf("" Kolmo Probabil = %f for shape alone, =%f for normalisation alone\n"",prb1,prb2);; 1627 }; 1628 // This numerical error condition should never occur:; 1629 if (TMath::Abs(rsum1-1) > 0.002) Warning(""KolmogorovTest"",""Numerical problems with h1=%s\n"",h1->GetName());; 1630 if (TMath::Abs(rsum2-1) > 0.002) Warning(""KolmogorovTest"",""Numerical problems with h2=%s\n"",h2->GetName());; 1631 ; 1632 if(opt.Contains(""M"")) return dfmax; // return average of max distance; 1633 ; 1634 return prb;; 1635}; 1636 ; 1637 ; 1638////////////////////////////////////////////////////////////////////////////////; 1639/// Rebin only the X axis; 1640/// see Rebin2D; 1641 ; 1642TH2 *TH2::RebinX(Int_t ngroup, const char *newname); 1643{; 1644 return Rebin2D(ngroup, 1, newname);; 1645}; 1646 ; 1647 ; 1648////////////////////////////////////////////////////////////////////////////////; 1649/// Rebin only the Y axis; 1650/// see Rebin2D; 1651 ; 1652TH2 *TH2::RebinY(Int_t ngroup, const char *newname); 1653{; 1654 return Rebin2D(1, ngroup, newname);; 1655}; 1656 ; 1657/////////////////////////////",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:66378,Availability,error,error,66378,"1626 printf("" Kolmo Probabil = %f for shape alone, =%f for normalisation alone\n"",prb1,prb2);; 1627 }; 1628 // This numerical error condition should never occur:; 1629 if (TMath::Abs(rsum1-1) > 0.002) Warning(""KolmogorovTest"",""Numerical problems with h1=%s\n"",h1->GetName());; 1630 if (TMath::Abs(rsum2-1) > 0.002) Warning(""KolmogorovTest"",""Numerical problems with h2=%s\n"",h2->GetName());; 1631 ; 1632 if(opt.Contains(""M"")) return dfmax; // return average of max distance; 1633 ; 1634 return prb;; 1635}; 1636 ; 1637 ; 1638////////////////////////////////////////////////////////////////////////////////; 1639/// Rebin only the X axis; 1640/// see Rebin2D; 1641 ; 1642TH2 *TH2::RebinX(Int_t ngroup, const char *newname); 1643{; 1644 return Rebin2D(ngroup, 1, newname);; 1645}; 1646 ; 1647 ; 1648////////////////////////////////////////////////////////////////////////////////; 1649/// Rebin only the Y axis; 1650/// see Rebin2D; 1651 ; 1652TH2 *TH2::RebinY(Int_t ngroup, const char *newname); 1653{; 1654 return Rebin2D(1, ngroup, newname);; 1655}; 1656 ; 1657////////////////////////////////////////////////////////////////////////////////; 1658/// Override TH1::Rebin as TH2::RebinX; 1659/// Rebinning in variable binning as for TH1 is not allowed; 1660/// If a non-null pointer is given an error is flagged; 1661/// see RebinX and Rebin2D; 1662 ; 1663TH2 * TH2::Rebin( Int_t ngroup, const char*newname, const Double_t *xbins); 1664{; 1665 if (xbins != nullptr) {; 1666 Error(""Rebin"",""Rebinning a 2-d histogram into variable bins is not supported (it is possible only for 1-d histograms). Return a nullptr"");; 1667 return nullptr;; 1668 }; 1669 Info(""Rebin"",""Rebinning only the x-axis. Use Rebin2D for rebinning both axes"");; 1670 return RebinX(ngroup, newname);; 1671}; 1672////////////////////////////////////////////////////////////////////////////////; 1673/// Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together.; 1674///; 1675/// if newname is not blank a new te",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:67357,Availability,error,errors,67357,"ng in variable binning as for TH1 is not allowed; 1660/// If a non-null pointer is given an error is flagged; 1661/// see RebinX and Rebin2D; 1662 ; 1663TH2 * TH2::Rebin( Int_t ngroup, const char*newname, const Double_t *xbins); 1664{; 1665 if (xbins != nullptr) {; 1666 Error(""Rebin"",""Rebinning a 2-d histogram into variable bins is not supported (it is possible only for 1-d histograms). Return a nullptr"");; 1667 return nullptr;; 1668 }; 1669 Info(""Rebin"",""Rebinning only the x-axis. Use Rebin2D for rebinning both axes"");; 1670 return RebinX(ngroup, newname);; 1671}; 1672////////////////////////////////////////////////////////////////////////////////; 1673/// Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together.; 1674///; 1675/// if newname is not blank a new temporary histogram hnew is created.; 1676/// else the current histogram is modified (default); 1677/// The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this; 1678/// have to me merged into one bin of hnew; 1679/// If the original histogram has errors stored (via Sumw2), the resulting; 1680/// histograms has new errors correctly calculated.; 1681///; 1682/// examples: if hpxpy is an existing TH2 histogram with 40 x 40 bins; 1683/// ~~~ {.cpp}; 1684/// hpxpy->Rebin2D(); // merges two bins along the xaxis and yaxis in one in hpxpy; 1685/// // Carefull: previous contents of hpxpy are lost; 1686/// hpxpy->RebinX(5); //merges five bins along the xaxis in one in hpxpy; 1687/// TH2 *hnew = hpxpy->RebinY(5,""hnew""); // creates a new histogram hnew; 1688/// // merging 5 bins of h1 along the yaxis in one bin; 1689/// ~~~; 1690///; 1691/// NOTE : If nxgroup/nygroup is not an exact divider of the number of bins,; 1692/// along the xaxis/yaxis the top limit(s) of the rebinned histogram; 1693/// is changed to the upper edge of the xbin=newxbins*nxgroup resp.; 1694/// ybin=newybins*nygroup and the corresponding bins are added to; 1695/// the overflow bin.; 1696/// Statisti",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:67426,Availability,error,errors,67426,"ng in variable binning as for TH1 is not allowed; 1660/// If a non-null pointer is given an error is flagged; 1661/// see RebinX and Rebin2D; 1662 ; 1663TH2 * TH2::Rebin( Int_t ngroup, const char*newname, const Double_t *xbins); 1664{; 1665 if (xbins != nullptr) {; 1666 Error(""Rebin"",""Rebinning a 2-d histogram into variable bins is not supported (it is possible only for 1-d histograms). Return a nullptr"");; 1667 return nullptr;; 1668 }; 1669 Info(""Rebin"",""Rebinning only the x-axis. Use Rebin2D for rebinning both axes"");; 1670 return RebinX(ngroup, newname);; 1671}; 1672////////////////////////////////////////////////////////////////////////////////; 1673/// Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together.; 1674///; 1675/// if newname is not blank a new temporary histogram hnew is created.; 1676/// else the current histogram is modified (default); 1677/// The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this; 1678/// have to me merged into one bin of hnew; 1679/// If the original histogram has errors stored (via Sumw2), the resulting; 1680/// histograms has new errors correctly calculated.; 1681///; 1682/// examples: if hpxpy is an existing TH2 histogram with 40 x 40 bins; 1683/// ~~~ {.cpp}; 1684/// hpxpy->Rebin2D(); // merges two bins along the xaxis and yaxis in one in hpxpy; 1685/// // Carefull: previous contents of hpxpy are lost; 1686/// hpxpy->RebinX(5); //merges five bins along the xaxis in one in hpxpy; 1687/// TH2 *hnew = hpxpy->RebinY(5,""hnew""); // creates a new histogram hnew; 1688/// // merging 5 bins of h1 along the yaxis in one bin; 1689/// ~~~; 1690///; 1691/// NOTE : If nxgroup/nygroup is not an exact divider of the number of bins,; 1692/// along the xaxis/yaxis the top limit(s) of the rebinned histogram; 1693/// is changed to the upper edge of the xbin=newxbins*nxgroup resp.; 1694/// ybin=newybins*nygroup and the corresponding bins are added to; 1695/// the overflow bin.; 1696/// Statisti",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:72431,Availability,error,errors,72431,"xis.GetTitleOffset();; 1777 Float_t yTitleSize = fYaxis.GetTitleSize();; 1778 Color_t yTitleColor = fYaxis.GetTitleColor();; 1779 Style_t yTitleFont = fYaxis.GetTitleFont();; 1780 ; 1781 ; 1782 // copy merged bin contents (ignore under/overflows); 1783 if (nxgroup != 1 || nygroup != 1) {; 1784 if(fXaxis.GetXbins()->GetSize() > 0 || fYaxis.GetXbins()->GetSize() > 0){; 1785 // variable bin sizes in x or y, don't treat both cases separately; 1786 Double_t *xbins = new Double_t[newxbins + 1];; 1787 for(Int_t i = 0; i <= newxbins; ++i) xbins[i] = fXaxis.GetBinLowEdge(1 + i * nxgroup);; 1788 Double_t *ybins = new Double_t[newybins + 1];; 1789 for(Int_t i = 0; i <= newybins; ++i) ybins[i] = fYaxis.GetBinLowEdge(1 + i * nygroup);; 1790 hnew->SetBins(newxbins, xbins, newybins, ybins); // changes also errors array (if any); 1791 delete [] xbins;; 1792 delete [] ybins;; 1793 } else {; 1794 hnew->SetBins(newxbins, xmin, xmax, newybins, ymin, ymax); //changes also errors array; 1795 }; 1796 ; 1797 // (0, 0): x - underflow; y - underflow; 1798 hnew->UpdateBinContent(0, oldBins[0]);; 1799 if (oldErrors) hnew->fSumw2[0] = 0;; 1800 ; 1801 // (x, 0): x - regular / overflow; y - underflow; 1802 for(Int_t binx = 1, oldbinx = 1; binx < newnx; ++binx, oldbinx += nxgroup){; 1803 Double_t binContent = 0.0, binErrorSq = 0.0;; 1804 for (Int_t i = 0; i < nxgroup && (oldbinx + i) < nx; ++i) {; 1805 Int_t bin = oldbinx + i;; 1806 binContent += oldBins[bin];; 1807 if(oldErrors) binErrorSq += oldErrors[bin];; 1808 }; 1809 Int_t newbin = binx;; 1810 hnew->UpdateBinContent(newbin, binContent);; 1811 if (oldErrors) hnew->fSumw2[newbin] = binErrorSq;; 1812 }; 1813 ; 1814 // (0, y): x - underflow; y - regular / overflow; 1815 for(Int_t biny = 1, oldbiny = 1; biny < newny; ++biny, oldbiny += nygroup){; 1816 Double_t binContent = 0.0, binErrorSq = 0.0;; 1817 for (Int_t j = 0; j < nygroup && (oldbiny + j) < ny; ++j) {; 1818 Int_t bin = (oldbiny + j) * nx;; 1819 binContent += oldBins[bin];; 1820 if(oldErro",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:72594,Availability,error,errors,72594,"xis.GetTitleOffset();; 1777 Float_t yTitleSize = fYaxis.GetTitleSize();; 1778 Color_t yTitleColor = fYaxis.GetTitleColor();; 1779 Style_t yTitleFont = fYaxis.GetTitleFont();; 1780 ; 1781 ; 1782 // copy merged bin contents (ignore under/overflows); 1783 if (nxgroup != 1 || nygroup != 1) {; 1784 if(fXaxis.GetXbins()->GetSize() > 0 || fYaxis.GetXbins()->GetSize() > 0){; 1785 // variable bin sizes in x or y, don't treat both cases separately; 1786 Double_t *xbins = new Double_t[newxbins + 1];; 1787 for(Int_t i = 0; i <= newxbins; ++i) xbins[i] = fXaxis.GetBinLowEdge(1 + i * nxgroup);; 1788 Double_t *ybins = new Double_t[newybins + 1];; 1789 for(Int_t i = 0; i <= newybins; ++i) ybins[i] = fYaxis.GetBinLowEdge(1 + i * nygroup);; 1790 hnew->SetBins(newxbins, xbins, newybins, ybins); // changes also errors array (if any); 1791 delete [] xbins;; 1792 delete [] ybins;; 1793 } else {; 1794 hnew->SetBins(newxbins, xmin, xmax, newybins, ymin, ymax); //changes also errors array; 1795 }; 1796 ; 1797 // (0, 0): x - underflow; y - underflow; 1798 hnew->UpdateBinContent(0, oldBins[0]);; 1799 if (oldErrors) hnew->fSumw2[0] = 0;; 1800 ; 1801 // (x, 0): x - regular / overflow; y - underflow; 1802 for(Int_t binx = 1, oldbinx = 1; binx < newnx; ++binx, oldbinx += nxgroup){; 1803 Double_t binContent = 0.0, binErrorSq = 0.0;; 1804 for (Int_t i = 0; i < nxgroup && (oldbinx + i) < nx; ++i) {; 1805 Int_t bin = oldbinx + i;; 1806 binContent += oldBins[bin];; 1807 if(oldErrors) binErrorSq += oldErrors[bin];; 1808 }; 1809 Int_t newbin = binx;; 1810 hnew->UpdateBinContent(newbin, binContent);; 1811 if (oldErrors) hnew->fSumw2[newbin] = binErrorSq;; 1812 }; 1813 ; 1814 // (0, y): x - underflow; y - regular / overflow; 1815 for(Int_t biny = 1, oldbiny = 1; biny < newny; ++biny, oldbiny += nygroup){; 1816 Double_t binContent = 0.0, binErrorSq = 0.0;; 1817 for (Int_t j = 0; j < nygroup && (oldbiny + j) < ny; ++j) {; 1818 Int_t bin = (oldbiny + j) * nx;; 1819 binContent += oldBins[bin];; 1820 if(oldErro",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:80791,Availability,avail,available,80791,"Xaxis()->ImportAttributes( &outAxis);; 1982 THashList* labels=outAxis.GetLabels();; 1983 if (labels) {; 1984 TIter iL(labels);; 1985 TObjString* lb;; 1986 Int_t i = 1;; 1987 while ((lb=(TObjString*)iL())) {; 1988 h1->GetXaxis()->SetBinLabel(i,lb->String().Data());; 1989 i++;; 1990 }; 1991 }; 1992 ; 1993 h1->SetLineColor(this->GetLineColor());; 1994 h1->SetFillColor(this->GetFillColor());; 1995 h1->SetMarkerColor(this->GetMarkerColor());; 1996 h1->SetMarkerStyle(this->GetMarkerStyle());; 1997 ; 1998 // check if histogram is weighted; 1999 // in case need to store sum of weight square/bin for the profile; 2000 TArrayD & binSumw2 = *(h1->GetBinSumw2());; 2001 bool useWeights = (GetSumw2N() > 0);; 2002 if (useWeights && (binSumw2.fN != h1->GetNcells()) ) h1->Sumw2();; 2003 // we need to set this bit because we fill the profile using a single Fill for many entries; 2004 // This is needed for the changes applied to make automatically the histogram weighted in ROOT 6 versions; 2005 else h1->SetBit(TH1::kIsNotW);; 2006 ; 2007 // Fill the profile histogram; 2008 // no entries/bin is available so can fill only using bin content as weight; 2009 ; 2010 // implement filling of projected histogram; 2011 // outbin is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; 2012 // inbin is the axis being integrated. Loop is done only on the selected bins; 2013 for ( Int_t outbin = 0; outbin <= outAxis.GetNbins() + 1; ++outbin) {; 2014 if (outAxis.TestBit(TAxis::kAxisRange) && ( outbin < firstOutBin || outbin > lastOutBin )) continue;; 2015 ; 2016 // find corresponding bin number in h1 for outbin (binOut); 2017 Double_t xOut = outAxis.GetBinCenter(outbin);; 2018 Int_t binOut = h1->GetXaxis()->FindBin( xOut );; 2019 if (binOut <0) continue;; 2020 ; 2021 for (Int_t inbin = firstbin ; inbin <= lastbin ; ++inbin) {; 2022 Int_t binx, biny;; 2023 if (onX) { binx = outbin; biny=inbin; }; 2024 else { binx = inbin; biny=outbin; }; 2025 ; 2026 if (ncuts) {; 2027 ",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:83837,Availability,error,error,83837,"""),1);; 2056 if (!gPad || !gPad->FindObject(h1)) {; 2057 h1->Draw(opt);; 2058 } else {; 2059 h1->Paint(opt);; 2060 }; 2061 }; 2062 return h1;; 2063}; 2064 ; 2065 ; 2066////////////////////////////////////////////////////////////////////////////////; 2067/// Project a 2-D histogram into a profile histogram along X.; 2068///; 2069/// The projection is made from the channels along the Y axis; 2070/// ranging from firstybin to lastybin included.; 2071/// By default, bins 1 to ny are included; 2072/// When all bins are included, the number of entries in the projection; 2073/// is set to the number of entries of the 2-D histogram, otherwise; 2074/// the number of entries is incremented by 1 for all non empty cells.; 2075///; 2076/// if option ""d"" is specified, the profile is drawn in the current pad.; 2077///; 2078/// if option ""o"" original axis range of the target axes will be; 2079/// kept, but only bins inside the selected range will be filled.; 2080///; 2081/// The option can also be used to specify the projected profile error type.; 2082/// Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details; 2083///; 2084/// Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; 2085/// One must create a graphical cut (mouse or C++) and specify the name; 2086/// of the cut between [] in the option.; 2087/// For example, with a TCutG named ""cutg"", one can call:; 2088/// myhist->ProfileX("" "",firstybin,lastybin,""[cutg]"");; 2089/// To invert the cut, it is enough to put a ""-"" in front of its name:; 2090/// myhist->ProfileX("" "",firstybin,lastybin,""[-cutg]"");; 2091/// It is possible to apply several cuts ("","" means logical AND):; 2092/// myhist->ProfileX("" "",firstybin,lastybin,""[cutg1,cutg2]"");; 2093///; 2094/// NOTE that if a TProfile named ""name"" exists in the current directory or pad with; 2095/// a compatible axis the profile is reset and filled again with the projected contents of the TH2.; 2096/// In the case of axis incompat",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:84814,Availability,error,error,84814," the projected profile error type.; 2082/// Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details; 2083///; 2084/// Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; 2085/// One must create a graphical cut (mouse or C++) and specify the name; 2086/// of the cut between [] in the option.; 2087/// For example, with a TCutG named ""cutg"", one can call:; 2088/// myhist->ProfileX("" "",firstybin,lastybin,""[cutg]"");; 2089/// To invert the cut, it is enough to put a ""-"" in front of its name:; 2090/// myhist->ProfileX("" "",firstybin,lastybin,""[-cutg]"");; 2091/// It is possible to apply several cuts ("","" means logical AND):; 2092/// myhist->ProfileX("" "",firstybin,lastybin,""[cutg1,cutg2]"");; 2093///; 2094/// NOTE that if a TProfile named ""name"" exists in the current directory or pad with; 2095/// a compatible axis the profile is reset and filled again with the projected contents of the TH2.; 2096/// In the case of axis incompatibility an error is reported and a NULL pointer is returned.; 2097///; 2098/// NOTE that the X axis attributes of the TH2 are copied to the X axis of the profile.; 2099///; 2100/// NOTE that the default under- / overflow behavior differs from what ProjectionX; 2101/// does! Profiles take the bin center into account, so here the under- and overflow; 2102/// bins are ignored by default.; 2103///; 2104/// NOTE that the return profile histogram is computed using the Y bin center values instead of; 2105/// the real Y values which are used to fill the 2d histogram. Therefore the obtained profile is just an approximation of the; 2106/// correct profile histogram that would be obtained when filling it directly with the original data (see ROOT-7770); 2107 ; 2108 ; 2109TProfile *TH2::ProfileX(const char *name, Int_t firstybin, Int_t lastybin, Option_t *option) const; 2110{; 2111 return DoProfile(true, name, firstybin, lastybin, option);; 2112 ; 2113}; 2114 ; 2115 ; 2116/////////////////////////////////////",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:86650,Availability,error,error,86650,"Int_t firstybin, Int_t lastybin, Option_t *option) const; 2110{; 2111 return DoProfile(true, name, firstybin, lastybin, option);; 2112 ; 2113}; 2114 ; 2115 ; 2116////////////////////////////////////////////////////////////////////////////////; 2117/// Project a 2-D histogram into a profile histogram along Y.; 2118///; 2119/// The projection is made from the channels along the X axis; 2120/// ranging from firstxbin to lastxbin included.; 2121/// By default, bins 1 to nx are included; 2122/// When all bins are included, the number of entries in the projection; 2123/// is set to the number of entries of the 2-D histogram, otherwise; 2124/// the number of entries is incremented by 1 for all non empty cells.; 2125///; 2126/// if option ""d"" is specified, the profile is drawn in the current pad.; 2127///; 2128/// if option ""o"" , the original axis range of the target axis will be; 2129/// kept, but only bins inside the selected range will be filled.; 2130///; 2131/// The option can also be used to specify the projected profile error type.; 2132/// Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details; 2133/// Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; 2134///; 2135/// One must create a graphical cut (mouse or C++) and specify the name; 2136/// of the cut between [] in the option.; 2137/// For example, with a TCutG named ""cutg"", one can call:; 2138/// myhist->ProfileY("" "",firstybin,lastybin,""[cutg]"");; 2139/// To invert the cut, it is enough to put a ""-"" in front of its name:; 2140/// myhist->ProfileY("" "",firstybin,lastybin,""[-cutg]"");; 2141/// It is possible to apply several cuts:; 2142/// myhist->ProfileY("" "",firstybin,lastybin,""[cutg1,cutg2]"");; 2143///; 2144/// NOTE that if a TProfile named ""name"" exists in the current directory or pad with; 2145/// a compatible axis the profile is reset and filled again with the projected contents of the TH2.; 2146/// In the case of axis incompatibility an error is repo",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:87603,Availability,error,error,87603," also be used to specify the projected profile error type.; 2132/// Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details; 2133/// Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; 2134///; 2135/// One must create a graphical cut (mouse or C++) and specify the name; 2136/// of the cut between [] in the option.; 2137/// For example, with a TCutG named ""cutg"", one can call:; 2138/// myhist->ProfileY("" "",firstybin,lastybin,""[cutg]"");; 2139/// To invert the cut, it is enough to put a ""-"" in front of its name:; 2140/// myhist->ProfileY("" "",firstybin,lastybin,""[-cutg]"");; 2141/// It is possible to apply several cuts:; 2142/// myhist->ProfileY("" "",firstybin,lastybin,""[cutg1,cutg2]"");; 2143///; 2144/// NOTE that if a TProfile named ""name"" exists in the current directory or pad with; 2145/// a compatible axis the profile is reset and filled again with the projected contents of the TH2.; 2146/// In the case of axis incompatibility an error is reported and a NULL pointer is returned.; 2147///; 2148/// NOTE that the Y axis attributes of the TH2 are copied to the X axis of the profile.; 2149///; 2150/// NOTE that the default under- / overflow behavior differs from what ProjectionX; 2151/// does! Profiles take the bin center into account, so here the under- and overflow; 2152/// bins are ignored by default.; 2153///; 2154/// NOTE that the return profile histogram is computed using the X bin center values instead of; 2155/// the real X values which are used to fill the 2d histogram. Therefore the obtained profile is just an approximation of the; 2156/// correct profile histogram that would be obtained when filling it directly with the original data (see ROOT-7770); 2157 ; 2158 ; 2159TProfile *TH2::ProfileY(const char *name, Int_t firstxbin, Int_t lastxbin, Option_t *option) const; 2160{; 2161 return DoProfile(false, name, firstxbin, lastxbin, option);; 2162}; 2163 ; 2164 ; 2165///////////////////////////////////////////",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:94689,Availability,error,error,94689,"is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; 2309 // inbin is the axis being integrated. Loop is done only on the selected bins; 2310 // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins; 2311 Bool_t extendable = outAxis->CanExtend();; 2312 if ( labels && extendable ) h1->GetXaxis()->SetCanExtend(kFALSE);; 2313 for ( Int_t outbin = 0; outbin <= outAxis->GetNbins() + 1; ++outbin) {; 2314 err2 = 0;; 2315 cont = 0;; 2316 if (outAxis->TestBit(TAxis::kAxisRange) && ( outbin < firstOutBin || outbin > lastOutBin )) continue;; 2317 ; 2318 for (Int_t inbin = firstbin ; inbin <= lastbin ; ++inbin) {; 2319 Int_t binx, biny;; 2320 if (onX) { binx = outbin; biny=inbin; }; 2321 else { binx = inbin; biny=outbin; }; 2322 ; 2323 if (ncuts) {; 2324 if (!fPainter->IsInside(binx,biny)) continue;; 2325 }; 2326 // sum bin content and error if needed; 2327 cont += GetBinContent(binx,biny);; 2328 if (computeErrors) {; 2329 Double_t exy = GetBinError(binx,biny);; 2330 err2 += exy*exy;; 2331 }; 2332 }; 2333 // find corresponding bin number in h1 for outbin; 2334 Int_t binOut = h1->GetXaxis()->FindBin( outAxis->GetBinCenter(outbin) );; 2335 h1->SetBinContent(binOut ,cont);; 2336 if (computeErrors) h1->SetBinError(binOut,TMath::Sqrt(err2));; 2337 // sum all content; 2338 totcont += cont;; 2339 }; 2340 if ( labels ) h1->GetXaxis()->SetCanExtend(extendable);; 2341 ; 2342 // check if we can re-use the original statistics from the previous histogram; 2343 bool reuseStats = false;; 2344 if ( ( GetStatOverflowsBehaviour() == false && firstbin == 1 && lastbin == inNbin ) ||; 2345 ( GetStatOverflowsBehaviour() == true && firstbin == 0 && lastbin == inNbin + 1 ) ); 2346 reuseStats = true;; 2347 else {; 2348 // also if total content match we can re-use; 2349 double eps = 1.E-12;; 2350 if (IsA() == TH2F::Class() ) eps = 1.E-6;; 2351 if (fTsumw != 0 && TMath::Abs( fTsumw - totcont) < TMath::Abs(fTsumw) * e",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:96770,Availability,error,error,96770,"ck if we can re-use the original statistics from the previous histogram; 2343 bool reuseStats = false;; 2344 if ( ( GetStatOverflowsBehaviour() == false && firstbin == 1 && lastbin == inNbin ) ||; 2345 ( GetStatOverflowsBehaviour() == true && firstbin == 0 && lastbin == inNbin + 1 ) ); 2346 reuseStats = true;; 2347 else {; 2348 // also if total content match we can re-use; 2349 double eps = 1.E-12;; 2350 if (IsA() == TH2F::Class() ) eps = 1.E-6;; 2351 if (fTsumw != 0 && TMath::Abs( fTsumw - totcont) < TMath::Abs(fTsumw) * eps); 2352 reuseStats = true;; 2353 }; 2354 if (ncuts) reuseStats = false;; 2355 // retrieve the statistics and set in projected histogram if we can re-use it; 2356 bool reuseEntries = reuseStats;; 2357 // can re-use entries if underflow/overflow are included; 2358 reuseEntries &= (firstbin==0 && lastbin == inNbin+1);; 2359 if (reuseStats) {; 2360 Double_t stats[kNstat];; 2361 GetStats(stats);; 2362 if (!onX) { // case of projection on Y; 2363 stats[2] = stats[4];; 2364 stats[3] = stats[5];; 2365 }; 2366 h1->PutStats(stats);; 2367 }; 2368 else {; 2369 // the statistics is automatically recalculated since it is reset by the call to SetBinContent; 2370 // we just need to set the entries since they have not been correctly calculated during the projection; 2371 // we can only set them to the effective entries; 2372 h1->SetEntries( h1->GetEffectiveEntries() );; 2373 }; 2374 if (reuseEntries) {; 2375 h1->SetEntries(fEntries);; 2376 }; 2377 else {; 2378 // re-compute the entries; 2379 // in case of error calculation (i.e. when Sumw2() is set); 2380 // use the effective entries for the entries; 2381 // since this is the only way to estimate them; 2382 Double_t entries = TMath::Floor( totcont + 0.5); // to avoid numerical rounding; 2383 if (h1->GetSumw2N()) entries = h1->GetEffectiveEntries();; 2384 h1->SetEntries( entries );; 2385 }; 2386 ; 2387 if (opt.Contains(""d"")) {; 2388 TVirtualPad::TContext ctxt(gROOT->GetSelectedPad(), true, true);; 2389 opt.Remove(",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:98253,Availability,error,errors,98253,"pt.First(""d""),1);; 2390 // remove also other options; 2391 if (opt.Contains(""e"")) opt.Remove(opt.First(""e""),1);; 2392 if (!gPad || !gPad->FindObject(h1)) {; 2393 h1->Draw(opt);; 2394 } else {; 2395 h1->Paint(opt);; 2396 }; 2397 }; 2398 ; 2399 return h1;; 2400}; 2401 ; 2402 ; 2403////////////////////////////////////////////////////////////////////////////////; 2404/// Project a 2-D histogram into a 1-D histogram along X.; 2405///; 2406/// The projection is always of the type TH1D.; 2407/// The projection is made from the channels along the Y axis; 2408/// ranging from firstybin to lastybin included.; 2409/// By default, all bins including under- and overflow are included.; 2410/// The number of entries in the projection is estimated from the; 2411/// number of effective entries for all the cells included in the projection.; 2412///; 2413/// To exclude the underflow bins in Y, use firstybin=1.; 2414/// To exclude the overflow bins in Y, use lastybin=nx.; 2415///; 2416/// if option ""e"" is specified, the errors are computed.; 2417/// if option ""d"" is specified, the projection is drawn in the current pad.; 2418/// if option ""o"" original axis range of the target axes will be; 2419/// kept, but only bins inside the selected range will be filled.; 2420///; 2421/// Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; 2422/// One must create a graphical cut (mouse or C++) and specify the name; 2423/// of the cut between [] in the option.; 2424/// For example, with a TCutG named ""cutg"", one can call:; 2425/// myhist->ProjectionX("" "",firstybin,lastybin,""[cutg]"");; 2426/// To invert the cut, it is enough to put a ""-"" in front of its name:; 2427/// myhist->ProjectionX("" "",firstybin,lastybin,""[-cutg]"");; 2428/// It is possible to apply several cuts:; 2429/// myhist->ProjectionX("" "",firstybin,lastybin,""[cutg1,cutg2]"");; 2430///; 2431/// NOTE that if a TH1D named ""name"" exists in the current directory or pad; 2432/// the histogram is reset and filled again ",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:100329,Availability,error,errors,100329,"xis attributes of the TH2 are copied to the X axis of the projection.; 2435 ; 2436TH1D *TH2::ProjectionX(const char *name, Int_t firstybin, Int_t lastybin, Option_t *option) const; 2437{; 2438 return DoProjection(true, name, firstybin, lastybin, option);; 2439}; 2440 ; 2441 ; 2442////////////////////////////////////////////////////////////////////////////////; 2443/// Project a 2-D histogram into a 1-D histogram along Y.; 2444///; 2445/// The projection is always of the type TH1D.; 2446/// The projection is made from the channels along the X axis; 2447/// ranging from firstxbin to lastxbin included.; 2448/// By default, all bins including under- and overflow are included.; 2449/// The number of entries in the projection is estimated from the; 2450/// number of effective entries for all the cells included in the projection; 2451///; 2452/// To exclude the underflow bins in X, use firstxbin=1.; 2453/// To exclude the overflow bins in X, use lastxbin=nx.; 2454///; 2455/// if option ""e"" is specified, the errors are computed.; 2456/// if option ""d"" is specified, the projection is drawn in the current pad.; 2457/// if option ""o"" original axis range of the target axes will be; 2458/// kept, but only bins inside the selected range will be filled.; 2459///; 2460/// Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; 2461/// One must create a graphical cut (mouse or C++) and specify the name; 2462/// of the cut between [] in the option.; 2463/// For example, with a TCutG named ""cutg"", one can call:; 2464/// myhist->ProjectionY("" "",firstxbin,lastxbin,""[cutg]"");; 2465/// To invert the cut, it is enough to put a ""-"" in front of its name:; 2466/// myhist->ProjectionY("" "",firstxbin,lastxbin,""[-cutg]"");; 2467/// It is possible to apply several cuts:; 2468/// myhist->ProjectionY("" "",firstxbin,lastxbin,""[cutg1,cutg2]"");; 2469///; 2470/// NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; 2471/// a compatible axis, the histog",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:101433,Availability,error,error,101433,"2457/// if option ""o"" original axis range of the target axes will be; 2458/// kept, but only bins inside the selected range will be filled.; 2459///; 2460/// Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; 2461/// One must create a graphical cut (mouse or C++) and specify the name; 2462/// of the cut between [] in the option.; 2463/// For example, with a TCutG named ""cutg"", one can call:; 2464/// myhist->ProjectionY("" "",firstxbin,lastxbin,""[cutg]"");; 2465/// To invert the cut, it is enough to put a ""-"" in front of its name:; 2466/// myhist->ProjectionY("" "",firstxbin,lastxbin,""[-cutg]"");; 2467/// It is possible to apply several cuts:; 2468/// myhist->ProjectionY("" "",firstxbin,lastxbin,""[cutg1,cutg2]"");; 2469///; 2470/// NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; 2471/// a compatible axis, the histogram is reset and filled again with the projected contents of the TH2.; 2472/// In the case of axis incompatibility, an error is reported and a NULL pointer is returned.; 2473///; 2474/// NOTE that the Y axis attributes of the TH2 are copied to the X axis of the projection.; 2475 ; 2476TH1D *TH2::ProjectionY(const char *name, Int_t firstxbin, Int_t lastxbin, Option_t *option) const; 2477{; 2478 return DoProjection(false, name, firstxbin, lastxbin, option);; 2479}; 2480 ; 2481 ; 2482////////////////////////////////////////////////////////////////////////////////; 2483/// Replace current statistics with the values in array stats; 2484 ; 2485void TH2::PutStats(Double_t *stats); 2486{; 2487 TH1::PutStats(stats);; 2488 fTsumwy = stats[4];; 2489 fTsumwy2 = stats[5];; 2490 fTsumwxy = stats[6];; 2491}; 2492 ; 2493 ; 2494////////////////////////////////////////////////////////////////////////////////; 2495/// Compute the X distribution of quantiles in the other variable Y; 2496/// name is the name of the returned histogram; 2497/// prob is the probability content for the quantile (0.5 is the default for the medi",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:102461,Availability,error,error,102461,"73///; 2474/// NOTE that the Y axis attributes of the TH2 are copied to the X axis of the projection.; 2475 ; 2476TH1D *TH2::ProjectionY(const char *name, Int_t firstxbin, Int_t lastxbin, Option_t *option) const; 2477{; 2478 return DoProjection(false, name, firstxbin, lastxbin, option);; 2479}; 2480 ; 2481 ; 2482////////////////////////////////////////////////////////////////////////////////; 2483/// Replace current statistics with the values in array stats; 2484 ; 2485void TH2::PutStats(Double_t *stats); 2486{; 2487 TH1::PutStats(stats);; 2488 fTsumwy = stats[4];; 2489 fTsumwy2 = stats[5];; 2490 fTsumwxy = stats[6];; 2491}; 2492 ; 2493 ; 2494////////////////////////////////////////////////////////////////////////////////; 2495/// Compute the X distribution of quantiles in the other variable Y; 2496/// name is the name of the returned histogram; 2497/// prob is the probability content for the quantile (0.5 is the default for the median); 2498/// An approximate error for the quantile is computed assuming that the distribution in; 2499/// the other variable is normal. According to this approximate formula the error on the quantile is; 2500/// estimated as sqrt( p (1-p) / ( n * f(q)^2) ), where p is the probability content of the quantile and; 2501/// n is the number of events used to compute the quantile and f(q) is the probability distribution for the; 2502/// other variable evaluated at the obtained quantile. In the error estimation the probability is then assumed to be; 2503/// a normal distribution.; 2504 ; 2505TH1D* TH2::QuantilesX( Double_t prob, const char * name) const; 2506{; 2507 return DoQuantiles(true, name, prob);; 2508}; 2509 ; 2510 ; 2511////////////////////////////////////////////////////////////////////////////////; 2512/// Compute the Y distribution of quantiles in the other variable X; 2513/// name is the name of the returned histogram; 2514/// prob is the probability content for the quantile (0.5 is the default for the median); 2515/// An approxima",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:102611,Availability,error,error,102611," firstxbin, lastxbin, option);; 2479}; 2480 ; 2481 ; 2482////////////////////////////////////////////////////////////////////////////////; 2483/// Replace current statistics with the values in array stats; 2484 ; 2485void TH2::PutStats(Double_t *stats); 2486{; 2487 TH1::PutStats(stats);; 2488 fTsumwy = stats[4];; 2489 fTsumwy2 = stats[5];; 2490 fTsumwxy = stats[6];; 2491}; 2492 ; 2493 ; 2494////////////////////////////////////////////////////////////////////////////////; 2495/// Compute the X distribution of quantiles in the other variable Y; 2496/// name is the name of the returned histogram; 2497/// prob is the probability content for the quantile (0.5 is the default for the median); 2498/// An approximate error for the quantile is computed assuming that the distribution in; 2499/// the other variable is normal. According to this approximate formula the error on the quantile is; 2500/// estimated as sqrt( p (1-p) / ( n * f(q)^2) ), where p is the probability content of the quantile and; 2501/// n is the number of events used to compute the quantile and f(q) is the probability distribution for the; 2502/// other variable evaluated at the obtained quantile. In the error estimation the probability is then assumed to be; 2503/// a normal distribution.; 2504 ; 2505TH1D* TH2::QuantilesX( Double_t prob, const char * name) const; 2506{; 2507 return DoQuantiles(true, name, prob);; 2508}; 2509 ; 2510 ; 2511////////////////////////////////////////////////////////////////////////////////; 2512/// Compute the Y distribution of quantiles in the other variable X; 2513/// name is the name of the returned histogram; 2514/// prob is the probability content for the quantile (0.5 is the default for the median); 2515/// An approximate error for the quantile is computed assuming that the distribution in; 2516/// the other variable is normal.; 2517 ; 2518TH1D* TH2::QuantilesY( Double_t prob, const char * name) const; 2519{; 2520 return DoQuantiles(false, name, prob);; 2521}; 2522 ; 2523",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:102926,Availability,error,error,102926,"TH2::PutStats(Double_t *stats); 2486{; 2487 TH1::PutStats(stats);; 2488 fTsumwy = stats[4];; 2489 fTsumwy2 = stats[5];; 2490 fTsumwxy = stats[6];; 2491}; 2492 ; 2493 ; 2494////////////////////////////////////////////////////////////////////////////////; 2495/// Compute the X distribution of quantiles in the other variable Y; 2496/// name is the name of the returned histogram; 2497/// prob is the probability content for the quantile (0.5 is the default for the median); 2498/// An approximate error for the quantile is computed assuming that the distribution in; 2499/// the other variable is normal. According to this approximate formula the error on the quantile is; 2500/// estimated as sqrt( p (1-p) / ( n * f(q)^2) ), where p is the probability content of the quantile and; 2501/// n is the number of events used to compute the quantile and f(q) is the probability distribution for the; 2502/// other variable evaluated at the obtained quantile. In the error estimation the probability is then assumed to be; 2503/// a normal distribution.; 2504 ; 2505TH1D* TH2::QuantilesX( Double_t prob, const char * name) const; 2506{; 2507 return DoQuantiles(true, name, prob);; 2508}; 2509 ; 2510 ; 2511////////////////////////////////////////////////////////////////////////////////; 2512/// Compute the Y distribution of quantiles in the other variable X; 2513/// name is the name of the returned histogram; 2514/// prob is the probability content for the quantile (0.5 is the default for the median); 2515/// An approximate error for the quantile is computed assuming that the distribution in; 2516/// the other variable is normal.; 2517 ; 2518TH1D* TH2::QuantilesY( Double_t prob, const char * name) const; 2519{; 2520 return DoQuantiles(false, name, prob);; 2521}; 2522 ; 2523 ; 2524////////////////////////////////////////////////////////////////////////////////; 2525/// Implementation of quantiles for x or y; 2526 ; 2527TH1D* TH2::DoQuantiles(bool onX, const char * name, Double_t prob) const; ",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:103489,Availability,error,error,103489,"distribution in; 2499/// the other variable is normal. According to this approximate formula the error on the quantile is; 2500/// estimated as sqrt( p (1-p) / ( n * f(q)^2) ), where p is the probability content of the quantile and; 2501/// n is the number of events used to compute the quantile and f(q) is the probability distribution for the; 2502/// other variable evaluated at the obtained quantile. In the error estimation the probability is then assumed to be; 2503/// a normal distribution.; 2504 ; 2505TH1D* TH2::QuantilesX( Double_t prob, const char * name) const; 2506{; 2507 return DoQuantiles(true, name, prob);; 2508}; 2509 ; 2510 ; 2511////////////////////////////////////////////////////////////////////////////////; 2512/// Compute the Y distribution of quantiles in the other variable X; 2513/// name is the name of the returned histogram; 2514/// prob is the probability content for the quantile (0.5 is the default for the median); 2515/// An approximate error for the quantile is computed assuming that the distribution in; 2516/// the other variable is normal.; 2517 ; 2518TH1D* TH2::QuantilesY( Double_t prob, const char * name) const; 2519{; 2520 return DoQuantiles(false, name, prob);; 2521}; 2522 ; 2523 ; 2524////////////////////////////////////////////////////////////////////////////////; 2525/// Implementation of quantiles for x or y; 2526 ; 2527TH1D* TH2::DoQuantiles(bool onX, const char * name, Double_t prob) const; 2528{; 2529 const TAxis *outAxis = nullptr;; 2530 if ( onX ) {; 2531 outAxis = GetXaxis();; 2532 } else {; 2533 outAxis = GetYaxis();; 2534 }; 2535 ; 2536 // build first name of returned histogram; 2537 TString qname = name;; 2538 if (qname.IsNull() || qname == ""_qx"" || qname == ""_qy"") {; 2539 const char * qtype = (onX) ? ""qx"" : ""qy"";; 2540 qname = TString::Format(""%s_%s_%3.2f"",GetName(),qtype, prob);; 2541 }; 2542 // check if the histogram is already existing; 2543 TH1D *h1=nullptr;; 2544 //check if histogram with identical name exist; 2545 T",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:105852,Availability,error,error,105852,"ame(),qtype, prob);; 2541 }; 2542 // check if the histogram is already existing; 2543 TH1D *h1=nullptr;; 2544 //check if histogram with identical name exist; 2545 TObject *h1obj = gROOT->FindObject(qname);; 2546 if (h1obj) {; 2547 h1 = dynamic_cast<TH1D*>(h1obj);; 2548 if (!h1) {; 2549 Error(""DoQuantiles"",""Histogram with name %s must be a TH1D and is a %s"",qname.Data(),h1obj->ClassName());; 2550 return nullptr;; 2551 }; 2552 }; 2553 if (h1) {; 2554 h1->Reset();; 2555 } else {; 2556 // create the histogram; 2557 h1 = new TH1D(qname, GetTitle(), 1, 0, 1);; 2558 }; 2559 // set the bin content; 2560 Int_t firstOutBin = std::max(outAxis->GetFirst(),1);; 2561 Int_t lastOutBin = std::max(outAxis->GetLast(),outAxis->GetNbins());; 2562 const TArrayD *xbins = outAxis->GetXbins();; 2563 if (xbins->fN == 0); 2564 h1->SetBins(lastOutBin-firstOutBin+1,outAxis->GetBinLowEdge(firstOutBin),outAxis->GetBinUpEdge(lastOutBin));; 2565 else; 2566 h1->SetBins(lastOutBin-firstOutBin+1,&xbins->fArray[firstOutBin-1]);; 2567 ; 2568 // set the bin content of the histogram; 2569 Double_t pp[1];; 2570 pp[0] = prob;; 2571 ; 2572 TH1D * slice = nullptr;; 2573 for (int ibin = outAxis->GetFirst() ; ibin <= outAxis->GetLast() ; ++ibin) {; 2574 Double_t qq[1];; 2575 // do a projection on the opposite axis; 2576 slice = DoProjection(!onX, ""tmp"",ibin,ibin,"""");; 2577 if (!slice) break;; 2578 if (slice->GetSum() == 0) continue;; 2579 slice->GetQuantiles(1,qq,pp);; 2580 h1->SetBinContent(ibin,qq[0]);; 2581 // compute error using normal approximation; 2582 // quantile error ~ sqrt (q*(1-q)/ *( n * f(xq)^2 ) from Kendall; 2583 // where f(xq) is the p.d.f value at the quantile xq; 2584 Double_t n = slice->GetEffectiveEntries();; 2585 Double_t f = TMath::Gaus(qq[0], slice->GetMean(), slice->GetStdDev(), kTRUE);; 2586 Double_t error = 0;; 2587 // set the errors to zero in case of small statistics; 2588 if (f > 0 && n > 1); 2589 error = TMath::Sqrt( prob*(1.-prob)/ (n * f * f) );; 2590 h1->SetBinError(ibin, error",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:105903,Availability,error,error,105903,"ame(),qtype, prob);; 2541 }; 2542 // check if the histogram is already existing; 2543 TH1D *h1=nullptr;; 2544 //check if histogram with identical name exist; 2545 TObject *h1obj = gROOT->FindObject(qname);; 2546 if (h1obj) {; 2547 h1 = dynamic_cast<TH1D*>(h1obj);; 2548 if (!h1) {; 2549 Error(""DoQuantiles"",""Histogram with name %s must be a TH1D and is a %s"",qname.Data(),h1obj->ClassName());; 2550 return nullptr;; 2551 }; 2552 }; 2553 if (h1) {; 2554 h1->Reset();; 2555 } else {; 2556 // create the histogram; 2557 h1 = new TH1D(qname, GetTitle(), 1, 0, 1);; 2558 }; 2559 // set the bin content; 2560 Int_t firstOutBin = std::max(outAxis->GetFirst(),1);; 2561 Int_t lastOutBin = std::max(outAxis->GetLast(),outAxis->GetNbins());; 2562 const TArrayD *xbins = outAxis->GetXbins();; 2563 if (xbins->fN == 0); 2564 h1->SetBins(lastOutBin-firstOutBin+1,outAxis->GetBinLowEdge(firstOutBin),outAxis->GetBinUpEdge(lastOutBin));; 2565 else; 2566 h1->SetBins(lastOutBin-firstOutBin+1,&xbins->fArray[firstOutBin-1]);; 2567 ; 2568 // set the bin content of the histogram; 2569 Double_t pp[1];; 2570 pp[0] = prob;; 2571 ; 2572 TH1D * slice = nullptr;; 2573 for (int ibin = outAxis->GetFirst() ; ibin <= outAxis->GetLast() ; ++ibin) {; 2574 Double_t qq[1];; 2575 // do a projection on the opposite axis; 2576 slice = DoProjection(!onX, ""tmp"",ibin,ibin,"""");; 2577 if (!slice) break;; 2578 if (slice->GetSum() == 0) continue;; 2579 slice->GetQuantiles(1,qq,pp);; 2580 h1->SetBinContent(ibin,qq[0]);; 2581 // compute error using normal approximation; 2582 // quantile error ~ sqrt (q*(1-q)/ *( n * f(xq)^2 ) from Kendall; 2583 // where f(xq) is the p.d.f value at the quantile xq; 2584 Double_t n = slice->GetEffectiveEntries();; 2585 Double_t f = TMath::Gaus(qq[0], slice->GetMean(), slice->GetStdDev(), kTRUE);; 2586 Double_t error = 0;; 2587 // set the errors to zero in case of small statistics; 2588 if (f > 0 && n > 1); 2589 error = TMath::Sqrt( prob*(1.-prob)/ (n * f * f) );; 2590 h1->SetBinError(ibin, error",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:106163,Availability,error,error,106163,"xbins->fN == 0); 2564 h1->SetBins(lastOutBin-firstOutBin+1,outAxis->GetBinLowEdge(firstOutBin),outAxis->GetBinUpEdge(lastOutBin));; 2565 else; 2566 h1->SetBins(lastOutBin-firstOutBin+1,&xbins->fArray[firstOutBin-1]);; 2567 ; 2568 // set the bin content of the histogram; 2569 Double_t pp[1];; 2570 pp[0] = prob;; 2571 ; 2572 TH1D * slice = nullptr;; 2573 for (int ibin = outAxis->GetFirst() ; ibin <= outAxis->GetLast() ; ++ibin) {; 2574 Double_t qq[1];; 2575 // do a projection on the opposite axis; 2576 slice = DoProjection(!onX, ""tmp"",ibin,ibin,"""");; 2577 if (!slice) break;; 2578 if (slice->GetSum() == 0) continue;; 2579 slice->GetQuantiles(1,qq,pp);; 2580 h1->SetBinContent(ibin,qq[0]);; 2581 // compute error using normal approximation; 2582 // quantile error ~ sqrt (q*(1-q)/ *( n * f(xq)^2 ) from Kendall; 2583 // where f(xq) is the p.d.f value at the quantile xq; 2584 Double_t n = slice->GetEffectiveEntries();; 2585 Double_t f = TMath::Gaus(qq[0], slice->GetMean(), slice->GetStdDev(), kTRUE);; 2586 Double_t error = 0;; 2587 // set the errors to zero in case of small statistics; 2588 if (f > 0 && n > 1); 2589 error = TMath::Sqrt( prob*(1.-prob)/ (n * f * f) );; 2590 h1->SetBinError(ibin, error);; 2591 }; 2592 if (slice) delete slice;; 2593 return h1;; 2594}; 2595 ; 2596 ; 2597////////////////////////////////////////////////////////////////////////////////; 2598/// Reset this histogram: contents, errors, etc.; 2599 ; 2600void TH2::Reset(Option_t *option); 2601{; 2602 TH1::Reset(option);; 2603 TString opt = option;; 2604 opt.ToUpper();; 2605 ; 2606 if (opt.Contains(""ICE"") && !opt.Contains(""S"")) return;; 2607 fTsumwy = 0;; 2608 fTsumwy2 = 0;; 2609 fTsumwxy = 0;; 2610}; 2611 ; 2612 ; 2613////////////////////////////////////////////////////////////////////////////////; 2614/// Set bin content; 2615 ; 2616void TH2::SetBinContent(Int_t bin, Double_t content); 2617{; 2618 fEntries++;; 2619 fTsumw = 0;; 2620 if (bin < 0) return;; 2621 if (bin >= fNcells) return;; 2622 UpdateBin",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:106191,Availability,error,errors,106191,"xbins->fN == 0); 2564 h1->SetBins(lastOutBin-firstOutBin+1,outAxis->GetBinLowEdge(firstOutBin),outAxis->GetBinUpEdge(lastOutBin));; 2565 else; 2566 h1->SetBins(lastOutBin-firstOutBin+1,&xbins->fArray[firstOutBin-1]);; 2567 ; 2568 // set the bin content of the histogram; 2569 Double_t pp[1];; 2570 pp[0] = prob;; 2571 ; 2572 TH1D * slice = nullptr;; 2573 for (int ibin = outAxis->GetFirst() ; ibin <= outAxis->GetLast() ; ++ibin) {; 2574 Double_t qq[1];; 2575 // do a projection on the opposite axis; 2576 slice = DoProjection(!onX, ""tmp"",ibin,ibin,"""");; 2577 if (!slice) break;; 2578 if (slice->GetSum() == 0) continue;; 2579 slice->GetQuantiles(1,qq,pp);; 2580 h1->SetBinContent(ibin,qq[0]);; 2581 // compute error using normal approximation; 2582 // quantile error ~ sqrt (q*(1-q)/ *( n * f(xq)^2 ) from Kendall; 2583 // where f(xq) is the p.d.f value at the quantile xq; 2584 Double_t n = slice->GetEffectiveEntries();; 2585 Double_t f = TMath::Gaus(qq[0], slice->GetMean(), slice->GetStdDev(), kTRUE);; 2586 Double_t error = 0;; 2587 // set the errors to zero in case of small statistics; 2588 if (f > 0 && n > 1); 2589 error = TMath::Sqrt( prob*(1.-prob)/ (n * f * f) );; 2590 h1->SetBinError(ibin, error);; 2591 }; 2592 if (slice) delete slice;; 2593 return h1;; 2594}; 2595 ; 2596 ; 2597////////////////////////////////////////////////////////////////////////////////; 2598/// Reset this histogram: contents, errors, etc.; 2599 ; 2600void TH2::Reset(Option_t *option); 2601{; 2602 TH1::Reset(option);; 2603 TString opt = option;; 2604 opt.ToUpper();; 2605 ; 2606 if (opt.Contains(""ICE"") && !opt.Contains(""S"")) return;; 2607 fTsumwy = 0;; 2608 fTsumwy2 = 0;; 2609 fTsumwxy = 0;; 2610}; 2611 ; 2612 ; 2613////////////////////////////////////////////////////////////////////////////////; 2614/// Set bin content; 2615 ; 2616void TH2::SetBinContent(Int_t bin, Double_t content); 2617{; 2618 fEntries++;; 2619 fTsumw = 0;; 2620 if (bin < 0) return;; 2621 if (bin >= fNcells) return;; 2622 UpdateBin",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:106266,Availability,error,error,106266,"xbins->fN == 0); 2564 h1->SetBins(lastOutBin-firstOutBin+1,outAxis->GetBinLowEdge(firstOutBin),outAxis->GetBinUpEdge(lastOutBin));; 2565 else; 2566 h1->SetBins(lastOutBin-firstOutBin+1,&xbins->fArray[firstOutBin-1]);; 2567 ; 2568 // set the bin content of the histogram; 2569 Double_t pp[1];; 2570 pp[0] = prob;; 2571 ; 2572 TH1D * slice = nullptr;; 2573 for (int ibin = outAxis->GetFirst() ; ibin <= outAxis->GetLast() ; ++ibin) {; 2574 Double_t qq[1];; 2575 // do a projection on the opposite axis; 2576 slice = DoProjection(!onX, ""tmp"",ibin,ibin,"""");; 2577 if (!slice) break;; 2578 if (slice->GetSum() == 0) continue;; 2579 slice->GetQuantiles(1,qq,pp);; 2580 h1->SetBinContent(ibin,qq[0]);; 2581 // compute error using normal approximation; 2582 // quantile error ~ sqrt (q*(1-q)/ *( n * f(xq)^2 ) from Kendall; 2583 // where f(xq) is the p.d.f value at the quantile xq; 2584 Double_t n = slice->GetEffectiveEntries();; 2585 Double_t f = TMath::Gaus(qq[0], slice->GetMean(), slice->GetStdDev(), kTRUE);; 2586 Double_t error = 0;; 2587 // set the errors to zero in case of small statistics; 2588 if (f > 0 && n > 1); 2589 error = TMath::Sqrt( prob*(1.-prob)/ (n * f * f) );; 2590 h1->SetBinError(ibin, error);; 2591 }; 2592 if (slice) delete slice;; 2593 return h1;; 2594}; 2595 ; 2596 ; 2597////////////////////////////////////////////////////////////////////////////////; 2598/// Reset this histogram: contents, errors, etc.; 2599 ; 2600void TH2::Reset(Option_t *option); 2601{; 2602 TH1::Reset(option);; 2603 TString opt = option;; 2604 opt.ToUpper();; 2605 ; 2606 if (opt.Contains(""ICE"") && !opt.Contains(""S"")) return;; 2607 fTsumwy = 0;; 2608 fTsumwy2 = 0;; 2609 fTsumwxy = 0;; 2610}; 2611 ; 2612 ; 2613////////////////////////////////////////////////////////////////////////////////; 2614/// Set bin content; 2615 ; 2616void TH2::SetBinContent(Int_t bin, Double_t content); 2617{; 2618 fEntries++;; 2619 fTsumw = 0;; 2620 if (bin < 0) return;; 2621 if (bin >= fNcells) return;; 2622 UpdateBin",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:106346,Availability,error,error,106346,"; 2570 pp[0] = prob;; 2571 ; 2572 TH1D * slice = nullptr;; 2573 for (int ibin = outAxis->GetFirst() ; ibin <= outAxis->GetLast() ; ++ibin) {; 2574 Double_t qq[1];; 2575 // do a projection on the opposite axis; 2576 slice = DoProjection(!onX, ""tmp"",ibin,ibin,"""");; 2577 if (!slice) break;; 2578 if (slice->GetSum() == 0) continue;; 2579 slice->GetQuantiles(1,qq,pp);; 2580 h1->SetBinContent(ibin,qq[0]);; 2581 // compute error using normal approximation; 2582 // quantile error ~ sqrt (q*(1-q)/ *( n * f(xq)^2 ) from Kendall; 2583 // where f(xq) is the p.d.f value at the quantile xq; 2584 Double_t n = slice->GetEffectiveEntries();; 2585 Double_t f = TMath::Gaus(qq[0], slice->GetMean(), slice->GetStdDev(), kTRUE);; 2586 Double_t error = 0;; 2587 // set the errors to zero in case of small statistics; 2588 if (f > 0 && n > 1); 2589 error = TMath::Sqrt( prob*(1.-prob)/ (n * f * f) );; 2590 h1->SetBinError(ibin, error);; 2591 }; 2592 if (slice) delete slice;; 2593 return h1;; 2594}; 2595 ; 2596 ; 2597////////////////////////////////////////////////////////////////////////////////; 2598/// Reset this histogram: contents, errors, etc.; 2599 ; 2600void TH2::Reset(Option_t *option); 2601{; 2602 TH1::Reset(option);; 2603 TString opt = option;; 2604 opt.ToUpper();; 2605 ; 2606 if (opt.Contains(""ICE"") && !opt.Contains(""S"")) return;; 2607 fTsumwy = 0;; 2608 fTsumwy2 = 0;; 2609 fTsumwxy = 0;; 2610}; 2611 ; 2612 ; 2613////////////////////////////////////////////////////////////////////////////////; 2614/// Set bin content; 2615 ; 2616void TH2::SetBinContent(Int_t bin, Double_t content); 2617{; 2618 fEntries++;; 2619 fTsumw = 0;; 2620 if (bin < 0) return;; 2621 if (bin >= fNcells) return;; 2622 UpdateBinContent(bin, content);; 2623}; 2624 ; 2625 ; 2626////////////////////////////////////////////////////////////////////////////////; 2627/// When the mouse is moved in a pad containing a 2-d view of this histogram; 2628/// a second canvas shows the projection along X corresponding to the; 262",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:106558,Availability,error,errors,106558,"; 2570 pp[0] = prob;; 2571 ; 2572 TH1D * slice = nullptr;; 2573 for (int ibin = outAxis->GetFirst() ; ibin <= outAxis->GetLast() ; ++ibin) {; 2574 Double_t qq[1];; 2575 // do a projection on the opposite axis; 2576 slice = DoProjection(!onX, ""tmp"",ibin,ibin,"""");; 2577 if (!slice) break;; 2578 if (slice->GetSum() == 0) continue;; 2579 slice->GetQuantiles(1,qq,pp);; 2580 h1->SetBinContent(ibin,qq[0]);; 2581 // compute error using normal approximation; 2582 // quantile error ~ sqrt (q*(1-q)/ *( n * f(xq)^2 ) from Kendall; 2583 // where f(xq) is the p.d.f value at the quantile xq; 2584 Double_t n = slice->GetEffectiveEntries();; 2585 Double_t f = TMath::Gaus(qq[0], slice->GetMean(), slice->GetStdDev(), kTRUE);; 2586 Double_t error = 0;; 2587 // set the errors to zero in case of small statistics; 2588 if (f > 0 && n > 1); 2589 error = TMath::Sqrt( prob*(1.-prob)/ (n * f * f) );; 2590 h1->SetBinError(ibin, error);; 2591 }; 2592 if (slice) delete slice;; 2593 return h1;; 2594}; 2595 ; 2596 ; 2597////////////////////////////////////////////////////////////////////////////////; 2598/// Reset this histogram: contents, errors, etc.; 2599 ; 2600void TH2::Reset(Option_t *option); 2601{; 2602 TH1::Reset(option);; 2603 TString opt = option;; 2604 opt.ToUpper();; 2605 ; 2606 if (opt.Contains(""ICE"") && !opt.Contains(""S"")) return;; 2607 fTsumwy = 0;; 2608 fTsumwy2 = 0;; 2609 fTsumwxy = 0;; 2610}; 2611 ; 2612 ; 2613////////////////////////////////////////////////////////////////////////////////; 2614/// Set bin content; 2615 ; 2616void TH2::SetBinContent(Int_t bin, Double_t content); 2617{; 2618 fEntries++;; 2619 fTsumw = 0;; 2620 if (bin < 0) return;; 2621 if (bin >= fNcells) return;; 2622 UpdateBinContent(bin, content);; 2623}; 2624 ; 2625 ; 2626////////////////////////////////////////////////////////////////////////////////; 2627/// When the mouse is moved in a pad containing a 2-d view of this histogram; 2628/// a second canvas shows the projection along X corresponding to the; 262",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:111118,Availability,error,errors,111118,"::ShowPeaks(Double_t sigma, Option_t *option, Double_t threshold); 2696{; 2697 ; 2698 return (Int_t)gROOT->ProcessLineFast(TString::Format(""TSpectrum2::StaticSearch((TH1*)0x%zx,%g,\""%s\"",%g)"",; 2699 (size_t)this, sigma, option, threshold).Data());; 2700}; 2701 ; 2702 ; 2703////////////////////////////////////////////////////////////////////////////////; 2704/// Smooth bin contents of this 2-d histogram using kernel algorithms; 2705/// similar to the ones used in the raster graphics community.; 2706/// Bin contents in the active range are replaced by their smooth values.; 2707/// The algorithm retains the input dimension by using Kernel Crop at the input boundaries.; 2708/// Kernel Crop sets any pixel in the kernel that extends past the input to zero and adjusts the; 2709/// normalization accordingly.; 2710/// If Errors are defined via Sumw2, they are also scaled and computed.; 2711/// However, note the resulting errors will be correlated between different-bins, so; 2712/// the errors should not be used blindly to perform any calculation involving several bins,; 2713/// like fitting the histogram. One would need to compute also the bin by bin correlation matrix.; 2714///; 2715/// 3 kernels are proposed k5a, k5b and k3a.; 2716/// k5a and k5b act on 5x5 cells (i-2,i-1,i,i+1,i+2, and same for j); 2717/// k5b is a bit more stronger in smoothing; 2718/// k3a acts only on 3x3 cells (i-1,i,i+1, and same for j).; 2719/// By default the kernel ""k5a"" is used. You can select the kernels ""k5b"" or ""k3a""; 2720/// via the option argument.; 2721/// If TAxis::SetRange has been called on the x or/and y axis, only the bins; 2722/// in the specified range are smoothed.; 2723/// In the current implementation if the first argument is not used (default value=1).; 2724///; 2725/// implementation by David McKee (dmckee@bama.ua.edu). Extended by Rene Brun; 2726 ; 2727void TH2::Smooth(Int_t ntimes, Option_t *option); 2728{; 2729 Double_t k5a[5][5] = { { 0, 0, 1, 0, 0 },; 2730 { 0, 2, 2, 2, 0 },",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:111184,Availability,error,errors,111184,"::ShowPeaks(Double_t sigma, Option_t *option, Double_t threshold); 2696{; 2697 ; 2698 return (Int_t)gROOT->ProcessLineFast(TString::Format(""TSpectrum2::StaticSearch((TH1*)0x%zx,%g,\""%s\"",%g)"",; 2699 (size_t)this, sigma, option, threshold).Data());; 2700}; 2701 ; 2702 ; 2703////////////////////////////////////////////////////////////////////////////////; 2704/// Smooth bin contents of this 2-d histogram using kernel algorithms; 2705/// similar to the ones used in the raster graphics community.; 2706/// Bin contents in the active range are replaced by their smooth values.; 2707/// The algorithm retains the input dimension by using Kernel Crop at the input boundaries.; 2708/// Kernel Crop sets any pixel in the kernel that extends past the input to zero and adjusts the; 2709/// normalization accordingly.; 2710/// If Errors are defined via Sumw2, they are also scaled and computed.; 2711/// However, note the resulting errors will be correlated between different-bins, so; 2712/// the errors should not be used blindly to perform any calculation involving several bins,; 2713/// like fitting the histogram. One would need to compute also the bin by bin correlation matrix.; 2714///; 2715/// 3 kernels are proposed k5a, k5b and k3a.; 2716/// k5a and k5b act on 5x5 cells (i-2,i-1,i,i+1,i+2, and same for j); 2717/// k5b is a bit more stronger in smoothing; 2718/// k3a acts only on 3x3 cells (i-1,i,i+1, and same for j).; 2719/// By default the kernel ""k5a"" is used. You can select the kernels ""k5b"" or ""k3a""; 2720/// via the option argument.; 2721/// If TAxis::SetRange has been called on the x or/and y axis, only the bins; 2722/// in the specified range are smoothed.; 2723/// In the current implementation if the first argument is not used (default value=1).; 2724///; 2725/// implementation by David McKee (dmckee@bama.ua.edu). Extended by Rene Brun; 2726 ; 2727void TH2::Smooth(Int_t ntimes, Option_t *option); 2728{; 2729 Double_t k5a[5][5] = { { 0, 0, 1, 0, 0 },; 2730 { 0, 2, 2, 2, 0 },",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:113987,Availability,error,error,113987," fXaxis.GetLast();; 2761 Int_t jfirst = fYaxis.GetFirst();; 2762 Int_t jlast = fYaxis.GetLast();; 2763 ; 2764 // Determine the size of the bin buffer(s) needed; 2765 Double_t nentries = fEntries;; 2766 Int_t nx = GetNbinsX();; 2767 Int_t ny = GetNbinsY();; 2768 Int_t bufSize = (nx+2)*(ny+2);; 2769 Double_t *buf = new Double_t[bufSize];; 2770 Double_t *ebuf = nullptr;; 2771 if (fSumw2.fN) ebuf = new Double_t[bufSize];; 2772 ; 2773 // Copy all the data to the temporary buffers; 2774 Int_t i,j,bin;; 2775 for (i=ifirst; i<=ilast; i++){; 2776 for (j=jfirst; j<=jlast; j++){; 2777 bin = GetBin(i,j);; 2778 buf[bin] = RetrieveBinContent(bin);; 2779 if (ebuf) ebuf[bin]=GetBinError(bin);; 2780 }; 2781 }; 2782 ; 2783 // Kernel tail sizes (kernel sizes must be odd for this to work!); 2784 Int_t x_push = (ksize_x-1)/2;; 2785 Int_t y_push = (ksize_y-1)/2;; 2786 ; 2787 // main work loop; 2788 for (i=ifirst; i<=ilast; i++){; 2789 for (j=jfirst; j<=jlast; j++) {; 2790 Double_t content = 0.0;; 2791 Double_t error = 0.0;; 2792 Double_t norm = 0.0;; 2793 ; 2794 for (Int_t n=0; n<ksize_x; n++) {; 2795 for (Int_t m=0; m<ksize_y; m++) {; 2796 Int_t xb = i+(n-x_push);; 2797 Int_t yb = j+(m-y_push);; 2798 if ( (xb >= 1) && (xb <= nx) && (yb >= 1) && (yb <= ny) ) {; 2799 bin = GetBin(xb,yb);; 2800 Double_t k = kernel[n*ksize_y +m];; 2801 //if ( (k != 0.0 ) && (buf[bin] != 0.0) ) { // General version probably does not want the second condition; 2802 if ( k != 0.0 ) {; 2803 norm += k;; 2804 content += k*buf[bin];; 2805 if (ebuf) error += k*k*ebuf[bin]*ebuf[bin];; 2806 }; 2807 }; 2808 }; 2809 }; 2810 ; 2811 if ( norm != 0.0 ) {; 2812 SetBinContent(i,j,content/norm);; 2813 if (ebuf) {; 2814 error /= (norm*norm);; 2815 SetBinError(i,j,sqrt(error));; 2816 }; 2817 }; 2818 }; 2819 }; 2820 fEntries = nentries;; 2821 ; 2822 delete [] buf;; 2823 delete [] ebuf;; 2824}; 2825 ; 2826 ; 2827////////////////////////////////////////////////////////////////////////////////; 2828/// Stream an object of class TH",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:114509,Availability,error,error,114509,"2776 for (j=jfirst; j<=jlast; j++){; 2777 bin = GetBin(i,j);; 2778 buf[bin] = RetrieveBinContent(bin);; 2779 if (ebuf) ebuf[bin]=GetBinError(bin);; 2780 }; 2781 }; 2782 ; 2783 // Kernel tail sizes (kernel sizes must be odd for this to work!); 2784 Int_t x_push = (ksize_x-1)/2;; 2785 Int_t y_push = (ksize_y-1)/2;; 2786 ; 2787 // main work loop; 2788 for (i=ifirst; i<=ilast; i++){; 2789 for (j=jfirst; j<=jlast; j++) {; 2790 Double_t content = 0.0;; 2791 Double_t error = 0.0;; 2792 Double_t norm = 0.0;; 2793 ; 2794 for (Int_t n=0; n<ksize_x; n++) {; 2795 for (Int_t m=0; m<ksize_y; m++) {; 2796 Int_t xb = i+(n-x_push);; 2797 Int_t yb = j+(m-y_push);; 2798 if ( (xb >= 1) && (xb <= nx) && (yb >= 1) && (yb <= ny) ) {; 2799 bin = GetBin(xb,yb);; 2800 Double_t k = kernel[n*ksize_y +m];; 2801 //if ( (k != 0.0 ) && (buf[bin] != 0.0) ) { // General version probably does not want the second condition; 2802 if ( k != 0.0 ) {; 2803 norm += k;; 2804 content += k*buf[bin];; 2805 if (ebuf) error += k*k*ebuf[bin]*ebuf[bin];; 2806 }; 2807 }; 2808 }; 2809 }; 2810 ; 2811 if ( norm != 0.0 ) {; 2812 SetBinContent(i,j,content/norm);; 2813 if (ebuf) {; 2814 error /= (norm*norm);; 2815 SetBinError(i,j,sqrt(error));; 2816 }; 2817 }; 2818 }; 2819 }; 2820 fEntries = nentries;; 2821 ; 2822 delete [] buf;; 2823 delete [] ebuf;; 2824}; 2825 ; 2826 ; 2827////////////////////////////////////////////////////////////////////////////////; 2828/// Stream an object of class TH2.; 2829 ; 2830void TH2::Streamer(TBuffer &R__b); 2831{; 2832 if (R__b.IsReading()) {; 2833 UInt_t R__s, R__c;; 2834 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 2835 if (R__v > 2) {; 2836 R__b.ReadClassBuffer(TH2::Class(), this, R__v, R__s, R__c);; 2837 return;; 2838 }; 2839 //====process old versions before automatic schema evolution; 2840 TH1::Streamer(R__b);; 2841 R__b >> fScalefactor;; 2842 R__b >> fTsumwy;; 2843 R__b >> fTsumwy2;; 2844 R__b >> fTsumwxy;; 2845 //====end of old versions; 2846 ; 2847 } else {; 2848 R__b.Write",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:114672,Availability,error,error,114672,"1)/2;; 2785 Int_t y_push = (ksize_y-1)/2;; 2786 ; 2787 // main work loop; 2788 for (i=ifirst; i<=ilast; i++){; 2789 for (j=jfirst; j<=jlast; j++) {; 2790 Double_t content = 0.0;; 2791 Double_t error = 0.0;; 2792 Double_t norm = 0.0;; 2793 ; 2794 for (Int_t n=0; n<ksize_x; n++) {; 2795 for (Int_t m=0; m<ksize_y; m++) {; 2796 Int_t xb = i+(n-x_push);; 2797 Int_t yb = j+(m-y_push);; 2798 if ( (xb >= 1) && (xb <= nx) && (yb >= 1) && (yb <= ny) ) {; 2799 bin = GetBin(xb,yb);; 2800 Double_t k = kernel[n*ksize_y +m];; 2801 //if ( (k != 0.0 ) && (buf[bin] != 0.0) ) { // General version probably does not want the second condition; 2802 if ( k != 0.0 ) {; 2803 norm += k;; 2804 content += k*buf[bin];; 2805 if (ebuf) error += k*k*ebuf[bin]*ebuf[bin];; 2806 }; 2807 }; 2808 }; 2809 }; 2810 ; 2811 if ( norm != 0.0 ) {; 2812 SetBinContent(i,j,content/norm);; 2813 if (ebuf) {; 2814 error /= (norm*norm);; 2815 SetBinError(i,j,sqrt(error));; 2816 }; 2817 }; 2818 }; 2819 }; 2820 fEntries = nentries;; 2821 ; 2822 delete [] buf;; 2823 delete [] ebuf;; 2824}; 2825 ; 2826 ; 2827////////////////////////////////////////////////////////////////////////////////; 2828/// Stream an object of class TH2.; 2829 ; 2830void TH2::Streamer(TBuffer &R__b); 2831{; 2832 if (R__b.IsReading()) {; 2833 UInt_t R__s, R__c;; 2834 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 2835 if (R__v > 2) {; 2836 R__b.ReadClassBuffer(TH2::Class(), this, R__v, R__s, R__c);; 2837 return;; 2838 }; 2839 //====process old versions before automatic schema evolution; 2840 TH1::Streamer(R__b);; 2841 R__b >> fScalefactor;; 2842 R__b >> fTsumwy;; 2843 R__b >> fTsumwy2;; 2844 R__b >> fTsumwxy;; 2845 //====end of old versions; 2846 ; 2847 } else {; 2848 R__b.WriteClassBuffer(TH2::Class(),this);; 2849 }; 2850}; 2851 ; 2852 ; 2853//______________________________________________________________________________; 2854// TH2C methods; 2855// TH2C a 2-D histogram with one byte per cell (char); 2856//______________________________________",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:114721,Availability,error,error,114721,"1)/2;; 2785 Int_t y_push = (ksize_y-1)/2;; 2786 ; 2787 // main work loop; 2788 for (i=ifirst; i<=ilast; i++){; 2789 for (j=jfirst; j<=jlast; j++) {; 2790 Double_t content = 0.0;; 2791 Double_t error = 0.0;; 2792 Double_t norm = 0.0;; 2793 ; 2794 for (Int_t n=0; n<ksize_x; n++) {; 2795 for (Int_t m=0; m<ksize_y; m++) {; 2796 Int_t xb = i+(n-x_push);; 2797 Int_t yb = j+(m-y_push);; 2798 if ( (xb >= 1) && (xb <= nx) && (yb >= 1) && (yb <= ny) ) {; 2799 bin = GetBin(xb,yb);; 2800 Double_t k = kernel[n*ksize_y +m];; 2801 //if ( (k != 0.0 ) && (buf[bin] != 0.0) ) { // General version probably does not want the second condition; 2802 if ( k != 0.0 ) {; 2803 norm += k;; 2804 content += k*buf[bin];; 2805 if (ebuf) error += k*k*ebuf[bin]*ebuf[bin];; 2806 }; 2807 }; 2808 }; 2809 }; 2810 ; 2811 if ( norm != 0.0 ) {; 2812 SetBinContent(i,j,content/norm);; 2813 if (ebuf) {; 2814 error /= (norm*norm);; 2815 SetBinError(i,j,sqrt(error));; 2816 }; 2817 }; 2818 }; 2819 }; 2820 fEntries = nentries;; 2821 ; 2822 delete [] buf;; 2823 delete [] ebuf;; 2824}; 2825 ; 2826 ; 2827////////////////////////////////////////////////////////////////////////////////; 2828/// Stream an object of class TH2.; 2829 ; 2830void TH2::Streamer(TBuffer &R__b); 2831{; 2832 if (R__b.IsReading()) {; 2833 UInt_t R__s, R__c;; 2834 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 2835 if (R__v > 2) {; 2836 R__b.ReadClassBuffer(TH2::Class(), this, R__v, R__s, R__c);; 2837 return;; 2838 }; 2839 //====process old versions before automatic schema evolution; 2840 TH1::Streamer(R__b);; 2841 R__b >> fScalefactor;; 2842 R__b >> fTsumwy;; 2843 R__b >> fTsumwy2;; 2844 R__b >> fTsumwxy;; 2845 //====end of old versions; 2846 ; 2847 } else {; 2848 R__b.WriteClassBuffer(TH2::Class(),this);; 2849 }; 2850}; 2851 ; 2852 ; 2853//______________________________________________________________________________; 2854// TH2C methods; 2855// TH2C a 2-D histogram with one byte per cell (char); 2856//______________________________________",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:120038,Availability,error,errors,120038,"// Increment bin content by 1.; 2956/// Passing an out-of-range bin leads to undefined behavior; 2957 ; 2958void TH2C::AddBinContent(Int_t bin); 2959{; 2960 if (fArray[bin] < 127) fArray[bin]++;; 2961}; 2962 ; 2963 ; 2964////////////////////////////////////////////////////////////////////////////////; 2965/// Increment bin content by w.; 2966/// \warning The value of w is cast to `Int_t` before being added.; 2967/// Passing an out-of-range bin leads to undefined behavior; 2968 ; 2969void TH2C::AddBinContent(Int_t bin, Double_t w); 2970{; 2971 Int_t newval = fArray[bin] + Int_t(w);; 2972 if (newval > -128 && newval < 128) {fArray[bin] = Char_t(newval); return;}; 2973 if (newval < -127) fArray[bin] = -127;; 2974 if (newval > 127) fArray[bin] = 127;; 2975}; 2976 ; 2977 ; 2978////////////////////////////////////////////////////////////////////////////////; 2979/// Copy.; 2980 ; 2981void TH2C::Copy(TObject &newth2) const; 2982{; 2983 TH2::Copy(newth2);; 2984}; 2985 ; 2986 ; 2987////////////////////////////////////////////////////////////////////////////////; 2988/// Reset this histogram: contents, errors, etc.; 2989 ; 2990void TH2C::Reset(Option_t *option); 2991{; 2992 TH2::Reset(option);; 2993 TArrayC::Reset();; 2994}; 2995 ; 2996 ; 2997////////////////////////////////////////////////////////////////////////////////; 2998/// Set total number of bins including under/overflow; 2999/// Reallocate bin contents array; 3000 ; 3001void TH2C::SetBinsLength(Int_t n); 3002{; 3003 if (n < 0) n = (fXaxis.GetNbins()+2)*(fYaxis.GetNbins()+2);; 3004 fNcells = n;; 3005 TArrayC::Set(n);; 3006}; 3007 ; 3008 ; 3009////////////////////////////////////////////////////////////////////////////////; 3010/// Stream an object of class TH2C.; 3011 ; 3012void TH2C::Streamer(TBuffer &R__b); 3013{; 3014 if (R__b.IsReading()) {; 3015 UInt_t R__s, R__c;; 3016 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 3017 if (R__v > 2) {; 3018 R__b.ReadClassBuffer(TH2C::Class(), this, R__v, R__s, R__c);; 3019 ",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:127710,Availability,error,errors,127710,"n content by 1.; 3220/// Passing an out-of-range bin leads to undefined behavior; 3221 ; 3222void TH2S::AddBinContent(Int_t bin); 3223{; 3224 if (fArray[bin] < 32767) fArray[bin]++;; 3225}; 3226 ; 3227 ; 3228////////////////////////////////////////////////////////////////////////////////; 3229/// Increment bin content by w.; 3230/// \warning The value of w is cast to `Int_t` before being added.; 3231/// Passing an out-of-range bin leads to undefined behavior; 3232 ; 3233void TH2S::AddBinContent(Int_t bin, Double_t w); 3234{; 3235 Int_t newval = fArray[bin] + Int_t(w);; 3236 if (newval > -32768 && newval < 32768) {fArray[bin] = Short_t(newval); return;}; 3237 if (newval < -32767) fArray[bin] = -32767;; 3238 if (newval > 32767) fArray[bin] = 32767;; 3239}; 3240 ; 3241 ; 3242////////////////////////////////////////////////////////////////////////////////; 3243/// Copy.; 3244 ; 3245void TH2S::Copy(TObject &newth2) const; 3246{; 3247 TH2::Copy(newth2);; 3248}; 3249 ; 3250 ; 3251////////////////////////////////////////////////////////////////////////////////; 3252/// Reset this histogram: contents, errors, etc.; 3253 ; 3254void TH2S::Reset(Option_t *option); 3255{; 3256 TH2::Reset(option);; 3257 TArrayS::Reset();; 3258}; 3259 ; 3260 ; 3261////////////////////////////////////////////////////////////////////////////////; 3262/// Set total number of bins including under/overflow; 3263/// Reallocate bin contents array; 3264 ; 3265void TH2S::SetBinsLength(Int_t n); 3266{; 3267 if (n < 0) n = (fXaxis.GetNbins()+2)*(fYaxis.GetNbins()+2);; 3268 fNcells = n;; 3269 TArrayS::Set(n);; 3270}; 3271 ; 3272 ; 3273////////////////////////////////////////////////////////////////////////////////; 3274/// Stream an object of class TH2S.; 3275 ; 3276void TH2S::Streamer(TBuffer &R__b); 3277{; 3278 if (R__b.IsReading()) {; 3279 UInt_t R__s, R__c;; 3280 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 3281 if (R__v > 2) {; 3282 R__b.ReadClassBuffer(TH2S::Class(), this, R__v, R__s, R__c);; 3283 ",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:135408,Availability,error,errors,135408,"/// Passing an out-of-range bin leads to undefined behavior; 3485 ; 3486void TH2I::AddBinContent(Int_t bin); 3487{; 3488 if (fArray[bin] < INT_MAX) fArray[bin]++;; 3489}; 3490 ; 3491 ; 3492////////////////////////////////////////////////////////////////////////////////; 3493/// Increment bin content by w.; 3494/// \warning The value of w is cast to `Long64_t` before being added.; 3495/// Passing an out-of-range bin leads to undefined behavior; 3496 ; 3497void TH2I::AddBinContent(Int_t bin, Double_t w); 3498{; 3499 Long64_t newval = fArray[bin] + Long64_t(w);; 3500 if (newval > -INT_MAX && newval < INT_MAX) {fArray[bin] = Int_t(newval); return;}; 3501 if (newval < -INT_MAX) fArray[bin] = -INT_MAX;; 3502 if (newval > INT_MAX) fArray[bin] = INT_MAX;; 3503}; 3504 ; 3505 ; 3506////////////////////////////////////////////////////////////////////////////////; 3507/// Copy.; 3508 ; 3509void TH2I::Copy(TObject &newth2) const; 3510{; 3511 TH2::Copy(newth2);; 3512}; 3513 ; 3514 ; 3515////////////////////////////////////////////////////////////////////////////////; 3516/// Reset this histogram: contents, errors, etc.; 3517 ; 3518void TH2I::Reset(Option_t *option); 3519{; 3520 TH2::Reset(option);; 3521 TArrayI::Reset();; 3522}; 3523 ; 3524 ; 3525////////////////////////////////////////////////////////////////////////////////; 3526/// Set total number of bins including under/overflow; 3527/// Reallocate bin contents array; 3528 ; 3529void TH2I::SetBinsLength(Int_t n); 3530{; 3531 if (n < 0) n = (fXaxis.GetNbins()+2)*(fYaxis.GetNbins()+2);; 3532 fNcells = n;; 3533 TArrayI::Set(n);; 3534}; 3535 ; 3536 ; 3537////////////////////////////////////////////////////////////////////////////////; 3538/// Operator =; 3539 ; 3540TH2I& TH2I::operator=(const TH2I &h2i); 3541{; 3542 if (this != &h2i); 3543 h2i.TH2I::Copy(*this);; 3544 return *this;; 3545}; 3546 ; 3547 ; 3548////////////////////////////////////////////////////////////////////////////////; 3549/// Operator *; 3550 ; 3551TH2I opera",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:142168,Availability,error,errors,142168," out-of-range bin leads to undefined behavior; 3714 ; 3715void TH2L::AddBinContent(Int_t bin); 3716{; 3717 if (fArray[bin] < LLONG_MAX) fArray[bin]++;; 3718}; 3719 ; 3720 ; 3721////////////////////////////////////////////////////////////////////////////////; 3722/// Increment bin content by w.; 3723/// \warning The value of w is cast to `Long64_t` before being added.; 3724/// Passing an out-of-range bin leads to undefined behavior; 3725 ; 3726void TH2L::AddBinContent(Int_t bin, Double_t w); 3727{; 3728 Long64_t newval = fArray[bin] + Long64_t(w);; 3729 if (newval > -LLONG_MAX && newval < LLONG_MAX) {fArray[bin] = Int_t(newval); return;}; 3730 if (newval < -LLONG_MAX) fArray[bin] = -LLONG_MAX;; 3731 if (newval > LLONG_MAX) fArray[bin] = LLONG_MAX;; 3732}; 3733 ; 3734 ; 3735////////////////////////////////////////////////////////////////////////////////; 3736/// Copy.; 3737 ; 3738void TH2L::Copy(TObject &newth2) const; 3739{; 3740 TH2::Copy(newth2);; 3741}; 3742 ; 3743 ; 3744////////////////////////////////////////////////////////////////////////////////; 3745/// Reset this histogram: contents, errors, etc.; 3746 ; 3747void TH2L::Reset(Option_t *option); 3748{; 3749 TH2::Reset(option);; 3750 TArrayL64::Reset();; 3751}; 3752 ; 3753 ; 3754////////////////////////////////////////////////////////////////////////////////; 3755/// Set total number of bins including under/overflow; 3756/// Reallocate bin contents array; 3757 ; 3758void TH2L::SetBinsLength(Int_t n); 3759{; 3760 if (n < 0) n = (fXaxis.GetNbins()+2)*(fYaxis.GetNbins()+2);; 3761 fNcells = n;; 3762 TArrayL64::Set(n);; 3763}; 3764 ; 3765 ; 3766////////////////////////////////////////////////////////////////////////////////; 3767/// Operator =; 3768 ; 3769TH2L& TH2L::operator=(const TH2L &h2l); 3770{; 3771 if (this != &h2l); 3772 h2l.TH2L::Copy(*this);; 3773 return *this;; 3774}; 3775 ; 3776 ; 3777////////////////////////////////////////////////////////////////////////////////; 3778/// Operator *; 3779 ; 3780TH2L o",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:148704,Availability,error,errors,148704,"TH2F::TH2F(const TMatrixFBase &m); 3935:TH2(""TMatrixFBase"","""",m.GetNcols(),m.GetColLwb(),1+m.GetColUpb(),m.GetNrows(),m.GetRowLwb(),1+m.GetRowUpb()); 3936{; 3937 TArrayF::Set(fNcells);; 3938 Int_t ilow = m.GetRowLwb();; 3939 Int_t iup = m.GetRowUpb();; 3940 Int_t jlow = m.GetColLwb();; 3941 Int_t jup = m.GetColUpb();; 3942 for (Int_t i=ilow;i<=iup;i++) {; 3943 for (Int_t j=jlow;j<=jup;j++) {; 3944 SetBinContent(j-jlow+1,i-ilow+1,m(i,j));; 3945 }; 3946 }; 3947}; 3948 ; 3949 ; 3950////////////////////////////////////////////////////////////////////////////////; 3951/// Copy constructor.; 3952/// The list of functions is not copied. (Use Clone() if needed); 3953 ; 3954TH2F::TH2F(const TH2F &h2f) : TH2(), TArrayF(); 3955{; 3956 h2f.TH2F::Copy(*this);; 3957}; 3958 ; 3959 ; 3960////////////////////////////////////////////////////////////////////////////////; 3961/// Copy.; 3962 ; 3963void TH2F::Copy(TObject &newth2) const; 3964{; 3965 TH2::Copy(newth2);; 3966}; 3967 ; 3968 ; 3969////////////////////////////////////////////////////////////////////////////////; 3970/// Reset this histogram: contents, errors, etc.; 3971 ; 3972void TH2F::Reset(Option_t *option); 3973{; 3974 TH2::Reset(option);; 3975 TArrayF::Reset();; 3976}; 3977 ; 3978 ; 3979////////////////////////////////////////////////////////////////////////////////; 3980/// Set total number of bins including under/overflow; 3981/// Reallocate bin contents array; 3982 ; 3983void TH2F::SetBinsLength(Int_t n); 3984{; 3985 if (n < 0) n = (fXaxis.GetNbins()+2)*(fYaxis.GetNbins()+2);; 3986 fNcells = n;; 3987 TArrayF::Set(n);; 3988}; 3989 ; 3990 ; 3991////////////////////////////////////////////////////////////////////////////////; 3992/// Stream an object of class TH2F.; 3993 ; 3994void TH2F::Streamer(TBuffer &R__b); 3995{; 3996 if (R__b.IsReading()) {; 3997 UInt_t R__s, R__c;; 3998 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 3999 if (R__v > 2) {; 4000 R__b.ReadClassBuffer(TH2F::Class(), this, R__v, R__s, R__c);; 4001 ",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:156615,Availability,error,errors,156615,"tNrows(),m.GetRowLwb(),1+m.GetRowUpb()); 4208{; 4209 TArrayD::Set(fNcells);; 4210 Int_t ilow = m.GetRowLwb();; 4211 Int_t iup = m.GetRowUpb();; 4212 Int_t jlow = m.GetColLwb();; 4213 Int_t jup = m.GetColUpb();; 4214 for (Int_t i=ilow;i<=iup;i++) {; 4215 for (Int_t j=jlow;j<=jup;j++) {; 4216 SetBinContent(j-jlow+1,i-ilow+1,m(i,j));; 4217 }; 4218 }; 4219 if (fgDefaultSumw2) Sumw2();; 4220}; 4221 ; 4222 ; 4223////////////////////////////////////////////////////////////////////////////////; 4224/// Copy constructor.; 4225/// The list of functions is not copied. (Use Clone() if needed); 4226 ; 4227TH2D::TH2D(const TH2D &h2d) : TH2(), TArrayD(); 4228{; 4229 // intentionally call virtual Copy method to warn if TProfile2D is copied; 4230 h2d.Copy(*this);; 4231}; 4232 ; 4233 ; 4234////////////////////////////////////////////////////////////////////////////////; 4235/// Copy.; 4236 ; 4237void TH2D::Copy(TObject &newth2) const; 4238{; 4239 TH2::Copy(newth2);; 4240}; 4241 ; 4242 ; 4243////////////////////////////////////////////////////////////////////////////////; 4244/// Reset this histogram: contents, errors, etc.; 4245 ; 4246void TH2D::Reset(Option_t *option); 4247{; 4248 TH2::Reset(option);; 4249 TArrayD::Reset();; 4250}; 4251 ; 4252 ; 4253////////////////////////////////////////////////////////////////////////////////; 4254/// Set total number of bins including under/overflow; 4255/// Reallocate bin contents array; 4256 ; 4257void TH2D::SetBinsLength(Int_t n); 4258{; 4259 if (n < 0) n = (fXaxis.GetNbins()+2)*(fYaxis.GetNbins()+2);; 4260 fNcells = n;; 4261 TArrayD::Set(n);; 4262}; 4263 ; 4264 ; 4265////////////////////////////////////////////////////////////////////////////////; 4266/// Stream an object of class TH2D.; 4267 ; 4268void TH2D::Streamer(TBuffer &R__b); 4269{; 4270 if (R__b.IsReading()) {; 4271 UInt_t R__s, R__c;; 4272 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 4273 if (R__v > 2) {; 4274 R__b.ReadClassBuffer(TH2D::Class(), this, R__v, R__s, R__c);; 4275 ",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:173495,Availability,error,error,173495,"reated, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::fBufferDouble_t * fBuffer[fBufferSize] entry bufferDefinition TH1.h:108; TH1::GetEffectiveEntriesvirtual Double_t GetEffectiveEntries() constNumber of effective entries of the histogram.Definition TH1.cxx:4448; TH1::Multiplyvirtual Bool_t Multiply(TF1 *f1, Double_t c1=1)Performs the operation:Definition TH1.cxx:6049; TH1::kXaxis@ kXaxisDefinition TH1.h:73; TH1::kYaxis@ kYaxisDefinition TH1.h:74; TH1::fNcellsInt_t fNcellsNumber of bins(1D), cells (2D) +U/Overflows.Definition TH1.h:89; TH1::Copyvoid Copy(TObject &hnew) const overrideCopy this histogram structure to newth1.Definition TH1.cxx:2671; TH1::fTsumwDouble_t fTsumwTotal Sum of weights.Definition TH1.h:96; TH1::fTsumw2Double_t fTsumw2Total Sum of squares of weights.Definition TH1.h:97; TH1::Classstatic TClass * Class(); TH1::DoIntegralvirtual Double_t DoIntegral(Int_t ix1, Int_t ix2, Int_t iy1, Int_t iy2, Int_t iz1, Int_t iz2, Double_t &err, Option_t *opt, Bool_t doerr=kFALSE) constInternal function compute integral and optionally the error between the limits specified by the bin n...Definition TH1.cxx:7977; TH1::fTsumwx2Double_t fTsumwx2Total Sum of weight*X*X.Definition TH1.h:99; TH1::GetStdDevvirtual Double_t GetStdDev(Int_t axis=1) constReturns the Standard Deviation (Sigma).Definition TH1.cxx:7607; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associated to bin number bin.Definition TH1.cxx:9063; TH1::GetMeanvirtual Double_t GetMean(Int_t axis=1) constFor axis = 1,2 or 3 returns the mean value of the histogram along X,Y or Z axis.Definition TH1.cxx:7535; TH1::GetDimensionvirtual Int_t GetDimension() constDefinition TH1.h:283; TH1::Streamervoid Streamer(TBuffer &) overrideStream a class object.Definition TH1.cxx:6933; TH1::kIsNotW@ kIsNotWHistogram is forced to be not weighted even when the histogram is fi",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:173913,Availability,error,error,173913," TH1::fNcellsInt_t fNcellsNumber of bins(1D), cells (2D) +U/Overflows.Definition TH1.h:89; TH1::Copyvoid Copy(TObject &hnew) const overrideCopy this histogram structure to newth1.Definition TH1.cxx:2671; TH1::fTsumwDouble_t fTsumwTotal Sum of weights.Definition TH1.h:96; TH1::fTsumw2Double_t fTsumw2Total Sum of squares of weights.Definition TH1.h:97; TH1::Classstatic TClass * Class(); TH1::DoIntegralvirtual Double_t DoIntegral(Int_t ix1, Int_t ix2, Int_t iy1, Int_t iy2, Int_t iz1, Int_t iz2, Double_t &err, Option_t *opt, Bool_t doerr=kFALSE) constInternal function compute integral and optionally the error between the limits specified by the bin n...Definition TH1.cxx:7977; TH1::fTsumwx2Double_t fTsumwx2Total Sum of weight*X*X.Definition TH1.h:99; TH1::GetStdDevvirtual Double_t GetStdDev(Int_t axis=1) constReturns the Standard Deviation (Sigma).Definition TH1.cxx:7607; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associated to bin number bin.Definition TH1.cxx:9063; TH1::GetMeanvirtual Double_t GetMean(Int_t axis=1) constFor axis = 1,2 or 3 returns the mean value of the histogram along X,Y or Z axis.Definition TH1.cxx:7535; TH1::GetDimensionvirtual Int_t GetDimension() constDefinition TH1.h:283; TH1::Streamervoid Streamer(TBuffer &) overrideStream a class object.Definition TH1.cxx:6933; TH1::kIsNotW@ kIsNotWHistogram is forced to be not weighted even when the histogram is filled with weighted.Definition TH1.h:172; TH1::CanExtendAllAxesvirtual Bool_t CanExtendAllAxes() constReturns true if all axes are extendable.Definition TH1.cxx:6636; TH1::Resetvirtual void Reset(Option_t *option="""")Reset this histogram: contents, errors, etc.Definition TH1.cxx:7103; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetNcellsvirtual Int_t GetNcells() constDefinition TH1.h:300; TH1::PutStatsvirtual void PutStats(Double_t *stats)Replace current statistics with the values in",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:174636,Availability,error,errors,174636,"mwx2Total Sum of weight*X*X.Definition TH1.h:99; TH1::GetStdDevvirtual Double_t GetStdDev(Int_t axis=1) constReturns the Standard Deviation (Sigma).Definition TH1.cxx:7607; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associated to bin number bin.Definition TH1.cxx:9063; TH1::GetMeanvirtual Double_t GetMean(Int_t axis=1) constFor axis = 1,2 or 3 returns the mean value of the histogram along X,Y or Z axis.Definition TH1.cxx:7535; TH1::GetDimensionvirtual Int_t GetDimension() constDefinition TH1.h:283; TH1::Streamervoid Streamer(TBuffer &) overrideStream a class object.Definition TH1.cxx:6933; TH1::kIsNotW@ kIsNotWHistogram is forced to be not weighted even when the histogram is filled with weighted.Definition TH1.h:172; TH1::CanExtendAllAxesvirtual Bool_t CanExtendAllAxes() constReturns true if all axes are extendable.Definition TH1.cxx:6636; TH1::Resetvirtual void Reset(Option_t *option="""")Reset this histogram: contents, errors, etc.Definition TH1.cxx:7103; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetNcellsvirtual Int_t GetNcells() constDefinition TH1.h:300; TH1::PutStatsvirtual void PutStats(Double_t *stats)Replace current statistics with the values in array stats.Definition TH1.cxx:7884; TH1::GetPainterTVirtualHistPainter * GetPainter(Option_t *option="""")Return pointer to painter.Definition TH1.cxx:4511; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::GetBinvirtual Int_t GetBin(Int_t binx, Int_t biny=0, Int_t binz=0) constReturn Global bin number corresponding to binx,y,z.Definition TH1.cxx:4961; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:175574,Availability,error,errors,175574,"Definition TH1.cxx:6636; TH1::Resetvirtual void Reset(Option_t *option="""")Reset this histogram: contents, errors, etc.Definition TH1.cxx:7103; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetNcellsvirtual Int_t GetNcells() constDefinition TH1.h:300; TH1::PutStatsvirtual void PutStats(Double_t *stats)Replace current statistics with the values in array stats.Definition TH1.cxx:7884; TH1::GetPainterTVirtualHistPainter * GetPainter(Option_t *option="""")Return pointer to painter.Definition TH1.cxx:4511; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::GetBinvirtual Int_t GetBin(Int_t binx, Int_t biny=0, Int_t binz=0) constReturn Global bin number corresponding to binx,y,z.Definition TH1.cxx:4961; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; TH1::fBufferSizeInt_t fBufferSizefBuffer sizeDefinition TH1.h:107; TH1::RetrieveBinContentvirtual Double_t RetrieveBinContent(Int_t bin) constRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.cxx:9439; TH1::fDimensionInt_t fDimension! Histogram dimension (1, 2 or 3 dim)Definition TH1.h:110; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::fgBufferSizestatic Int_t fgBufferSize! Default buffer size for automatic histogramsDefinition TH1.h:115; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with o",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:176059,Availability,error,error,176059,"(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::GetBinvirtual Int_t GetBin(Int_t binx, Int_t biny=0, Int_t binz=0) constReturn Global bin number corresponding to binx,y,z.Definition TH1.cxx:4961; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; TH1::fBufferSizeInt_t fBufferSizefBuffer sizeDefinition TH1.h:107; TH1::RetrieveBinContentvirtual Double_t RetrieveBinContent(Int_t bin) constRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.cxx:9439; TH1::fDimensionInt_t fDimension! Histogram dimension (1, 2 or 3 dim)Definition TH1.h:110; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::fgBufferSizestatic Int_t fgBufferSize! Default buffer size for automatic histogramsDefinition TH1.h:115; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::GetBinErrorSqUncheckedvirtual Double_t GetBinErrorSqUnchecked(Int_t bin) constDefinition TH1.h:449; TH1::GetAxisLabelStatusUInt_t GetAxisLabelStatus() constInternal function used in TH1::Fill to see which axis is full alphanumeric, i.e.Definition TH1.cxx:6675; TH1::fIntegralDouble_t * fIntegral! Integral of bins used by GetRandomDefinition TH1.h:111; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Double_t content)Set bin content see convention for numbering bins in TH1::GetBin In case the bin numbe",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:179599,Availability,error,errors,179599,"is such that x is in the axis range.Definition TH1.cxx:6504; TH1::fSumw2TArrayD fSumw2Array of sum of squares of weights.Definition TH1.h:104; TH1::Scalevirtual void Scale(Double_t c1=1, Option_t *option="""")Multiply this histogram by a constant c1.Definition TH1.cxx:6604; TH1::GetSumw2Nvirtual Int_t GetSumw2N() constDefinition TH1.h:315; TH1::FindBinvirtual Int_t FindBin(Double_t x, Double_t y=0, Double_t z=0)Return Global bin number corresponding to x,y,z.Definition TH1.cxx:3672; TH1::GetStatOverflowsBehaviourBool_t GetStatOverflowsBehaviour() constDefinition TH1.h:152; TH1::GetQuantilesvirtual Int_t GetQuantiles(Int_t n, Double_t *xp, const Double_t *p=nullptr)Compute Quantiles for this histogram Quantile x_p := Q(p) is defined as the value x_p such that the c...Definition TH1.cxx:4611; TH1::CloneTObject * Clone(const char *newname="""") const overrideMake a complete copy of the underlying object.Definition TH1.cxx:2752; TH1::Dividevirtual Bool_t Divide(TF1 *f1, Double_t c1=1)Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:2840; TH1::fYaxisTAxis fYaxisY axis descriptor.Definition TH1.h:91; TH1::fPainterTVirtualHistPainter * fPainter! Pointer to histogram painterDefinition TH1.h:112; TH1::SetBinsvirtual void SetBins(Int_t nx, Double_t xmin, Double_t xmax)Redefine x axis parameters.Definition TH1.cxx:8767; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create structure to store sum of squares of weights.Definition TH1.cxx:9020; TH1::SetEntriesvirtual void SetEntries(Double_t n)Definition TH1.h:391; TH1::fgDefaultSumw2static Bool_t fgDefaultSumw2! Flag to call TH1::Sumw2 automatically at histogram creation timeDefinition TH1.h:118; TH1::fTsumwxDouble_t fTsumwxTotal Sum of weight*X.Definition TH1.h:98; TH1::ComputeIntegralvirtual Double_t ComputeIntegral(Bool_t onlyPositive=false)Compute integral (normalized cumulative sum of bins) w/o under/overflows The result is stored in fInt...Definition TH1.cxx:2537; TH2C2-D",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:180724,Availability,error,errors,180724,"sY axis descriptor.Definition TH1.h:91; TH1::fPainterTVirtualHistPainter * fPainter! Pointer to histogram painterDefinition TH1.h:112; TH1::SetBinsvirtual void SetBins(Int_t nx, Double_t xmin, Double_t xmax)Redefine x axis parameters.Definition TH1.cxx:8767; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create structure to store sum of squares of weights.Definition TH1.cxx:9020; TH1::SetEntriesvirtual void SetEntries(Double_t n)Definition TH1.h:391; TH1::fgDefaultSumw2static Bool_t fgDefaultSumw2! Flag to call TH1::Sumw2 automatically at histogram creation timeDefinition TH1.h:118; TH1::fTsumwxDouble_t fTsumwxTotal Sum of weight*X.Definition TH1.h:98; TH1::ComputeIntegralvirtual Double_t ComputeIntegral(Bool_t onlyPositive=false)Compute integral (normalized cumulative sum of bins) w/o under/overflows The result is stored in fInt...Definition TH1.cxx:2537; TH2C2-D histogram with a byte per channel (see TH1 documentation)Definition TH2.h:139; TH2C::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH2.cxx:2990; TH2C::Classstatic TClass * Class(); TH2C::IsATClass * IsA() const overrideDefinition TH2.h:176; TH2C::Streamervoid Streamer(TBuffer &) overrideStream an object of class TH2C.Definition TH2.cxx:3012; TH2C::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH2.cxx:2958; TH2C::TH2CTH2C()Constructor.Definition TH2.cxx:2864; TH2C::operator=TH2C & operator=(const TH2C &h1)Operator =.Definition TH2.cxx:3047; TH2C::~TH2C~TH2C() overrideDestructor.Definition TH2.cxx:2874; TH2C::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH2.cxx:2981; TH2C::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH2.cxx:3001; TH2D2-D histogram with a double per channel (see TH1 documentation)Definition TH2.h:357; TH2D::Streamervoid Streamer(TBuffer &) overrideStream an object of class TH2D.Definiti",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:189452,Availability,error,errors,189452,"efinition TH2.cxx:2616; TH2::BufferEmptyInt_t BufferEmpty(Int_t action=0) overrideFill histogram with all entries in the buffer.Definition TH2.cxx:278; TH2::DoFitSlicesvirtual void DoFitSlices(bool onX, TF1 *f1, Int_t firstbin, Int_t lastbin, Int_t cut, Option_t *option, TObjArray *arr)Definition TH2.cxx:814; TH2::QuantilesXTH1D * QuantilesX(Double_t prob=0.5, const char *name=""_qx"") constCompute the X distribution of quantiles in the other variable Y name is the name of the returned hist...Definition TH2.cxx:2505; TH2::SetShowProjectionYvirtual void SetShowProjectionY(Int_t nbins=1)When the mouse is moved in a pad containing a 2-d view of this histogram a second canvas shows the pr...Definition TH2.cxx:2650; TH2::FillRandomvoid FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr) overrideFill histogram following distribution in function fname.Definition TH2.cxx:714; TH2::IsATClass * IsA() const overrideDefinition TH2.h:133; TH2::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH2.cxx:2600; TH2::fScalefactorDouble_t fScalefactorScale factor.Definition TH2.h:33; TH2::DoProjectionvirtual TH1D * DoProjection(bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) constInternal (protected) method for performing projection on the X or Y axis called by ProjectionX or Pro...Definition TH2.cxx:2169; TH2::RebinXTH2 * RebinX(Int_t ngroup=2, const char *newname="""") overrideRebin only the X axis see Rebin2D.Definition TH2.cxx:1642; TH2::fTsumwy2Double_t fTsumwy2Total Sum of weight*Y*Y.Definition TH2.h:35; TH2::GetRandom2virtual void GetRandom2(Double_t &x, Double_t &y, TRandom *rng=nullptr)Return 2 random numbers along axis x and y distributed according to the cell-contents of this 2-D his...Definition TH2.cxx:1200; TH2::GetCovariancevirtual Double_t GetCovariance(Int_t axis1=1, Int_t axis2=2) constReturn covariance between axis1 and axis2.Definition TH2.cxx:1163; TH2::GetBinInt_t GetBin(I",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:195732,Availability,error,error,195732,"onstUse this method to implement an ""abstract"" method that you don't want to leave purely abstract.Definition TObject.cxx:1035; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TProfileProfile Histogram.Definition TProfile.h:32; TProfile::Classstatic TClass * Class(); TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::FirstSsiz_t First(char c) constFind first occurrence of a character c.Definition TString.cxx:538; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::ToUppervoid ToUpper()Change string to upper case.D",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:198692,Availability,down,downward,198692,"t_t y)=0; TVirtualHistPainter::SetShowProjectionXYvirtual void SetShowProjectionXY(const char *option, Int_t nbinsY, Int_t nbinsX)=0; TVirtualPad::TContextsmall helper class to store/restore gPad context in TPad methodsDefinition TVirtualPad.h:61; bool; double; int; unsigned int; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; h1TH1F * h1Definition legend1.C:5; f1TF1 * f1Definition legend1.C:11; TMath::GausDouble_t Gaus(Double_t x, Double_t mean=0, Double_t sigma=1, Bool_t norm=kFALSE)Calculates a gaussian function with mean and sigma.Definition TMath.cxx:471; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf...Definition TMath.cxx:637; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::KolmogorovProbDouble_t KolmogorovProb(Double_t z)Calculates the Kolmogorov distribution function,.Definition TMath.cxx:679; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; mTMarker mDefinition textangle.C:8. histhistsrcTH2.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:27262,Deployability,integrat,integrated,27262,"0) continue;; 673 bin = biny*(fXaxis.GetNbins()+2) + binx;; 674 if (w) ww = w[i];; 675 if (!fSumw2.fN && ww != 1.0 && !TestBit(TH1::kIsNotW)) Sumw2();; 676 if (fSumw2.fN) fSumw2.fArray[bin] += ww*ww;; 677 AddBinContent(bin,ww);; 678 if (binx == 0 || binx > fXaxis.GetNbins()) {; 679 if (!GetStatOverflowsBehaviour()) continue;; 680 }; 681 if (biny == 0 || biny > fYaxis.GetNbins()) {; 682 if (!GetStatOverflowsBehaviour()) continue;; 683 }; 684 Double_t z= ww; //(ww > 0 ? ww : -ww);; 685 fTsumw += z;; 686 fTsumw2 += z*z;; 687 fTsumwx += z*x[i];; 688 fTsumwx2 += z*x[i]*x[i];; 689 fTsumwy += z*y[i];; 690 fTsumwy2 += z*y[i]*y[i];; 691 fTsumwxy += z*x[i]*y[i];; 692 }; 693}; 694 ; 695 ; 696////////////////////////////////////////////////////////////////////////////////; 697/// Fill histogram following distribution in function fname.; 698///; 699/// @param fname : Function name used for filling the histogram; 700/// @param ntimes : number of times the histogram is filled; 701/// @param rng : (optional) Random number generator used to sample; 702///; 703/// The distribution contained in the function fname (TF2) is integrated; 704/// over the channel contents.; 705/// It is normalized to 1.; 706/// Getting one random number implies:; 707/// - Generating a random number between 0 and 1 (say r1); 708/// - Look in which bin in the normalized integral r1 corresponds to; 709/// - Fill histogram channel; 710/// ntimes random numbers are generated; 711///; 712/// One can also call TF2::GetRandom2 to get a random variate from a function.; 713 ; 714void TH2::FillRandom(const char *fname, Int_t ntimes, TRandom * rng); 715{; 716 Int_t bin, binx, biny, ibin, loop;; 717 Double_t r1, x, y;; 718 //*-*- Search for fname in the list of ROOT defined functions; 719 TObject *fobj = gROOT->GetFunction(fname);; 720 if (!fobj) { Error(""FillRandom"", ""Unknown function: %s"",fname); return; }; 721 TF2 * f1 = dynamic_cast<TF2*>(fobj);; 722 if (!f1) { Error(""FillRandom"", ""Function: %s is not a TF2, is a %s""",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:30338,Deployability,integrat,integrated,30338,"ge(biny));; 751 integral[ibin] = integral[ibin-1] + fint;; 752 }; 753 }; 754 ; 755 // Normalize integral to 1; 756 if (integral[nbins] == 0 ) {; 757 delete [] integral;; 758 Error(""FillRandom"", ""Integral = zero""); return;; 759 }; 760 for (bin=1;bin<=nbins;bin++) integral[bin] /= integral[nbins];; 761 ; 762 // Start main loop ntimes; 763 for (loop=0;loop<ntimes;loop++) {; 764 r1 = (rng) ? rng->Rndm() : gRandom->Rndm();; 765 ibin = TMath::BinarySearch(nbins,&integral[0],r1);; 766 biny = ibin/nbinsx;; 767 binx = 1 + ibin - nbinsx*biny;; 768 biny++;; 769 x = xAxis.GetBinCenter(binx);; 770 y = yAxis.GetBinCenter(biny);; 771 Fill(x,y);; 772 }; 773 delete [] integral;; 774}; 775 ; 776 ; 777////////////////////////////////////////////////////////////////////////////////; 778/// Fill histogram following distribution in histogram h.; 779///; 780/// @param h : Histogram pointer used for sampling random number; 781/// @param ntimes : number of times the histogram is filled; 782/// @param rng : (optional) Random number generator used for sampling; 783///; 784/// The distribution contained in the histogram h (TH2) is integrated; 785/// over the channel contents.; 786/// It is normalized to 1.; 787/// Getting one random number implies:; 788/// - Generating a random number between 0 and 1 (say r1); 789/// - Look in which bin in the normalized integral r1 corresponds to; 790/// - Fill histogram channel; 791/// ntimes random numbers are generated; 792 ; 793void TH2::FillRandom(TH1 *h, Int_t ntimes, TRandom * rng); 794{; 795 if (!h) { Error(""FillRandom"", ""Null histogram""); return; }; 796 if (fDimension != h->GetDimension()) {; 797 Error(""FillRandom"", ""Histograms with different dimensions""); return;; 798 }; 799 ; 800 if (h->ComputeIntegral() == 0) return;; 801 ; 802 Int_t loop;; 803 Double_t x,y;; 804 TH2 *h2 = (TH2*)h;; 805 for (loop=0;loop<ntimes;loop++) {; 806 h2->GetRandom2(x,y,rng);; 807 Fill(x,y);; 808 }; 809}; 810 ; 811 ; 812//////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:81041,Deployability,integrat,integrated,81041,">SetLineColor(this->GetLineColor());; 1994 h1->SetFillColor(this->GetFillColor());; 1995 h1->SetMarkerColor(this->GetMarkerColor());; 1996 h1->SetMarkerStyle(this->GetMarkerStyle());; 1997 ; 1998 // check if histogram is weighted; 1999 // in case need to store sum of weight square/bin for the profile; 2000 TArrayD & binSumw2 = *(h1->GetBinSumw2());; 2001 bool useWeights = (GetSumw2N() > 0);; 2002 if (useWeights && (binSumw2.fN != h1->GetNcells()) ) h1->Sumw2();; 2003 // we need to set this bit because we fill the profile using a single Fill for many entries; 2004 // This is needed for the changes applied to make automatically the histogram weighted in ROOT 6 versions; 2005 else h1->SetBit(TH1::kIsNotW);; 2006 ; 2007 // Fill the profile histogram; 2008 // no entries/bin is available so can fill only using bin content as weight; 2009 ; 2010 // implement filling of projected histogram; 2011 // outbin is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; 2012 // inbin is the axis being integrated. Loop is done only on the selected bins; 2013 for ( Int_t outbin = 0; outbin <= outAxis.GetNbins() + 1; ++outbin) {; 2014 if (outAxis.TestBit(TAxis::kAxisRange) && ( outbin < firstOutBin || outbin > lastOutBin )) continue;; 2015 ; 2016 // find corresponding bin number in h1 for outbin (binOut); 2017 Double_t xOut = outAxis.GetBinCenter(outbin);; 2018 Int_t binOut = h1->GetXaxis()->FindBin( xOut );; 2019 if (binOut <0) continue;; 2020 ; 2021 for (Int_t inbin = firstbin ; inbin <= lastbin ; ++inbin) {; 2022 Int_t binx, biny;; 2023 if (onX) { binx = outbin; biny=inbin; }; 2024 else { binx = inbin; biny=outbin; }; 2025 ; 2026 if (ncuts) {; 2027 if (!fPainter->IsInside(binx,biny)) continue;; 2028 }; 2029 Int_t bin = GetBin(binx, biny);; 2030 Double_t cxy = RetrieveBinContent(bin);; 2031 ; 2032 ; 2033 if (cxy) {; 2034 Double_t tmp = 0;; 2035 // the following fill update wrongly the fBinSumw2- need to save it before; 2036 if ( useWeights ) tmp = binS",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:81922,Deployability,update,update,81922,"h1->SetBit(TH1::kIsNotW);; 2006 ; 2007 // Fill the profile histogram; 2008 // no entries/bin is available so can fill only using bin content as weight; 2009 ; 2010 // implement filling of projected histogram; 2011 // outbin is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; 2012 // inbin is the axis being integrated. Loop is done only on the selected bins; 2013 for ( Int_t outbin = 0; outbin <= outAxis.GetNbins() + 1; ++outbin) {; 2014 if (outAxis.TestBit(TAxis::kAxisRange) && ( outbin < firstOutBin || outbin > lastOutBin )) continue;; 2015 ; 2016 // find corresponding bin number in h1 for outbin (binOut); 2017 Double_t xOut = outAxis.GetBinCenter(outbin);; 2018 Int_t binOut = h1->GetXaxis()->FindBin( xOut );; 2019 if (binOut <0) continue;; 2020 ; 2021 for (Int_t inbin = firstbin ; inbin <= lastbin ; ++inbin) {; 2022 Int_t binx, biny;; 2023 if (onX) { binx = outbin; biny=inbin; }; 2024 else { binx = inbin; biny=outbin; }; 2025 ; 2026 if (ncuts) {; 2027 if (!fPainter->IsInside(binx,biny)) continue;; 2028 }; 2029 Int_t bin = GetBin(binx, biny);; 2030 Double_t cxy = RetrieveBinContent(bin);; 2031 ; 2032 ; 2033 if (cxy) {; 2034 Double_t tmp = 0;; 2035 // the following fill update wrongly the fBinSumw2- need to save it before; 2036 if ( useWeights ) tmp = binSumw2.fArray[binOut];; 2037 h1->Fill( xOut, inAxis.GetBinCenter(inbin), cxy );; 2038 if ( useWeights ) binSumw2.fArray[binOut] = tmp + fSumw2.fArray[bin];; 2039 }; 2040 ; 2041 }; 2042 }; 2043 ; 2044 // the statistics must be recalculated since by using the Fill method the total sum of weight^2 is; 2045 // not computed correctly; 2046 // for a profile does not much sense to re-use statistics of original TH2; 2047 h1->ResetStats();; 2048 // Also we need to set the entries since they have not been correctly calculated during the projection; 2049 // we can only set them to the effective entries; 2050 h1->SetEntries( h1->GetEffectiveEntries() );; 2051 ; 2052 ; 2053 if (opt.Contains(""d",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:93886,Deployability,integrat,integrated,93886,";; 2279 }; 2280 if (opt.Contains(""e"") || GetSumw2N() ) h1->Sumw2();; 2281 }; 2282 if (pname != name) delete [] pname;; 2283 ; 2284 // Copy the axis attributes and the axis labels if needed.; 2285 h1->GetXaxis()->ImportAttributes(outAxis);; 2286 THashList* labels=outAxis->GetLabels();; 2287 if (labels) {; 2288 TIter iL(labels);; 2289 TObjString* lb;; 2290 Int_t i = 1;; 2291 while ((lb=(TObjString*)iL())) {; 2292 h1->GetXaxis()->SetBinLabel(i,lb->String().Data());; 2293 i++;; 2294 }; 2295 }; 2296 ; 2297 h1->SetLineColor(this->GetLineColor());; 2298 h1->SetFillColor(this->GetFillColor());; 2299 h1->SetMarkerColor(this->GetMarkerColor());; 2300 h1->SetMarkerStyle(this->GetMarkerStyle());; 2301 ; 2302 // Fill the projected histogram; 2303 Double_t cont,err2;; 2304 Double_t totcont = 0;; 2305 Bool_t computeErrors = h1->GetSumw2N();; 2306 ; 2307 // implement filling of projected histogram; 2308 // outbin is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; 2309 // inbin is the axis being integrated. Loop is done only on the selected bins; 2310 // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins; 2311 Bool_t extendable = outAxis->CanExtend();; 2312 if ( labels && extendable ) h1->GetXaxis()->SetCanExtend(kFALSE);; 2313 for ( Int_t outbin = 0; outbin <= outAxis->GetNbins() + 1; ++outbin) {; 2314 err2 = 0;; 2315 cont = 0;; 2316 if (outAxis->TestBit(TAxis::kAxisRange) && ( outbin < firstOutBin || outbin > lastOutBin )) continue;; 2317 ; 2318 for (Int_t inbin = firstbin ; inbin <= lastbin ; ++inbin) {; 2319 Int_t binx, biny;; 2320 if (onX) { binx = outbin; biny=inbin; }; 2321 else { binx = inbin; biny=outbin; }; 2322 ; 2323 if (ncuts) {; 2324 if (!fPainter->IsInside(binx,biny)) continue;; 2325 }; 2326 // sum bin content and error if needed; 2327 cont += GetBinContent(binx,biny);; 2328 if (computeErrors) {; 2329 Double_t exy = GetBinError(binx,biny);; 2330 err2 += exy*exy;; 2331 }; 2332 ",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:178159,Deployability,update,update,178159,"LowEdge(Int_t bin) constReturn bin lower edge for 1D histogram.Definition TH1.cxx:9152; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::ResetStatsvirtual void ResetStats()Reset the statistics including the number of entries and replace with values calculated from bin cont...Definition TH1.cxx:7902; TH1::SetBuffervirtual void SetBuffer(Int_t buffersize, Option_t *option="""")Set the maximum number of entries to be kept in the buffer.Definition TH1.cxx:8458; TH1::kNstat@ kNstatSize of statistics data (up to TProfile3D)Definition TH1.h:184; TH1::fEntriesDouble_t fEntriesNumber of entries.Definition TH1.h:95; TH1::UpdateBinContentvirtual void UpdateBinContent(Int_t bin, Double_t content)Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH1.cxx:9449; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::fXaxisTAxis fXaxisX axis descriptor.Definition TH1.h:90; TH1::ExtendAxisvirtual void ExtendAxis(Double_t x, TAxis *axis)Histogram is resized along axis such that x is in the axis range.Definition TH1.cxx:6504; TH1::fSumw2TArrayD fSumw2Array of sum of squares of weights.Definition TH1.h:104; TH1::Scalevirtual void Scale(Double_t c1=1, Option_t *option="""")Multiply this histogram by a constant c1.Definition TH1.cxx:6604; TH1::GetSumw2Nvirtual Int_t GetSumw2N() constDefinition TH1.h:315; TH1::FindBinvirtual Int_t FindBin(Double_t x, Double_t y=0, Double_t z=0)Return Global bin number corresponding to x,y,z.Definition TH1.cxx:3672; TH1::GetStatOverflowsBehaviourBool_t GetStatOverflowsBehaviour() constDefinition TH1.h:152; TH1::GetQuantilesvirtual ",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:59648,Energy Efficiency,adapt,adapted,59648,"2, using Kolmogorov test.; 1450/// Default: Ignore under- and overflow bins in comparison; 1451///; 1452/// option is a character string to specify options; 1453/// - ""U"" include Underflows in test; 1454/// - ""O"" include Overflows; 1455/// - ""N"" include comparison of normalizations; 1456/// - ""D"" Put out a line of ""Debug"" printout; 1457/// - ""M"" Return the Maximum Kolmogorov distance instead of prob; 1458///; 1459/// The returned function value is the probability of test; 1460/// (much less than one means NOT compatible); 1461///; 1462/// The KS test uses the distance between the pseudo-CDF's obtained; 1463/// from the histogram. Since in 2D the order for generating the pseudo-CDF is; 1464/// arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; 1465/// other from the y axis and the maximum distance is the average of the two maximum; 1466/// distances obtained.; 1467///; 1468/// Code adapted by Rene Brun from original HBOOK routine HDIFF; 1469 ; 1470Double_t TH2::KolmogorovTest(const TH1 *h2, Option_t *option) const; 1471{; 1472 TString opt = option;; 1473 opt.ToUpper();; 1474 ; 1475 Double_t prb = 0;; 1476 TH1 *h1 = (TH1*)this;; 1477 if (h2 == nullptr) return 0;; 1478 const TAxis *xaxis1 = h1->GetXaxis();; 1479 const TAxis *xaxis2 = h2->GetXaxis();; 1480 const TAxis *yaxis1 = h1->GetYaxis();; 1481 const TAxis *yaxis2 = h2->GetYaxis();; 1482 Int_t ncx1 = xaxis1->GetNbins();; 1483 Int_t ncx2 = xaxis2->GetNbins();; 1484 Int_t ncy1 = yaxis1->GetNbins();; 1485 Int_t ncy2 = yaxis2->GetNbins();; 1486 ; 1487 // Check consistency of dimensions; 1488 if (h1->GetDimension() != 2 || h2->GetDimension() != 2) {; 1489 Error(""KolmogorovTest"",""Histograms must be 2-D\n"");; 1490 return 0;; 1491 }; 1492 ; 1493 // Check consistency in number of channels; 1494 if (ncx1 != ncx2) {; 1495 Error(""KolmogorovTest"",""Number of channels in X is different, %d and %d\n"",ncx1,ncx2);; 1496 return 0;; 1497 }; 1498 if (ncy1 != ncy2) {; 1499 Error(""KolmogorovTest"",""Number of ch",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:27262,Integrability,integrat,integrated,27262,"0) continue;; 673 bin = biny*(fXaxis.GetNbins()+2) + binx;; 674 if (w) ww = w[i];; 675 if (!fSumw2.fN && ww != 1.0 && !TestBit(TH1::kIsNotW)) Sumw2();; 676 if (fSumw2.fN) fSumw2.fArray[bin] += ww*ww;; 677 AddBinContent(bin,ww);; 678 if (binx == 0 || binx > fXaxis.GetNbins()) {; 679 if (!GetStatOverflowsBehaviour()) continue;; 680 }; 681 if (biny == 0 || biny > fYaxis.GetNbins()) {; 682 if (!GetStatOverflowsBehaviour()) continue;; 683 }; 684 Double_t z= ww; //(ww > 0 ? ww : -ww);; 685 fTsumw += z;; 686 fTsumw2 += z*z;; 687 fTsumwx += z*x[i];; 688 fTsumwx2 += z*x[i]*x[i];; 689 fTsumwy += z*y[i];; 690 fTsumwy2 += z*y[i]*y[i];; 691 fTsumwxy += z*x[i]*y[i];; 692 }; 693}; 694 ; 695 ; 696////////////////////////////////////////////////////////////////////////////////; 697/// Fill histogram following distribution in function fname.; 698///; 699/// @param fname : Function name used for filling the histogram; 700/// @param ntimes : number of times the histogram is filled; 701/// @param rng : (optional) Random number generator used to sample; 702///; 703/// The distribution contained in the function fname (TF2) is integrated; 704/// over the channel contents.; 705/// It is normalized to 1.; 706/// Getting one random number implies:; 707/// - Generating a random number between 0 and 1 (say r1); 708/// - Look in which bin in the normalized integral r1 corresponds to; 709/// - Fill histogram channel; 710/// ntimes random numbers are generated; 711///; 712/// One can also call TF2::GetRandom2 to get a random variate from a function.; 713 ; 714void TH2::FillRandom(const char *fname, Int_t ntimes, TRandom * rng); 715{; 716 Int_t bin, binx, biny, ibin, loop;; 717 Double_t r1, x, y;; 718 //*-*- Search for fname in the list of ROOT defined functions; 719 TObject *fobj = gROOT->GetFunction(fname);; 720 if (!fobj) { Error(""FillRandom"", ""Unknown function: %s"",fname); return; }; 721 TF2 * f1 = dynamic_cast<TF2*>(fobj);; 722 if (!f1) { Error(""FillRandom"", ""Function: %s is not a TF2, is a %s""",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:30338,Integrability,integrat,integrated,30338,"ge(biny));; 751 integral[ibin] = integral[ibin-1] + fint;; 752 }; 753 }; 754 ; 755 // Normalize integral to 1; 756 if (integral[nbins] == 0 ) {; 757 delete [] integral;; 758 Error(""FillRandom"", ""Integral = zero""); return;; 759 }; 760 for (bin=1;bin<=nbins;bin++) integral[bin] /= integral[nbins];; 761 ; 762 // Start main loop ntimes; 763 for (loop=0;loop<ntimes;loop++) {; 764 r1 = (rng) ? rng->Rndm() : gRandom->Rndm();; 765 ibin = TMath::BinarySearch(nbins,&integral[0],r1);; 766 biny = ibin/nbinsx;; 767 binx = 1 + ibin - nbinsx*biny;; 768 biny++;; 769 x = xAxis.GetBinCenter(binx);; 770 y = yAxis.GetBinCenter(biny);; 771 Fill(x,y);; 772 }; 773 delete [] integral;; 774}; 775 ; 776 ; 777////////////////////////////////////////////////////////////////////////////////; 778/// Fill histogram following distribution in histogram h.; 779///; 780/// @param h : Histogram pointer used for sampling random number; 781/// @param ntimes : number of times the histogram is filled; 782/// @param rng : (optional) Random number generator used for sampling; 783///; 784/// The distribution contained in the histogram h (TH2) is integrated; 785/// over the channel contents.; 786/// It is normalized to 1.; 787/// Getting one random number implies:; 788/// - Generating a random number between 0 and 1 (say r1); 789/// - Look in which bin in the normalized integral r1 corresponds to; 790/// - Fill histogram channel; 791/// ntimes random numbers are generated; 792 ; 793void TH2::FillRandom(TH1 *h, Int_t ntimes, TRandom * rng); 794{; 795 if (!h) { Error(""FillRandom"", ""Null histogram""); return; }; 796 if (fDimension != h->GetDimension()) {; 797 Error(""FillRandom"", ""Histograms with different dimensions""); return;; 798 }; 799 ; 800 if (h->ComputeIntegral() == 0) return;; 801 ; 802 Int_t loop;; 803 Double_t x,y;; 804 TH2 *h2 = (TH2*)h;; 805 for (loop=0;loop<ntimes;loop++) {; 806 h2->GetRandom2(x,y,rng);; 807 Fill(x,y);; 808 }; 809}; 810 ; 811 ; 812//////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:59689,Integrability,rout,routine,59689,"2, using Kolmogorov test.; 1450/// Default: Ignore under- and overflow bins in comparison; 1451///; 1452/// option is a character string to specify options; 1453/// - ""U"" include Underflows in test; 1454/// - ""O"" include Overflows; 1455/// - ""N"" include comparison of normalizations; 1456/// - ""D"" Put out a line of ""Debug"" printout; 1457/// - ""M"" Return the Maximum Kolmogorov distance instead of prob; 1458///; 1459/// The returned function value is the probability of test; 1460/// (much less than one means NOT compatible); 1461///; 1462/// The KS test uses the distance between the pseudo-CDF's obtained; 1463/// from the histogram. Since in 2D the order for generating the pseudo-CDF is; 1464/// arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; 1465/// other from the y axis and the maximum distance is the average of the two maximum; 1466/// distances obtained.; 1467///; 1468/// Code adapted by Rene Brun from original HBOOK routine HDIFF; 1469 ; 1470Double_t TH2::KolmogorovTest(const TH1 *h2, Option_t *option) const; 1471{; 1472 TString opt = option;; 1473 opt.ToUpper();; 1474 ; 1475 Double_t prb = 0;; 1476 TH1 *h1 = (TH1*)this;; 1477 if (h2 == nullptr) return 0;; 1478 const TAxis *xaxis1 = h1->GetXaxis();; 1479 const TAxis *xaxis2 = h2->GetXaxis();; 1480 const TAxis *yaxis1 = h1->GetYaxis();; 1481 const TAxis *yaxis2 = h2->GetYaxis();; 1482 Int_t ncx1 = xaxis1->GetNbins();; 1483 Int_t ncx2 = xaxis2->GetNbins();; 1484 Int_t ncy1 = yaxis1->GetNbins();; 1485 Int_t ncy2 = yaxis2->GetNbins();; 1486 ; 1487 // Check consistency of dimensions; 1488 if (h1->GetDimension() != 2 || h2->GetDimension() != 2) {; 1489 Error(""KolmogorovTest"",""Histograms must be 2-D\n"");; 1490 return 0;; 1491 }; 1492 ; 1493 // Check consistency in number of channels; 1494 if (ncx1 != ncx2) {; 1495 Error(""KolmogorovTest"",""Number of channels in X is different, %d and %d\n"",ncx1,ncx2);; 1496 return 0;; 1497 }; 1498 if (ncy1 != ncy2) {; 1499 Error(""KolmogorovTest"",""Number of ch",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:81041,Integrability,integrat,integrated,81041,">SetLineColor(this->GetLineColor());; 1994 h1->SetFillColor(this->GetFillColor());; 1995 h1->SetMarkerColor(this->GetMarkerColor());; 1996 h1->SetMarkerStyle(this->GetMarkerStyle());; 1997 ; 1998 // check if histogram is weighted; 1999 // in case need to store sum of weight square/bin for the profile; 2000 TArrayD & binSumw2 = *(h1->GetBinSumw2());; 2001 bool useWeights = (GetSumw2N() > 0);; 2002 if (useWeights && (binSumw2.fN != h1->GetNcells()) ) h1->Sumw2();; 2003 // we need to set this bit because we fill the profile using a single Fill for many entries; 2004 // This is needed for the changes applied to make automatically the histogram weighted in ROOT 6 versions; 2005 else h1->SetBit(TH1::kIsNotW);; 2006 ; 2007 // Fill the profile histogram; 2008 // no entries/bin is available so can fill only using bin content as weight; 2009 ; 2010 // implement filling of projected histogram; 2011 // outbin is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; 2012 // inbin is the axis being integrated. Loop is done only on the selected bins; 2013 for ( Int_t outbin = 0; outbin <= outAxis.GetNbins() + 1; ++outbin) {; 2014 if (outAxis.TestBit(TAxis::kAxisRange) && ( outbin < firstOutBin || outbin > lastOutBin )) continue;; 2015 ; 2016 // find corresponding bin number in h1 for outbin (binOut); 2017 Double_t xOut = outAxis.GetBinCenter(outbin);; 2018 Int_t binOut = h1->GetXaxis()->FindBin( xOut );; 2019 if (binOut <0) continue;; 2020 ; 2021 for (Int_t inbin = firstbin ; inbin <= lastbin ; ++inbin) {; 2022 Int_t binx, biny;; 2023 if (onX) { binx = outbin; biny=inbin; }; 2024 else { binx = inbin; biny=outbin; }; 2025 ; 2026 if (ncuts) {; 2027 if (!fPainter->IsInside(binx,biny)) continue;; 2028 }; 2029 Int_t bin = GetBin(binx, biny);; 2030 Double_t cxy = RetrieveBinContent(bin);; 2031 ; 2032 ; 2033 if (cxy) {; 2034 Double_t tmp = 0;; 2035 // the following fill update wrongly the fBinSumw2- need to save it before; 2036 if ( useWeights ) tmp = binS",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:93886,Integrability,integrat,integrated,93886,";; 2279 }; 2280 if (opt.Contains(""e"") || GetSumw2N() ) h1->Sumw2();; 2281 }; 2282 if (pname != name) delete [] pname;; 2283 ; 2284 // Copy the axis attributes and the axis labels if needed.; 2285 h1->GetXaxis()->ImportAttributes(outAxis);; 2286 THashList* labels=outAxis->GetLabels();; 2287 if (labels) {; 2288 TIter iL(labels);; 2289 TObjString* lb;; 2290 Int_t i = 1;; 2291 while ((lb=(TObjString*)iL())) {; 2292 h1->GetXaxis()->SetBinLabel(i,lb->String().Data());; 2293 i++;; 2294 }; 2295 }; 2296 ; 2297 h1->SetLineColor(this->GetLineColor());; 2298 h1->SetFillColor(this->GetFillColor());; 2299 h1->SetMarkerColor(this->GetMarkerColor());; 2300 h1->SetMarkerStyle(this->GetMarkerStyle());; 2301 ; 2302 // Fill the projected histogram; 2303 Double_t cont,err2;; 2304 Double_t totcont = 0;; 2305 Bool_t computeErrors = h1->GetSumw2N();; 2306 ; 2307 // implement filling of projected histogram; 2308 // outbin is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; 2309 // inbin is the axis being integrated. Loop is done only on the selected bins; 2310 // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins; 2311 Bool_t extendable = outAxis->CanExtend();; 2312 if ( labels && extendable ) h1->GetXaxis()->SetCanExtend(kFALSE);; 2313 for ( Int_t outbin = 0; outbin <= outAxis->GetNbins() + 1; ++outbin) {; 2314 err2 = 0;; 2315 cont = 0;; 2316 if (outAxis->TestBit(TAxis::kAxisRange) && ( outbin < firstOutBin || outbin > lastOutBin )) continue;; 2317 ; 2318 for (Int_t inbin = firstbin ; inbin <= lastbin ; ++inbin) {; 2319 Int_t binx, biny;; 2320 if (onX) { binx = outbin; biny=inbin; }; 2321 else { binx = inbin; biny=outbin; }; 2322 ; 2323 if (ncuts) {; 2324 if (!fPainter->IsInside(binx,biny)) continue;; 2325 }; 2326 // sum bin content and error if needed; 2327 cont += GetBinContent(binx,biny);; 2328 if (computeErrors) {; 2329 Double_t exy = GetBinError(binx,biny);; 2330 err2 += exy*exy;; 2331 }; 2332 ",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:177531,Integrability,rout,routine,177531,"togram with options.Definition TH1.cxx:3066; TH1::GetBinErrorSqUncheckedvirtual Double_t GetBinErrorSqUnchecked(Int_t bin) constDefinition TH1.h:449; TH1::GetAxisLabelStatusUInt_t GetAxisLabelStatus() constInternal function used in TH1::Fill to see which axis is full alphanumeric, i.e.Definition TH1.cxx:6675; TH1::fIntegralDouble_t * fIntegral! Integral of bins used by GetRandomDefinition TH1.h:111; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Double_t content)Set bin content see convention for numbering bins in TH1::GetBin In case the bin number is greater th...Definition TH1.cxx:9222; TH1::GetBinLowEdgevirtual Double_t GetBinLowEdge(Int_t bin) constReturn bin lower edge for 1D histogram.Definition TH1.cxx:9152; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::ResetStatsvirtual void ResetStats()Reset the statistics including the number of entries and replace with values calculated from bin cont...Definition TH1.cxx:7902; TH1::SetBuffervirtual void SetBuffer(Int_t buffersize, Option_t *option="""")Set the maximum number of entries to be kept in the buffer.Definition TH1.cxx:8458; TH1::kNstat@ kNstatSize of statistics data (up to TProfile3D)Definition TH1.h:184; TH1::fEntriesDouble_t fEntriesNumber of entries.Definition TH1.h:95; TH1::UpdateBinContentvirtual void UpdateBinContent(Int_t bin, Double_t content)Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH1.cxx:9449; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::fXaxisTAxis fXaxisX axis descriptor.Definition TH1.h:90; TH1::ExtendAxisvirtual void ExtendAxis(Double_t ",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:195183,Integrability,message,message,195183,"ition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::Expandvirtual void Expand(Int_t newSize)Expand or shrink the array to newSize elements.Definition TObjArray.cxx:387; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::AbstractMethodvoid AbstractMethod(const char *method) constUse this method to implement an ""abstract"" method that you don't want to leave purely abstract.Definition TObject.cxx:1035; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TProfileProfile Histogram.Definition TProfile.h:32; TProfile::Classstatic TClass * Class(); TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::RndmDouble_t Rnd",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:195738,Integrability,message,message,195738,"onstUse this method to implement an ""abstract"" method that you don't want to leave purely abstract.Definition TObject.cxx:1035; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TProfileProfile Histogram.Definition TProfile.h:32; TProfile::Classstatic TClass * Class(); TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::FirstSsiz_t First(char c) constFind first occurrence of a character c.Definition TString.cxx:538; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::ToUppervoid ToUpper()Change string to upper case.D",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:195931,Integrability,message,message,195931,"inition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TProfileProfile Histogram.Definition TProfile.h:32; TProfile::Classstatic TClass * Class(); TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::FirstSsiz_t First(char c) constFind first occurrence of a character c.Definition TString.cxx:538; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Formatstatic TString Form",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:2568,Modifiability,variab,variable,2568,"43\class TH2F; 44\brief 2-D histogram with a float per channel (see TH1 documentation); 45\class TH2D; 46\brief 2-D histogram with a double per channel (see TH1 documentation); 47@}; 48*/; 49 ; 50/** \class TH2; 51 Service class for 2-D histogram classes; 52 ; 53- TH2C a 2-D histogram with one byte per cell (char). Maximum bin content = 127; 54- TH2S a 2-D histogram with two bytes per cell (short integer). Maximum bin content = 32767; 55- TH2I a 2-D histogram with four bytes per cell (32 bit integer). Maximum bin content = INT_MAX (\ref intmax2 ""*""); 56- TH2L a 2-D histogram with eight bytes per cell (64 bit integer). Maximum bin content = LLONG_MAX (\ref llongmax2 ""**""); 57- TH2F a 2-D histogram with four bytes per cell (float). Maximum precision 7 digits, maximum integer bin content = +/-16777216 (\ref floatmax2 ""***""); 58- TH2D a 2-D histogram with eight bytes per cell (double). Maximum precision 14 digits, maximum integer bin content = +/-9007199254740992 (\ref doublemax2 ""****""); 59 ; 60<sup>; 61\anchor intmax2 (*) INT_MAX = 2147483647 is the [maximum value for a variable of type int.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 62\anchor llongmax2 (**) LLONG_MAX = 9223372036854775807 is the [maximum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 63\anchor floatmax2 (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br>; 64\anchor doublemax2 (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760); 65</sup>; 66 ; 67*/; 68 ; 69 ; 70////////////////////////////////////////////////////////////////////////////////; 71/// 2-D histogram default constructor.; 72 ; 73TH2::TH2(); 74{; 75 fDimension = 2;; 76 fScalefactor = 1;; 77 fTsumwy = fTsumwy2 = fTsumwxy = ",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:2749,Modifiability,variab,variable,2749,"; 51 Service class for 2-D histogram classes; 52 ; 53- TH2C a 2-D histogram with one byte per cell (char). Maximum bin content = 127; 54- TH2S a 2-D histogram with two bytes per cell (short integer). Maximum bin content = 32767; 55- TH2I a 2-D histogram with four bytes per cell (32 bit integer). Maximum bin content = INT_MAX (\ref intmax2 ""*""); 56- TH2L a 2-D histogram with eight bytes per cell (64 bit integer). Maximum bin content = LLONG_MAX (\ref llongmax2 ""**""); 57- TH2F a 2-D histogram with four bytes per cell (float). Maximum precision 7 digits, maximum integer bin content = +/-16777216 (\ref floatmax2 ""***""); 58- TH2D a 2-D histogram with eight bytes per cell (double). Maximum precision 14 digits, maximum integer bin content = +/-9007199254740992 (\ref doublemax2 ""****""); 59 ; 60<sup>; 61\anchor intmax2 (*) INT_MAX = 2147483647 is the [maximum value for a variable of type int.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 62\anchor llongmax2 (**) LLONG_MAX = 9223372036854775807 is the [maximum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 63\anchor floatmax2 (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br>; 64\anchor doublemax2 (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760); 65</sup>; 66 ; 67*/; 68 ; 69 ; 70////////////////////////////////////////////////////////////////////////////////; 71/// 2-D histogram default constructor.; 72 ; 73TH2::TH2(); 74{; 75 fDimension = 2;; 76 fScalefactor = 1;; 77 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 78}; 79 ; 80 ; 81////////////////////////////////////////////////////////////////////////////////; 82/// Constructor for fix bin size 2-D histograms.; 83/// Creates the main histogram structure.; 84///; 85//",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:4957,Modifiability,variab,variable,4957,"stringt`,; 89/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 90/// \param[in] nbinsx number of bins along the X axis; 91/// \param[in] xlow low edge of the X axis first bin; 92/// \param[in] xup upper edge of the X axis last bin (not included in last bin); 93/// \param[in] nbinsy number of bins along the Y axis; 94/// \param[in] ylow low edge of the Y axis first bin; 95/// \param[in] yup upper edge of the Y axis last bin (not included in last bin); 96 ; 97TH2::TH2(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 98 ,Int_t nbinsy,Double_t ylow,Double_t yup); 99 :TH1(name,title,nbinsx,xlow,xup); 100{; 101 fDimension = 2;; 102 fScalefactor = 1;; 103 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 104 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 105 fYaxis.Set(nbinsy,ylow,yup);; 106 fNcells = fNcells*(nbinsy+2); // fNCells is set in the TH1 constructor; 107}; 108 ; 109 ; 110////////////////////////////////////////////////////////////////////////////////; 111/// Constructor for variable bin size (along X axis) 2-D histograms using an input array; 112/// of type double.; 113///; 114/// \param[in] name name of histogram (avoid blanks); 115/// \param[in] title histogram title.; 116/// If title is of the form `stringt;stringx;stringy;stringz`; 117/// the histogram title is set to `stringt`,; 118/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 119/// \param[in] nbinsx number of bins; 120/// \param[in] xbins array of low-edges for each bin.; 121/// This is an array of type double and size nbinsx+1; 122/// \param[in] nbinsy number of bins along the Y axis; 123/// \param[in] ylow low edge of the Y axis first bin; 124/// \param[in] yup upper edge of the Y axis last bin (not included in last bin); 125 ; 126TH2::TH2(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 127 ,Int_t nbinsy,Double_t ylow,Double_t yup); 128 :TH1(name,title,nbinsx,xbins); 129{; 130 fDimen",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:6299,Modifiability,variab,variable,6299,"stringy;stringz`; 117/// the histogram title is set to `stringt`,; 118/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 119/// \param[in] nbinsx number of bins; 120/// \param[in] xbins array of low-edges for each bin.; 121/// This is an array of type double and size nbinsx+1; 122/// \param[in] nbinsy number of bins along the Y axis; 123/// \param[in] ylow low edge of the Y axis first bin; 124/// \param[in] yup upper edge of the Y axis last bin (not included in last bin); 125 ; 126TH2::TH2(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 127 ,Int_t nbinsy,Double_t ylow,Double_t yup); 128 :TH1(name,title,nbinsx,xbins); 129{; 130 fDimension = 2;; 131 fScalefactor = 1;; 132 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 133 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 134 fYaxis.Set(nbinsy,ylow,yup);; 135 fNcells = fNcells*(nbinsy+2); // fNCells is set in the TH1 constructor; 136}; 137 ; 138 ; 139////////////////////////////////////////////////////////////////////////////////; 140/// Constructor for Double_t variable bin size (along Y axis) 2-D histograms.; 141///; 142/// \param[in] name name of histogram (avoid blanks); 143/// \param[in] title histogram title.; 144/// If title is of the form `stringt;stringx;stringy;stringz`; 145/// the histogram title is set to `stringt`,; 146/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 147/// \param[in] nbinsx number of bins along the X axis; 148/// \param[in] xlow low edge of the X axis first bin; 149/// \param[in] xup upper edge of the X axis last bin (not included in last bin); 150/// \param[in] nbinsy number of bins; 151/// \param[in] ybins array of low-edges for each bin.; 152/// This is an array of type double and size nbinsy+1; 153 ; 154TH2::TH2(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 155 ,Int_t nbinsy,const Double_t *ybins); 156 :TH1(name,title,nbinsx,xlow,xup); 157{; 158 fDimension = 2;; 159",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:7642,Modifiability,variab,variable,7642,"itle is set to `stringt`,; 146/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 147/// \param[in] nbinsx number of bins along the X axis; 148/// \param[in] xlow low edge of the X axis first bin; 149/// \param[in] xup upper edge of the X axis last bin (not included in last bin); 150/// \param[in] nbinsy number of bins; 151/// \param[in] ybins array of low-edges for each bin.; 152/// This is an array of type double and size nbinsy+1; 153 ; 154TH2::TH2(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 155 ,Int_t nbinsy,const Double_t *ybins); 156 :TH1(name,title,nbinsx,xlow,xup); 157{; 158 fDimension = 2;; 159 fScalefactor = 1;; 160 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 161 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 162 if (ybins) fYaxis.Set(nbinsy,ybins);; 163 else fYaxis.Set(nbinsy,0,1);; 164 fNcells = fNcells*(nbinsy+2); // fNCells is set in the TH1 constructor; 165}; 166 ; 167 ; 168////////////////////////////////////////////////////////////////////////////////; 169/// Constructor for Double_t variable bin size 2-D histograms.; 170///; 171/// \param[in] name name of histogram (avoid blanks); 172/// \param[in] title histogram title.; 173/// If title is of the form `stringt;stringx;stringy;stringz`; 174/// the histogram title is set to `stringt`,; 175/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 176/// \param[in] nbinsx number of bins; 177/// \param[in] xbins array of low-edges for each bin.; 178/// This is an array of type double and size nbinsx+1; 179/// \param[in] nbinsy number of bins; 180/// \param[in] ybins array of low-edges for each bin.; 181/// This is an array of type double and size nbinsy+1; 182 ; 183TH2::TH2(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 184 ,Int_t nbinsy,const Double_t *ybins); 185 :TH1(name,title,nbinsx,xbins); 186{; 187 fDimension = 2;; 188 fScalefactor = 1;; 189 fTsumwy = fTsumwy2 = fTsumwxy = 0;; ",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:8911,Modifiability,variab,variable,8911,"; 174/// the histogram title is set to `stringt`,; 175/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 176/// \param[in] nbinsx number of bins; 177/// \param[in] xbins array of low-edges for each bin.; 178/// This is an array of type double and size nbinsx+1; 179/// \param[in] nbinsy number of bins; 180/// \param[in] ybins array of low-edges for each bin.; 181/// This is an array of type double and size nbinsy+1; 182 ; 183TH2::TH2(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 184 ,Int_t nbinsy,const Double_t *ybins); 185 :TH1(name,title,nbinsx,xbins); 186{; 187 fDimension = 2;; 188 fScalefactor = 1;; 189 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 190 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 191 if (ybins) fYaxis.Set(nbinsy,ybins);; 192 else fYaxis.Set(nbinsy,0,1);; 193 fNcells = fNcells*(nbinsy+2); // fNCells is set in the TH1 constructor; 194}; 195 ; 196 ; 197////////////////////////////////////////////////////////////////////////////////; 198/// Constructor for variable bin size (along X and Y axis) 2-D histograms using input; 199/// arrays of type float.; 200///; 201/// \param[in] name name of histogram (avoid blanks); 202/// \param[in] title histogram title.; 203/// If title is of the form `stringt;stringx;stringy;stringz`; 204/// the histogram title is set to `stringt`,; 205/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 206/// \param[in] nbinsx number of bins; 207/// \param[in] xbins array of low-edges for each bin.; 208/// This is an array of type float and size nbinsx+1; 209/// \param[in] nbinsy number of bins; 210/// \param[in] ybins array of low-edges for each bin.; 211/// This is an array of type float and size nbinsy+1; 212 ; 213TH2::TH2(const char *name,const char *title,Int_t nbinsx,const Float_t *xbins; 214 ,Int_t nbinsy,const Float_t *ybins); 215 :TH1(name,title,nbinsx,xbins); 216{; 217 fDimension = 2;; 218 fScalefactor = 1;; 219 fTsumwy = fTsu",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:20380,Modifiability,extend,extended,20380,"ghts is automatically triggered and the sum of the squares of weights is incremented; 500/// by w^2 in the bin corresponding to namex,namey; 501///; 502/// The function returns the corresponding global bin number which has its content; 503/// incremented by w; 504 ; 505Int_t TH2::Fill(const char *namex, const char *namey, Double_t w); 506{; 507 Int_t binx, biny, bin;; 508 fEntries++;; 509 binx = fXaxis.FindBin(namex);; 510 biny = fYaxis.FindBin(namey);; 511 if (binx <0 || biny <0) return -1;; 512 bin = biny*(fXaxis.GetNbins()+2) + binx;; 513 if (!fSumw2.fN && w != 1.0 && !TestBit(TH1::kIsNotW)) Sumw2(); // must be called before AddBinContent; 514 if (fSumw2.fN) fSumw2.fArray[bin] += w*w;; 515 AddBinContent(bin,w);; 516 if (binx == 0 || binx > fXaxis.GetNbins()) return -1;; 517 if (biny == 0 || biny > fYaxis.GetNbins()) return -1;; 518 ; 519 Double_t z= w;; 520 fTsumw += z;; 521 fTsumw2 += z*z;; 522 // skip computation of the statistics along axis that have labels (can be extended and are alphanumeric); 523 UInt_t labelBitMask = GetAxisLabelStatus();; 524 if (labelBitMask != (TH1::kXaxis | TH1::kYaxis)) {; 525 Double_t x = (labelBitMask & TH1::kXaxis) ? 0 : fXaxis.GetBinCenter(binx);; 526 Double_t y = (labelBitMask & TH1::kYaxis) ? 0 : fYaxis.GetBinCenter(biny);; 527 fTsumwx += z * x;; 528 fTsumwx2 += z * x * x;; 529 fTsumwy += z * y;; 530 fTsumwy2 += z * y * y;; 531 fTsumwxy += z * x * y;; 532 }; 533 return bin;; 534}; 535 ; 536 ; 537////////////////////////////////////////////////////////////////////////////////; 538/// Increment cell defined by namex,y by a weight w; 539///; 540/// - if x or/and y is less than the low-edge of the corresponding axis first bin,; 541/// the Underflow cell is incremented.; 542/// - if x or/and y is equal to or greater than the upper edge of corresponding axis last bin,; 543/// the Overflow cell is incremented.; 544///; 545/// - If the weight is not equal to 1, the storage of the sum of squares of; 546/// weights is automatically trigge",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:59648,Modifiability,adapt,adapted,59648,"2, using Kolmogorov test.; 1450/// Default: Ignore under- and overflow bins in comparison; 1451///; 1452/// option is a character string to specify options; 1453/// - ""U"" include Underflows in test; 1454/// - ""O"" include Overflows; 1455/// - ""N"" include comparison of normalizations; 1456/// - ""D"" Put out a line of ""Debug"" printout; 1457/// - ""M"" Return the Maximum Kolmogorov distance instead of prob; 1458///; 1459/// The returned function value is the probability of test; 1460/// (much less than one means NOT compatible); 1461///; 1462/// The KS test uses the distance between the pseudo-CDF's obtained; 1463/// from the histogram. Since in 2D the order for generating the pseudo-CDF is; 1464/// arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; 1465/// other from the y axis and the maximum distance is the average of the two maximum; 1466/// distances obtained.; 1467///; 1468/// Code adapted by Rene Brun from original HBOOK routine HDIFF; 1469 ; 1470Double_t TH2::KolmogorovTest(const TH1 *h2, Option_t *option) const; 1471{; 1472 TString opt = option;; 1473 opt.ToUpper();; 1474 ; 1475 Double_t prb = 0;; 1476 TH1 *h1 = (TH1*)this;; 1477 if (h2 == nullptr) return 0;; 1478 const TAxis *xaxis1 = h1->GetXaxis();; 1479 const TAxis *xaxis2 = h2->GetXaxis();; 1480 const TAxis *yaxis1 = h1->GetYaxis();; 1481 const TAxis *yaxis2 = h2->GetYaxis();; 1482 Int_t ncx1 = xaxis1->GetNbins();; 1483 Int_t ncx2 = xaxis2->GetNbins();; 1484 Int_t ncy1 = yaxis1->GetNbins();; 1485 Int_t ncy2 = yaxis2->GetNbins();; 1486 ; 1487 // Check consistency of dimensions; 1488 if (h1->GetDimension() != 2 || h2->GetDimension() != 2) {; 1489 Error(""KolmogorovTest"",""Histograms must be 2-D\n"");; 1490 return 0;; 1491 }; 1492 ; 1493 // Check consistency in number of channels; 1494 if (ncx1 != ncx2) {; 1495 Error(""KolmogorovTest"",""Number of channels in X is different, %d and %d\n"",ncx1,ncx2);; 1496 return 0;; 1497 }; 1498 if (ncy1 != ncy2) {; 1499 Error(""KolmogorovTest"",""Number of ch",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:66292,Modifiability,variab,variable,66292,"1626 printf("" Kolmo Probabil = %f for shape alone, =%f for normalisation alone\n"",prb1,prb2);; 1627 }; 1628 // This numerical error condition should never occur:; 1629 if (TMath::Abs(rsum1-1) > 0.002) Warning(""KolmogorovTest"",""Numerical problems with h1=%s\n"",h1->GetName());; 1630 if (TMath::Abs(rsum2-1) > 0.002) Warning(""KolmogorovTest"",""Numerical problems with h2=%s\n"",h2->GetName());; 1631 ; 1632 if(opt.Contains(""M"")) return dfmax; // return average of max distance; 1633 ; 1634 return prb;; 1635}; 1636 ; 1637 ; 1638////////////////////////////////////////////////////////////////////////////////; 1639/// Rebin only the X axis; 1640/// see Rebin2D; 1641 ; 1642TH2 *TH2::RebinX(Int_t ngroup, const char *newname); 1643{; 1644 return Rebin2D(ngroup, 1, newname);; 1645}; 1646 ; 1647 ; 1648////////////////////////////////////////////////////////////////////////////////; 1649/// Rebin only the Y axis; 1650/// see Rebin2D; 1651 ; 1652TH2 *TH2::RebinY(Int_t ngroup, const char *newname); 1653{; 1654 return Rebin2D(1, ngroup, newname);; 1655}; 1656 ; 1657////////////////////////////////////////////////////////////////////////////////; 1658/// Override TH1::Rebin as TH2::RebinX; 1659/// Rebinning in variable binning as for TH1 is not allowed; 1660/// If a non-null pointer is given an error is flagged; 1661/// see RebinX and Rebin2D; 1662 ; 1663TH2 * TH2::Rebin( Int_t ngroup, const char*newname, const Double_t *xbins); 1664{; 1665 if (xbins != nullptr) {; 1666 Error(""Rebin"",""Rebinning a 2-d histogram into variable bins is not supported (it is possible only for 1-d histograms). Return a nullptr"");; 1667 return nullptr;; 1668 }; 1669 Info(""Rebin"",""Rebinning only the x-axis. Use Rebin2D for rebinning both axes"");; 1670 return RebinX(ngroup, newname);; 1671}; 1672////////////////////////////////////////////////////////////////////////////////; 1673/// Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together.; 1674///; 1675/// if newname is not blank a new te",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:66603,Modifiability,variab,variable,66603,"1626 printf("" Kolmo Probabil = %f for shape alone, =%f for normalisation alone\n"",prb1,prb2);; 1627 }; 1628 // This numerical error condition should never occur:; 1629 if (TMath::Abs(rsum1-1) > 0.002) Warning(""KolmogorovTest"",""Numerical problems with h1=%s\n"",h1->GetName());; 1630 if (TMath::Abs(rsum2-1) > 0.002) Warning(""KolmogorovTest"",""Numerical problems with h2=%s\n"",h2->GetName());; 1631 ; 1632 if(opt.Contains(""M"")) return dfmax; // return average of max distance; 1633 ; 1634 return prb;; 1635}; 1636 ; 1637 ; 1638////////////////////////////////////////////////////////////////////////////////; 1639/// Rebin only the X axis; 1640/// see Rebin2D; 1641 ; 1642TH2 *TH2::RebinX(Int_t ngroup, const char *newname); 1643{; 1644 return Rebin2D(ngroup, 1, newname);; 1645}; 1646 ; 1647 ; 1648////////////////////////////////////////////////////////////////////////////////; 1649/// Rebin only the Y axis; 1650/// see Rebin2D; 1651 ; 1652TH2 *TH2::RebinY(Int_t ngroup, const char *newname); 1653{; 1654 return Rebin2D(1, ngroup, newname);; 1655}; 1656 ; 1657////////////////////////////////////////////////////////////////////////////////; 1658/// Override TH1::Rebin as TH2::RebinX; 1659/// Rebinning in variable binning as for TH1 is not allowed; 1660/// If a non-null pointer is given an error is flagged; 1661/// see RebinX and Rebin2D; 1662 ; 1663TH2 * TH2::Rebin( Int_t ngroup, const char*newname, const Double_t *xbins); 1664{; 1665 if (xbins != nullptr) {; 1666 Error(""Rebin"",""Rebinning a 2-d histogram into variable bins is not supported (it is possible only for 1-d histograms). Return a nullptr"");; 1667 return nullptr;; 1668 }; 1669 Info(""Rebin"",""Rebinning only the x-axis. Use Rebin2D for rebinning both axes"");; 1670 return RebinX(ngroup, newname);; 1671}; 1672////////////////////////////////////////////////////////////////////////////////; 1673/// Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together.; 1674///; 1675/// if newname is not blank a new te",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:72006,Modifiability,variab,variable,72006," Color_t xTitleColor = fXaxis.GetTitleColor();; 1767 Style_t xTitleFont = fXaxis.GetTitleFont();; 1768 // save the TAttAxis members (reset by SetBins) for y axis; 1769 Int_t nYdivisions = fYaxis.GetNdivisions();; 1770 Color_t yAxisColor = fYaxis.GetAxisColor();; 1771 Color_t yLabelColor = fYaxis.GetLabelColor();; 1772 Style_t yLabelFont = fYaxis.GetLabelFont();; 1773 Float_t yLabelOffset = fYaxis.GetLabelOffset();; 1774 Float_t yLabelSize = fYaxis.GetLabelSize();; 1775 Float_t yTickLength = fYaxis.GetTickLength();; 1776 Float_t yTitleOffset = fYaxis.GetTitleOffset();; 1777 Float_t yTitleSize = fYaxis.GetTitleSize();; 1778 Color_t yTitleColor = fYaxis.GetTitleColor();; 1779 Style_t yTitleFont = fYaxis.GetTitleFont();; 1780 ; 1781 ; 1782 // copy merged bin contents (ignore under/overflows); 1783 if (nxgroup != 1 || nygroup != 1) {; 1784 if(fXaxis.GetXbins()->GetSize() > 0 || fYaxis.GetXbins()->GetSize() > 0){; 1785 // variable bin sizes in x or y, don't treat both cases separately; 1786 Double_t *xbins = new Double_t[newxbins + 1];; 1787 for(Int_t i = 0; i <= newxbins; ++i) xbins[i] = fXaxis.GetBinLowEdge(1 + i * nxgroup);; 1788 Double_t *ybins = new Double_t[newybins + 1];; 1789 for(Int_t i = 0; i <= newybins; ++i) ybins[i] = fYaxis.GetBinLowEdge(1 + i * nygroup);; 1790 hnew->SetBins(newxbins, xbins, newybins, ybins); // changes also errors array (if any); 1791 delete [] xbins;; 1792 delete [] ybins;; 1793 } else {; 1794 hnew->SetBins(newxbins, xmin, xmax, newybins, ymin, ymax); //changes also errors array; 1795 }; 1796 ; 1797 // (0, 0): x - underflow; y - underflow; 1798 hnew->UpdateBinContent(0, oldBins[0]);; 1799 if (oldErrors) hnew->fSumw2[0] = 0;; 1800 ; 1801 // (x, 0): x - regular / overflow; y - underflow; 1802 for(Int_t binx = 1, oldbinx = 1; binx < newnx; ++binx, oldbinx += nxgroup){; 1803 Double_t binContent = 0.0, binErrorSq = 0.0;; 1804 for (Int_t i = 0; i < nxgroup && (oldbinx + i) < nx; ++i) {; 1805 Int_t bin = oldbinx + i;; 1806 binContent += oldBins[b",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:78577,Modifiability,variab,variable,78577,"t and re-use previous histogram; 1929 TObject *h1obj = gROOT->FindObject(pname);; 1930 if (h1obj && h1obj->InheritsFrom(TH1::Class())) {; 1931 if (h1obj->IsA() != TProfile::Class() ) {; 1932 Error(""DoProfile"",""Histogram with name %s must be a TProfile and is a %s"",name,h1obj->ClassName());; 1933 return nullptr;; 1934 }; 1935 h1 = (TProfile*)h1obj;; 1936 // reset the existing histogram and set always the new binning for the axis; 1937 // This avoid problems when the histogram already exists and the histograms is rebinned or its range has changed; 1938 // (see https://savannah.cern.ch/bugs/?94101 or https://savannah.cern.ch/bugs/?95808 ); 1939 h1->Reset();; 1940 const TArrayD *xbins = outAxis.GetXbins();; 1941 if (xbins->fN == 0) {; 1942 if ( originalRange ); 1943 h1->SetBins(outAxis.GetNbins(),outAxis.GetXmin(),outAxis.GetXmax());; 1944 else; 1945 h1->SetBins(lastOutBin-firstOutBin+1,outAxis.GetBinLowEdge(firstOutBin),outAxis.GetBinUpEdge(lastOutBin));; 1946 } else {; 1947 // case variable bins; 1948 if (originalRange ); 1949 h1->SetBins(outAxis.GetNbins(),xbins->fArray);; 1950 else; 1951 h1->SetBins(lastOutBin-firstOutBin+1,&xbins->fArray[firstOutBin-1]);; 1952 }; 1953 }; 1954 ; 1955 Int_t ncuts = 0;; 1956 if (opt.Contains(""["")) {; 1957 ((TH2 *)this)->GetPainter();; 1958 if (fPainter) ncuts = fPainter->MakeCuts((char*)cut.Data());; 1959 }; 1960 ; 1961 if (!h1) {; 1962 const TArrayD *bins = outAxis.GetXbins();; 1963 if (bins->fN == 0) {; 1964 if ( originalRange ); 1965 h1 = new TProfile(pname,GetTitle(),outAxis.GetNbins(),outAxis.GetXmin(),outAxis.GetXmax(),opt);; 1966 else; 1967 h1 = new TProfile(pname,GetTitle(),lastOutBin-firstOutBin+1,; 1968 outAxis.GetBinLowEdge(firstOutBin),; 1969 outAxis.GetBinUpEdge(lastOutBin), opt);; 1970 } else {; 1971 // case variable bins; 1972 if (originalRange ); 1973 h1 = new TProfile(pname,GetTitle(),outAxis.GetNbins(),bins->fArray,opt);; 1974 else; 1975 h1 = new TProfile(pname,GetTitle(),lastOutBin-firstOutBin+1,&bins->fArray[firstO",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:79366,Modifiability,variab,variable,79366,"ins(),outAxis.GetXmin(),outAxis.GetXmax());; 1944 else; 1945 h1->SetBins(lastOutBin-firstOutBin+1,outAxis.GetBinLowEdge(firstOutBin),outAxis.GetBinUpEdge(lastOutBin));; 1946 } else {; 1947 // case variable bins; 1948 if (originalRange ); 1949 h1->SetBins(outAxis.GetNbins(),xbins->fArray);; 1950 else; 1951 h1->SetBins(lastOutBin-firstOutBin+1,&xbins->fArray[firstOutBin-1]);; 1952 }; 1953 }; 1954 ; 1955 Int_t ncuts = 0;; 1956 if (opt.Contains(""["")) {; 1957 ((TH2 *)this)->GetPainter();; 1958 if (fPainter) ncuts = fPainter->MakeCuts((char*)cut.Data());; 1959 }; 1960 ; 1961 if (!h1) {; 1962 const TArrayD *bins = outAxis.GetXbins();; 1963 if (bins->fN == 0) {; 1964 if ( originalRange ); 1965 h1 = new TProfile(pname,GetTitle(),outAxis.GetNbins(),outAxis.GetXmin(),outAxis.GetXmax(),opt);; 1966 else; 1967 h1 = new TProfile(pname,GetTitle(),lastOutBin-firstOutBin+1,; 1968 outAxis.GetBinLowEdge(firstOutBin),; 1969 outAxis.GetBinUpEdge(lastOutBin), opt);; 1970 } else {; 1971 // case variable bins; 1972 if (originalRange ); 1973 h1 = new TProfile(pname,GetTitle(),outAxis.GetNbins(),bins->fArray,opt);; 1974 else; 1975 h1 = new TProfile(pname,GetTitle(),lastOutBin-firstOutBin+1,&bins->fArray[firstOutBin-1],opt);; 1976 }; 1977 }; 1978 if (pname != name) delete [] pname;; 1979 ; 1980 // Copy attributes; 1981 h1->GetXaxis()->ImportAttributes( &outAxis);; 1982 THashList* labels=outAxis.GetLabels();; 1983 if (labels) {; 1984 TIter iL(labels);; 1985 TObjString* lb;; 1986 Int_t i = 1;; 1987 while ((lb=(TObjString*)iL())) {; 1988 h1->GetXaxis()->SetBinLabel(i,lb->String().Data());; 1989 i++;; 1990 }; 1991 }; 1992 ; 1993 h1->SetLineColor(this->GetLineColor());; 1994 h1->SetFillColor(this->GetFillColor());; 1995 h1->SetMarkerColor(this->GetMarkerColor());; 1996 h1->SetMarkerStyle(this->GetMarkerStyle());; 1997 ; 1998 // check if histogram is weighted; 1999 // in case need to store sum of weight square/bin for the profile; 2000 TArrayD & binSumw2 = *(h1->GetBinSumw2());; 2001 bool useWeights",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:91867,Modifiability,variab,variable,91867,"1 // if compatible reset and re-use previous histogram; 2232 // (see https://savannah.cern.ch/bugs/?54340); 2233 TObject *h1obj = gROOT->FindObject(pname);; 2234 if (h1obj && h1obj->InheritsFrom(TH1::Class())) {; 2235 if (h1obj->IsA() != TH1D::Class() ) {; 2236 Error(""DoProjection"",""Histogram with name %s must be a TH1D and is a %s"",name,h1obj->ClassName());; 2237 return nullptr;; 2238 }; 2239 h1 = (TH1D*)h1obj;; 2240 // reset the existing histogram and set always the new binning for the axis; 2241 // This avoid problems when the histogram already exists and the histograms is rebinned or its range has changed; 2242 // (see https://savannah.cern.ch/bugs/?94101 or https://savannah.cern.ch/bugs/?95808 ); 2243 h1->Reset();; 2244 const TArrayD *xbins = outAxis->GetXbins();; 2245 if (xbins->fN == 0) {; 2246 if ( originalRange ); 2247 h1->SetBins(outAxis->GetNbins(),outAxis->GetXmin(),outAxis->GetXmax());; 2248 else; 2249 h1->SetBins(lastOutBin-firstOutBin+1,outAxis->GetBinLowEdge(firstOutBin),outAxis->GetBinUpEdge(lastOutBin));; 2250 } else {; 2251 // case variable bins; 2252 if (originalRange ); 2253 h1->SetBins(outAxis->GetNbins(),xbins->fArray);; 2254 else; 2255 h1->SetBins(lastOutBin-firstOutBin+1,&xbins->fArray[firstOutBin-1]);; 2256 }; 2257 }; 2258 ; 2259 Int_t ncuts = 0;; 2260 if (opt.Contains(""["")) {; 2261 ((TH2 *)this)->GetPainter();; 2262 if (fPainter) ncuts = fPainter->MakeCuts((char*)cut.Data());; 2263 }; 2264 ; 2265 if (!h1) {; 2266 const TArrayD *bins = outAxis->GetXbins();; 2267 if (bins->fN == 0) {; 2268 if ( originalRange ); 2269 h1 = new TH1D(pname,GetTitle(),outAxis->GetNbins(),outAxis->GetXmin(),outAxis->GetXmax());; 2270 else; 2271 h1 = new TH1D(pname,GetTitle(),lastOutBin-firstOutBin+1,; 2272 outAxis->GetBinLowEdge(firstOutBin),outAxis->GetBinUpEdge(lastOutBin));; 2273 } else {; 2274 // case variable bins; 2275 if (originalRange ); 2276 h1 = new TH1D(pname,GetTitle(),outAxis->GetNbins(),bins->fArray);; 2277 else; 2278 h1 = new TH1D(pname,GetTitle(),l",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:92639,Modifiability,variab,variable,92639,"D *xbins = outAxis->GetXbins();; 2245 if (xbins->fN == 0) {; 2246 if ( originalRange ); 2247 h1->SetBins(outAxis->GetNbins(),outAxis->GetXmin(),outAxis->GetXmax());; 2248 else; 2249 h1->SetBins(lastOutBin-firstOutBin+1,outAxis->GetBinLowEdge(firstOutBin),outAxis->GetBinUpEdge(lastOutBin));; 2250 } else {; 2251 // case variable bins; 2252 if (originalRange ); 2253 h1->SetBins(outAxis->GetNbins(),xbins->fArray);; 2254 else; 2255 h1->SetBins(lastOutBin-firstOutBin+1,&xbins->fArray[firstOutBin-1]);; 2256 }; 2257 }; 2258 ; 2259 Int_t ncuts = 0;; 2260 if (opt.Contains(""["")) {; 2261 ((TH2 *)this)->GetPainter();; 2262 if (fPainter) ncuts = fPainter->MakeCuts((char*)cut.Data());; 2263 }; 2264 ; 2265 if (!h1) {; 2266 const TArrayD *bins = outAxis->GetXbins();; 2267 if (bins->fN == 0) {; 2268 if ( originalRange ); 2269 h1 = new TH1D(pname,GetTitle(),outAxis->GetNbins(),outAxis->GetXmin(),outAxis->GetXmax());; 2270 else; 2271 h1 = new TH1D(pname,GetTitle(),lastOutBin-firstOutBin+1,; 2272 outAxis->GetBinLowEdge(firstOutBin),outAxis->GetBinUpEdge(lastOutBin));; 2273 } else {; 2274 // case variable bins; 2275 if (originalRange ); 2276 h1 = new TH1D(pname,GetTitle(),outAxis->GetNbins(),bins->fArray);; 2277 else; 2278 h1 = new TH1D(pname,GetTitle(),lastOutBin-firstOutBin+1,&bins->fArray[firstOutBin-1]);; 2279 }; 2280 if (opt.Contains(""e"") || GetSumw2N() ) h1->Sumw2();; 2281 }; 2282 if (pname != name) delete [] pname;; 2283 ; 2284 // Copy the axis attributes and the axis labels if needed.; 2285 h1->GetXaxis()->ImportAttributes(outAxis);; 2286 THashList* labels=outAxis->GetLabels();; 2287 if (labels) {; 2288 TIter iL(labels);; 2289 TObjString* lb;; 2290 Int_t i = 1;; 2291 while ((lb=(TObjString*)iL())) {; 2292 h1->GetXaxis()->SetBinLabel(i,lb->String().Data());; 2293 i++;; 2294 }; 2295 }; 2296 ; 2297 h1->SetLineColor(this->GetLineColor());; 2298 h1->SetFillColor(this->GetFillColor());; 2299 h1->SetMarkerColor(this->GetMarkerColor());; 2300 h1->SetMarkerStyle(this->GetMarkerStyle());; ",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:93980,Modifiability,extend,extendable,93980,"is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; 2309 // inbin is the axis being integrated. Loop is done only on the selected bins; 2310 // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins; 2311 Bool_t extendable = outAxis->CanExtend();; 2312 if ( labels && extendable ) h1->GetXaxis()->SetCanExtend(kFALSE);; 2313 for ( Int_t outbin = 0; outbin <= outAxis->GetNbins() + 1; ++outbin) {; 2314 err2 = 0;; 2315 cont = 0;; 2316 if (outAxis->TestBit(TAxis::kAxisRange) && ( outbin < firstOutBin || outbin > lastOutBin )) continue;; 2317 ; 2318 for (Int_t inbin = firstbin ; inbin <= lastbin ; ++inbin) {; 2319 Int_t binx, biny;; 2320 if (onX) { binx = outbin; biny=inbin; }; 2321 else { binx = inbin; biny=outbin; }; 2322 ; 2323 if (ncuts) {; 2324 if (!fPainter->IsInside(binx,biny)) continue;; 2325 }; 2326 // sum bin content and error if needed; 2327 cont += GetBinContent(binx,biny);; 2328 if (computeErrors) {; 2329 Double_t exy = GetBinError(binx,biny);; 2330 err2 += exy*exy;; 2331 }; 2332 }; 2333 // find corresponding bin number in h1 for outbin; 2334 Int_t binOut = h1->GetXaxis()->FindBin( outAxis->GetBinCenter(outbin) );; 2335 h1->SetBinContent(binOut ,cont);; 2336 if (computeErrors) h1->SetBinError(binOut,TMath::Sqrt(err2));; 2337 // sum all content; 2338 totcont += cont;; 2339 }; 2340 if ( labels ) h1->GetXaxis()->SetCanExtend(extendable);; 2341 ; 2342 // check if we can re-use the original statistics from the previous histogram; 2343 bool reuseStats = false;; 2344 if ( ( GetStatOverflowsBehaviour() == false && firstbin == 1 && lastbin == inNbin ) ||; 2345 ( GetStatOverflowsBehaviour() == true && firstbin == 0 && lastbin == inNbin + 1 ) ); 2346 reuseStats = true;; 2347 else {; 2348 // also if total content match we can re-use; 2349 double eps = 1.E-12;; 2350 if (IsA() == TH2F::Class() ) eps = 1.E-6;; 2351 if (fTsumw != 0 && TMath::Abs( fTsumw - totcont) < TMath::Abs(fTsumw) * e",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:94014,Modifiability,extend,extendable,94014,"is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; 2309 // inbin is the axis being integrated. Loop is done only on the selected bins; 2310 // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins; 2311 Bool_t extendable = outAxis->CanExtend();; 2312 if ( labels && extendable ) h1->GetXaxis()->SetCanExtend(kFALSE);; 2313 for ( Int_t outbin = 0; outbin <= outAxis->GetNbins() + 1; ++outbin) {; 2314 err2 = 0;; 2315 cont = 0;; 2316 if (outAxis->TestBit(TAxis::kAxisRange) && ( outbin < firstOutBin || outbin > lastOutBin )) continue;; 2317 ; 2318 for (Int_t inbin = firstbin ; inbin <= lastbin ; ++inbin) {; 2319 Int_t binx, biny;; 2320 if (onX) { binx = outbin; biny=inbin; }; 2321 else { binx = inbin; biny=outbin; }; 2322 ; 2323 if (ncuts) {; 2324 if (!fPainter->IsInside(binx,biny)) continue;; 2325 }; 2326 // sum bin content and error if needed; 2327 cont += GetBinContent(binx,biny);; 2328 if (computeErrors) {; 2329 Double_t exy = GetBinError(binx,biny);; 2330 err2 += exy*exy;; 2331 }; 2332 }; 2333 // find corresponding bin number in h1 for outbin; 2334 Int_t binOut = h1->GetXaxis()->FindBin( outAxis->GetBinCenter(outbin) );; 2335 h1->SetBinContent(binOut ,cont);; 2336 if (computeErrors) h1->SetBinError(binOut,TMath::Sqrt(err2));; 2337 // sum all content; 2338 totcont += cont;; 2339 }; 2340 if ( labels ) h1->GetXaxis()->SetCanExtend(extendable);; 2341 ; 2342 // check if we can re-use the original statistics from the previous histogram; 2343 bool reuseStats = false;; 2344 if ( ( GetStatOverflowsBehaviour() == false && firstbin == 1 && lastbin == inNbin ) ||; 2345 ( GetStatOverflowsBehaviour() == true && firstbin == 0 && lastbin == inNbin + 1 ) ); 2346 reuseStats = true;; 2347 else {; 2348 // also if total content match we can re-use; 2349 double eps = 1.E-12;; 2350 if (IsA() == TH2F::Class() ) eps = 1.E-6;; 2351 if (fTsumw != 0 && TMath::Abs( fTsumw - totcont) < TMath::Abs(fTsumw) * e",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:94065,Modifiability,extend,extendable,94065,"is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; 2309 // inbin is the axis being integrated. Loop is done only on the selected bins; 2310 // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins; 2311 Bool_t extendable = outAxis->CanExtend();; 2312 if ( labels && extendable ) h1->GetXaxis()->SetCanExtend(kFALSE);; 2313 for ( Int_t outbin = 0; outbin <= outAxis->GetNbins() + 1; ++outbin) {; 2314 err2 = 0;; 2315 cont = 0;; 2316 if (outAxis->TestBit(TAxis::kAxisRange) && ( outbin < firstOutBin || outbin > lastOutBin )) continue;; 2317 ; 2318 for (Int_t inbin = firstbin ; inbin <= lastbin ; ++inbin) {; 2319 Int_t binx, biny;; 2320 if (onX) { binx = outbin; biny=inbin; }; 2321 else { binx = inbin; biny=outbin; }; 2322 ; 2323 if (ncuts) {; 2324 if (!fPainter->IsInside(binx,biny)) continue;; 2325 }; 2326 // sum bin content and error if needed; 2327 cont += GetBinContent(binx,biny);; 2328 if (computeErrors) {; 2329 Double_t exy = GetBinError(binx,biny);; 2330 err2 += exy*exy;; 2331 }; 2332 }; 2333 // find corresponding bin number in h1 for outbin; 2334 Int_t binOut = h1->GetXaxis()->FindBin( outAxis->GetBinCenter(outbin) );; 2335 h1->SetBinContent(binOut ,cont);; 2336 if (computeErrors) h1->SetBinError(binOut,TMath::Sqrt(err2));; 2337 // sum all content; 2338 totcont += cont;; 2339 }; 2340 if ( labels ) h1->GetXaxis()->SetCanExtend(extendable);; 2341 ; 2342 // check if we can re-use the original statistics from the previous histogram; 2343 bool reuseStats = false;; 2344 if ( ( GetStatOverflowsBehaviour() == false && firstbin == 1 && lastbin == inNbin ) ||; 2345 ( GetStatOverflowsBehaviour() == true && firstbin == 0 && lastbin == inNbin + 1 ) ); 2346 reuseStats = true;; 2347 else {; 2348 // also if total content match we can re-use; 2349 double eps = 1.E-12;; 2350 if (IsA() == TH2F::Class() ) eps = 1.E-6;; 2351 if (fTsumw != 0 && TMath::Abs( fTsumw - totcont) < TMath::Abs(fTsumw) * e",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:94121,Modifiability,extend,extendable,94121,"is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; 2309 // inbin is the axis being integrated. Loop is done only on the selected bins; 2310 // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins; 2311 Bool_t extendable = outAxis->CanExtend();; 2312 if ( labels && extendable ) h1->GetXaxis()->SetCanExtend(kFALSE);; 2313 for ( Int_t outbin = 0; outbin <= outAxis->GetNbins() + 1; ++outbin) {; 2314 err2 = 0;; 2315 cont = 0;; 2316 if (outAxis->TestBit(TAxis::kAxisRange) && ( outbin < firstOutBin || outbin > lastOutBin )) continue;; 2317 ; 2318 for (Int_t inbin = firstbin ; inbin <= lastbin ; ++inbin) {; 2319 Int_t binx, biny;; 2320 if (onX) { binx = outbin; biny=inbin; }; 2321 else { binx = inbin; biny=outbin; }; 2322 ; 2323 if (ncuts) {; 2324 if (!fPainter->IsInside(binx,biny)) continue;; 2325 }; 2326 // sum bin content and error if needed; 2327 cont += GetBinContent(binx,biny);; 2328 if (computeErrors) {; 2329 Double_t exy = GetBinError(binx,biny);; 2330 err2 += exy*exy;; 2331 }; 2332 }; 2333 // find corresponding bin number in h1 for outbin; 2334 Int_t binOut = h1->GetXaxis()->FindBin( outAxis->GetBinCenter(outbin) );; 2335 h1->SetBinContent(binOut ,cont);; 2336 if (computeErrors) h1->SetBinError(binOut,TMath::Sqrt(err2));; 2337 // sum all content; 2338 totcont += cont;; 2339 }; 2340 if ( labels ) h1->GetXaxis()->SetCanExtend(extendable);; 2341 ; 2342 // check if we can re-use the original statistics from the previous histogram; 2343 bool reuseStats = false;; 2344 if ( ( GetStatOverflowsBehaviour() == false && firstbin == 1 && lastbin == inNbin ) ||; 2345 ( GetStatOverflowsBehaviour() == true && firstbin == 0 && lastbin == inNbin + 1 ) ); 2346 reuseStats = true;; 2347 else {; 2348 // also if total content match we can re-use; 2349 double eps = 1.E-12;; 2350 if (IsA() == TH2F::Class() ) eps = 1.E-6;; 2351 if (fTsumw != 0 && TMath::Abs( fTsumw - totcont) < TMath::Abs(fTsumw) * e",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:95203,Modifiability,extend,extendable,95203,"is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; 2309 // inbin is the axis being integrated. Loop is done only on the selected bins; 2310 // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins; 2311 Bool_t extendable = outAxis->CanExtend();; 2312 if ( labels && extendable ) h1->GetXaxis()->SetCanExtend(kFALSE);; 2313 for ( Int_t outbin = 0; outbin <= outAxis->GetNbins() + 1; ++outbin) {; 2314 err2 = 0;; 2315 cont = 0;; 2316 if (outAxis->TestBit(TAxis::kAxisRange) && ( outbin < firstOutBin || outbin > lastOutBin )) continue;; 2317 ; 2318 for (Int_t inbin = firstbin ; inbin <= lastbin ; ++inbin) {; 2319 Int_t binx, biny;; 2320 if (onX) { binx = outbin; biny=inbin; }; 2321 else { binx = inbin; biny=outbin; }; 2322 ; 2323 if (ncuts) {; 2324 if (!fPainter->IsInside(binx,biny)) continue;; 2325 }; 2326 // sum bin content and error if needed; 2327 cont += GetBinContent(binx,biny);; 2328 if (computeErrors) {; 2329 Double_t exy = GetBinError(binx,biny);; 2330 err2 += exy*exy;; 2331 }; 2332 }; 2333 // find corresponding bin number in h1 for outbin; 2334 Int_t binOut = h1->GetXaxis()->FindBin( outAxis->GetBinCenter(outbin) );; 2335 h1->SetBinContent(binOut ,cont);; 2336 if (computeErrors) h1->SetBinError(binOut,TMath::Sqrt(err2));; 2337 // sum all content; 2338 totcont += cont;; 2339 }; 2340 if ( labels ) h1->GetXaxis()->SetCanExtend(extendable);; 2341 ; 2342 // check if we can re-use the original statistics from the previous histogram; 2343 bool reuseStats = false;; 2344 if ( ( GetStatOverflowsBehaviour() == false && firstbin == 1 && lastbin == inNbin ) ||; 2345 ( GetStatOverflowsBehaviour() == true && firstbin == 0 && lastbin == inNbin + 1 ) ); 2346 reuseStats = true;; 2347 else {; 2348 // also if total content match we can re-use; 2349 double eps = 1.E-12;; 2350 if (IsA() == TH2F::Class() ) eps = 1.E-6;; 2351 if (fTsumw != 0 && TMath::Abs( fTsumw - totcont) < TMath::Abs(fTsumw) * e",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:102280,Modifiability,variab,variable,102280,"2466/// myhist->ProjectionY("" "",firstxbin,lastxbin,""[-cutg]"");; 2467/// It is possible to apply several cuts:; 2468/// myhist->ProjectionY("" "",firstxbin,lastxbin,""[cutg1,cutg2]"");; 2469///; 2470/// NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; 2471/// a compatible axis, the histogram is reset and filled again with the projected contents of the TH2.; 2472/// In the case of axis incompatibility, an error is reported and a NULL pointer is returned.; 2473///; 2474/// NOTE that the Y axis attributes of the TH2 are copied to the X axis of the projection.; 2475 ; 2476TH1D *TH2::ProjectionY(const char *name, Int_t firstxbin, Int_t lastxbin, Option_t *option) const; 2477{; 2478 return DoProjection(false, name, firstxbin, lastxbin, option);; 2479}; 2480 ; 2481 ; 2482////////////////////////////////////////////////////////////////////////////////; 2483/// Replace current statistics with the values in array stats; 2484 ; 2485void TH2::PutStats(Double_t *stats); 2486{; 2487 TH1::PutStats(stats);; 2488 fTsumwy = stats[4];; 2489 fTsumwy2 = stats[5];; 2490 fTsumwxy = stats[6];; 2491}; 2492 ; 2493 ; 2494////////////////////////////////////////////////////////////////////////////////; 2495/// Compute the X distribution of quantiles in the other variable Y; 2496/// name is the name of the returned histogram; 2497/// prob is the probability content for the quantile (0.5 is the default for the median); 2498/// An approximate error for the quantile is computed assuming that the distribution in; 2499/// the other variable is normal. According to this approximate formula the error on the quantile is; 2500/// estimated as sqrt( p (1-p) / ( n * f(q)^2) ), where p is the probability content of the quantile and; 2501/// n is the number of events used to compute the quantile and f(q) is the probability distribution for the; 2502/// other variable evaluated at the obtained quantile. In the error estimation the probability is then assumed to be; 2503/// a norm",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:102549,Modifiability,variab,variable,102549,"73///; 2474/// NOTE that the Y axis attributes of the TH2 are copied to the X axis of the projection.; 2475 ; 2476TH1D *TH2::ProjectionY(const char *name, Int_t firstxbin, Int_t lastxbin, Option_t *option) const; 2477{; 2478 return DoProjection(false, name, firstxbin, lastxbin, option);; 2479}; 2480 ; 2481 ; 2482////////////////////////////////////////////////////////////////////////////////; 2483/// Replace current statistics with the values in array stats; 2484 ; 2485void TH2::PutStats(Double_t *stats); 2486{; 2487 TH1::PutStats(stats);; 2488 fTsumwy = stats[4];; 2489 fTsumwy2 = stats[5];; 2490 fTsumwxy = stats[6];; 2491}; 2492 ; 2493 ; 2494////////////////////////////////////////////////////////////////////////////////; 2495/// Compute the X distribution of quantiles in the other variable Y; 2496/// name is the name of the returned histogram; 2497/// prob is the probability content for the quantile (0.5 is the default for the median); 2498/// An approximate error for the quantile is computed assuming that the distribution in; 2499/// the other variable is normal. According to this approximate formula the error on the quantile is; 2500/// estimated as sqrt( p (1-p) / ( n * f(q)^2) ), where p is the probability content of the quantile and; 2501/// n is the number of events used to compute the quantile and f(q) is the probability distribution for the; 2502/// other variable evaluated at the obtained quantile. In the error estimation the probability is then assumed to be; 2503/// a normal distribution.; 2504 ; 2505TH1D* TH2::QuantilesX( Double_t prob, const char * name) const; 2506{; 2507 return DoQuantiles(true, name, prob);; 2508}; 2509 ; 2510 ; 2511////////////////////////////////////////////////////////////////////////////////; 2512/// Compute the Y distribution of quantiles in the other variable X; 2513/// name is the name of the returned histogram; 2514/// prob is the probability content for the quantile (0.5 is the default for the median); 2515/// An approxima",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:102874,Modifiability,variab,variable,102874," firstxbin, lastxbin, option);; 2479}; 2480 ; 2481 ; 2482////////////////////////////////////////////////////////////////////////////////; 2483/// Replace current statistics with the values in array stats; 2484 ; 2485void TH2::PutStats(Double_t *stats); 2486{; 2487 TH1::PutStats(stats);; 2488 fTsumwy = stats[4];; 2489 fTsumwy2 = stats[5];; 2490 fTsumwxy = stats[6];; 2491}; 2492 ; 2493 ; 2494////////////////////////////////////////////////////////////////////////////////; 2495/// Compute the X distribution of quantiles in the other variable Y; 2496/// name is the name of the returned histogram; 2497/// prob is the probability content for the quantile (0.5 is the default for the median); 2498/// An approximate error for the quantile is computed assuming that the distribution in; 2499/// the other variable is normal. According to this approximate formula the error on the quantile is; 2500/// estimated as sqrt( p (1-p) / ( n * f(q)^2) ), where p is the probability content of the quantile and; 2501/// n is the number of events used to compute the quantile and f(q) is the probability distribution for the; 2502/// other variable evaluated at the obtained quantile. In the error estimation the probability is then assumed to be; 2503/// a normal distribution.; 2504 ; 2505TH1D* TH2::QuantilesX( Double_t prob, const char * name) const; 2506{; 2507 return DoQuantiles(true, name, prob);; 2508}; 2509 ; 2510 ; 2511////////////////////////////////////////////////////////////////////////////////; 2512/// Compute the Y distribution of quantiles in the other variable X; 2513/// name is the name of the returned histogram; 2514/// prob is the probability content for the quantile (0.5 is the default for the median); 2515/// An approximate error for the quantile is computed assuming that the distribution in; 2516/// the other variable is normal.; 2517 ; 2518TH1D* TH2::QuantilesY( Double_t prob, const char * name) const; 2519{; 2520 return DoQuantiles(false, name, prob);; 2521}; 2522 ; 2523",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:103308,Modifiability,variab,variable,103308,"5/// Compute the X distribution of quantiles in the other variable Y; 2496/// name is the name of the returned histogram; 2497/// prob is the probability content for the quantile (0.5 is the default for the median); 2498/// An approximate error for the quantile is computed assuming that the distribution in; 2499/// the other variable is normal. According to this approximate formula the error on the quantile is; 2500/// estimated as sqrt( p (1-p) / ( n * f(q)^2) ), where p is the probability content of the quantile and; 2501/// n is the number of events used to compute the quantile and f(q) is the probability distribution for the; 2502/// other variable evaluated at the obtained quantile. In the error estimation the probability is then assumed to be; 2503/// a normal distribution.; 2504 ; 2505TH1D* TH2::QuantilesX( Double_t prob, const char * name) const; 2506{; 2507 return DoQuantiles(true, name, prob);; 2508}; 2509 ; 2510 ; 2511////////////////////////////////////////////////////////////////////////////////; 2512/// Compute the Y distribution of quantiles in the other variable X; 2513/// name is the name of the returned histogram; 2514/// prob is the probability content for the quantile (0.5 is the default for the median); 2515/// An approximate error for the quantile is computed assuming that the distribution in; 2516/// the other variable is normal.; 2517 ; 2518TH1D* TH2::QuantilesY( Double_t prob, const char * name) const; 2519{; 2520 return DoQuantiles(false, name, prob);; 2521}; 2522 ; 2523 ; 2524////////////////////////////////////////////////////////////////////////////////; 2525/// Implementation of quantiles for x or y; 2526 ; 2527TH1D* TH2::DoQuantiles(bool onX, const char * name, Double_t prob) const; 2528{; 2529 const TAxis *outAxis = nullptr;; 2530 if ( onX ) {; 2531 outAxis = GetXaxis();; 2532 } else {; 2533 outAxis = GetYaxis();; 2534 }; 2535 ; 2536 // build first name of returned histogram; 2537 TString qname = name;; 2538 if (qname.IsNull() || qnam",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:103577,Modifiability,variab,variable,103577,"distribution in; 2499/// the other variable is normal. According to this approximate formula the error on the quantile is; 2500/// estimated as sqrt( p (1-p) / ( n * f(q)^2) ), where p is the probability content of the quantile and; 2501/// n is the number of events used to compute the quantile and f(q) is the probability distribution for the; 2502/// other variable evaluated at the obtained quantile. In the error estimation the probability is then assumed to be; 2503/// a normal distribution.; 2504 ; 2505TH1D* TH2::QuantilesX( Double_t prob, const char * name) const; 2506{; 2507 return DoQuantiles(true, name, prob);; 2508}; 2509 ; 2510 ; 2511////////////////////////////////////////////////////////////////////////////////; 2512/// Compute the Y distribution of quantiles in the other variable X; 2513/// name is the name of the returned histogram; 2514/// prob is the probability content for the quantile (0.5 is the default for the median); 2515/// An approximate error for the quantile is computed assuming that the distribution in; 2516/// the other variable is normal.; 2517 ; 2518TH1D* TH2::QuantilesY( Double_t prob, const char * name) const; 2519{; 2520 return DoQuantiles(false, name, prob);; 2521}; 2522 ; 2523 ; 2524////////////////////////////////////////////////////////////////////////////////; 2525/// Implementation of quantiles for x or y; 2526 ; 2527TH1D* TH2::DoQuantiles(bool onX, const char * name, Double_t prob) const; 2528{; 2529 const TAxis *outAxis = nullptr;; 2530 if ( onX ) {; 2531 outAxis = GetXaxis();; 2532 } else {; 2533 outAxis = GetYaxis();; 2534 }; 2535 ; 2536 // build first name of returned histogram; 2537 TString qname = name;; 2538 if (qname.IsNull() || qname == ""_qx"" || qname == ""_qy"") {; 2539 const char * qtype = (onX) ? ""qx"" : ""qy"";; 2540 qname = TString::Format(""%s_%s_%3.2f"",GetName(),qtype, prob);; 2541 }; 2542 // check if the histogram is already existing; 2543 TH1D *h1=nullptr;; 2544 //check if histogram with identical name exist; 2545 T",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:110921,Modifiability,extend,extends,110921,"ater than threshold*maximum bin content of this.; 2691///for more details see TSpectrum::Search.; 2692///note the difference in the default value for option compared to TSpectrum2::Search; 2693///option="""" by default (instead of ""goff""); 2694 ; 2695Int_t TH2::ShowPeaks(Double_t sigma, Option_t *option, Double_t threshold); 2696{; 2697 ; 2698 return (Int_t)gROOT->ProcessLineFast(TString::Format(""TSpectrum2::StaticSearch((TH1*)0x%zx,%g,\""%s\"",%g)"",; 2699 (size_t)this, sigma, option, threshold).Data());; 2700}; 2701 ; 2702 ; 2703////////////////////////////////////////////////////////////////////////////////; 2704/// Smooth bin contents of this 2-d histogram using kernel algorithms; 2705/// similar to the ones used in the raster graphics community.; 2706/// Bin contents in the active range are replaced by their smooth values.; 2707/// The algorithm retains the input dimension by using Kernel Crop at the input boundaries.; 2708/// Kernel Crop sets any pixel in the kernel that extends past the input to zero and adjusts the; 2709/// normalization accordingly.; 2710/// If Errors are defined via Sumw2, they are also scaled and computed.; 2711/// However, note the resulting errors will be correlated between different-bins, so; 2712/// the errors should not be used blindly to perform any calculation involving several bins,; 2713/// like fitting the histogram. One would need to compute also the bin by bin correlation matrix.; 2714///; 2715/// 3 kernels are proposed k5a, k5b and k3a.; 2716/// k5a and k5b act on 5x5 cells (i-2,i-1,i,i+1,i+2, and same for j); 2717/// k5b is a bit more stronger in smoothing; 2718/// k3a acts only on 3x3 cells (i-1,i,i+1, and same for j).; 2719/// By default the kernel ""k5a"" is used. You can select the kernels ""k5b"" or ""k3a""; 2720/// via the option argument.; 2721/// If TAxis::SetRange has been called on the x or/and y axis, only the bins; 2722/// in the specified range are smoothed.; 2723/// In the current implementation if the first argument is n",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:174519,Modifiability,extend,extendable,174519,"and optionally the error between the limits specified by the bin n...Definition TH1.cxx:7977; TH1::fTsumwx2Double_t fTsumwx2Total Sum of weight*X*X.Definition TH1.h:99; TH1::GetStdDevvirtual Double_t GetStdDev(Int_t axis=1) constReturns the Standard Deviation (Sigma).Definition TH1.cxx:7607; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associated to bin number bin.Definition TH1.cxx:9063; TH1::GetMeanvirtual Double_t GetMean(Int_t axis=1) constFor axis = 1,2 or 3 returns the mean value of the histogram along X,Y or Z axis.Definition TH1.cxx:7535; TH1::GetDimensionvirtual Int_t GetDimension() constDefinition TH1.h:283; TH1::Streamervoid Streamer(TBuffer &) overrideStream a class object.Definition TH1.cxx:6933; TH1::kIsNotW@ kIsNotWHistogram is forced to be not weighted even when the histogram is filled with weighted.Definition TH1.h:172; TH1::CanExtendAllAxesvirtual Bool_t CanExtendAllAxes() constReturns true if all axes are extendable.Definition TH1.cxx:6636; TH1::Resetvirtual void Reset(Option_t *option="""")Reset this histogram: contents, errors, etc.Definition TH1.cxx:7103; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetNcellsvirtual Int_t GetNcells() constDefinition TH1.h:300; TH1::PutStatsvirtual void PutStats(Double_t *stats)Replace current statistics with the values in array stats.Definition TH1.cxx:7884; TH1::GetPainterTVirtualHistPainter * GetPainter(Option_t *option="""")Return pointer to painter.Definition TH1.cxx:4511; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::GetBinvirtual Int_t GetBin(Int_t binx, Int_t biny=0, Int_t binz=0) constReturn Global bin number corresponding to binx,y,z.Definition TH1.cxx:4961; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::Addvirtual Bool_",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:187370,Modifiability,variab,variable,187370,"tual void FitSlicesY(TF1 *f1=nullptr, Int_t firstxbin=0, Int_t lastxbin=-1, Int_t cut=0, Option_t *option=""QNR"", TObjArray *arr=nullptr)Project slices along Y in case of a 2-D histogram, then fit each slice with function f1 and make a hi...Definition TH2.cxx:1081; TH2::GetBinWithContent2virtual Double_t GetBinWithContent2(Double_t c, Int_t &binx, Int_t &biny, Int_t firstxbin=1, Int_t lastxbin=-1, Int_t firstybin=1, Int_t lastybin=-1, Double_t maxdiff=0) constcompute first cell (binx,biny) in the range [firstxbin,lastxbin][firstybin,lastybin] for which diff =...Definition TH2.cxx:1117; TH2::ProfileXTProfile * ProfileX(const char *name=""_pfx"", Int_t firstybin=1, Int_t lastybin=-1, Option_t *option="""") constProject a 2-D histogram into a profile histogram along X.Definition TH2.cxx:2109; TH2::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH2.cxx:238; TH2::RebinTH2 * Rebin(Int_t ngroup=2, const char *newname="""", const Double_t *xbins=nullptr) overrideOverride TH1::Rebin as TH2::RebinX Rebinning in variable binning as for TH1 is not allowed If a non-n...Definition TH2.cxx:1663; TH2::FillNvoid FillN(Int_t, const Double_t *, const Double_t *, Int_t) overrideFill this histogram with an array x and weights w.Definition TH2.h:84; TH2::QuantilesYTH1D * QuantilesY(Double_t prob=0.5, const char *name=""_qy"") constCompute the Y distribution of quantiles in the other variable X name is the name of the returned hist...Definition TH2.cxx:2518; TH2::ProfileYTProfile * ProfileY(const char *name=""_pfy"", Int_t firstxbin=1, Int_t lastxbin=-1, Option_t *option="""") constProject a 2-D histogram into a profile histogram along Y.Definition TH2.cxx:2159; TH2::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH2.cxx:380; TH2::DoQuantilesvirtual TH1D * DoQuantiles(bool onX, const char *name, Double_t prob) constImplementation of quantiles for x or y.Definition TH2.cxx:2527; TH2::fTsumwxyDouble_t fTsumwxyTotal Sum of weight*X*Y.Definition TH2.h:",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:187735,Modifiability,variab,variable,187735," Int_t firstybin=1, Int_t lastybin=-1, Double_t maxdiff=0) constcompute first cell (binx,biny) in the range [firstxbin,lastxbin][firstybin,lastybin] for which diff =...Definition TH2.cxx:1117; TH2::ProfileXTProfile * ProfileX(const char *name=""_pfx"", Int_t firstybin=1, Int_t lastybin=-1, Option_t *option="""") constProject a 2-D histogram into a profile histogram along X.Definition TH2.cxx:2109; TH2::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH2.cxx:238; TH2::RebinTH2 * Rebin(Int_t ngroup=2, const char *newname="""", const Double_t *xbins=nullptr) overrideOverride TH1::Rebin as TH2::RebinX Rebinning in variable binning as for TH1 is not allowed If a non-n...Definition TH2.cxx:1663; TH2::FillNvoid FillN(Int_t, const Double_t *, const Double_t *, Int_t) overrideFill this histogram with an array x and weights w.Definition TH2.h:84; TH2::QuantilesYTH1D * QuantilesY(Double_t prob=0.5, const char *name=""_qy"") constCompute the Y distribution of quantiles in the other variable X name is the name of the returned hist...Definition TH2.cxx:2518; TH2::ProfileYTProfile * ProfileY(const char *name=""_pfy"", Int_t firstxbin=1, Int_t lastxbin=-1, Option_t *option="""") constProject a 2-D histogram into a profile histogram along Y.Definition TH2.cxx:2159; TH2::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH2.cxx:380; TH2::DoQuantilesvirtual TH1D * DoQuantiles(bool onX, const char *name, Double_t prob) constImplementation of quantiles for x or y.Definition TH2.cxx:2527; TH2::fTsumwxyDouble_t fTsumwxyTotal Sum of weight*X*Y.Definition TH2.h:36; TH2::SetBinContentvoid SetBinContent(Int_t bin, Double_t content) overrideSet bin content.Definition TH2.cxx:2616; TH2::BufferEmptyInt_t BufferEmpty(Int_t action=0) overrideFill histogram with all entries in the buffer.Definition TH2.cxx:278; TH2::DoFitSlicesvirtual void DoFitSlices(bool onX, TF1 *f1, Int_t firstbin, Int_t lastbin, Int_t cut, Option_t *option, TObjArray *arr)Definition TH2.cx",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:188858,Modifiability,variab,variable,188858,"leY(const char *name=""_pfy"", Int_t firstxbin=1, Int_t lastxbin=-1, Option_t *option="""") constProject a 2-D histogram into a profile histogram along Y.Definition TH2.cxx:2159; TH2::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH2.cxx:380; TH2::DoQuantilesvirtual TH1D * DoQuantiles(bool onX, const char *name, Double_t prob) constImplementation of quantiles for x or y.Definition TH2.cxx:2527; TH2::fTsumwxyDouble_t fTsumwxyTotal Sum of weight*X*Y.Definition TH2.h:36; TH2::SetBinContentvoid SetBinContent(Int_t bin, Double_t content) overrideSet bin content.Definition TH2.cxx:2616; TH2::BufferEmptyInt_t BufferEmpty(Int_t action=0) overrideFill histogram with all entries in the buffer.Definition TH2.cxx:278; TH2::DoFitSlicesvirtual void DoFitSlices(bool onX, TF1 *f1, Int_t firstbin, Int_t lastbin, Int_t cut, Option_t *option, TObjArray *arr)Definition TH2.cxx:814; TH2::QuantilesXTH1D * QuantilesX(Double_t prob=0.5, const char *name=""_qx"") constCompute the X distribution of quantiles in the other variable Y name is the name of the returned hist...Definition TH2.cxx:2505; TH2::SetShowProjectionYvirtual void SetShowProjectionY(Int_t nbins=1)When the mouse is moved in a pad containing a 2-d view of this histogram a second canvas shows the pr...Definition TH2.cxx:2650; TH2::FillRandomvoid FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr) overrideFill histogram following distribution in function fname.Definition TH2.cxx:714; TH2::IsATClass * IsA() const overrideDefinition TH2.h:133; TH2::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH2.cxx:2600; TH2::fScalefactorDouble_t fScalefactorScale factor.Definition TH2.h:33; TH2::DoProjectionvirtual TH1D * DoProjection(bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) constInternal (protected) method for performing projection on the X or Y axis called by ProjectionX or Pro...Definition TH2.cxx:2169; TH2::RebinXTH2 * RebinX",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:195584,Modifiability,inherit,inherits,195584,"TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::AbstractMethodvoid AbstractMethod(const char *method) constUse this method to implement an ""abstract"" method that you don't want to leave purely abstract.Definition TObject.cxx:1035; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TProfileProfile Histogram.Definition TProfile.h:32; TProfile::Classstatic TClass * Class(); TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::FirstSsiz_t First(char c) constFind first occurrence of a character c.Definition TString.cxx:538; TString::Dataconst char * Data() const",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:88682,Performance,perform,performing,88682,"nd a NULL pointer is returned.; 2147///; 2148/// NOTE that the Y axis attributes of the TH2 are copied to the X axis of the profile.; 2149///; 2150/// NOTE that the default under- / overflow behavior differs from what ProjectionX; 2151/// does! Profiles take the bin center into account, so here the under- and overflow; 2152/// bins are ignored by default.; 2153///; 2154/// NOTE that the return profile histogram is computed using the X bin center values instead of; 2155/// the real X values which are used to fill the 2d histogram. Therefore the obtained profile is just an approximation of the; 2156/// correct profile histogram that would be obtained when filling it directly with the original data (see ROOT-7770); 2157 ; 2158 ; 2159TProfile *TH2::ProfileY(const char *name, Int_t firstxbin, Int_t lastxbin, Option_t *option) const; 2160{; 2161 return DoProfile(false, name, firstxbin, lastxbin, option);; 2162}; 2163 ; 2164 ; 2165////////////////////////////////////////////////////////////////////////////////; 2166/// Internal (protected) method for performing projection on the X or Y axis; 2167/// called by ProjectionX or ProjectionY; 2168 ; 2169TH1D *TH2::DoProjection(bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) const; 2170{; 2171 const char *expectedName = nullptr;; 2172 Int_t inNbin;; 2173 const TAxis* outAxis;; 2174 const TAxis* inAxis;; 2175 ; 2176 TString opt = option;; 2177 TString cut;; 2178 Int_t i1 = opt.Index(""["");; 2179 if (i1>=0) {; 2180 Int_t i2 = opt.Index(""]"");; 2181 cut = opt(i1,i2-i1+1);; 2182 }; 2183 opt.ToLower(); //must be called after having parsed the cut name; 2184 bool originalRange = opt.Contains(""o"");; 2185 ; 2186 if ( onX ); 2187 {; 2188 expectedName = ""_px"";; 2189 inNbin = fYaxis.GetNbins();; 2190 outAxis = GetXaxis();; 2191 inAxis = GetYaxis();; 2192 }; 2193 else; 2194 {; 2195 expectedName = ""_py"";; 2196 inNbin = fXaxis.GetNbins();; 2197 outAxis = GetYaxis();; 2198 inAxis = GetXaxis();; 2199 }; 2200 ; 2201 // ",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:111221,Performance,perform,perform,111221,"::ShowPeaks(Double_t sigma, Option_t *option, Double_t threshold); 2696{; 2697 ; 2698 return (Int_t)gROOT->ProcessLineFast(TString::Format(""TSpectrum2::StaticSearch((TH1*)0x%zx,%g,\""%s\"",%g)"",; 2699 (size_t)this, sigma, option, threshold).Data());; 2700}; 2701 ; 2702 ; 2703////////////////////////////////////////////////////////////////////////////////; 2704/// Smooth bin contents of this 2-d histogram using kernel algorithms; 2705/// similar to the ones used in the raster graphics community.; 2706/// Bin contents in the active range are replaced by their smooth values.; 2707/// The algorithm retains the input dimension by using Kernel Crop at the input boundaries.; 2708/// Kernel Crop sets any pixel in the kernel that extends past the input to zero and adjusts the; 2709/// normalization accordingly.; 2710/// If Errors are defined via Sumw2, they are also scaled and computed.; 2711/// However, note the resulting errors will be correlated between different-bins, so; 2712/// the errors should not be used blindly to perform any calculation involving several bins,; 2713/// like fitting the histogram. One would need to compute also the bin by bin correlation matrix.; 2714///; 2715/// 3 kernels are proposed k5a, k5b and k3a.; 2716/// k5a and k5b act on 5x5 cells (i-2,i-1,i,i+1,i+2, and same for j); 2717/// k5b is a bit more stronger in smoothing; 2718/// k3a acts only on 3x3 cells (i-1,i,i+1, and same for j).; 2719/// By default the kernel ""k5a"" is used. You can select the kernels ""k5b"" or ""k3a""; 2720/// via the option argument.; 2721/// If TAxis::SetRange has been called on the x or/and y axis, only the bins; 2722/// in the specified range are smoothed.; 2723/// In the current implementation if the first argument is not used (default value=1).; 2724///; 2725/// implementation by David McKee (dmckee@bama.ua.edu). Extended by Rene Brun; 2726 ; 2727void TH2::Smooth(Int_t ntimes, Option_t *option); 2728{; 2729 Double_t k5a[5][5] = { { 0, 0, 1, 0, 0 },; 2730 { 0, 2, 2, 2, 0 },",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:189720,Performance,perform,performing,189720,"n_t *option, TObjArray *arr)Definition TH2.cxx:814; TH2::QuantilesXTH1D * QuantilesX(Double_t prob=0.5, const char *name=""_qx"") constCompute the X distribution of quantiles in the other variable Y name is the name of the returned hist...Definition TH2.cxx:2505; TH2::SetShowProjectionYvirtual void SetShowProjectionY(Int_t nbins=1)When the mouse is moved in a pad containing a 2-d view of this histogram a second canvas shows the pr...Definition TH2.cxx:2650; TH2::FillRandomvoid FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr) overrideFill histogram following distribution in function fname.Definition TH2.cxx:714; TH2::IsATClass * IsA() const overrideDefinition TH2.h:133; TH2::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH2.cxx:2600; TH2::fScalefactorDouble_t fScalefactorScale factor.Definition TH2.h:33; TH2::DoProjectionvirtual TH1D * DoProjection(bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) constInternal (protected) method for performing projection on the X or Y axis called by ProjectionX or Pro...Definition TH2.cxx:2169; TH2::RebinXTH2 * RebinX(Int_t ngroup=2, const char *newname="""") overrideRebin only the X axis see Rebin2D.Definition TH2.cxx:1642; TH2::fTsumwy2Double_t fTsumwy2Total Sum of weight*Y*Y.Definition TH2.h:35; TH2::GetRandom2virtual void GetRandom2(Double_t &x, Double_t &y, TRandom *rng=nullptr)Return 2 random numbers along axis x and y distributed according to the cell-contents of this 2-D his...Definition TH2.cxx:1200; TH2::GetCovariancevirtual Double_t GetCovariance(Int_t axis1=1, Int_t axis2=2) constReturn covariance between axis1 and axis2.Definition TH2.cxx:1163; TH2::GetBinInt_t GetBin(Int_t binx, Int_t biny, Int_t binz=0) const overrideReturn Global bin number corresponding to binx,y,z.Definition TH2.cxx:1086; TH2::ProjectionXTH1D * ProjectionX(const char *name=""_px"", Int_t firstybin=0, Int_t lastybin=-1, Option_t *option="""") constProject a",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:3731,Safety,avoid,avoid,3731,"mum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 63\anchor floatmax2 (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br>; 64\anchor doublemax2 (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760); 65</sup>; 66 ; 67*/; 68 ; 69 ; 70////////////////////////////////////////////////////////////////////////////////; 71/// 2-D histogram default constructor.; 72 ; 73TH2::TH2(); 74{; 75 fDimension = 2;; 76 fScalefactor = 1;; 77 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 78}; 79 ; 80 ; 81////////////////////////////////////////////////////////////////////////////////; 82/// Constructor for fix bin size 2-D histograms.; 83/// Creates the main histogram structure.; 84///; 85/// \param[in] name name of histogram (avoid blanks); 86/// \param[in] title histogram title.; 87/// If title is of the form `stringt;stringx;stringy;stringz`,; 88/// the histogram title is set to `stringt`,; 89/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 90/// \param[in] nbinsx number of bins along the X axis; 91/// \param[in] xlow low edge of the X axis first bin; 92/// \param[in] xup upper edge of the X axis last bin (not included in last bin); 93/// \param[in] nbinsy number of bins along the Y axis; 94/// \param[in] ylow low edge of the Y axis first bin; 95/// \param[in] yup upper edge of the Y axis last bin (not included in last bin); 96 ; 97TH2::TH2(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 98 ,Int_t nbinsy,Double_t ylow,Double_t yup); 99 :TH1(name,title,nbinsx,xlow,xup); 100{; 101 fDimension = 2;; 102 fScalefactor = 1;; 103 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 104 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 105 fYaxis.S",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:5101,Safety,avoid,avoid,5101,"n] xup upper edge of the X axis last bin (not included in last bin); 93/// \param[in] nbinsy number of bins along the Y axis; 94/// \param[in] ylow low edge of the Y axis first bin; 95/// \param[in] yup upper edge of the Y axis last bin (not included in last bin); 96 ; 97TH2::TH2(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 98 ,Int_t nbinsy,Double_t ylow,Double_t yup); 99 :TH1(name,title,nbinsx,xlow,xup); 100{; 101 fDimension = 2;; 102 fScalefactor = 1;; 103 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 104 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 105 fYaxis.Set(nbinsy,ylow,yup);; 106 fNcells = fNcells*(nbinsy+2); // fNCells is set in the TH1 constructor; 107}; 108 ; 109 ; 110////////////////////////////////////////////////////////////////////////////////; 111/// Constructor for variable bin size (along X axis) 2-D histograms using an input array; 112/// of type double.; 113///; 114/// \param[in] name name of histogram (avoid blanks); 115/// \param[in] title histogram title.; 116/// If title is of the form `stringt;stringx;stringy;stringz`; 117/// the histogram title is set to `stringt`,; 118/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 119/// \param[in] nbinsx number of bins; 120/// \param[in] xbins array of low-edges for each bin.; 121/// This is an array of type double and size nbinsx+1; 122/// \param[in] nbinsy number of bins along the Y axis; 123/// \param[in] ylow low edge of the Y axis first bin; 124/// \param[in] yup upper edge of the Y axis last bin (not included in last bin); 125 ; 126TH2::TH2(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 127 ,Int_t nbinsy,Double_t ylow,Double_t yup); 128 :TH1(name,title,nbinsx,xbins); 129{; 130 fDimension = 2;; 131 fScalefactor = 1;; 132 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 133 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 134 fYaxis.Set(nbinsy,ylow,yup);; 135 fNcells = f",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:6399,Safety,avoid,avoid,6399,"am[in] xbins array of low-edges for each bin.; 121/// This is an array of type double and size nbinsx+1; 122/// \param[in] nbinsy number of bins along the Y axis; 123/// \param[in] ylow low edge of the Y axis first bin; 124/// \param[in] yup upper edge of the Y axis last bin (not included in last bin); 125 ; 126TH2::TH2(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 127 ,Int_t nbinsy,Double_t ylow,Double_t yup); 128 :TH1(name,title,nbinsx,xbins); 129{; 130 fDimension = 2;; 131 fScalefactor = 1;; 132 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 133 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 134 fYaxis.Set(nbinsy,ylow,yup);; 135 fNcells = fNcells*(nbinsy+2); // fNCells is set in the TH1 constructor; 136}; 137 ; 138 ; 139////////////////////////////////////////////////////////////////////////////////; 140/// Constructor for Double_t variable bin size (along Y axis) 2-D histograms.; 141///; 142/// \param[in] name name of histogram (avoid blanks); 143/// \param[in] title histogram title.; 144/// If title is of the form `stringt;stringx;stringy;stringz`; 145/// the histogram title is set to `stringt`,; 146/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 147/// \param[in] nbinsx number of bins along the X axis; 148/// \param[in] xlow low edge of the X axis first bin; 149/// \param[in] xup upper edge of the X axis last bin (not included in last bin); 150/// \param[in] nbinsy number of bins; 151/// \param[in] ybins array of low-edges for each bin.; 152/// This is an array of type double and size nbinsy+1; 153 ; 154TH2::TH2(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 155 ,Int_t nbinsy,const Double_t *ybins); 156 :TH1(name,title,nbinsx,xlow,xup); 157{; 158 fDimension = 2;; 159 fScalefactor = 1;; 160 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 161 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 162 if (ybins) fYaxis.Set(nbinsy,ybins);; 163 ",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:7727,Safety,avoid,avoid,7727,"ow edge of the X axis first bin; 149/// \param[in] xup upper edge of the X axis last bin (not included in last bin); 150/// \param[in] nbinsy number of bins; 151/// \param[in] ybins array of low-edges for each bin.; 152/// This is an array of type double and size nbinsy+1; 153 ; 154TH2::TH2(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 155 ,Int_t nbinsy,const Double_t *ybins); 156 :TH1(name,title,nbinsx,xlow,xup); 157{; 158 fDimension = 2;; 159 fScalefactor = 1;; 160 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 161 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 162 if (ybins) fYaxis.Set(nbinsy,ybins);; 163 else fYaxis.Set(nbinsy,0,1);; 164 fNcells = fNcells*(nbinsy+2); // fNCells is set in the TH1 constructor; 165}; 166 ; 167 ; 168////////////////////////////////////////////////////////////////////////////////; 169/// Constructor for Double_t variable bin size 2-D histograms.; 170///; 171/// \param[in] name name of histogram (avoid blanks); 172/// \param[in] title histogram title.; 173/// If title is of the form `stringt;stringx;stringy;stringz`; 174/// the histogram title is set to `stringt`,; 175/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 176/// \param[in] nbinsx number of bins; 177/// \param[in] xbins array of low-edges for each bin.; 178/// This is an array of type double and size nbinsx+1; 179/// \param[in] nbinsy number of bins; 180/// \param[in] ybins array of low-edges for each bin.; 181/// This is an array of type double and size nbinsy+1; 182 ; 183TH2::TH2(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 184 ,Int_t nbinsy,const Double_t *ybins); 185 :TH1(name,title,nbinsx,xbins); 186{; 187 fDimension = 2;; 188 fScalefactor = 1;; 189 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 190 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 191 if (ybins) fYaxis.Set(nbinsy,ybins);; 192 else fYaxis.Set(nbinsy,0,1);; 193 fNcells = fNcell",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:9058,Safety,avoid,avoid,9058,"or each bin.; 178/// This is an array of type double and size nbinsx+1; 179/// \param[in] nbinsy number of bins; 180/// \param[in] ybins array of low-edges for each bin.; 181/// This is an array of type double and size nbinsy+1; 182 ; 183TH2::TH2(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 184 ,Int_t nbinsy,const Double_t *ybins); 185 :TH1(name,title,nbinsx,xbins); 186{; 187 fDimension = 2;; 188 fScalefactor = 1;; 189 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 190 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 191 if (ybins) fYaxis.Set(nbinsy,ybins);; 192 else fYaxis.Set(nbinsy,0,1);; 193 fNcells = fNcells*(nbinsy+2); // fNCells is set in the TH1 constructor; 194}; 195 ; 196 ; 197////////////////////////////////////////////////////////////////////////////////; 198/// Constructor for variable bin size (along X and Y axis) 2-D histograms using input; 199/// arrays of type float.; 200///; 201/// \param[in] name name of histogram (avoid blanks); 202/// \param[in] title histogram title.; 203/// If title is of the form `stringt;stringx;stringy;stringz`; 204/// the histogram title is set to `stringt`,; 205/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 206/// \param[in] nbinsx number of bins; 207/// \param[in] xbins array of low-edges for each bin.; 208/// This is an array of type float and size nbinsx+1; 209/// \param[in] nbinsy number of bins; 210/// \param[in] ybins array of low-edges for each bin.; 211/// This is an array of type float and size nbinsy+1; 212 ; 213TH2::TH2(const char *name,const char *title,Int_t nbinsx,const Float_t *xbins; 214 ,Int_t nbinsy,const Float_t *ybins); 215 :TH1(name,title,nbinsx,xbins); 216{; 217 fDimension = 2;; 218 fScalefactor = 1;; 219 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 220 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 221 if (ybins) fYaxis.Set(nbinsy,ybins);; 222 else fYaxis.Set(nbinsy,0,1);; 223 fNcells = fNcells*(n",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:52254,Safety,avoid,avoid,52254,"GetNbins() ) lastBinY += 1;; 1274 }; 1275 }; 1276 // check for labels axis. In that case corresponding statistics do not make sense and it is set to zero; 1277 Bool_t labelXaxis = ((const_cast<TAxis&>(fXaxis)).GetLabels() && fXaxis.CanExtend() );; 1278 Bool_t labelYaxis = ((const_cast<TAxis&>(fYaxis)).GetLabels() && fYaxis.CanExtend() );; 1279 ; 1280 for (Int_t biny = firstBinY; biny <= lastBinY; ++biny) {; 1281 Double_t y = (!labelYaxis) ? fYaxis.GetBinCenter(biny) : 0;; 1282 for (Int_t binx = firstBinX; binx <= lastBinX; ++binx) {; 1283 Double_t x = (!labelXaxis) ? fXaxis.GetBinCenter(binx) : 0;; 1284 //w = TMath::Abs(GetBinContent(bin));; 1285 Int_t bin = GetBin(binx,biny);; 1286 Double_t w = RetrieveBinContent(bin);; 1287 Double_t wx = w * x; // avoid some extra multiplications at the expense of some clarity; 1288 Double_t wy = w * y;; 1289 ; 1290 stats[0] += w;; 1291 stats[1] += GetBinErrorSqUnchecked(bin);; 1292 stats[2] += wx;; 1293 stats[3] += wx * x;; 1294 stats[4] += wy;; 1295 stats[5] += wy * y;; 1296 stats[6] += wx * y;; 1297 }; 1298 }; 1299 } else {; 1300 stats[0] = fTsumw;; 1301 stats[1] = fTsumw2;; 1302 stats[2] = fTsumwx;; 1303 stats[3] = fTsumwx2;; 1304 stats[4] = fTsumwy;; 1305 stats[5] = fTsumwy2;; 1306 stats[6] = fTsumwxy;; 1307 }; 1308}; 1309 ; 1310 ; 1311////////////////////////////////////////////////////////////////////////////////; 1312/// Return integral of bin contents. Only bins in the bins range are considered.; 1313/// By default the integral is computed as the sum of bin contents in the range.; 1314/// if option ""width"" is specified, the integral is the sum of; 1315/// the bin contents multiplied by the bin width in x and in y.; 1316 ; 1317Double_t TH2::Integral(Option_t *option) const; 1318{; 1319 return Integral(fXaxis.GetFirst(),fXaxis.GetLast(),; 1320 fYaxis.GetFirst(),fYaxis.GetLast(),option);; 1321}; 1322 ; 1323 ; 1324////////////////////////////////////////////////////////////////////////////////; 1325/// Return integral of bin ",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:78028,Safety,avoid,avoid,78028,"n = std::min(outAxis.GetLast(),outAxis.GetNbins() ) ;; 1902 ; 1903 if ( lastbin < firstbin && inAxis.TestBit(TAxis::kAxisRange) ) {; 1904 firstbin = inAxis.GetFirst();; 1905 lastbin = inAxis.GetLast();; 1906 // For special case of TAxis::SetRange, when first == 1 and last; 1907 // = N and the range bit has been set, the TAxis will return 0; 1908 // for both.; 1909 if (firstbin == 0 && lastbin == 0); 1910 {; 1911 firstbin = 1;; 1912 lastbin = inAxis.GetNbins();; 1913 }; 1914 }; 1915 if (firstbin < 0) firstbin = 1;; 1916 if (lastbin < 0) lastbin = inN;; 1917 if (lastbin > inN+1) lastbin = inN;; 1918 ; 1919 // Create the profile histogram; 1920 char *pname = (char*)name;; 1921 if (name && strcmp(name, expectedName) == 0) {; 1922 Int_t nch = strlen(GetName()) + 5;; 1923 pname = new char[nch];; 1924 snprintf(pname,nch,""%s%s"",GetName(),name);; 1925 }; 1926 TProfile *h1=nullptr;; 1927 //check if a profile with identical name exist; 1928 // if compatible reset and re-use previous histogram; 1929 TObject *h1obj = gROOT->FindObject(pname);; 1930 if (h1obj && h1obj->InheritsFrom(TH1::Class())) {; 1931 if (h1obj->IsA() != TProfile::Class() ) {; 1932 Error(""DoProfile"",""Histogram with name %s must be a TProfile and is a %s"",name,h1obj->ClassName());; 1933 return nullptr;; 1934 }; 1935 h1 = (TProfile*)h1obj;; 1936 // reset the existing histogram and set always the new binning for the axis; 1937 // This avoid problems when the histogram already exists and the histograms is rebinned or its range has changed; 1938 // (see https://savannah.cern.ch/bugs/?94101 or https://savannah.cern.ch/bugs/?95808 ); 1939 h1->Reset();; 1940 const TArrayD *xbins = outAxis.GetXbins();; 1941 if (xbins->fN == 0) {; 1942 if ( originalRange ); 1943 h1->SetBins(outAxis.GetNbins(),outAxis.GetXmin(),outAxis.GetXmax());; 1944 else; 1945 h1->SetBins(lastOutBin-firstOutBin+1,outAxis.GetBinLowEdge(firstOutBin),outAxis.GetBinUpEdge(lastOutBin));; 1946 } else {; 1947 // case variable bins; 1948 if (originalRange );",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:91312,Safety,avoid,avoid,91312," will return 0; 2211 // for both.; 2212 if (firstbin == 0 && lastbin == 0); 2213 {; 2214 firstbin = 1;; 2215 lastbin = inAxis->GetNbins();; 2216 }; 2217 }; 2218 if (firstbin < 0) firstbin = 0;; 2219 if (lastbin < 0) lastbin = inNbin + 1;; 2220 if (lastbin > inNbin+1) lastbin = inNbin + 1;; 2221 ; 2222 // Create the projection histogram; 2223 char *pname = (char*)name;; 2224 if (name && strcmp(name,expectedName) == 0) {; 2225 Int_t nch = strlen(GetName()) + 4;; 2226 pname = new char[nch];; 2227 snprintf(pname,nch,""%s%s"",GetName(),name);; 2228 }; 2229 TH1D *h1=nullptr;; 2230 //check if histogram with identical name exist; 2231 // if compatible reset and re-use previous histogram; 2232 // (see https://savannah.cern.ch/bugs/?54340); 2233 TObject *h1obj = gROOT->FindObject(pname);; 2234 if (h1obj && h1obj->InheritsFrom(TH1::Class())) {; 2235 if (h1obj->IsA() != TH1D::Class() ) {; 2236 Error(""DoProjection"",""Histogram with name %s must be a TH1D and is a %s"",name,h1obj->ClassName());; 2237 return nullptr;; 2238 }; 2239 h1 = (TH1D*)h1obj;; 2240 // reset the existing histogram and set always the new binning for the axis; 2241 // This avoid problems when the histogram already exists and the histograms is rebinned or its range has changed; 2242 // (see https://savannah.cern.ch/bugs/?94101 or https://savannah.cern.ch/bugs/?95808 ); 2243 h1->Reset();; 2244 const TArrayD *xbins = outAxis->GetXbins();; 2245 if (xbins->fN == 0) {; 2246 if ( originalRange ); 2247 h1->SetBins(outAxis->GetNbins(),outAxis->GetXmin(),outAxis->GetXmax());; 2248 else; 2249 h1->SetBins(lastOutBin-firstOutBin+1,outAxis->GetBinLowEdge(firstOutBin),outAxis->GetBinUpEdge(lastOutBin));; 2250 } else {; 2251 // case variable bins; 2252 if (originalRange ); 2253 h1->SetBins(outAxis->GetNbins(),xbins->fArray);; 2254 else; 2255 h1->SetBins(lastOutBin-firstOutBin+1,&xbins->fArray[firstOutBin-1]);; 2256 }; 2257 }; 2258 ; 2259 Int_t ncuts = 0;; 2260 if (opt.Contains(""["")) {; 2261 ((TH2 *)this)->GetPainter();; 2262 if (f",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:94028,Safety,avoid,avoid,94028,"is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; 2309 // inbin is the axis being integrated. Loop is done only on the selected bins; 2310 // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins; 2311 Bool_t extendable = outAxis->CanExtend();; 2312 if ( labels && extendable ) h1->GetXaxis()->SetCanExtend(kFALSE);; 2313 for ( Int_t outbin = 0; outbin <= outAxis->GetNbins() + 1; ++outbin) {; 2314 err2 = 0;; 2315 cont = 0;; 2316 if (outAxis->TestBit(TAxis::kAxisRange) && ( outbin < firstOutBin || outbin > lastOutBin )) continue;; 2317 ; 2318 for (Int_t inbin = firstbin ; inbin <= lastbin ; ++inbin) {; 2319 Int_t binx, biny;; 2320 if (onX) { binx = outbin; biny=inbin; }; 2321 else { binx = inbin; biny=outbin; }; 2322 ; 2323 if (ncuts) {; 2324 if (!fPainter->IsInside(binx,biny)) continue;; 2325 }; 2326 // sum bin content and error if needed; 2327 cont += GetBinContent(binx,biny);; 2328 if (computeErrors) {; 2329 Double_t exy = GetBinError(binx,biny);; 2330 err2 += exy*exy;; 2331 }; 2332 }; 2333 // find corresponding bin number in h1 for outbin; 2334 Int_t binOut = h1->GetXaxis()->FindBin( outAxis->GetBinCenter(outbin) );; 2335 h1->SetBinContent(binOut ,cont);; 2336 if (computeErrors) h1->SetBinError(binOut,TMath::Sqrt(err2));; 2337 // sum all content; 2338 totcont += cont;; 2339 }; 2340 if ( labels ) h1->GetXaxis()->SetCanExtend(extendable);; 2341 ; 2342 // check if we can re-use the original statistics from the previous histogram; 2343 bool reuseStats = false;; 2344 if ( ( GetStatOverflowsBehaviour() == false && firstbin == 1 && lastbin == inNbin ) ||; 2345 ( GetStatOverflowsBehaviour() == true && firstbin == 0 && lastbin == inNbin + 1 ) ); 2346 reuseStats = true;; 2347 else {; 2348 // also if total content match we can re-use; 2349 double eps = 1.E-12;; 2350 if (IsA() == TH2F::Class() ) eps = 1.E-6;; 2351 if (fTsumw != 0 && TMath::Abs( fTsumw - totcont) < TMath::Abs(fTsumw) * e",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:96980,Safety,avoid,avoid,96980,"tbin==0 && lastbin == inNbin+1);; 2359 if (reuseStats) {; 2360 Double_t stats[kNstat];; 2361 GetStats(stats);; 2362 if (!onX) { // case of projection on Y; 2363 stats[2] = stats[4];; 2364 stats[3] = stats[5];; 2365 }; 2366 h1->PutStats(stats);; 2367 }; 2368 else {; 2369 // the statistics is automatically recalculated since it is reset by the call to SetBinContent; 2370 // we just need to set the entries since they have not been correctly calculated during the projection; 2371 // we can only set them to the effective entries; 2372 h1->SetEntries( h1->GetEffectiveEntries() );; 2373 }; 2374 if (reuseEntries) {; 2375 h1->SetEntries(fEntries);; 2376 }; 2377 else {; 2378 // re-compute the entries; 2379 // in case of error calculation (i.e. when Sumw2() is set); 2380 // use the effective entries for the entries; 2381 // since this is the only way to estimate them; 2382 Double_t entries = TMath::Floor( totcont + 0.5); // to avoid numerical rounding; 2383 if (h1->GetSumw2N()) entries = h1->GetEffectiveEntries();; 2384 h1->SetEntries( entries );; 2385 }; 2386 ; 2387 if (opt.Contains(""d"")) {; 2388 TVirtualPad::TContext ctxt(gROOT->GetSelectedPad(), true, true);; 2389 opt.Remove(opt.First(""d""),1);; 2390 // remove also other options; 2391 if (opt.Contains(""e"")) opt.Remove(opt.First(""e""),1);; 2392 if (!gPad || !gPad->FindObject(h1)) {; 2393 h1->Draw(opt);; 2394 } else {; 2395 h1->Paint(opt);; 2396 }; 2397 }; 2398 ; 2399 return h1;; 2400}; 2401 ; 2402 ; 2403////////////////////////////////////////////////////////////////////////////////; 2404/// Project a 2-D histogram into a 1-D histogram along X.; 2405///; 2406/// The projection is always of the type TH1D.; 2407/// The projection is made from the channels along the Y axis; 2408/// ranging from firstybin to lastybin included.; 2409/// By default, all bins including under- and overflow are included.; 2410/// The number of entries in the projection is estimated from the; 2411/// number of effective entries for all the cells included",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:40060,Security,access,access,40060,"rameters) contains the chi2 distribution of; 991/// the fits.; 992///; 993/// If arr is NULL, the generated histograms are added to the list of objects; 994/// in the current directory. It is the user's responsibility to delete; 995/// these histograms.; 996///; 997/// Example: Assume a 2-d histogram h2; 998/// ~~~ {.cpp}; 999/// Root > h2->FitSlicesX(); produces 4 TH1D histograms; 1000/// with h2_0 containing parameter 0(Constant) for a Gaus fit; 1001/// of each bin in Y projected along X; 1002/// with h2_1 containing parameter 1(Mean) for a gaus fit; 1003/// with h2_2 containing parameter 2(StdDev) for a gaus fit; 1004/// with h2_chi2 containing the chisquare/number of degrees of freedom for a gaus fit; 1005///; 1006/// Root > h2->FitSlicesX(0,15,22,10);; 1007/// same as above, but only for bins 15 to 22 along Y; 1008/// and only for bins in Y for which the corresponding projection; 1009/// along X has more than cut bins filled.; 1010/// ~~~; 1011/// NOTE: To access the generated histograms in the current directory, do eg:; 1012/// ~~~ {.cpp}; 1013/// TH1D *h2_1 = (TH1D*)gDirectory->Get(""h2_1"");; 1014/// ~~~; 1015 ; 1016void TH2::FitSlicesX(TF1 *f1, Int_t firstybin, Int_t lastybin, Int_t cut, Option_t *option, TObjArray* arr); 1017{; 1018 DoFitSlices(true, f1, firstybin, lastybin, cut, option, arr);; 1019 ; 1020}; 1021 ; 1022 ; 1023////////////////////////////////////////////////////////////////////////////////; 1024/// Project slices along Y in case of a 2-D histogram, then fit each slice; 1025/// with function f1 and make a histogram for each fit parameter; 1026/// Only bins along X between firstxbin and lastxbin are considered.; 1027/// By default (firstxbin == 0, lastxbin == -1), all bins in x including; 1028/// over- and underflows are taken into account.; 1029/// If f1=0, a gaussian is assumed; 1030/// Before invoking this function, one can set a subrange to be fitted along Y; 1031/// via f1->SetRange(ymin,ymax); 1032/// The argument option (default=""QNR"") c",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:43216,Security,access,access,43216,"tains the chi2 distribution of; 1053/// the fits.; 1054///; 1055/// If arr is NULL, the generated histograms are added to the list of objects; 1056/// in the current directory. It is the user's responsibility to delete; 1057/// these histograms.; 1058///; 1059/// Example: Assume a 2-d histogram h2; 1060/// ~~~ {.cpp}; 1061/// Root > h2->FitSlicesY(); produces 4 TH1D histograms; 1062/// with h2_0 containing parameter 0(Constant) for a Gaus fit; 1063/// of each bin in X projected along Y; 1064/// with h2_1 containing parameter 1(Mean) for a gaus fit; 1065/// with h2_2 containing parameter 2(StdDev) for a gaus fit; 1066/// with h2_chi2 containing the chisquare/number of degrees of freedom for a gaus fit; 1067///; 1068/// Root > h2->FitSlicesY(0,15,22,10);; 1069/// same as above, but only for bins 15 to 22 along X; 1070/// and only for bins in X for which the corresponding projection; 1071/// along Y has more than cut bins filled.; 1072/// ~~~; 1073///; 1074/// NOTE: To access the generated histograms in the current directory, do eg:; 1075/// ~~~ {.cpp}; 1076/// TH1D *h2_1 = (TH1D*)gDirectory->Get(""h2_1"");; 1077/// ~~~; 1078///; 1079/// A complete example of this function is given in tutorial:fitslicesy.C.; 1080 ; 1081void TH2::FitSlicesY(TF1 *f1, Int_t firstxbin, Int_t lastxbin, Int_t cut, Option_t *option, TObjArray* arr); 1082{; 1083 DoFitSlices(false, f1, firstxbin, lastxbin, cut, option, arr);; 1084}; 1085 ; 1086Int_t TH2::GetBin(Int_t binx, Int_t biny, Int_t) const; 1087{; 1088 // See comments in TH1::GetBin; 1089 Int_t ofy = fYaxis.GetNbins() + 1; // overflow bin; 1090 if (biny < 0) biny = 0;; 1091 if (biny > ofy) biny = ofy;; 1092 ; 1093 return TH1::GetBin(binx) + (fXaxis.GetNbins() + 2) * biny;; 1094}; 1095 ; 1096 ; 1097////////////////////////////////////////////////////////////////////////////////; 1098/// compute first cell (binx,biny) in the range [firstxbin,lastxbin][firstybin,lastybin] for which; 1099/// diff = abs(cell_content-c) <= maxdiff; 1100/// In ca",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:193824,Security,hash,hash,193824,"r.Definition TH2.cxx:352; TH2::SetShowProjectionXYvirtual void SetShowProjectionXY(Int_t nbinsY=1, Int_t nbinsX=1)When the mouse is moved in a pad containing a 2-d view of this histogram two canvases show the projec...Definition TH2.cxx:2667; TH2::IntegralDouble_t Integral(Option_t *option="""") const overrideReturn integral of bin contents.Definition TH2.cxx:1317; TH2::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TH2.cxx:2485; TH2::RebinYvirtual TH2 * RebinY(Int_t ngroup=2, const char *newname="""")Rebin only the Y axis see Rebin2D.Definition TH2.cxx:1652; THLimitsFinder::GetLimitsFinderstatic THLimitsFinder * GetLimitsFinder()Return pointer to the current finder.Definition THLimitsFinder.cxx:153; THLimitsFinder::FindGoodLimitsvirtual Int_t FindGoodLimits(TH1 *h, Double_t xmin, Double_t xmax)Compute the best axis limits for the X axis.Definition THLimitsFinder.cxx:53; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; TIterDefinition TCollection.h:235; TMatrixTBaseTMatrixTBase.Definition TMatrixTBase.h:84; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::Expandvirtual void Expand(Int_t newSize)Expand or shrink the array to newSize elements.Definition TObjArray.cxx:387; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::AbstractMethodvoid AbstractMethod(const char *method) constUse this method to implement an ""abstract"" method that you don't wan",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:58658,Testability,test,test,58658,"f(bin_x2>GetNbinsX()) bin_x2=GetNbinsX();; 1419 Int_t bin_y1 = fYaxis.FindFixBin(y1);; 1420 if(bin_y1<1) bin_y1=1;; 1421 Int_t bin_y2 = fYaxis.FindFixBin(y2);; 1422 if(bin_y2>GetNbinsY()) bin_y2=GetNbinsY();; 1423 Int_t bin_q22 = GetBin(bin_x2,bin_y2);; 1424 Int_t bin_q12 = GetBin(bin_x1,bin_y2);; 1425 Int_t bin_q11 = GetBin(bin_x1,bin_y1);; 1426 Int_t bin_q21 = GetBin(bin_x2,bin_y1);; 1427 Double_t q11 = RetrieveBinContent(bin_q11);; 1428 Double_t q12 = RetrieveBinContent(bin_q12);; 1429 Double_t q21 = RetrieveBinContent(bin_q21);; 1430 Double_t q22 = RetrieveBinContent(bin_q22);; 1431 Double_t d = 1.0*(x2-x1)*(y2-y1);; 1432 f = 1.0*q11/d*(x2-x)*(y2-y)+1.0*q21/d*(x-x1)*(y2-y)+1.0*q12/d*(x2-x)*(y-y1)+1.0*q22/d*(x-x1)*(y-y1);; 1433 return f;; 1434}; 1435 ; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438///illegal for a TH2; 1439 ; 1440Double_t TH2::Interpolate(Double_t, Double_t, Double_t) const; 1441{; 1442 Error(""Interpolate"",""This function must be called with 2 arguments for a TH2"");; 1443 return 0;; 1444}; 1445 ; 1446 ; 1447////////////////////////////////////////////////////////////////////////////////; 1448/// Statistical test of compatibility in shape between; 1449/// THIS histogram and h2, using Kolmogorov test.; 1450/// Default: Ignore under- and overflow bins in comparison; 1451///; 1452/// option is a character string to specify options; 1453/// - ""U"" include Underflows in test; 1454/// - ""O"" include Overflows; 1455/// - ""N"" include comparison of normalizations; 1456/// - ""D"" Put out a line of ""Debug"" printout; 1457/// - ""M"" Return the Maximum Kolmogorov distance instead of prob; 1458///; 1459/// The returned function value is the probability of test; 1460/// (much less than one means NOT compatible); 1461///; 1462/// The KS test uses the distance between the pseudo-CDF's obtained; 1463/// from the histogram. Since in 2D the order for generating the pseudo-CDF is; 1464/// arbitrary, two pairs of pseudo-CDF ",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:58746,Testability,test,test,58746,"f(bin_x2>GetNbinsX()) bin_x2=GetNbinsX();; 1419 Int_t bin_y1 = fYaxis.FindFixBin(y1);; 1420 if(bin_y1<1) bin_y1=1;; 1421 Int_t bin_y2 = fYaxis.FindFixBin(y2);; 1422 if(bin_y2>GetNbinsY()) bin_y2=GetNbinsY();; 1423 Int_t bin_q22 = GetBin(bin_x2,bin_y2);; 1424 Int_t bin_q12 = GetBin(bin_x1,bin_y2);; 1425 Int_t bin_q11 = GetBin(bin_x1,bin_y1);; 1426 Int_t bin_q21 = GetBin(bin_x2,bin_y1);; 1427 Double_t q11 = RetrieveBinContent(bin_q11);; 1428 Double_t q12 = RetrieveBinContent(bin_q12);; 1429 Double_t q21 = RetrieveBinContent(bin_q21);; 1430 Double_t q22 = RetrieveBinContent(bin_q22);; 1431 Double_t d = 1.0*(x2-x1)*(y2-y1);; 1432 f = 1.0*q11/d*(x2-x)*(y2-y)+1.0*q21/d*(x-x1)*(y2-y)+1.0*q12/d*(x2-x)*(y-y1)+1.0*q22/d*(x-x1)*(y-y1);; 1433 return f;; 1434}; 1435 ; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438///illegal for a TH2; 1439 ; 1440Double_t TH2::Interpolate(Double_t, Double_t, Double_t) const; 1441{; 1442 Error(""Interpolate"",""This function must be called with 2 arguments for a TH2"");; 1443 return 0;; 1444}; 1445 ; 1446 ; 1447////////////////////////////////////////////////////////////////////////////////; 1448/// Statistical test of compatibility in shape between; 1449/// THIS histogram and h2, using Kolmogorov test.; 1450/// Default: Ignore under- and overflow bins in comparison; 1451///; 1452/// option is a character string to specify options; 1453/// - ""U"" include Underflows in test; 1454/// - ""O"" include Overflows; 1455/// - ""N"" include comparison of normalizations; 1456/// - ""D"" Put out a line of ""Debug"" printout; 1457/// - ""M"" Return the Maximum Kolmogorov distance instead of prob; 1458///; 1459/// The returned function value is the probability of test; 1460/// (much less than one means NOT compatible); 1461///; 1462/// The KS test uses the distance between the pseudo-CDF's obtained; 1463/// from the histogram. Since in 2D the order for generating the pseudo-CDF is; 1464/// arbitrary, two pairs of pseudo-CDF ",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:58919,Testability,test,test,58919,"Double_t d = 1.0*(x2-x1)*(y2-y1);; 1432 f = 1.0*q11/d*(x2-x)*(y2-y)+1.0*q21/d*(x-x1)*(y2-y)+1.0*q12/d*(x2-x)*(y-y1)+1.0*q22/d*(x-x1)*(y-y1);; 1433 return f;; 1434}; 1435 ; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438///illegal for a TH2; 1439 ; 1440Double_t TH2::Interpolate(Double_t, Double_t, Double_t) const; 1441{; 1442 Error(""Interpolate"",""This function must be called with 2 arguments for a TH2"");; 1443 return 0;; 1444}; 1445 ; 1446 ; 1447////////////////////////////////////////////////////////////////////////////////; 1448/// Statistical test of compatibility in shape between; 1449/// THIS histogram and h2, using Kolmogorov test.; 1450/// Default: Ignore under- and overflow bins in comparison; 1451///; 1452/// option is a character string to specify options; 1453/// - ""U"" include Underflows in test; 1454/// - ""O"" include Overflows; 1455/// - ""N"" include comparison of normalizations; 1456/// - ""D"" Put out a line of ""Debug"" printout; 1457/// - ""M"" Return the Maximum Kolmogorov distance instead of prob; 1458///; 1459/// The returned function value is the probability of test; 1460/// (much less than one means NOT compatible); 1461///; 1462/// The KS test uses the distance between the pseudo-CDF's obtained; 1463/// from the histogram. Since in 2D the order for generating the pseudo-CDF is; 1464/// arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; 1465/// other from the y axis and the maximum distance is the average of the two maximum; 1466/// distances obtained.; 1467///; 1468/// Code adapted by Rene Brun from original HBOOK routine HDIFF; 1469 ; 1470Double_t TH2::KolmogorovTest(const TH1 *h2, Option_t *option) const; 1471{; 1472 TString opt = option;; 1473 opt.ToUpper();; 1474 ; 1475 Double_t prb = 0;; 1476 TH1 *h1 = (TH1*)this;; 1477 if (h2 == nullptr) return 0;; 1478 const TAxis *xaxis1 = h1->GetXaxis();; 1479 const TAxis *xaxis2 = h2->GetXaxis();; 1480 const TAxis *yaxis1 = h1->GetY",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:59197,Testability,test,test,59197,"Double_t d = 1.0*(x2-x1)*(y2-y1);; 1432 f = 1.0*q11/d*(x2-x)*(y2-y)+1.0*q21/d*(x-x1)*(y2-y)+1.0*q12/d*(x2-x)*(y-y1)+1.0*q22/d*(x-x1)*(y-y1);; 1433 return f;; 1434}; 1435 ; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438///illegal for a TH2; 1439 ; 1440Double_t TH2::Interpolate(Double_t, Double_t, Double_t) const; 1441{; 1442 Error(""Interpolate"",""This function must be called with 2 arguments for a TH2"");; 1443 return 0;; 1444}; 1445 ; 1446 ; 1447////////////////////////////////////////////////////////////////////////////////; 1448/// Statistical test of compatibility in shape between; 1449/// THIS histogram and h2, using Kolmogorov test.; 1450/// Default: Ignore under- and overflow bins in comparison; 1451///; 1452/// option is a character string to specify options; 1453/// - ""U"" include Underflows in test; 1454/// - ""O"" include Overflows; 1455/// - ""N"" include comparison of normalizations; 1456/// - ""D"" Put out a line of ""Debug"" printout; 1457/// - ""M"" Return the Maximum Kolmogorov distance instead of prob; 1458///; 1459/// The returned function value is the probability of test; 1460/// (much less than one means NOT compatible); 1461///; 1462/// The KS test uses the distance between the pseudo-CDF's obtained; 1463/// from the histogram. Since in 2D the order for generating the pseudo-CDF is; 1464/// arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; 1465/// other from the y axis and the maximum distance is the average of the two maximum; 1466/// distances obtained.; 1467///; 1468/// Code adapted by Rene Brun from original HBOOK routine HDIFF; 1469 ; 1470Double_t TH2::KolmogorovTest(const TH1 *h2, Option_t *option) const; 1471{; 1472 TString opt = option;; 1473 opt.ToUpper();; 1474 ; 1475 Double_t prb = 0;; 1476 TH1 *h1 = (TH1*)this;; 1477 if (h2 == nullptr) return 0;; 1478 const TAxis *xaxis1 = h1->GetXaxis();; 1479 const TAxis *xaxis2 = h2->GetXaxis();; 1480 const TAxis *yaxis1 = h1->GetY",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:59278,Testability,test,test,59278,"Double_t d = 1.0*(x2-x1)*(y2-y1);; 1432 f = 1.0*q11/d*(x2-x)*(y2-y)+1.0*q21/d*(x-x1)*(y2-y)+1.0*q12/d*(x2-x)*(y-y1)+1.0*q22/d*(x-x1)*(y-y1);; 1433 return f;; 1434}; 1435 ; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438///illegal for a TH2; 1439 ; 1440Double_t TH2::Interpolate(Double_t, Double_t, Double_t) const; 1441{; 1442 Error(""Interpolate"",""This function must be called with 2 arguments for a TH2"");; 1443 return 0;; 1444}; 1445 ; 1446 ; 1447////////////////////////////////////////////////////////////////////////////////; 1448/// Statistical test of compatibility in shape between; 1449/// THIS histogram and h2, using Kolmogorov test.; 1450/// Default: Ignore under- and overflow bins in comparison; 1451///; 1452/// option is a character string to specify options; 1453/// - ""U"" include Underflows in test; 1454/// - ""O"" include Overflows; 1455/// - ""N"" include comparison of normalizations; 1456/// - ""D"" Put out a line of ""Debug"" printout; 1457/// - ""M"" Return the Maximum Kolmogorov distance instead of prob; 1458///; 1459/// The returned function value is the probability of test; 1460/// (much less than one means NOT compatible); 1461///; 1462/// The KS test uses the distance between the pseudo-CDF's obtained; 1463/// from the histogram. Since in 2D the order for generating the pseudo-CDF is; 1464/// arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; 1465/// other from the y axis and the maximum distance is the average of the two maximum; 1466/// distances obtained.; 1467///; 1468/// Code adapted by Rene Brun from original HBOOK routine HDIFF; 1469 ; 1470Double_t TH2::KolmogorovTest(const TH1 *h2, Option_t *option) const; 1471{; 1472 TString opt = option;; 1473 opt.ToUpper();; 1474 ; 1475 Double_t prb = 0;; 1476 TH1 *h1 = (TH1*)this;; 1477 if (h2 == nullptr) return 0;; 1478 const TAxis *xaxis1 = h1->GetXaxis();; 1479 const TAxis *xaxis2 = h2->GetXaxis();; 1480 const TAxis *yaxis1 = h1->GetY",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:84481,Testability,log,logical,84481," of entries is incremented by 1 for all non empty cells.; 2075///; 2076/// if option ""d"" is specified, the profile is drawn in the current pad.; 2077///; 2078/// if option ""o"" original axis range of the target axes will be; 2079/// kept, but only bins inside the selected range will be filled.; 2080///; 2081/// The option can also be used to specify the projected profile error type.; 2082/// Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details; 2083///; 2084/// Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; 2085/// One must create a graphical cut (mouse or C++) and specify the name; 2086/// of the cut between [] in the option.; 2087/// For example, with a TCutG named ""cutg"", one can call:; 2088/// myhist->ProfileX("" "",firstybin,lastybin,""[cutg]"");; 2089/// To invert the cut, it is enough to put a ""-"" in front of its name:; 2090/// myhist->ProfileX("" "",firstybin,lastybin,""[-cutg]"");; 2091/// It is possible to apply several cuts ("","" means logical AND):; 2092/// myhist->ProfileX("" "",firstybin,lastybin,""[cutg1,cutg2]"");; 2093///; 2094/// NOTE that if a TProfile named ""name"" exists in the current directory or pad with; 2095/// a compatible axis the profile is reset and filled again with the projected contents of the TH2.; 2096/// In the case of axis incompatibility an error is reported and a NULL pointer is returned.; 2097///; 2098/// NOTE that the X axis attributes of the TH2 are copied to the X axis of the profile.; 2099///; 2100/// NOTE that the default under- / overflow behavior differs from what ProjectionX; 2101/// does! Profiles take the bin center into account, so here the under- and overflow; 2102/// bins are ignored by default.; 2103///; 2104/// NOTE that the return profile histogram is computed using the Y bin center values instead of; 2105/// the real Y values which are used to fill the 2d histogram. Therefore the obtained profile is just an approximation of the; 2106/// correct profile histogr",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:186191,Testability,test,test,186191,"onY(const char *name=""_py"", Int_t firstxbin=0, Int_t lastxbin=-1, Option_t *option="""") constProject a 2-D histogram into a 1-D histogram along Y.Definition TH2.cxx:2476; TH2::GetStatsvoid GetStats(Double_t *stats) const overrideFill the array stats from the contents of this histogram The array stats must be correctly dimensione...Definition TH2.cxx:1254; TH2::ShowPeaksInt_t ShowPeaks(Double_t sigma=2, Option_t *option="""", Double_t threshold=0.05) overrideInterface to TSpectrum2::Search the function finds peaks in this histogram where the width is > sigma...Definition TH2.cxx:2695; TH2::GetCorrelationFactorvirtual Double_t GetCorrelationFactor(Int_t axis1=1, Int_t axis2=2) constReturn correlation factor between axis1 and axis2.Definition TH2.cxx:1145; TH2::DoProfilevirtual TProfile * DoProfile(bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) constDefinition TH2.cxx:1880; TH2::KolmogorovTestDouble_t KolmogorovTest(const TH1 *h2, Option_t *option="""") const overrideStatistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test.Definition TH2.cxx:1470; TH2::FitSlicesYvirtual void FitSlicesY(TF1 *f1=nullptr, Int_t firstxbin=0, Int_t lastxbin=-1, Int_t cut=0, Option_t *option=""QNR"", TObjArray *arr=nullptr)Project slices along Y in case of a 2-D histogram, then fit each slice with function f1 and make a hi...Definition TH2.cxx:1081; TH2::GetBinWithContent2virtual Double_t GetBinWithContent2(Double_t c, Int_t &binx, Int_t &biny, Int_t firstxbin=1, Int_t lastxbin=-1, Int_t firstybin=1, Int_t lastybin=-1, Double_t maxdiff=0) constcompute first cell (binx,biny) in the range [firstxbin,lastxbin][firstybin,lastybin] for which diff =...Definition TH2.cxx:1117; TH2::ProfileXTProfile * ProfileX(const char *name=""_pfx"", Int_t firstybin=1, Int_t lastybin=-1, Option_t *option="""") constProject a 2-D histogram into a profile histogram along X.Definition TH2.cxx:2109; TH2::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrem",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:186270,Testability,test,test,186270,"onY(const char *name=""_py"", Int_t firstxbin=0, Int_t lastxbin=-1, Option_t *option="""") constProject a 2-D histogram into a 1-D histogram along Y.Definition TH2.cxx:2476; TH2::GetStatsvoid GetStats(Double_t *stats) const overrideFill the array stats from the contents of this histogram The array stats must be correctly dimensione...Definition TH2.cxx:1254; TH2::ShowPeaksInt_t ShowPeaks(Double_t sigma=2, Option_t *option="""", Double_t threshold=0.05) overrideInterface to TSpectrum2::Search the function finds peaks in this histogram where the width is > sigma...Definition TH2.cxx:2695; TH2::GetCorrelationFactorvirtual Double_t GetCorrelationFactor(Int_t axis1=1, Int_t axis2=2) constReturn correlation factor between axis1 and axis2.Definition TH2.cxx:1145; TH2::DoProfilevirtual TProfile * DoProfile(bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) constDefinition TH2.cxx:1880; TH2::KolmogorovTestDouble_t KolmogorovTest(const TH1 *h2, Option_t *option="""") const overrideStatistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test.Definition TH2.cxx:1470; TH2::FitSlicesYvirtual void FitSlicesY(TF1 *f1=nullptr, Int_t firstxbin=0, Int_t lastxbin=-1, Int_t cut=0, Option_t *option=""QNR"", TObjArray *arr=nullptr)Project slices along Y in case of a 2-D histogram, then fit each slice with function f1 and make a hi...Definition TH2.cxx:1081; TH2::GetBinWithContent2virtual Double_t GetBinWithContent2(Double_t c, Int_t &binx, Int_t &biny, Int_t firstxbin=1, Int_t lastxbin=-1, Int_t firstybin=1, Int_t lastybin=-1, Double_t maxdiff=0) constcompute first cell (binx,biny) in the range [firstxbin,lastxbin][firstybin,lastybin] for which diff =...Definition TH2.cxx:1117; TH2::ProfileXTProfile * ProfileX(const char *name=""_pfx"", Int_t firstybin=1, Int_t lastybin=-1, Option_t *option="""") constProject a 2-D histogram into a profile histogram along X.Definition TH2.cxx:2109; TH2::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrem",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:198844,Testability,log,logarithm,198844,"t_t y)=0; TVirtualHistPainter::SetShowProjectionXYvirtual void SetShowProjectionXY(const char *option, Int_t nbinsY, Int_t nbinsX)=0; TVirtualPad::TContextsmall helper class to store/restore gPad context in TPad methodsDefinition TVirtualPad.h:61; bool; double; int; unsigned int; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; h1TH1F * h1Definition legend1.C:5; f1TF1 * f1Definition legend1.C:11; TMath::GausDouble_t Gaus(Double_t x, Double_t mean=0, Double_t sigma=1, Bool_t norm=kFALSE)Calculates a gaussian function with mean and sigma.Definition TMath.cxx:471; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf...Definition TMath.cxx:637; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::KolmogorovProbDouble_t KolmogorovProb(Double_t z)Calculates the Kolmogorov distribution function,.Definition TMath.cxx:679; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; mTMarker mDefinition textangle.C:8. histhistsrcTH2.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8cxx_source.html:49997,Usability,simpl,simply,49997,"l == TMath::QuietNaN() ) { x = TMath::QuietNaN(); y = TMath::QuietNaN(); return;}; 1216 ; 1217 if (!rng) rng = gRandom;; 1218 Double_t r1 = rng->Rndm();; 1219 Int_t ibin = TMath::BinarySearch(nbins,fIntegral,(Double_t) r1);; 1220 Int_t biny = ibin/nbinsx;; 1221 Int_t binx = ibin - nbinsx*biny;; 1222 x = fXaxis.GetBinLowEdge(binx+1);; 1223 if (r1 > fIntegral[ibin]) x +=; 1224 fXaxis.GetBinWidth(binx+1)*(r1-fIntegral[ibin])/(fIntegral[ibin+1] - fIntegral[ibin]);; 1225 y = fYaxis.GetBinLowEdge(biny+1) + fYaxis.GetBinWidth(biny+1)*rng->Rndm();; 1226}; 1227 ; 1228 ; 1229////////////////////////////////////////////////////////////////////////////////; 1230/// Fill the array stats from the contents of this histogram; 1231/// The array stats must be correctly dimensioned in the calling program.; 1232/// ~~~ {.cpp}; 1233/// stats[0] = sumw; 1234/// stats[1] = sumw2; 1235/// stats[2] = sumwx; 1236/// stats[3] = sumwx2; 1237/// stats[4] = sumwy; 1238/// stats[5] = sumwy2; 1239/// stats[6] = sumwxy; 1240/// ~~~; 1241///; 1242/// If no axis-subranges are specified (via TAxis::SetRange), the array stats; 1243/// is simply a copy of the statistics quantities computed at filling time.; 1244/// If sub-ranges are specified, the function recomputes these quantities; 1245/// from the bin contents in the current axis ranges.; 1246///; 1247/// Note that the mean value/StdDev is computed using the bins in the currently; 1248/// defined ranges (see TAxis::SetRange). By default the ranges include; 1249/// all bins from 1 to nbins included, excluding underflows and overflows.; 1250/// To force the underflows and overflows in the computation, one must; 1251/// call the static function TH1::StatOverflows(kTRUE) before filling; 1252/// the histogram.; 1253 ; 1254void TH2::GetStats(Double_t *stats) const; 1255{; 1256 if (fBuffer) ((TH2*)this)->BufferEmpty();; 1257 ; 1258 if ((fTsumw == 0 && fEntries > 0) || fXaxis.TestBit(TAxis::kAxisRange) || fYaxis.TestBit(TAxis::kAxisRange)) {; 1259 std::fill",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
https://root.cern/doc/master/TH2_8h.html:243,Integrability,depend,dependency,243,". ROOT: hist/hist/inc/TH2.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TH2.h File Reference. #include ""TH1.h""; #include ""TMatrixFBasefwd.h""; #include ""TMatrixDBasefwd.h"". Include dependency graph for TH2.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TH2;  Service class for 2-D histogram classes. More...;  ; class  TH2C;  2-D histogram with a byte per channel (see TH1 documentation) More...;  ; class  TH2D;  2-D histogram with a double per channel (see TH1 documentation) More...;  ; class  TH2F;  2-D histogram with a float per channel (see TH1 documentation) More...;  ; class  TH2I;  2-D histogram with an int per channel (see TH1 documentation) More...;  ; class  TH2L;  2-D histogram with a long64 per channel (see TH1 documentation) More...;  ; class  TH2S;  2-D histogram with a short per channel (see TH1 documentation) More...;  . histhistincTH2.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TH2_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8h.html
https://root.cern/doc/master/TH2_8h_source.html:23022,Availability,error,error,23022,"bits per element).Definition TArrayF.h:27; TArrayF::fArrayFloat_t * fArrayDefinition TArrayF.h:30; TArrayF::Resetvoid Reset()Definition TArrayF.h:47; TArrayIArray of integers (32 bits per element).Definition TArrayI.h:27; TArrayI::fArrayInt_t * fArrayDefinition TArrayI.h:30; TArrayI::Resetvoid Reset()Definition TArrayI.h:47; TArrayL64Array of long64s (64 bits per element).Definition TArrayL64.h:27; TArrayL64::fArrayLong64_t * fArrayDefinition TArrayL64.h:30; TArrayL64::Resetvoid Reset()Definition TArrayL64.h:47; TArraySArray of shorts (16 bits per element).Definition TArrayS.h:27; TArrayS::Resetvoid Reset()Definition TArrayS.h:47; TArrayS::fArrayShort_t * fArrayDefinition TArrayS.h:30; TF11-Dim function classDefinition TF1.h:233; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::IntegralAndErrorvirtual Double_t IntegralAndError(Int_t binx1, Int_t binx2, Double_t &err, Option_t *option="""") constReturn integral of bin contents in range [binx1,binx2] and its error.Definition TH1.cxx:7968; TH1::GetBinErrorLowvirtual Double_t GetBinErrorLow(Int_t bin) constReturn lower error associated to bin number bin.Definition TH1.cxx:9079; TH1::Integralvirtual Double_t Integral(Option_t *option="""") constReturn integral of bin contents.Definition TH1.cxx:7941; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t bin) constReturn upper error associated to bin number bin.Definition TH1.cxx:9110; TH2C2-D histogram with a byte per channel (see TH1 documentation)Definition TH2.h:139; TH2C::operator*friend TH2C operator*(TH2C const &h1, Float_t c1)Definition TH2.h:166; TH2C::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH2.cxx:2990; TH2C::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny,",MatchSource.WIKI,doc/master/TH2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8h_source.html
https://root.cern/doc/master/TH2_8h_source.html:23133,Availability,error,error,23133,"32 bits per element).Definition TArrayI.h:27; TArrayI::fArrayInt_t * fArrayDefinition TArrayI.h:30; TArrayI::Resetvoid Reset()Definition TArrayI.h:47; TArrayL64Array of long64s (64 bits per element).Definition TArrayL64.h:27; TArrayL64::fArrayLong64_t * fArrayDefinition TArrayL64.h:30; TArrayL64::Resetvoid Reset()Definition TArrayL64.h:47; TArraySArray of shorts (16 bits per element).Definition TArrayS.h:27; TArrayS::Resetvoid Reset()Definition TArrayS.h:47; TArrayS::fArrayShort_t * fArrayDefinition TArrayS.h:30; TF11-Dim function classDefinition TF1.h:233; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::IntegralAndErrorvirtual Double_t IntegralAndError(Int_t binx1, Int_t binx2, Double_t &err, Option_t *option="""") constReturn integral of bin contents in range [binx1,binx2] and its error.Definition TH1.cxx:7968; TH1::GetBinErrorLowvirtual Double_t GetBinErrorLow(Int_t bin) constReturn lower error associated to bin number bin.Definition TH1.cxx:9079; TH1::Integralvirtual Double_t Integral(Option_t *option="""") constReturn integral of bin contents.Definition TH1.cxx:7941; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t bin) constReturn upper error associated to bin number bin.Definition TH1.cxx:9110; TH2C2-D histogram with a byte per channel (see TH1 documentation)Definition TH2.h:139; TH2C::operator*friend TH2C operator*(TH2C const &h1, Float_t c1)Definition TH2.h:166; TH2C::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH2.cxx:2990; TH2C::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Double_t w) overrideIncrement 2D bin content by a weight w.Definition TH2.h:159; TH2C::operator+friend TH2C operator+(TH2C const &h1, TH2C const &h2)Operator +.Definition TH2.",MatchSource.WIKI,doc/master/TH2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8h_source.html
https://root.cern/doc/master/TH2_8h_source.html:23516,Availability,error,error,23516,"t).Definition TArrayS.h:27; TArrayS::Resetvoid Reset()Definition TArrayS.h:47; TArrayS::fArrayShort_t * fArrayDefinition TArrayS.h:30; TF11-Dim function classDefinition TF1.h:233; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::IntegralAndErrorvirtual Double_t IntegralAndError(Int_t binx1, Int_t binx2, Double_t &err, Option_t *option="""") constReturn integral of bin contents in range [binx1,binx2] and its error.Definition TH1.cxx:7968; TH1::GetBinErrorLowvirtual Double_t GetBinErrorLow(Int_t bin) constReturn lower error associated to bin number bin.Definition TH1.cxx:9079; TH1::Integralvirtual Double_t Integral(Option_t *option="""") constReturn integral of bin contents.Definition TH1.cxx:7941; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t bin) constReturn upper error associated to bin number bin.Definition TH1.cxx:9110; TH2C2-D histogram with a byte per channel (see TH1 documentation)Definition TH2.h:139; TH2C::operator*friend TH2C operator*(TH2C const &h1, Float_t c1)Definition TH2.h:166; TH2C::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH2.cxx:2990; TH2C::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Double_t w) overrideIncrement 2D bin content by a weight w.Definition TH2.h:159; TH2C::operator+friend TH2C operator+(TH2C const &h1, TH2C const &h2)Operator +.Definition TH2.cxx:3070; TH2C::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH2.h:173; TH2C::operator*friend TH2C operator*(Float_t c1, TH2C const &h1)Operator *.Definition TH2.cxx:3058; TH2C::operator/friend TH2C operator/(TH2C const &h1, TH2C const &h2)Ope",MatchSource.WIKI,doc/master/TH2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8h_source.html
https://root.cern/doc/master/TH2_8h_source.html:23832,Availability,error,errors,23832,"togram classes in ROOT.Definition TH1.h:59; TH1::IntegralAndErrorvirtual Double_t IntegralAndError(Int_t binx1, Int_t binx2, Double_t &err, Option_t *option="""") constReturn integral of bin contents in range [binx1,binx2] and its error.Definition TH1.cxx:7968; TH1::GetBinErrorLowvirtual Double_t GetBinErrorLow(Int_t bin) constReturn lower error associated to bin number bin.Definition TH1.cxx:9079; TH1::Integralvirtual Double_t Integral(Option_t *option="""") constReturn integral of bin contents.Definition TH1.cxx:7941; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t bin) constReturn upper error associated to bin number bin.Definition TH1.cxx:9110; TH2C2-D histogram with a byte per channel (see TH1 documentation)Definition TH2.h:139; TH2C::operator*friend TH2C operator*(TH2C const &h1, Float_t c1)Definition TH2.h:166; TH2C::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH2.cxx:2990; TH2C::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Double_t w) overrideIncrement 2D bin content by a weight w.Definition TH2.h:159; TH2C::operator+friend TH2C operator+(TH2C const &h1, TH2C const &h2)Operator +.Definition TH2.cxx:3070; TH2C::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH2.h:173; TH2C::operator*friend TH2C operator*(Float_t c1, TH2C const &h1)Operator *.Definition TH2.cxx:3058; TH2C::operator/friend TH2C operator/(TH2C const &h1, TH2C const &h2)Operator /.Definition TH2.cxx:3106; TH2C::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH2.h:174; TH2C::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny) o",MatchSource.WIKI,doc/master/TH2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8h_source.html
https://root.cern/doc/master/TH2_8h_source.html:39684,Availability,error,errors,39684," TH2::DoFitSlicesvirtual void DoFitSlices(bool onX, TF1 *f1, Int_t firstbin, Int_t lastbin, Int_t cut, Option_t *option, TObjArray *arr)Definition TH2.cxx:814; TH2::QuantilesXTH1D * QuantilesX(Double_t prob=0.5, const char *name=""_qx"") constCompute the X distribution of quantiles in the other variable Y name is the name of the returned hist...Definition TH2.cxx:2505; TH2::SetShowProjectionYvirtual void SetShowProjectionY(Int_t nbins=1)When the mouse is moved in a pad containing a 2-d view of this histogram a second canvas shows the pr...Definition TH2.cxx:2650; TH2::SetBinContentvoid SetBinContent(Int_t binx, Int_t biny, Int_t, Double_t content) overrideDefinition TH2.h:125; TH2::FillRandomvoid FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr) overrideFill histogram following distribution in function fname.Definition TH2.cxx:714; TH2::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t binx, Int_t biny)Definition TH2.h:98; TH2::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH2.cxx:2600; TH2::fScalefactorDouble_t fScalefactorScale factor.Definition TH2.h:33; TH2::DoProjectionvirtual TH1D * DoProjection(bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) constInternal (protected) method for performing projection on the X or Y axis called by ProjectionX or Pro...Definition TH2.cxx:2169; TH2::RebinXTH2 * RebinX(Int_t ngroup=2, const char *newname="""") overrideRebin only the X axis see Rebin2D.Definition TH2.cxx:1642; TH2::fTsumwy2Double_t fTsumwy2Total Sum of weight*Y*Y.Definition TH2.h:35; TH2::GetRandom2virtual void GetRandom2(Double_t &x, Double_t &y, TRandom *rng=nullptr)Return 2 random numbers along axis x and y distributed according to the cell-contents of this 2-D his...Definition TH2.cxx:1200; TH2::SetBinContentvoid SetBinContent(Int_t binx, Int_t biny, Double_t content) overrideDefinition TH2.h:124; TH2::GetCovariancevirtual Double_t GetCovariance(Int_t axis1=1, Int",MatchSource.WIKI,doc/master/TH2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8h_source.html
https://root.cern/doc/master/TH2_8h_source.html:24608,Deployability,update,update,24608," channel (see TH1 documentation)Definition TH2.h:139; TH2C::operator*friend TH2C operator*(TH2C const &h1, Float_t c1)Definition TH2.h:166; TH2C::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH2.cxx:2990; TH2C::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Double_t w) overrideIncrement 2D bin content by a weight w.Definition TH2.h:159; TH2C::operator+friend TH2C operator+(TH2C const &h1, TH2C const &h2)Operator +.Definition TH2.cxx:3070; TH2C::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH2.h:173; TH2C::operator*friend TH2C operator*(Float_t c1, TH2C const &h1)Operator *.Definition TH2.cxx:3058; TH2C::operator/friend TH2C operator/(TH2C const &h1, TH2C const &h2)Operator /.Definition TH2.cxx:3106; TH2C::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH2.h:174; TH2C::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny) overrideIncrement 2D bin content by 1.Definition TH2.h:158; TH2C::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH2.cxx:2958; TH2C::TH2CTH2C()Constructor.Definition TH2.cxx:2864; TH2C::operator=TH2C & operator=(const TH2C &h1)Operator =.Definition TH2.cxx:3047; TH2C::~TH2C~TH2C() overrideDestructor.Definition TH2.cxx:2874; TH2C::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH2.cxx:2981; TH2C::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH2.cxx:3001; TH2C::operator-friend TH2C operator-(TH2C const &h1, TH2C const &h2)Operator -.Definition TH2.cxx:3082; TH2D2-D histogram with a double per channel (see TH1 documentation)Definition TH2.h:357; TH2D::UpdateBin",MatchSource.WIKI,doc/master/TH2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8h_source.html
https://root.cern/doc/master/TH2_8h_source.html:25680,Deployability,update,update,25680,"ng bins in TH1::GetBin...Definition TH2.h:174; TH2C::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny) overrideIncrement 2D bin content by 1.Definition TH2.h:158; TH2C::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH2.cxx:2958; TH2C::TH2CTH2C()Constructor.Definition TH2.cxx:2864; TH2C::operator=TH2C & operator=(const TH2C &h1)Operator =.Definition TH2.cxx:3047; TH2C::~TH2C~TH2C() overrideDestructor.Definition TH2.cxx:2874; TH2C::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH2.cxx:2981; TH2C::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH2.cxx:3001; TH2C::operator-friend TH2C operator-(TH2C const &h1, TH2C const &h2)Operator -.Definition TH2.cxx:3082; TH2D2-D histogram with a double per channel (see TH1 documentation)Definition TH2.h:357; TH2D::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH2.h:398; TH2D::operator-friend TH2D operator-(TH2D const &h1, TH2D const &h2)Operator -.Definition TH2.cxx:4340; TH2D::operator+friend TH2D operator+(TH2D const &h1, TH2D const &h2)Operator +.Definition TH2.cxx:4328; TH2D::operator*friend TH2D operator*(Float_t c1, TH2D const &h1)Operator *.Definition TH2.cxx:4316; TH2D::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH2.cxx:4257; TH2D::operator/friend TH2D operator/(TH2D const &h1, TH2D const &h2)Operator /.Definition TH2.cxx:4364; TH2D::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Double_t w) overrideIncrement 2D bin content by a weight w.Definition TH2.h:383; TH2D::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering b",MatchSource.WIKI,doc/master/TH2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8h_source.html
https://root.cern/doc/master/TH2_8h_source.html:28408,Deployability,update,update,28408,"ntvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH2.h:377; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH2F::TH2FTH2F()Constructor.Definition TH2.cxx:3848; TH2F::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH2.h:327; TH2F::AddBinContentvoid AddBinContent(Int_t bin, Double_t w) overrideIncrement bin content by a weight w.Definition TH2.h:331; TH2F::operator=TH2F & operator=(const TH2F &h1)Operator =.Definition TH2.cxx:4029; TH2F::~TH2F~TH2F() overrideDestructor.Definition TH2.cxx:3858; TH2F::operator+friend TH2F operator+(TH2F const &h1, TH2F const &h2)Operator +.Definition TH2.cxx:4064; TH2F::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny) overrideIncrement 2D bin content by 1.Definition TH2.h:333; TH2F::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH2.cxx:3963; TH2F::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH2.h:349; TH2F::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH2.h:348; TH2F::operator-friend TH2F operator-(TH2F const &h1, TH2F const &h2)Operator -.Definition TH2.cxx:4076; TH2F::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Double_t w) overrideIncrement 2D bin content by a weight w.Definition TH2.h:334; TH2F::operator*friend TH2F operator*(Float_t c1, TH2F const &h1)Operator *.Definition TH2.cxx:4040; TH2F::operator/friend TH2F operator/(TH2F const &h1, TH2F const &h2)Operator /.Definition TH2.cxx:4100; TH2F::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH2.cxx:3983; TH2I2-D histogram with an int per channel (see TH1 documentatio",MatchSource.WIKI,doc/master/TH2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8h_source.html
https://root.cern/doc/master/TH2_8h_source.html:30266,Deployability,update,update,30266,"cluding under/overflow Reallocate bin contents array.Definition TH2.cxx:3983; TH2I2-D histogram with an int per channel (see TH1 documentation)Definition TH2.h:225; TH2I::operator*friend TH2I operator*(TH2I const &h1, Float_t c1)Definition TH2.h:252; TH2I::TH2ITH2I()Constructor.Definition TH2.cxx:3390; TH2I::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH2.h:259; TH2I::operator*friend TH2I operator*(Float_t c1, TH2I const &h1)Operator *.Definition TH2.cxx:3551; TH2I::operator-friend TH2I operator-(TH2I const &h1, TH2I const &h2)Operator -.Definition TH2.cxx:3575; TH2I::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH2.cxx:3509; TH2I::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny) overrideIncrement 2D bin content by 1.Definition TH2.h:244; TH2I::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH2.h:260; TH2I::operator+friend TH2I operator+(TH2I const &h1, TH2I const &h2)Operator +.Definition TH2.cxx:3563; TH2I::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH2.cxx:3486; TH2I::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Double_t w) overrideIncrement 2D bin content by a weight w.Definition TH2.h:245; TH2I::~TH2I~TH2I() overrideDestructor.Definition TH2.cxx:3400; TH2I::operator=TH2I & operator=(const TH2I &h1)Operator =.Definition TH2.cxx:3540; TH2I::operator/friend TH2I operator/(TH2I const &h1, TH2I const &h2)Operator /.Definition TH2.cxx:3599; TH2I::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH2.cxx:3529; TH2L2-D histogram with a long64 per channel (see TH1 documentation)Definition TH2.h:267; TH2L::AddBinContentvoid",MatchSource.WIKI,doc/master/TH2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8h_source.html
https://root.cern/doc/master/TH2_8h_source.html:32585,Deployability,update,update,32585,"ator+(TH2L const &h1, TH2L const &h2)Operator +.Definition TH2.cxx:3792; TH2L::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Double_t w) overrideIncrement 2D bin content by a weight w.Definition TH2.h:286; TH2L::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH2.cxx:3758; TH2L::operator*friend TH2L operator*(TH2L const &h1, Float_t c1)Definition TH2.h:292; TH2L::~TH2L~TH2L() overrideDestructor.Definition TH2.cxx:3629; TH2L::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH2.cxx:3738; TH2L::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH2.h:299; TH2L::operator/friend TH2L operator/(TH2L const &h1, TH2L const &h2)Operator /.Definition TH2.cxx:3828; TH2L::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH2.h:300; TH2L::TH2LTH2L()Constructor.Definition TH2.cxx:3619; TH2L::operator*friend TH2L operator*(Float_t c1, TH2L const &h1)Operator *.Definition TH2.cxx:3780; TH2L::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH2.cxx:3715; TH2S2-D histogram with a short per channel (see TH1 documentation)Definition TH2.h:182; TH2S::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Double_t w) overrideIncrement 2D bin content by a weight w.Definition TH2.h:202; TH2S::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH2.cxx:3222; TH2S::~TH2S~TH2S() overrideDestructor.Definition TH2.cxx:3136; TH2S::operator-friend TH2S operator-(TH2S const &h1, TH2S const &h2)Operator -.Definition TH2.cxx:3346; TH2S::operator=TH2S & operator=(const TH2S &h1)Operator =.Definition TH2.cxx:3311; TH2S::Copyvoid Copy(TObject ",MatchSource.WIKI,doc/master/TH2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8h_source.html
https://root.cern/doc/master/TH2_8h_source.html:34187,Deployability,update,update,34187,"H2.h:202; TH2S::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH2.cxx:3222; TH2S::~TH2S~TH2S() overrideDestructor.Definition TH2.cxx:3136; TH2S::operator-friend TH2S operator-(TH2S const &h1, TH2S const &h2)Operator -.Definition TH2.cxx:3346; TH2S::operator=TH2S & operator=(const TH2S &h1)Operator =.Definition TH2.cxx:3311; TH2S::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH2.cxx:3245; TH2S::TH2STH2S()Constructor.Definition TH2.cxx:3126; TH2S::operator*friend TH2S operator*(TH2S const &h1, Float_t c1)Definition TH2.h:209; TH2S::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH2.h:216; TH2S::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny) overrideIncrement 2D bin content by 1.Definition TH2.h:201; TH2S::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH2.h:217; TH2S::operator*friend TH2S operator*(Float_t c1, TH2S const &h1)Operator *.Definition TH2.cxx:3322; TH2S::operator+friend TH2S operator+(TH2S const &h1, TH2S const &h2)Operator +.Definition TH2.cxx:3334; TH2S::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH2.cxx:3265; TH2S::operator/friend TH2S operator/(TH2S const &h1, TH2S const &h2)Operator /.Definition TH2.cxx:3370; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TH2::ProjectionYTH1D * ProjectionY(const char *name=""_py"", Int_t firstxbin=0, Int_t lastxbin=-1, Option_t *option="""") constProject a 2-D histogram into a 1-D histogram along Y.Definition TH2.cxx:2476; TH2::GetStatsvoid GetStats(Double_t *stats) const overrideFill the array stats from the contents of this histogram The array stats must be correc",MatchSource.WIKI,doc/master/TH2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8h_source.html
https://root.cern/doc/master/TH2_8h_source.html:37103,Modifiability,variab,variable,37103,"cesY(TF1 *f1=nullptr, Int_t firstxbin=0, Int_t lastxbin=-1, Int_t cut=0, Option_t *option=""QNR"", TObjArray *arr=nullptr)Project slices along Y in case of a 2-D histogram, then fit each slice with function f1 and make a hi...Definition TH2.cxx:1081; TH2::GetBinWithContent2virtual Double_t GetBinWithContent2(Double_t c, Int_t &binx, Int_t &biny, Int_t firstxbin=1, Int_t lastxbin=-1, Int_t firstybin=1, Int_t lastybin=-1, Double_t maxdiff=0) constcompute first cell (binx,biny) in the range [firstxbin,lastxbin][firstybin,lastybin] for which diff =...Definition TH2.cxx:1117; TH2::ProfileXTProfile * ProfileX(const char *name=""_pfx"", Int_t firstybin=1, Int_t lastybin=-1, Option_t *option="""") constProject a 2-D histogram into a profile histogram along X.Definition TH2.cxx:2109; TH2::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH2.cxx:238; TH2::TH2TH2(const TH2 &)=delete; TH2::RebinTH2 * Rebin(Int_t ngroup=2, const char *newname="""", const Double_t *xbins=nullptr) overrideOverride TH1::Rebin as TH2::RebinX Rebinning in variable binning as for TH1 is not allowed If a non-n...Definition TH2.cxx:1663; TH2::FillNvoid FillN(Int_t, const Double_t *, const Double_t *, Int_t) overrideFill this histogram with an array x and weights w.Definition TH2.h:84; TH2::BufferFillInt_t BufferFill(Double_t, Double_t) overrideaccumulate arguments in buffer.Definition TH2.h:56; TH2::QuantilesYTH1D * QuantilesY(Double_t prob=0.5, const char *name=""_qy"") constCompute the Y distribution of quantiles in the other variable X name is the name of the returned hist...Definition TH2.cxx:2518; TH2::ProfileYTProfile * ProfileY(const char *name=""_pfy"", Int_t firstxbin=1, Int_t lastxbin=-1, Option_t *option="""") constProject a 2-D histogram into a profile histogram along Y.Definition TH2.cxx:2159; TH2::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH2.cxx:380; TH2::DoQuantilesvirtual TH1D * DoQuantiles(bool onX, const char *name, Double_t prob) constImpleme",MatchSource.WIKI,doc/master/TH2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8h_source.html
https://root.cern/doc/master/TH2_8h_source.html:37580,Modifiability,variab,variable,37580,"in] for which diff =...Definition TH2.cxx:1117; TH2::ProfileXTProfile * ProfileX(const char *name=""_pfx"", Int_t firstybin=1, Int_t lastybin=-1, Option_t *option="""") constProject a 2-D histogram into a profile histogram along X.Definition TH2.cxx:2109; TH2::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH2.cxx:238; TH2::TH2TH2(const TH2 &)=delete; TH2::RebinTH2 * Rebin(Int_t ngroup=2, const char *newname="""", const Double_t *xbins=nullptr) overrideOverride TH1::Rebin as TH2::RebinX Rebinning in variable binning as for TH1 is not allowed If a non-n...Definition TH2.cxx:1663; TH2::FillNvoid FillN(Int_t, const Double_t *, const Double_t *, Int_t) overrideFill this histogram with an array x and weights w.Definition TH2.h:84; TH2::BufferFillInt_t BufferFill(Double_t, Double_t) overrideaccumulate arguments in buffer.Definition TH2.h:56; TH2::QuantilesYTH1D * QuantilesY(Double_t prob=0.5, const char *name=""_qy"") constCompute the Y distribution of quantiles in the other variable X name is the name of the returned hist...Definition TH2.cxx:2518; TH2::ProfileYTProfile * ProfileY(const char *name=""_pfy"", Int_t firstxbin=1, Int_t lastxbin=-1, Option_t *option="""") constProject a 2-D histogram into a profile histogram along Y.Definition TH2.cxx:2159; TH2::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH2.cxx:380; TH2::DoQuantilesvirtual TH1D * DoQuantiles(bool onX, const char *name, Double_t prob) constImplementation of quantiles for x or y.Definition TH2.cxx:2527; TH2::fTsumwxyDouble_t fTsumwxyTotal Sum of weight*X*Y.Definition TH2.h:36; TH2::SetBinContentvoid SetBinContent(Int_t bin, Double_t content) overrideSet bin content.Definition TH2.cxx:2616; TH2::FillInt_t Fill(const char *, Double_t) overrideIncrement bin with namex with a weight w.Definition TH2.h:58; TH2::BufferEmptyInt_t BufferEmpty(Int_t action=0) overrideFill histogram with all entries in the buffer.Definition TH2.cxx:278; TH2::Integralvirtual Double_t Integral",MatchSource.WIKI,doc/master/TH2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8h_source.html
https://root.cern/doc/master/TH2_8h_source.html:38940,Modifiability,variab,variable,38940,"n TH2.cxx:380; TH2::DoQuantilesvirtual TH1D * DoQuantiles(bool onX, const char *name, Double_t prob) constImplementation of quantiles for x or y.Definition TH2.cxx:2527; TH2::fTsumwxyDouble_t fTsumwxyTotal Sum of weight*X*Y.Definition TH2.h:36; TH2::SetBinContentvoid SetBinContent(Int_t bin, Double_t content) overrideSet bin content.Definition TH2.cxx:2616; TH2::FillInt_t Fill(const char *, Double_t) overrideIncrement bin with namex with a weight w.Definition TH2.h:58; TH2::BufferEmptyInt_t BufferEmpty(Int_t action=0) overrideFill histogram with all entries in the buffer.Definition TH2.cxx:278; TH2::Integralvirtual Double_t Integral(Int_t, Int_t, Int_t, Int_t, Int_t, Int_t, Option_t *="""") constDefinition TH2.h:106; TH2::DoFitSlicesvirtual void DoFitSlices(bool onX, TF1 *f1, Int_t firstbin, Int_t lastbin, Int_t cut, Option_t *option, TObjArray *arr)Definition TH2.cxx:814; TH2::QuantilesXTH1D * QuantilesX(Double_t prob=0.5, const char *name=""_qx"") constCompute the X distribution of quantiles in the other variable Y name is the name of the returned hist...Definition TH2.cxx:2505; TH2::SetShowProjectionYvirtual void SetShowProjectionY(Int_t nbins=1)When the mouse is moved in a pad containing a 2-d view of this histogram a second canvas shows the pr...Definition TH2.cxx:2650; TH2::SetBinContentvoid SetBinContent(Int_t binx, Int_t biny, Int_t, Double_t content) overrideDefinition TH2.h:125; TH2::FillRandomvoid FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr) overrideFill histogram following distribution in function fname.Definition TH2.cxx:714; TH2::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t binx, Int_t biny)Definition TH2.h:98; TH2::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH2.cxx:2600; TH2::fScalefactorDouble_t fScalefactorScale factor.Definition TH2.h:33; TH2::DoProjectionvirtual TH1D * DoProjection(bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) constIn",MatchSource.WIKI,doc/master/TH2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8h_source.html
https://root.cern/doc/master/TH2_8h_source.html:39952,Performance,perform,performing,39952,"tribution of quantiles in the other variable Y name is the name of the returned hist...Definition TH2.cxx:2505; TH2::SetShowProjectionYvirtual void SetShowProjectionY(Int_t nbins=1)When the mouse is moved in a pad containing a 2-d view of this histogram a second canvas shows the pr...Definition TH2.cxx:2650; TH2::SetBinContentvoid SetBinContent(Int_t binx, Int_t biny, Int_t, Double_t content) overrideDefinition TH2.h:125; TH2::FillRandomvoid FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr) overrideFill histogram following distribution in function fname.Definition TH2.cxx:714; TH2::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t binx, Int_t biny)Definition TH2.h:98; TH2::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH2.cxx:2600; TH2::fScalefactorDouble_t fScalefactorScale factor.Definition TH2.h:33; TH2::DoProjectionvirtual TH1D * DoProjection(bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) constInternal (protected) method for performing projection on the X or Y axis called by ProjectionX or Pro...Definition TH2.cxx:2169; TH2::RebinXTH2 * RebinX(Int_t ngroup=2, const char *newname="""") overrideRebin only the X axis see Rebin2D.Definition TH2.cxx:1642; TH2::fTsumwy2Double_t fTsumwy2Total Sum of weight*Y*Y.Definition TH2.h:35; TH2::GetRandom2virtual void GetRandom2(Double_t &x, Double_t &y, TRandom *rng=nullptr)Return 2 random numbers along axis x and y distributed according to the cell-contents of this 2-D his...Definition TH2.cxx:1200; TH2::SetBinContentvoid SetBinContent(Int_t binx, Int_t biny, Double_t content) overrideDefinition TH2.h:124; TH2::GetCovariancevirtual Double_t GetCovariance(Int_t axis1=1, Int_t axis2=2) constReturn covariance between axis1 and axis2.Definition TH2.cxx:1163; TH2::GetBinInt_t GetBin(Int_t binx, Int_t biny, Int_t binz=0) const overrideReturn Global bin number corresponding to binx,y,z.Definition TH2.cxx:1086; TH2::GetBinContentDoubl",MatchSource.WIKI,doc/master/TH2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8h_source.html
https://root.cern/doc/master/TH2_8h_source.html:35891,Testability,test,test,35891,"onY(const char *name=""_py"", Int_t firstxbin=0, Int_t lastxbin=-1, Option_t *option="""") constProject a 2-D histogram into a 1-D histogram along Y.Definition TH2.cxx:2476; TH2::GetStatsvoid GetStats(Double_t *stats) const overrideFill the array stats from the contents of this histogram The array stats must be correctly dimensione...Definition TH2.cxx:1254; TH2::ShowPeaksInt_t ShowPeaks(Double_t sigma=2, Option_t *option="""", Double_t threshold=0.05) overrideInterface to TSpectrum2::Search the function finds peaks in this histogram where the width is > sigma...Definition TH2.cxx:2695; TH2::GetCorrelationFactorvirtual Double_t GetCorrelationFactor(Int_t axis1=1, Int_t axis2=2) constReturn correlation factor between axis1 and axis2.Definition TH2.cxx:1145; TH2::DoProfilevirtual TProfile * DoProfile(bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) constDefinition TH2.cxx:1880; TH2::KolmogorovTestDouble_t KolmogorovTest(const TH1 *h2, Option_t *option="""") const overrideStatistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test.Definition TH2.cxx:1470; TH2::FitSlicesYvirtual void FitSlicesY(TF1 *f1=nullptr, Int_t firstxbin=0, Int_t lastxbin=-1, Int_t cut=0, Option_t *option=""QNR"", TObjArray *arr=nullptr)Project slices along Y in case of a 2-D histogram, then fit each slice with function f1 and make a hi...Definition TH2.cxx:1081; TH2::GetBinWithContent2virtual Double_t GetBinWithContent2(Double_t c, Int_t &binx, Int_t &biny, Int_t firstxbin=1, Int_t lastxbin=-1, Int_t firstybin=1, Int_t lastybin=-1, Double_t maxdiff=0) constcompute first cell (binx,biny) in the range [firstxbin,lastxbin][firstybin,lastybin] for which diff =...Definition TH2.cxx:1117; TH2::ProfileXTProfile * ProfileX(const char *name=""_pfx"", Int_t firstybin=1, Int_t lastybin=-1, Option_t *option="""") constProject a 2-D histogram into a profile histogram along X.Definition TH2.cxx:2109; TH2::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrem",MatchSource.WIKI,doc/master/TH2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8h_source.html
https://root.cern/doc/master/TH2_8h_source.html:35970,Testability,test,test,35970,"onY(const char *name=""_py"", Int_t firstxbin=0, Int_t lastxbin=-1, Option_t *option="""") constProject a 2-D histogram into a 1-D histogram along Y.Definition TH2.cxx:2476; TH2::GetStatsvoid GetStats(Double_t *stats) const overrideFill the array stats from the contents of this histogram The array stats must be correctly dimensione...Definition TH2.cxx:1254; TH2::ShowPeaksInt_t ShowPeaks(Double_t sigma=2, Option_t *option="""", Double_t threshold=0.05) overrideInterface to TSpectrum2::Search the function finds peaks in this histogram where the width is > sigma...Definition TH2.cxx:2695; TH2::GetCorrelationFactorvirtual Double_t GetCorrelationFactor(Int_t axis1=1, Int_t axis2=2) constReturn correlation factor between axis1 and axis2.Definition TH2.cxx:1145; TH2::DoProfilevirtual TProfile * DoProfile(bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) constDefinition TH2.cxx:1880; TH2::KolmogorovTestDouble_t KolmogorovTest(const TH1 *h2, Option_t *option="""") const overrideStatistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test.Definition TH2.cxx:1470; TH2::FitSlicesYvirtual void FitSlicesY(TF1 *f1=nullptr, Int_t firstxbin=0, Int_t lastxbin=-1, Int_t cut=0, Option_t *option=""QNR"", TObjArray *arr=nullptr)Project slices along Y in case of a 2-D histogram, then fit each slice with function f1 and make a hi...Definition TH2.cxx:1081; TH2::GetBinWithContent2virtual Double_t GetBinWithContent2(Double_t c, Int_t &binx, Int_t &biny, Int_t firstxbin=1, Int_t lastxbin=-1, Int_t firstybin=1, Int_t lastybin=-1, Double_t maxdiff=0) constcompute first cell (binx,biny) in the range [firstxbin,lastxbin][firstybin,lastybin] for which diff =...Definition TH2.cxx:1117; TH2::ProfileXTProfile * ProfileX(const char *name=""_pfx"", Int_t firstybin=1, Int_t lastybin=-1, Option_t *option="""") constProject a 2-D histogram into a profile histogram along X.Definition TH2.cxx:2109; TH2::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrem",MatchSource.WIKI,doc/master/TH2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8h_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:27037,Availability,mask,mask,27037,"66/// incremented by w; 667 ; 668Int_t TH3::Fill(const char * namex, Double_t y, Double_t z, Double_t w); 669{; 670 Int_t binx, biny, binz, bin;; 671 fEntries++;; 672 binx = fXaxis.FindBin(namex);; 673 biny = fYaxis.FindBin(y);; 674 binz = fZaxis.FindBin(z);; 675 if (binx < 0 || biny < 0 || binz < 0); 676 return -1;; 677 bin = binx + (fXaxis.GetNbins() + 2) * (biny + (fYaxis.GetNbins() + 2) * binz);; 678 if (!fSumw2.fN && w != 1.0 && !TestBit(TH1::kIsNotW)); 679 Sumw2(); // must be called before AddBinContent; 680 if (fSumw2.fN); 681 fSumw2.fArray[bin] += w * w;; 682 AddBinContent(bin, w);; 683 if (binx == 0 || binx > fXaxis.GetNbins()) {; 684 return -1;; 685 }; 686 if (biny == 0 || biny > fYaxis.GetNbins()) {; 687 if (!GetStatOverflowsBehaviour()); 688 return -1;; 689 }; 690 if (binz == 0 || binz > fZaxis.GetNbins()) {; 691 if (!GetStatOverflowsBehaviour()); 692 return -1;; 693 }; 694 Double_t v = w;; 695 fTsumw += v;; 696 fTsumw2 += v * v;; 697 fTsumwy += v * y;; 698 fTsumwy2 += v * y * y;; 699 fTsumwz += v * z;; 700 fTsumwz2 += v * z * z;; 701 fTsumwyz += v * y * z;; 702 // skip computation for x axis : for only one axis no need to use bit mask; 703 if (!fXaxis.CanExtend() || !fXaxis.IsAlphanumeric()) {; 704 Double_t x = fXaxis.GetBinCenter(binx);; 705 fTsumwx += v * x;; 706 fTsumwx2 += v * x * x;; 707 fTsumwxy += v * x * y;; 708 fTsumwxz += v * x * z;; 709 }; 710 return bin;; 711}; 712 ; 713////////////////////////////////////////////////////////////////////////////////; 714/// Increment cell defined by x,namey,z by a weight w; 715///; 716/// If the weight is not equal to 1, the storage of the sum of squares of; 717/// weights is automatically triggered and the sum of the squares of weights is incremented; 718/// by w^2 in the corresponding cell.; 719/// The function returns the corresponding global bin number which has its content; 720/// incremented by w; 721 ; 722Int_t TH3::Fill(Double_t x, const char *namey, Double_t z, Double_t w); 723{; 724 Int_t binx, biny",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:28834,Availability,mask,mask,28834," the corresponding global bin number which has its content; 720/// incremented by w; 721 ; 722Int_t TH3::Fill(Double_t x, const char *namey, Double_t z, Double_t w); 723{; 724 Int_t binx, biny, binz, bin;; 725 fEntries++;; 726 binx = fXaxis.FindBin(x);; 727 biny = fYaxis.FindBin(namey);; 728 binz = fZaxis.FindBin(z);; 729 if (binx <0 || biny <0 || binz<0) return -1;; 730 bin = binx + (fXaxis.GetNbins()+2)*(biny + (fYaxis.GetNbins()+2)*binz);; 731 if (!fSumw2.fN && w != 1.0 && !TestBit(TH1::kIsNotW)) Sumw2(); // must be called before AddBinContent; 732 if (fSumw2.fN) fSumw2.fArray[bin] += w*w;; 733 AddBinContent(bin,w);; 734 if (binx == 0 || binx > fXaxis.GetNbins()) {; 735 if (!GetStatOverflowsBehaviour()) return -1;; 736 }; 737 if (biny == 0 || biny > fYaxis.GetNbins()) return -1;; 738 if (binz == 0 || binz > fZaxis.GetNbins()) {; 739 if (!GetStatOverflowsBehaviour()) return -1;; 740 }; 741 Double_t v = w;; 742 fTsumw += v;; 743 fTsumw2 += v*v;; 744 fTsumwx += v*x;; 745 fTsumwx2 += v*x*x;; 746 fTsumwz += v*z;; 747 fTsumwz2 += v*z*z;; 748 fTsumwxz += v*x*z;; 749 // skip computation for y axis : for only one axis no need to use bit mask; 750 if (!fYaxis.CanExtend() || !fYaxis.IsAlphanumeric()) {; 751 Double_t y = fYaxis.GetBinCenter(biny);; 752 fTsumwy += v*y;; 753 fTsumwy2 += v*y*y;; 754 fTsumwxy += v*x*y;; 755 fTsumwyz += v*y*z;; 756 }; 757 ; 758 return bin;; 759}; 760 ; 761 ; 762////////////////////////////////////////////////////////////////////////////////; 763/// Increment cell defined by x,y,namez by a weight w; 764///; 765/// If the weight is not equal to 1, the storage of the sum of squares of; 766/// weights is automatically triggered and the sum of the squares of weights is incremented; 767/// by w^2 in the corresponding cell.; 768/// The function returns the corresponding global bin number which has its content; 769/// incremented by w; 770 ; 771Int_t TH3::Fill(Double_t x, Double_t y, const char *namez, Double_t w); 772{; 773 Int_t binx, biny, binz, bin;;",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:30641,Availability,mask,mask,30641,"number which has its content; 769/// incremented by w; 770 ; 771Int_t TH3::Fill(Double_t x, Double_t y, const char *namez, Double_t w); 772{; 773 Int_t binx, biny, binz, bin;; 774 fEntries++;; 775 binx = fXaxis.FindBin(x);; 776 biny = fYaxis.FindBin(y);; 777 binz = fZaxis.FindBin(namez);; 778 if (binx <0 || biny <0 || binz<0) return -1;; 779 bin = binx + (fXaxis.GetNbins()+2)*(biny + (fYaxis.GetNbins()+2)*binz);; 780 if (!fSumw2.fN && w != 1.0 && !TestBit(TH1::kIsNotW)) Sumw2(); // must be called before AddBinContent; 781 if (fSumw2.fN) fSumw2.fArray[bin] += w*w;; 782 AddBinContent(bin,w);; 783 if (binx == 0 || binx > fXaxis.GetNbins()) {; 784 if (!GetStatOverflowsBehaviour()) return -1;; 785 }; 786 if (biny == 0 || biny > fYaxis.GetNbins()) {; 787 if (!GetStatOverflowsBehaviour()) return -1;; 788 }; 789 if (binz == 0 || binz > fZaxis.GetNbins()) return -1;; 790 ; 791 Double_t v = w;; 792 fTsumw += v;; 793 fTsumw2 += v*v;; 794 fTsumwx += v*x;; 795 fTsumwx2 += v*x*x;; 796 fTsumwy += v*y;; 797 fTsumwy2 += v*y*y;; 798 fTsumwxy += v*x*y;; 799 ; 800 // skip computation for z axis : for only one axis no need to use bit mask; 801 if (!fZaxis.CanExtend() || !fZaxis.IsAlphanumeric()) {; 802 Double_t z = fZaxis.GetBinCenter(binz);; 803 fTsumwz += v*z;; 804 fTsumwz2 += v*z*z;; 805 fTsumwxz += v*x*z;; 806 fTsumwyz += v*y*z;; 807 }; 808 return bin;; 809}; 810 ; 811 ; 812////////////////////////////////////////////////////////////////////////////////; 813/// Fill histogram following distribution in function fname.; 814///; 815/// @param fname : Function name used for filling the historam; 816/// @param ntimes : number of times the histogram is filled; 817/// @param rng : (optional) Random number generator used to sample; 818///; 819/// The distribution contained in the function fname (TF1) is integrated; 820/// over the channel contents.; 821/// It is normalized to 1.; 822/// Getting one random number implies:; 823/// - Generating a random number between 0 and 1 (say r1); 824/// ",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:55684,Availability,error,error,55684,"on);; 1395}; 1396 ; 1397 ; 1398////////////////////////////////////////////////////////////////////////////////; 1399/// Return integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2]; 1400/// for a 3-D histogram; 1401/// By default the integral is computed as the sum of bin contents in the range.; 1402/// if option ""width"" is specified, the integral is the sum of; 1403/// the bin contents multiplied by the bin width in x, y and in z.; 1404 ; 1405Double_t TH3::Integral(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2,; 1406 Int_t binz1, Int_t binz2, Option_t *option) const; 1407{; 1408 Double_t err = 0;; 1409 return DoIntegral(binx1,binx2,biny1,biny2,binz1,binz2,err,option);; 1410}; 1411 ; 1412 ; 1413////////////////////////////////////////////////////////////////////////////////; 1414/// Return integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2]; 1415/// for a 3-D histogram. Calculates also the integral error using error propagation; 1416/// from the bin errors assuming that all the bins are uncorrelated.; 1417/// By default the integral is computed as the sum of bin contents in the range.; 1418/// if option ""width"" is specified, the integral is the sum of; 1419/// the bin contents multiplied by the bin width in x, y and in z.; 1420 ; 1421Double_t TH3::IntegralAndError(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2,; 1422 Int_t binz1, Int_t binz2,; 1423 Double_t & error, Option_t *option) const; 1424{; 1425 return DoIntegral(binx1,binx2,biny1,biny2,binz1,binz2,error,option,kTRUE);; 1426}; 1427 ; 1428////////////////////////////////////////////////////////////////////////////////; 1429///Not yet implemented; 1430 ; 1431Double_t TH3::Interpolate(Double_t) const; 1432{; 1433 Error(""Interpolate"",""This function must be called with 3 arguments for a TH3"");; 1434 return 0;; 1435}; 1436 ; 1437 ; 1438////////////////////////////////////////////////////////////////////////////////; 1439///Not yet implemented; 1440 ; 1441Double",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:55696,Availability,error,error,55696,"on);; 1395}; 1396 ; 1397 ; 1398////////////////////////////////////////////////////////////////////////////////; 1399/// Return integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2]; 1400/// for a 3-D histogram; 1401/// By default the integral is computed as the sum of bin contents in the range.; 1402/// if option ""width"" is specified, the integral is the sum of; 1403/// the bin contents multiplied by the bin width in x, y and in z.; 1404 ; 1405Double_t TH3::Integral(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2,; 1406 Int_t binz1, Int_t binz2, Option_t *option) const; 1407{; 1408 Double_t err = 0;; 1409 return DoIntegral(binx1,binx2,biny1,biny2,binz1,binz2,err,option);; 1410}; 1411 ; 1412 ; 1413////////////////////////////////////////////////////////////////////////////////; 1414/// Return integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2]; 1415/// for a 3-D histogram. Calculates also the integral error using error propagation; 1416/// from the bin errors assuming that all the bins are uncorrelated.; 1417/// By default the integral is computed as the sum of bin contents in the range.; 1418/// if option ""width"" is specified, the integral is the sum of; 1419/// the bin contents multiplied by the bin width in x, y and in z.; 1420 ; 1421Double_t TH3::IntegralAndError(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2,; 1422 Int_t binz1, Int_t binz2,; 1423 Double_t & error, Option_t *option) const; 1424{; 1425 return DoIntegral(binx1,binx2,biny1,biny2,binz1,binz2,error,option,kTRUE);; 1426}; 1427 ; 1428////////////////////////////////////////////////////////////////////////////////; 1429///Not yet implemented; 1430 ; 1431Double_t TH3::Interpolate(Double_t) const; 1432{; 1433 Error(""Interpolate"",""This function must be called with 3 arguments for a TH3"");; 1434 return 0;; 1435}; 1436 ; 1437 ; 1438////////////////////////////////////////////////////////////////////////////////; 1439///Not yet implemented; 1440 ; 1441Double",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:55736,Availability,error,errors,55736,"on);; 1395}; 1396 ; 1397 ; 1398////////////////////////////////////////////////////////////////////////////////; 1399/// Return integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2]; 1400/// for a 3-D histogram; 1401/// By default the integral is computed as the sum of bin contents in the range.; 1402/// if option ""width"" is specified, the integral is the sum of; 1403/// the bin contents multiplied by the bin width in x, y and in z.; 1404 ; 1405Double_t TH3::Integral(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2,; 1406 Int_t binz1, Int_t binz2, Option_t *option) const; 1407{; 1408 Double_t err = 0;; 1409 return DoIntegral(binx1,binx2,biny1,biny2,binz1,binz2,err,option);; 1410}; 1411 ; 1412 ; 1413////////////////////////////////////////////////////////////////////////////////; 1414/// Return integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2]; 1415/// for a 3-D histogram. Calculates also the integral error using error propagation; 1416/// from the bin errors assuming that all the bins are uncorrelated.; 1417/// By default the integral is computed as the sum of bin contents in the range.; 1418/// if option ""width"" is specified, the integral is the sum of; 1419/// the bin contents multiplied by the bin width in x, y and in z.; 1420 ; 1421Double_t TH3::IntegralAndError(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2,; 1422 Int_t binz1, Int_t binz2,; 1423 Double_t & error, Option_t *option) const; 1424{; 1425 return DoIntegral(binx1,binx2,biny1,biny2,binz1,binz2,error,option,kTRUE);; 1426}; 1427 ; 1428////////////////////////////////////////////////////////////////////////////////; 1429///Not yet implemented; 1430 ; 1431Double_t TH3::Interpolate(Double_t) const; 1432{; 1433 Error(""Interpolate"",""This function must be called with 3 arguments for a TH3"");; 1434 return 0;; 1435}; 1436 ; 1437 ; 1438////////////////////////////////////////////////////////////////////////////////; 1439///Not yet implemented; 1440 ; 1441Double",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:56158,Availability,error,error,56158,",binz2]; 1415/// for a 3-D histogram. Calculates also the integral error using error propagation; 1416/// from the bin errors assuming that all the bins are uncorrelated.; 1417/// By default the integral is computed as the sum of bin contents in the range.; 1418/// if option ""width"" is specified, the integral is the sum of; 1419/// the bin contents multiplied by the bin width in x, y and in z.; 1420 ; 1421Double_t TH3::IntegralAndError(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2,; 1422 Int_t binz1, Int_t binz2,; 1423 Double_t & error, Option_t *option) const; 1424{; 1425 return DoIntegral(binx1,binx2,biny1,biny2,binz1,binz2,error,option,kTRUE);; 1426}; 1427 ; 1428////////////////////////////////////////////////////////////////////////////////; 1429///Not yet implemented; 1430 ; 1431Double_t TH3::Interpolate(Double_t) const; 1432{; 1433 Error(""Interpolate"",""This function must be called with 3 arguments for a TH3"");; 1434 return 0;; 1435}; 1436 ; 1437 ; 1438////////////////////////////////////////////////////////////////////////////////; 1439///Not yet implemented; 1440 ; 1441Double_t TH3::Interpolate(Double_t, Double_t) const; 1442{; 1443 Error(""Interpolate"",""This function must be called with 3 arguments for a TH3"");; 1444 return 0;; 1445}; 1446 ; 1447 ; 1448////////////////////////////////////////////////////////////////////////////////; 1449/// Given a point P(x,y,z), Interpolate approximates the value via trilinear interpolation; 1450/// based on the 8 nearest bin center points (corner of the cube surrounding the points); 1451/// The Algorithm is described in http://en.wikipedia.org/wiki/Trilinear_interpolation; 1452/// The given values (x,y,z) must be between first bin center and last bin center for each coordinate:; 1453///; 1454/// fXAxis.GetBinCenter(1) < x < fXaxis.GetBinCenter(nbinX) AND; 1455/// fYAxis.GetBinCenter(1) < y < fYaxis.GetBinCenter(nbinY) AND; 1456/// fZAxis.GetBinCenter(1) < z < fZaxis.GetBinCenter(nbinZ); 1457 ; 1458Double_t TH3::Interpo",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:56256,Availability,error,error,56256,",binz2]; 1415/// for a 3-D histogram. Calculates also the integral error using error propagation; 1416/// from the bin errors assuming that all the bins are uncorrelated.; 1417/// By default the integral is computed as the sum of bin contents in the range.; 1418/// if option ""width"" is specified, the integral is the sum of; 1419/// the bin contents multiplied by the bin width in x, y and in z.; 1420 ; 1421Double_t TH3::IntegralAndError(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2,; 1422 Int_t binz1, Int_t binz2,; 1423 Double_t & error, Option_t *option) const; 1424{; 1425 return DoIntegral(binx1,binx2,biny1,biny2,binz1,binz2,error,option,kTRUE);; 1426}; 1427 ; 1428////////////////////////////////////////////////////////////////////////////////; 1429///Not yet implemented; 1430 ; 1431Double_t TH3::Interpolate(Double_t) const; 1432{; 1433 Error(""Interpolate"",""This function must be called with 3 arguments for a TH3"");; 1434 return 0;; 1435}; 1436 ; 1437 ; 1438////////////////////////////////////////////////////////////////////////////////; 1439///Not yet implemented; 1440 ; 1441Double_t TH3::Interpolate(Double_t, Double_t) const; 1442{; 1443 Error(""Interpolate"",""This function must be called with 3 arguments for a TH3"");; 1444 return 0;; 1445}; 1446 ; 1447 ; 1448////////////////////////////////////////////////////////////////////////////////; 1449/// Given a point P(x,y,z), Interpolate approximates the value via trilinear interpolation; 1450/// based on the 8 nearest bin center points (corner of the cube surrounding the points); 1451/// The Algorithm is described in http://en.wikipedia.org/wiki/Trilinear_interpolation; 1452/// The given values (x,y,z) must be between first bin center and last bin center for each coordinate:; 1453///; 1454/// fXAxis.GetBinCenter(1) < x < fXaxis.GetBinCenter(nbinX) AND; 1455/// fYAxis.GetBinCenter(1) < y < fYaxis.GetBinCenter(nbinY) AND; 1456/// fZAxis.GetBinCenter(1) < z < fZaxis.GetBinCenter(nbinZ); 1457 ; 1458Double_t TH3::Interpo",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:64147,Availability,error,errors,64147,"0; kbeg = 0;}; 1600 if (opt.Contains(""O"")) {iend = ncx1+1; jend = ncy1+1; kend = ncz1+1;}; 1601 ; 1602 Int_t i,j,k,bin;; 1603 Double_t sum1 = 0;; 1604 Double_t sum2 = 0;; 1605 Double_t w1 = 0;; 1606 Double_t w2 = 0;; 1607 for (i = ibeg; i <= iend; i++) {; 1608 for (j = jbeg; j <= jend; j++) {; 1609 for (k = kbeg; k <= kend; k++) {; 1610 bin = h1->GetBin(i,j,k);; 1611 sum1 += h1->GetBinContent(bin);; 1612 sum2 += h2->GetBinContent(bin);; 1613 Double_t ew1 = h1->GetBinError(bin);; 1614 Double_t ew2 = h2->GetBinError(bin);; 1615 w1 += ew1*ew1;; 1616 w2 += ew2*ew2;; 1617 }; 1618 }; 1619 }; 1620 ; 1621 ; 1622 // Check that both scatterplots contain events; 1623 if (sum1 == 0) {; 1624 Error(""KolmogorovTest"",""Integral is zero for h1=%s\n"",h1->GetName());; 1625 return 0;; 1626 }; 1627 if (sum2 == 0) {; 1628 Error(""KolmogorovTest"",""Integral is zero for h2=%s\n"",h2->GetName());; 1629 return 0;; 1630 }; 1631 // calculate the effective entries.; 1632 // the case when errors are zero (w1 == 0 or w2 ==0) are equivalent to; 1633 // compare to a function. In that case the rescaling is done only on sqrt(esum2) or sqrt(esum1); 1634 Double_t esum1 = 0, esum2 = 0;; 1635 if (w1 > 0); 1636 esum1 = sum1 * sum1 / w1;; 1637 else; 1638 afunc1 = kTRUE; // use later for calculating z; 1639 ; 1640 if (w2 > 0); 1641 esum2 = sum2 * sum2 / w2;; 1642 else; 1643 afunc2 = kTRUE; // use later for calculating z; 1644 ; 1645 if (afunc2 && afunc1) {; 1646 Error(""KolmogorovTest"",""Errors are zero for both histograms\n"");; 1647 return 0;; 1648 }; 1649 ; 1650 // Find Kolmogorov distance; 1651 // order is arbitrary take average of all possible 6 starting orders x,y,z; 1652 int order[3] = {0,1,2};; 1653 int binbeg[3];; 1654 int binend[3];; 1655 int ibin[3];; 1656 binbeg[0] = ibeg; binbeg[1] = jbeg; binbeg[2] = kbeg;; 1657 binend[0] = iend; binend[1] = jend; binend[2] = kend;; 1658 Double_t vdfmax[6]; // there are in total 6 combinations; 1659 int icomb = 0;; 1660 Double_t s1 = 1./(6.*sum1);; 1661 Double_t s2 = ",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:67191,Availability,error,error,67191,"*sum2/(sum1+sum2));; 1692 Double_t z = dfmax*factnm;; 1693 ; 1694 prb = TMath::KolmogorovProb(z);; 1695 ; 1696 Double_t prb1 = 0, prb2 = 0;; 1697 // option N to combine normalization makes sense if both afunc1 and afunc2 are false; 1698 if (opt.Contains(""N"") && !(afunc1 || afunc2 ) ) {; 1699 // Combine probabilities for shape and normalization; 1700 prb1 = prb;; 1701 Double_t d12 = esum1-esum2;; 1702 Double_t chi2 = d12*d12/(esum1+esum2);; 1703 prb2 = TMath::Prob(chi2,1);; 1704 // see Eadie et al., section 11.6.2; 1705 if (prb > 0 && prb2 > 0) prb = prb*prb2*(1-TMath::Log(prb*prb2));; 1706 else prb = 0;; 1707 }; 1708 ; 1709 // debug printout; 1710 if (opt.Contains(""D"")) {; 1711 printf("" Kolmo Prob h1 = %s, sum1=%g\n"",h1->GetName(),sum1);; 1712 printf("" Kolmo Prob h2 = %s, sum2=%g\n"",h2->GetName(),sum2);; 1713 printf("" Kolmo Probabil = %f, Max Dist = %g\n"",prb,dfmax);; 1714 if (opt.Contains(""N"")); 1715 printf("" Kolmo Probabil = %f for shape alone, =%f for normalisation alone\n"",prb1,prb2);; 1716 }; 1717 // This numerical error condition should never occur:; 1718 if (TMath::Abs(rsum1-1) > 0.002) Warning(""KolmogorovTest"",""Numerical problems with h1=%s\n"",h1->GetName());; 1719 if (TMath::Abs(rsum2-1) > 0.002) Warning(""KolmogorovTest"",""Numerical problems with h2=%s\n"",h2->GetName());; 1720 ; 1721 if (opt.Contains(""M"")) return dfmax; // return average of max distance; 1722 ; 1723 return prb;; 1724}; 1725 ; 1726 ; 1727////////////////////////////////////////////////////////////////////////////////; 1728/// Project a 3-D histogram into a 1-D histogram along X.; 1729///; 1730/// The projection is always of the type TH1D.; 1731/// The projection is made from the cells along the X axis; 1732/// ranging from iymin to iymax and izmin to izmax included.; 1733/// By default, underflow and overflows are included in both the Y and Z axis.; 1734/// By Setting iymin=1 and iymax=NbinsY the underflow and/or overflow in Y will be excluded; 1735/// By setting izmin=1 and izmax=NbinsZ the ",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:68253,Availability,error,errors,68253,"one\n"",prb1,prb2);; 1716 }; 1717 // This numerical error condition should never occur:; 1718 if (TMath::Abs(rsum1-1) > 0.002) Warning(""KolmogorovTest"",""Numerical problems with h1=%s\n"",h1->GetName());; 1719 if (TMath::Abs(rsum2-1) > 0.002) Warning(""KolmogorovTest"",""Numerical problems with h2=%s\n"",h2->GetName());; 1720 ; 1721 if (opt.Contains(""M"")) return dfmax; // return average of max distance; 1722 ; 1723 return prb;; 1724}; 1725 ; 1726 ; 1727////////////////////////////////////////////////////////////////////////////////; 1728/// Project a 3-D histogram into a 1-D histogram along X.; 1729///; 1730/// The projection is always of the type TH1D.; 1731/// The projection is made from the cells along the X axis; 1732/// ranging from iymin to iymax and izmin to izmax included.; 1733/// By default, underflow and overflows are included in both the Y and Z axis.; 1734/// By Setting iymin=1 and iymax=NbinsY the underflow and/or overflow in Y will be excluded; 1735/// By setting izmin=1 and izmax=NbinsZ the underflow and/or overflow in Z will be excluded; 1736///; 1737/// if option ""e"" is specified, the errors are computed.; 1738/// if option ""d"" is specified, the projection is drawn in the current pad.; 1739/// if option ""o"" original axis range of the target axes will be; 1740/// kept, but only bins inside the selected range will be filled.; 1741///; 1742/// NOTE that if a TH1D named ""name"" exists in the current directory or pad; 1743/// the histogram is reset and filled again with the projected contents of the TH3.; 1744///; 1745/// implemented using Project3D; 1746 ; 1747TH1D *TH3::ProjectionX(const char *name, Int_t iymin, Int_t iymax,; 1748 Int_t izmin, Int_t izmax, Option_t *option) const; 1749{; 1750 // in case of default name append the parent name; 1751 TString hname = name;; 1752 if (hname == ""_px"") hname = TString::Format(""%s%s"", GetName(), name);; 1753 TString title = TString::Format(""%s ( Projection X )"",GetTitle());; 1754 ; 1755 // when projecting in Z outer ax",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:70011,Availability,error,errors,70011,"pend the parent name; 1751 TString hname = name;; 1752 if (hname == ""_px"") hname = TString::Format(""%s%s"", GetName(), name);; 1753 TString title = TString::Format(""%s ( Projection X )"",GetTitle());; 1754 ; 1755 // when projecting in Z outer axis are Y and Z (order is important. It is defined in the DoProject1D function); 1756 return DoProject1D(hname, title, iymin, iymax, izmin, izmax, &fXaxis, &fYaxis, &fZaxis, option);; 1757}; 1758 ; 1759 ; 1760////////////////////////////////////////////////////////////////////////////////; 1761/// Project a 3-D histogram into a 1-D histogram along Y.; 1762///; 1763/// The projection is always of the type TH1D.; 1764/// The projection is made from the cells along the Y axis; 1765/// ranging from ixmin to ixmax and izmin to izmax included.; 1766/// By default, underflow and overflow are included in both the X and Z axis.; 1767/// By setting ixmin=1 and ixmax=NbinsX the underflow and/or overflow in X will be excluded; 1768/// By setting izmin=1 and izmax=NbinsZ the underflow and/or overflow in Z will be excluded; 1769///; 1770/// if option ""e"" is specified, the errors are computed.; 1771/// if option ""d"" is specified, the projection is drawn in the current pad.; 1772/// if option ""o"" original axis range of the target axes will be; 1773/// kept, but only bins inside the selected range will be filled.; 1774///; 1775/// NOTE that if a TH1D named ""name"" exists in the current directory or pad,; 1776/// the histogram is reset and filled again with the projected contents of the TH3.; 1777///; 1778/// implemented using Project3D; 1779 ; 1780TH1D *TH3::ProjectionY(const char *name, Int_t ixmin, Int_t ixmax,; 1781 Int_t izmin, Int_t izmax, Option_t *option) const; 1782{; 1783 TString hname = name;; 1784 if (hname == ""_py"") hname = TString::Format(""%s%s"", GetName(), name);; 1785 TString title = TString::Format(""%s ( Projection Y )"",GetTitle());; 1786 ; 1787 // when projecting in Z outer axis are X and Y (order is important. It is defined in th",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:71769,Availability,error,errors,71769," if (hname == ""_py"") hname = TString::Format(""%s%s"", GetName(), name);; 1785 TString title = TString::Format(""%s ( Projection Y )"",GetTitle());; 1786 ; 1787 // when projecting in Z outer axis are X and Y (order is important. It is defined in the DoProject1D function); 1788 return DoProject1D(hname, title, ixmin, ixmax, izmin, izmax, &fYaxis, &fXaxis, &fZaxis, option);; 1789}; 1790 ; 1791////////////////////////////////////////////////////////////////////////////////; 1792/// Project a 3-D histogram into a 1-D histogram along Z.; 1793///; 1794/// The projection is always of the type TH1D.; 1795/// The projection is made from the cells along the Z axis; 1796/// ranging from ixmin to ixmax and iymin to iymax included.; 1797/// By default, bins 1 to nx and 1 to ny are included; 1798/// By default, underflow and overflow are included in both the X and Y axis.; 1799/// By Setting ixmin=1 and ixmax=NbinsX the underflow and/or overflow in X will be excluded; 1800/// By setting iymin=1 and/or iymax=NbinsY the underflow and/or overflow in Y will be excluded; 1801///; 1802/// if option ""e"" is specified, the errors are computed.; 1803/// if option ""d"" is specified, the projection is drawn in the current pad.; 1804/// if option ""o"" original axis range of the target axes will be; 1805/// kept, but only bins inside the selected range will be filled.; 1806///; 1807/// NOTE that if a TH1D named ""name"" exists in the current directory or pad,; 1808/// the histogram is reset and filled again with the projected contents of the TH3.; 1809///; 1810/// implemented using Project3D; 1811 ; 1812TH1D *TH3::ProjectionZ(const char *name, Int_t ixmin, Int_t ixmax,; 1813 Int_t iymin, Int_t iymax, Option_t *option) const; 1814{; 1815 ; 1816 TString hname = name;; 1817 if (hname == ""_pz"") hname = TString::Format(""%s%s"", GetName(), name);; 1818 TString title = TString::Format(""%s ( Projection Z )"",GetTitle());; 1819 ; 1820 // when projecting in Z outer axis are X and Y (order is important. It is defi",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:77827,Availability,error,errors,77827,,MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:80624,Availability,error,errors,80624,"t is set artificially (see TAxis::SetRange); 2010 //if (out1min == 0 && out1max == 0) { out1min = 1; out1max = out1->GetNbins(); }; 2011 // correct for underflow/overflows; 2012 if (useUF && !out1->TestBit(TAxis::kAxisRange) ) out1min -= 1;; 2013 if (useOF && !out1->TestBit(TAxis::kAxisRange) ) out1max += 1;; 2014 Int_t out2min = out2->GetFirst();; 2015 Int_t out2max = out2->GetLast();; 2016// if (out2min == 0 && out2max == 0) { out2min = 1; out2max = out2->GetNbins(); }; 2017 if (useUF && !out2->TestBit(TAxis::kAxisRange) ) out2min -= 1;; 2018 if (useOF && !out2->TestBit(TAxis::kAxisRange) ) out2max += 1;; 2019 ; 2020 // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins; 2021 Bool_t extendable = projX->CanExtend();; 2022 if ( labels && extendable ) h1->GetXaxis()->SetCanExtend(kFALSE);; 2023 for (ixbin=0;ixbin<=1+projX->GetNbins();ixbin++) {; 2024 if ( projX->TestBit(TAxis::kAxisRange) && ( ixbin < ixmin || ixbin > ixmax )) continue;; 2025 ; 2026 Double_t cont = 0;; 2027 Double_t err2 = 0;; 2028 ; 2029 // loop on the bins to be integrated (outbin should be called inbin); 2030 for (out1bin = out1min; out1bin <= out1max; out1bin++) {; 2031 for (out2bin = out2min; out2bin <= out2max; out2bin++) {; 2032 ; 2033 Int_t bin = GetBin(*refX, *refY, *refZ);; 2034 ; 2035 // sum the bin contents and errors if needed; 2036 cont += RetrieveBinContent(bin);; 2037 if (computeErrors) {; 2038 Double_t exyz = GetBinError(bin);; 2039 err2 += exyz*exyz;; 2040 }; 2041 }; 2042 }; 2043 Int_t ix = h1->FindBin( projX->GetBinCenter(ixbin) );; 2044 h1->SetBinContent(ix ,cont);; 2045 if (computeErrors) h1->SetBinError(ix, TMath::Sqrt(err2) );; 2046 // sum all content; 2047 totcont += cont;; 2048 ; 2049 }; 2050 if ( labels ) h1->GetXaxis()->SetCanExtend(extendable);; 2051 ; 2052 // since we use a combination of fill and SetBinError we need to reset and recalculate the statistics; 2053 // for weighted histograms otherwise sumw2 will be wrong.",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:82246,Availability,error,error,82246,"= cont;; 2048 ; 2049 }; 2050 if ( labels ) h1->GetXaxis()->SetCanExtend(extendable);; 2051 ; 2052 // since we use a combination of fill and SetBinError we need to reset and recalculate the statistics; 2053 // for weighted histograms otherwise sumw2 will be wrong.; 2054 // We can keep the original statistics from the TH3 if the projected sumw is consistent with original one; 2055 // i.e. when no events are thrown away; 2056 bool resetStats = true;; 2057 double eps = 1.E-12;; 2058 if (IsA() == TH3F::Class() ) eps = 1.E-6;; 2059 if (fTsumw != 0 && TMath::Abs( fTsumw - totcont) < TMath::Abs(fTsumw) * eps) resetStats = false;; 2060 ; 2061 bool resetEntries = resetStats;; 2062 // entries are calculated using underflow/overflow. If excluded entries must be reset; 2063 resetEntries |= !useUF || !useOF;; 2064 ; 2065 ; 2066 if (!resetStats) {; 2067 Double_t stats[kNstat];; 2068 GetStats(stats);; 2069 if ( projX == GetYaxis() ) {; 2070 stats[2] = stats[4];; 2071 stats[3] = stats[5];; 2072 }; 2073 else if ( projX == GetZaxis() ) {; 2074 stats[2] = stats[7];; 2075 stats[3] = stats[8];; 2076 }; 2077 h1->PutStats(stats);; 2078 }; 2079 else {; 2080 // reset statistics; 2081 h1->ResetStats();; 2082 }; 2083 if (resetEntries) {; 2084 // in case of error calculation (i.e. when Sumw2() is set); 2085 // use the effective entries for the entries; 2086 // since this is the only way to estimate them; 2087 Double_t entries = TMath::Floor( totcont + 0.5); // to avoid numerical rounding; 2088 if (computeErrors) entries = h1->GetEffectiveEntries();; 2089 h1->SetEntries( entries );; 2090 }; 2091 else {; 2092 h1->SetEntries( fEntries );; 2093 }; 2094 ; 2095 return h1;; 2096}; 2097 ; 2098 ; 2099////////////////////////////////////////////////////////////////////////////////; 2100/// internal method performing the projection to a 2D histogram; 2101/// called from TH3::Project3D; 2102 ; 2103TH2D *TH3::DoProject2D(const char* name, const char * title, const TAxis* projX, const TAxis* projY,; 2104 bool",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:87320,Availability,error,errors,87320,",ny,&ybins->fArray[iymin-1],nx,&xbins->fArray[ixmin-1]);; 2180 }; 2181 }; 2182 }; 2183 ; 2184 // Copy the axis attributes and the axis labels if needed.; 2185 THashList* labels1 = nullptr;; 2186 THashList* labels2 = nullptr;; 2187 // ""xy""; 2188 h2->GetXaxis()->ImportAttributes(projY);; 2189 h2->GetYaxis()->ImportAttributes(projX);; 2190 labels1 = projY->GetLabels();; 2191 labels2 = projX->GetLabels();; 2192 if (labels1) {; 2193 TIter iL(labels1);; 2194 TObjString* lb;; 2195 Int_t i = 1;; 2196 while ((lb=(TObjString*)iL())) {; 2197 h2->GetXaxis()->SetBinLabel(i,lb->String().Data());; 2198 i++;; 2199 }; 2200 }; 2201 if (labels2) {; 2202 TIter iL(labels2);; 2203 TObjString* lb;; 2204 Int_t i = 1;; 2205 while ((lb=(TObjString*)iL())) {; 2206 h2->GetYaxis()->SetBinLabel(i,lb->String().Data());; 2207 i++;; 2208 }; 2209 }; 2210 h2->SetLineColor(this->GetLineColor());; 2211 h2->SetFillColor(this->GetFillColor());; 2212 h2->SetMarkerColor(this->GetMarkerColor());; 2213 h2->SetMarkerStyle(this->GetMarkerStyle());; 2214 ; 2215 // Activate errors; 2216 if ( computeErrors && (h2->GetSumw2N() != h2->GetNcells()) ) h2->Sumw2();; 2217 ; 2218 // Set references to the axis, so that the bucle has no branches.; 2219 const TAxis* out = nullptr;; 2220 if ( projX != GetXaxis() && projY != GetXaxis() ) {; 2221 out = GetXaxis();; 2222 } else if ( projX != GetYaxis() && projY != GetYaxis() ) {; 2223 out = GetYaxis();; 2224 } else {; 2225 out = GetZaxis();; 2226 }; 2227 ; 2228 Int_t *refX = nullptr, *refY = nullptr, *refZ = nullptr;; 2229 Int_t ixbin, iybin, outbin;; 2230 if ( projX == GetXaxis() && projY == GetYaxis() ) { refX = &ixbin; refY = &iybin; refZ = &outbin; }; 2231 if ( projX == GetYaxis() && projY == GetXaxis() ) { refX = &iybin; refY = &ixbin; refZ = &outbin; }; 2232 if ( projX == GetXaxis() && projY == GetZaxis() ) { refX = &ixbin; refY = &outbin; refZ = &iybin; }; 2233 if ( projX == GetZaxis() && projY == GetXaxis() ) { refX = &iybin; refY = &outbin; refZ = &ixbin; }; 2234 if (",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:89943,Availability,error,errors,89943,"; 2238 // Fill the projected histogram excluding underflow/overflows if considered in the option; 2239 // if specified in the option (by default they considered); 2240 Double_t totcont = 0;; 2241 ; 2242 Int_t outmin = out->GetFirst();; 2243 Int_t outmax = out->GetLast();; 2244 // GetFirst(), GetLast() can return (0,0) when the range bit is set artificially (see TAxis::SetRange); 2245 if (outmin == 0 && outmax == 0) { outmin = 1; outmax = out->GetNbins(); }; 2246 // correct for underflow/overflows; 2247 if (useUF && !out->TestBit(TAxis::kAxisRange) ) outmin -= 1;; 2248 if (useOF && !out->TestBit(TAxis::kAxisRange) ) outmax += 1;; 2249 ; 2250 for (ixbin=0;ixbin<=1+projX->GetNbins();ixbin++) {; 2251 if ( projX->TestBit(TAxis::kAxisRange) && ( ixbin < ixmin || ixbin > ixmax )) continue;; 2252 Int_t ix = h2->GetYaxis()->FindBin( projX->GetBinCenter(ixbin) );; 2253 ; 2254 for (iybin=0;iybin<=1+projY->GetNbins();iybin++) {; 2255 if ( projY->TestBit(TAxis::kAxisRange) && ( iybin < iymin || iybin > iymax )) continue;; 2256 Int_t iy = h2->GetXaxis()->FindBin( projY->GetBinCenter(iybin) );; 2257 ; 2258 Double_t cont = 0;; 2259 Double_t err2 = 0;; 2260 ; 2261 // loop on the bins to be integrated (outbin should be called inbin); 2262 for (outbin = outmin; outbin <= outmax; outbin++) {; 2263 ; 2264 Int_t bin = GetBin(*refX,*refY,*refZ);; 2265 ; 2266 // sum the bin contents and errors if needed; 2267 cont += RetrieveBinContent(bin);; 2268 if (computeErrors) {; 2269 Double_t exyz = GetBinError(bin);; 2270 err2 += exyz*exyz;; 2271 }; 2272 ; 2273 }; 2274 ; 2275 // remember axis are inverted; 2276 h2->SetBinContent(iy , ix, cont);; 2277 if (computeErrors) h2->SetBinError(iy, ix, TMath::Sqrt(err2) );; 2278 // sum all content; 2279 totcont += cont;; 2280 ; 2281 }; 2282 }; 2283 ; 2284 // since we use fill we need to reset and recalculate the statistics (see comment in DoProject1D ); 2285 // or keep original statistics if consistent sumw2; 2286 bool resetStats = true;; 2287 double eps = 1.",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:93942,Availability,error,errors,93942," x,y,z,e; 2362/// - option = ""x"" return the x projection into a TH1D histogram; 2363/// - option = ""y"" return the y projection into a TH1D histogram; 2364/// - option = ""z"" return the z projection into a TH1D histogram; 2365/// - option = ""xy"" return the x versus y projection into a TH2D histogram; 2366/// - option = ""yx"" return the y versus x projection into a TH2D histogram; 2367/// - option = ""xz"" return the x versus z projection into a TH2D histogram; 2368/// - option = ""zx"" return the z versus x projection into a TH2D histogram; 2369/// - option = ""yz"" return the y versus z projection into a TH2D histogram; 2370/// - option = ""zy"" return the z versus y projection into a TH2D histogram; 2371///; 2372/// NB: the notation ""a vs b"" means ""a"" vertical and ""b"" horizontal; 2373///; 2374/// option = ""o"" original axis range of the target axes will be; 2375/// kept, but only bins inside the selected range will be filled.; 2376///; 2377/// If option contains the string ""e"", errors are computed; 2378///; 2379/// The projection is made for the selected bins only.; 2380/// To select a bin range along an axis, use TAxis::SetRange, eg; 2381/// h3.GetYaxis()->SetRange(23,56);; 2382///; 2383/// NOTE 1: The generated histogram is named th3name + option; 2384/// eg if the TH3* h histogram is named ""myhist"", then; 2385/// h->Project3D(""xy""); produces a TH2D histogram named ""myhist_xy""; 2386/// if a histogram of the same type already exists, it is overwritten.; 2387/// The following sequence; 2388/// h->Project3D(""xy"");; 2389/// h->Project3D(""xy2"");; 2390/// will generate two TH2D histograms named ""myhist_xy"" and ""myhist_xy2""; 2391/// A different name can be generated by attaching a string to the option; 2392/// For example h->Project3D(""name_xy"") will generate an histogram with the name: h3dname_name_xy.; 2393///; 2394/// NOTE 2: If an histogram of the same type and with the same name already exists in current Directory,; 2395/// the histogram is reset and filled again with the pro",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:111168,Availability,error,error,111168," axes will be; 2780/// kept, but only bins inside the selected range will be filled.; 2781///; 2782/// The projection is made for the selected bins only.; 2783/// To select a bin range along an axis, use TAxis::SetRange, eg; 2784/// h3.GetYaxis()->SetRange(23,56);; 2785///; 2786/// NOTE 1: The generated histogram is named th3name + ""_p"" + option; 2787/// eg if the TH3* h histogram is named ""myhist"", then; 2788/// h->Project3D(""xy""); produces a TProfile2D histogram named ""myhist_pxy"".; 2789/// The following sequence; 2790/// h->Project3DProfile(""xy"");; 2791/// h->Project3DProfile(""xy2"");; 2792/// will generate two TProfile2D histograms named ""myhist_pxy"" and ""myhist_pxy2""; 2793/// So, passing additional characters in the option string one can customize the name.; 2794///; 2795/// NOTE 2: If a profile of the same type already exists with compatible axes,; 2796/// the profile is reset and filled again with the projected contents of the TH3.; 2797/// In the case of axes incompatibility, an error is reported and a NULL pointer is returned.; 2798///; 2799/// NOTE 3: The number of entries in the projected profile is estimated from the number of; 2800/// effective entries for all the cells included in the projection.; 2801///; 2802/// NOTE 4: underflow/overflow are by default excluded from the projection; 2803/// (Note that this is a different default behavior compared to the projection to an histogram); 2804/// To include the underflow and/or overflow use option ""UF"" and/or ""OF""; 2805 ; 2806TProfile2D *TH3::Project3DProfile(Option_t *option) const; 2807{; 2808 TString opt = option; opt.ToLower();; 2809 Int_t pcase = 0;; 2810 TString ptype;; 2811 if (opt.Contains(""xy"")) { pcase = 4; ptype = ""xy""; }; 2812 if (opt.Contains(""yx"")) { pcase = 5; ptype = ""yx""; }; 2813 if (opt.Contains(""xz"")) { pcase = 6; ptype = ""xz""; }; 2814 if (opt.Contains(""zx"")) { pcase = 7; ptype = ""zx""; }; 2815 if (opt.Contains(""yz"")) { pcase = 8; ptype = ""yz""; }; 2816 if (opt.Contains(""zy"")) { pcase = 9; pt",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:115901,Availability,error,errors,115901," 2912////////////////////////////////////////////////////////////////////////////////; 2913/// Rebin only the Y axis; 2914/// see Rebin3D; 2915 ; 2916TH3 *TH3::RebinY(Int_t ngroup, const char *newname); 2917{; 2918 return Rebin3D(1, ngroup, 1, newname);; 2919}; 2920 ; 2921 ; 2922////////////////////////////////////////////////////////////////////////////////; 2923/// Rebin only the Z axis; 2924/// see Rebin3D; 2925 ; 2926TH3 *TH3::RebinZ(Int_t ngroup, const char *newname); 2927{; 2928 return Rebin3D(1, 1, ngroup, newname);; 2929 ; 2930}; 2931 ; 2932 ; 2933////////////////////////////////////////////////////////////////////////////////; 2934/// Rebin this histogram grouping nxgroup/nygroup/nzgroup bins along the xaxis/yaxis/zaxis together.; 2935///; 2936/// if newname is not blank a new temporary histogram hnew is created.; 2937/// else the current histogram is modified (default); 2938/// The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this; 2939/// have to me merged into one bin of hnew; 2940/// If the original histogram has errors stored (via Sumw2), the resulting; 2941/// histograms has new errors correctly calculated.; 2942///; 2943/// examples: if hpxpy is an existing TH3 histogram with 40 x 40 x 40 bins; 2944/// hpxpypz->Rebin3D(); // merges two bins along the xaxis and yaxis in one in hpxpypz; 2945/// // Carefull: previous contents of hpxpy are lost; 2946/// hpxpypz->RebinX(5); //merges five bins along the xaxis in one in hpxpypz; 2947/// TH3 *hnew = hpxpypz->RebinY(5,""hnew""); // creates a new histogram hnew; 2948/// // merging 5 bins of h1 along the yaxis in one bin; 2949///; 2950/// NOTE : If nxgroup/nygroup is not an exact divider of the number of bins,; 2951/// along the xaxis/yaxis the top limit(s) of the rebinned histogram; 2952/// is changed to the upper edge of the xbin=newxbins*nxgroup resp.; 2953/// ybin=newybins*nygroup and the corresponding bins are added to; 2954/// the overflow bin.; 2955/// Statistics will be recompu",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:115970,Availability,error,errors,115970," 2912////////////////////////////////////////////////////////////////////////////////; 2913/// Rebin only the Y axis; 2914/// see Rebin3D; 2915 ; 2916TH3 *TH3::RebinY(Int_t ngroup, const char *newname); 2917{; 2918 return Rebin3D(1, ngroup, 1, newname);; 2919}; 2920 ; 2921 ; 2922////////////////////////////////////////////////////////////////////////////////; 2923/// Rebin only the Z axis; 2924/// see Rebin3D; 2925 ; 2926TH3 *TH3::RebinZ(Int_t ngroup, const char *newname); 2927{; 2928 return Rebin3D(1, 1, ngroup, newname);; 2929 ; 2930}; 2931 ; 2932 ; 2933////////////////////////////////////////////////////////////////////////////////; 2934/// Rebin this histogram grouping nxgroup/nygroup/nzgroup bins along the xaxis/yaxis/zaxis together.; 2935///; 2936/// if newname is not blank a new temporary histogram hnew is created.; 2937/// else the current histogram is modified (default); 2938/// The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this; 2939/// have to me merged into one bin of hnew; 2940/// If the original histogram has errors stored (via Sumw2), the resulting; 2941/// histograms has new errors correctly calculated.; 2942///; 2943/// examples: if hpxpy is an existing TH3 histogram with 40 x 40 x 40 bins; 2944/// hpxpypz->Rebin3D(); // merges two bins along the xaxis and yaxis in one in hpxpypz; 2945/// // Carefull: previous contents of hpxpy are lost; 2946/// hpxpypz->RebinX(5); //merges five bins along the xaxis in one in hpxpypz; 2947/// TH3 *hnew = hpxpypz->RebinY(5,""hnew""); // creates a new histogram hnew; 2948/// // merging 5 bins of h1 along the yaxis in one bin; 2949///; 2950/// NOTE : If nxgroup/nygroup is not an exact divider of the number of bins,; 2951/// along the xaxis/yaxis the top limit(s) of the rebinned histogram; 2952/// is changed to the upper edge of the xbin=newxbins*nxgroup resp.; 2953/// ybin=newybins*nygroup and the corresponding bins are added to; 2954/// the overflow bin.; 2955/// Statistics will be recompu",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:122039,Availability,error,errors,122039,"068 for (i = 0; i <= newxbins; ++i) xbins[i] = fXaxis.GetBinLowEdge(1+i*nxgroup);; 3069 Double_t *ybins = new Double_t[newybins+1];; 3070 for (i = 0; i <= newybins; ++i) ybins[i] = fYaxis.GetBinLowEdge(1+i*nygroup);; 3071 Double_t *zbins = new Double_t[newzbins+1];; 3072 for (i = 0; i <= newzbins; ++i) zbins[i] = fZaxis.GetBinLowEdge(1+i*nzgroup);; 3073 hnew->SetBins(newxbins,xbins, newybins, ybins, newzbins, zbins);//changes also errors array (if any); 3074 delete [] xbins;; 3075 delete [] ybins;; 3076 delete [] zbins;; 3077 } else {; 3078 hnew->SetBins(newxbins, xmin, xmax, newybins, ymin, ymax, newzbins, zmin, zmax);//changes also errors array; 3079 }; 3080 ; 3081 Double_t binContent, binSumw2;; 3082 Int_t oldxbin = 1;; 3083 Int_t oldybin = 1;; 3084 Int_t oldzbin = 1;; 3085 Int_t bin;; 3086 for (xbin = 1; xbin <= newxbins; xbin++) {; 3087 oldybin=1;; 3088 oldzbin=1;; 3089 for (ybin = 1; ybin <= newybins; ybin++) {; 3090 oldzbin=1;; 3091 for (zbin = 1; zbin <= newzbins; zbin++) {; 3092 binContent = 0;; 3093 binSumw2 = 0;; 3094 for (i = 0; i < nxgroup; i++) {; 3095 if (oldxbin+i > nxbins) break;; 3096 for (j =0; j < nygroup; j++) {; 3097 if (oldybin+j > nybins) break;; 3098 for (k =0; k < nzgroup; k++) {; 3099 if (oldzbin+k > nzbins) break;; 3100 //get global bin (same conventions as in TH1::GetBin(xbin,ybin); 3101 bin = oldxbin + i + (oldybin + j)*(nxbins + 2) + (oldzbin + k)*(nxbins + 2)*(nybins + 2);; 3102 binContent += oldBins[bin];; 3103 if (oldSumw2) binSumw2 += oldSumw2[bin];; 3104 }; 3105 }; 3106 }; 3107 Int_t ibin = hnew->GetBin(xbin,ybin,zbin); // new bin number; 3108 hnew->SetBinContent(ibin, binContent);; 3109 if (oldSumw2) hnew->fSumw2.fArray[ibin] = binSumw2;; 3110 oldzbin += nzgroup;; 3111 }; 3112 oldybin += nygroup;; 3113 }; 3114 oldxbin += nxgroup;; 3115 }; 3116 ; 3117 // compute new underflow/overflows for the 8 vertices; 3118 for (Int_t xover = 0; xover <= 1; xover++) {; 3119 for (Int_t yover = 0; yover <= 1; yover++) {; 3120 for (Int_t zover = 0",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:122246,Availability,error,errors,122246,"068 for (i = 0; i <= newxbins; ++i) xbins[i] = fXaxis.GetBinLowEdge(1+i*nxgroup);; 3069 Double_t *ybins = new Double_t[newybins+1];; 3070 for (i = 0; i <= newybins; ++i) ybins[i] = fYaxis.GetBinLowEdge(1+i*nygroup);; 3071 Double_t *zbins = new Double_t[newzbins+1];; 3072 for (i = 0; i <= newzbins; ++i) zbins[i] = fZaxis.GetBinLowEdge(1+i*nzgroup);; 3073 hnew->SetBins(newxbins,xbins, newybins, ybins, newzbins, zbins);//changes also errors array (if any); 3074 delete [] xbins;; 3075 delete [] ybins;; 3076 delete [] zbins;; 3077 } else {; 3078 hnew->SetBins(newxbins, xmin, xmax, newybins, ymin, ymax, newzbins, zmin, zmax);//changes also errors array; 3079 }; 3080 ; 3081 Double_t binContent, binSumw2;; 3082 Int_t oldxbin = 1;; 3083 Int_t oldybin = 1;; 3084 Int_t oldzbin = 1;; 3085 Int_t bin;; 3086 for (xbin = 1; xbin <= newxbins; xbin++) {; 3087 oldybin=1;; 3088 oldzbin=1;; 3089 for (ybin = 1; ybin <= newybins; ybin++) {; 3090 oldzbin=1;; 3091 for (zbin = 1; zbin <= newzbins; zbin++) {; 3092 binContent = 0;; 3093 binSumw2 = 0;; 3094 for (i = 0; i < nxgroup; i++) {; 3095 if (oldxbin+i > nxbins) break;; 3096 for (j =0; j < nygroup; j++) {; 3097 if (oldybin+j > nybins) break;; 3098 for (k =0; k < nzgroup; k++) {; 3099 if (oldzbin+k > nzbins) break;; 3100 //get global bin (same conventions as in TH1::GetBin(xbin,ybin); 3101 bin = oldxbin + i + (oldybin + j)*(nxbins + 2) + (oldzbin + k)*(nxbins + 2)*(nybins + 2);; 3102 binContent += oldBins[bin];; 3103 if (oldSumw2) binSumw2 += oldSumw2[bin];; 3104 }; 3105 }; 3106 }; 3107 Int_t ibin = hnew->GetBin(xbin,ybin,zbin); // new bin number; 3108 hnew->SetBinContent(ibin, binContent);; 3109 if (oldSumw2) hnew->fSumw2.fArray[ibin] = binSumw2;; 3110 oldzbin += nzgroup;; 3111 }; 3112 oldybin += nygroup;; 3113 }; 3114 oldxbin += nxgroup;; 3115 }; 3116 ; 3117 // compute new underflow/overflows for the 8 vertices; 3118 for (Int_t xover = 0; xover <= 1; xover++) {; 3119 for (Int_t yover = 0; yover <= 1; yover++) {; 3120 for (Int_t zover = 0",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:135455,Availability,error,errors,135455,"lColor);; 3415 fYaxis.SetLabelFont(yLabelFont);; 3416 fYaxis.SetLabelOffset(yLabelOffset);; 3417 fYaxis.SetLabelSize(yLabelSize);; 3418 fYaxis.SetTickLength(yTickLength);; 3419 fYaxis.SetTitleOffset(yTitleOffset);; 3420 fYaxis.SetTitleSize(yTitleSize);; 3421 fYaxis.SetTitleColor(yTitleColor);; 3422 fYaxis.SetTitleFont(yTitleFont);; 3423 // Restore z axis attributes; 3424 fZaxis.SetNdivisions(nZdivisions);; 3425 fZaxis.SetAxisColor(zAxisColor);; 3426 fZaxis.SetLabelColor(zLabelColor);; 3427 fZaxis.SetLabelFont(zLabelFont);; 3428 fZaxis.SetLabelOffset(zLabelOffset);; 3429 fZaxis.SetLabelSize(zLabelSize);; 3430 fZaxis.SetTickLength(zTickLength);; 3431 fZaxis.SetTitleOffset(zTitleOffset);; 3432 fZaxis.SetTitleSize(zTitleSize);; 3433 fZaxis.SetTitleColor(zTitleColor);; 3434 fZaxis.SetTitleFont(zTitleFont);; 3435 ; 3436 //restore statistics and entries modified by SetBinContent; 3437 hnew->SetEntries(entries);; 3438 if (!resetStat) hnew->PutStats(stat);; 3439 ; 3440 delete [] oldBins;; 3441 if (oldSumw2) delete [] oldSumw2;; 3442 return hnew;; 3443}; 3444 ; 3445 ; 3446////////////////////////////////////////////////////////////////////////////////; 3447/// Reset this histogram: contents, errors, etc.; 3448 ; 3449void TH3::Reset(Option_t *option); 3450{; 3451 TH1::Reset(option);; 3452 TString opt = option;; 3453 opt.ToUpper();; 3454 if (opt.Contains(""ICE"") && !opt.Contains(""S"")) return;; 3455 fTsumwy = 0;; 3456 fTsumwy2 = 0;; 3457 fTsumwxy = 0;; 3458 fTsumwz = 0;; 3459 fTsumwz2 = 0;; 3460 fTsumwxz = 0;; 3461 fTsumwyz = 0;; 3462}; 3463 ; 3464 ; 3465////////////////////////////////////////////////////////////////////////////////; 3466/// Set bin content.; 3467 ; 3468void TH3::SetBinContent(Int_t bin, Double_t content); 3469{; 3470 fEntries++;; 3471 fTsumw = 0;; 3472 if (bin < 0) return;; 3473 if (bin >= fNcells) return;; 3474 UpdateBinContent(bin, content);; 3475}; 3476 ; 3477 ; 3478////////////////////////////////////////////////////////////////////////////////; 3479/// Str",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:141690,Availability,error,errors,141690," Passing an out-of-range bin leads to undefined behavior; 3602 ; 3603void TH3C::AddBinContent(Int_t bin); 3604{; 3605 if (fArray[bin] < 127) fArray[bin]++;; 3606}; 3607 ; 3608 ; 3609////////////////////////////////////////////////////////////////////////////////; 3610/// Increment bin content by w.; 3611/// \warning The value of w is cast to `Int_t` before being added.; 3612/// Passing an out-of-range bin leads to undefined behavior; 3613 ; 3614void TH3C::AddBinContent(Int_t bin, Double_t w); 3615{; 3616 Int_t newval = fArray[bin] + Int_t(w);; 3617 if (newval > -128 && newval < 128) {fArray[bin] = Char_t(newval); return;}; 3618 if (newval < -127) fArray[bin] = -127;; 3619 if (newval > 127) fArray[bin] = 127;; 3620}; 3621 ; 3622 ; 3623////////////////////////////////////////////////////////////////////////////////; 3624/// Copy this 3-D histogram structure to newth3.; 3625 ; 3626void TH3C::Copy(TObject &newth3) const; 3627{; 3628 TH3::Copy(newth3);; 3629}; 3630 ; 3631 ; 3632////////////////////////////////////////////////////////////////////////////////; 3633/// Reset this histogram: contents, errors, etc.; 3634 ; 3635void TH3C::Reset(Option_t *option); 3636{; 3637 TH3::Reset(option);; 3638 TArrayC::Reset();; 3639 // should also reset statistics once statistics are implemented for TH3; 3640}; 3641 ; 3642 ; 3643////////////////////////////////////////////////////////////////////////////////; 3644/// Set total number of bins including under/overflow; 3645/// Reallocate bin contents array; 3646 ; 3647void TH3C::SetBinsLength(Int_t n); 3648{; 3649 if (n < 0) n = (fXaxis.GetNbins()+2)*(fYaxis.GetNbins()+2)*(fZaxis.GetNbins()+2);; 3650 fNcells = n;; 3651 TArrayC::Set(n);; 3652}; 3653 ; 3654 ; 3655////////////////////////////////////////////////////////////////////////////////; 3656/// When the mouse is moved in a pad containing a 3-d view of this histogram; 3657/// a second canvas shows a projection type given as option.; 3658/// To stop the generation of the projections, ",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:150508,Availability,error,errors,150508,"-of-range bin leads to undefined behavior; 3871 ; 3872void TH3S::AddBinContent(Int_t bin); 3873{; 3874 if (fArray[bin] < 32767) fArray[bin]++;; 3875}; 3876 ; 3877 ; 3878////////////////////////////////////////////////////////////////////////////////; 3879/// Increment bin content by w.; 3880/// \warning The value of w is cast to `Int_t` before being added.; 3881/// Passing an out-of-range bin leads to undefined behavior; 3882 ; 3883void TH3S::AddBinContent(Int_t bin, Double_t w); 3884{; 3885 Int_t newval = fArray[bin] + Int_t(w);; 3886 if (newval > -32768 && newval < 32768) {fArray[bin] = Short_t(newval); return;}; 3887 if (newval < -32767) fArray[bin] = -32767;; 3888 if (newval > 32767) fArray[bin] = 32767;; 3889}; 3890 ; 3891 ; 3892////////////////////////////////////////////////////////////////////////////////; 3893/// Copy this 3-D histogram structure to newth3.; 3894 ; 3895void TH3S::Copy(TObject &newth3) const; 3896{; 3897 TH3::Copy(newth3);; 3898}; 3899 ; 3900 ; 3901////////////////////////////////////////////////////////////////////////////////; 3902/// Reset this histogram: contents, errors, etc.; 3903 ; 3904void TH3S::Reset(Option_t *option); 3905{; 3906 TH3::Reset(option);; 3907 TArrayS::Reset();; 3908 // should also reset statistics once statistics are implemented for TH3; 3909}; 3910 ; 3911 ; 3912////////////////////////////////////////////////////////////////////////////////; 3913/// Set total number of bins including under/overflow; 3914/// Reallocate bin contents array; 3915 ; 3916void TH3S::SetBinsLength(Int_t n); 3917{; 3918 if (n < 0) n = (fXaxis.GetNbins()+2)*(fYaxis.GetNbins()+2)*(fZaxis.GetNbins()+2);; 3919 fNcells = n;; 3920 TArrayS::Set(n);; 3921}; 3922 ; 3923 ; 3924////////////////////////////////////////////////////////////////////////////////; 3925/// Stream an object of class TH3S.; 3926 ; 3927void TH3S::Streamer(TBuffer &R__b); 3928{; 3929 if (R__b.IsReading()) {; 3930 UInt_t R__s, R__c;; 3931 if (R__b.GetParent() && R__b.GetVersionOwner",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:157757,Availability,error,errors,157757,"o undefined behavior; 4111 ; 4112void TH3I::AddBinContent(Int_t bin); 4113{; 4114 if (fArray[bin] < INT_MAX) fArray[bin]++;; 4115}; 4116 ; 4117 ; 4118////////////////////////////////////////////////////////////////////////////////; 4119/// Increment bin content by w.; 4120/// \warning The value of w is cast to `Long64_t` before being added.; 4121/// Passing an out-of-range bin leads to undefined behavior; 4122 ; 4123void TH3I::AddBinContent(Int_t bin, Double_t w); 4124{; 4125 Long64_t newval = fArray[bin] + Long64_t(w);; 4126 if (newval > -INT_MAX && newval < INT_MAX) {fArray[bin] = Int_t(newval); return;}; 4127 if (newval < -INT_MAX) fArray[bin] = -INT_MAX;; 4128 if (newval > INT_MAX) fArray[bin] = INT_MAX;; 4129}; 4130 ; 4131 ; 4132////////////////////////////////////////////////////////////////////////////////; 4133/// Copy this 3-D histogram structure to newth3.; 4134 ; 4135void TH3I::Copy(TObject &newth3) const; 4136{; 4137 TH3::Copy(newth3);; 4138}; 4139 ; 4140 ; 4141////////////////////////////////////////////////////////////////////////////////; 4142/// Reset this histogram: contents, errors, etc.; 4143 ; 4144void TH3I::Reset(Option_t *option); 4145{; 4146 TH3::Reset(option);; 4147 TArrayI::Reset();; 4148 // should also reset statistics once statistics are implemented for TH3; 4149}; 4150 ; 4151 ; 4152////////////////////////////////////////////////////////////////////////////////; 4153/// Set total number of bins including under/overflow; 4154/// Reallocate bin contents array; 4155 ; 4156void TH3I::SetBinsLength(Int_t n); 4157{; 4158 if (n < 0) n = (fXaxis.GetNbins()+2)*(fYaxis.GetNbins()+2)*(fZaxis.GetNbins()+2);; 4159 fNcells = n;; 4160 TArrayI::Set(n);; 4161}; 4162 ; 4163 ; 4164////////////////////////////////////////////////////////////////////////////////; 4165/// Operator =; 4166 ; 4167TH3I& TH3I::operator=(const TH3I &h3i); 4168{; 4169 if (this != &h3i); 4170 h3i.TH3I::Copy(*this);; 4171 return *this;; 4172}; 4173 ; 4174 ; 4175///////////////////////",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:164049,Availability,error,errors,164049,"havior; 4318 ; 4319void TH3L::AddBinContent(Int_t bin); 4320{; 4321 if (fArray[bin] < LLONG_MAX) fArray[bin]++;; 4322}; 4323 ; 4324 ; 4325////////////////////////////////////////////////////////////////////////////////; 4326/// Increment bin content by w.; 4327/// \warning The value of w is cast to `Long64_t` before being added.; 4328/// Passing an out-of-range bin leads to undefined behavior; 4329 ; 4330void TH3L::AddBinContent(Int_t bin, Double_t w); 4331{; 4332 Long64_t newval = fArray[bin] + Long64_t(w);; 4333 if (newval > -LLONG_MAX && newval < LLONG_MAX) {fArray[bin] = Int_t(newval); return;}; 4334 if (newval < -LLONG_MAX) fArray[bin] = -LLONG_MAX;; 4335 if (newval > LLONG_MAX) fArray[bin] = LLONG_MAX;; 4336}; 4337 ; 4338 ; 4339////////////////////////////////////////////////////////////////////////////////; 4340/// Copy this 3-D histogram structure to newth3.; 4341 ; 4342void TH3L::Copy(TObject &newth3) const; 4343{; 4344 TH3::Copy(newth3);; 4345}; 4346 ; 4347 ; 4348////////////////////////////////////////////////////////////////////////////////; 4349/// Reset this histogram: contents, errors, etc.; 4350 ; 4351void TH3L::Reset(Option_t *option); 4352{; 4353 TH3::Reset(option);; 4354 TArrayL64::Reset();; 4355 // should also reset statistics once statistics are implemented for TH3; 4356}; 4357 ; 4358 ; 4359////////////////////////////////////////////////////////////////////////////////; 4360/// Set total number of bins including under/overflow; 4361/// Reallocate bin contents array; 4362 ; 4363void TH3L::SetBinsLength(Int_t n); 4364{; 4365 if (n < 0) n = (fXaxis.GetNbins()+2)*(fYaxis.GetNbins()+2)*(fZaxis.GetNbins()+2);; 4366 fNcells = n;; 4367 TArrayL64::Set(n);; 4368}; 4369 ; 4370 ; 4371////////////////////////////////////////////////////////////////////////////////; 4372/// Operator =; 4373 ; 4374TH3L& TH3L::operator=(const TH3L &h3l); 4375{; 4376 if (this != &h3l); 4377 h3l.TH3L::Copy(*this);; 4378 return *this;; 4379}; 4380 ; 4381 ; 4382///////////////////",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:169483,Availability,error,errors,169483,"9/// Constructor for variable bin size 3-D histograms; 4500/// (see TH3::TH3 for explanation of parameters); 4501 ; 4502TH3F::TH3F(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 4503 ,Int_t nbinsy,const Double_t *ybins; 4504 ,Int_t nbinsz,const Double_t *zbins); 4505 :TH3(name,title,nbinsx,xbins,nbinsy,ybins,nbinsz,zbins); 4506{; 4507 TArrayF::Set(fNcells);; 4508 if (fgDefaultSumw2) Sumw2();; 4509}; 4510 ; 4511 ; 4512////////////////////////////////////////////////////////////////////////////////; 4513/// Copy constructor.; 4514/// The list of functions is not copied. (Use Clone() if needed); 4515 ; 4516TH3F::TH3F(const TH3F &h3f) : TH3(), TArrayF(); 4517{; 4518 h3f.TH3F::Copy(*this);; 4519}; 4520 ; 4521 ; 4522////////////////////////////////////////////////////////////////////////////////; 4523/// Copy this 3-D histogram structure to newth3.; 4524 ; 4525void TH3F::Copy(TObject &newth3) const; 4526{; 4527 TH3::Copy(newth3);; 4528}; 4529 ; 4530 ; 4531////////////////////////////////////////////////////////////////////////////////; 4532/// Reset this histogram: contents, errors, etc.; 4533 ; 4534void TH3F::Reset(Option_t *option); 4535{; 4536 TH3::Reset(option);; 4537 TArrayF::Reset();; 4538 // should also reset statistics once statistics are implemented for TH3; 4539}; 4540 ; 4541 ; 4542////////////////////////////////////////////////////////////////////////////////; 4543/// Set total number of bins including under/overflow; 4544/// Reallocate bin contents array; 4545 ; 4546void TH3F::SetBinsLength(Int_t n); 4547{; 4548 if (n < 0) n = (fXaxis.GetNbins()+2)*(fYaxis.GetNbins()+2)*(fZaxis.GetNbins()+2);; 4549 fNcells = n;; 4550 TArrayF::Set(n);; 4551}; 4552 ; 4553 ; 4554////////////////////////////////////////////////////////////////////////////////; 4555/// Stream an object of class TH3F.; 4556 ; 4557void TH3F::Streamer(TBuffer &R__b); 4558{; 4559 if (R__b.IsReading()) {; 4560 UInt_t R__s, R__c;; 4561 if (R__b.GetParent() && R__b.GetVersionOwner",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:175974,Availability,error,errors,175974,":TH3 for explanation of parameters); 4717 ; 4718TH3D::TH3D(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 4719 ,Int_t nbinsy,const Double_t *ybins; 4720 ,Int_t nbinsz,const Double_t *zbins); 4721 :TH3(name,title,nbinsx,xbins,nbinsy,ybins,nbinsz,zbins); 4722{; 4723 TArrayD::Set(fNcells);; 4724 if (fgDefaultSumw2) Sumw2();; 4725}; 4726 ; 4727 ; 4728////////////////////////////////////////////////////////////////////////////////; 4729/// Copy constructor.; 4730/// The list of functions is not copied. (Use Clone() if needed); 4731 ; 4732TH3D::TH3D(const TH3D &h3d) : TH3(), TArrayD(); 4733{; 4734 // intentially call virtual Copy method to warn if TProfile3D is copied; 4735 h3d.Copy(*this);; 4736}; 4737 ; 4738 ; 4739////////////////////////////////////////////////////////////////////////////////; 4740/// Copy this 3-D histogram structure to newth3.; 4741 ; 4742void TH3D::Copy(TObject &newth3) const; 4743{; 4744 TH3::Copy(newth3);; 4745}; 4746 ; 4747 ; 4748////////////////////////////////////////////////////////////////////////////////; 4749/// Reset this histogram: contents, errors, etc.; 4750 ; 4751void TH3D::Reset(Option_t *option); 4752{; 4753 TH3::Reset(option);; 4754 TArrayD::Reset();; 4755 // should also reset statistics once statistics are implemented for TH3; 4756}; 4757 ; 4758 ; 4759////////////////////////////////////////////////////////////////////////////////; 4760/// Set total number of bins including under/overflow; 4761/// Reallocate bin contents array; 4762 ; 4763void TH3D::SetBinsLength(Int_t n); 4764{; 4765 if (n < 0) n = (fXaxis.GetNbins()+2)*(fYaxis.GetNbins()+2)*(fZaxis.GetNbins()+2);; 4766 fNcells = n;; 4767 TArrayD::Set(n);; 4768}; 4769 ; 4770 ; 4771////////////////////////////////////////////////////////////////////////////////; 4772/// Stream an object of class TH3D.; 4773 ; 4774void TH3D::Streamer(TBuffer &R__b); 4775{; 4776 if (R__b.IsReading()) {; 4777 UInt_t R__s, R__c;; 4778 if (R__b.GetParent() && R__b.GetVersionOwner",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:180201,Availability,error,error,180201,"perator/(TH3D const &h1, TH3D const &h2); 4868{; 4869 TH3D hnew = h1;; 4870 hnew.Divide(&h2);; 4871 hnew.SetDirectory(nullptr);; 4872 return hnew;; 4873}; c#define c(i)Definition RSha256.hxx:101; s1#define s1(x)Definition RSha256.hxx:91; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; Style_tshort Style_tDefinition RtypesCore.h:82; Int_tint Int_tDefinition RtypesCore.h:45; Color_tshort Color_tDefinition RtypesCore.h:85; Version_tshort Version_tDefinition RtypesCore.h:65; Char_tchar Char_tDefinition RtypesCore.h:37; Float_tfloat Float_tDefinition RtypesCore.h:57; Short_tshort Short_tDefinition RtypesCore.h:39; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBuffer.h; TClass.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; TF3.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; namechar name[80]Definition TGX11.cxx:110; TH2.h; operator-TH3C operator-(TH3C const &h1, TH3C const &h2)Operator -.Definition TH3.cxx:3755; operator+TH3C operator+(TH3C const &h1, TH3C const &h2)Operator +.Definition TH3.cxx:3743; operator/TH3C operator/(TH3C const &h1, TH3C const &h2)Operator /.Definition TH3.cxx:3779; operator*TH3C operator*(Float_t c1, TH3C const &h3c)Operator *.Definition TH3.cxx:3731; TH3.h; THLimitsFinder.h; THashList.h; xminfloat xminDefinition THbookFile.cxx",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:193156,Availability,error,error,193156,"e] entry bufferDefinition TH1.h:108; TH1::GetEffectiveEntriesvirtual Double_t GetEffectiveEntries() constNumber of effective entries of the histogram.Definition TH1.cxx:4448; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Multiplyvirtual Bool_t Multiply(TF1 *f1, Double_t c1=1)Performs the operation:Definition TH1.cxx:6049; TH1::kXaxis@ kXaxisDefinition TH1.h:73; TH1::kAllAxes@ kAllAxesDefinition TH1.h:76; TH1::kZaxis@ kZaxisDefinition TH1.h:75; TH1::kYaxis@ kYaxisDefinition TH1.h:74; TH1::fNcellsInt_t fNcellsNumber of bins(1D), cells (2D) +U/Overflows.Definition TH1.h:89; TH1::Copyvoid Copy(TObject &hnew) const overrideCopy this histogram structure to newth1.Definition TH1.cxx:2671; TH1::fTsumwDouble_t fTsumwTotal Sum of weights.Definition TH1.h:96; TH1::fTsumw2Double_t fTsumw2Total Sum of squares of weights.Definition TH1.h:97; TH1::Classstatic TClass * Class(); TH1::DoIntegralvirtual Double_t DoIntegral(Int_t ix1, Int_t ix2, Int_t iy1, Int_t iy2, Int_t iz1, Int_t iz2, Double_t &err, Option_t *opt, Bool_t doerr=kFALSE) constInternal function compute integral and optionally the error between the limits specified by the bin n...Definition TH1.cxx:7977; TH1::fTsumwx2Double_t fTsumwx2Total Sum of weight*X*X.Definition TH1.h:99; TH1::GetStdDevvirtual Double_t GetStdDev(Int_t axis=1) constReturns the Standard Deviation (Sigma).Definition TH1.cxx:7607; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associated to bin number bin.Definition TH1.cxx:9063; TH1::GetNbinsZvirtual Int_t GetNbinsZ() constDefinition TH1.h:299; TH1::GetDimensionvirtual Int_t GetDimension() constDefinition TH1.h:283; TH1::Streamervoid Streamer(TBuffer &) overrideStream a class object.Definition TH1.cxx:6933; TH1::kIsNotW@ kIsNotWHistogram is forced to be not weighted even when the histogram is filled with weighted.Definition TH1.h:172; TH1::CanExtendAllAxesvirtual Bool_t CanExtendAllAxes(",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:193574,Availability,error,error,193574," TH1::fNcellsInt_t fNcellsNumber of bins(1D), cells (2D) +U/Overflows.Definition TH1.h:89; TH1::Copyvoid Copy(TObject &hnew) const overrideCopy this histogram structure to newth1.Definition TH1.cxx:2671; TH1::fTsumwDouble_t fTsumwTotal Sum of weights.Definition TH1.h:96; TH1::fTsumw2Double_t fTsumw2Total Sum of squares of weights.Definition TH1.h:97; TH1::Classstatic TClass * Class(); TH1::DoIntegralvirtual Double_t DoIntegral(Int_t ix1, Int_t ix2, Int_t iy1, Int_t iy2, Int_t iz1, Int_t iz2, Double_t &err, Option_t *opt, Bool_t doerr=kFALSE) constInternal function compute integral and optionally the error between the limits specified by the bin n...Definition TH1.cxx:7977; TH1::fTsumwx2Double_t fTsumwx2Total Sum of weight*X*X.Definition TH1.h:99; TH1::GetStdDevvirtual Double_t GetStdDev(Int_t axis=1) constReturns the Standard Deviation (Sigma).Definition TH1.cxx:7607; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associated to bin number bin.Definition TH1.cxx:9063; TH1::GetNbinsZvirtual Int_t GetNbinsZ() constDefinition TH1.h:299; TH1::GetDimensionvirtual Int_t GetDimension() constDefinition TH1.h:283; TH1::Streamervoid Streamer(TBuffer &) overrideStream a class object.Definition TH1.cxx:6933; TH1::kIsNotW@ kIsNotWHistogram is forced to be not weighted even when the histogram is filled with weighted.Definition TH1.h:172; TH1::CanExtendAllAxesvirtual Bool_t CanExtendAllAxes() constReturns true if all axes are extendable.Definition TH1.cxx:6636; TH1::Resetvirtual void Reset(Option_t *option="""")Reset this histogram: contents, errors, etc.Definition TH1.cxx:7103; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetNcellsvirtual Int_t GetNcells() constDefinition TH1.h:300; TH1::PutStatsvirtual void PutStats(Double_t *stats)Replace current statistics with the values in array stats.Definition TH1.cxx:7884; TH1::GetPainterTVirtualHistPainter * GetPainter(Option_t",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:194203,Availability,error,errors,194203,"etween the limits specified by the bin n...Definition TH1.cxx:7977; TH1::fTsumwx2Double_t fTsumwx2Total Sum of weight*X*X.Definition TH1.h:99; TH1::GetStdDevvirtual Double_t GetStdDev(Int_t axis=1) constReturns the Standard Deviation (Sigma).Definition TH1.cxx:7607; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associated to bin number bin.Definition TH1.cxx:9063; TH1::GetNbinsZvirtual Int_t GetNbinsZ() constDefinition TH1.h:299; TH1::GetDimensionvirtual Int_t GetDimension() constDefinition TH1.h:283; TH1::Streamervoid Streamer(TBuffer &) overrideStream a class object.Definition TH1.cxx:6933; TH1::kIsNotW@ kIsNotWHistogram is forced to be not weighted even when the histogram is filled with weighted.Definition TH1.h:172; TH1::CanExtendAllAxesvirtual Bool_t CanExtendAllAxes() constReturns true if all axes are extendable.Definition TH1.cxx:6636; TH1::Resetvirtual void Reset(Option_t *option="""")Reset this histogram: contents, errors, etc.Definition TH1.cxx:7103; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetNcellsvirtual Int_t GetNcells() constDefinition TH1.h:300; TH1::PutStatsvirtual void PutStats(Double_t *stats)Replace current statistics with the values in array stats.Definition TH1.cxx:7884; TH1::GetPainterTVirtualHistPainter * GetPainter(Option_t *option="""")Return pointer to painter.Definition TH1.cxx:4511; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::GetBinvirtual Int_t GetBin(Int_t binx, Int_t biny=0, Int_t binz=0) constReturn Global bin number corresponding to binx,y,z.Definition TH1.cxx:4961; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:195141,Availability,error,errors,195141,"Definition TH1.cxx:6636; TH1::Resetvirtual void Reset(Option_t *option="""")Reset this histogram: contents, errors, etc.Definition TH1.cxx:7103; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetNcellsvirtual Int_t GetNcells() constDefinition TH1.h:300; TH1::PutStatsvirtual void PutStats(Double_t *stats)Replace current statistics with the values in array stats.Definition TH1.cxx:7884; TH1::GetPainterTVirtualHistPainter * GetPainter(Option_t *option="""")Return pointer to painter.Definition TH1.cxx:4511; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::GetBinvirtual Int_t GetBin(Int_t binx, Int_t biny=0, Int_t binz=0) constReturn Global bin number corresponding to binx,y,z.Definition TH1.cxx:4961; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; TH1::fBufferSizeInt_t fBufferSizefBuffer sizeDefinition TH1.h:107; TH1::RetrieveBinContentvirtual Double_t RetrieveBinContent(Int_t bin) constRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.cxx:9439; TH1::fDimensionInt_t fDimension! Histogram dimension (1, 2 or 3 dim)Definition TH1.h:110; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::fgBufferSizestatic Int_t fgBufferSize! Default buffer size for automatic histogramsDefinition TH1.h:115; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::GetAxisLabelStatusUInt_t GetAxisLabelStatus() constInternal fu",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:195626,Availability,error,error,195626,"(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::GetBinvirtual Int_t GetBin(Int_t binx, Int_t biny=0, Int_t binz=0) constReturn Global bin number corresponding to binx,y,z.Definition TH1.cxx:4961; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; TH1::fBufferSizeInt_t fBufferSizefBuffer sizeDefinition TH1.h:107; TH1::RetrieveBinContentvirtual Double_t RetrieveBinContent(Int_t bin) constRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.cxx:9439; TH1::fDimensionInt_t fDimension! Histogram dimension (1, 2 or 3 dim)Definition TH1.h:110; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::fgBufferSizestatic Int_t fgBufferSize! Default buffer size for automatic histogramsDefinition TH1.h:115; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::GetAxisLabelStatusUInt_t GetAxisLabelStatus() constInternal function used in TH1::Fill to see which axis is full alphanumeric, i.e.Definition TH1.cxx:6675; TH1::fIntegralDouble_t * fIntegral! Integral of bins used by GetRandomDefinition TH1.h:111; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Double_t content)Set bin content see convention for numbering bins in TH1::GetBin In case the bin number is greater th...Definition TH1.cxx:9222; TH1::GetBinLowEdgevirtual Double_t GetBinLowEdge(Int_t bin) constReturn bin lower edge for 1D histogram.Definition TH1.cxx:9152; TH1::GetEntriesvirtual Double_t ",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:198802,Availability,error,errors,198802,"bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::fXaxisTAxis fXaxisX axis descriptor.Definition TH1.h:90; TH1::ExtendAxisvirtual void ExtendAxis(Double_t x, TAxis *axis)Histogram is resized along axis such that x is in the axis range.Definition TH1.cxx:6504; TH1::fSumw2TArrayD fSumw2Array of sum of squares of weights.Definition TH1.h:104; TH1::Scalevirtual void Scale(Double_t c1=1, Option_t *option="""")Multiply this histogram by a constant c1.Definition TH1.cxx:6604; TH1::GetSumw2Nvirtual Int_t GetSumw2N() constDefinition TH1.h:315; TH1::FindBinvirtual Int_t FindBin(Double_t x, Double_t y=0, Double_t z=0)Return Global bin number corresponding to x,y,z.Definition TH1.cxx:3672; TH1::GetStatOverflowsBehaviourBool_t GetStatOverflowsBehaviour() constDefinition TH1.h:152; TH1::CloneTObject * Clone(const char *newname="""") const overrideMake a complete copy of the underlying object.Definition TH1.cxx:2752; TH1::Dividevirtual Bool_t Divide(TF1 *f1, Double_t c1=1)Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:2840; TH1::fYaxisTAxis fYaxisY axis descriptor.Definition TH1.h:91; TH1::fPainterTVirtualHistPainter * fPainter! Pointer to histogram painterDefinition TH1.h:112; TH1::SetBinsvirtual void SetBins(Int_t nx, Double_t xmin, Double_t xmax)Redefine x axis parameters.Definition TH1.cxx:8767; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create structure to store sum of squares of weights.Definition TH1.cxx:9020; TH1::SetEntriesvirtual void SetEntries(Double_t n)Definition TH1.h:391; TH1::fgDefaultSumw2static Bool_t fgDefaultSumw2! Flag to call TH1::Sumw2 automatically at histogram creation timeDefinition TH1.h:118; TH1::fTsumwxDouble_t fTsumwxTotal Sum of weight*X.Definition TH1.h:98; TH1::ComputeIntegralvirtual Double_t ComputeIntegral(Bool_t onlyPositive=false)Compute integral (normalized cumulative sum of bins) w/o under/overflows The result is stored in fInt...Definition TH1.cxx:2537; TH2D2-D",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:200338,Availability,error,errors,200338,"d SetEntries(Double_t n)Definition TH1.h:391; TH1::fgDefaultSumw2static Bool_t fgDefaultSumw2! Flag to call TH1::Sumw2 automatically at histogram creation timeDefinition TH1.h:118; TH1::fTsumwxDouble_t fTsumwxTotal Sum of weight*X.Definition TH1.h:98; TH1::ComputeIntegralvirtual Double_t ComputeIntegral(Bool_t onlyPositive=false)Compute integral (normalized cumulative sum of bins) w/o under/overflows The result is stored in fInt...Definition TH1.cxx:2537; TH2D2-D histogram with a double per channel (see TH1 documentation)Definition TH2.h:357; TH2D::Classstatic TClass * Class(); TH3C3-D histogram with a byte per channel (see TH1 documentation)Definition TH3.h:157; TH3C::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH3.cxx:3647; TH3C::IsATClass * IsA() const overrideDefinition TH3.h:192; TH3C::~TH3C~TH3C() overrideDestructor.Definition TH3.cxx:3540; TH3C::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH3.cxx:3635; TH3C::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH3.cxx:3603; TH3C::operator=TH3C & operator=(const TH3C &h1)Operator =.Definition TH3.cxx:3720; TH3C::TH3CTH3C()Constructor.Definition TH3.cxx:3530; TH3C::Classstatic TClass * Class(); TH3C::Streamervoid Streamer(TBuffer &) overrideStream an object of class TH3C.Definition TH3.cxx:3687; TH3C::Copyvoid Copy(TObject &hnew) const overrideCopy this 3-D histogram structure to newth3.Definition TH3.cxx:3626; TH3D3-D histogram with a double per channel (see TH1 documentation)Definition TH3.h:363; TH3D::IsATClass * IsA() const overrideDefinition TH3.h:403; TH3D::TH3DTH3D()Constructor.Definition TH3.cxx:4669; TH3D::Streamervoid Streamer(TBuffer &) overrideStream an object of class TH3D.Definition TH3.cxx:4774; TH3D::Classstatic TClass * Class(); TH3D::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bi",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:207079,Availability,error,errors,207079,"void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr) overrideFill histogram following distribution in function fname.Definition TH3.cxx:833; TH3::KolmogorovTestDouble_t KolmogorovTest(const TH1 *h2, Option_t *option="""") const overrideStatistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test.Definition TH3.cxx:1532; TH3::ProjectionYvirtual TH1D * ProjectionY(const char *name=""_py"", Int_t ixmin=0, Int_t ixmax=-1, Int_t izmin=0, Int_t izmax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D histogram along Y.Definition TH3.cxx:1780; TH3::InterpolateDouble_t Interpolate(Double_t x, Double_t y) const overrideNot yet implemented.Definition TH3.cxx:1441; TH3::GetRandom3virtual void GetRandom3(Double_t &x, Double_t &y, Double_t &, TRandom *rng=nullptr)Return 3 random numbers along axis x , y and z distributed according to the cell-contents of this 3-d...Definition TH3.cxx:1259; TH3::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH3.cxx:3449; TH3::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH3.cxx:224; TH3::~TH3~TH3() overrideDestructor.Definition TH3.cxx:200; TH3::FillInt_t Fill(Double_t) overrideInvalid Fill method.Definition TH3.cxx:368; TH3::RebinYvirtual TH3 * RebinY(Int_t ngroup=2, const char *newname="""")Rebin only the Y axis see Rebin3D.Definition TH3.cxx:2916; TH3::IntegralAndErrorvirtual Double_t IntegralAndError(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Int_t binz1, Int_t binz2, Double_t &err, Option_t *option="""") constReturn integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2] for a 3-D histogra...Definition TH3.cxx:1421; TH3::ProjectionZvirtual TH1D * ProjectionZ(const char *name=""_pz"", Int_t ixmin=0, Int_t ixmax=-1, Int_t iymin=0, Int_t iymax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D histogram along Z.Definition TH3.cxx:1812; TH3::Proj",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:214120,Availability,error,error,214120,"onstUse this method to implement an ""abstract"" method that you don't want to leave purely abstract.Definition TObject.cxx:1035; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TProfile2DProfile2D histograms are used to display the mean value of Z and its error for each cell in X,...Definition TProfile2D.h:27; TProfile2D::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TProfile2D.cxx:1474; TProfile2D::FillInt_t Fill(const Double_t *v)Definition TProfile2D.h:51; TProfile2D::Classstatic TClass * Class(); TProfile2D::Sumw2void Sumw2(Bool_t flag=kTRUE) overrideCreate/Delete structure to store sum of squares of weights per bin.Definition TProfile2D.cxx:2043; TProfile2D::SetBinsvoid SetBins(const Int_t *nbins, const Double_t *range)Definition TProfile2D.h:49; TProfile2D::GetBinSumw2virtual TArrayD * GetBinSumw2()Definition TProfile2D.h:121; TProfile2D::Resetvoid Reset(",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:214434,Availability,error,error,214434,"me of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TProfile2DProfile2D histograms are used to display the mean value of Z and its error for each cell in X,...Definition TProfile2D.h:27; TProfile2D::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TProfile2D.cxx:1474; TProfile2D::FillInt_t Fill(const Double_t *v)Definition TProfile2D.h:51; TProfile2D::Classstatic TClass * Class(); TProfile2D::Sumw2void Sumw2(Bool_t flag=kTRUE) overrideCreate/Delete structure to store sum of squares of weights per bin.Definition TProfile2D.cxx:2043; TProfile2D::SetBinsvoid SetBins(const Int_t *nbins, const Double_t *range)Definition TProfile2D.h:49; TProfile2D::GetBinSumw2virtual TArrayD * GetBinSumw2()Definition TProfile2D.h:121; TProfile2D::Resetvoid Reset(Option_t *option="""") overrideReset contents of a Profile2D histogram.Definition TProfile2D.cxx:1490; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definit",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:217540,Availability,down,downward,217540,"option, Int_t nbins)=0; TVirtualPad::TContextsmall helper class to store/restore gPad context in TPad methodsDefinition TVirtualPad.h:61; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; h1TH1F * h1Definition legend1.C:5; f1TF1 * f1Definition legend1.C:11; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf...Definition TMath.cxx:637; TMath::PermuteBool_t Permute(Int_t n, Int_t *a)Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinc...Definition TMath.cxx:2557; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::MeanDouble_t Mean(Long64_t n, const T *a, const Double_t *w=nullptr)Returns the weighted mean of an array a with length n.Definition TMath.h:1089; TMath::KolmogorovProbDouble_t KolmogorovProb(Double_t z)Calculates the Kolmogorov distribution function,.Definition TMath.cxx:679; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; v@ vDefinition rootcling_impl.cxx:3699. histhistsrcTH3.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:31320,Deployability,integrat,integrated,31320,"rn -1;; 785 }; 786 if (biny == 0 || biny > fYaxis.GetNbins()) {; 787 if (!GetStatOverflowsBehaviour()) return -1;; 788 }; 789 if (binz == 0 || binz > fZaxis.GetNbins()) return -1;; 790 ; 791 Double_t v = w;; 792 fTsumw += v;; 793 fTsumw2 += v*v;; 794 fTsumwx += v*x;; 795 fTsumwx2 += v*x*x;; 796 fTsumwy += v*y;; 797 fTsumwy2 += v*y*y;; 798 fTsumwxy += v*x*y;; 799 ; 800 // skip computation for z axis : for only one axis no need to use bit mask; 801 if (!fZaxis.CanExtend() || !fZaxis.IsAlphanumeric()) {; 802 Double_t z = fZaxis.GetBinCenter(binz);; 803 fTsumwz += v*z;; 804 fTsumwz2 += v*z*z;; 805 fTsumwxz += v*x*z;; 806 fTsumwyz += v*y*z;; 807 }; 808 return bin;; 809}; 810 ; 811 ; 812////////////////////////////////////////////////////////////////////////////////; 813/// Fill histogram following distribution in function fname.; 814///; 815/// @param fname : Function name used for filling the historam; 816/// @param ntimes : number of times the histogram is filled; 817/// @param rng : (optional) Random number generator used to sample; 818///; 819/// The distribution contained in the function fname (TF1) is integrated; 820/// over the channel contents.; 821/// It is normalized to 1.; 822/// Getting one random number implies:; 823/// - Generating a random number between 0 and 1 (say r1); 824/// - Look in which bin in the normalized integral r1 corresponds to; 825/// - Fill histogram channel; 826/// ntimes random numbers are generated; 827///; 828/// N.B. By dfault this methods approximates the integral of the function in each bin with the; 829/// function value at the center of the bin, mutiplied by the bin width; 830///; 831/// One can also call TF1::GetRandom to get a random variate from a function.; 832 ; 833void TH3::FillRandom(const char *fname, Int_t ntimes, TRandom * rng); 834{; 835 Int_t bin, binx, biny, binz, ibin, loop;; 836 Double_t r1, x, y,z, xv[3];; 837 // Search for fname in the list of ROOT defined functions; 838 TObject *fobj = gROOT->GetFunction(fname);;",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:35425,Deployability,integrat,integrated,35425,"= zero""); return;; 889 }; 890 for (bin=1;bin<=nbins;bin++) integral[bin] /= integral[nbins];; 891 ; 892 // Start main loop ntimes; 893 if (fDimension < 2) nbinsy = -1;; 894 if (fDimension < 3) nbinsz = -1;; 895 for (loop=0;loop<ntimes;loop++) {; 896 r1 = (rng) ? rng->Rndm() : gRandom->Rndm();; 897 ibin = TMath::BinarySearch(nbins,&integral[0],r1);; 898 binz = ibin/nxy;; 899 biny = (ibin - nxy*binz)/nbinsx;; 900 binx = 1 + ibin - nbinsx*(biny + nbinsy*binz);; 901 if (nbinsz) binz++;; 902 if (nbinsy) biny++;; 903 x = xAxis.GetBinCenter(binx);; 904 y = yAxis.GetBinCenter(biny);; 905 z = zAxis.GetBinCenter(binz);; 906 Fill(x,y,z, 1.);; 907 }; 908 delete [] integral;; 909}; 910 ; 911 ; 912////////////////////////////////////////////////////////////////////////////////; 913/// Fill histogram following distribution in histogram h.; 914///; 915/// @param h : Histogram pointer used for smpling random number; 916/// @param ntimes : number of times the histogram is filled; 917/// @param rng : (optional) Random number generator used for sampling; 918///; 919/// The distribution contained in the histogram h (TH3) is integrated; 920/// over the channel contents.; 921/// It is normalized to 1.; 922/// Getting one random number implies:; 923/// - Generating a random number between 0 and 1 (say r1); 924/// - Look in which bin in the normalized integral r1 corresponds to; 925/// - Fill histogram channel; 926/// ntimes random numbers are generated; 927 ; 928void TH3::FillRandom(TH1 *h, Int_t ntimes, TRandom * rng); 929{; 930 if (!h) { Error(""FillRandom"", ""Null histogram""); return; }; 931 if (fDimension != h->GetDimension()) {; 932 Error(""FillRandom"", ""Histograms with different dimensions""); return;; 933 }; 934 ; 935 if (h->ComputeIntegral() == 0) return;; 936 ; 937 TH3 *h3 = (TH3*)h;; 938 Int_t loop;; 939 Double_t x,y,z;; 940 for (loop=0;loop<ntimes;loop++) {; 941 h3->GetRandom3(x,y,z,rng);; 942 Fill(x,y,z);; 943 }; 944}; 945 ; 946///////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:80360,Deployability,integrat,integrated,80360,"t is set artificially (see TAxis::SetRange); 2010 //if (out1min == 0 && out1max == 0) { out1min = 1; out1max = out1->GetNbins(); }; 2011 // correct for underflow/overflows; 2012 if (useUF && !out1->TestBit(TAxis::kAxisRange) ) out1min -= 1;; 2013 if (useOF && !out1->TestBit(TAxis::kAxisRange) ) out1max += 1;; 2014 Int_t out2min = out2->GetFirst();; 2015 Int_t out2max = out2->GetLast();; 2016// if (out2min == 0 && out2max == 0) { out2min = 1; out2max = out2->GetNbins(); }; 2017 if (useUF && !out2->TestBit(TAxis::kAxisRange) ) out2min -= 1;; 2018 if (useOF && !out2->TestBit(TAxis::kAxisRange) ) out2max += 1;; 2019 ; 2020 // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins; 2021 Bool_t extendable = projX->CanExtend();; 2022 if ( labels && extendable ) h1->GetXaxis()->SetCanExtend(kFALSE);; 2023 for (ixbin=0;ixbin<=1+projX->GetNbins();ixbin++) {; 2024 if ( projX->TestBit(TAxis::kAxisRange) && ( ixbin < ixmin || ixbin > ixmax )) continue;; 2025 ; 2026 Double_t cont = 0;; 2027 Double_t err2 = 0;; 2028 ; 2029 // loop on the bins to be integrated (outbin should be called inbin); 2030 for (out1bin = out1min; out1bin <= out1max; out1bin++) {; 2031 for (out2bin = out2min; out2bin <= out2max; out2bin++) {; 2032 ; 2033 Int_t bin = GetBin(*refX, *refY, *refZ);; 2034 ; 2035 // sum the bin contents and errors if needed; 2036 cont += RetrieveBinContent(bin);; 2037 if (computeErrors) {; 2038 Double_t exyz = GetBinError(bin);; 2039 err2 += exyz*exyz;; 2040 }; 2041 }; 2042 }; 2043 Int_t ix = h1->FindBin( projX->GetBinCenter(ixbin) );; 2044 h1->SetBinContent(ix ,cont);; 2045 if (computeErrors) h1->SetBinError(ix, TMath::Sqrt(err2) );; 2046 // sum all content; 2047 totcont += cont;; 2048 ; 2049 }; 2050 if ( labels ) h1->GetXaxis()->SetCanExtend(extendable);; 2051 ; 2052 // since we use a combination of fill and SetBinError we need to reset and recalculate the statistics; 2053 // for weighted histograms otherwise sumw2 will be wrong.",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:89749,Deployability,integrat,integrated,89749,"; 2238 // Fill the projected histogram excluding underflow/overflows if considered in the option; 2239 // if specified in the option (by default they considered); 2240 Double_t totcont = 0;; 2241 ; 2242 Int_t outmin = out->GetFirst();; 2243 Int_t outmax = out->GetLast();; 2244 // GetFirst(), GetLast() can return (0,0) when the range bit is set artificially (see TAxis::SetRange); 2245 if (outmin == 0 && outmax == 0) { outmin = 1; outmax = out->GetNbins(); }; 2246 // correct for underflow/overflows; 2247 if (useUF && !out->TestBit(TAxis::kAxisRange) ) outmin -= 1;; 2248 if (useOF && !out->TestBit(TAxis::kAxisRange) ) outmax += 1;; 2249 ; 2250 for (ixbin=0;ixbin<=1+projX->GetNbins();ixbin++) {; 2251 if ( projX->TestBit(TAxis::kAxisRange) && ( ixbin < ixmin || ixbin > ixmax )) continue;; 2252 Int_t ix = h2->GetYaxis()->FindBin( projX->GetBinCenter(ixbin) );; 2253 ; 2254 for (iybin=0;iybin<=1+projY->GetNbins();iybin++) {; 2255 if ( projY->TestBit(TAxis::kAxisRange) && ( iybin < iymin || iybin > iymax )) continue;; 2256 Int_t iy = h2->GetXaxis()->FindBin( projY->GetBinCenter(iybin) );; 2257 ; 2258 Double_t cont = 0;; 2259 Double_t err2 = 0;; 2260 ; 2261 // loop on the bins to be integrated (outbin should be called inbin); 2262 for (outbin = outmin; outbin <= outmax; outbin++) {; 2263 ; 2264 Int_t bin = GetBin(*refX,*refY,*refZ);; 2265 ; 2266 // sum the bin contents and errors if needed; 2267 cont += RetrieveBinContent(bin);; 2268 if (computeErrors) {; 2269 Double_t exyz = GetBinError(bin);; 2270 err2 += exyz*exyz;; 2271 }; 2272 ; 2273 }; 2274 ; 2275 // remember axis are inverted; 2276 h2->SetBinContent(iy , ix, cont);; 2277 if (computeErrors) h2->SetBinError(iy, ix, TMath::Sqrt(err2) );; 2278 // sum all content; 2279 totcont += cont;; 2280 ; 2281 }; 2282 }; 2283 ; 2284 // since we use fill we need to reset and recalculate the statistics (see comment in DoProject1D ); 2285 // or keep original statistics if consistent sumw2; 2286 bool resetStats = true;; 2287 double eps = 1.",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:100522,Deployability,update,update,100522,"nt pad; 2532 if (h && opt.Contains(""d"")) {; 2533 opt.Remove(opt.First(""d""),1);; 2534 TVirtualPad::TContext ctxt(gROOT->GetSelectedPad(), true, true);; 2535 if (!gPad || !gPad->FindObject(h)) {; 2536 h->Draw(opt);; 2537 } else {; 2538 h->Paint(opt);; 2539 }; 2540 }; 2541 ; 2542 return h;; 2543}; 2544 ; 2545 ; 2546////////////////////////////////////////////////////////////////////////////////; 2547/// internal function to fill the bins of the projected profile 2D histogram; 2548/// called from DoProjectProfile2D; 2549 ; 2550void TH3::DoFillProfileProjection(TProfile2D * p2,; 2551 const TAxis & a1, const TAxis & a2, const TAxis & a3,; 2552 Int_t bin1, Int_t bin2, Int_t bin3,; 2553 Int_t inBin, Bool_t useWeights ) const {; 2554 Double_t cont = GetBinContent(inBin);; 2555 if (!cont) return;; 2556 TArrayD & binSumw2 = *(p2->GetBinSumw2());; 2557 if (useWeights && binSumw2.fN <= 0) useWeights = false;; 2558 if (!useWeights) p2->SetBit(TH1::kIsNotW); // to use Fill for setting the bin contents of the Profile; 2559 // the following fill update wrongly the fBinSumw2- need to save it before; 2560 Double_t u = a1.GetBinCenter(bin1);; 2561 Double_t v = a2.GetBinCenter(bin2);; 2562 Double_t w = a3.GetBinCenter(bin3);; 2563 Int_t outBin = p2->FindBin(u, v);; 2564 if (outBin <0) return;; 2565 Double_t tmp = 0;; 2566 if ( useWeights ) tmp = binSumw2.fArray[outBin];; 2567 p2->Fill( u , v, w, cont);; 2568 if (useWeights ) binSumw2.fArray[outBin] = tmp + fSumw2.fArray[inBin];; 2569}; 2570 ; 2571 ; 2572////////////////////////////////////////////////////////////////////////////////; 2573/// internal method to project to a 2D Profile; 2574/// called from TH3::Project3DProfile; 2575 ; 2576TProfile2D *TH3::DoProjectProfile2D(const char* name, const char * title, const TAxis* projX, const TAxis* projY,; 2577 bool originalRange, bool useUF, bool useOF) const; 2578{; 2579 // Get the ranges where we will work.; 2580 Int_t ixmin = std::max(projX->GetFirst(),1);; 2581 Int_t ixmax = std::min(pro",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:107880,Deployability,integrat,integrated,107880,"Z != nullptr);; 2703 ; 2704 Int_t outmin = outAxis->GetFirst();; 2705 Int_t outmax = outAxis->GetLast();; 2706 // GetFirst, GetLast can return underflow or overflow bins; 2707 // correct for underflow/overflows; 2708 if (useUF && !outAxis->TestBit(TAxis::kAxisRange) ) outmin -= 1;; 2709 if (useOF && !outAxis->TestBit(TAxis::kAxisRange) ) outmax += 1;; 2710 ; 2711 TArrayD & binSumw2 = *(p2->GetBinSumw2());; 2712 if (useWeights && binSumw2.fN <= 0) useWeights = false;; 2713 if (!useWeights) p2->SetBit(TH1::kIsNotW);; 2714 ; 2715 // Call specific method for the projection; 2716 for (ixbin=0;ixbin<=1+projX->GetNbins();ixbin++) {; 2717 if ( (ixbin < ixmin || ixbin > ixmax) && projX->TestBit(TAxis::kAxisRange)) continue;; 2718 for ( iybin=0;iybin<=1+projY->GetNbins();iybin++) {; 2719 if ( (iybin < iymin || iybin > iymax) && projX->TestBit(TAxis::kAxisRange)) continue;; 2720 ; 2721 // profile output bin; 2722 Int_t poutBin = p2->FindBin(projY->GetBinCenter(iybin), projX->GetBinCenter(ixbin));; 2723 if (poutBin <0) continue;; 2724 // loop on the bins to be integrated (outbin should be called inbin); 2725 for (outbin = outmin; outbin <= outmax; outbin++) {; 2726 ; 2727 Int_t bin = GetBin(*refX,*refY,*refZ);; 2728 ; 2729 //DoFillProfileProjection(p2, *projY, *projX, *outAxis, iybin, ixbin, outbin, bin, useWeights);; 2730 ; 2731 Double_t cont = RetrieveBinContent(bin);; 2732 if (!cont) continue;; 2733 ; 2734 Double_t tmp = 0;; 2735 // the following fill update wrongly the fBinSumw2- need to save it before; 2736 if ( useWeights ) tmp = binSumw2.fArray[poutBin];; 2737 p2->Fill( projY->GetBinCenter(iybin) , projX->GetBinCenter(ixbin), outAxis->GetBinCenter(outbin), cont);; 2738 if (useWeights ) binSumw2.fArray[poutBin] = tmp + fSumw2.fArray[bin];; 2739 ; 2740 }; 2741 }; 2742 }; 2743 ; 2744 // recompute statistics for the projected profiles; 2745 // forget about preserving old statistics; 2746 bool resetStats = true;; 2747 Double_t stats[kNstat];; 2748 // reset statistics; 2749 if ",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:108282,Deployability,update,update,108282,"Z != nullptr);; 2703 ; 2704 Int_t outmin = outAxis->GetFirst();; 2705 Int_t outmax = outAxis->GetLast();; 2706 // GetFirst, GetLast can return underflow or overflow bins; 2707 // correct for underflow/overflows; 2708 if (useUF && !outAxis->TestBit(TAxis::kAxisRange) ) outmin -= 1;; 2709 if (useOF && !outAxis->TestBit(TAxis::kAxisRange) ) outmax += 1;; 2710 ; 2711 TArrayD & binSumw2 = *(p2->GetBinSumw2());; 2712 if (useWeights && binSumw2.fN <= 0) useWeights = false;; 2713 if (!useWeights) p2->SetBit(TH1::kIsNotW);; 2714 ; 2715 // Call specific method for the projection; 2716 for (ixbin=0;ixbin<=1+projX->GetNbins();ixbin++) {; 2717 if ( (ixbin < ixmin || ixbin > ixmax) && projX->TestBit(TAxis::kAxisRange)) continue;; 2718 for ( iybin=0;iybin<=1+projY->GetNbins();iybin++) {; 2719 if ( (iybin < iymin || iybin > iymax) && projX->TestBit(TAxis::kAxisRange)) continue;; 2720 ; 2721 // profile output bin; 2722 Int_t poutBin = p2->FindBin(projY->GetBinCenter(iybin), projX->GetBinCenter(ixbin));; 2723 if (poutBin <0) continue;; 2724 // loop on the bins to be integrated (outbin should be called inbin); 2725 for (outbin = outmin; outbin <= outmax; outbin++) {; 2726 ; 2727 Int_t bin = GetBin(*refX,*refY,*refZ);; 2728 ; 2729 //DoFillProfileProjection(p2, *projY, *projX, *outAxis, iybin, ixbin, outbin, bin, useWeights);; 2730 ; 2731 Double_t cont = RetrieveBinContent(bin);; 2732 if (!cont) continue;; 2733 ; 2734 Double_t tmp = 0;; 2735 // the following fill update wrongly the fBinSumw2- need to save it before; 2736 if ( useWeights ) tmp = binSumw2.fArray[poutBin];; 2737 p2->Fill( projY->GetBinCenter(iybin) , projX->GetBinCenter(ixbin), outAxis->GetBinCenter(outbin), cont);; 2738 if (useWeights ) binSumw2.fArray[poutBin] = tmp + fSumw2.fArray[bin];; 2739 ; 2740 }; 2741 }; 2742 }; 2743 ; 2744 // recompute statistics for the projected profiles; 2745 // forget about preserving old statistics; 2746 bool resetStats = true;; 2747 Double_t stats[kNstat];; 2748 // reset statistics; 2749 if ",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:197584,Deployability,update,update,197584,".Definition TH1.cxx:9152; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::ResetStatsvirtual void ResetStats()Reset the statistics including the number of entries and replace with values calculated from bin cont...Definition TH1.cxx:7902; TH1::SetBuffervirtual void SetBuffer(Int_t buffersize, Option_t *option="""")Set the maximum number of entries to be kept in the buffer.Definition TH1.cxx:8458; TH1::kNstat@ kNstatSize of statistics data (up to TProfile3D)Definition TH1.h:184; TH1::fEntriesDouble_t fEntriesNumber of entries.Definition TH1.h:95; TH1::fZaxisTAxis fZaxisZ axis descriptor.Definition TH1.h:92; TH1::UpdateBinContentvirtual void UpdateBinContent(Int_t bin, Double_t content)Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH1.cxx:9449; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::fXaxisTAxis fXaxisX axis descriptor.Definition TH1.h:90; TH1::ExtendAxisvirtual void ExtendAxis(Double_t x, TAxis *axis)Histogram is resized along axis such that x is in the axis range.Definition TH1.cxx:6504; TH1::fSumw2TArrayD fSumw2Array of sum of squares of weights.Definition TH1.h:104; TH1::Scalevirtual void Scale(Double_t c1=1, Option_t *option="""")Multiply this histogram by a constant c1.Definition TH1.cxx:6604; TH1::GetSumw2Nvirtual Int_t GetSumw2N() constDefinition TH1.h:315; TH1::FindBinvirtual Int_t FindBin(Double_t x, Double_t y=0, Double_t z=0)Return Global bin number corresponding to x,y,z.Definition TH1.cxx:3672; TH1::GetStatOverflowsBehaviourBool_t GetStatOverflowsBehaviour() constDefinition TH1.h:152; TH1::CloneTObject * Clone",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:31320,Integrability,integrat,integrated,31320,"rn -1;; 785 }; 786 if (biny == 0 || biny > fYaxis.GetNbins()) {; 787 if (!GetStatOverflowsBehaviour()) return -1;; 788 }; 789 if (binz == 0 || binz > fZaxis.GetNbins()) return -1;; 790 ; 791 Double_t v = w;; 792 fTsumw += v;; 793 fTsumw2 += v*v;; 794 fTsumwx += v*x;; 795 fTsumwx2 += v*x*x;; 796 fTsumwy += v*y;; 797 fTsumwy2 += v*y*y;; 798 fTsumwxy += v*x*y;; 799 ; 800 // skip computation for z axis : for only one axis no need to use bit mask; 801 if (!fZaxis.CanExtend() || !fZaxis.IsAlphanumeric()) {; 802 Double_t z = fZaxis.GetBinCenter(binz);; 803 fTsumwz += v*z;; 804 fTsumwz2 += v*z*z;; 805 fTsumwxz += v*x*z;; 806 fTsumwyz += v*y*z;; 807 }; 808 return bin;; 809}; 810 ; 811 ; 812////////////////////////////////////////////////////////////////////////////////; 813/// Fill histogram following distribution in function fname.; 814///; 815/// @param fname : Function name used for filling the historam; 816/// @param ntimes : number of times the histogram is filled; 817/// @param rng : (optional) Random number generator used to sample; 818///; 819/// The distribution contained in the function fname (TF1) is integrated; 820/// over the channel contents.; 821/// It is normalized to 1.; 822/// Getting one random number implies:; 823/// - Generating a random number between 0 and 1 (say r1); 824/// - Look in which bin in the normalized integral r1 corresponds to; 825/// - Fill histogram channel; 826/// ntimes random numbers are generated; 827///; 828/// N.B. By dfault this methods approximates the integral of the function in each bin with the; 829/// function value at the center of the bin, mutiplied by the bin width; 830///; 831/// One can also call TF1::GetRandom to get a random variate from a function.; 832 ; 833void TH3::FillRandom(const char *fname, Int_t ntimes, TRandom * rng); 834{; 835 Int_t bin, binx, biny, binz, ibin, loop;; 836 Double_t r1, x, y,z, xv[3];; 837 // Search for fname in the list of ROOT defined functions; 838 TObject *fobj = gROOT->GetFunction(fname);;",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:35425,Integrability,integrat,integrated,35425,"= zero""); return;; 889 }; 890 for (bin=1;bin<=nbins;bin++) integral[bin] /= integral[nbins];; 891 ; 892 // Start main loop ntimes; 893 if (fDimension < 2) nbinsy = -1;; 894 if (fDimension < 3) nbinsz = -1;; 895 for (loop=0;loop<ntimes;loop++) {; 896 r1 = (rng) ? rng->Rndm() : gRandom->Rndm();; 897 ibin = TMath::BinarySearch(nbins,&integral[0],r1);; 898 binz = ibin/nxy;; 899 biny = (ibin - nxy*binz)/nbinsx;; 900 binx = 1 + ibin - nbinsx*(biny + nbinsy*binz);; 901 if (nbinsz) binz++;; 902 if (nbinsy) biny++;; 903 x = xAxis.GetBinCenter(binx);; 904 y = yAxis.GetBinCenter(biny);; 905 z = zAxis.GetBinCenter(binz);; 906 Fill(x,y,z, 1.);; 907 }; 908 delete [] integral;; 909}; 910 ; 911 ; 912////////////////////////////////////////////////////////////////////////////////; 913/// Fill histogram following distribution in histogram h.; 914///; 915/// @param h : Histogram pointer used for smpling random number; 916/// @param ntimes : number of times the histogram is filled; 917/// @param rng : (optional) Random number generator used for sampling; 918///; 919/// The distribution contained in the histogram h (TH3) is integrated; 920/// over the channel contents.; 921/// It is normalized to 1.; 922/// Getting one random number implies:; 923/// - Generating a random number between 0 and 1 (say r1); 924/// - Look in which bin in the normalized integral r1 corresponds to; 925/// - Fill histogram channel; 926/// ntimes random numbers are generated; 927 ; 928void TH3::FillRandom(TH1 *h, Int_t ntimes, TRandom * rng); 929{; 930 if (!h) { Error(""FillRandom"", ""Null histogram""); return; }; 931 if (fDimension != h->GetDimension()) {; 932 Error(""FillRandom"", ""Histograms with different dimensions""); return;; 933 }; 934 ; 935 if (h->ComputeIntegral() == 0) return;; 936 ; 937 TH3 *h3 = (TH3*)h;; 938 Int_t loop;; 939 Double_t x,y,z;; 940 for (loop=0;loop<ntimes;loop++) {; 941 h3->GetRandom3(x,y,z,rng);; 942 Fill(x,y,z);; 943 }; 944}; 945 ; 946///////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:80360,Integrability,integrat,integrated,80360,"t is set artificially (see TAxis::SetRange); 2010 //if (out1min == 0 && out1max == 0) { out1min = 1; out1max = out1->GetNbins(); }; 2011 // correct for underflow/overflows; 2012 if (useUF && !out1->TestBit(TAxis::kAxisRange) ) out1min -= 1;; 2013 if (useOF && !out1->TestBit(TAxis::kAxisRange) ) out1max += 1;; 2014 Int_t out2min = out2->GetFirst();; 2015 Int_t out2max = out2->GetLast();; 2016// if (out2min == 0 && out2max == 0) { out2min = 1; out2max = out2->GetNbins(); }; 2017 if (useUF && !out2->TestBit(TAxis::kAxisRange) ) out2min -= 1;; 2018 if (useOF && !out2->TestBit(TAxis::kAxisRange) ) out2max += 1;; 2019 ; 2020 // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins; 2021 Bool_t extendable = projX->CanExtend();; 2022 if ( labels && extendable ) h1->GetXaxis()->SetCanExtend(kFALSE);; 2023 for (ixbin=0;ixbin<=1+projX->GetNbins();ixbin++) {; 2024 if ( projX->TestBit(TAxis::kAxisRange) && ( ixbin < ixmin || ixbin > ixmax )) continue;; 2025 ; 2026 Double_t cont = 0;; 2027 Double_t err2 = 0;; 2028 ; 2029 // loop on the bins to be integrated (outbin should be called inbin); 2030 for (out1bin = out1min; out1bin <= out1max; out1bin++) {; 2031 for (out2bin = out2min; out2bin <= out2max; out2bin++) {; 2032 ; 2033 Int_t bin = GetBin(*refX, *refY, *refZ);; 2034 ; 2035 // sum the bin contents and errors if needed; 2036 cont += RetrieveBinContent(bin);; 2037 if (computeErrors) {; 2038 Double_t exyz = GetBinError(bin);; 2039 err2 += exyz*exyz;; 2040 }; 2041 }; 2042 }; 2043 Int_t ix = h1->FindBin( projX->GetBinCenter(ixbin) );; 2044 h1->SetBinContent(ix ,cont);; 2045 if (computeErrors) h1->SetBinError(ix, TMath::Sqrt(err2) );; 2046 // sum all content; 2047 totcont += cont;; 2048 ; 2049 }; 2050 if ( labels ) h1->GetXaxis()->SetCanExtend(extendable);; 2051 ; 2052 // since we use a combination of fill and SetBinError we need to reset and recalculate the statistics; 2053 // for weighted histograms otherwise sumw2 will be wrong.",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:89749,Integrability,integrat,integrated,89749,"; 2238 // Fill the projected histogram excluding underflow/overflows if considered in the option; 2239 // if specified in the option (by default they considered); 2240 Double_t totcont = 0;; 2241 ; 2242 Int_t outmin = out->GetFirst();; 2243 Int_t outmax = out->GetLast();; 2244 // GetFirst(), GetLast() can return (0,0) when the range bit is set artificially (see TAxis::SetRange); 2245 if (outmin == 0 && outmax == 0) { outmin = 1; outmax = out->GetNbins(); }; 2246 // correct for underflow/overflows; 2247 if (useUF && !out->TestBit(TAxis::kAxisRange) ) outmin -= 1;; 2248 if (useOF && !out->TestBit(TAxis::kAxisRange) ) outmax += 1;; 2249 ; 2250 for (ixbin=0;ixbin<=1+projX->GetNbins();ixbin++) {; 2251 if ( projX->TestBit(TAxis::kAxisRange) && ( ixbin < ixmin || ixbin > ixmax )) continue;; 2252 Int_t ix = h2->GetYaxis()->FindBin( projX->GetBinCenter(ixbin) );; 2253 ; 2254 for (iybin=0;iybin<=1+projY->GetNbins();iybin++) {; 2255 if ( projY->TestBit(TAxis::kAxisRange) && ( iybin < iymin || iybin > iymax )) continue;; 2256 Int_t iy = h2->GetXaxis()->FindBin( projY->GetBinCenter(iybin) );; 2257 ; 2258 Double_t cont = 0;; 2259 Double_t err2 = 0;; 2260 ; 2261 // loop on the bins to be integrated (outbin should be called inbin); 2262 for (outbin = outmin; outbin <= outmax; outbin++) {; 2263 ; 2264 Int_t bin = GetBin(*refX,*refY,*refZ);; 2265 ; 2266 // sum the bin contents and errors if needed; 2267 cont += RetrieveBinContent(bin);; 2268 if (computeErrors) {; 2269 Double_t exyz = GetBinError(bin);; 2270 err2 += exyz*exyz;; 2271 }; 2272 ; 2273 }; 2274 ; 2275 // remember axis are inverted; 2276 h2->SetBinContent(iy , ix, cont);; 2277 if (computeErrors) h2->SetBinError(iy, ix, TMath::Sqrt(err2) );; 2278 // sum all content; 2279 totcont += cont;; 2280 ; 2281 }; 2282 }; 2283 ; 2284 // since we use fill we need to reset and recalculate the statistics (see comment in DoProject1D ); 2285 // or keep original statistics if consistent sumw2; 2286 bool resetStats = true;; 2287 double eps = 1.",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:92866,Integrability,depend,depending,92866,"else {; 2339 // recalculate the statistics; 2340 h2->ResetStats();; 2341 }; 2342 ; 2343 if (resetEntries) {; 2344 // use the effective entries for the entries; 2345 // since this is the only way to estimate them; 2346 Double_t entries = h2->GetEffectiveEntries();; 2347 if (!computeErrors) entries = TMath::Floor( entries + 0.5); // to avoid numerical rounding; 2348 h2->SetEntries( entries );; 2349 }; 2350 else {; 2351 h2->SetEntries( fEntries );; 2352 }; 2353 ; 2354 ; 2355 return h2;; 2356}; 2357 ; 2358 ; 2359////////////////////////////////////////////////////////////////////////////////; 2360/// Project a 3-d histogram into 1 or 2-d histograms depending on the; 2361/// option parameter, which may contain a combination of the characters x,y,z,e; 2362/// - option = ""x"" return the x projection into a TH1D histogram; 2363/// - option = ""y"" return the y projection into a TH1D histogram; 2364/// - option = ""z"" return the z projection into a TH1D histogram; 2365/// - option = ""xy"" return the x versus y projection into a TH2D histogram; 2366/// - option = ""yx"" return the y versus x projection into a TH2D histogram; 2367/// - option = ""xz"" return the x versus z projection into a TH2D histogram; 2368/// - option = ""zx"" return the z versus x projection into a TH2D histogram; 2369/// - option = ""yz"" return the y versus z projection into a TH2D histogram; 2370/// - option = ""zy"" return the z versus y projection into a TH2D histogram; 2371///; 2372/// NB: the notation ""a vs b"" means ""a"" vertical and ""b"" horizontal; 2373///; 2374/// option = ""o"" original axis range of the target axes will be; 2375/// kept, but only bins inside the selected range will be filled.; 2376///; 2377/// If option contains the string ""e"", errors are computed; 2378///; 2379/// The projection is made for the selected bins only.; 2380/// To select a bin range along an axis, use TAxis::SetRange, eg; 2381/// h3.GetYaxis()->SetRange(23,56);; 2382///; 2383/// NOTE 1: The generated histogram is named th3name + opt",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:107880,Integrability,integrat,integrated,107880,"Z != nullptr);; 2703 ; 2704 Int_t outmin = outAxis->GetFirst();; 2705 Int_t outmax = outAxis->GetLast();; 2706 // GetFirst, GetLast can return underflow or overflow bins; 2707 // correct for underflow/overflows; 2708 if (useUF && !outAxis->TestBit(TAxis::kAxisRange) ) outmin -= 1;; 2709 if (useOF && !outAxis->TestBit(TAxis::kAxisRange) ) outmax += 1;; 2710 ; 2711 TArrayD & binSumw2 = *(p2->GetBinSumw2());; 2712 if (useWeights && binSumw2.fN <= 0) useWeights = false;; 2713 if (!useWeights) p2->SetBit(TH1::kIsNotW);; 2714 ; 2715 // Call specific method for the projection; 2716 for (ixbin=0;ixbin<=1+projX->GetNbins();ixbin++) {; 2717 if ( (ixbin < ixmin || ixbin > ixmax) && projX->TestBit(TAxis::kAxisRange)) continue;; 2718 for ( iybin=0;iybin<=1+projY->GetNbins();iybin++) {; 2719 if ( (iybin < iymin || iybin > iymax) && projX->TestBit(TAxis::kAxisRange)) continue;; 2720 ; 2721 // profile output bin; 2722 Int_t poutBin = p2->FindBin(projY->GetBinCenter(iybin), projX->GetBinCenter(ixbin));; 2723 if (poutBin <0) continue;; 2724 // loop on the bins to be integrated (outbin should be called inbin); 2725 for (outbin = outmin; outbin <= outmax; outbin++) {; 2726 ; 2727 Int_t bin = GetBin(*refX,*refY,*refZ);; 2728 ; 2729 //DoFillProfileProjection(p2, *projY, *projX, *outAxis, iybin, ixbin, outbin, bin, useWeights);; 2730 ; 2731 Double_t cont = RetrieveBinContent(bin);; 2732 if (!cont) continue;; 2733 ; 2734 Double_t tmp = 0;; 2735 // the following fill update wrongly the fBinSumw2- need to save it before; 2736 if ( useWeights ) tmp = binSumw2.fArray[poutBin];; 2737 p2->Fill( projY->GetBinCenter(iybin) , projX->GetBinCenter(ixbin), outAxis->GetBinCenter(outbin), cont);; 2738 if (useWeights ) binSumw2.fArray[poutBin] = tmp + fSumw2.fArray[bin];; 2739 ; 2740 }; 2741 }; 2742 }; 2743 ; 2744 // recompute statistics for the projected profiles; 2745 // forget about preserving old statistics; 2746 bool resetStats = true;; 2747 Double_t stats[kNstat];; 2748 // reset statistics; 2749 if ",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:109417,Integrability,depend,depending,109417,"/ forget about preserving old statistics; 2746 bool resetStats = true;; 2747 Double_t stats[kNstat];; 2748 // reset statistics; 2749 if (resetStats); 2750 for (Int_t i=0;i<kNstat;i++) stats[i] = 0;; 2751 ; 2752 p2->PutStats(stats);; 2753 Double_t entries = fEntries;; 2754 // recalculate the statistics; 2755 if (resetStats) {; 2756 entries = p2->GetEffectiveEntries();; 2757 if (!useWeights) entries = TMath::Floor( entries + 0.5); // to avoid numerical rounding; 2758 p2->SetEntries( entries );; 2759 }; 2760 ; 2761 p2->SetEntries(entries);; 2762 ; 2763 return p2;; 2764}; 2765 ; 2766 ; 2767////////////////////////////////////////////////////////////////////////////////; 2768/// Project a 3-d histogram into a 2-d profile histograms depending; 2769/// on the option parameter; 2770/// option may contain a combination of the characters x,y,z; 2771/// option = ""xy"" return the x versus y projection into a TProfile2D histogram; 2772/// option = ""yx"" return the y versus x projection into a TProfile2D histogram; 2773/// option = ""xz"" return the x versus z projection into a TProfile2D histogram; 2774/// option = ""zx"" return the z versus x projection into a TProfile2D histogram; 2775/// option = ""yz"" return the y versus z projection into a TProfile2D histogram; 2776/// option = ""zy"" return the z versus y projection into a TProfile2D histogram; 2777/// NB: the notation ""a vs b"" means ""a"" vertical and ""b"" horizontal; 2778///; 2779/// option = ""o"" original axis range of the target axes will be; 2780/// kept, but only bins inside the selected range will be filled.; 2781///; 2782/// The projection is made for the selected bins only.; 2783/// To select a bin range along an axis, use TAxis::SetRange, eg; 2784/// h3.GetYaxis()->SetRange(23,56);; 2785///; 2786/// NOTE 1: The generated histogram is named th3name + ""_p"" + option; 2787/// eg if the TH3* h histogram is named ""myhist"", then; 2788/// h->Project3D(""xy""); produces a TProfile2D histogram named ""myhist_pxy"".; 2789/// The following s",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:196894,Integrability,rout,routine,196894,"axisTAxis * GetYaxis()Definition TH1.h:325; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::GetAxisLabelStatusUInt_t GetAxisLabelStatus() constInternal function used in TH1::Fill to see which axis is full alphanumeric, i.e.Definition TH1.cxx:6675; TH1::fIntegralDouble_t * fIntegral! Integral of bins used by GetRandomDefinition TH1.h:111; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Double_t content)Set bin content see convention for numbering bins in TH1::GetBin In case the bin number is greater th...Definition TH1.cxx:9222; TH1::GetBinLowEdgevirtual Double_t GetBinLowEdge(Int_t bin) constReturn bin lower edge for 1D histogram.Definition TH1.cxx:9152; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::ResetStatsvirtual void ResetStats()Reset the statistics including the number of entries and replace with values calculated from bin cont...Definition TH1.cxx:7902; TH1::SetBuffervirtual void SetBuffer(Int_t buffersize, Option_t *option="""")Set the maximum number of entries to be kept in the buffer.Definition TH1.cxx:8458; TH1::kNstat@ kNstatSize of statistics data (up to TProfile3D)Definition TH1.h:184; TH1::fEntriesDouble_t fEntriesNumber of entries.Definition TH1.h:95; TH1::fZaxisTAxis fZaxisZ axis descriptor.Definition TH1.h:92; TH1::UpdateBinContentvirtual void UpdateBinContent(Int_t bin, Double_t content)Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH1.cxx:9449; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::fXaxisTAxis fXaxisX axis descriptor.Definit",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:208404,Integrability,depend,depending,208404,"H3.cxx:368; TH3::RebinYvirtual TH3 * RebinY(Int_t ngroup=2, const char *newname="""")Rebin only the Y axis see Rebin3D.Definition TH3.cxx:2916; TH3::IntegralAndErrorvirtual Double_t IntegralAndError(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Int_t binz1, Int_t binz2, Double_t &err, Option_t *option="""") constReturn integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2] for a 3-D histogra...Definition TH3.cxx:1421; TH3::ProjectionZvirtual TH1D * ProjectionZ(const char *name=""_pz"", Int_t ixmin=0, Int_t ixmax=-1, Int_t iymin=0, Int_t iymax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D histogram along Z.Definition TH3.cxx:1812; TH3::ProjectionXvirtual TH1D * ProjectionX(const char *name=""_px"", Int_t iymin=0, Int_t iymax=-1, Int_t izmin=0, Int_t izmax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D histogram along X.Definition TH3.cxx:1747; TH3::Project3DProfilevirtual TProfile2D * Project3DProfile(Option_t *option=""xy"") constProject a 3-d histogram into a 2-d profile histograms depending on the option parameter option may co...Definition TH3.cxx:2806; TH3::Classstatic TClass * Class(); TH3::fTsumwz2Double_t fTsumwz2Total Sum of weight*Z*Z.Definition TH3.h:38; TH3::fTsumwxyDouble_t fTsumwxyTotal Sum of weight*X*Y.Definition TH3.h:36; TH3::Project3Dvirtual TH1 * Project3D(Option_t *option=""x"") constProject a 3-d histogram into 1 or 2-d histograms depending on the option parameter,...Definition TH3.cxx:2409; TH3::GetBinWithContent3virtual Double_t GetBinWithContent3(Double_t c, Int_t &binx, Int_t &biny, Int_t &binz, Int_t firstx=0, Int_t lastx=0, Int_t firsty=0, Int_t lasty=0, Int_t firstz=0, Int_t lastz=0, Double_t maxdiff=0) constCompute first cell (binx,biny,binz) in the range [firstx,lastx](firsty,lasty][firstz,...Definition TH3.cxx:1151; TH3::DoFillProfileProjectionvoid DoFillProfileProjection(TProfile2D *p2, const TAxis &a1, const TAxis &a2, const TAxis &a3, Int_t bin1, Int_t bin2, Int_t bin3, Int_t inBin,",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:208778,Integrability,depend,depending,208778,"],[binz1,binz2] for a 3-D histogra...Definition TH3.cxx:1421; TH3::ProjectionZvirtual TH1D * ProjectionZ(const char *name=""_pz"", Int_t ixmin=0, Int_t ixmax=-1, Int_t iymin=0, Int_t iymax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D histogram along Z.Definition TH3.cxx:1812; TH3::ProjectionXvirtual TH1D * ProjectionX(const char *name=""_px"", Int_t iymin=0, Int_t iymax=-1, Int_t izmin=0, Int_t izmax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D histogram along X.Definition TH3.cxx:1747; TH3::Project3DProfilevirtual TProfile2D * Project3DProfile(Option_t *option=""xy"") constProject a 3-d histogram into a 2-d profile histograms depending on the option parameter option may co...Definition TH3.cxx:2806; TH3::Classstatic TClass * Class(); TH3::fTsumwz2Double_t fTsumwz2Total Sum of weight*Z*Z.Definition TH3.h:38; TH3::fTsumwxyDouble_t fTsumwxyTotal Sum of weight*X*Y.Definition TH3.h:36; TH3::Project3Dvirtual TH1 * Project3D(Option_t *option=""x"") constProject a 3-d histogram into 1 or 2-d histograms depending on the option parameter,...Definition TH3.cxx:2409; TH3::GetBinWithContent3virtual Double_t GetBinWithContent3(Double_t c, Int_t &binx, Int_t &biny, Int_t &binz, Int_t firstx=0, Int_t lastx=0, Int_t firsty=0, Int_t lasty=0, Int_t firstz=0, Int_t lastz=0, Double_t maxdiff=0) constCompute first cell (binx,biny,binz) in the range [firstx,lastx](firsty,lasty][firstz,...Definition TH3.cxx:1151; TH3::DoFillProfileProjectionvoid DoFillProfileProjection(TProfile2D *p2, const TAxis &a1, const TAxis &a2, const TAxis &a3, Int_t bin1, Int_t bin2, Int_t bin3, Int_t inBin, Bool_t useWeights) constinternal function to fill the bins of the projected profile 2D histogram called from DoProjectProfile...Definition TH3.cxx:2550; TH3::RebinZvirtual TH3 * RebinZ(Int_t ngroup=2, const char *newname="""")Rebin only the Z axis see Rebin3D.Definition TH3.cxx:2926; TH3::Streamervoid Streamer(TBuffer &) overrideStream an object of class TH3.Definition TH3.cxx:3481",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:213571,Integrability,message,message,213571,"a hash table and a list to store TObject...Definition THashList.h:34; TIterDefinition TCollection.h:235; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::AbstractMethodvoid AbstractMethod(const char *method) constUse this method to implement an ""abstract"" method that you don't want to leave purely abstract.Definition TObject.cxx:1035; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TProfile2DProfile2D histograms are used to display the mean value of Z and its error for each cell in X,...Definition TProfile2D.h:27; TProfile2D::PutStatsvoid PutStats(Double_t *stats) overrideReplace current ",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:214126,Integrability,message,message,214126,"onstUse this method to implement an ""abstract"" method that you don't want to leave purely abstract.Definition TObject.cxx:1035; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TProfile2DProfile2D histograms are used to display the mean value of Z and its error for each cell in X,...Definition TProfile2D.h:27; TProfile2D::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TProfile2D.cxx:1474; TProfile2D::FillInt_t Fill(const Double_t *v)Definition TProfile2D.h:51; TProfile2D::Classstatic TClass * Class(); TProfile2D::Sumw2void Sumw2(Bool_t flag=kTRUE) overrideCreate/Delete structure to store sum of squares of weights per bin.Definition TProfile2D.cxx:2043; TProfile2D::SetBinsvoid SetBins(const Int_t *nbins, const Double_t *range)Definition TProfile2D.h:49; TProfile2D::GetBinSumw2virtual TArrayD * GetBinSumw2()Definition TProfile2D.h:121; TProfile2D::Resetvoid Reset(",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:214319,Integrability,message,message,214319,"inition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TProfile2DProfile2D histograms are used to display the mean value of Z and its error for each cell in X,...Definition TProfile2D.h:27; TProfile2D::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TProfile2D.cxx:1474; TProfile2D::FillInt_t Fill(const Double_t *v)Definition TProfile2D.h:51; TProfile2D::Classstatic TClass * Class(); TProfile2D::Sumw2void Sumw2(Bool_t flag=kTRUE) overrideCreate/Delete structure to store sum of squares of weights per bin.Definition TProfile2D.cxx:2043; TProfile2D::SetBinsvoid SetBins(const Int_t *nbins, const Double_t *range)Definition TProfile2D.h:49; TProfile2D::GetBinSumw2virtual TArrayD * GetBinSumw2()Definition TProfile2D.h:121; TProfile2D::Resetvoid Reset(Option_t *option="""") overrideReset contents of a Profile2D histogram.Definition TProfile2D.cxx:1490; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27;",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:2720,Modifiability,variab,variable,2720,"he 3-D histogram classes derived from the 1-D histogram classes.; 50All operations are supported (fill, fit).; 51Drawing is currently restricted to one single option.; 52A cloud of points is drawn. The number of points is proportional to; 53cell content.; 54 ; 55- TH3C a 3-D histogram with one byte per cell (char). Maximum bin content = 127; 56- TH3S a 3-D histogram with two bytes per cell (short integer). Maximum bin content = 32767; 57- TH3I a 3-D histogram with four bytes per cell (32 bit integer). Maximum bin content = INT_MAX (\ref intmax3 ""*""); 58- TH3L a 3-D histogram with eight bytes per cell (64 bit integer). Maximum bin content = LLONG_MAX (\ref llongmax3 ""**""); 59- TH3F a 3-D histogram with four bytes per cell (float). Maximum precision 7 digits, maximum integer bin content = +/-16777216 (\ref floatmax3 ""***""); 60- TH3D a 3-D histogram with eight bytes per cell (double). Maximum precision 14 digits, maximum integer bin content = +/-9007199254740992 (\ref doublemax3 ""****""); 61 ; 62<sup>; 63\anchor intmax3 (*) INT_MAX = 2147483647 is the [maximum value for a variable of type int.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 64\anchor llongmax3 (**) LLONG_MAX = 9223372036854775807 is the [maximum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 65\anchor floatmax3 (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br>; 66\anchor doublemax3 (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760); 67</sup>; 68*/; 69 ; 70 ; 71////////////////////////////////////////////////////////////////////////////////; 72/// Default constructor.; 73 ; 74TH3::TH3(); 75{; 76 fDimension = 3;; 77 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 78 fTsumwz = fTsumwz2 = fTsumwxz = fT",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:2901,Modifiability,variab,variable,2901,"f points is proportional to; 53cell content.; 54 ; 55- TH3C a 3-D histogram with one byte per cell (char). Maximum bin content = 127; 56- TH3S a 3-D histogram with two bytes per cell (short integer). Maximum bin content = 32767; 57- TH3I a 3-D histogram with four bytes per cell (32 bit integer). Maximum bin content = INT_MAX (\ref intmax3 ""*""); 58- TH3L a 3-D histogram with eight bytes per cell (64 bit integer). Maximum bin content = LLONG_MAX (\ref llongmax3 ""**""); 59- TH3F a 3-D histogram with four bytes per cell (float). Maximum precision 7 digits, maximum integer bin content = +/-16777216 (\ref floatmax3 ""***""); 60- TH3D a 3-D histogram with eight bytes per cell (double). Maximum precision 14 digits, maximum integer bin content = +/-9007199254740992 (\ref doublemax3 ""****""); 61 ; 62<sup>; 63\anchor intmax3 (*) INT_MAX = 2147483647 is the [maximum value for a variable of type int.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 64\anchor llongmax3 (**) LLONG_MAX = 9223372036854775807 is the [maximum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 65\anchor floatmax3 (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br>; 66\anchor doublemax3 (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760); 67</sup>; 68*/; 69 ; 70 ; 71////////////////////////////////////////////////////////////////////////////////; 72/// Default constructor.; 73 ; 74TH3::TH3(); 75{; 76 fDimension = 3;; 77 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 78 fTsumwz = fTsumwz2 = fTsumwxz = fTsumwyz = 0;; 79}; 80 ; 81 ; 82////////////////////////////////////////////////////////////////////////////////; 83/// Constructor for fix bin size 3-D histograms.; 84/// Creates the main histogram structure.; 85",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:5520,Modifiability,variab,variable,5520,"he Y axis first bin; 96/// \param[in] yup upper edge of the Y axis last bin (not included in last bin); 97/// \param[in] nbinsz number of bins along the Z axis; 98/// \param[in] zlow low edge of the Z axis first bin; 99/// \param[in] zup upper edge of the Z axis last bin (not included in last bin); 100 ; 101TH3::TH3(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 102 ,Int_t nbinsy,Double_t ylow,Double_t yup; 103 ,Int_t nbinsz,Double_t zlow,Double_t zup); 104 :TH1(name,title,nbinsx,xlow,xup); 105{; 106 fDimension = 3;; 107 if (nbinsy <= 0) {; 108 Warning(""TH3"",""nbinsy is <=0 - set to nbinsy = 1"");; 109 nbinsy = 1;; 110 }; 111 if (nbinsz <= 0) {; 112 Warning(""TH3"",""nbinsz is <=0 - set to nbinsz = 1"");; 113 nbinsz = 1;; 114 }; 115 fYaxis.Set(nbinsy,ylow,yup);; 116 fZaxis.Set(nbinsz,zlow,zup);; 117 fNcells = (nbinsx+2)*(nbinsy+2)*(nbinsz+2);; 118 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 119 fTsumwz = fTsumwz2 = fTsumwxz = fTsumwyz = 0;; 120}; 121 ; 122 ; 123////////////////////////////////////////////////////////////////////////////////; 124/// Constructor for variable bin size (along X, Y and Z axis) 3-D histograms using input; 125/// arrays of type float.; 126///; 127/// \param[in] name name of histogram (avoid blanks); 128/// \param[in] title histogram title.; 129/// If title is of the form `stringt;stringx;stringy;stringz`; 130/// the histogram title is set to `stringt`,; 131/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 132/// \param[in] nbinsx number of bins; 133/// \param[in] xbins array of low-edges for each bin.; 134/// This is an array of type float and size nbinsx+1; 135/// \param[in] nbinsy number of bins; 136/// \param[in] ybins array of low-edges for each bin.; 137/// This is an array of type float and size nbinsy+1; 138/// \param[in] nbinsz number of bins; 139/// \param[in] zbins array of low-edges for each bin.; 140/// This is an array of type float and size nbinsz+1; 141 ; 142TH3::TH3(const char *name,const",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:7157,Modifiability,variab,variable,7157,"binsx+1; 135/// \param[in] nbinsy number of bins; 136/// \param[in] ybins array of low-edges for each bin.; 137/// This is an array of type float and size nbinsy+1; 138/// \param[in] nbinsz number of bins; 139/// \param[in] zbins array of low-edges for each bin.; 140/// This is an array of type float and size nbinsz+1; 141 ; 142TH3::TH3(const char *name,const char *title,Int_t nbinsx,const Float_t *xbins; 143 ,Int_t nbinsy,const Float_t *ybins; 144 ,Int_t nbinsz,const Float_t *zbins); 145 :TH1(name,title,nbinsx,xbins); 146{; 147 fDimension = 3;; 148 if (nbinsy <= 0) {Warning(""TH3"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 149 if (nbinsz <= 0) nbinsz = 1;; 150 if (ybins) fYaxis.Set(nbinsy,ybins);; 151 else fYaxis.Set(nbinsy,0,1);; 152 if (zbins) fZaxis.Set(nbinsz,zbins);; 153 else fZaxis.Set(nbinsz,0,1);; 154 fNcells = (nbinsx+2)*(nbinsy+2)*(nbinsz+2);; 155 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 156 fTsumwz = fTsumwz2 = fTsumwxz = fTsumwyz = 0;; 157}; 158 ; 159 ; 160////////////////////////////////////////////////////////////////////////////////; 161/// Constructor for variable bin size (along X, Y and Z axis) 3-D histograms using input; 162/// arrays of type double.; 163///; 164/// \param[in] name name of histogram (avoid blanks); 165/// \param[in] title histogram title.; 166/// If title is of the form `stringt;stringx;stringy;stringz`; 167/// the histogram title is set to `stringt`,; 168/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 169/// \param[in] nbinsx number of bins; 170/// \param[in] xbins array of low-edges for each bin.; 171/// This is an array of type double and size nbinsx+1; 172/// \param[in] nbinsy number of bins; 173/// \param[in] ybins array of low-edges for each bin.; 174/// This is an array of type double and size nbinsy+1; 175/// \param[in] nbinsz number of bins; 176/// \param[in] zbins array of low-edges for each bin.; 177/// This is an array of type double and size nbinsz+1; 178 ; 179TH3::TH3(const char *name,cons",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:18861,Modifiability,extend,extended,18861,"// The function returns the corresponding global bin number which has its content; 474/// incremented by w; 475 ; 476Int_t TH3::Fill(const char *namex, const char *namey, const char *namez, Double_t w); 477{; 478 Int_t binx, biny, binz, bin;; 479 fEntries++;; 480 binx = fXaxis.FindBin(namex);; 481 biny = fYaxis.FindBin(namey);; 482 binz = fZaxis.FindBin(namez);; 483 if (binx <0 || biny <0 || binz<0) return -1;; 484 bin = binx + (fXaxis.GetNbins()+2)*(biny + (fYaxis.GetNbins()+2)*binz);; 485 if (!fSumw2.fN && w != 1.0 && !TestBit(TH1::kIsNotW)) Sumw2(); // must be called before AddBinContent; 486 if (fSumw2.fN) fSumw2.fArray[bin] += w*w;; 487 AddBinContent(bin,w);; 488 if (binx == 0 || binx > fXaxis.GetNbins()) return -1;; 489 if (biny == 0 || biny > fYaxis.GetNbins()) return -1;; 490 if (binz == 0 || binz > fZaxis.GetNbins()) return -1;; 491 ; 492 Double_t v = w;; 493 fTsumw += v;; 494 fTsumw2 += v*v;; 495 // skip computation of the statistics along axis that have labels (can be extended and are aphanumeric); 496 UInt_t labelBitMask = GetAxisLabelStatus();; 497 if (labelBitMask != TH1::kAllAxes) {; 498 Double_t x = (labelBitMask & TH1::kXaxis) ? 0 : fXaxis.GetBinCenter(binx);; 499 Double_t y = (labelBitMask & TH1::kYaxis) ? 0 : fYaxis.GetBinCenter(biny);; 500 Double_t z = (labelBitMask & TH1::kZaxis) ? 0 : fZaxis.GetBinCenter(binz);; 501 fTsumwx += v * x;; 502 fTsumwx2 += v * x * x;; 503 fTsumwy += v * y;; 504 fTsumwy2 += v * y * y;; 505 fTsumwxy += v * x * y;; 506 fTsumwz += v * z;; 507 fTsumwz2 += v * z * z;; 508 fTsumwxz += v * x * z;; 509 fTsumwyz += v * y * z;; 510 }; 511 return bin;; 512}; 513 ; 514 ; 515////////////////////////////////////////////////////////////////////////////////; 516/// Increment cell defined by namex,y,namez by a weight w; 517///; 518/// If the weight is not equal to 1, the storage of the sum of squares of; 519/// weights is automatically triggered and the sum of the squares of weights is incremented; 520/// by w^2 in the corresponding ce",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:20947,Modifiability,extend,extended,20947,"h has its content; 522/// incremented by w; 523 ; 524Int_t TH3::Fill(const char *namex, Double_t y, const char *namez, Double_t w); 525{; 526 Int_t binx, biny, binz, bin;; 527 fEntries++;; 528 binx = fXaxis.FindBin(namex);; 529 biny = fYaxis.FindBin(y);; 530 binz = fZaxis.FindBin(namez);; 531 if (binx <0 || biny <0 || binz<0) return -1;; 532 bin = binx + (fXaxis.GetNbins()+2)*(biny + (fYaxis.GetNbins()+2)*binz);; 533 if (!fSumw2.fN && w != 1.0 && !TestBit(TH1::kIsNotW)) Sumw2(); // must be called before AddBinContent; 534 if (fSumw2.fN) fSumw2.fArray[bin] += w*w;; 535 AddBinContent(bin,w);; 536 if (binx == 0 || binx > fXaxis.GetNbins()) return -1;; 537 if (biny == 0 || biny > fYaxis.GetNbins()) {; 538 if (!GetStatOverflowsBehaviour()) return -1;; 539 }; 540 if (binz == 0 || binz > fZaxis.GetNbins()) return -1;; 541 Double_t v = w;; 542 fTsumw += v;; 543 fTsumw2 += v*v;; 544 fTsumwy += v*y;; 545 fTsumwy2 += v*y*y;; 546 // skip computation of the statistics along axis that have labels (can be extended and are aphanumeric); 547 UInt_t labelBitMask = GetAxisLabelStatus();; 548 if (labelBitMask != (TH1::kXaxis | TH1::kZaxis) ) {; 549 Double_t x = (labelBitMask & TH1::kXaxis) ? 0 : fXaxis.GetBinCenter(binx);; 550 Double_t z = (labelBitMask & TH1::kZaxis) ? 0 : fZaxis.GetBinCenter(binz);; 551 fTsumwx += v * x;; 552 fTsumwx2 += v * x * x;; 553 fTsumwxy += v * x * y;; 554 fTsumwz += v * z;; 555 fTsumwz2 += v * z * z;; 556 fTsumwxz += v * x * z;; 557 fTsumwyz += v * y * z;; 558 }; 559 return bin;; 560}; 561 ; 562 ; 563////////////////////////////////////////////////////////////////////////////////; 564/// Increment cell defined by namex,namey,z by a weight w; 565///; 566/// If the weight is not equal to 1, the storage of the sum of squares of; 567/// weights is automatically triggered and the sum of the squares of weights is incremented; 568/// by w^2 in the corresponding cell.; 569/// The function returns the corresponding global bin number which has its content; 570/// incre",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:22917,Modifiability,extend,extended,22917,"g global bin number which has its content; 570/// incremented by w; 571 ; 572Int_t TH3::Fill(const char *namex, const char *namey, Double_t z, Double_t w); 573{; 574 Int_t binx, biny, binz, bin;; 575 fEntries++;; 576 binx = fXaxis.FindBin(namex);; 577 biny = fYaxis.FindBin(namey);; 578 binz = fZaxis.FindBin(z);; 579 if (binx <0 || biny <0 || binz<0) return -1;; 580 bin = binx + (fXaxis.GetNbins()+2)*(biny + (fYaxis.GetNbins()+2)*binz);; 581 if (!fSumw2.fN && w != 1.0 && !TestBit(TH1::kIsNotW)) Sumw2(); // must be called before AddBinContent; 582 if (fSumw2.fN) fSumw2.fArray[bin] += w*w;; 583 AddBinContent(bin,w);; 584 if (binx == 0 || binx > fXaxis.GetNbins()) return -1;; 585 if (biny == 0 || biny > fYaxis.GetNbins()) return -1;; 586 if (binz == 0 || binz > fZaxis.GetNbins()) {; 587 if (!GetStatOverflowsBehaviour()) return -1;; 588 }; 589 Double_t v = w;; 590 fTsumw += v;; 591 fTsumw2 += v*v;; 592 fTsumwz += v*z;; 593 fTsumwz2 += v*z*z;; 594 // skip computation of the statistics along axis that have labels (can be extended and are aphanumeric); 595 UInt_t labelBitMask = GetAxisLabelStatus();; 596 if (labelBitMask != (TH1::kXaxis | TH1::kYaxis)) {; 597 Double_t x = (labelBitMask & TH1::kXaxis) ? 0 : fXaxis.GetBinCenter(binx);; 598 Double_t y = (labelBitMask & TH1::kYaxis) ? 0 : fYaxis.GetBinCenter(biny);; 599 fTsumwx += v * x;; 600 fTsumwx2 += v * x * x;; 601 fTsumwy += v * y;; 602 fTsumwy2 += v * y * y;; 603 fTsumwxy += v * x * y;; 604 fTsumwxz += v * x * z;; 605 fTsumwyz += v * y * z;; 606 }; 607 return bin;; 608}; 609 ; 610 ; 611////////////////////////////////////////////////////////////////////////////////; 612/// Increment cell defined by x,namey,namez by a weight w; 613///; 614/// If the weight is not equal to 1, the storage of the sum of squares of; 615/// weights is automatically triggered and the sum of the squares of weights is incremented; 616/// by w^2 in the corresponding cell.; 617/// The function returns the corresponding global bin number which has i",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:24900,Modifiability,extend,extended,24900,"ts content; 618/// incremented by w; 619 ; 620Int_t TH3::Fill(Double_t x, const char *namey, const char *namez, Double_t w); 621{; 622 Int_t binx, biny, binz, bin;; 623 fEntries++;; 624 binx = fXaxis.FindBin(x);; 625 biny = fYaxis.FindBin(namey);; 626 binz = fZaxis.FindBin(namez);; 627 if (binx <0 || biny <0 || binz<0) return -1;; 628 bin = binx + (fXaxis.GetNbins()+2)*(biny + (fYaxis.GetNbins()+2)*binz);; 629 if (!fSumw2.fN && w != 1.0 && !TestBit(TH1::kIsNotW)) Sumw2(); // must be called before AddBinContent; 630 if (fSumw2.fN) fSumw2.fArray[bin] += w*w;; 631 AddBinContent(bin,w);; 632 if (binx == 0 || binx > fXaxis.GetNbins()) {; 633 if (!GetStatOverflowsBehaviour()) return -1;; 634 }; 635 if (biny == 0 || biny > fYaxis.GetNbins()) return -1;; 636 if (binz == 0 || binz > fZaxis.GetNbins()) return -1;; 637 ; 638 Double_t v = w;; 639 fTsumw += v;; 640 fTsumw2 += v * v;; 641 fTsumwx += v * x;; 642 fTsumwx2 += v * x * x;; 643 // skip computation of the statistics along axis that have labels (can be extended and are aphanumeric); 644 UInt_t labelBitMask = GetAxisLabelStatus();; 645 if (labelBitMask != (TH1::kYaxis | TH1::kZaxis)) {; 646 Double_t y = (labelBitMask & TH1::kYaxis) ? 0 : fYaxis.GetBinCenter(biny);; 647 Double_t z = (labelBitMask & TH1::kZaxis) ? 0 : fZaxis.GetBinCenter(binz);; 648 fTsumwy += v * y;; 649 fTsumwy2 += v * y * y;; 650 fTsumwxy += v * x * y;; 651 fTsumwz += v * z;; 652 fTsumwz2 += v * z * z;; 653 fTsumwxz += v * x * z;; 654 fTsumwyz += v * y * z;; 655 }; 656 return bin;; 657}; 658 ; 659////////////////////////////////////////////////////////////////////////////////; 660/// Increment cell defined by namex , y ,z by a weight w; 661///; 662/// If the weight is not equal to 1, the storage of the sum of squares of; 663/// weights is automatically triggered and the sum of the squares of weights is incremented; 664/// by w^2 in the corresponding cell.; 665/// The function returns the corresponding global bin number which has its content; 666/// incre",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:39731,Modifiability,variab,variable,39731," || lastbin > nbins + 1) lastbin = nbins + 1;; 1000 if (lastbin < firstbin) {firstbin = 0; lastbin = nbins + 1;}; 1001 };; 1002 ; 1003 computeFirstAndLastBin(fXaxis, binminx, binmaxx);; 1004 computeFirstAndLastBin(fYaxis, binminy, binmaxy);; 1005 ; 1006 // limits for the axis of the fit results histograms are different; 1007 auto computeAxisLimits = [](const TAxis & outerAxis, Int_t firstbin, Int_t lastbin,; 1008 Int_t &nBins, Double_t &xMin, Double_t & xMax) {; 1009 Int_t firstOutBin = std::max(firstbin,1);; 1010 Int_t lastOutBin = std::min(lastbin,outerAxis.GetNbins() ) ;; 1011 nBins = lastOutBin-firstOutBin+1;; 1012 xMin = outerAxis.GetBinLowEdge(firstOutBin);; 1013 xMax = outerAxis.GetBinUpEdge(lastOutBin);; 1014 // return first bin that is used in case of variable bin size axis; 1015 return firstOutBin;; 1016 };; 1017 Int_t nbinsX = 0;; 1018 Double_t xMin, xMax = 0;; 1019 Int_t firstBinXaxis = computeAxisLimits(fXaxis, binminx, binmaxx, nbinsX, xMin, xMax);; 1020 Int_t nbinsY = 0;; 1021 Double_t yMin, yMax = 0;; 1022 Int_t firstBinYaxis = computeAxisLimits(fYaxis, binminy, binmaxy, nbinsY, yMin, yMax);; 1023 ; 1024 //default is to fit with a gaussian; 1025 if (f1 == nullptr) {; 1026 f1 = (TF1*)gROOT->GetFunction(""gaus"");; 1027 if (f1 == nullptr) f1 = new TF1(""gaus"",""gaus"",fZaxis.GetXmin(),fZaxis.GetXmax());; 1028 else f1->SetRange(fZaxis.GetXmin(),fZaxis.GetXmax());; 1029 }; 1030 const char *fname = f1->GetName();; 1031 Int_t npar = f1->GetNpar();; 1032 Double_t *parsave = new Double_t[npar];; 1033 f1->GetParameters(parsave);; 1034 ; 1035 //Create one 2-d histogram for each function parameter; 1036 Int_t ipar;; 1037 TString name;; 1038 TString title;; 1039 std::vector<TH1*> hlist(npar+1); // include also chi2 histogram; 1040 const TArrayD *xbins = fXaxis.GetXbins();; 1041 const TArrayD *ybins = fYaxis.GetXbins();; 1042 for (ipar=0;ipar<= npar;ipar++) {; 1043 if (ipar < npar) {; 1044 // fitted parameter histograms; 1045 name = TString::Format(""%s_%d"",GetName(),i",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:43831,Modifiability,inherit,inherit,43831,"owEdge(iby), hlist[0]->GetYaxis()->GetBinUpEdge(iby));; 1093 }; 1094 hpz->Fit(fname,opt.Data());; 1095 Int_t npfits = f1->GetNumberFitPoints();; 1096 if (npfits > npar && npfits >= cut) {; 1097 for (ipar=0;ipar<npar;ipar++) {; 1098 hlist[ipar]->SetBinContent(bin,f1->GetParameter(ipar));; 1099 hlist[ipar]->SetBinError(bin,f1->GetParError(ipar));; 1100 }; 1101 hchi2->SetBinContent(bin,f1->GetChisquare()/(npfits-npar));; 1102 }; 1103 else {; 1104 if (!opt.Contains(""Q"")); 1105 Info(""FitSlicesZ"",""Fitted slice (%d,%d) skipped, the number of fitted points is too small, n=%d"",binx,biny,npfits);; 1106 }; 1107 }; 1108 }; 1109 delete [] parsave;; 1110 delete hpz;; 1111}; 1112 ; 1113 ; 1114////////////////////////////////////////////////////////////////////////////////; 1115/// See comments in TH1::GetBin; 1116 ; 1117Int_t TH3::GetBin(Int_t binx, Int_t biny, Int_t binz) const; 1118{; 1119 Int_t ofy = fYaxis.GetNbins() + 1; // code duplication unavoidable because TH3 does not inherit from TH2; 1120 if (biny < 0) biny = 0;; 1121 if (biny > ofy) biny = ofy;; 1122 ; 1123 Int_t ofz = fZaxis.GetNbins() + 1; // overflow bin; 1124 if (binz < 0) binz = 0;; 1125 if (binz > ofz) binz = ofz;; 1126 ; 1127 return TH1::GetBin(binx) + (fXaxis.GetNbins() + 2) * (biny + (fYaxis.GetNbins() + 2) * binz);; 1128}; 1129 ; 1130 ; 1131////////////////////////////////////////////////////////////////////////////////; 1132/// Compute first cell (binx,biny,binz) in the range [firstx,lastx](firsty,lasty][firstz,lastz] for which; 1133/// diff = abs(cell_content-c) <= maxdiff; 1134/// In case several cells in the specified range with diff=0 are found; 1135/// the first cell found is returned in binx,biny,binz.; 1136/// In case several cells in the specified range satisfy diff <=maxdiff; 1137/// the cell with the smallest difference is returned in binx,biny,binz.; 1138/// In all cases the function returns the smallest difference.; 1139///; 1140/// NOTE1: if firstx <= 0, firstx is set to bin 1; 1141/// if (last",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:79923,Modifiability,extend,extendable,79923,"Fill the projected histogram excluding underflow/overflows if considered in the option; 2004 // if specified in the option (by default they considered); 2005 Double_t totcont = 0;; 2006 ; 2007 Int_t out1min = out1->GetFirst();; 2008 Int_t out1max = out1->GetLast();; 2009 // GetFirst(), GetLast() can return (0,0) when the range bit is set artificially (see TAxis::SetRange); 2010 //if (out1min == 0 && out1max == 0) { out1min = 1; out1max = out1->GetNbins(); }; 2011 // correct for underflow/overflows; 2012 if (useUF && !out1->TestBit(TAxis::kAxisRange) ) out1min -= 1;; 2013 if (useOF && !out1->TestBit(TAxis::kAxisRange) ) out1max += 1;; 2014 Int_t out2min = out2->GetFirst();; 2015 Int_t out2max = out2->GetLast();; 2016// if (out2min == 0 && out2max == 0) { out2min = 1; out2max = out2->GetNbins(); }; 2017 if (useUF && !out2->TestBit(TAxis::kAxisRange) ) out2min -= 1;; 2018 if (useOF && !out2->TestBit(TAxis::kAxisRange) ) out2max += 1;; 2019 ; 2020 // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins; 2021 Bool_t extendable = projX->CanExtend();; 2022 if ( labels && extendable ) h1->GetXaxis()->SetCanExtend(kFALSE);; 2023 for (ixbin=0;ixbin<=1+projX->GetNbins();ixbin++) {; 2024 if ( projX->TestBit(TAxis::kAxisRange) && ( ixbin < ixmin || ixbin > ixmax )) continue;; 2025 ; 2026 Double_t cont = 0;; 2027 Double_t err2 = 0;; 2028 ; 2029 // loop on the bins to be integrated (outbin should be called inbin); 2030 for (out1bin = out1min; out1bin <= out1max; out1bin++) {; 2031 for (out2bin = out2min; out2bin <= out2max; out2bin++) {; 2032 ; 2033 Int_t bin = GetBin(*refX, *refY, *refZ);; 2034 ; 2035 // sum the bin contents and errors if needed; 2036 cont += RetrieveBinContent(bin);; 2037 if (computeErrors) {; 2038 Double_t exyz = GetBinError(bin);; 2039 err2 += exyz*exyz;; 2040 }; 2041 }; 2042 }; 2043 Int_t ix = h1->FindBin( projX->GetBinCenter(ixbin) );; 2044 h1->SetBinContent(ix ,cont);; 2045 if (computeErrors) h1->SetBinErr",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:79957,Modifiability,extend,extendable,79957,"ding underflow/overflows if considered in the option; 2004 // if specified in the option (by default they considered); 2005 Double_t totcont = 0;; 2006 ; 2007 Int_t out1min = out1->GetFirst();; 2008 Int_t out1max = out1->GetLast();; 2009 // GetFirst(), GetLast() can return (0,0) when the range bit is set artificially (see TAxis::SetRange); 2010 //if (out1min == 0 && out1max == 0) { out1min = 1; out1max = out1->GetNbins(); }; 2011 // correct for underflow/overflows; 2012 if (useUF && !out1->TestBit(TAxis::kAxisRange) ) out1min -= 1;; 2013 if (useOF && !out1->TestBit(TAxis::kAxisRange) ) out1max += 1;; 2014 Int_t out2min = out2->GetFirst();; 2015 Int_t out2max = out2->GetLast();; 2016// if (out2min == 0 && out2max == 0) { out2min = 1; out2max = out2->GetNbins(); }; 2017 if (useUF && !out2->TestBit(TAxis::kAxisRange) ) out2min -= 1;; 2018 if (useOF && !out2->TestBit(TAxis::kAxisRange) ) out2max += 1;; 2019 ; 2020 // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins; 2021 Bool_t extendable = projX->CanExtend();; 2022 if ( labels && extendable ) h1->GetXaxis()->SetCanExtend(kFALSE);; 2023 for (ixbin=0;ixbin<=1+projX->GetNbins();ixbin++) {; 2024 if ( projX->TestBit(TAxis::kAxisRange) && ( ixbin < ixmin || ixbin > ixmax )) continue;; 2025 ; 2026 Double_t cont = 0;; 2027 Double_t err2 = 0;; 2028 ; 2029 // loop on the bins to be integrated (outbin should be called inbin); 2030 for (out1bin = out1min; out1bin <= out1max; out1bin++) {; 2031 for (out2bin = out2min; out2bin <= out2max; out2bin++) {; 2032 ; 2033 Int_t bin = GetBin(*refX, *refY, *refZ);; 2034 ; 2035 // sum the bin contents and errors if needed; 2036 cont += RetrieveBinContent(bin);; 2037 if (computeErrors) {; 2038 Double_t exyz = GetBinError(bin);; 2039 err2 += exyz*exyz;; 2040 }; 2041 }; 2042 }; 2043 Int_t ix = h1->FindBin( projX->GetBinCenter(ixbin) );; 2044 h1->SetBinContent(ix ,cont);; 2045 if (computeErrors) h1->SetBinError(ix, TMath::Sqrt(err2) );; 2046 ",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:80008,Modifiability,extend,extendable,80008,"n; 2004 // if specified in the option (by default they considered); 2005 Double_t totcont = 0;; 2006 ; 2007 Int_t out1min = out1->GetFirst();; 2008 Int_t out1max = out1->GetLast();; 2009 // GetFirst(), GetLast() can return (0,0) when the range bit is set artificially (see TAxis::SetRange); 2010 //if (out1min == 0 && out1max == 0) { out1min = 1; out1max = out1->GetNbins(); }; 2011 // correct for underflow/overflows; 2012 if (useUF && !out1->TestBit(TAxis::kAxisRange) ) out1min -= 1;; 2013 if (useOF && !out1->TestBit(TAxis::kAxisRange) ) out1max += 1;; 2014 Int_t out2min = out2->GetFirst();; 2015 Int_t out2max = out2->GetLast();; 2016// if (out2min == 0 && out2max == 0) { out2min = 1; out2max = out2->GetNbins(); }; 2017 if (useUF && !out2->TestBit(TAxis::kAxisRange) ) out2min -= 1;; 2018 if (useOF && !out2->TestBit(TAxis::kAxisRange) ) out2max += 1;; 2019 ; 2020 // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins; 2021 Bool_t extendable = projX->CanExtend();; 2022 if ( labels && extendable ) h1->GetXaxis()->SetCanExtend(kFALSE);; 2023 for (ixbin=0;ixbin<=1+projX->GetNbins();ixbin++) {; 2024 if ( projX->TestBit(TAxis::kAxisRange) && ( ixbin < ixmin || ixbin > ixmax )) continue;; 2025 ; 2026 Double_t cont = 0;; 2027 Double_t err2 = 0;; 2028 ; 2029 // loop on the bins to be integrated (outbin should be called inbin); 2030 for (out1bin = out1min; out1bin <= out1max; out1bin++) {; 2031 for (out2bin = out2min; out2bin <= out2max; out2bin++) {; 2032 ; 2033 Int_t bin = GetBin(*refX, *refY, *refZ);; 2034 ; 2035 // sum the bin contents and errors if needed; 2036 cont += RetrieveBinContent(bin);; 2037 if (computeErrors) {; 2038 Double_t exyz = GetBinError(bin);; 2039 err2 += exyz*exyz;; 2040 }; 2041 }; 2042 }; 2043 Int_t ix = h1->FindBin( projX->GetBinCenter(ixbin) );; 2044 h1->SetBinContent(ix ,cont);; 2045 if (computeErrors) h1->SetBinError(ix, TMath::Sqrt(err2) );; 2046 // sum all content; 2047 totcont += cont;; 2048 ; 2",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:80062,Modifiability,extend,extendable,80062," considered); 2005 Double_t totcont = 0;; 2006 ; 2007 Int_t out1min = out1->GetFirst();; 2008 Int_t out1max = out1->GetLast();; 2009 // GetFirst(), GetLast() can return (0,0) when the range bit is set artificially (see TAxis::SetRange); 2010 //if (out1min == 0 && out1max == 0) { out1min = 1; out1max = out1->GetNbins(); }; 2011 // correct for underflow/overflows; 2012 if (useUF && !out1->TestBit(TAxis::kAxisRange) ) out1min -= 1;; 2013 if (useOF && !out1->TestBit(TAxis::kAxisRange) ) out1max += 1;; 2014 Int_t out2min = out2->GetFirst();; 2015 Int_t out2max = out2->GetLast();; 2016// if (out2min == 0 && out2max == 0) { out2min = 1; out2max = out2->GetNbins(); }; 2017 if (useUF && !out2->TestBit(TAxis::kAxisRange) ) out2min -= 1;; 2018 if (useOF && !out2->TestBit(TAxis::kAxisRange) ) out2max += 1;; 2019 ; 2020 // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins; 2021 Bool_t extendable = projX->CanExtend();; 2022 if ( labels && extendable ) h1->GetXaxis()->SetCanExtend(kFALSE);; 2023 for (ixbin=0;ixbin<=1+projX->GetNbins();ixbin++) {; 2024 if ( projX->TestBit(TAxis::kAxisRange) && ( ixbin < ixmin || ixbin > ixmax )) continue;; 2025 ; 2026 Double_t cont = 0;; 2027 Double_t err2 = 0;; 2028 ; 2029 // loop on the bins to be integrated (outbin should be called inbin); 2030 for (out1bin = out1min; out1bin <= out1max; out1bin++) {; 2031 for (out2bin = out2min; out2bin <= out2max; out2bin++) {; 2032 ; 2033 Int_t bin = GetBin(*refX, *refY, *refZ);; 2034 ; 2035 // sum the bin contents and errors if needed; 2036 cont += RetrieveBinContent(bin);; 2037 if (computeErrors) {; 2038 Double_t exyz = GetBinError(bin);; 2039 err2 += exyz*exyz;; 2040 }; 2041 }; 2042 }; 2043 Int_t ix = h1->FindBin( projX->GetBinCenter(ixbin) );; 2044 h1->SetBinContent(ix ,cont);; 2045 if (computeErrors) h1->SetBinError(ix, TMath::Sqrt(err2) );; 2046 // sum all content; 2047 totcont += cont;; 2048 ; 2049 }; 2050 if ( labels ) h1->GetXaxis()->SetCanExtend",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:81069,Modifiability,extend,extendable,81069,"t is set artificially (see TAxis::SetRange); 2010 //if (out1min == 0 && out1max == 0) { out1min = 1; out1max = out1->GetNbins(); }; 2011 // correct for underflow/overflows; 2012 if (useUF && !out1->TestBit(TAxis::kAxisRange) ) out1min -= 1;; 2013 if (useOF && !out1->TestBit(TAxis::kAxisRange) ) out1max += 1;; 2014 Int_t out2min = out2->GetFirst();; 2015 Int_t out2max = out2->GetLast();; 2016// if (out2min == 0 && out2max == 0) { out2min = 1; out2max = out2->GetNbins(); }; 2017 if (useUF && !out2->TestBit(TAxis::kAxisRange) ) out2min -= 1;; 2018 if (useOF && !out2->TestBit(TAxis::kAxisRange) ) out2max += 1;; 2019 ; 2020 // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins; 2021 Bool_t extendable = projX->CanExtend();; 2022 if ( labels && extendable ) h1->GetXaxis()->SetCanExtend(kFALSE);; 2023 for (ixbin=0;ixbin<=1+projX->GetNbins();ixbin++) {; 2024 if ( projX->TestBit(TAxis::kAxisRange) && ( ixbin < ixmin || ixbin > ixmax )) continue;; 2025 ; 2026 Double_t cont = 0;; 2027 Double_t err2 = 0;; 2028 ; 2029 // loop on the bins to be integrated (outbin should be called inbin); 2030 for (out1bin = out1min; out1bin <= out1max; out1bin++) {; 2031 for (out2bin = out2min; out2bin <= out2max; out2bin++) {; 2032 ; 2033 Int_t bin = GetBin(*refX, *refY, *refZ);; 2034 ; 2035 // sum the bin contents and errors if needed; 2036 cont += RetrieveBinContent(bin);; 2037 if (computeErrors) {; 2038 Double_t exyz = GetBinError(bin);; 2039 err2 += exyz*exyz;; 2040 }; 2041 }; 2042 }; 2043 Int_t ix = h1->FindBin( projX->GetBinCenter(ixbin) );; 2044 h1->SetBinContent(ix ,cont);; 2045 if (computeErrors) h1->SetBinError(ix, TMath::Sqrt(err2) );; 2046 // sum all content; 2047 totcont += cont;; 2048 ; 2049 }; 2050 if ( labels ) h1->GetXaxis()->SetCanExtend(extendable);; 2051 ; 2052 // since we use a combination of fill and SetBinError we need to reset and recalculate the statistics; 2053 // for weighted histograms otherwise sumw2 will be wrong.",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:84322,Modifiability,variab,variable,84322,,MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:102631,Modifiability,variab,variable,102631," 2585 Int_t nx = ixmax-ixmin+1;; 2586 Int_t ny = iymax-iymin+1;; 2587 ; 2588 // Create the projected profiles; 2589 TProfile2D *p2 = nullptr;; 2590 ; 2591 // Create the histogram, either reseting a preexisting one; 2592 // Does an object with the same name exists?; 2593 TObject *p2obj = gROOT->FindObject(name);; 2594 if (p2obj && p2obj->InheritsFrom(TH1::Class())) {; 2595 if (p2obj->IsA() != TProfile2D::Class() ) {; 2596 Error(""DoProjectProfile2D"",""Histogram with name %s must be a TProfile2D and is a %s"",name,p2obj->ClassName());; 2597 return nullptr;; 2598 }; 2599 p2 = (TProfile2D*)p2obj;; 2600 // reset existing profile and re-set bins; 2601 p2->Reset();; 2602 const TArrayD *xbins = projX->GetXbins();; 2603 const TArrayD *ybins = projY->GetXbins();; 2604 if ( originalRange ) {; 2605 p2->SetBins(projY->GetNbins(),projY->GetXmin(),projY->GetXmax(); 2606 ,projX->GetNbins(),projX->GetXmin(),projX->GetXmax());; 2607 // set bins for mixed axis do not exists - need to set afterwards the variable bins; 2608 if (ybins->fN != 0); 2609 p2->GetXaxis()->Set(projY->GetNbins(),&ybins->fArray[iymin-1]);; 2610 if (xbins->fN != 0); 2611 p2->GetYaxis()->Set(projX->GetNbins(),&xbins->fArray[ixmin-1]);; 2612 } else {; 2613 p2->SetBins(ny,projY->GetBinLowEdge(iymin),projY->GetBinUpEdge(iymax); 2614 ,nx,projX->GetBinLowEdge(ixmin),projX->GetBinUpEdge(ixmax));; 2615 if (ybins->fN != 0); 2616 p2->GetXaxis()->Set(ny,&ybins->fArray[iymin-1]);; 2617 if (xbins->fN != 0); 2618 p2->GetYaxis()->Set(nx,&xbins->fArray[ixmin-1]);; 2619 }; 2620 }; 2621 ; 2622 if (!p2) {; 2623 const TArrayD *xbins = projX->GetXbins();; 2624 const TArrayD *ybins = projY->GetXbins();; 2625 if ( originalRange ) {; 2626 if (xbins->fN == 0 && ybins->fN == 0) {; 2627 p2 = new TProfile2D(name,title,projY->GetNbins(),projY->GetXmin(),projY->GetXmax(); 2628 ,projX->GetNbins(),projX->GetXmin(),projX->GetXmax());; 2629 } else if (ybins->fN == 0) {; 2630 p2 = new TProfile2D(name,title,projY->GetNbins(),projY->GetXmin(),projY->GetX",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:121488,Modifiability,variab,variable,121488,"();; 3049 Style_t yTitleFont = fYaxis.GetTitleFont();; 3050 // save the TAttAxis members (reset by SetBins) for z axis; 3051 Int_t nZdivisions = fZaxis.GetNdivisions();; 3052 Color_t zAxisColor = fZaxis.GetAxisColor();; 3053 Color_t zLabelColor = fZaxis.GetLabelColor();; 3054 Style_t zLabelFont = fZaxis.GetLabelFont();; 3055 Float_t zLabelOffset = fZaxis.GetLabelOffset();; 3056 Float_t zLabelSize = fZaxis.GetLabelSize();; 3057 Float_t zTickLength = fZaxis.GetTickLength();; 3058 Float_t zTitleOffset = fZaxis.GetTitleOffset();; 3059 Float_t zTitleSize = fZaxis.GetTitleSize();; 3060 Color_t zTitleColor = fZaxis.GetTitleColor();; 3061 Style_t zTitleFont = fZaxis.GetTitleFont();; 3062 ; 3063 // copy merged bin contents (ignore under/overflows); 3064 if (nxgroup != 1 || nygroup != 1 || nzgroup != 1) {; 3065 if (fXaxis.GetXbins()->GetSize() > 0 || fYaxis.GetXbins()->GetSize() > 0 || fZaxis.GetXbins()->GetSize() > 0) {; 3066 // variable bin sizes in x or y, don't treat both cases separately; 3067 Double_t *xbins = new Double_t[newxbins+1];; 3068 for (i = 0; i <= newxbins; ++i) xbins[i] = fXaxis.GetBinLowEdge(1+i*nxgroup);; 3069 Double_t *ybins = new Double_t[newybins+1];; 3070 for (i = 0; i <= newybins; ++i) ybins[i] = fYaxis.GetBinLowEdge(1+i*nygroup);; 3071 Double_t *zbins = new Double_t[newzbins+1];; 3072 for (i = 0; i <= newzbins; ++i) zbins[i] = fZaxis.GetBinLowEdge(1+i*nzgroup);; 3073 hnew->SetBins(newxbins,xbins, newybins, ybins, newzbins, zbins);//changes also errors array (if any); 3074 delete [] xbins;; 3075 delete [] ybins;; 3076 delete [] zbins;; 3077 } else {; 3078 hnew->SetBins(newxbins, xmin, xmax, newybins, ymin, ymax, newzbins, zmin, zmax);//changes also errors array; 3079 }; 3080 ; 3081 Double_t binContent, binSumw2;; 3082 Int_t oldxbin = 1;; 3083 Int_t oldybin = 1;; 3084 Int_t oldzbin = 1;; 3085 Int_t bin;; 3086 for (xbin = 1; xbin <= newxbins; xbin++) {; 3087 oldybin=1;; 3088 oldzbin=1;; 3089 for (ybin = 1; ybin <= newybins; ybin++) {; 3090 oldzbin=1;; 3",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:139202,Modifiability,variab,variable,139202,"________________________________________________; 3520// TH3C methods; 3521// TH3C a 3-D histogram with one byte per cell (char); 3522//______________________________________________________________________________; 3523 ; 3524ClassImp(TH3C);; 3525 ; 3526 ; 3527////////////////////////////////////////////////////////////////////////////////; 3528/// Constructor.; 3529 ; 3530TH3C::TH3C(); 3531{; 3532 SetBinsLength(27);; 3533 if (fgDefaultSumw2) Sumw2();; 3534}; 3535 ; 3536 ; 3537////////////////////////////////////////////////////////////////////////////////; 3538/// Destructor.; 3539 ; 3540TH3C::~TH3C(); 3541{; 3542}; 3543 ; 3544 ; 3545////////////////////////////////////////////////////////////////////////////////; 3546/// Constructor for fix bin size 3-D histograms; 3547/// (see TH3::TH3 for explanation of parameters); 3548 ; 3549TH3C::TH3C(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 3550 ,Int_t nbinsy,Double_t ylow,Double_t yup; 3551 ,Int_t nbinsz,Double_t zlow,Double_t zup); 3552 :TH3(name,title,nbinsx,xlow,xup,nbinsy,ylow,yup,nbinsz,zlow,zup); 3553{; 3554 TArrayC::Set(fNcells);; 3555 if (fgDefaultSumw2) Sumw2();; 3556 ; 3557 if (xlow >= xup || ylow >= yup || zlow >= zup) SetBuffer(fgBufferSize);; 3558}; 3559 ; 3560 ; 3561////////////////////////////////////////////////////////////////////////////////; 3562/// Constructor for variable bin size 3-D histograms.; 3563/// (see TH3::TH3 for explanation of parameters); 3564 ; 3565TH3C::TH3C(const char *name,const char *title,Int_t nbinsx,const Float_t *xbins; 3566 ,Int_t nbinsy,const Float_t *ybins; 3567 ,Int_t nbinsz,const Float_t *zbins); 3568 :TH3(name,title,nbinsx,xbins,nbinsy,ybins,nbinsz,zbins); 3569{; 3570 TArrayC::Set(fNcells);; 3571 if (fgDefaultSumw2) Sumw2();; 3572}; 3573 ; 3574 ; 3575////////////////////////////////////////////////////////////////////////////////; 3576/// Constructor for variable bin size 3-D histograms.; 3577/// (see TH3::TH3 for explanation of parameters); ",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:139730,Modifiability,variab,variable,139730,"///////////////////////////////////////////; 3546/// Constructor for fix bin size 3-D histograms; 3547/// (see TH3::TH3 for explanation of parameters); 3548 ; 3549TH3C::TH3C(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 3550 ,Int_t nbinsy,Double_t ylow,Double_t yup; 3551 ,Int_t nbinsz,Double_t zlow,Double_t zup); 3552 :TH3(name,title,nbinsx,xlow,xup,nbinsy,ylow,yup,nbinsz,zlow,zup); 3553{; 3554 TArrayC::Set(fNcells);; 3555 if (fgDefaultSumw2) Sumw2();; 3556 ; 3557 if (xlow >= xup || ylow >= yup || zlow >= zup) SetBuffer(fgBufferSize);; 3558}; 3559 ; 3560 ; 3561////////////////////////////////////////////////////////////////////////////////; 3562/// Constructor for variable bin size 3-D histograms.; 3563/// (see TH3::TH3 for explanation of parameters); 3564 ; 3565TH3C::TH3C(const char *name,const char *title,Int_t nbinsx,const Float_t *xbins; 3566 ,Int_t nbinsy,const Float_t *ybins; 3567 ,Int_t nbinsz,const Float_t *zbins); 3568 :TH3(name,title,nbinsx,xbins,nbinsy,ybins,nbinsz,zbins); 3569{; 3570 TArrayC::Set(fNcells);; 3571 if (fgDefaultSumw2) Sumw2();; 3572}; 3573 ; 3574 ; 3575////////////////////////////////////////////////////////////////////////////////; 3576/// Constructor for variable bin size 3-D histograms.; 3577/// (see TH3::TH3 for explanation of parameters); 3578 ; 3579TH3C::TH3C(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 3580 ,Int_t nbinsy,const Double_t *ybins; 3581 ,Int_t nbinsz,const Double_t *zbins); 3582 :TH3(name,title,nbinsx,xbins,nbinsy,ybins,nbinsz,zbins); 3583{; 3584 TArrayC::Set(fNcells);; 3585 if (fgDefaultSumw2) Sumw2();; 3586}; 3587 ; 3588 ; 3589////////////////////////////////////////////////////////////////////////////////; 3590/// Copy constructor.; 3591/// The list of functions is not copied. (Use Clone() if needed); 3592 ; 3593TH3C::TH3C(const TH3C &h3c) : TH3(), TArrayC(); 3594{; 3595 h3c.TH3C::Copy(*this);; 3596}; 3597 ; 3598 ; 3599/////////////////////////////////////////////",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:148011,Modifiability,variab,variable,148011,"o bytes per cell (short integer); 3791//______________________________________________________________________________; 3792 ; 3793ClassImp(TH3S);; 3794 ; 3795 ; 3796////////////////////////////////////////////////////////////////////////////////; 3797/// Constructor.; 3798 ; 3799TH3S::TH3S(); 3800{; 3801 SetBinsLength(27);; 3802 if (fgDefaultSumw2) Sumw2();; 3803}; 3804 ; 3805 ; 3806////////////////////////////////////////////////////////////////////////////////; 3807/// Destructor.; 3808 ; 3809TH3S::~TH3S(); 3810{; 3811}; 3812 ; 3813 ; 3814////////////////////////////////////////////////////////////////////////////////; 3815/// Constructor for fix bin size 3-D histograms.; 3816/// (see TH3::TH3 for explanation of parameters); 3817 ; 3818TH3S::TH3S(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 3819 ,Int_t nbinsy,Double_t ylow,Double_t yup; 3820 ,Int_t nbinsz,Double_t zlow,Double_t zup); 3821 :TH3(name,title,nbinsx,xlow,xup,nbinsy,ylow,yup,nbinsz,zlow,zup); 3822{; 3823 TH3S::Set(fNcells);; 3824 if (fgDefaultSumw2) Sumw2();; 3825 ; 3826 if (xlow >= xup || ylow >= yup || zlow >= zup) SetBuffer(fgBufferSize);; 3827}; 3828 ; 3829 ; 3830////////////////////////////////////////////////////////////////////////////////; 3831/// Constructor for variable bin size 3-D histograms.; 3832/// (see TH3::TH3 for explanation of parameters); 3833 ; 3834TH3S::TH3S(const char *name,const char *title,Int_t nbinsx,const Float_t *xbins; 3835 ,Int_t nbinsy,const Float_t *ybins; 3836 ,Int_t nbinsz,const Float_t *zbins); 3837 :TH3(name,title,nbinsx,xbins,nbinsy,ybins,nbinsz,zbins); 3838{; 3839 TH3S::Set(fNcells);; 3840 if (fgDefaultSumw2) Sumw2();; 3841}; 3842 ; 3843 ; 3844////////////////////////////////////////////////////////////////////////////////; 3845/// Constructor for variable bin size 3-D histograms.; 3846/// (see TH3::TH3 for explanation of parameters); 3847 ; 3848TH3S::TH3S(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 3849 ,In",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:148536,Modifiability,variab,variable,148536,"///////////////////////////////////////////////; 3815/// Constructor for fix bin size 3-D histograms.; 3816/// (see TH3::TH3 for explanation of parameters); 3817 ; 3818TH3S::TH3S(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 3819 ,Int_t nbinsy,Double_t ylow,Double_t yup; 3820 ,Int_t nbinsz,Double_t zlow,Double_t zup); 3821 :TH3(name,title,nbinsx,xlow,xup,nbinsy,ylow,yup,nbinsz,zlow,zup); 3822{; 3823 TH3S::Set(fNcells);; 3824 if (fgDefaultSumw2) Sumw2();; 3825 ; 3826 if (xlow >= xup || ylow >= yup || zlow >= zup) SetBuffer(fgBufferSize);; 3827}; 3828 ; 3829 ; 3830////////////////////////////////////////////////////////////////////////////////; 3831/// Constructor for variable bin size 3-D histograms.; 3832/// (see TH3::TH3 for explanation of parameters); 3833 ; 3834TH3S::TH3S(const char *name,const char *title,Int_t nbinsx,const Float_t *xbins; 3835 ,Int_t nbinsy,const Float_t *ybins; 3836 ,Int_t nbinsz,const Float_t *zbins); 3837 :TH3(name,title,nbinsx,xbins,nbinsy,ybins,nbinsz,zbins); 3838{; 3839 TH3S::Set(fNcells);; 3840 if (fgDefaultSumw2) Sumw2();; 3841}; 3842 ; 3843 ; 3844////////////////////////////////////////////////////////////////////////////////; 3845/// Constructor for variable bin size 3-D histograms.; 3846/// (see TH3::TH3 for explanation of parameters); 3847 ; 3848TH3S::TH3S(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 3849 ,Int_t nbinsy,const Double_t *ybins; 3850 ,Int_t nbinsz,const Double_t *zbins); 3851 :TH3(name,title,nbinsx,xbins,nbinsy,ybins,nbinsz,zbins); 3852{; 3853 TH3S::Set(fNcells);; 3854 if (fgDefaultSumw2) Sumw2();; 3855}; 3856 ; 3857 ; 3858////////////////////////////////////////////////////////////////////////////////; 3859/// Copy Constructor.; 3860/// The list of functions is not copied. (Use Clone() if needed); 3861 ; 3862TH3S::TH3S(const TH3S &h3s) : TH3(), TArrayS(); 3863{; 3864 h3s.TH3S::Copy(*this);; 3865}; 3866 ; 3867 ; 3868//////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:155235,Modifiability,variab,variable,155235,"////////////////////////////////////////////////////; 4047/// Destructor.; 4048 ; 4049TH3I::~TH3I(); 4050{; 4051}; 4052 ; 4053 ; 4054////////////////////////////////////////////////////////////////////////////////; 4055/// Constructor for fix bin size 3-D histograms; 4056/// (see TH3::TH3 for explanation of parameters); 4057 ; 4058TH3I::TH3I(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 4059 ,Int_t nbinsy,Double_t ylow,Double_t yup; 4060 ,Int_t nbinsz,Double_t zlow,Double_t zup); 4061 :TH3(name,title,nbinsx,xlow,xup,nbinsy,ylow,yup,nbinsz,zlow,zup); 4062{; 4063 TH3I::Set(fNcells);; 4064 if (fgDefaultSumw2) Sumw2();; 4065 ; 4066 if (xlow >= xup || ylow >= yup || zlow >= zup) SetBuffer(fgBufferSize);; 4067}; 4068 ; 4069 ; 4070////////////////////////////////////////////////////////////////////////////////; 4071/// Constructor for variable bin size 3-D histograms; 4072/// (see TH3::TH3 for explanation of parameters); 4073 ; 4074TH3I::TH3I(const char *name,const char *title,Int_t nbinsx,const Float_t *xbins; 4075 ,Int_t nbinsy,const Float_t *ybins; 4076 ,Int_t nbinsz,const Float_t *zbins); 4077 :TH3(name,title,nbinsx,xbins,nbinsy,ybins,nbinsz,zbins); 4078{; 4079 TArrayI::Set(fNcells);; 4080 if (fgDefaultSumw2) Sumw2();; 4081}; 4082 ; 4083 ; 4084////////////////////////////////////////////////////////////////////////////////; 4085/// Constructor for variable bin size 3-D histograms; 4086/// (see TH3::TH3 for explanation of parameters); 4087 ; 4088TH3I::TH3I(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 4089 ,Int_t nbinsy,const Double_t *ybins; 4090 ,Int_t nbinsz,const Double_t *zbins); 4091 :TH3(name,title,nbinsx,xbins,nbinsy,ybins,nbinsz,zbins); 4092{; 4093 TArrayI::Set(fNcells);; 4094 if (fgDefaultSumw2) Sumw2();; 4095}; 4096 ; 4097 ; 4098////////////////////////////////////////////////////////////////////////////////; 4099/// Copy constructor.; 4100/// The list of functions is not copied. (Use Clone() if needed); 4",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:155762,Modifiability,variab,variable,155762,"////////////////////////////////////////////////////; 4047/// Destructor.; 4048 ; 4049TH3I::~TH3I(); 4050{; 4051}; 4052 ; 4053 ; 4054////////////////////////////////////////////////////////////////////////////////; 4055/// Constructor for fix bin size 3-D histograms; 4056/// (see TH3::TH3 for explanation of parameters); 4057 ; 4058TH3I::TH3I(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 4059 ,Int_t nbinsy,Double_t ylow,Double_t yup; 4060 ,Int_t nbinsz,Double_t zlow,Double_t zup); 4061 :TH3(name,title,nbinsx,xlow,xup,nbinsy,ylow,yup,nbinsz,zlow,zup); 4062{; 4063 TH3I::Set(fNcells);; 4064 if (fgDefaultSumw2) Sumw2();; 4065 ; 4066 if (xlow >= xup || ylow >= yup || zlow >= zup) SetBuffer(fgBufferSize);; 4067}; 4068 ; 4069 ; 4070////////////////////////////////////////////////////////////////////////////////; 4071/// Constructor for variable bin size 3-D histograms; 4072/// (see TH3::TH3 for explanation of parameters); 4073 ; 4074TH3I::TH3I(const char *name,const char *title,Int_t nbinsx,const Float_t *xbins; 4075 ,Int_t nbinsy,const Float_t *ybins; 4076 ,Int_t nbinsz,const Float_t *zbins); 4077 :TH3(name,title,nbinsx,xbins,nbinsy,ybins,nbinsz,zbins); 4078{; 4079 TArrayI::Set(fNcells);; 4080 if (fgDefaultSumw2) Sumw2();; 4081}; 4082 ; 4083 ; 4084////////////////////////////////////////////////////////////////////////////////; 4085/// Constructor for variable bin size 3-D histograms; 4086/// (see TH3::TH3 for explanation of parameters); 4087 ; 4088TH3I::TH3I(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 4089 ,Int_t nbinsy,const Double_t *ybins; 4090 ,Int_t nbinsz,const Double_t *zbins); 4091 :TH3(name,title,nbinsx,xbins,nbinsy,ybins,nbinsz,zbins); 4092{; 4093 TArrayI::Set(fNcells);; 4094 if (fgDefaultSumw2) Sumw2();; 4095}; 4096 ; 4097 ; 4098////////////////////////////////////////////////////////////////////////////////; 4099/// Copy constructor.; 4100/// The list of functions is not copied. (Use Clone() if needed); 4",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:161507,Modifiability,variab,variable,161507,"//////////////////////////////////////////////////; 4254/// Destructor.; 4255 ; 4256TH3L::~TH3L(); 4257{; 4258}; 4259 ; 4260 ; 4261////////////////////////////////////////////////////////////////////////////////; 4262/// Constructor for fix bin size 3-D histograms; 4263/// (see TH3::TH3 for explanation of parameters); 4264 ; 4265TH3L::TH3L(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 4266 ,Int_t nbinsy,Double_t ylow,Double_t yup; 4267 ,Int_t nbinsz,Double_t zlow,Double_t zup); 4268 :TH3(name,title,nbinsx,xlow,xup,nbinsy,ylow,yup,nbinsz,zlow,zup); 4269{; 4270 TH3L::Set(fNcells);; 4271 if (fgDefaultSumw2) Sumw2();; 4272 ; 4273 if (xlow >= xup || ylow >= yup || zlow >= zup) SetBuffer(fgBufferSize);; 4274}; 4275 ; 4276 ; 4277////////////////////////////////////////////////////////////////////////////////; 4278/// Constructor for variable bin size 3-D histograms; 4279/// (see TH3::TH3 for explanation of parameters); 4280 ; 4281TH3L::TH3L(const char *name,const char *title,Int_t nbinsx,const Float_t *xbins; 4282 ,Int_t nbinsy,const Float_t *ybins; 4283 ,Int_t nbinsz,const Float_t *zbins); 4284 :TH3(name,title,nbinsx,xbins,nbinsy,ybins,nbinsz,zbins); 4285{; 4286 TArrayL64::Set(fNcells);; 4287 if (fgDefaultSumw2) Sumw2();; 4288}; 4289 ; 4290 ; 4291////////////////////////////////////////////////////////////////////////////////; 4292/// Constructor for variable bin size 3-D histograms; 4293/// (see TH3::TH3 for explanation of parameters); 4294 ; 4295TH3L::TH3L(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 4296 ,Int_t nbinsy,const Double_t *ybins; 4297 ,Int_t nbinsz,const Double_t *zbins); 4298 :TH3(name,title,nbinsx,xbins,nbinsy,ybins,nbinsz,zbins); 4299{; 4300 TArrayL64::Set(fNcells);; 4301 if (fgDefaultSumw2) Sumw2();; 4302}; 4303 ; 4304 ; 4305////////////////////////////////////////////////////////////////////////////////; 4306/// Copy constructor.; 4307/// The list of functions is not copied. (Use Clone() if needed);",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:162036,Modifiability,variab,variable,162036,"//////////////////////////////////////////////////; 4254/// Destructor.; 4255 ; 4256TH3L::~TH3L(); 4257{; 4258}; 4259 ; 4260 ; 4261////////////////////////////////////////////////////////////////////////////////; 4262/// Constructor for fix bin size 3-D histograms; 4263/// (see TH3::TH3 for explanation of parameters); 4264 ; 4265TH3L::TH3L(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 4266 ,Int_t nbinsy,Double_t ylow,Double_t yup; 4267 ,Int_t nbinsz,Double_t zlow,Double_t zup); 4268 :TH3(name,title,nbinsx,xlow,xup,nbinsy,ylow,yup,nbinsz,zlow,zup); 4269{; 4270 TH3L::Set(fNcells);; 4271 if (fgDefaultSumw2) Sumw2();; 4272 ; 4273 if (xlow >= xup || ylow >= yup || zlow >= zup) SetBuffer(fgBufferSize);; 4274}; 4275 ; 4276 ; 4277////////////////////////////////////////////////////////////////////////////////; 4278/// Constructor for variable bin size 3-D histograms; 4279/// (see TH3::TH3 for explanation of parameters); 4280 ; 4281TH3L::TH3L(const char *name,const char *title,Int_t nbinsx,const Float_t *xbins; 4282 ,Int_t nbinsy,const Float_t *ybins; 4283 ,Int_t nbinsz,const Float_t *zbins); 4284 :TH3(name,title,nbinsx,xbins,nbinsy,ybins,nbinsz,zbins); 4285{; 4286 TArrayL64::Set(fNcells);; 4287 if (fgDefaultSumw2) Sumw2();; 4288}; 4289 ; 4290 ; 4291////////////////////////////////////////////////////////////////////////////////; 4292/// Constructor for variable bin size 3-D histograms; 4293/// (see TH3::TH3 for explanation of parameters); 4294 ; 4295TH3L::TH3L(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 4296 ,Int_t nbinsy,const Double_t *ybins; 4297 ,Int_t nbinsz,const Double_t *zbins); 4298 :TH3(name,title,nbinsx,xbins,nbinsy,ybins,nbinsz,zbins); 4299{; 4300 TArrayL64::Set(fNcells);; 4301 if (fgDefaultSumw2) Sumw2();; 4302}; 4303 ; 4304 ; 4305////////////////////////////////////////////////////////////////////////////////; 4306/// Copy constructor.; 4307/// The list of functions is not copied. (Use Clone() if needed);",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:167867,Modifiability,variab,variable,167867,"//////////////////////////////////////////////////; 4461/// Destructor.; 4462 ; 4463TH3F::~TH3F(); 4464{; 4465}; 4466 ; 4467 ; 4468////////////////////////////////////////////////////////////////////////////////; 4469/// Constructor for fix bin size 3-D histograms; 4470/// (see TH3::TH3 for explanation of parameters); 4471 ; 4472TH3F::TH3F(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 4473 ,Int_t nbinsy,Double_t ylow,Double_t yup; 4474 ,Int_t nbinsz,Double_t zlow,Double_t zup); 4475 :TH3(name,title,nbinsx,xlow,xup,nbinsy,ylow,yup,nbinsz,zlow,zup); 4476{; 4477 TArrayF::Set(fNcells);; 4478 if (fgDefaultSumw2) Sumw2();; 4479 ; 4480 if (xlow >= xup || ylow >= yup || zlow >= zup) SetBuffer(fgBufferSize);; 4481}; 4482 ; 4483 ; 4484////////////////////////////////////////////////////////////////////////////////; 4485/// Constructor for variable bin size 3-D histograms; 4486/// (see TH3::TH3 for explanation of parameters); 4487 ; 4488TH3F::TH3F(const char *name,const char *title,Int_t nbinsx,const Float_t *xbins; 4489 ,Int_t nbinsy,const Float_t *ybins; 4490 ,Int_t nbinsz,const Float_t *zbins); 4491 :TH3(name,title,nbinsx,xbins,nbinsy,ybins,nbinsz,zbins); 4492{; 4493 TArrayF::Set(fNcells);; 4494 if (fgDefaultSumw2) Sumw2();; 4495}; 4496 ; 4497 ; 4498////////////////////////////////////////////////////////////////////////////////; 4499/// Constructor for variable bin size 3-D histograms; 4500/// (see TH3::TH3 for explanation of parameters); 4501 ; 4502TH3F::TH3F(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 4503 ,Int_t nbinsy,const Double_t *ybins; 4504 ,Int_t nbinsz,const Double_t *zbins); 4505 :TH3(name,title,nbinsx,xbins,nbinsy,ybins,nbinsz,zbins); 4506{; 4507 TArrayF::Set(fNcells);; 4508 if (fgDefaultSumw2) Sumw2();; 4509}; 4510 ; 4511 ; 4512////////////////////////////////////////////////////////////////////////////////; 4513/// Copy constructor.; 4514/// The list of functions is not copied. (Use Clone() if needed);",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:168394,Modifiability,variab,variable,168394,"//////////////////////////////////////////////////; 4461/// Destructor.; 4462 ; 4463TH3F::~TH3F(); 4464{; 4465}; 4466 ; 4467 ; 4468////////////////////////////////////////////////////////////////////////////////; 4469/// Constructor for fix bin size 3-D histograms; 4470/// (see TH3::TH3 for explanation of parameters); 4471 ; 4472TH3F::TH3F(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 4473 ,Int_t nbinsy,Double_t ylow,Double_t yup; 4474 ,Int_t nbinsz,Double_t zlow,Double_t zup); 4475 :TH3(name,title,nbinsx,xlow,xup,nbinsy,ylow,yup,nbinsz,zlow,zup); 4476{; 4477 TArrayF::Set(fNcells);; 4478 if (fgDefaultSumw2) Sumw2();; 4479 ; 4480 if (xlow >= xup || ylow >= yup || zlow >= zup) SetBuffer(fgBufferSize);; 4481}; 4482 ; 4483 ; 4484////////////////////////////////////////////////////////////////////////////////; 4485/// Constructor for variable bin size 3-D histograms; 4486/// (see TH3::TH3 for explanation of parameters); 4487 ; 4488TH3F::TH3F(const char *name,const char *title,Int_t nbinsx,const Float_t *xbins; 4489 ,Int_t nbinsy,const Float_t *ybins; 4490 ,Int_t nbinsz,const Float_t *zbins); 4491 :TH3(name,title,nbinsx,xbins,nbinsy,ybins,nbinsz,zbins); 4492{; 4493 TArrayF::Set(fNcells);; 4494 if (fgDefaultSumw2) Sumw2();; 4495}; 4496 ; 4497 ; 4498////////////////////////////////////////////////////////////////////////////////; 4499/// Constructor for variable bin size 3-D histograms; 4500/// (see TH3::TH3 for explanation of parameters); 4501 ; 4502TH3F::TH3F(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 4503 ,Int_t nbinsy,const Double_t *ybins; 4504 ,Int_t nbinsz,const Double_t *zbins); 4505 :TH3(name,title,nbinsx,xbins,nbinsy,ybins,nbinsz,zbins); 4506{; 4507 TArrayF::Set(fNcells);; 4508 if (fgDefaultSumw2) Sumw2();; 4509}; 4510 ; 4511 ; 4512////////////////////////////////////////////////////////////////////////////////; 4513/// Copy constructor.; 4514/// The list of functions is not copied. (Use Clone() if needed);",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:174286,Modifiability,variab,variable,174286,"//////////////////////////////////////////////////; 4677/// Destructor.; 4678 ; 4679TH3D::~TH3D(); 4680{; 4681}; 4682 ; 4683 ; 4684////////////////////////////////////////////////////////////////////////////////; 4685/// Constructor for fix bin size 3-D histograms; 4686/// (see TH3::TH3 for explanation of parameters); 4687 ; 4688TH3D::TH3D(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 4689 ,Int_t nbinsy,Double_t ylow,Double_t yup; 4690 ,Int_t nbinsz,Double_t zlow,Double_t zup); 4691 :TH3(name,title,nbinsx,xlow,xup,nbinsy,ylow,yup,nbinsz,zlow,zup); 4692{; 4693 TArrayD::Set(fNcells);; 4694 if (fgDefaultSumw2) Sumw2();; 4695 ; 4696 if (xlow >= xup || ylow >= yup || zlow >= zup) SetBuffer(fgBufferSize);; 4697}; 4698 ; 4699 ; 4700////////////////////////////////////////////////////////////////////////////////; 4701/// Constructor for variable bin size 3-D histograms; 4702/// (see TH3::TH3 for explanation of parameters); 4703 ; 4704TH3D::TH3D(const char *name,const char *title,Int_t nbinsx,const Float_t *xbins; 4705 ,Int_t nbinsy,const Float_t *ybins; 4706 ,Int_t nbinsz,const Float_t *zbins); 4707 :TH3(name,title,nbinsx,xbins,nbinsy,ybins,nbinsz,zbins); 4708{; 4709 TArrayD::Set(fNcells);; 4710 if (fgDefaultSumw2) Sumw2();; 4711}; 4712 ; 4713 ; 4714////////////////////////////////////////////////////////////////////////////////; 4715/// Constructor for variable bin size 3-D histograms; 4716/// (see TH3::TH3 for explanation of parameters); 4717 ; 4718TH3D::TH3D(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 4719 ,Int_t nbinsy,const Double_t *ybins; 4720 ,Int_t nbinsz,const Double_t *zbins); 4721 :TH3(name,title,nbinsx,xbins,nbinsy,ybins,nbinsz,zbins); 4722{; 4723 TArrayD::Set(fNcells);; 4724 if (fgDefaultSumw2) Sumw2();; 4725}; 4726 ; 4727 ; 4728////////////////////////////////////////////////////////////////////////////////; 4729/// Copy constructor.; 4730/// The list of functions is not copied. (Use Clone() if needed);",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:174813,Modifiability,variab,variable,174813,"//////////////////////////////////////////////////; 4677/// Destructor.; 4678 ; 4679TH3D::~TH3D(); 4680{; 4681}; 4682 ; 4683 ; 4684////////////////////////////////////////////////////////////////////////////////; 4685/// Constructor for fix bin size 3-D histograms; 4686/// (see TH3::TH3 for explanation of parameters); 4687 ; 4688TH3D::TH3D(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 4689 ,Int_t nbinsy,Double_t ylow,Double_t yup; 4690 ,Int_t nbinsz,Double_t zlow,Double_t zup); 4691 :TH3(name,title,nbinsx,xlow,xup,nbinsy,ylow,yup,nbinsz,zlow,zup); 4692{; 4693 TArrayD::Set(fNcells);; 4694 if (fgDefaultSumw2) Sumw2();; 4695 ; 4696 if (xlow >= xup || ylow >= yup || zlow >= zup) SetBuffer(fgBufferSize);; 4697}; 4698 ; 4699 ; 4700////////////////////////////////////////////////////////////////////////////////; 4701/// Constructor for variable bin size 3-D histograms; 4702/// (see TH3::TH3 for explanation of parameters); 4703 ; 4704TH3D::TH3D(const char *name,const char *title,Int_t nbinsx,const Float_t *xbins; 4705 ,Int_t nbinsy,const Float_t *ybins; 4706 ,Int_t nbinsz,const Float_t *zbins); 4707 :TH3(name,title,nbinsx,xbins,nbinsy,ybins,nbinsz,zbins); 4708{; 4709 TArrayD::Set(fNcells);; 4710 if (fgDefaultSumw2) Sumw2();; 4711}; 4712 ; 4713 ; 4714////////////////////////////////////////////////////////////////////////////////; 4715/// Constructor for variable bin size 3-D histograms; 4716/// (see TH3::TH3 for explanation of parameters); 4717 ; 4718TH3D::TH3D(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 4719 ,Int_t nbinsy,const Double_t *ybins; 4720 ,Int_t nbinsz,const Double_t *zbins); 4721 :TH3(name,title,nbinsx,xbins,nbinsy,ybins,nbinsz,zbins); 4722{; 4723 TArrayD::Set(fNcells);; 4724 if (fgDefaultSumw2) Sumw2();; 4725}; 4726 ; 4727 ; 4728////////////////////////////////////////////////////////////////////////////////; 4729/// Copy constructor.; 4730/// The list of functions is not copied. (Use Clone() if needed);",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:194086,Modifiability,extend,extendable,194086,"2, Double_t &err, Option_t *opt, Bool_t doerr=kFALSE) constInternal function compute integral and optionally the error between the limits specified by the bin n...Definition TH1.cxx:7977; TH1::fTsumwx2Double_t fTsumwx2Total Sum of weight*X*X.Definition TH1.h:99; TH1::GetStdDevvirtual Double_t GetStdDev(Int_t axis=1) constReturns the Standard Deviation (Sigma).Definition TH1.cxx:7607; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associated to bin number bin.Definition TH1.cxx:9063; TH1::GetNbinsZvirtual Int_t GetNbinsZ() constDefinition TH1.h:299; TH1::GetDimensionvirtual Int_t GetDimension() constDefinition TH1.h:283; TH1::Streamervoid Streamer(TBuffer &) overrideStream a class object.Definition TH1.cxx:6933; TH1::kIsNotW@ kIsNotWHistogram is forced to be not weighted even when the histogram is filled with weighted.Definition TH1.h:172; TH1::CanExtendAllAxesvirtual Bool_t CanExtendAllAxes() constReturns true if all axes are extendable.Definition TH1.cxx:6636; TH1::Resetvirtual void Reset(Option_t *option="""")Reset this histogram: contents, errors, etc.Definition TH1.cxx:7103; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetNcellsvirtual Int_t GetNcells() constDefinition TH1.h:300; TH1::PutStatsvirtual void PutStats(Double_t *stats)Replace current statistics with the values in array stats.Definition TH1.cxx:7884; TH1::GetPainterTVirtualHistPainter * GetPainter(Option_t *option="""")Return pointer to painter.Definition TH1.cxx:4511; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::GetBinvirtual Int_t GetBin(Int_t binx, Int_t biny=0, Int_t binz=0) constReturn Global bin number corresponding to binx,y,z.Definition TH1.cxx:4961; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::Addvirtual Bool_",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:213972,Modifiability,inherit,inherits,213972,"TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::AbstractMethodvoid AbstractMethod(const char *method) constUse this method to implement an ""abstract"" method that you don't want to leave purely abstract.Definition TObject.cxx:1035; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TProfile2DProfile2D histograms are used to display the mean value of Z and its error for each cell in X,...Definition TProfile2D.h:27; TProfile2D::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TProfile2D.cxx:1474; TProfile2D::FillInt_t Fill(const Double_t *v)Definition TProfile2D.h:51; TProfile2D::Classstatic TClass * Class(); TProfile2D::Sumw2void Sumw2(Bool_t flag=kTRUE) overrideCreate/Delete structure to store sum of squares of weights per bin.Definition TProfile2D.cxx:2043; TProfile2D::SetBinsvoid S",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:72923,Performance,perform,performing,72923," but only bins inside the selected range will be filled.; 1806///; 1807/// NOTE that if a TH1D named ""name"" exists in the current directory or pad,; 1808/// the histogram is reset and filled again with the projected contents of the TH3.; 1809///; 1810/// implemented using Project3D; 1811 ; 1812TH1D *TH3::ProjectionZ(const char *name, Int_t ixmin, Int_t ixmax,; 1813 Int_t iymin, Int_t iymax, Option_t *option) const; 1814{; 1815 ; 1816 TString hname = name;; 1817 if (hname == ""_pz"") hname = TString::Format(""%s%s"", GetName(), name);; 1818 TString title = TString::Format(""%s ( Projection Z )"",GetTitle());; 1819 ; 1820 // when projecting in Z outer axis are X and Y (order is important. It is defined in the DoProject1D function); 1821 return DoProject1D(hname, title, ixmin, ixmax, iymin, iymax, &fZaxis, &fXaxis, &fYaxis, option);; 1822}; 1823 ; 1824 ; 1825////////////////////////////////////////////////////////////////////////////////; 1826/// internal method performing the projection to 1D histogram; 1827/// called from TH3::Project3D; 1828 ; 1829TH1D *TH3::DoProject1D(const char* name, const char * title, int imin1, int imax1, int imin2, int imax2,; 1830 const TAxis* projAxis, const TAxis * axis1, const TAxis * axis2, Option_t * option) const; 1831{; 1832 ; 1833 TString opt = option;; 1834 opt.ToLower();; 1835 ; 1836 // save previous axis range and bits; 1837 // Int_t iminOld1 = axis1->GetFirst();; 1838 // Int_t imaxOld1 = axis1->GetLast();; 1839 // Int_t iminOld2 = axis2->GetFirst();; 1840 // Int_t imaxOld2 = axis2->GetLast();; 1841 // Bool_t hadRange1 = axis1->TestBit(TAxis::kAxisRange);; 1842 // Bool_t hadRange2 = axis2->TestBit(TAxis::kAxisRange);; 1843 ; 1844 // need to cast-away constness to set range; 1845 TAxis out1(*axis1);; 1846 TAxis out2(*axis2);; 1847 // const_cast<TAxis *>(axis1)->SetRange(imin1, imax1);; 1848 // const_cast<TAxis*>(axis2)->SetRange(imin2,imax2);; 1849 out1.SetRange(imin1, imax1);; 1850 out2.SetRange(imin2, imax2);; 1851 ; 1852 Bool_t compu",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:75119,Performance,perform,performing,75119,,MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:82795,Performance,perform,performing,82795,"rojX == GetZaxis() ) {; 2074 stats[2] = stats[7];; 2075 stats[3] = stats[8];; 2076 }; 2077 h1->PutStats(stats);; 2078 }; 2079 else {; 2080 // reset statistics; 2081 h1->ResetStats();; 2082 }; 2083 if (resetEntries) {; 2084 // in case of error calculation (i.e. when Sumw2() is set); 2085 // use the effective entries for the entries; 2086 // since this is the only way to estimate them; 2087 Double_t entries = TMath::Floor( totcont + 0.5); // to avoid numerical rounding; 2088 if (computeErrors) entries = h1->GetEffectiveEntries();; 2089 h1->SetEntries( entries );; 2090 }; 2091 else {; 2092 h1->SetEntries( fEntries );; 2093 }; 2094 ; 2095 return h1;; 2096}; 2097 ; 2098 ; 2099////////////////////////////////////////////////////////////////////////////////; 2100/// internal method performing the projection to a 2D histogram; 2101/// called from TH3::Project3D; 2102 ; 2103TH2D *TH3::DoProject2D(const char* name, const char * title, const TAxis* projX, const TAxis* projY,; 2104 bool computeErrors, bool originalRange,; 2105 bool useUF, bool useOF) const; 2106{; 2107 TH2D *h2 = nullptr;; 2108 ; 2109 // Get range to use as well as bin limits; 2110 Int_t ixmin = std::max(projX->GetFirst(),1);; 2111 Int_t ixmax = std::min(projX->GetLast(),projX->GetNbins());; 2112 Int_t iymin = std::max(projY->GetFirst(),1);; 2113 Int_t iymax = std::min(projY->GetLast(),projY->GetNbins());; 2114 ; 2115 Int_t nx = ixmax-ixmin+1;; 2116 Int_t ny = iymax-iymin+1;; 2117 ; 2118 // Create the histogram, either reseting a preexisting one; 2119 // or creating one from scratch.; 2120 // Does an object with the same name exists?; 2121 TObject *h2obj = gROOT->FindObject(name);; 2122 if (h2obj && h2obj->InheritsFrom(TH1::Class())) {; 2123 if ( h2obj->IsA() != TH2D::Class() ) {; 2124 Error(""DoProject2D"",""Histogram with name %s must be a TH2D and is a %s"",name,h2obj->ClassName());; 2125 return nullptr;; 2126 }; 2127 h2 = (TH2D*)h2obj;; 2128 // reset histogram and its axes; 2129 h2->Reset();; 2130 const TArrayD ",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:136964,Performance,perform,performing,136964,"; 3470 fEntries++;; 3471 fTsumw = 0;; 3472 if (bin < 0) return;; 3473 if (bin >= fNcells) return;; 3474 UpdateBinContent(bin, content);; 3475}; 3476 ; 3477 ; 3478////////////////////////////////////////////////////////////////////////////////; 3479/// Stream an object of class TH3.; 3480 ; 3481void TH3::Streamer(TBuffer &R__b); 3482{; 3483 if (R__b.IsReading()) {; 3484 UInt_t R__s, R__c;; 3485 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 3486 if (R__v > 2) {; 3487 R__b.ReadClassBuffer(TH3::Class(), this, R__v, R__s, R__c);; 3488 return;; 3489 }; 3490 //====process old versions before automatic schema evolution; 3491 TH1::Streamer(R__b);; 3492 TAtt3D::Streamer(R__b);; 3493 R__b.CheckByteCount(R__s, R__c, TH3::IsA());; 3494 //====end of old versions; 3495 ; 3496 } else {; 3497 R__b.WriteClassBuffer(TH3::Class(),this);; 3498 }; 3499}; 3500 ; 3501////////////////////////////////////////////////////////////////////////////////; 3502/// static methdod performing the projection to 1D histogram; 3503 ; 3504TH1D *TH3::DoProject1D(const TH3 &h, const char *name, const char *title, const TAxis *projX, bool computeErrors,; 3505 bool originalRange, bool useUF, bool useOF); 3506{; 3507 return h.DoProject1D(name, title, projX, nullptr, nullptr, computeErrors, originalRange, useUF, useOF);; 3508}; 3509 ; 3510////////////////////////////////////////////////////////////////////////////////; 3511/// static methdod performing the projection to 2D histogram; 3512 ; 3513TH2D *TH3::DoProject2D(const TH3 &h, const char *name, const char *title, const TAxis *projX, const TAxis *projY,; 3514 bool computeErrors, bool originalRange, bool useUF, bool useOF); 3515{; 3516 return h.DoProject2D(name, title, projX, projY, computeErrors, originalRange, useUF, useOF);; 3517}; 3518 ; 3519//______________________________________________________________________________; 3520// TH3C methods; 3521// TH3C a 3-D histogram with one byte per cell (char); 3522//______________________________________________",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:137423,Performance,perform,performing,137423,";; 3486 if (R__v > 2) {; 3487 R__b.ReadClassBuffer(TH3::Class(), this, R__v, R__s, R__c);; 3488 return;; 3489 }; 3490 //====process old versions before automatic schema evolution; 3491 TH1::Streamer(R__b);; 3492 TAtt3D::Streamer(R__b);; 3493 R__b.CheckByteCount(R__s, R__c, TH3::IsA());; 3494 //====end of old versions; 3495 ; 3496 } else {; 3497 R__b.WriteClassBuffer(TH3::Class(),this);; 3498 }; 3499}; 3500 ; 3501////////////////////////////////////////////////////////////////////////////////; 3502/// static methdod performing the projection to 1D histogram; 3503 ; 3504TH1D *TH3::DoProject1D(const TH3 &h, const char *name, const char *title, const TAxis *projX, bool computeErrors,; 3505 bool originalRange, bool useUF, bool useOF); 3506{; 3507 return h.DoProject1D(name, title, projX, nullptr, nullptr, computeErrors, originalRange, useUF, useOF);; 3508}; 3509 ; 3510////////////////////////////////////////////////////////////////////////////////; 3511/// static methdod performing the projection to 2D histogram; 3512 ; 3513TH2D *TH3::DoProject2D(const TH3 &h, const char *name, const char *title, const TAxis *projX, const TAxis *projY,; 3514 bool computeErrors, bool originalRange, bool useUF, bool useOF); 3515{; 3516 return h.DoProject2D(name, title, projX, projY, computeErrors, originalRange, useUF, useOF);; 3517}; 3518 ; 3519//______________________________________________________________________________; 3520// TH3C methods; 3521// TH3C a 3-D histogram with one byte per cell (char); 3522//______________________________________________________________________________; 3523 ; 3524ClassImp(TH3C);; 3525 ; 3526 ; 3527////////////////////////////////////////////////////////////////////////////////; 3528/// Constructor.; 3529 ; 3530TH3C::TH3C(); 3531{; 3532 SetBinsLength(27);; 3533 if (fgDefaultSumw2) Sumw2();; 3534}; 3535 ; 3536 ; 3537////////////////////////////////////////////////////////////////////////////////; 3538/// Destructor.; 3539 ; 3540TH3C::~TH3C(); 3541{; 3542}; ",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:205854,Performance,perform,performing,205854,"ygroup=2, Int_t nzgroup=2, const char *newname="""")Rebin this histogram grouping nxgroup/nygroup/nzgroup bins along the xaxis/yaxis/zaxis together.Definition TH3.cxx:2957; TH3::BufferEmptyInt_t BufferEmpty(Int_t action=0) overrideFill histogram with all entries in the buffer.Definition TH3.cxx:264; TH3::fTsumwyDouble_t fTsumwyTotal Sum of weight*Y.Definition TH3.h:34; TH3::fTsumwy2Double_t fTsumwy2Total Sum of weight*Y*Y.Definition TH3.h:35; TH3::GetCovariancevirtual Double_t GetCovariance(Int_t axis1=1, Int_t axis2=2) constReturn covariance between axis1 and axis2.Definition TH3.cxx:1209; TH3::GetStatsvoid GetStats(Double_t *stats) const overrideFill the array stats from the contents of this histogram The array stats must be correctly dimensione...Definition TH3.cxx:1307; TH3::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH3.cxx:208; TH3::DoProject2Dvirtual TH2D * DoProject2D(const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF) constinternal method performing the projection to a 2D histogram called from TH3::Project3DDefinition TH3.cxx:2103; TH3::fTsumwxzDouble_t fTsumwxzTotal Sum of weight*X*Z.Definition TH3.h:39; TH3::FillRandomvoid FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr) overrideFill histogram following distribution in function fname.Definition TH3.cxx:833; TH3::KolmogorovTestDouble_t KolmogorovTest(const TH1 *h2, Option_t *option="""") const overrideStatistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test.Definition TH3.cxx:1532; TH3::ProjectionYvirtual TH1D * ProjectionY(const char *name=""_py"", Int_t ixmin=0, Int_t ixmax=-1, Int_t izmin=0, Int_t izmax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D histogram along Y.Definition TH3.cxx:1780; TH3::InterpolateDouble_t Interpolate(Double_t x, Double_t y) const overrideNot yet implemented.Definition TH3.cxx:1441; TH3::GetRandom3virtu",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:210813,Performance,perform,performing,210813,"; TH3::IntegralDouble_t Integral(Option_t *option="""") const overrideReturn integral of bin contents.Definition TH3.cxx:1390; TH3::BufferFillvirtual Int_t BufferFill(Double_t x, Double_t y, Double_t z, Double_t w)Accumulate arguments in buffer.Definition TH3.cxx:339; TH3::IsATClass * IsA() const overrideDefinition TH3.h:152; TH3::SetShowProjectionvirtual void SetShowProjection(const char *option=""xy"", Int_t nbins=1)When the mouse is moved in a pad containing a 3-d view of this histogram a second canvas shows a proj...Definition TH3.cxx:3676; TH3::RebinXTH3 * RebinX(Int_t ngroup=2, const char *newname="""") overrideRebin only the X axis see Rebin3D.Definition TH3.cxx:2906; TH3::GetCorrelationFactorvirtual Double_t GetCorrelationFactor(Int_t axis1=1, Int_t axis2=2) constReturn correlation factor between axis1 and axis2.Definition TH3.cxx:1191; TH3::DoProject1Dvirtual TH1D * DoProject1D(const char *name, const char *title, int imin1, int imax1, int imin2, int imax2, const TAxis *projAxis, const TAxis *axis1, const TAxis *axis2, Option_t *option) constinternal method performing the projection to 1D histogram called from TH3::Project3DDefinition TH3.cxx:1829; TH3::fTsumwzDouble_t fTsumwzTotal Sum of weight*Z.Definition TH3.h:37; TH3::GetBinContentDouble_t GetBinContent(Int_t binx, Int_t biny, Int_t binz) const overrideDefinition TH3.h:101; TH3::SetBinContentvoid SetBinContent(Int_t bin, Double_t content) overrideSet bin content.Definition TH3.cxx:3468; TH3::fTsumwyzDouble_t fTsumwyzTotal Sum of weight*Y*Z.Definition TH3.h:40; TH3::TH3TH3()Default constructor.Definition TH3.cxx:74; TH3::GetBinInt_t GetBin(Int_t binx, Int_t biny, Int_t binz) const overrideSee comments in TH1::GetBin.Definition TH3.cxx:1117; TH3::FitSlicesZvirtual void FitSlicesZ(TF1 *f1=nullptr, Int_t binminx=1, Int_t binmaxx=0, Int_t binminy=1, Int_t binmaxy=0, Int_t cut=0, Option_t *option=""QNR"")Project slices along Z in case of a 3-D histogram, then fit each slice with function f1 and make a 2-...Definition",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:3892,Safety,avoid,avoid,3892," for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 65\anchor floatmax3 (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br>; 66\anchor doublemax3 (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760); 67</sup>; 68*/; 69 ; 70 ; 71////////////////////////////////////////////////////////////////////////////////; 72/// Default constructor.; 73 ; 74TH3::TH3(); 75{; 76 fDimension = 3;; 77 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 78 fTsumwz = fTsumwz2 = fTsumwxz = fTsumwyz = 0;; 79}; 80 ; 81 ; 82////////////////////////////////////////////////////////////////////////////////; 83/// Constructor for fix bin size 3-D histograms.; 84/// Creates the main histogram structure.; 85///; 86/// \param[in] name name of histogram (avoid blanks); 87/// \param[in] title histogram title.; 88/// If title is of the form `stringt;stringx;stringy;stringz`,; 89/// the histogram title is set to `stringt`,; 90/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 91/// \param[in] nbinsx number of bins along the X axis; 92/// \param[in] xlow low edge of the X axis first bin; 93/// \param[in] xup upper edge of the X axis last bin (not included in last bin); 94/// \param[in] nbinsy number of bins along the Y axis; 95/// \param[in] ylow low edge of the Y axis first bin; 96/// \param[in] yup upper edge of the Y axis last bin (not included in last bin); 97/// \param[in] nbinsz number of bins along the Z axis; 98/// \param[in] zlow low edge of the Z axis first bin; 99/// \param[in] zup upper edge of the Z axis last bin (not included in last bin); 100 ; 101TH3::TH3(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 102 ,Int_t nbinsy,Double_t ylow,Double_t yup; 103 ,Int_t nbinsz,Double_t zlo",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:5670,Safety,avoid,avoid,5670,"e of the Z axis last bin (not included in last bin); 100 ; 101TH3::TH3(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 102 ,Int_t nbinsy,Double_t ylow,Double_t yup; 103 ,Int_t nbinsz,Double_t zlow,Double_t zup); 104 :TH1(name,title,nbinsx,xlow,xup); 105{; 106 fDimension = 3;; 107 if (nbinsy <= 0) {; 108 Warning(""TH3"",""nbinsy is <=0 - set to nbinsy = 1"");; 109 nbinsy = 1;; 110 }; 111 if (nbinsz <= 0) {; 112 Warning(""TH3"",""nbinsz is <=0 - set to nbinsz = 1"");; 113 nbinsz = 1;; 114 }; 115 fYaxis.Set(nbinsy,ylow,yup);; 116 fZaxis.Set(nbinsz,zlow,zup);; 117 fNcells = (nbinsx+2)*(nbinsy+2)*(nbinsz+2);; 118 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 119 fTsumwz = fTsumwz2 = fTsumwxz = fTsumwyz = 0;; 120}; 121 ; 122 ; 123////////////////////////////////////////////////////////////////////////////////; 124/// Constructor for variable bin size (along X, Y and Z axis) 3-D histograms using input; 125/// arrays of type float.; 126///; 127/// \param[in] name name of histogram (avoid blanks); 128/// \param[in] title histogram title.; 129/// If title is of the form `stringt;stringx;stringy;stringz`; 130/// the histogram title is set to `stringt`,; 131/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 132/// \param[in] nbinsx number of bins; 133/// \param[in] xbins array of low-edges for each bin.; 134/// This is an array of type float and size nbinsx+1; 135/// \param[in] nbinsy number of bins; 136/// \param[in] ybins array of low-edges for each bin.; 137/// This is an array of type float and size nbinsy+1; 138/// \param[in] nbinsz number of bins; 139/// \param[in] zbins array of low-edges for each bin.; 140/// This is an array of type float and size nbinsz+1; 141 ; 142TH3::TH3(const char *name,const char *title,Int_t nbinsx,const Float_t *xbins; 143 ,Int_t nbinsy,const Float_t *ybins; 144 ,Int_t nbinsz,const Float_t *zbins); 145 :TH1(name,title,nbinsx,xbins); 146{; 147 fDimension = 3;; 148 if (nbinsy <= 0) {Warning(""TH3"",""nbinsy is <=0 - set",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:7308,Safety,avoid,avoid,7308,"ges for each bin.; 140/// This is an array of type float and size nbinsz+1; 141 ; 142TH3::TH3(const char *name,const char *title,Int_t nbinsx,const Float_t *xbins; 143 ,Int_t nbinsy,const Float_t *ybins; 144 ,Int_t nbinsz,const Float_t *zbins); 145 :TH1(name,title,nbinsx,xbins); 146{; 147 fDimension = 3;; 148 if (nbinsy <= 0) {Warning(""TH3"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 149 if (nbinsz <= 0) nbinsz = 1;; 150 if (ybins) fYaxis.Set(nbinsy,ybins);; 151 else fYaxis.Set(nbinsy,0,1);; 152 if (zbins) fZaxis.Set(nbinsz,zbins);; 153 else fZaxis.Set(nbinsz,0,1);; 154 fNcells = (nbinsx+2)*(nbinsy+2)*(nbinsz+2);; 155 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 156 fTsumwz = fTsumwz2 = fTsumwxz = fTsumwyz = 0;; 157}; 158 ; 159 ; 160////////////////////////////////////////////////////////////////////////////////; 161/// Constructor for variable bin size (along X, Y and Z axis) 3-D histograms using input; 162/// arrays of type double.; 163///; 164/// \param[in] name name of histogram (avoid blanks); 165/// \param[in] title histogram title.; 166/// If title is of the form `stringt;stringx;stringy;stringz`; 167/// the histogram title is set to `stringt`,; 168/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 169/// \param[in] nbinsx number of bins; 170/// \param[in] xbins array of low-edges for each bin.; 171/// This is an array of type double and size nbinsx+1; 172/// \param[in] nbinsy number of bins; 173/// \param[in] ybins array of low-edges for each bin.; 174/// This is an array of type double and size nbinsy+1; 175/// \param[in] nbinsz number of bins; 176/// \param[in] zbins array of low-edges for each bin.; 177/// This is an array of type double and size nbinsz+1; 178 ; 179TH3::TH3(const char *name,const char *title,Int_t nbinsx,const Double_t *xbins; 180 ,Int_t nbinsy,const Double_t *ybins; 181 ,Int_t nbinsz,const Double_t *zbins); 182 :TH1(name,title,nbinsx,xbins); 183{; 184 fDimension = 3;; 185 if (nbinsy <= 0) {Warning(""TH3"",""nbinsy is <=0",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:79971,Safety,avoid,avoid,79971,"ow/overflows if considered in the option; 2004 // if specified in the option (by default they considered); 2005 Double_t totcont = 0;; 2006 ; 2007 Int_t out1min = out1->GetFirst();; 2008 Int_t out1max = out1->GetLast();; 2009 // GetFirst(), GetLast() can return (0,0) when the range bit is set artificially (see TAxis::SetRange); 2010 //if (out1min == 0 && out1max == 0) { out1min = 1; out1max = out1->GetNbins(); }; 2011 // correct for underflow/overflows; 2012 if (useUF && !out1->TestBit(TAxis::kAxisRange) ) out1min -= 1;; 2013 if (useOF && !out1->TestBit(TAxis::kAxisRange) ) out1max += 1;; 2014 Int_t out2min = out2->GetFirst();; 2015 Int_t out2max = out2->GetLast();; 2016// if (out2min == 0 && out2max == 0) { out2min = 1; out2max = out2->GetNbins(); }; 2017 if (useUF && !out2->TestBit(TAxis::kAxisRange) ) out2min -= 1;; 2018 if (useOF && !out2->TestBit(TAxis::kAxisRange) ) out2max += 1;; 2019 ; 2020 // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins; 2021 Bool_t extendable = projX->CanExtend();; 2022 if ( labels && extendable ) h1->GetXaxis()->SetCanExtend(kFALSE);; 2023 for (ixbin=0;ixbin<=1+projX->GetNbins();ixbin++) {; 2024 if ( projX->TestBit(TAxis::kAxisRange) && ( ixbin < ixmin || ixbin > ixmax )) continue;; 2025 ; 2026 Double_t cont = 0;; 2027 Double_t err2 = 0;; 2028 ; 2029 // loop on the bins to be integrated (outbin should be called inbin); 2030 for (out1bin = out1min; out1bin <= out1max; out1bin++) {; 2031 for (out2bin = out2min; out2bin <= out2max; out2bin++) {; 2032 ; 2033 Int_t bin = GetBin(*refX, *refY, *refZ);; 2034 ; 2035 // sum the bin contents and errors if needed; 2036 cont += RetrieveBinContent(bin);; 2037 if (computeErrors) {; 2038 Double_t exyz = GetBinError(bin);; 2039 err2 += exyz*exyz;; 2040 }; 2041 }; 2042 }; 2043 Int_t ix = h1->FindBin( projX->GetBinCenter(ixbin) );; 2044 h1->SetBinContent(ix ,cont);; 2045 if (computeErrors) h1->SetBinError(ix, TMath::Sqrt(err2) );; 2046 // sum all ",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:82456,Safety,avoid,avoid,82456,"rojX == GetZaxis() ) {; 2074 stats[2] = stats[7];; 2075 stats[3] = stats[8];; 2076 }; 2077 h1->PutStats(stats);; 2078 }; 2079 else {; 2080 // reset statistics; 2081 h1->ResetStats();; 2082 }; 2083 if (resetEntries) {; 2084 // in case of error calculation (i.e. when Sumw2() is set); 2085 // use the effective entries for the entries; 2086 // since this is the only way to estimate them; 2087 Double_t entries = TMath::Floor( totcont + 0.5); // to avoid numerical rounding; 2088 if (computeErrors) entries = h1->GetEffectiveEntries();; 2089 h1->SetEntries( entries );; 2090 }; 2091 else {; 2092 h1->SetEntries( fEntries );; 2093 }; 2094 ; 2095 return h1;; 2096}; 2097 ; 2098 ; 2099////////////////////////////////////////////////////////////////////////////////; 2100/// internal method performing the projection to a 2D histogram; 2101/// called from TH3::Project3D; 2102 ; 2103TH2D *TH3::DoProject2D(const char* name, const char * title, const TAxis* projX, const TAxis* projY,; 2104 bool computeErrors, bool originalRange,; 2105 bool useUF, bool useOF) const; 2106{; 2107 TH2D *h2 = nullptr;; 2108 ; 2109 // Get range to use as well as bin limits; 2110 Int_t ixmin = std::max(projX->GetFirst(),1);; 2111 Int_t ixmax = std::min(projX->GetLast(),projX->GetNbins());; 2112 Int_t iymin = std::max(projY->GetFirst(),1);; 2113 Int_t iymax = std::min(projY->GetLast(),projY->GetNbins());; 2114 ; 2115 Int_t nx = ixmax-ixmin+1;; 2116 Int_t ny = iymax-iymin+1;; 2117 ; 2118 // Create the histogram, either reseting a preexisting one; 2119 // or creating one from scratch.; 2120 // Does an object with the same name exists?; 2121 TObject *h2obj = gROOT->FindObject(name);; 2122 if (h2obj && h2obj->InheritsFrom(TH1::Class())) {; 2123 if ( h2obj->IsA() != TH2D::Class() ) {; 2124 Error(""DoProject2D"",""Histogram with name %s must be a TH2D and is a %s"",name,h2obj->ClassName());; 2125 return nullptr;; 2126 }; 2127 h2 = (TH2D*)h2obj;; 2128 // reset histogram and its axes; 2129 h2->Reset();; 2130 const TArrayD ",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:92549,Safety,avoid,avoid,92549,"else {; 2339 // recalculate the statistics; 2340 h2->ResetStats();; 2341 }; 2342 ; 2343 if (resetEntries) {; 2344 // use the effective entries for the entries; 2345 // since this is the only way to estimate them; 2346 Double_t entries = h2->GetEffectiveEntries();; 2347 if (!computeErrors) entries = TMath::Floor( entries + 0.5); // to avoid numerical rounding; 2348 h2->SetEntries( entries );; 2349 }; 2350 else {; 2351 h2->SetEntries( fEntries );; 2352 }; 2353 ; 2354 ; 2355 return h2;; 2356}; 2357 ; 2358 ; 2359////////////////////////////////////////////////////////////////////////////////; 2360/// Project a 3-d histogram into 1 or 2-d histograms depending on the; 2361/// option parameter, which may contain a combination of the characters x,y,z,e; 2362/// - option = ""x"" return the x projection into a TH1D histogram; 2363/// - option = ""y"" return the y projection into a TH1D histogram; 2364/// - option = ""z"" return the z projection into a TH1D histogram; 2365/// - option = ""xy"" return the x versus y projection into a TH2D histogram; 2366/// - option = ""yx"" return the y versus x projection into a TH2D histogram; 2367/// - option = ""xz"" return the x versus z projection into a TH2D histogram; 2368/// - option = ""zx"" return the z versus x projection into a TH2D histogram; 2369/// - option = ""yz"" return the y versus z projection into a TH2D histogram; 2370/// - option = ""zy"" return the z versus y projection into a TH2D histogram; 2371///; 2372/// NB: the notation ""a vs b"" means ""a"" vertical and ""b"" horizontal; 2373///; 2374/// option = ""o"" original axis range of the target axes will be; 2375/// kept, but only bins inside the selected range will be filled.; 2376///; 2377/// If option contains the string ""e"", errors are computed; 2378///; 2379/// The projection is made for the selected bins only.; 2380/// To select a bin range along an axis, use TAxis::SetRange, eg; 2381/// h3.GetYaxis()->SetRange(23,56);; 2382///; 2383/// NOTE 1: The generated histogram is named th3name + opt",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:95845,Safety,avoid,avoid,95845,"histogram of the same type and with the same name already exists in current Directory,; 2395/// the histogram is reset and filled again with the projected contents of the TH3.; 2396///; 2397/// NOTE 3: The number of entries in the projected histogram is estimated from the number of; 2398/// effective entries for all the cells included in the projection.; 2399///; 2400/// NOTE 4: underflow/overflow are included by default in the projection; 2401/// To exclude underflow and/or overflow (for both axis in case of a projection to a 1D histogram) use option ""NUF"" and/or ""NOF""; 2402/// With SetRange() you can have all bins except underflow/overflow only if you set the axis bit range as; 2403/// following after having called SetRange: axis->SetRange(1, axis->GetNbins());; 2404///; 2405/// NOTE 5: If TH1::AddDirectory is set to false, a new histogram is always created and the ownership of the; 2406/// returned pointer is delegated to the user. Be sure in this case to call `delete` on it after it's no longer needed,; 2407/// to avoid memory leaks.; 2408 ; 2409TH1 *TH3::Project3D(Option_t *option) const; 2410{; 2411 TString opt = option;; 2412 TString extra_name = option;; 2413 Int_t underscore = extra_name.Last('_');; 2414 if (underscore > 0) {; 2415 extra_name.Remove(underscore,extra_name.Length()-underscore);; 2416 opt.Remove(0,underscore+1);; 2417 }; 2418 opt.ToLower();; 2419 ; 2420 Int_t pcase = 0;; 2421 TString ptype;; 2422 if (opt.Contains(""x"")) { pcase = 1; ptype = ""x""; }; 2423 if (opt.Contains(""y"")) { pcase = 2; ptype = ""y""; }; 2424 if (opt.Contains(""z"")) { pcase = 3; ptype = ""z""; }; 2425 if (opt.Contains(""xy"")) { pcase = 4; ptype = ""xy""; }; 2426 if (opt.Contains(""yx"")) { pcase = 5; ptype = ""yx""; }; 2427 if (opt.Contains(""xz"")) { pcase = 6; ptype = ""xz""; }; 2428 if (opt.Contains(""zx"")) { pcase = 7; ptype = ""zx""; }; 2429 if (opt.Contains(""yz"")) { pcase = 8; ptype = ""yz""; }; 2430 if (opt.Contains(""zy"")) { pcase = 9; ptype = ""zy""; }; 2431 ; 2432 if (pcase == 0) {; 2433 Er",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:109119,Safety,avoid,avoid,109119,"/ forget about preserving old statistics; 2746 bool resetStats = true;; 2747 Double_t stats[kNstat];; 2748 // reset statistics; 2749 if (resetStats); 2750 for (Int_t i=0;i<kNstat;i++) stats[i] = 0;; 2751 ; 2752 p2->PutStats(stats);; 2753 Double_t entries = fEntries;; 2754 // recalculate the statistics; 2755 if (resetStats) {; 2756 entries = p2->GetEffectiveEntries();; 2757 if (!useWeights) entries = TMath::Floor( entries + 0.5); // to avoid numerical rounding; 2758 p2->SetEntries( entries );; 2759 }; 2760 ; 2761 p2->SetEntries(entries);; 2762 ; 2763 return p2;; 2764}; 2765 ; 2766 ; 2767////////////////////////////////////////////////////////////////////////////////; 2768/// Project a 3-d histogram into a 2-d profile histograms depending; 2769/// on the option parameter; 2770/// option may contain a combination of the characters x,y,z; 2771/// option = ""xy"" return the x versus y projection into a TProfile2D histogram; 2772/// option = ""yx"" return the y versus x projection into a TProfile2D histogram; 2773/// option = ""xz"" return the x versus z projection into a TProfile2D histogram; 2774/// option = ""zx"" return the z versus x projection into a TProfile2D histogram; 2775/// option = ""yz"" return the y versus z projection into a TProfile2D histogram; 2776/// option = ""zy"" return the z versus y projection into a TProfile2D histogram; 2777/// NB: the notation ""a vs b"" means ""a"" vertical and ""b"" horizontal; 2778///; 2779/// option = ""o"" original axis range of the target axes will be; 2780/// kept, but only bins inside the selected range will be filled.; 2781///; 2782/// The projection is made for the selected bins only.; 2783/// To select a bin range along an axis, use TAxis::SetRange, eg; 2784/// h3.GetYaxis()->SetRange(23,56);; 2785///; 2786/// NOTE 1: The generated histogram is named th3name + ""_p"" + option; 2787/// eg if the TH3* h histogram is named ""myhist"", then; 2788/// h->Project3D(""xy""); produces a TProfile2D histogram named ""myhist_pxy"".; 2789/// The following s",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:37840,Security,access,access,37840,"///; 958/// Note that the generated histograms are added to the list of objects; 959/// in the current directory. It is the user's responsibility to delete; 960/// these histograms.; 961///; 962/// Example: Assume a 3-d histogram h3; 963/// Root > h3->FitSlicesZ(); produces 4 TH2D histograms; 964/// with h3_0 containing parameter 0(Constant) for a Gaus fit; 965/// of each cell in X,Y projected along Z; 966/// with h3_1 containing parameter 1(Mean) for a gaus fit; 967/// with h3_2 containing parameter 2(StdDev) for a gaus fit; 968/// with h3_chi2 containing the chisquare/number of degrees of freedom for a gaus fit; 969///; 970/// Root > h3->Fit(0,15,22,0,0,10);; 971/// same as above, but only for bins 15 to 22 along X; 972/// and only for cells in X,Y for which the corresponding projection; 973/// along Z has more than cut bins filled.; 974///; 975/// NOTE: To access the generated histograms in the current directory, do eg:; 976/// TH2D *h3_1 = (TH2D*)gDirectory->Get(""h3_1"");; 977 ; 978void TH3::FitSlicesZ(TF1 *f1, Int_t binminx, Int_t binmaxx, Int_t binminy, Int_t binmaxy, Int_t cut, Option_t *option); 979{; 980 //Int_t nbinsz = fZaxis.GetNbins();; 981 ; 982 // get correct first and last bins for outer axes used in the loop doing the slices; 983 // when using default values (0,-1) check if an axis range is set in outer axis; 984 // do same as in DoProjection for inner axis; 985 auto computeFirstAndLastBin = [](const TAxis & outerAxis, Int_t &firstbin, Int_t &lastbin) {; 986 Int_t nbins = outerAxis.GetNbins();; 987 if ( lastbin < firstbin && outerAxis.TestBit(TAxis::kAxisRange) ) {; 988 firstbin = outerAxis.GetFirst();; 989 lastbin = outerAxis.GetLast();; 990 // For special case of TAxis::SetRange, when first == 1 and last; 991 // = N and the range bit has been set, the TAxis will return 0; 992 // for both.; 993 if (firstbin == 0 && lastbin == 0) {; 994 firstbin = 1;; 995 lastbin = nbins;; 996 }; 997 }; 998 if (firstbin < 0) firstbin = 0;; 999 if (lastbin < 0 || last",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:212566,Security,hash,hash,212566,"maxx=0, Int_t binminy=1, Int_t binmaxy=0, Int_t cut=0, Option_t *option=""QNR"")Project slices along Z in case of a 3-D histogram, then fit each slice with function f1 and make a 2-...Definition TH3.cxx:978; TH3::DoProjectProfile2Dvirtual TProfile2D * DoProjectProfile2D(const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool originalRange, bool useUF, bool useOF) constinternal method to project to a 2D Profile called from TH3::Project3DProfileDefinition TH3.cxx:2576; TH3::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TH3.cxx:2889; THLimitsFinder::GetLimitsFinderstatic THLimitsFinder * GetLimitsFinder()Return pointer to the current finder.Definition THLimitsFinder.cxx:153; THLimitsFinder::FindGoodLimitsvirtual Int_t FindGoodLimits(TH1 *h, Double_t xmin, Double_t xmax)Compute the best axis limits for the X axis.Definition THLimitsFinder.cxx:53; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; TIterDefinition TCollection.h:235; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::AbstractMethodvoid AbstractMethod(const char *method) constUse this method to implement an ""abstract"" method that you don't want to leave purely abstract.Definition TObject.cxx:1035; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:59642,Testability,test,test,59642,"tNbins() || obz > fZaxis.GetNbins() ) {; 1477 Error(""Interpolate"",""Cannot interpolate outside histogram domain."");; 1478 return 0;; 1479 }; 1480 ; 1481 Double_t xw = fXaxis.GetBinCenter(obx) - fXaxis.GetBinCenter(ubx);; 1482 Double_t yw = fYaxis.GetBinCenter(oby) - fYaxis.GetBinCenter(uby);; 1483 Double_t zw = fZaxis.GetBinCenter(obz) - fZaxis.GetBinCenter(ubz);; 1484 ; 1485 Double_t xd = (x - fXaxis.GetBinCenter(ubx)) / xw;; 1486 Double_t yd = (y - fYaxis.GetBinCenter(uby)) / yw;; 1487 Double_t zd = (z - fZaxis.GetBinCenter(ubz)) / zw;; 1488 ; 1489 ; 1490 Double_t v[] = { GetBinContent( ubx, uby, ubz ), GetBinContent( ubx, uby, obz ),; 1491 GetBinContent( ubx, oby, ubz ), GetBinContent( ubx, oby, obz ),; 1492 GetBinContent( obx, uby, ubz ), GetBinContent( obx, uby, obz ),; 1493 GetBinContent( obx, oby, ubz ), GetBinContent( obx, oby, obz ) };; 1494 ; 1495 ; 1496 Double_t i1 = v[0] * (1 - zd) + v[1] * zd;; 1497 Double_t i2 = v[2] * (1 - zd) + v[3] * zd;; 1498 Double_t j1 = v[4] * (1 - zd) + v[5] * zd;; 1499 Double_t j2 = v[6] * (1 - zd) + v[7] * zd;; 1500 ; 1501 ; 1502 Double_t w1 = i1 * (1 - yd) + i2 * yd;; 1503 Double_t w2 = j1 * (1 - yd) + j2 * yd;; 1504 ; 1505 ; 1506 Double_t result = w1 * (1 - xd) + w2 * xd;; 1507 ; 1508 return result;; 1509}; 1510 ; 1511 ; 1512////////////////////////////////////////////////////////////////////////////////; 1513/// Statistical test of compatibility in shape between; 1514/// THIS histogram and h2, using Kolmogorov test.; 1515/// Default: Ignore under- and overflow bins in comparison; 1516///; 1517/// option is a character string to specify options; 1518/// ""U"" include Underflows in test; 1519/// ""O"" include Overflows; 1520/// ""N"" include comparison of normalizations; 1521/// ""D"" Put out a line of ""Debug"" printout; 1522/// ""M"" Return the Maximum Kolmogorov distance instead of prob; 1523///; 1524/// The returned function value is the probability of test; 1525/// (much less than one means NOT compatible); 1526///; 1527/// The KS t",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:59730,Testability,test,test,59730,"tNbins() || obz > fZaxis.GetNbins() ) {; 1477 Error(""Interpolate"",""Cannot interpolate outside histogram domain."");; 1478 return 0;; 1479 }; 1480 ; 1481 Double_t xw = fXaxis.GetBinCenter(obx) - fXaxis.GetBinCenter(ubx);; 1482 Double_t yw = fYaxis.GetBinCenter(oby) - fYaxis.GetBinCenter(uby);; 1483 Double_t zw = fZaxis.GetBinCenter(obz) - fZaxis.GetBinCenter(ubz);; 1484 ; 1485 Double_t xd = (x - fXaxis.GetBinCenter(ubx)) / xw;; 1486 Double_t yd = (y - fYaxis.GetBinCenter(uby)) / yw;; 1487 Double_t zd = (z - fZaxis.GetBinCenter(ubz)) / zw;; 1488 ; 1489 ; 1490 Double_t v[] = { GetBinContent( ubx, uby, ubz ), GetBinContent( ubx, uby, obz ),; 1491 GetBinContent( ubx, oby, ubz ), GetBinContent( ubx, oby, obz ),; 1492 GetBinContent( obx, uby, ubz ), GetBinContent( obx, uby, obz ),; 1493 GetBinContent( obx, oby, ubz ), GetBinContent( obx, oby, obz ) };; 1494 ; 1495 ; 1496 Double_t i1 = v[0] * (1 - zd) + v[1] * zd;; 1497 Double_t i2 = v[2] * (1 - zd) + v[3] * zd;; 1498 Double_t j1 = v[4] * (1 - zd) + v[5] * zd;; 1499 Double_t j2 = v[6] * (1 - zd) + v[7] * zd;; 1500 ; 1501 ; 1502 Double_t w1 = i1 * (1 - yd) + i2 * yd;; 1503 Double_t w2 = j1 * (1 - yd) + j2 * yd;; 1504 ; 1505 ; 1506 Double_t result = w1 * (1 - xd) + w2 * xd;; 1507 ; 1508 return result;; 1509}; 1510 ; 1511 ; 1512////////////////////////////////////////////////////////////////////////////////; 1513/// Statistical test of compatibility in shape between; 1514/// THIS histogram and h2, using Kolmogorov test.; 1515/// Default: Ignore under- and overflow bins in comparison; 1516///; 1517/// option is a character string to specify options; 1518/// ""U"" include Underflows in test; 1519/// ""O"" include Overflows; 1520/// ""N"" include comparison of normalizations; 1521/// ""D"" Put out a line of ""Debug"" printout; 1522/// ""M"" Return the Maximum Kolmogorov distance instead of prob; 1523///; 1524/// The returned function value is the probability of test; 1525/// (much less than one means NOT compatible); 1526///; 1527/// The KS t",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:59901,Testability,test,test,59901,"; 1493 GetBinContent( obx, oby, ubz ), GetBinContent( obx, oby, obz ) };; 1494 ; 1495 ; 1496 Double_t i1 = v[0] * (1 - zd) + v[1] * zd;; 1497 Double_t i2 = v[2] * (1 - zd) + v[3] * zd;; 1498 Double_t j1 = v[4] * (1 - zd) + v[5] * zd;; 1499 Double_t j2 = v[6] * (1 - zd) + v[7] * zd;; 1500 ; 1501 ; 1502 Double_t w1 = i1 * (1 - yd) + i2 * yd;; 1503 Double_t w2 = j1 * (1 - yd) + j2 * yd;; 1504 ; 1505 ; 1506 Double_t result = w1 * (1 - xd) + w2 * xd;; 1507 ; 1508 return result;; 1509}; 1510 ; 1511 ; 1512////////////////////////////////////////////////////////////////////////////////; 1513/// Statistical test of compatibility in shape between; 1514/// THIS histogram and h2, using Kolmogorov test.; 1515/// Default: Ignore under- and overflow bins in comparison; 1516///; 1517/// option is a character string to specify options; 1518/// ""U"" include Underflows in test; 1519/// ""O"" include Overflows; 1520/// ""N"" include comparison of normalizations; 1521/// ""D"" Put out a line of ""Debug"" printout; 1522/// ""M"" Return the Maximum Kolmogorov distance instead of prob; 1523///; 1524/// The returned function value is the probability of test; 1525/// (much less than one means NOT compatible); 1526///; 1527/// The KS test uses the distance between the pseudo-CDF's obtained; 1528/// from the histogram. Since in more than 1D the order for generating the pseudo-CDF is; 1529/// arbitrary, we use the pseudo-CDF's obtained from all the possible 6 combinations of the 3 axis.; 1530/// The average of all the maximum distances obtained is used in the tests.; 1531 ; 1532Double_t TH3::KolmogorovTest(const TH1 *h2, Option_t *option) const; 1533{; 1534 TString opt = option;; 1535 opt.ToUpper();; 1536 ; 1537 Double_t prb = 0;; 1538 TH1 *h1 = (TH1*)this;; 1539 if (h2 == nullptr) return 0;; 1540 const TAxis *xaxis1 = h1->GetXaxis();; 1541 const TAxis *xaxis2 = h2->GetXaxis();; 1542 const TAxis *yaxis1 = h1->GetYaxis();; 1543 const TAxis *yaxis2 = h2->GetYaxis();; 1544 const TAxis *zaxis1 = h1->GetZaxis(",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:60171,Testability,test,test,60171,"; 1493 GetBinContent( obx, oby, ubz ), GetBinContent( obx, oby, obz ) };; 1494 ; 1495 ; 1496 Double_t i1 = v[0] * (1 - zd) + v[1] * zd;; 1497 Double_t i2 = v[2] * (1 - zd) + v[3] * zd;; 1498 Double_t j1 = v[4] * (1 - zd) + v[5] * zd;; 1499 Double_t j2 = v[6] * (1 - zd) + v[7] * zd;; 1500 ; 1501 ; 1502 Double_t w1 = i1 * (1 - yd) + i2 * yd;; 1503 Double_t w2 = j1 * (1 - yd) + j2 * yd;; 1504 ; 1505 ; 1506 Double_t result = w1 * (1 - xd) + w2 * xd;; 1507 ; 1508 return result;; 1509}; 1510 ; 1511 ; 1512////////////////////////////////////////////////////////////////////////////////; 1513/// Statistical test of compatibility in shape between; 1514/// THIS histogram and h2, using Kolmogorov test.; 1515/// Default: Ignore under- and overflow bins in comparison; 1516///; 1517/// option is a character string to specify options; 1518/// ""U"" include Underflows in test; 1519/// ""O"" include Overflows; 1520/// ""N"" include comparison of normalizations; 1521/// ""D"" Put out a line of ""Debug"" printout; 1522/// ""M"" Return the Maximum Kolmogorov distance instead of prob; 1523///; 1524/// The returned function value is the probability of test; 1525/// (much less than one means NOT compatible); 1526///; 1527/// The KS test uses the distance between the pseudo-CDF's obtained; 1528/// from the histogram. Since in more than 1D the order for generating the pseudo-CDF is; 1529/// arbitrary, we use the pseudo-CDF's obtained from all the possible 6 combinations of the 3 axis.; 1530/// The average of all the maximum distances obtained is used in the tests.; 1531 ; 1532Double_t TH3::KolmogorovTest(const TH1 *h2, Option_t *option) const; 1533{; 1534 TString opt = option;; 1535 opt.ToUpper();; 1536 ; 1537 Double_t prb = 0;; 1538 TH1 *h1 = (TH1*)this;; 1539 if (h2 == nullptr) return 0;; 1540 const TAxis *xaxis1 = h1->GetXaxis();; 1541 const TAxis *xaxis2 = h2->GetXaxis();; 1542 const TAxis *yaxis1 = h1->GetYaxis();; 1543 const TAxis *yaxis2 = h2->GetYaxis();; 1544 const TAxis *zaxis1 = h1->GetZaxis(",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:60252,Testability,test,test,60252,"; 1493 GetBinContent( obx, oby, ubz ), GetBinContent( obx, oby, obz ) };; 1494 ; 1495 ; 1496 Double_t i1 = v[0] * (1 - zd) + v[1] * zd;; 1497 Double_t i2 = v[2] * (1 - zd) + v[3] * zd;; 1498 Double_t j1 = v[4] * (1 - zd) + v[5] * zd;; 1499 Double_t j2 = v[6] * (1 - zd) + v[7] * zd;; 1500 ; 1501 ; 1502 Double_t w1 = i1 * (1 - yd) + i2 * yd;; 1503 Double_t w2 = j1 * (1 - yd) + j2 * yd;; 1504 ; 1505 ; 1506 Double_t result = w1 * (1 - xd) + w2 * xd;; 1507 ; 1508 return result;; 1509}; 1510 ; 1511 ; 1512////////////////////////////////////////////////////////////////////////////////; 1513/// Statistical test of compatibility in shape between; 1514/// THIS histogram and h2, using Kolmogorov test.; 1515/// Default: Ignore under- and overflow bins in comparison; 1516///; 1517/// option is a character string to specify options; 1518/// ""U"" include Underflows in test; 1519/// ""O"" include Overflows; 1520/// ""N"" include comparison of normalizations; 1521/// ""D"" Put out a line of ""Debug"" printout; 1522/// ""M"" Return the Maximum Kolmogorov distance instead of prob; 1523///; 1524/// The returned function value is the probability of test; 1525/// (much less than one means NOT compatible); 1526///; 1527/// The KS test uses the distance between the pseudo-CDF's obtained; 1528/// from the histogram. Since in more than 1D the order for generating the pseudo-CDF is; 1529/// arbitrary, we use the pseudo-CDF's obtained from all the possible 6 combinations of the 3 axis.; 1530/// The average of all the maximum distances obtained is used in the tests.; 1531 ; 1532Double_t TH3::KolmogorovTest(const TH1 *h2, Option_t *option) const; 1533{; 1534 TString opt = option;; 1535 opt.ToUpper();; 1536 ; 1537 Double_t prb = 0;; 1538 TH1 *h1 = (TH1*)this;; 1539 if (h2 == nullptr) return 0;; 1540 const TAxis *xaxis1 = h1->GetXaxis();; 1541 const TAxis *xaxis2 = h2->GetXaxis();; 1542 const TAxis *yaxis1 = h1->GetYaxis();; 1543 const TAxis *yaxis2 = h2->GetYaxis();; 1544 const TAxis *zaxis1 = h1->GetZaxis(",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:60582,Testability,test,tests,60582,"/////////////////////////////////////////////////////////////////////////; 1513/// Statistical test of compatibility in shape between; 1514/// THIS histogram and h2, using Kolmogorov test.; 1515/// Default: Ignore under- and overflow bins in comparison; 1516///; 1517/// option is a character string to specify options; 1518/// ""U"" include Underflows in test; 1519/// ""O"" include Overflows; 1520/// ""N"" include comparison of normalizations; 1521/// ""D"" Put out a line of ""Debug"" printout; 1522/// ""M"" Return the Maximum Kolmogorov distance instead of prob; 1523///; 1524/// The returned function value is the probability of test; 1525/// (much less than one means NOT compatible); 1526///; 1527/// The KS test uses the distance between the pseudo-CDF's obtained; 1528/// from the histogram. Since in more than 1D the order for generating the pseudo-CDF is; 1529/// arbitrary, we use the pseudo-CDF's obtained from all the possible 6 combinations of the 3 axis.; 1530/// The average of all the maximum distances obtained is used in the tests.; 1531 ; 1532Double_t TH3::KolmogorovTest(const TH1 *h2, Option_t *option) const; 1533{; 1534 TString opt = option;; 1535 opt.ToUpper();; 1536 ; 1537 Double_t prb = 0;; 1538 TH1 *h1 = (TH1*)this;; 1539 if (h2 == nullptr) return 0;; 1540 const TAxis *xaxis1 = h1->GetXaxis();; 1541 const TAxis *xaxis2 = h2->GetXaxis();; 1542 const TAxis *yaxis1 = h1->GetYaxis();; 1543 const TAxis *yaxis2 = h2->GetYaxis();; 1544 const TAxis *zaxis1 = h1->GetZaxis();; 1545 const TAxis *zaxis2 = h2->GetZaxis();; 1546 Int_t ncx1 = xaxis1->GetNbins();; 1547 Int_t ncx2 = xaxis2->GetNbins();; 1548 Int_t ncy1 = yaxis1->GetNbins();; 1549 Int_t ncy2 = yaxis2->GetNbins();; 1550 Int_t ncz1 = zaxis1->GetNbins();; 1551 Int_t ncz2 = zaxis2->GetNbins();; 1552 ; 1553 // Check consistency of dimensions; 1554 if (h1->GetDimension() != 3 || h2->GetDimension() != 3) {; 1555 Error(""KolmogorovTest"",""Histograms must be 3-D\n"");; 1556 return 0;; 1557 }; 1558 ; 1559 // Check consistency in ",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:206308,Testability,test,test,206308,"1=1, Int_t axis2=2) constReturn covariance between axis1 and axis2.Definition TH3.cxx:1209; TH3::GetStatsvoid GetStats(Double_t *stats) const overrideFill the array stats from the contents of this histogram The array stats must be correctly dimensione...Definition TH3.cxx:1307; TH3::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH3.cxx:208; TH3::DoProject2Dvirtual TH2D * DoProject2D(const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF) constinternal method performing the projection to a 2D histogram called from TH3::Project3DDefinition TH3.cxx:2103; TH3::fTsumwxzDouble_t fTsumwxzTotal Sum of weight*X*Z.Definition TH3.h:39; TH3::FillRandomvoid FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr) overrideFill histogram following distribution in function fname.Definition TH3.cxx:833; TH3::KolmogorovTestDouble_t KolmogorovTest(const TH1 *h2, Option_t *option="""") const overrideStatistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test.Definition TH3.cxx:1532; TH3::ProjectionYvirtual TH1D * ProjectionY(const char *name=""_py"", Int_t ixmin=0, Int_t ixmax=-1, Int_t izmin=0, Int_t izmax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D histogram along Y.Definition TH3.cxx:1780; TH3::InterpolateDouble_t Interpolate(Double_t x, Double_t y) const overrideNot yet implemented.Definition TH3.cxx:1441; TH3::GetRandom3virtual void GetRandom3(Double_t &x, Double_t &y, Double_t &, TRandom *rng=nullptr)Return 3 random numbers along axis x , y and z distributed according to the cell-contents of this 3-d...Definition TH3.cxx:1259; TH3::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH3.cxx:3449; TH3::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH3.cxx:224; TH3::~TH3~TH3() overrideDestructor.Definition TH3.cxx:200; TH3::FillIn",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:206387,Testability,test,test,206387,"1=1, Int_t axis2=2) constReturn covariance between axis1 and axis2.Definition TH3.cxx:1209; TH3::GetStatsvoid GetStats(Double_t *stats) const overrideFill the array stats from the contents of this histogram The array stats must be correctly dimensione...Definition TH3.cxx:1307; TH3::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH3.cxx:208; TH3::DoProject2Dvirtual TH2D * DoProject2D(const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF) constinternal method performing the projection to a 2D histogram called from TH3::Project3DDefinition TH3.cxx:2103; TH3::fTsumwxzDouble_t fTsumwxzTotal Sum of weight*X*Z.Definition TH3.h:39; TH3::FillRandomvoid FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr) overrideFill histogram following distribution in function fname.Definition TH3.cxx:833; TH3::KolmogorovTestDouble_t KolmogorovTest(const TH1 *h2, Option_t *option="""") const overrideStatistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test.Definition TH3.cxx:1532; TH3::ProjectionYvirtual TH1D * ProjectionY(const char *name=""_py"", Int_t ixmin=0, Int_t ixmax=-1, Int_t izmin=0, Int_t izmax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D histogram along Y.Definition TH3.cxx:1780; TH3::InterpolateDouble_t Interpolate(Double_t x, Double_t y) const overrideNot yet implemented.Definition TH3.cxx:1441; TH3::GetRandom3virtual void GetRandom3(Double_t &x, Double_t &y, Double_t &, TRandom *rng=nullptr)Return 3 random numbers along axis x , y and z distributed according to the cell-contents of this 3-d...Definition TH3.cxx:1259; TH3::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH3.cxx:3449; TH3::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH3.cxx:224; TH3::~TH3~TH3() overrideDestructor.Definition TH3.cxx:200; TH3::FillIn",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8cxx_source.html:217692,Testability,log,logarithm,217692,"option, Int_t nbins)=0; TVirtualPad::TContextsmall helper class to store/restore gPad context in TPad methodsDefinition TVirtualPad.h:61; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; h1TH1F * h1Definition legend1.C:5; f1TF1 * f1Definition legend1.C:11; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf...Definition TMath.cxx:637; TMath::PermuteBool_t Permute(Int_t n, Int_t *a)Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinc...Definition TMath.cxx:2557; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::MeanDouble_t Mean(Long64_t n, const T *a, const Double_t *w=nullptr)Returns the weighted mean of an array a with length n.Definition TMath.h:1089; TMath::KolmogorovProbDouble_t KolmogorovProb(Double_t z)Calculates the Kolmogorov distribution function,.Definition TMath.cxx:679; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; v@ vDefinition rootcling_impl.cxx:3699. histhistsrcTH3.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
https://root.cern/doc/master/TH3_8h_source.html:23313,Availability,error,error,23313,"Array of integers (32 bits per element).Definition TArrayI.h:27; TArrayI::fArrayInt_t * fArrayDefinition TArrayI.h:30; TArrayI::Resetvoid Reset()Definition TArrayI.h:47; TArrayL64Array of long64s (64 bits per element).Definition TArrayL64.h:27; TArrayL64::fArrayLong64_t * fArrayDefinition TArrayL64.h:30; TArrayL64::Resetvoid Reset()Definition TArrayL64.h:47; TArraySArray of shorts (16 bits per element).Definition TArrayS.h:27; TArrayS::Resetvoid Reset()Definition TArrayS.h:47; TArrayS::fArrayShort_t * fArrayDefinition TArrayS.h:30; TAtt3DUse this attribute class when an object should have 3D capabilities.Definition TAtt3D.h:19; TAxisClass to manage histogram axis.Definition TAxis.h:31; TF11-Dim function classDefinition TF1.h:233; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::IntegralAndErrorvirtual Double_t IntegralAndError(Int_t binx1, Int_t binx2, Double_t &err, Option_t *option="""") constReturn integral of bin contents in range [binx1,binx2] and its error.Definition TH1.cxx:7968; TH1::GetBinErrorLowvirtual Double_t GetBinErrorLow(Int_t bin) constReturn lower error associated to bin number bin.Definition TH1.cxx:9079; TH1::Integralvirtual Double_t Integral(Option_t *option="""") constReturn integral of bin contents.Definition TH1.cxx:7941; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t bin) constReturn upper error associated to bin number bin.Definition TH1.cxx:9110; TH2D2-D histogram with a double per channel (see TH1 documentation)Definition TH2.h:357; TH3C3-D histogram with a byte per channel (see TH1 documentation)Definition TH3.h:157; TH3C::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH3.cxx:3647; TH3C::operator*",MatchSource.WIKI,doc/master/TH3_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8h_source.html
https://root.cern/doc/master/TH3_8h_source.html:23424,Availability,error,error,23424,"L64Array of long64s (64 bits per element).Definition TArrayL64.h:27; TArrayL64::fArrayLong64_t * fArrayDefinition TArrayL64.h:30; TArrayL64::Resetvoid Reset()Definition TArrayL64.h:47; TArraySArray of shorts (16 bits per element).Definition TArrayS.h:27; TArrayS::Resetvoid Reset()Definition TArrayS.h:47; TArrayS::fArrayShort_t * fArrayDefinition TArrayS.h:30; TAtt3DUse this attribute class when an object should have 3D capabilities.Definition TAtt3D.h:19; TAxisClass to manage histogram axis.Definition TAxis.h:31; TF11-Dim function classDefinition TF1.h:233; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::IntegralAndErrorvirtual Double_t IntegralAndError(Int_t binx1, Int_t binx2, Double_t &err, Option_t *option="""") constReturn integral of bin contents in range [binx1,binx2] and its error.Definition TH1.cxx:7968; TH1::GetBinErrorLowvirtual Double_t GetBinErrorLow(Int_t bin) constReturn lower error associated to bin number bin.Definition TH1.cxx:9079; TH1::Integralvirtual Double_t Integral(Option_t *option="""") constReturn integral of bin contents.Definition TH1.cxx:7941; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t bin) constReturn upper error associated to bin number bin.Definition TH1.cxx:9110; TH2D2-D histogram with a double per channel (see TH1 documentation)Definition TH2.h:357; TH3C3-D histogram with a byte per channel (see TH1 documentation)Definition TH3.h:157; TH3C::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH3.cxx:3647; TH3C::operator*friend TH3C operator*(TH3C const &h1, Float_t c1)Definition TH3.h:182; TH3C::operator*friend TH3C operator*(Float_t c1, TH3C const &h1)Operator *.Definition TH3.cxx:3731; TH3C:",MatchSource.WIKI,doc/master/TH3_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8h_source.html
https://root.cern/doc/master/TH3_8h_source.html:23807,Availability,error,error,23807,"te class when an object should have 3D capabilities.Definition TAtt3D.h:19; TAxisClass to manage histogram axis.Definition TAxis.h:31; TF11-Dim function classDefinition TF1.h:233; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::IntegralAndErrorvirtual Double_t IntegralAndError(Int_t binx1, Int_t binx2, Double_t &err, Option_t *option="""") constReturn integral of bin contents in range [binx1,binx2] and its error.Definition TH1.cxx:7968; TH1::GetBinErrorLowvirtual Double_t GetBinErrorLow(Int_t bin) constReturn lower error associated to bin number bin.Definition TH1.cxx:9079; TH1::Integralvirtual Double_t Integral(Option_t *option="""") constReturn integral of bin contents.Definition TH1.cxx:7941; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t bin) constReturn upper error associated to bin number bin.Definition TH1.cxx:9110; TH2D2-D histogram with a double per channel (see TH1 documentation)Definition TH2.h:357; TH3C3-D histogram with a byte per channel (see TH1 documentation)Definition TH3.h:157; TH3C::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH3.cxx:3647; TH3C::operator*friend TH3C operator*(TH3C const &h1, Float_t c1)Definition TH3.h:182; TH3C::operator*friend TH3C operator*(Float_t c1, TH3C const &h1)Operator *.Definition TH3.cxx:3731; TH3C::~TH3C~TH3C() overrideDestructor.Definition TH3.cxx:3540; TH3C::operator-friend TH3C operator-(TH3C const &h1, TH3C const &h2)Operator -.Definition TH3.cxx:3755; TH3C::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH3.cxx:3635; TH3C::operator+friend TH3C operator+(TH3C const &h1, TH3C const &h2)Operator +.Definition TH3.cxx:3743",MatchSource.WIKI,doc/master/TH3_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8h_source.html
https://root.cern/doc/master/TH3_8h_source.html:24642,Availability,error,errors,24642,"941; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t bin) constReturn upper error associated to bin number bin.Definition TH1.cxx:9110; TH2D2-D histogram with a double per channel (see TH1 documentation)Definition TH2.h:357; TH3C3-D histogram with a byte per channel (see TH1 documentation)Definition TH3.h:157; TH3C::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH3.cxx:3647; TH3C::operator*friend TH3C operator*(TH3C const &h1, Float_t c1)Definition TH3.h:182; TH3C::operator*friend TH3C operator*(Float_t c1, TH3C const &h1)Operator *.Definition TH3.cxx:3731; TH3C::~TH3C~TH3C() overrideDestructor.Definition TH3.cxx:3540; TH3C::operator-friend TH3C operator-(TH3C const &h1, TH3C const &h2)Operator -.Definition TH3.cxx:3755; TH3C::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH3.cxx:3635; TH3C::operator+friend TH3C operator+(TH3C const &h1, TH3C const &h2)Operator +.Definition TH3.cxx:3743; TH3C::operator/friend TH3C operator/(TH3C const &h1, TH3C const &h2)Operator /.Definition TH3.cxx:3779; TH3C::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Int_t binz, Double_t w) overrideIncrement 3D bin content by a weight w.Definition TH3.h:175; TH3C::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH3.h:189; TH3C::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH3.cxx:3603; TH3C::operator=TH3C & operator=(const TH3C &h1)Operator =.Definition TH3.cxx:3720; TH3C::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Int_t binz) overrideIncrement 3D bin content by 1.Definition TH3.h:174; TH3C::TH3CTH3C()Constructor.Def",MatchSource.WIKI,doc/master/TH3_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8h_source.html
https://root.cern/doc/master/TH3_8h_source.html:38441,Availability,error,errors,38441,"ollowing distribution in function fname.Definition TH3.cxx:833; TH3::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t binx, Int_t biny, Int_t binz)Definition TH3.h:105; TH3::KolmogorovTestDouble_t KolmogorovTest(const TH1 *h2, Option_t *option="""") const overrideStatistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test.Definition TH3.cxx:1532; TH3::ProjectionYvirtual TH1D * ProjectionY(const char *name=""_py"", Int_t ixmin=0, Int_t ixmax=-1, Int_t izmin=0, Int_t izmax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D histogram along Y.Definition TH3.cxx:1780; TH3::FillInt_t Fill(const char *, Double_t) overrideIncrement bin with namex with a weight w.Definition TH3.h:60; TH3::GetRandom3virtual void GetRandom3(Double_t &x, Double_t &y, Double_t &, TRandom *rng=nullptr)Return 3 random numbers along axis x , y and z distributed according to the cell-contents of this 3-d...Definition TH3.cxx:1259; TH3::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH3.cxx:3449; TH3::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH3.cxx:224; TH3::~TH3~TH3() overrideDestructor.Definition TH3.cxx:200; TH3::FillInt_t Fill(Double_t) overrideInvalid Fill method.Definition TH3.cxx:368; TH3::RebinYvirtual TH3 * RebinY(Int_t ngroup=2, const char *newname="""")Rebin only the Y axis see Rebin3D.Definition TH3.cxx:2916; TH3::operator=TH3 & operator=(const TH3 &)=delete; TH3::IntegralAndErrorvirtual Double_t IntegralAndError(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Int_t binz1, Int_t binz2, Double_t &err, Option_t *option="""") constReturn integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2] for a 3-D histogra...Definition TH3.cxx:1421; TH3::ProjectionZvirtual TH1D * ProjectionZ(const char *name=""_pz"", Int_t ixmin=0, Int_t ixmax=-1, Int_t iymin=0, Int_t iymax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D h",MatchSource.WIKI,doc/master/TH3_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8h_source.html
https://root.cern/doc/master/TH3_8h_source.html:44160,Availability,error,error,44160,"Double_t GetBinContent(Int_t binx, Int_t biny, Int_t binz) const overrideDefinition TH3.h:101; TH3::SetBinContentvoid SetBinContent(Int_t bin, Double_t content) overrideSet bin content.Definition TH3.cxx:3468; TH3::SetBinContentvoid SetBinContent(Int_t bin, Int_t, Double_t content) overrideDefinition TH3.h:131; TH3::fTsumwyzDouble_t fTsumwyzTotal Sum of weight*Y*Z.Definition TH3.h:40; TH3::TH3TH3()Default constructor.Definition TH3.cxx:74; TH3::GetBinInt_t GetBin(Int_t binx, Int_t biny, Int_t binz) const overrideSee comments in TH1::GetBin.Definition TH3.cxx:1117; TH3::FitSlicesZvirtual void FitSlicesZ(TF1 *f1=nullptr, Int_t binminx=1, Int_t binmaxx=0, Int_t binminy=1, Int_t binmaxy=0, Int_t cut=0, Option_t *option=""QNR"")Project slices along Z in case of a 3-D histogram, then fit each slice with function f1 and make a 2-...Definition TH3.cxx:978; TH3::DoProjectProfile2Dvirtual TProfile2D * DoProjectProfile2D(const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool originalRange, bool useUF, bool useOF) constinternal method to project to a 2D Profile called from TH3::Project3DProfileDefinition TH3.cxx:2576; TH3::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TH3.cxx:2889; TObjectMother of all ROOT objects.Definition TObject.h:41; TProfile2DProfile2D histograms are used to display the mean value of Z and its error for each cell in X,...Definition TProfile2D.h:27; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; bool; double; int; Interpolate#define Interpolate(a, x, b, y)Definition geom.c:179; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; h1TH1F * h1Definition legend1.C:5; f1TF1 * f1Definition legend1.C:11. histhistincTH3.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TH3_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8h_source.html
https://root.cern/doc/master/TH3_8h_source.html:25709,Deployability,update,update,25709,"ator+(TH3C const &h1, TH3C const &h2)Operator +.Definition TH3.cxx:3743; TH3C::operator/friend TH3C operator/(TH3C const &h1, TH3C const &h2)Operator /.Definition TH3.cxx:3779; TH3C::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Int_t binz, Double_t w) overrideIncrement 3D bin content by a weight w.Definition TH3.h:175; TH3C::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH3.h:189; TH3C::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH3.cxx:3603; TH3C::operator=TH3C & operator=(const TH3C &h1)Operator =.Definition TH3.cxx:3720; TH3C::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Int_t binz) overrideIncrement 3D bin content by 1.Definition TH3.h:174; TH3C::TH3CTH3C()Constructor.Definition TH3.cxx:3530; TH3C::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH3.h:190; TH3C::Copyvoid Copy(TObject &hnew) const overrideCopy this 3-D histogram structure to newth3.Definition TH3.cxx:3626; TH3D3-D histogram with a double per channel (see TH1 documentation)Definition TH3.h:363; TH3D::operator*friend TH3D operator*(TH3D const &h1, Float_t c1)Definition TH3.h:393; TH3D::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH3.h:401; TH3D::TH3DTH3D()Constructor.Definition TH3.cxx:4669; TH3D::operator+friend TH3D operator+(TH3D const &h1, TH3D const &h2)Operator +.Definition TH3.cxx:4831; TH3D::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH3.cxx:4763; TH3D::~TH3D~TH3D() overrideDestructor.Definition TH3.cxx:467",MatchSource.WIKI,doc/master/TH3_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8h_source.html
https://root.cern/doc/master/TH3_8h_source.html:26209,Deployability,update,update,26209,"TH1::Get...Definition TH3.h:189; TH3C::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH3.cxx:3603; TH3C::operator=TH3C & operator=(const TH3C &h1)Operator =.Definition TH3.cxx:3720; TH3C::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Int_t binz) overrideIncrement 3D bin content by 1.Definition TH3.h:174; TH3C::TH3CTH3C()Constructor.Definition TH3.cxx:3530; TH3C::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH3.h:190; TH3C::Copyvoid Copy(TObject &hnew) const overrideCopy this 3-D histogram structure to newth3.Definition TH3.cxx:3626; TH3D3-D histogram with a double per channel (see TH1 documentation)Definition TH3.h:363; TH3D::operator*friend TH3D operator*(TH3D const &h1, Float_t c1)Definition TH3.h:393; TH3D::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH3.h:401; TH3D::TH3DTH3D()Constructor.Definition TH3.cxx:4669; TH3D::operator+friend TH3D operator+(TH3D const &h1, TH3D const &h2)Operator +.Definition TH3.cxx:4831; TH3D::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH3.cxx:4763; TH3D::~TH3D~TH3D() overrideDestructor.Definition TH3.cxx:4679; TH3D::AddBinContentvoid AddBinContent(Int_t bin, Double_t w) overrideIncrement bin content by a weight w Passing an out-of-range bin leads to undefined behavior.Definition TH3.h:383; TH3D::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Int_t binz) overrideIncrement 3D bin content by 1.Definition TH3.h:385; TH3D::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...",MatchSource.WIKI,doc/master/TH3_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8h_source.html
https://root.cern/doc/master/TH3_8h_source.html:28574,Deployability,update,update,28574,"ition TH3.cxx:4867; TH3D::operator*friend TH3D operator*(Float_t c1, TH3D const &h1)Operator *.Definition TH3.cxx:4819; TH3D::Copyvoid Copy(TObject &hnew) const overrideCopy this 3-D histogram structure to newth3.Definition TH3.cxx:4742; TH3D::operator=TH3D & operator=(const TH3D &h1)Operator =.Definition TH3.cxx:4807; TH3D::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH3.h:380; TH3F3-D histogram with a float per channel (see TH1 documentation)Definition TH3.h:317; TH3F::operator/friend TH3F operator/(TH3F const &h1, TH3F const &h2)Operator /.Definition TH3.cxx:4649; TH3F::operator=TH3F & operator=(const TH3F &h1)Operator =.Definition TH3.cxx:4590; TH3F::operator+friend TH3F operator+(TH3F const &h1, TH3F const &h2)Operator +.Definition TH3.cxx:4613; TH3F::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH3.h:334; TH3F::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH3.h:356; TH3F::AddBinContentvoid AddBinContent(Int_t bin, Double_t w) overrideIncrement bin content by a weight w.Definition TH3.h:338; TH3F::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH3.cxx:4546; TH3F::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH3.h:355; TH3F::TH3FTH3F()Constructor.Definition TH3.cxx:4453; TH3F::~TH3F~TH3F() overrideDestructor.Definition TH3.cxx:4463; TH3F::operator-friend TH3F operator-(TH3F const &h1, TH3F const &h2)Operator -.Definition TH3.cxx:4625; TH3F::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Int_t binz, Double_t w) overrideIncrement 3D bin content by a weight w.Definition TH3.h:341; TH3F::operato",MatchSource.WIKI,doc/master/TH3_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8h_source.html
https://root.cern/doc/master/TH3_8h_source.html:30777,Deployability,update,update,30777,"inContentvoid AddBinContent(Int_t binx, Int_t biny, Int_t binz) overrideIncrement 3D bin content by 1.Definition TH3.h:340; TH3F::operator*friend TH3F operator*(Float_t c1, TH3F const &h1)Operator *.Definition TH3.cxx:4601; TH3I3-D histogram with an int per channel (see TH1 documentation)Definition TH3.h:237; TH3I::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH3.h:269; TH3I::operator=TH3I & operator=(const TH3I &h1)Operator =.Definition TH3.cxx:4167; TH3I::operator+friend TH3I operator+(TH3I const &h1, TH3I const &h2)Operator +.Definition TH3.cxx:4190; TH3I::operator-friend TH3I operator-(TH3I const &h1, TH3I const &h2)Operator _.Definition TH3.cxx:4202; TH3I::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH3.cxx:4112; TH3I::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH3.h:270; TH3I::TH3ITH3I()Constructor.Definition TH3.cxx:4039; TH3I::Copyvoid Copy(TObject &hnew) const overrideCopy this 3-D histogram structure to newth3.Definition TH3.cxx:4135; TH3I::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Int_t binz, Double_t w) overrideIncrement 3D bin content by a weight w.Definition TH3.h:255; TH3I::operator*friend TH3I operator*(Float_t c1, TH3I const &h1)Operator *.Definition TH3.cxx:4178; TH3I::operator/friend TH3I operator/(TH3I const &h1, TH3I const &h2)Operator /.Definition TH3.cxx:4226; TH3I::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH3.cxx:4156; TH3I::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Int_t binz) overrideIncrement 3D bin content by 1.Definition TH3.h:254; TH3I::~TH3I~TH3I() overrideDestructor.Definition TH3.",MatchSource.WIKI,doc/master/TH3_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8h_source.html
https://root.cern/doc/master/TH3_8h_source.html:32049,Deployability,update,update,32049,"ion TH3.cxx:4135; TH3I::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Int_t binz, Double_t w) overrideIncrement 3D bin content by a weight w.Definition TH3.h:255; TH3I::operator*friend TH3I operator*(Float_t c1, TH3I const &h1)Operator *.Definition TH3.cxx:4178; TH3I::operator/friend TH3I operator/(TH3I const &h1, TH3I const &h2)Operator /.Definition TH3.cxx:4226; TH3I::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH3.cxx:4156; TH3I::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Int_t binz) overrideIncrement 3D bin content by 1.Definition TH3.h:254; TH3I::~TH3I~TH3I() overrideDestructor.Definition TH3.cxx:4049; TH3I::operator*friend TH3I operator*(TH3I const &h1, Float_t c1)Definition TH3.h:262; TH3L3-D histogram with a long64 per channel (see TH1 documentation)Definition TH3.h:278; TH3L::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH3.h:309; TH3L::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH3.h:308; TH3L::Copyvoid Copy(TObject &hnew) const overrideCopy this 3-D histogram structure to newth3.Definition TH3.cxx:4342; TH3L::operator=TH3L & operator=(const TH3L &h1)Operator =.Definition TH3.cxx:4374; TH3L::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH3.cxx:4319; TH3L::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH3.cxx:4363; TH3L::operator+friend TH3L operator+(TH3L const &h1, TH3L const &h2)Operator +.Definition TH3.cxx:4397; TH3L::~TH3L~TH3L() overrideDestructor.Definition TH3.cxx:4256; TH3L::TH3LTH3L()Constructor.Definition",MatchSource.WIKI,doc/master/TH3_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8h_source.html
https://root.cern/doc/master/TH3_8h_source.html:34623,Deployability,update,update,34623,"nContent(Int_t binx, Int_t biny, Int_t binz, Double_t w) overrideIncrement 3D bin content by a weight w.Definition TH3.h:295; TH3S3-D histogram with a short per channel (see TH1 documentation)Definition TH3.h:197; TH3S::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Int_t binz) overrideIncrement 3D bin content by 1.Definition TH3.h:214; TH3S::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH3.cxx:3916; TH3S::operator*friend TH3S operator*(TH3S const &h1, Float_t c1)Definition TH3.h:222; TH3S::operator+friend TH3S operator+(TH3S const &h1, TH3S const &h2)Operator +.Definition TH3.cxx:3983; TH3S::operator/friend TH3S operator/(TH3S const &h1, TH3S const &h2)Operator /.Definition TH3.cxx:4019; TH3S::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH3.cxx:3872; TH3S::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH3.h:230; TH3S::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Int_t binz, Double_t w) overrideIncrement 3D bin content by a weight w.Definition TH3.h:215; TH3S::~TH3S~TH3S() overrideDestructor.Definition TH3.cxx:3809; TH3S::Copyvoid Copy(TObject &hnew) const overrideCopy this 3-D histogram structure to newth3.Definition TH3.cxx:3895; TH3S::operator*friend TH3S operator*(Float_t c1, TH3S const &h1)Operator *.Definition TH3.cxx:3971; TH3S::operator-friend TH3S operator-(TH3S const &h1, TH3S const &h2)Operator -.Definition TH3.cxx:3995; TH3S::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH3.h:229; TH3S::operator=TH3S & operator=(const TH3S &h1)Operator =.Definition TH3.cxx:3960; TH3S::TH3STH3S()Constructor.Definition TH3.cxx:3799; T",MatchSource.WIKI,doc/master/TH3_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8h_source.html
https://root.cern/doc/master/TH3_8h_source.html:39938,Integrability,depend,depending,39938,"const TH3 &)=delete; TH3::IntegralAndErrorvirtual Double_t IntegralAndError(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Int_t binz1, Int_t binz2, Double_t &err, Option_t *option="""") constReturn integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2] for a 3-D histogra...Definition TH3.cxx:1421; TH3::ProjectionZvirtual TH1D * ProjectionZ(const char *name=""_pz"", Int_t ixmin=0, Int_t ixmax=-1, Int_t iymin=0, Int_t iymax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D histogram along Z.Definition TH3.cxx:1812; TH3::SetBinContentvoid SetBinContent(Int_t binx, Int_t biny, Int_t binz, Double_t content) overrideDefinition TH3.h:132; TH3::ProjectionXvirtual TH1D * ProjectionX(const char *name=""_px"", Int_t iymin=0, Int_t iymax=-1, Int_t izmin=0, Int_t izmax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D histogram along X.Definition TH3.cxx:1747; TH3::Project3DProfilevirtual TProfile2D * Project3DProfile(Option_t *option=""xy"") constProject a 3-d histogram into a 2-d profile histograms depending on the option parameter option may co...Definition TH3.cxx:2806; TH3::fTsumwz2Double_t fTsumwz2Total Sum of weight*Z*Z.Definition TH3.h:38; TH3::fTsumwxyDouble_t fTsumwxyTotal Sum of weight*X*Y.Definition TH3.h:36; TH3::FillInt_t Fill(Double_t, Double_t) overrideIncrement bin with abscissa X with a weight w.Definition TH3.h:59; TH3::Project3Dvirtual TH1 * Project3D(Option_t *option=""x"") constProject a 3-d histogram into 1 or 2-d histograms depending on the option parameter,...Definition TH3.cxx:2409; TH3::GetBinErrorLowvirtual Double_t GetBinErrorLow(Int_t binx, Int_t biny, Int_t binz)Definition TH3.h:104; TH3::FillInt_t Fill(Double_t, const char *, Double_t)Definition TH3.h:61; TH3::GetBinWithContent3virtual Double_t GetBinWithContent3(Double_t c, Int_t &binx, Int_t &biny, Int_t &binz, Int_t firstx=0, Int_t lastx=0, Int_t firsty=0, Int_t lasty=0, Int_t firstz=0, Int_t lastz=0, Double_t maxdiff=0) constCompute first cell (bin",MatchSource.WIKI,doc/master/TH3_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8h_source.html
https://root.cern/doc/master/TH3_8h_source.html:40392,Integrability,depend,depending,40392,"option="""") constProject a 3-D histogram into a 1-D histogram along Z.Definition TH3.cxx:1812; TH3::SetBinContentvoid SetBinContent(Int_t binx, Int_t biny, Int_t binz, Double_t content) overrideDefinition TH3.h:132; TH3::ProjectionXvirtual TH1D * ProjectionX(const char *name=""_px"", Int_t iymin=0, Int_t iymax=-1, Int_t izmin=0, Int_t izmax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D histogram along X.Definition TH3.cxx:1747; TH3::Project3DProfilevirtual TProfile2D * Project3DProfile(Option_t *option=""xy"") constProject a 3-d histogram into a 2-d profile histograms depending on the option parameter option may co...Definition TH3.cxx:2806; TH3::fTsumwz2Double_t fTsumwz2Total Sum of weight*Z*Z.Definition TH3.h:38; TH3::fTsumwxyDouble_t fTsumwxyTotal Sum of weight*X*Y.Definition TH3.h:36; TH3::FillInt_t Fill(Double_t, Double_t) overrideIncrement bin with abscissa X with a weight w.Definition TH3.h:59; TH3::Project3Dvirtual TH1 * Project3D(Option_t *option=""x"") constProject a 3-d histogram into 1 or 2-d histograms depending on the option parameter,...Definition TH3.cxx:2409; TH3::GetBinErrorLowvirtual Double_t GetBinErrorLow(Int_t binx, Int_t biny, Int_t binz)Definition TH3.h:104; TH3::FillInt_t Fill(Double_t, const char *, Double_t)Definition TH3.h:61; TH3::GetBinWithContent3virtual Double_t GetBinWithContent3(Double_t c, Int_t &binx, Int_t &biny, Int_t &binz, Int_t firstx=0, Int_t lastx=0, Int_t firsty=0, Int_t lasty=0, Int_t firstz=0, Int_t lastz=0, Double_t maxdiff=0) constCompute first cell (binx,biny,binz) in the range [firstx,lastx](firsty,lasty][firstz,...Definition TH3.cxx:1151; TH3::DoFillProfileProjectionvoid DoFillProfileProjection(TProfile2D *p2, const TAxis &a1, const TAxis &a2, const TAxis &a3, Int_t bin1, Int_t bin2, Int_t bin3, Int_t inBin, Bool_t useWeights) constinternal function to fill the bins of the projected profile 2D histogram called from DoProjectProfile...Definition TH3.cxx:2550; TH3::RebinZvirtual TH3 * RebinZ(Int_t ngroup=2,",MatchSource.WIKI,doc/master/TH3_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8h_source.html
https://root.cern/doc/master/TH3_8h_source.html:37116,Performance,perform,performing,37116,"6; TH3::BufferEmptyInt_t BufferEmpty(Int_t action=0) overrideFill histogram with all entries in the buffer.Definition TH3.cxx:264; TH3::fTsumwyDouble_t fTsumwyTotal Sum of weight*Y.Definition TH3.h:34; TH3::FillInt_t Fill(const char *, const char *, Double_t)Definition TH3.h:63; TH3::BufferFillvirtual Int_t BufferFill(Double_t, Double_t, Double_t)Definition TH3.h:57; TH3::fTsumwy2Double_t fTsumwy2Total Sum of weight*Y*Y.Definition TH3.h:35; TH3::GetCovariancevirtual Double_t GetCovariance(Int_t axis1=1, Int_t axis2=2) constReturn covariance between axis1 and axis2.Definition TH3.cxx:1209; TH3::GetStatsvoid GetStats(Double_t *stats) const overrideFill the array stats from the contents of this histogram The array stats must be correctly dimensione...Definition TH3.cxx:1307; TH3::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH3.cxx:208; TH3::DoProject2Dvirtual TH2D * DoProject2D(const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF) constinternal method performing the projection to a 2D histogram called from TH3::Project3DDefinition TH3.cxx:2103; TH3::fTsumwxzDouble_t fTsumwxzTotal Sum of weight*X*Z.Definition TH3.h:39; TH3::FillRandomvoid FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr) overrideFill histogram following distribution in function fname.Definition TH3.cxx:833; TH3::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t binx, Int_t biny, Int_t binz)Definition TH3.h:105; TH3::KolmogorovTestDouble_t KolmogorovTest(const TH1 *h2, Option_t *option="""") const overrideStatistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test.Definition TH3.cxx:1532; TH3::ProjectionYvirtual TH1D * ProjectionY(const char *name=""_py"", Int_t ixmin=0, Int_t ixmax=-1, Int_t izmin=0, Int_t izmax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D histogram along Y.Definition TH3.cxx:1780; TH3::FillInt_t Fill(const char *, ",MatchSource.WIKI,doc/master/TH3_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8h_source.html
https://root.cern/doc/master/TH3_8h_source.html:42523,Performance,perform,performing,42523,"Double_t Integral(Option_t *option="""") const overrideReturn integral of bin contents.Definition TH3.cxx:1390; TH3::BufferFillvirtual Int_t BufferFill(Double_t x, Double_t y, Double_t z, Double_t w)Accumulate arguments in buffer.Definition TH3.cxx:339; TH3::SetShowProjectionvirtual void SetShowProjection(const char *option=""xy"", Int_t nbins=1)When the mouse is moved in a pad containing a 3-d view of this histogram a second canvas shows a proj...Definition TH3.cxx:3676; TH3::FillInt_t Fill(const char *, Double_t, Double_t)Definition TH3.h:62; TH3::RebinXTH3 * RebinX(Int_t ngroup=2, const char *newname="""") overrideRebin only the X axis see Rebin3D.Definition TH3.cxx:2906; TH3::GetCorrelationFactorvirtual Double_t GetCorrelationFactor(Int_t axis1=1, Int_t axis2=2) constReturn correlation factor between axis1 and axis2.Definition TH3.cxx:1191; TH3::DoProject1Dvirtual TH1D * DoProject1D(const char *name, const char *title, int imin1, int imax1, int imin2, int imax2, const TAxis *projAxis, const TAxis *axis1, const TAxis *axis2, Option_t *option) constinternal method performing the projection to 1D histogram called from TH3::Project3DDefinition TH3.cxx:1829; TH3::TH3TH3(const TH3 &)=delete; TH3::fTsumwzDouble_t fTsumwzTotal Sum of weight*Z.Definition TH3.h:37; TH3::GetBinContentDouble_t GetBinContent(Int_t binx, Int_t biny, Int_t binz) const overrideDefinition TH3.h:101; TH3::SetBinContentvoid SetBinContent(Int_t bin, Double_t content) overrideSet bin content.Definition TH3.cxx:3468; TH3::SetBinContentvoid SetBinContent(Int_t bin, Int_t, Double_t content) overrideDefinition TH3.h:131; TH3::fTsumwyzDouble_t fTsumwyzTotal Sum of weight*Y*Z.Definition TH3.h:40; TH3::TH3TH3()Default constructor.Definition TH3.cxx:74; TH3::GetBinInt_t GetBin(Int_t binx, Int_t biny, Int_t binz) const overrideSee comments in TH1::GetBin.Definition TH3.cxx:1117; TH3::FitSlicesZvirtual void FitSlicesZ(TF1 *f1=nullptr, Int_t binminx=1, Int_t binmaxx=0, Int_t binminy=1, Int_t binmaxy=0, Int_t cut=0, O",MatchSource.WIKI,doc/master/TH3_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8h_source.html
https://root.cern/doc/master/TH3_8h_source.html:37676,Testability,test,test,37676,"id GetStats(Double_t *stats) const overrideFill the array stats from the contents of this histogram The array stats must be correctly dimensione...Definition TH3.cxx:1307; TH3::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH3.cxx:208; TH3::DoProject2Dvirtual TH2D * DoProject2D(const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF) constinternal method performing the projection to a 2D histogram called from TH3::Project3DDefinition TH3.cxx:2103; TH3::fTsumwxzDouble_t fTsumwxzTotal Sum of weight*X*Z.Definition TH3.h:39; TH3::FillRandomvoid FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr) overrideFill histogram following distribution in function fname.Definition TH3.cxx:833; TH3::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t binx, Int_t biny, Int_t binz)Definition TH3.h:105; TH3::KolmogorovTestDouble_t KolmogorovTest(const TH1 *h2, Option_t *option="""") const overrideStatistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test.Definition TH3.cxx:1532; TH3::ProjectionYvirtual TH1D * ProjectionY(const char *name=""_py"", Int_t ixmin=0, Int_t ixmax=-1, Int_t izmin=0, Int_t izmax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D histogram along Y.Definition TH3.cxx:1780; TH3::FillInt_t Fill(const char *, Double_t) overrideIncrement bin with namex with a weight w.Definition TH3.h:60; TH3::GetRandom3virtual void GetRandom3(Double_t &x, Double_t &y, Double_t &, TRandom *rng=nullptr)Return 3 random numbers along axis x , y and z distributed according to the cell-contents of this 3-d...Definition TH3.cxx:1259; TH3::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH3.cxx:3449; TH3::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH3.cxx:224; TH3::~TH3~TH3() overrideDestructor.Definition TH3.cxx:200; TH3::FillInt_t Fil",MatchSource.WIKI,doc/master/TH3_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8h_source.html
https://root.cern/doc/master/TH3_8h_source.html:37755,Testability,test,test,37755,"id GetStats(Double_t *stats) const overrideFill the array stats from the contents of this histogram The array stats must be correctly dimensione...Definition TH3.cxx:1307; TH3::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH3.cxx:208; TH3::DoProject2Dvirtual TH2D * DoProject2D(const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF) constinternal method performing the projection to a 2D histogram called from TH3::Project3DDefinition TH3.cxx:2103; TH3::fTsumwxzDouble_t fTsumwxzTotal Sum of weight*X*Z.Definition TH3.h:39; TH3::FillRandomvoid FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr) overrideFill histogram following distribution in function fname.Definition TH3.cxx:833; TH3::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t binx, Int_t biny, Int_t binz)Definition TH3.h:105; TH3::KolmogorovTestDouble_t KolmogorovTest(const TH1 *h2, Option_t *option="""") const overrideStatistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test.Definition TH3.cxx:1532; TH3::ProjectionYvirtual TH1D * ProjectionY(const char *name=""_py"", Int_t ixmin=0, Int_t ixmax=-1, Int_t izmin=0, Int_t izmax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D histogram along Y.Definition TH3.cxx:1780; TH3::FillInt_t Fill(const char *, Double_t) overrideIncrement bin with namex with a weight w.Definition TH3.h:60; TH3::GetRandom3virtual void GetRandom3(Double_t &x, Double_t &y, Double_t &, TRandom *rng=nullptr)Return 3 random numbers along axis x , y and z distributed according to the cell-contents of this 3-d...Definition TH3.cxx:1259; TH3::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH3.cxx:3449; TH3::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH3.cxx:224; TH3::~TH3~TH3() overrideDestructor.Definition TH3.cxx:200; TH3::FillInt_t Fil",MatchSource.WIKI,doc/master/TH3_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8h_source.html
https://root.cern/doc/master/THbookFile_8cxx.html:623,Integrability,depend,dependency,623,". ROOT: hist/hbook/src/THbookFile.cxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Macros |; Functions |; Variables ; THbookFile.cxx File Reference. #include <cstdlib>; #include <cstring>; #include <cctype>; #include ""TROOT.h""; #include ""THbookFile.h""; #include ""TH2.h""; #include ""THbookTree.h""; #include ""THbookBranch.h""; #include ""THbookKey.h""; #include ""TGraph.h""; #include ""TProfile.h""; #include ""TTreeFormula.h""; #include ""TLeafI.h""; #include ""TBrowser.h""; #include ""TSystem.h""; #include ""TMath.h""; #include ""strlcpy.h""; #include ""snprintf.h"". Include dependency graph for THbookFile.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  . Macros; #define DEFCHAR   const char*;  ; #define hbnam   hbnam_;  ; #define hbnamc   hbnamc_;  ; #define hbname   hbname_;  ; #define hcbits   hcbits_;  ; #define hcbook   hcbook_;  ; #define hcdir   hcdir_;  ; #define hdcofl   hdcofl_;  ; #define hdelet   hdelet_;  ; #define hgive   hgive_;  ; #define hgiven   hgiven_;  ; #define hgnf   hgnf_;  ; #define hgnpar   hgnpar_;  ; #define hgnt   hgnt_;  ; #define hgnt1   hgnt1_;  ; #define hgntf   hgntf_;  ; #define hi   hi_;  ; #define hie   hie_;  ; #define hif   hif_;  ; #define hij   hij_;  ; #define hije   hije_;  ; #define hijxy   hijxy_;  ; #define hix   hix_;  ; #define hldir   hldir_;  ; #define hlimit   hlimit_;  ; #define hmaxim   hmaxim_;  ; #define hminim   hminim_;  ; #define hnoent   hnoent_;  ; #define hntvar2   hntvar2_;  ; #define hntvar3   hntvar3_;  ; #define hrend   hrend_;  ; #define hrin   hrin_;  ; #define hropen   hropen_;  ; #define PASSCHAR(string)   string;  ; #define pawc   pawc_;  ; #define PAWC_SIZE   4000000;  ; #define quest   quest_;  ; #define rzcl   rzcl_;  ; #defin",MatchSource.WIKI,doc/master/THbookFile_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THbookFile_8cxx.html
https://root.cern/doc/master/THbookFile_8cxx_source.html:28565,Availability,error,error,28565,,MatchSource.WIKI,doc/master/THbookFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THbookFile_8cxx_source.html
https://root.cern/doc/master/THbookFile_8cxx_source.html:28651,Availability,error,error,28651,,MatchSource.WIKI,doc/master/THbookFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THbookFile_8cxx_source.html
https://root.cern/doc/master/THbookFile_8cxx_source.html:37009,Availability,error,error,37009,"temDefinition TSystem.h:561; TTreeFormula.h; snprintf#define snprintfDefinition civetweb.c:1540; TBranch::GetListOfLeavesTObjArray * GetListOfLeaves()Definition TBranch.h:247; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::SetPointvirtual void SetPoint(Int_t i, Double_t x, Double_t y)Set x and y values for point number i.Definition TGraph.cxx:2342; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn bin center for 1D histogram.Definition TH1.cxx:9141; TH1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Definition TH1.h:404; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create structure to store sum of squares of weights.Definition TH1.cxx:9020; TH1::SetEntriesvirtual void SetEntries(Double_t n)Definition TH1.h:391; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; THbookBranchHBOOK Branch.Definition THbookBranch.h:26; THbookBranch::SetAddressvoid SetAddress(void *addobj) overrideSet address of this branch See important remark in the header of THbookTree.Definition THbookBranch.cxx:75; THbookBranch::SetBlockNamevoid SetBlockName(const char *name)Definition THbookBranch.h:40; THbookFileThis class is",MatchSource.WIKI,doc/master/THbookFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THbookFile_8cxx_source.html
https://root.cern/doc/master/THbookFile_8cxx_source.html:42996,Availability,error,error,42996,"ar *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TProfileProfile Histogram.Definition TProfile.h:32; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TTreeFormulaUsed to pass a selection expression to the Tree drawing routine.Definition TTreeFormula.h:58; TTreeFormula::GetLeafvirtual TLeaf * GetLeaf(Int_t n) constReturn leaf corresponding to serial number n.Definition TTreeFormula.cxx:4465; TTreeFormula::GetNcodes",MatchSource.WIKI,doc/master/THbookFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THbookFile_8cxx_source.html
https://root.cern/doc/master/THbookFile_8cxx_source.html:689,Integrability,interface,interface,689,". ROOT: hist/hbook/src/THbookFile.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. THbookFile.cxx. Go to the documentation of this file. 1// @(#)root/hbook:$Id$; 2// Author: Rene Brun 18/02/2002; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class THbookFile; 13 \ingroup Hist; 14 This class is an interface to the Hbook objects in Hbook files.; 15 Any Hbook object (1-D, 2-D, Profile, RWN or CWN can be read; 16 ; 17 NB: a THbookFile can only be used in READ mode; 18 Use the utility in $ROOTSYS/bin/h2root to convert Hbook to Root; 19 ; 20 Example of use:; 21 ; 22 gSystem->Load(""libHbook"");; 23 THbookFile f(""myfile.hbook"");; 24 f.ls();; 25 TH1F *h1 = (TH1F*)f.Get(1); //import histogram ID=1 in h1; 26 h1->Fit(""gaus"");; 27 THbookTree *T = (THbookTree*)f.Get(111); //import ntuple header; 28 T->Print(); //show the Hbook ntuple variables; 29 T->Draw(""x"",""y<0""); // as in normal TTree::Draw; 30 ; 31 THbookFile can be browsed via TBrowser.; 32*/; 33 ; 34#include <cstdlib>; 35#include <cstring>; 36#include <cctype>; 37 ; 38#include ""TROOT.h""; 39#include ""THbookFile.h""; 40#include ""TH2.h""; 41#include ""THbookTree.h""; 42#include ""THbookBranch.h""; 43#include ""THbookKey.h""; 44#include ""TGraph.h""; 45#include ""TProfile.h""; 46#include ""TTreeFormula.h""; 47#include ""TLeafI.h""; 48#include ""TBrowser.h""; 49#include ""TSystem.h""; 50#include ""TMath.h""; 51#include ""strlcpy.h""; 52#include ""snprintf.h""; 53 ; 54// NOTE: THe following comments and declarations are a duplicate; 55// of those in main/src/h2root.cxx; 56 ; 57// Note that with gcc3.4 or above the size of PAWC_SIZE must be the same; 58// as in the Fortran ",MatchSource.WIKI,doc/master/THbookFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THbookFile_8cxx_source.html
https://root.cern/doc/master/THbookFile_8cxx_source.html:38033,Integrability,interface,interface,38033,"hat this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create structure to store sum of squares of weights.Definition TH1.cxx:9020; TH1::SetEntriesvirtual void SetEntries(Double_t n)Definition TH1.h:391; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; THbookBranchHBOOK Branch.Definition THbookBranch.h:26; THbookBranch::SetAddressvoid SetAddress(void *addobj) overrideSet address of this branch See important remark in the header of THbookTree.Definition THbookBranch.cxx:75; THbookBranch::SetBlockNamevoid SetBlockName(const char *name)Definition THbookBranch.h:40; THbookFileThis class is an interface to the Hbook objects in Hbook files.Definition THbookFile.h:29; THbookFile::InitLeavesvoid InitLeaves(Int_t id, Int_t var, TTreeFormula *formula)This function is called from the first entry in TTreePlayer::InitLoop It analyzes the list of variabl...Definition THbookFile.cxx:554; THbookFile::fLunInt_t fLunDefinition THbookFile.h:32; THbookFile::GetTObject * Get(Int_t id)import Hbook object with identifier idd in memoryDefinition THbookFile.cxx:445; THbookFile::fgPawInitstatic Bool_t fgPawInitDefinition THbookFile.h:38; THbookFile::fLreclInt_t fLreclDefinition THbookFile.h:33; THbookFile::DeleteIDvoid DeleteID(Int_t id)remove id from file and memoryDefinition THbookFile.cxx:421; THbookFile::GetEntryBranchInt_t GetEntryBranch(Int_t entry, Int_t id)Read in memory only the branch bname.Definition THbookFile.cxx:531; THbookFile::Closevirtual void Close(Option_t *option="""")Close the Hbook file.Definition THbookFile.cxx:398; THbookFile::fCurDirTString fCurDirDefinition THbookFile.h:36; THbo",MatchSource.WIKI,doc/master/THbookFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THbookFile_8cxx_source.html
https://root.cern/doc/master/THbookFile_8cxx_source.html:41313,Integrability,wrap,wrapper,41313,"is Hbook file to a Root file with name rootname.Definition THbookFile.cxx:607; THbookFile::IsOpenvirtual Bool_t IsOpen() constReturns kTRUE in case file is open and kFALSE if file is not open.Definition THbookFile.cxx:578; THbookFile::Convert2Dvirtual TObject * Convert2D(Int_t id)Convert an Hbook 2-d histogram into a Root TH2F.Definition THbookFile.cxx:981; THbookFile::ConvertCWNvirtual TObject * ConvertCWN(Int_t id)Convert the Column-Wise-Ntuple id to a Root Tree.Definition THbookFile.cxx:647; THbookFile::Browsevoid Browse(TBrowser *b) overrideto be implementedDefinition THbookFile.cxx:350; THbookFile::GetEntryInt_t GetEntry(Int_t entry, Int_t id, Int_t atype, Float_t *x)Read in memory all columns of entry number of ntuple id from the Hbook file.Definition THbookFile.cxx:517; THbookFile::ConvertRWNvirtual TObject * ConvertRWN(Int_t id)Convert the Row-Wise-Ntuple id to a Root Tree.Definition THbookFile.cxx:808; THbookKeyHBOOK Key.Definition THbookKey.h:26; THbookTreeA wrapper class supporting Hbook ntuples (CWN and RWN).Definition THbookTree.h:30; TLeafIA TLeaf for an Integer data type.Definition TLeafI.h:27; TLeafI::GetMaximumInt_t GetMaximum() const overrideDefinition TLeafI.h:44; TLeafI::SetMaximumvirtual void SetMaximum(Int_t max)Definition TLeafI.h:56; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TLeaf::GetLeafCountvirtual TLeaf * GetLeafCount() constIf this leaf stores a variable-sized array or a multi-dimensional array whose last dimension has vari...Definition TLeaf.h:121; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNamedThe TNamed class is the b",MatchSource.WIKI,doc/master/THbookFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THbookFile_8cxx_source.html
https://root.cern/doc/master/THbookFile_8cxx_source.html:43002,Integrability,message,message,43002,"ar *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TProfileProfile Histogram.Definition TProfile.h:32; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TTreeFormulaUsed to pass a selection expression to the Tree drawing routine.Definition TTreeFormula.h:58; TTreeFormula::GetLeafvirtual TLeaf * GetLeaf(Int_t n) constReturn leaf corresponding to serial number n.Definition TTreeFormula.cxx:4465; TTreeFormula::GetNcodes",MatchSource.WIKI,doc/master/THbookFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THbookFile_8cxx_source.html
https://root.cern/doc/master/THbookFile_8cxx_source.html:43798,Integrability,rout,routine,43798,"med::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TProfileProfile Histogram.Definition TProfile.h:32; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TTreeFormulaUsed to pass a selection expression to the Tree drawing routine.Definition TTreeFormula.h:58; TTreeFormula::GetLeafvirtual TLeaf * GetLeaf(Int_t n) constReturn leaf corresponding to serial number n.Definition TTreeFormula.cxx:4465; TTreeFormula::GetNcodesvirtual Int_t GetNcodes() constDefinition TTreeFormula.h:196; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; h1TH1F * h1Definition legend1.C:5; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662. histhbooksrcTHbookFile.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/THbookFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THbookFile_8cxx_source.html
https://root.cern/doc/master/THbookFile_8cxx_source.html:1222,Modifiability,variab,variables,1222,"002; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class THbookFile; 13 \ingroup Hist; 14 This class is an interface to the Hbook objects in Hbook files.; 15 Any Hbook object (1-D, 2-D, Profile, RWN or CWN can be read; 16 ; 17 NB: a THbookFile can only be used in READ mode; 18 Use the utility in $ROOTSYS/bin/h2root to convert Hbook to Root; 19 ; 20 Example of use:; 21 ; 22 gSystem->Load(""libHbook"");; 23 THbookFile f(""myfile.hbook"");; 24 f.ls();; 25 TH1F *h1 = (TH1F*)f.Get(1); //import histogram ID=1 in h1; 26 h1->Fit(""gaus"");; 27 THbookTree *T = (THbookTree*)f.Get(111); //import ntuple header; 28 T->Print(); //show the Hbook ntuple variables; 29 T->Draw(""x"",""y<0""); // as in normal TTree::Draw; 30 ; 31 THbookFile can be browsed via TBrowser.; 32*/; 33 ; 34#include <cstdlib>; 35#include <cstring>; 36#include <cctype>; 37 ; 38#include ""TROOT.h""; 39#include ""THbookFile.h""; 40#include ""TH2.h""; 41#include ""THbookTree.h""; 42#include ""THbookBranch.h""; 43#include ""THbookKey.h""; 44#include ""TGraph.h""; 45#include ""TProfile.h""; 46#include ""TTreeFormula.h""; 47#include ""TLeafI.h""; 48#include ""TBrowser.h""; 49#include ""TSystem.h""; 50#include ""TMath.h""; 51#include ""strlcpy.h""; 52#include ""snprintf.h""; 53 ; 54// NOTE: THe following comments and declarations are a duplicate; 55// of those in main/src/h2root.cxx; 56 ; 57// Note that with gcc3.4 or above the size of PAWC_SIZE must be the same; 58// as in the Fortran definition in hbook.f and zebra; 59// Also, the arrays must be declared extern like on Windows; 60#define PAWC_SIZE 4000000; 61 ; 62// Define the names of the Fortran common blocks for the different OSs; 63 ; 64#ifndef WIN32; 65# define paw",MatchSource.WIKI,doc/master/THbookFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THbookFile_8cxx_source.html
https://root.cern/doc/master/THbookFile_8cxx_source.html:16801,Modifiability,variab,variables,16801,"used in GetEntry; 486 if (obj) {; 487 fList->Add(obj);; 488 ((THbookTree *)obj)->SetTitle(GetName());; 489 }; 490 return obj;; 491 }; 492 if (hcbits[0] && hcbits[7]) {; 493 obj = ConvertProfile(id);; 494 hdelet(id);; 495 if (obj) fList->Add(obj);; 496 return obj;; 497 }; 498 if (hcbits[0]) {; 499 obj = Convert1D(id);; 500 hdelet(id);; 501 if (obj) fList->Add(obj);; 502 return obj;; 503 }; 504 if (hcbits[1] || hcbits[2]) {; 505 obj = Convert2D(id);; 506 hdelet(id);; 507 if (obj) fList->Add(obj);; 508 return obj;; 509 }; 510 return obj;; 511}; 512 ; 513 ; 514////////////////////////////////////////////////////////////////////////////////; 515/// Read in memory all columns of entry number of ntuple id from the Hbook file; 516 ; 517Int_t THbookFile::GetEntry(Int_t entry, Int_t id, Int_t atype, Float_t *x); 518{; 519 Int_t ier = 0;; 520 if (atype == 0) {; 521 hgnf(id,entry+1,x[0],ier);; 522 } else {; 523 hgnt(id,entry+1,ier);; 524 }; 525 return 0;; 526}; 527 ; 528////////////////////////////////////////////////////////////////////////////////; 529/// Read in memory only the branch bname; 530 ; 531Int_t THbookFile::GetEntryBranch(Int_t entry, Int_t id); 532{; 533 if (entry == gLastEntry) return 0;; 534 gLastEntry = entry;; 535 Int_t ier = 0;; 536 //uses the fast read method using the Hbook tables computed in InitLeaves; 537 hgntf(id,entry+1,ier);; 538 //old alternative slow method; 539//#ifndef WIN32; 540// hgnt1(id,PASSCHAR(blockname),PASSCHAR(branchname),0,-1,entry+1,ier,strlen(blockname),strlen(branchname));; 541//#else; 542// hgnt1(id,PASSCHAR(blockname),PASSCHAR(branchname),0,-1,entry+1,ier);; 543//#endif; 544 return 0;; 545}; 546 ; 547 ; 548////////////////////////////////////////////////////////////////////////////////; 549/// This function is called from the first entry in TTreePlayer::InitLoop; 550/// It analyzes the list of variables involved in the current query; 551/// and pre-process the internal Hbook tables to speed-up the search; 552/// at the next entries.",MatchSource.WIKI,doc/master/THbookFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THbookFile_8cxx_source.html
https://root.cern/doc/master/THbookFile_8cxx_source.html:38282,Modifiability,variab,variabl,38282,"n with abscissa X by 1.Definition TH1.cxx:3344; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create structure to store sum of squares of weights.Definition TH1.cxx:9020; TH1::SetEntriesvirtual void SetEntries(Double_t n)Definition TH1.h:391; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; THbookBranchHBOOK Branch.Definition THbookBranch.h:26; THbookBranch::SetAddressvoid SetAddress(void *addobj) overrideSet address of this branch See important remark in the header of THbookTree.Definition THbookBranch.cxx:75; THbookBranch::SetBlockNamevoid SetBlockName(const char *name)Definition THbookBranch.h:40; THbookFileThis class is an interface to the Hbook objects in Hbook files.Definition THbookFile.h:29; THbookFile::InitLeavesvoid InitLeaves(Int_t id, Int_t var, TTreeFormula *formula)This function is called from the first entry in TTreePlayer::InitLoop It analyzes the list of variabl...Definition THbookFile.cxx:554; THbookFile::fLunInt_t fLunDefinition THbookFile.h:32; THbookFile::GetTObject * Get(Int_t id)import Hbook object with identifier idd in memoryDefinition THbookFile.cxx:445; THbookFile::fgPawInitstatic Bool_t fgPawInitDefinition THbookFile.h:38; THbookFile::fLreclInt_t fLreclDefinition THbookFile.h:33; THbookFile::DeleteIDvoid DeleteID(Int_t id)remove id from file and memoryDefinition THbookFile.cxx:421; THbookFile::GetEntryBranchInt_t GetEntryBranch(Int_t entry, Int_t id)Read in memory only the branch bname.Definition THbookFile.cxx:531; THbookFile::Closevirtual void Close(Option_t *option="""")Close the Hbook file.Definition THbookFile.cxx:398; THbookFile::fCurDirTString fCurDirDefinition THbookFile.h:36; THbookFile::fListTList * fListDefinition THbookFile.h:34; THbookFile::lsvoid ls(const char *path="""") const overrideList contents of Hbook directory.Definition T",MatchSource.WIKI,doc/master/THbookFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THbookFile_8cxx_source.html
https://root.cern/doc/master/THbookFile_8cxx_source.html:41795,Modifiability,variab,variable-sized,41795," Tree.Definition THbookFile.cxx:647; THbookFile::Browsevoid Browse(TBrowser *b) overrideto be implementedDefinition THbookFile.cxx:350; THbookFile::GetEntryInt_t GetEntry(Int_t entry, Int_t id, Int_t atype, Float_t *x)Read in memory all columns of entry number of ntuple id from the Hbook file.Definition THbookFile.cxx:517; THbookFile::ConvertRWNvirtual TObject * ConvertRWN(Int_t id)Convert the Row-Wise-Ntuple id to a Root Tree.Definition THbookFile.cxx:808; THbookKeyHBOOK Key.Definition THbookKey.h:26; THbookTreeA wrapper class supporting Hbook ntuples (CWN and RWN).Definition THbookTree.h:30; TLeafIA TLeaf for an Integer data type.Definition TLeafI.h:27; TLeafI::GetMaximumInt_t GetMaximum() const overrideDefinition TLeafI.h:44; TLeafI::SetMaximumvirtual void SetMaximum(Int_t max)Definition TLeafI.h:56; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TLeaf::GetLeafCountvirtual TLeaf * GetLeafCount() constIf this leaf stores a variable-sized array or a multi-dimensional array whose last dimension has vari...Definition TLeaf.h:121; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::UncheckedAtTObject ",MatchSource.WIKI,doc/master/THbookFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THbookFile_8cxx_source.html
https://root.cern/doc/master/THbookFile_8cxx_source.html:9682,Testability,log,logical,9682,");; 244extern ""C"" void type_of_call hldir(DEFCHAR,DEFCHAR);; 245#endif; 246 ; 247Bool_t THbookFile::fgPawInit = kFALSE;; 248Int_t *THbookFile::fgLuns = nullptr;; 249 ; 250ClassImp(THbookFile);; 251 ; 252////////////////////////////////////////////////////////////////////////////////; 253///the constructor; 254 ; 255THbookFile::THbookFile() : fLun(0),fLrecl(0); 256{; 257 fList = new TList();; 258 fKeys = new TList();; 259}; 260 ; 261////////////////////////////////////////////////////////////////////////////////; 262/// Constructor for an HBook file object; 263 ; 264THbookFile::THbookFile(const char *fname, Int_t lrecl); 265 :TNamed(fname,""""); 266{; 267 // Initialize the Hbook/Zebra store; 268 Int_t i;; 269 if (!fgPawInit) {; 270 fgPawInit = kTRUE;; 271 lq = &pawc[9];; 272 iq = &pawc[17];; 273 void *qq = iq;; 274 q = (float*)qq;; 275 int pawc_size = PAWC_SIZE;; 276 hlimit(pawc_size);; 277 fgLuns = new Int_t[10];; 278 for (i=0;i<10;i++) fgLuns[i] = 0;; 279 }; 280 ; 281 //find a free logical unit (max 10); 282 fLun = 0;; 283 for (i=0;i<10;i++) {; 284 if (fgLuns[i] == 0) {; 285 fLun = 10+i;; 286 fgLuns[i] = 1;; 287 break;; 288 }; 289 }; 290 if (fLun == 0) {; 291 Error(""THbookFile"",""Too many HbookFiles\n"");; 292 return;; 293 }; 294 char topdir[20];; 295 snprintf(topdir,19,""lun%d"",fLun);; 296 ; 297 Int_t ier = 0;; 298#ifndef WIN32; 299 hropen(fLun,PASSCHAR(topdir),PASSCHAR(fname),PASSCHAR(""p""),lrecl,ier,strlen(topdir),strlen(fname),1);; 300#else; 301 hropen(fLun,PASSCHAR(topdir),PASSCHAR(fname),PASSCHAR(""p""),lrecl,ier);; 302#endif; 303 fLrecl = lrecl;; 304 SetTitle(topdir);; 305 snprintf(topdir,19,""//lun%d"",fLun);; 306 fCurDir = topdir;; 307 ; 308 if (ier) printf ("" Error on hropen was %d \n"", ier);; 309 if (quest[0]) {; 310 printf(""Error cannot open input file: %s\n"",fname);; 311 }; 312 if (ier || quest[0]) {; 313 fgLuns[fLun-10]=0;; 314 fLun = 0;; 315 fList = nullptr;; 316 fKeys = nullptr;; 317 MakeZombie();; 318 return;; 319 }; 320 ; 321 gROOT->GetListOfBrowsables()->A",MatchSource.WIKI,doc/master/THbookFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THbookFile_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:3040,Availability,error,error,3040,,MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:8187,Availability,error,error,8187,"ts image is automatically removed; 189from the pad.; 190 ; 191To create a copy of the histogram when drawing it, one can use; 192`TH1::DrawClone()`. This will clone the histogram and allow to change; 193and delete the original one without affecting the clone.; 194 ; 195 ; 196\anchor HP01; 197### Histograms' plotting options; 198 ; 199 ; 200Most options can be concatenated with or without spaces or commas, for example:; 201 ; 202 h->Draw(""E1 SAME"");; 203 ; 204The options are not case sensitive:; 205 ; 206 h->Draw(""e1 same"");; 207 ; 208 ; 209The default drawing option can be set with `TH1::SetOption` and retrieve; 210using `TH1::GetOption`:; 211 ; 212 root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; 213 root [1] h->Draw(""E""); // Draw ""h"" using error bars; 214 root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; 215 root [4] h->Draw(); // Draw ""h"" using error bars; 216 root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; 217 (const Option_t* 0xa3ff948)""E""; 218 ; 219 ; 220\anchor HP01a; 221#### Options supported for 1D and 2D histograms; 222 ; 223| Option | Description |; 224|----------|-------------------------------------------------------------------|; 225| ""E"" | Draw error bars. |; 226| ""AXIS"" | Draw only axis. |; 227| ""AXIG"" | Draw only grid (if the grid is requested). |; 228| \anchor OPTHIST ""HIST"" | When an histogram has errors it is visualized by default with error bars. To visualize it without errors use the option ""HIST"" together with the required option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the histogram and not the associated function(s). |; 229| ""FUNC"" | When an histogram has a fitted function, this option allows to draw the fit result only. |; 230| ""SAME"" | Superimpose on previous picture in the same pad. |; 231| ""SAMES"" | Same as ""SAME"" and draw the statistics box|; 232| ""PFC"" | Palette Fill Color: histogram's fill color is taken in the current palette. |; 2",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:8319,Availability,error,error,8319,"ts image is automatically removed; 189from the pad.; 190 ; 191To create a copy of the histogram when drawing it, one can use; 192`TH1::DrawClone()`. This will clone the histogram and allow to change; 193and delete the original one without affecting the clone.; 194 ; 195 ; 196\anchor HP01; 197### Histograms' plotting options; 198 ; 199 ; 200Most options can be concatenated with or without spaces or commas, for example:; 201 ; 202 h->Draw(""E1 SAME"");; 203 ; 204The options are not case sensitive:; 205 ; 206 h->Draw(""e1 same"");; 207 ; 208 ; 209The default drawing option can be set with `TH1::SetOption` and retrieve; 210using `TH1::GetOption`:; 211 ; 212 root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; 213 root [1] h->Draw(""E""); // Draw ""h"" using error bars; 214 root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; 215 root [4] h->Draw(); // Draw ""h"" using error bars; 216 root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; 217 (const Option_t* 0xa3ff948)""E""; 218 ; 219 ; 220\anchor HP01a; 221#### Options supported for 1D and 2D histograms; 222 ; 223| Option | Description |; 224|----------|-------------------------------------------------------------------|; 225| ""E"" | Draw error bars. |; 226| ""AXIS"" | Draw only axis. |; 227| ""AXIG"" | Draw only grid (if the grid is requested). |; 228| \anchor OPTHIST ""HIST"" | When an histogram has errors it is visualized by default with error bars. To visualize it without errors use the option ""HIST"" together with the required option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the histogram and not the associated function(s). |; 229| ""FUNC"" | When an histogram has a fitted function, this option allows to draw the fit result only. |; 230| ""SAME"" | Superimpose on previous picture in the same pad. |; 231| ""SAMES"" | Same as ""SAME"" and draw the statistics box|; 232| ""PFC"" | Palette Fill Color: histogram's fill color is taken in the current palette. |; 2",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:8662,Availability,error,error,8662,"ts image is automatically removed; 189from the pad.; 190 ; 191To create a copy of the histogram when drawing it, one can use; 192`TH1::DrawClone()`. This will clone the histogram and allow to change; 193and delete the original one without affecting the clone.; 194 ; 195 ; 196\anchor HP01; 197### Histograms' plotting options; 198 ; 199 ; 200Most options can be concatenated with or without spaces or commas, for example:; 201 ; 202 h->Draw(""E1 SAME"");; 203 ; 204The options are not case sensitive:; 205 ; 206 h->Draw(""e1 same"");; 207 ; 208 ; 209The default drawing option can be set with `TH1::SetOption` and retrieve; 210using `TH1::GetOption`:; 211 ; 212 root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; 213 root [1] h->Draw(""E""); // Draw ""h"" using error bars; 214 root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; 215 root [4] h->Draw(); // Draw ""h"" using error bars; 216 root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; 217 (const Option_t* 0xa3ff948)""E""; 218 ; 219 ; 220\anchor HP01a; 221#### Options supported for 1D and 2D histograms; 222 ; 223| Option | Description |; 224|----------|-------------------------------------------------------------------|; 225| ""E"" | Draw error bars. |; 226| ""AXIS"" | Draw only axis. |; 227| ""AXIG"" | Draw only grid (if the grid is requested). |; 228| \anchor OPTHIST ""HIST"" | When an histogram has errors it is visualized by default with error bars. To visualize it without errors use the option ""HIST"" together with the required option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the histogram and not the associated function(s). |; 229| ""FUNC"" | When an histogram has a fitted function, this option allows to draw the fit result only. |; 230| ""SAME"" | Superimpose on previous picture in the same pad. |; 231| ""SAMES"" | Same as ""SAME"" and draw the statistics box|; 232| ""PFC"" | Palette Fill Color: histogram's fill color is taken in the current palette. |; 2",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:8822,Availability,error,errors,8822,"example:; 201 ; 202 h->Draw(""E1 SAME"");; 203 ; 204The options are not case sensitive:; 205 ; 206 h->Draw(""e1 same"");; 207 ; 208 ; 209The default drawing option can be set with `TH1::SetOption` and retrieve; 210using `TH1::GetOption`:; 211 ; 212 root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; 213 root [1] h->Draw(""E""); // Draw ""h"" using error bars; 214 root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; 215 root [4] h->Draw(); // Draw ""h"" using error bars; 216 root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; 217 (const Option_t* 0xa3ff948)""E""; 218 ; 219 ; 220\anchor HP01a; 221#### Options supported for 1D and 2D histograms; 222 ; 223| Option | Description |; 224|----------|-------------------------------------------------------------------|; 225| ""E"" | Draw error bars. |; 226| ""AXIS"" | Draw only axis. |; 227| ""AXIG"" | Draw only grid (if the grid is requested). |; 228| \anchor OPTHIST ""HIST"" | When an histogram has errors it is visualized by default with error bars. To visualize it without errors use the option ""HIST"" together with the required option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the histogram and not the associated function(s). |; 229| ""FUNC"" | When an histogram has a fitted function, this option allows to draw the fit result only. |; 230| ""SAME"" | Superimpose on previous picture in the same pad. |; 231| ""SAMES"" | Same as ""SAME"" and draw the statistics box|; 232| ""PFC"" | Palette Fill Color: histogram's fill color is taken in the current palette. |; 233| ""PLC"" | Palette Line Color: histogram's line color is taken in the current palette. |; 234| ""PMC"" | Palette Marker Color: histogram's marker color is taken in the current palette. |; 235| ""LEGO"" | Draw a lego plot with hidden line removal. |; 236| ""LEGO1"" | Draw a lego plot with hidden surface removal. |; 237| ""LEGO2"" | Draw a lego plot using colors to show the cell contents When the option ""0"" is used wit",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:8862,Availability,error,error,8862,"example:; 201 ; 202 h->Draw(""E1 SAME"");; 203 ; 204The options are not case sensitive:; 205 ; 206 h->Draw(""e1 same"");; 207 ; 208 ; 209The default drawing option can be set with `TH1::SetOption` and retrieve; 210using `TH1::GetOption`:; 211 ; 212 root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; 213 root [1] h->Draw(""E""); // Draw ""h"" using error bars; 214 root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; 215 root [4] h->Draw(); // Draw ""h"" using error bars; 216 root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; 217 (const Option_t* 0xa3ff948)""E""; 218 ; 219 ; 220\anchor HP01a; 221#### Options supported for 1D and 2D histograms; 222 ; 223| Option | Description |; 224|----------|-------------------------------------------------------------------|; 225| ""E"" | Draw error bars. |; 226| ""AXIS"" | Draw only axis. |; 227| ""AXIG"" | Draw only grid (if the grid is requested). |; 228| \anchor OPTHIST ""HIST"" | When an histogram has errors it is visualized by default with error bars. To visualize it without errors use the option ""HIST"" together with the required option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the histogram and not the associated function(s). |; 229| ""FUNC"" | When an histogram has a fitted function, this option allows to draw the fit result only. |; 230| ""SAME"" | Superimpose on previous picture in the same pad. |; 231| ""SAMES"" | Same as ""SAME"" and draw the statistics box|; 232| ""PFC"" | Palette Fill Color: histogram's fill color is taken in the current palette. |; 233| ""PLC"" | Palette Line Color: histogram's line color is taken in the current palette. |; 234| ""PMC"" | Palette Marker Color: histogram's marker color is taken in the current palette. |; 235| ""LEGO"" | Draw a lego plot with hidden line removal. |; 236| ""LEGO1"" | Draw a lego plot with hidden surface removal. |; 237| ""LEGO2"" | Draw a lego plot using colors to show the cell contents When the option ""0"" is used wit",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:8898,Availability,error,errors,8898,"1 same"");; 207 ; 208 ; 209The default drawing option can be set with `TH1::SetOption` and retrieve; 210using `TH1::GetOption`:; 211 ; 212 root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; 213 root [1] h->Draw(""E""); // Draw ""h"" using error bars; 214 root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; 215 root [4] h->Draw(); // Draw ""h"" using error bars; 216 root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; 217 (const Option_t* 0xa3ff948)""E""; 218 ; 219 ; 220\anchor HP01a; 221#### Options supported for 1D and 2D histograms; 222 ; 223| Option | Description |; 224|----------|-------------------------------------------------------------------|; 225| ""E"" | Draw error bars. |; 226| ""AXIS"" | Draw only axis. |; 227| ""AXIG"" | Draw only grid (if the grid is requested). |; 228| \anchor OPTHIST ""HIST"" | When an histogram has errors it is visualized by default with error bars. To visualize it without errors use the option ""HIST"" together with the required option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the histogram and not the associated function(s). |; 229| ""FUNC"" | When an histogram has a fitted function, this option allows to draw the fit result only. |; 230| ""SAME"" | Superimpose on previous picture in the same pad. |; 231| ""SAMES"" | Same as ""SAME"" and draw the statistics box|; 232| ""PFC"" | Palette Fill Color: histogram's fill color is taken in the current palette. |; 233| ""PLC"" | Palette Line Color: histogram's line color is taken in the current palette. |; 234| ""PMC"" | Palette Marker Color: histogram's marker color is taken in the current palette. |; 235| ""LEGO"" | Draw a lego plot with hidden line removal. |; 236| ""LEGO1"" | Draw a lego plot with hidden surface removal. |; 237| ""LEGO2"" | Draw a lego plot using colors to show the cell contents When the option ""0"" is used with any LEGO option, the empty bins are not drawn.|; 238| ""LEGO3"" | Draw a lego plot with hidden surface remo",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:11241,Availability,error,error,11241,"ntents as text at angle nn (0 < nn <= 90). |; 242| ""X+"" | The X-axis is drawn on the top side of the plot. |; 243| ""Y+"" | The Y-axis is drawn on the right side of the plot. |; 244| ""MIN0"" | Set minimum value for the Y axis to 0, equivalent to gStyle->SetHistMinimumZero(). |; 245 ; 246\anchor HP01b; 247#### Options supported for 1D histograms; 248 ; 249| Option | Description |; 250|----------|-------------------------------------------------------------------|; 251| "" "" | Default. |; 252| ""AH"" | Draw histogram without axis. ""A"" can be combined with any drawing option. For instance, ""AC"" draws the histogram as a smooth Curve without axis.|; 253| ""]["" | When this option is selected the first and last vertical lines of the histogram are not drawn.|; 254| ""B"" | Bar chart option.|; 255| ""BAR"" | Like option ""B"", but bars can be drawn with a 3D effect.|; 256| ""HBAR"" | Like option ""BAR"", but bars are drawn horizontally.|; 257| ""C"" | Draw a smooth Curve through the histogram bins.|; 258| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 259| ""E1"" | Draw error bars with perpendicular lines at the edges.|; 260| ""E2"" | Draw error bars with rectangles.|; 261| ""E3"" | Draw a fill area through the end points of the vertical error bars.|; 262| ""E4"" | Draw a smoothed filled area through the end points of the error bars.|; 263| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 264| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 265| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 266| ""L"" | Draw a line through the bin contents.|; 267| ""P"" | Draw current marker at each bin except empty bins.|; 268| ""P*"" | Draw a star marker at each bin except empty bins.|; 269| ""P0"" | Draw current marker at each bin including empty bins.|; 270| ""PIE"" | Draw histogram as a Pie Chart.|; 271| ""*H"" | Draw histogram with a * at each bin.|; 272| ""LF2"" | Draw h",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:11330,Availability,error,error,11330," The Y-axis is drawn on the right side of the plot. |; 244| ""MIN0"" | Set minimum value for the Y axis to 0, equivalent to gStyle->SetHistMinimumZero(). |; 245 ; 246\anchor HP01b; 247#### Options supported for 1D histograms; 248 ; 249| Option | Description |; 250|----------|-------------------------------------------------------------------|; 251| "" "" | Default. |; 252| ""AH"" | Draw histogram without axis. ""A"" can be combined with any drawing option. For instance, ""AC"" draws the histogram as a smooth Curve without axis.|; 253| ""]["" | When this option is selected the first and last vertical lines of the histogram are not drawn.|; 254| ""B"" | Bar chart option.|; 255| ""BAR"" | Like option ""B"", but bars can be drawn with a 3D effect.|; 256| ""HBAR"" | Like option ""BAR"", but bars are drawn horizontally.|; 257| ""C"" | Draw a smooth Curve through the histogram bins.|; 258| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 259| ""E1"" | Draw error bars with perpendicular lines at the edges.|; 260| ""E2"" | Draw error bars with rectangles.|; 261| ""E3"" | Draw a fill area through the end points of the vertical error bars.|; 262| ""E4"" | Draw a smoothed filled area through the end points of the error bars.|; 263| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 264| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 265| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 266| ""L"" | Draw a line through the bin contents.|; 267| ""P"" | Draw current marker at each bin except empty bins.|; 268| ""P*"" | Draw a star marker at each bin except empty bins.|; 269| ""P0"" | Draw current marker at each bin including empty bins.|; 270| ""PIE"" | Draw histogram as a Pie Chart.|; 271| ""*H"" | Draw histogram with a * at each bin.|; 272| ""LF2"" | Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws also a fill area if the hist fill color is set b",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:11369,Availability,error,error,11369," The Y-axis is drawn on the right side of the plot. |; 244| ""MIN0"" | Set minimum value for the Y axis to 0, equivalent to gStyle->SetHistMinimumZero(). |; 245 ; 246\anchor HP01b; 247#### Options supported for 1D histograms; 248 ; 249| Option | Description |; 250|----------|-------------------------------------------------------------------|; 251| "" "" | Default. |; 252| ""AH"" | Draw histogram without axis. ""A"" can be combined with any drawing option. For instance, ""AC"" draws the histogram as a smooth Curve without axis.|; 253| ""]["" | When this option is selected the first and last vertical lines of the histogram are not drawn.|; 254| ""B"" | Bar chart option.|; 255| ""BAR"" | Like option ""B"", but bars can be drawn with a 3D effect.|; 256| ""HBAR"" | Like option ""BAR"", but bars are drawn horizontally.|; 257| ""C"" | Draw a smooth Curve through the histogram bins.|; 258| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 259| ""E1"" | Draw error bars with perpendicular lines at the edges.|; 260| ""E2"" | Draw error bars with rectangles.|; 261| ""E3"" | Draw a fill area through the end points of the vertical error bars.|; 262| ""E4"" | Draw a smoothed filled area through the end points of the error bars.|; 263| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 264| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 265| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 266| ""L"" | Draw a line through the bin contents.|; 267| ""P"" | Draw current marker at each bin except empty bins.|; 268| ""P*"" | Draw a star marker at each bin except empty bins.|; 269| ""P0"" | Draw current marker at each bin including empty bins.|; 270| ""PIE"" | Draw histogram as a Pie Chart.|; 271| ""*H"" | Draw histogram with a * at each bin.|; 272| ""LF2"" | Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws also a fill area if the hist fill color is set b",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:11438,Availability,error,error,11438,"ue for the Y axis to 0, equivalent to gStyle->SetHistMinimumZero(). |; 245 ; 246\anchor HP01b; 247#### Options supported for 1D histograms; 248 ; 249| Option | Description |; 250|----------|-------------------------------------------------------------------|; 251| "" "" | Default. |; 252| ""AH"" | Draw histogram without axis. ""A"" can be combined with any drawing option. For instance, ""AC"" draws the histogram as a smooth Curve without axis.|; 253| ""]["" | When this option is selected the first and last vertical lines of the histogram are not drawn.|; 254| ""B"" | Bar chart option.|; 255| ""BAR"" | Like option ""B"", but bars can be drawn with a 3D effect.|; 256| ""HBAR"" | Like option ""BAR"", but bars are drawn horizontally.|; 257| ""C"" | Draw a smooth Curve through the histogram bins.|; 258| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 259| ""E1"" | Draw error bars with perpendicular lines at the edges.|; 260| ""E2"" | Draw error bars with rectangles.|; 261| ""E3"" | Draw a fill area through the end points of the vertical error bars.|; 262| ""E4"" | Draw a smoothed filled area through the end points of the error bars.|; 263| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 264| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 265| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 266| ""L"" | Draw a line through the bin contents.|; 267| ""P"" | Draw current marker at each bin except empty bins.|; 268| ""P*"" | Draw a star marker at each bin except empty bins.|; 269| ""P0"" | Draw current marker at each bin including empty bins.|; 270| ""PIE"" | Draw histogram as a Pie Chart.|; 271| ""*H"" | Draw histogram with a * at each bin.|; 272| ""LF2"" | Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws also a fill area if the hist fill color is set but the fill area corresponds to the histogram contour.|; 273 ; 274 ; 275\anchor HP01c",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:11536,Availability,error,error,11536,"). |; 245 ; 246\anchor HP01b; 247#### Options supported for 1D histograms; 248 ; 249| Option | Description |; 250|----------|-------------------------------------------------------------------|; 251| "" "" | Default. |; 252| ""AH"" | Draw histogram without axis. ""A"" can be combined with any drawing option. For instance, ""AC"" draws the histogram as a smooth Curve without axis.|; 253| ""]["" | When this option is selected the first and last vertical lines of the histogram are not drawn.|; 254| ""B"" | Bar chart option.|; 255| ""BAR"" | Like option ""B"", but bars can be drawn with a 3D effect.|; 256| ""HBAR"" | Like option ""BAR"", but bars are drawn horizontally.|; 257| ""C"" | Draw a smooth Curve through the histogram bins.|; 258| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 259| ""E1"" | Draw error bars with perpendicular lines at the edges.|; 260| ""E2"" | Draw error bars with rectangles.|; 261| ""E3"" | Draw a fill area through the end points of the vertical error bars.|; 262| ""E4"" | Draw a smoothed filled area through the end points of the error bars.|; 263| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 264| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 265| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 266| ""L"" | Draw a line through the bin contents.|; 267| ""P"" | Draw current marker at each bin except empty bins.|; 268| ""P*"" | Draw a star marker at each bin except empty bins.|; 269| ""P0"" | Draw current marker at each bin including empty bins.|; 270| ""PIE"" | Draw histogram as a Pie Chart.|; 271| ""*H"" | Draw histogram with a * at each bin.|; 272| ""LF2"" | Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws also a fill area if the hist fill color is set but the fill area corresponds to the histogram contour.|; 273 ; 274 ; 275\anchor HP01c; 276#### Options supported for 2D histograms; 277 ; 278| Option",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:11620,Availability,error,error,11620,"9| Option | Description |; 250|----------|-------------------------------------------------------------------|; 251| "" "" | Default. |; 252| ""AH"" | Draw histogram without axis. ""A"" can be combined with any drawing option. For instance, ""AC"" draws the histogram as a smooth Curve without axis.|; 253| ""]["" | When this option is selected the first and last vertical lines of the histogram are not drawn.|; 254| ""B"" | Bar chart option.|; 255| ""BAR"" | Like option ""B"", but bars can be drawn with a 3D effect.|; 256| ""HBAR"" | Like option ""BAR"", but bars are drawn horizontally.|; 257| ""C"" | Draw a smooth Curve through the histogram bins.|; 258| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 259| ""E1"" | Draw error bars with perpendicular lines at the edges.|; 260| ""E2"" | Draw error bars with rectangles.|; 261| ""E3"" | Draw a fill area through the end points of the vertical error bars.|; 262| ""E4"" | Draw a smoothed filled area through the end points of the error bars.|; 263| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 264| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 265| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 266| ""L"" | Draw a line through the bin contents.|; 267| ""P"" | Draw current marker at each bin except empty bins.|; 268| ""P*"" | Draw a star marker at each bin except empty bins.|; 269| ""P0"" | Draw current marker at each bin including empty bins.|; 270| ""PIE"" | Draw histogram as a Pie Chart.|; 271| ""*H"" | Draw histogram with a * at each bin.|; 272| ""LF2"" | Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws also a fill area if the hist fill color is set but the fill area corresponds to the histogram contour.|; 273 ; 274 ; 275\anchor HP01c; 276#### Options supported for 2D histograms; 277 ; 278| Option | Description |; 279|--------------|----------------------------------------------",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:11818,Availability,error,error,11818,"For instance, ""AC"" draws the histogram as a smooth Curve without axis.|; 253| ""]["" | When this option is selected the first and last vertical lines of the histogram are not drawn.|; 254| ""B"" | Bar chart option.|; 255| ""BAR"" | Like option ""B"", but bars can be drawn with a 3D effect.|; 256| ""HBAR"" | Like option ""BAR"", but bars are drawn horizontally.|; 257| ""C"" | Draw a smooth Curve through the histogram bins.|; 258| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 259| ""E1"" | Draw error bars with perpendicular lines at the edges.|; 260| ""E2"" | Draw error bars with rectangles.|; 261| ""E3"" | Draw a fill area through the end points of the vertical error bars.|; 262| ""E4"" | Draw a smoothed filled area through the end points of the error bars.|; 263| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 264| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 265| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 266| ""L"" | Draw a line through the bin contents.|; 267| ""P"" | Draw current marker at each bin except empty bins.|; 268| ""P*"" | Draw a star marker at each bin except empty bins.|; 269| ""P0"" | Draw current marker at each bin including empty bins.|; 270| ""PIE"" | Draw histogram as a Pie Chart.|; 271| ""*H"" | Draw histogram with a * at each bin.|; 272| ""LF2"" | Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws also a fill area if the hist fill color is set but the fill area corresponds to the histogram contour.|; 273 ; 274 ; 275\anchor HP01c; 276#### Options supported for 2D histograms; 277 ; 278| Option | Description |; 279|--------------|------------------------------------------------------------------|; 280| "" "" | Default (color plot).|; 281| ""ARR"" | Arrow mode. Shows gradient between adjacent cells.|; 282| ""BOX"" | A box is drawn for each cell with surface proportional to the content's absolute val",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:21347,Availability,avail,available,21347,"; 399(`tx = ty = 0`); 400 ; 401`TPad::SetTicks(tx,ty)` allows to set these options.; 402See also The `TAxis` functions to set specific axis attributes.; 403 ; 404In case multiple color filled histograms are drawn on the same pad, the fill; 405area may hide the axis tick marks. One can force a redraw of the axis over all; 406the histograms by calling:; 407 ; 408 gPad->RedrawAxis();; 409 ; 410 ; 411\anchor HP05; 412### Giving titles to the X, Y and Z axis; 413 ; 414 ; 415 h->GetXaxis()->SetTitle(""X axis title"");; 416 h->GetYaxis()->SetTitle(""Y axis title"");; 417 ; 418The histogram title and the axis titles can be any `TLatex` string.; 419The titles are part of the persistent histogram.; 420 ; 421 ; 422\anchor HP060; 423### The option ""SAME""; 424 ; 425 ; 426By default, when an histogram is drawn, the current pad is cleared before; 427drawing. In order to keep the previous drawing and draw on top of it the; 428option `SAME` should be use. The histogram drawn with the option; 429`SAME` uses the coordinates system available in the current pad.; 430 ; 431This option can be used alone or combined with any valid drawing option but; 432some combinations must be use with care.; 433 ; 434\anchor HP060a; 435#### Limitations; 436 ; 437- It does not work when combined with the `LEGO` and `SURF` options unless the; 438 histogram plotted with the option `SAME` has exactly the same; 439 ranges on the X, Y and Z axis as the currently drawn histogram. To superimpose; 440 lego plots [histograms' stacks](\ref HP26) should be used.; 441 ; 442 ; 443\anchor HP061; 444### Colors automatically picked in palette; 445 ; 446\since **ROOT version 6.09/01**; 447 ; 448When several histograms are painted in the same canvas thanks to the option ""SAME""; 449or via a `THStack` it might be useful to have an easy and automatic way to choose; 450their color. The simplest way is to pick colors in the current active color; 451palette. Palette coloring for histogram is activated thanks to the options `PFC`; 45",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:24900,Availability,error,error,24900,"; 505 ; 506 // draw an axis on the right side; 507 auto axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; 508 gPad->GetUxmax(), gPad->GetUymax(),0,rightmax,510,""+L"");; 509 axis->SetLineColor(kRed);; 510 axis->SetTextColor(kRed);; 511 axis->Draw();; 512}; 513End_Macro; 514 ; 515 ; 516\anchor HP07; 517### Statistics Display; 518 ; 519 ; 520The type of information shown in the histogram statistics box can be selected; 521with:; 522 ; 523 gStyle->SetOptStat(mode);; 524 ; 525The `mode` has up to nine digits that can be set to on (1 or 2), off (0).; 526 ; 527 mode = ksiourmen (default = 000001111); 528 k = 1; kurtosis printed; 529 k = 2; kurtosis and kurtosis error printed; 530 s = 1; skewness printed; 531 s = 2; skewness and skewness error printed; 532 i = 1; integral of bins printed; 533 i = 2; integral of bins with option ""width"" printed; 534 o = 1; number of overflows printed; 535 u = 1; number of underflows printed; 536 r = 1; standard deviation printed; 537 r = 2; standard deviation and standard deviation error printed; 538 m = 1; mean value printed; 539 m = 2; mean and mean error values printed; 540 e = 1; number of entries printed; 541 n = 1; name of histogram is printed; 542 ; 543For example:; 544 ; 545 gStyle->SetOptStat(11);; 546 ; 547displays only the name of histogram and the number of entries, whereas:; 548 ; 549 gStyle->SetOptStat(1101);; 550 ; 551displays the name of histogram, mean value and standard deviation.; 552 ; 553<b>WARNING 1:</b> never do:; 554 ; 555 gStyle->SetOptStat(0001111);; 556 ; 557but instead do:; 558 ; 559 gStyle->SetOptStat(1111);; 560 ; 561because `0001111` will be taken as an octal number!; 562 ; 563<b>WARNING 2:</b> for backward compatibility with older versions; 564 ; 565 gStyle->SetOptStat(1);; 566 ; 567is taken as:; 568 ; 569 gStyle->SetOptStat(1111); 570 ; 571To print only the name of the histogram do:; 572 ; 573 gStyle->SetOptStat(1000000001);; 574 ; 575<b>NOTE</b> that in case of 2D histograms, when selecting only underflow;",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:24977,Availability,error,error,24977,"; 505 ; 506 // draw an axis on the right side; 507 auto axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; 508 gPad->GetUxmax(), gPad->GetUymax(),0,rightmax,510,""+L"");; 509 axis->SetLineColor(kRed);; 510 axis->SetTextColor(kRed);; 511 axis->Draw();; 512}; 513End_Macro; 514 ; 515 ; 516\anchor HP07; 517### Statistics Display; 518 ; 519 ; 520The type of information shown in the histogram statistics box can be selected; 521with:; 522 ; 523 gStyle->SetOptStat(mode);; 524 ; 525The `mode` has up to nine digits that can be set to on (1 or 2), off (0).; 526 ; 527 mode = ksiourmen (default = 000001111); 528 k = 1; kurtosis printed; 529 k = 2; kurtosis and kurtosis error printed; 530 s = 1; skewness printed; 531 s = 2; skewness and skewness error printed; 532 i = 1; integral of bins printed; 533 i = 2; integral of bins with option ""width"" printed; 534 o = 1; number of overflows printed; 535 u = 1; number of underflows printed; 536 r = 1; standard deviation printed; 537 r = 2; standard deviation and standard deviation error printed; 538 m = 1; mean value printed; 539 m = 2; mean and mean error values printed; 540 e = 1; number of entries printed; 541 n = 1; name of histogram is printed; 542 ; 543For example:; 544 ; 545 gStyle->SetOptStat(11);; 546 ; 547displays only the name of histogram and the number of entries, whereas:; 548 ; 549 gStyle->SetOptStat(1101);; 550 ; 551displays the name of histogram, mean value and standard deviation.; 552 ; 553<b>WARNING 1:</b> never do:; 554 ; 555 gStyle->SetOptStat(0001111);; 556 ; 557but instead do:; 558 ; 559 gStyle->SetOptStat(1111);; 560 ; 561because `0001111` will be taken as an octal number!; 562 ; 563<b>WARNING 2:</b> for backward compatibility with older versions; 564 ; 565 gStyle->SetOptStat(1);; 566 ; 567is taken as:; 568 ; 569 gStyle->SetOptStat(1111); 570 ; 571To print only the name of the histogram do:; 572 ; 573 gStyle->SetOptStat(1000000001);; 574 ; 575<b>NOTE</b> that in case of 2D histograms, when selecting only underflow;",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:25259,Availability,error,error,25259,"; 505 ; 506 // draw an axis on the right side; 507 auto axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; 508 gPad->GetUxmax(), gPad->GetUymax(),0,rightmax,510,""+L"");; 509 axis->SetLineColor(kRed);; 510 axis->SetTextColor(kRed);; 511 axis->Draw();; 512}; 513End_Macro; 514 ; 515 ; 516\anchor HP07; 517### Statistics Display; 518 ; 519 ; 520The type of information shown in the histogram statistics box can be selected; 521with:; 522 ; 523 gStyle->SetOptStat(mode);; 524 ; 525The `mode` has up to nine digits that can be set to on (1 or 2), off (0).; 526 ; 527 mode = ksiourmen (default = 000001111); 528 k = 1; kurtosis printed; 529 k = 2; kurtosis and kurtosis error printed; 530 s = 1; skewness printed; 531 s = 2; skewness and skewness error printed; 532 i = 1; integral of bins printed; 533 i = 2; integral of bins with option ""width"" printed; 534 o = 1; number of overflows printed; 535 u = 1; number of underflows printed; 536 r = 1; standard deviation printed; 537 r = 2; standard deviation and standard deviation error printed; 538 m = 1; mean value printed; 539 m = 2; mean and mean error values printed; 540 e = 1; number of entries printed; 541 n = 1; name of histogram is printed; 542 ; 543For example:; 544 ; 545 gStyle->SetOptStat(11);; 546 ; 547displays only the name of histogram and the number of entries, whereas:; 548 ; 549 gStyle->SetOptStat(1101);; 550 ; 551displays the name of histogram, mean value and standard deviation.; 552 ; 553<b>WARNING 1:</b> never do:; 554 ; 555 gStyle->SetOptStat(0001111);; 556 ; 557but instead do:; 558 ; 559 gStyle->SetOptStat(1111);; 560 ; 561because `0001111` will be taken as an octal number!; 562 ; 563<b>WARNING 2:</b> for backward compatibility with older versions; 564 ; 565 gStyle->SetOptStat(1);; 566 ; 567is taken as:; 568 ; 569 gStyle->SetOptStat(1111); 570 ; 571To print only the name of the histogram do:; 572 ; 573 gStyle->SetOptStat(1000000001);; 574 ; 575<b>NOTE</b> that in case of 2D histograms, when selecting only underflow;",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:25330,Availability,error,error,25330,"; 505 ; 506 // draw an axis on the right side; 507 auto axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; 508 gPad->GetUxmax(), gPad->GetUymax(),0,rightmax,510,""+L"");; 509 axis->SetLineColor(kRed);; 510 axis->SetTextColor(kRed);; 511 axis->Draw();; 512}; 513End_Macro; 514 ; 515 ; 516\anchor HP07; 517### Statistics Display; 518 ; 519 ; 520The type of information shown in the histogram statistics box can be selected; 521with:; 522 ; 523 gStyle->SetOptStat(mode);; 524 ; 525The `mode` has up to nine digits that can be set to on (1 or 2), off (0).; 526 ; 527 mode = ksiourmen (default = 000001111); 528 k = 1; kurtosis printed; 529 k = 2; kurtosis and kurtosis error printed; 530 s = 1; skewness printed; 531 s = 2; skewness and skewness error printed; 532 i = 1; integral of bins printed; 533 i = 2; integral of bins with option ""width"" printed; 534 o = 1; number of overflows printed; 535 u = 1; number of underflows printed; 536 r = 1; standard deviation printed; 537 r = 2; standard deviation and standard deviation error printed; 538 m = 1; mean value printed; 539 m = 2; mean and mean error values printed; 540 e = 1; number of entries printed; 541 n = 1; name of histogram is printed; 542 ; 543For example:; 544 ; 545 gStyle->SetOptStat(11);; 546 ; 547displays only the name of histogram and the number of entries, whereas:; 548 ; 549 gStyle->SetOptStat(1101);; 550 ; 551displays the name of histogram, mean value and standard deviation.; 552 ; 553<b>WARNING 1:</b> never do:; 554 ; 555 gStyle->SetOptStat(0001111);; 556 ; 557but instead do:; 558 ; 559 gStyle->SetOptStat(1111);; 560 ; 561because `0001111` will be taken as an octal number!; 562 ; 563<b>WARNING 2:</b> for backward compatibility with older versions; 564 ; 565 gStyle->SetOptStat(1);; 566 ; 567is taken as:; 568 ; 569 gStyle->SetOptStat(1111); 570 ; 571To print only the name of the histogram do:; 572 ; 573 gStyle->SetOptStat(1000000001);; 574 ; 575<b>NOTE</b> that in case of 2D histograms, when selecting only underflow;",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:26521,Availability,error,error,26521,"b>WARNING 2:</b> for backward compatibility with older versions; 564 ; 565 gStyle->SetOptStat(1);; 566 ; 567is taken as:; 568 ; 569 gStyle->SetOptStat(1111); 570 ; 571To print only the name of the histogram do:; 572 ; 573 gStyle->SetOptStat(1000000001);; 574 ; 575<b>NOTE</b> that in case of 2D histograms, when selecting only underflow; 576(10000) or overflow (100000), the statistics box will show all combinations; 577of underflow/overflows and not just one single number.; 578 ; 579The parameter mode can be any combination of the letters `kKsSiIourRmMen`; 580 ; 581 k : kurtosis printed; 582 K : kurtosis and kurtosis error printed; 583 s : skewness printed; 584 S : skewness and skewness error printed; 585 i : integral of bins printed; 586 I : integral of bins with option ""width"" printed; 587 o : number of overflows printed; 588 u : number of underflows printed; 589 r : standard deviation printed; 590 R : standard deviation and standard deviation error printed; 591 m : mean value printed; 592 M : mean value mean error values printed; 593 e : number of entries printed; 594 n : name of histogram is printed; 595 ; 596For example, to print only name of histogram and number of entries do:; 597 ; 598 gStyle->SetOptStat(""ne"");; 599 ; 600To print only the name of the histogram do:; 601 ; 602 gStyle->SetOptStat(""n"");; 603 ; 604The default value is:; 605 ; 606 gStyle->SetOptStat(""nemr"");; 607 ; 608When a histogram is painted, a `TPaveStats` object is created and added; 609to the list of functions of the histogram. If a `TPaveStats` object; 610already exists in the histogram list of functions, the existing object is just; 611updated with the current histogram parameters.; 612 ; 613Once a histogram is painted, the statistics box can be accessed using; 614`h->FindObject(""stats"")`. In the command line it is enough to do:; 615 ; 616 Root > h->Draw(); 617 Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); 618 ; 619because after `h->Draw()` the histogram is automatically paint",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:26592,Availability,error,error,26592,"b>WARNING 2:</b> for backward compatibility with older versions; 564 ; 565 gStyle->SetOptStat(1);; 566 ; 567is taken as:; 568 ; 569 gStyle->SetOptStat(1111); 570 ; 571To print only the name of the histogram do:; 572 ; 573 gStyle->SetOptStat(1000000001);; 574 ; 575<b>NOTE</b> that in case of 2D histograms, when selecting only underflow; 576(10000) or overflow (100000), the statistics box will show all combinations; 577of underflow/overflows and not just one single number.; 578 ; 579The parameter mode can be any combination of the letters `kKsSiIourRmMen`; 580 ; 581 k : kurtosis printed; 582 K : kurtosis and kurtosis error printed; 583 s : skewness printed; 584 S : skewness and skewness error printed; 585 i : integral of bins printed; 586 I : integral of bins with option ""width"" printed; 587 o : number of overflows printed; 588 u : number of underflows printed; 589 r : standard deviation printed; 590 R : standard deviation and standard deviation error printed; 591 m : mean value printed; 592 M : mean value mean error values printed; 593 e : number of entries printed; 594 n : name of histogram is printed; 595 ; 596For example, to print only name of histogram and number of entries do:; 597 ; 598 gStyle->SetOptStat(""ne"");; 599 ; 600To print only the name of the histogram do:; 601 ; 602 gStyle->SetOptStat(""n"");; 603 ; 604The default value is:; 605 ; 606 gStyle->SetOptStat(""nemr"");; 607 ; 608When a histogram is painted, a `TPaveStats` object is created and added; 609to the list of functions of the histogram. If a `TPaveStats` object; 610already exists in the histogram list of functions, the existing object is just; 611updated with the current histogram parameters.; 612 ; 613Once a histogram is painted, the statistics box can be accessed using; 614`h->FindObject(""stats"")`. In the command line it is enough to do:; 615 ; 616 Root > h->Draw(); 617 Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); 618 ; 619because after `h->Draw()` the histogram is automatically paint",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:26856,Availability,error,error,26856,"b>WARNING 2:</b> for backward compatibility with older versions; 564 ; 565 gStyle->SetOptStat(1);; 566 ; 567is taken as:; 568 ; 569 gStyle->SetOptStat(1111); 570 ; 571To print only the name of the histogram do:; 572 ; 573 gStyle->SetOptStat(1000000001);; 574 ; 575<b>NOTE</b> that in case of 2D histograms, when selecting only underflow; 576(10000) or overflow (100000), the statistics box will show all combinations; 577of underflow/overflows and not just one single number.; 578 ; 579The parameter mode can be any combination of the letters `kKsSiIourRmMen`; 580 ; 581 k : kurtosis printed; 582 K : kurtosis and kurtosis error printed; 583 s : skewness printed; 584 S : skewness and skewness error printed; 585 i : integral of bins printed; 586 I : integral of bins with option ""width"" printed; 587 o : number of overflows printed; 588 u : number of underflows printed; 589 r : standard deviation printed; 590 R : standard deviation and standard deviation error printed; 591 m : mean value printed; 592 M : mean value mean error values printed; 593 e : number of entries printed; 594 n : name of histogram is printed; 595 ; 596For example, to print only name of histogram and number of entries do:; 597 ; 598 gStyle->SetOptStat(""ne"");; 599 ; 600To print only the name of the histogram do:; 601 ; 602 gStyle->SetOptStat(""n"");; 603 ; 604The default value is:; 605 ; 606 gStyle->SetOptStat(""nemr"");; 607 ; 608When a histogram is painted, a `TPaveStats` object is created and added; 609to the list of functions of the histogram. If a `TPaveStats` object; 610already exists in the histogram list of functions, the existing object is just; 611updated with the current histogram parameters.; 612 ; 613Once a histogram is painted, the statistics box can be accessed using; 614`h->FindObject(""stats"")`. In the command line it is enough to do:; 615 ; 616 Root > h->Draw(); 617 Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); 618 ; 619because after `h->Draw()` the histogram is automatically paint",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:26923,Availability,error,error,26923,"b>WARNING 2:</b> for backward compatibility with older versions; 564 ; 565 gStyle->SetOptStat(1);; 566 ; 567is taken as:; 568 ; 569 gStyle->SetOptStat(1111); 570 ; 571To print only the name of the histogram do:; 572 ; 573 gStyle->SetOptStat(1000000001);; 574 ; 575<b>NOTE</b> that in case of 2D histograms, when selecting only underflow; 576(10000) or overflow (100000), the statistics box will show all combinations; 577of underflow/overflows and not just one single number.; 578 ; 579The parameter mode can be any combination of the letters `kKsSiIourRmMen`; 580 ; 581 k : kurtosis printed; 582 K : kurtosis and kurtosis error printed; 583 s : skewness printed; 584 S : skewness and skewness error printed; 585 i : integral of bins printed; 586 I : integral of bins with option ""width"" printed; 587 o : number of overflows printed; 588 u : number of underflows printed; 589 r : standard deviation printed; 590 R : standard deviation and standard deviation error printed; 591 m : mean value printed; 592 M : mean value mean error values printed; 593 e : number of entries printed; 594 n : name of histogram is printed; 595 ; 596For example, to print only name of histogram and number of entries do:; 597 ; 598 gStyle->SetOptStat(""ne"");; 599 ; 600To print only the name of the histogram do:; 601 ; 602 gStyle->SetOptStat(""n"");; 603 ; 604The default value is:; 605 ; 606 gStyle->SetOptStat(""nemr"");; 607 ; 608When a histogram is painted, a `TPaveStats` object is created and added; 609to the list of functions of the histogram. If a `TPaveStats` object; 610already exists in the histogram list of functions, the existing object is just; 611updated with the current histogram parameters.; 612 ; 613Once a histogram is painted, the statistics box can be accessed using; 614`h->FindObject(""stats"")`. In the command line it is enough to do:; 615 ; 616 Root > h->Draw(); 617 Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); 618 ; 619because after `h->Draw()` the histogram is automatically paint",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:29717,Availability,error,errors,29717,"X2NDC(newx2); //new x end position; 638 ; 639To change the type of information for an histogram with an existing; 640`TPaveStats` one should do:; 641 ; 642 st->SetOptStat(mode);; 643 ; 644Where `mode` has the same meaning than when calling `gStyle->SetOptStat(mode)`; 645(see above).; 646 ; 647One can delete the statistics box for a histogram `TH1* h` with:; 648 ; 649 h->SetStats(0); 650 ; 651and activate it again with:; 652 ; 653 h->SetStats(1).; 654 ; 655Labels used in the statistics box (""Mean"", ""Std Dev"", ...) can be changed from; 656`$ROOTSYS/etc/system.rootrc` or `.rootrc` (look for the string `Hist.Stats.`).; 657 ; 658 ; 659\anchor HP08; 660### Fit Statistics; 661 ; 662 ; 663The type of information about fit parameters printed in the histogram statistics; 664box can be selected via the parameter mode. The parameter mode can be; 665`= pcev` (default `= 0111`); 666 ; 667 p = 1; print Probability; 668 c = 1; print Chisquare/Number of degrees of freedom; 669 e = 1; print errors (if e=1, v must be 1); 670 v = 1; print name/values of parameters; 671 ; 672Example:; 673 ; 674 gStyle->SetOptFit(1011);; 675 ; 676print fit probability, parameter names/values and errors.; 677 ; 6781. When `v = 1` is specified, only the non-fixed parameters are shown.; 6792. When `v = 2` all parameters are shown.; 680 ; 681Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; 682to `gStyle->SetOptFit(111)`; 683 ; 684 ; 685\anchor HP09; 686### The error bars options; 687 ; 688 ; 689| Option | Description |; 690|----------|-------------------------------------------------------------------|; 691| ""E"" | Default. Shows only the error bars, not a marker.|; 692| ""E1"" | Small lines are drawn at the end of the error bars.|; 693| ""E2"" | Error rectangles are drawn.|; 694| ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; 695| ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; 696| ""E0"" | Draw error bars. Mark",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:29905,Availability,error,errors,29905,"X2NDC(newx2); //new x end position; 638 ; 639To change the type of information for an histogram with an existing; 640`TPaveStats` one should do:; 641 ; 642 st->SetOptStat(mode);; 643 ; 644Where `mode` has the same meaning than when calling `gStyle->SetOptStat(mode)`; 645(see above).; 646 ; 647One can delete the statistics box for a histogram `TH1* h` with:; 648 ; 649 h->SetStats(0); 650 ; 651and activate it again with:; 652 ; 653 h->SetStats(1).; 654 ; 655Labels used in the statistics box (""Mean"", ""Std Dev"", ...) can be changed from; 656`$ROOTSYS/etc/system.rootrc` or `.rootrc` (look for the string `Hist.Stats.`).; 657 ; 658 ; 659\anchor HP08; 660### Fit Statistics; 661 ; 662 ; 663The type of information about fit parameters printed in the histogram statistics; 664box can be selected via the parameter mode. The parameter mode can be; 665`= pcev` (default `= 0111`); 666 ; 667 p = 1; print Probability; 668 c = 1; print Chisquare/Number of degrees of freedom; 669 e = 1; print errors (if e=1, v must be 1); 670 v = 1; print name/values of parameters; 671 ; 672Example:; 673 ; 674 gStyle->SetOptFit(1011);; 675 ; 676print fit probability, parameter names/values and errors.; 677 ; 6781. When `v = 1` is specified, only the non-fixed parameters are shown.; 6792. When `v = 2` all parameters are shown.; 680 ; 681Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; 682to `gStyle->SetOptFit(111)`; 683 ; 684 ; 685\anchor HP09; 686### The error bars options; 687 ; 688 ; 689| Option | Description |; 690|----------|-------------------------------------------------------------------|; 691| ""E"" | Default. Shows only the error bars, not a marker.|; 692| ""E1"" | Small lines are drawn at the end of the error bars.|; 693| ""E2"" | Error rectangles are drawn.|; 694| ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; 695| ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; 696| ""E0"" | Draw error bars. Mark",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:30195,Availability,error,error,30195,"d in the statistics box (""Mean"", ""Std Dev"", ...) can be changed from; 656`$ROOTSYS/etc/system.rootrc` or `.rootrc` (look for the string `Hist.Stats.`).; 657 ; 658 ; 659\anchor HP08; 660### Fit Statistics; 661 ; 662 ; 663The type of information about fit parameters printed in the histogram statistics; 664box can be selected via the parameter mode. The parameter mode can be; 665`= pcev` (default `= 0111`); 666 ; 667 p = 1; print Probability; 668 c = 1; print Chisquare/Number of degrees of freedom; 669 e = 1; print errors (if e=1, v must be 1); 670 v = 1; print name/values of parameters; 671 ; 672Example:; 673 ; 674 gStyle->SetOptFit(1011);; 675 ; 676print fit probability, parameter names/values and errors.; 677 ; 6781. When `v = 1` is specified, only the non-fixed parameters are shown.; 6792. When `v = 2` all parameters are shown.; 680 ; 681Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; 682to `gStyle->SetOptFit(111)`; 683 ; 684 ; 685\anchor HP09; 686### The error bars options; 687 ; 688 ; 689| Option | Description |; 690|----------|-------------------------------------------------------------------|; 691| ""E"" | Default. Shows only the error bars, not a marker.|; 692| ""E1"" | Small lines are drawn at the end of the error bars.|; 693| ""E2"" | Error rectangles are drawn.|; 694| ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; 695| ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; 696| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 697| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 698| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 699| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 700 ; 701Begin_Macro(source); 702{; 703 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 704 auto he = new TH1F(""he"",""Distribution drawn with",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:30376,Availability,error,error,30376," 660### Fit Statistics; 661 ; 662 ; 663The type of information about fit parameters printed in the histogram statistics; 664box can be selected via the parameter mode. The parameter mode can be; 665`= pcev` (default `= 0111`); 666 ; 667 p = 1; print Probability; 668 c = 1; print Chisquare/Number of degrees of freedom; 669 e = 1; print errors (if e=1, v must be 1); 670 v = 1; print name/values of parameters; 671 ; 672Example:; 673 ; 674 gStyle->SetOptFit(1011);; 675 ; 676print fit probability, parameter names/values and errors.; 677 ; 6781. When `v = 1` is specified, only the non-fixed parameters are shown.; 6792. When `v = 2` all parameters are shown.; 680 ; 681Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; 682to `gStyle->SetOptFit(111)`; 683 ; 684 ; 685\anchor HP09; 686### The error bars options; 687 ; 688 ; 689| Option | Description |; 690|----------|-------------------------------------------------------------------|; 691| ""E"" | Default. Shows only the error bars, not a marker.|; 692| ""E1"" | Small lines are drawn at the end of the error bars.|; 693| ""E2"" | Error rectangles are drawn.|; 694| ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; 695| ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; 696| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 697| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 698| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 699| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 700 ; 701Begin_Macro(source); 702{; 703 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 704 auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; 705 for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; 706 gStyle->SetEndErrorSize(3);; 707 gStyle->SetErrorX(1.);; 708 he->SetMarkerSt",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:30456,Availability,error,error,30456,"ormation about fit parameters printed in the histogram statistics; 664box can be selected via the parameter mode. The parameter mode can be; 665`= pcev` (default `= 0111`); 666 ; 667 p = 1; print Probability; 668 c = 1; print Chisquare/Number of degrees of freedom; 669 e = 1; print errors (if e=1, v must be 1); 670 v = 1; print name/values of parameters; 671 ; 672Example:; 673 ; 674 gStyle->SetOptFit(1011);; 675 ; 676print fit probability, parameter names/values and errors.; 677 ; 6781. When `v = 1` is specified, only the non-fixed parameters are shown.; 6792. When `v = 2` all parameters are shown.; 680 ; 681Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; 682to `gStyle->SetOptFit(111)`; 683 ; 684 ; 685\anchor HP09; 686### The error bars options; 687 ; 688 ; 689| Option | Description |; 690|----------|-------------------------------------------------------------------|; 691| ""E"" | Default. Shows only the error bars, not a marker.|; 692| ""E1"" | Small lines are drawn at the end of the error bars.|; 693| ""E2"" | Error rectangles are drawn.|; 694| ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; 695| ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; 696| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 697| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 698| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 699| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 700 ; 701Begin_Macro(source); 702{; 703 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 704 auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; 705 for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; 706 gStyle->SetEndErrorSize(3);; 707 gStyle->SetErrorX(1.);; 708 he->SetMarkerStyle(20);; 709 he->Draw(""E1"");; 710}; 711End_Macro; 71",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:30586,Availability,error,error,30586,"arameter mode can be; 665`= pcev` (default `= 0111`); 666 ; 667 p = 1; print Probability; 668 c = 1; print Chisquare/Number of degrees of freedom; 669 e = 1; print errors (if e=1, v must be 1); 670 v = 1; print name/values of parameters; 671 ; 672Example:; 673 ; 674 gStyle->SetOptFit(1011);; 675 ; 676print fit probability, parameter names/values and errors.; 677 ; 6781. When `v = 1` is specified, only the non-fixed parameters are shown.; 6792. When `v = 2` all parameters are shown.; 680 ; 681Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; 682to `gStyle->SetOptFit(111)`; 683 ; 684 ; 685\anchor HP09; 686### The error bars options; 687 ; 688 ; 689| Option | Description |; 690|----------|-------------------------------------------------------------------|; 691| ""E"" | Default. Shows only the error bars, not a marker.|; 692| ""E1"" | Small lines are drawn at the end of the error bars.|; 693| ""E2"" | Error rectangles are drawn.|; 694| ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; 695| ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; 696| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 697| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 698| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 699| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 700 ; 701Begin_Macro(source); 702{; 703 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 704 auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; 705 for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; 706 gStyle->SetEndErrorSize(3);; 707 gStyle->SetErrorX(1.);; 708 he->SetMarkerStyle(20);; 709 he->Draw(""E1"");; 710}; 711End_Macro; 712 ; 713The options ""E3"" and ""E4"" draw an error band through the end points of the; 714vertical error bars. With ""E4"" th",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:30683,Availability,error,error,30683,"8 c = 1; print Chisquare/Number of degrees of freedom; 669 e = 1; print errors (if e=1, v must be 1); 670 v = 1; print name/values of parameters; 671 ; 672Example:; 673 ; 674 gStyle->SetOptFit(1011);; 675 ; 676print fit probability, parameter names/values and errors.; 677 ; 6781. When `v = 1` is specified, only the non-fixed parameters are shown.; 6792. When `v = 2` all parameters are shown.; 680 ; 681Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; 682to `gStyle->SetOptFit(111)`; 683 ; 684 ; 685\anchor HP09; 686### The error bars options; 687 ; 688 ; 689| Option | Description |; 690|----------|-------------------------------------------------------------------|; 691| ""E"" | Default. Shows only the error bars, not a marker.|; 692| ""E1"" | Small lines are drawn at the end of the error bars.|; 693| ""E2"" | Error rectangles are drawn.|; 694| ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; 695| ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; 696| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 697| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 698| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 699| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 700 ; 701Begin_Macro(source); 702{; 703 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 704 auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; 705 for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; 706 gStyle->SetEndErrorSize(3);; 707 gStyle->SetErrorX(1.);; 708 he->SetMarkerStyle(20);; 709 he->Draw(""E1"");; 710}; 711End_Macro; 712 ; 713The options ""E3"" and ""E4"" draw an error band through the end points of the; 714vertical error bars. With ""E4"" the error band is smoothed. Because of the; 715smoothing algorithm used some artefacts may appe",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:30714,Availability,error,error,30714,"; print errors (if e=1, v must be 1); 670 v = 1; print name/values of parameters; 671 ; 672Example:; 673 ; 674 gStyle->SetOptFit(1011);; 675 ; 676print fit probability, parameter names/values and errors.; 677 ; 6781. When `v = 1` is specified, only the non-fixed parameters are shown.; 6792. When `v = 2` all parameters are shown.; 680 ; 681Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; 682to `gStyle->SetOptFit(111)`; 683 ; 684 ; 685\anchor HP09; 686### The error bars options; 687 ; 688 ; 689| Option | Description |; 690|----------|-------------------------------------------------------------------|; 691| ""E"" | Default. Shows only the error bars, not a marker.|; 692| ""E1"" | Small lines are drawn at the end of the error bars.|; 693| ""E2"" | Error rectangles are drawn.|; 694| ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; 695| ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; 696| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 697| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 698| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 699| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 700 ; 701Begin_Macro(source); 702{; 703 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 704 auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; 705 for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; 706 gStyle->SetEndErrorSize(3);; 707 gStyle->SetErrorX(1.);; 708 he->SetMarkerStyle(20);; 709 he->Draw(""E1"");; 710}; 711End_Macro; 712 ; 713The options ""E3"" and ""E4"" draw an error band through the end points of the; 714vertical error bars. With ""E4"" the error band is smoothed. Because of the; 715smoothing algorithm used some artefacts may appear at the end of the band; 716like in the following example. In ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:30803,Availability,error,error,30803,"e->SetOptFit(1011);; 675 ; 676print fit probability, parameter names/values and errors.; 677 ; 6781. When `v = 1` is specified, only the non-fixed parameters are shown.; 6792. When `v = 2` all parameters are shown.; 680 ; 681Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; 682to `gStyle->SetOptFit(111)`; 683 ; 684 ; 685\anchor HP09; 686### The error bars options; 687 ; 688 ; 689| Option | Description |; 690|----------|-------------------------------------------------------------------|; 691| ""E"" | Default. Shows only the error bars, not a marker.|; 692| ""E1"" | Small lines are drawn at the end of the error bars.|; 693| ""E2"" | Error rectangles are drawn.|; 694| ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; 695| ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; 696| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 697| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 698| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 699| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 700 ; 701Begin_Macro(source); 702{; 703 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 704 auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; 705 for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; 706 gStyle->SetEndErrorSize(3);; 707 gStyle->SetErrorX(1.);; 708 he->SetMarkerStyle(20);; 709 he->Draw(""E1"");; 710}; 711End_Macro; 712 ; 713The options ""E3"" and ""E4"" draw an error band through the end points of the; 714vertical error bars. With ""E4"" the error band is smoothed. Because of the; 715smoothing algorithm used some artefacts may appear at the end of the band; 716like in the following example. In such cases ""E3"" should be used instead; 717of ""E4"".; 718 ; 719Begin_Macro(source); 720{; 721 auto ce4 = new TCanvas",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:31009,Availability,error,error,31009,"When `v = 2` all parameters are shown.; 680 ; 681Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; 682to `gStyle->SetOptFit(111)`; 683 ; 684 ; 685\anchor HP09; 686### The error bars options; 687 ; 688 ; 689| Option | Description |; 690|----------|-------------------------------------------------------------------|; 691| ""E"" | Default. Shows only the error bars, not a marker.|; 692| ""E1"" | Small lines are drawn at the end of the error bars.|; 693| ""E2"" | Error rectangles are drawn.|; 694| ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; 695| ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; 696| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 697| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 698| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 699| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 700 ; 701Begin_Macro(source); 702{; 703 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 704 auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; 705 for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; 706 gStyle->SetEndErrorSize(3);; 707 gStyle->SetErrorX(1.);; 708 he->SetMarkerStyle(20);; 709 he->Draw(""E1"");; 710}; 711End_Macro; 712 ; 713The options ""E3"" and ""E4"" draw an error band through the end points of the; 714vertical error bars. With ""E4"" the error band is smoothed. Because of the; 715smoothing algorithm used some artefacts may appear at the end of the band; 716like in the following example. In such cases ""E3"" should be used instead; 717of ""E4"".; 718 ; 719Begin_Macro(source); 720{; 721 auto ce4 = new TCanvas(""ce4"",""ce4"",600,400);; 722 ce4->Divide(2,1);; 723 auto he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; 724 Int_t i;; 725 for (i=0;i<10000;i++) he4->Fill(g",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:31201,Availability,error,error,31201,"ons; 687 ; 688 ; 689| Option | Description |; 690|----------|-------------------------------------------------------------------|; 691| ""E"" | Default. Shows only the error bars, not a marker.|; 692| ""E1"" | Small lines are drawn at the end of the error bars.|; 693| ""E2"" | Error rectangles are drawn.|; 694| ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; 695| ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; 696| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 697| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 698| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 699| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 700 ; 701Begin_Macro(source); 702{; 703 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 704 auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; 705 for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; 706 gStyle->SetEndErrorSize(3);; 707 gStyle->SetErrorX(1.);; 708 he->SetMarkerStyle(20);; 709 he->Draw(""E1"");; 710}; 711End_Macro; 712 ; 713The options ""E3"" and ""E4"" draw an error band through the end points of the; 714vertical error bars. With ""E4"" the error band is smoothed. Because of the; 715smoothing algorithm used some artefacts may appear at the end of the band; 716like in the following example. In such cases ""E3"" should be used instead; 717of ""E4"".; 718 ; 719Begin_Macro(source); 720{; 721 auto ce4 = new TCanvas(""ce4"",""ce4"",600,400);; 722 ce4->Divide(2,1);; 723 auto he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; 724 Int_t i;; 725 for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; 726 he4->SetFillColor(kRed);; 727 he4->GetXaxis()->SetRange(40,48);; 728 ce4->cd(1);; 729 he4->Draw(""E4"");; 730 ce4->cd(2);; 731 auto he3 = (TH1F*)he4->DrawClone(""E3"");; 732 he3->SetTitle(",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:31475,Availability,error,error,31475,"of the error bars.|; 693| ""E2"" | Error rectangles are drawn.|; 694| ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; 695| ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; 696| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 697| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 698| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 699| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 700 ; 701Begin_Macro(source); 702{; 703 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 704 auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; 705 for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; 706 gStyle->SetEndErrorSize(3);; 707 gStyle->SetErrorX(1.);; 708 he->SetMarkerStyle(20);; 709 he->Draw(""E1"");; 710}; 711End_Macro; 712 ; 713The options ""E3"" and ""E4"" draw an error band through the end points of the; 714vertical error bars. With ""E4"" the error band is smoothed. Because of the; 715smoothing algorithm used some artefacts may appear at the end of the band; 716like in the following example. In such cases ""E3"" should be used instead; 717of ""E4"".; 718 ; 719Begin_Macro(source); 720{; 721 auto ce4 = new TCanvas(""ce4"",""ce4"",600,400);; 722 ce4->Divide(2,1);; 723 auto he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; 724 Int_t i;; 725 for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; 726 he4->SetFillColor(kRed);; 727 he4->GetXaxis()->SetRange(40,48);; 728 ce4->cd(1);; 729 he4->Draw(""E4"");; 730 ce4->cd(2);; 731 auto he3 = (TH1F*)he4->DrawClone(""E3"");; 732 he3->SetTitle(""Distribution drawn option E3"");; 733}; 734End_Macro; 735 ; 7362D histograms can be drawn with error bars as shown is the following example:; 737 ; 738Begin_Macro(source); 739{; 740 auto c2e = new TCanvas(""c2e"",""c2e"",600,400);; 741 auto h2",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:31529,Availability,error,error,31529,"of the error bars.|; 693| ""E2"" | Error rectangles are drawn.|; 694| ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; 695| ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; 696| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 697| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 698| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 699| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 700 ; 701Begin_Macro(source); 702{; 703 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 704 auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; 705 for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; 706 gStyle->SetEndErrorSize(3);; 707 gStyle->SetErrorX(1.);; 708 he->SetMarkerStyle(20);; 709 he->Draw(""E1"");; 710}; 711End_Macro; 712 ; 713The options ""E3"" and ""E4"" draw an error band through the end points of the; 714vertical error bars. With ""E4"" the error band is smoothed. Because of the; 715smoothing algorithm used some artefacts may appear at the end of the band; 716like in the following example. In such cases ""E3"" should be used instead; 717of ""E4"".; 718 ; 719Begin_Macro(source); 720{; 721 auto ce4 = new TCanvas(""ce4"",""ce4"",600,400);; 722 ce4->Divide(2,1);; 723 auto he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; 724 Int_t i;; 725 for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; 726 he4->SetFillColor(kRed);; 727 he4->GetXaxis()->SetRange(40,48);; 728 ce4->cd(1);; 729 he4->Draw(""E4"");; 730 ce4->cd(2);; 731 auto he3 = (TH1F*)he4->DrawClone(""E3"");; 732 he3->SetTitle(""Distribution drawn option E3"");; 733}; 734End_Macro; 735 ; 7362D histograms can be drawn with error bars as shown is the following example:; 737 ; 738Begin_Macro(source); 739{; 740 auto c2e = new TCanvas(""c2e"",""c2e"",600,400);; 741 auto h2",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:31555,Availability,error,error,31555,"end points of the vertical error bars.|; 695| ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; 696| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 697| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 698| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 699| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 700 ; 701Begin_Macro(source); 702{; 703 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 704 auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; 705 for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; 706 gStyle->SetEndErrorSize(3);; 707 gStyle->SetErrorX(1.);; 708 he->SetMarkerStyle(20);; 709 he->Draw(""E1"");; 710}; 711End_Macro; 712 ; 713The options ""E3"" and ""E4"" draw an error band through the end points of the; 714vertical error bars. With ""E4"" the error band is smoothed. Because of the; 715smoothing algorithm used some artefacts may appear at the end of the band; 716like in the following example. In such cases ""E3"" should be used instead; 717of ""E4"".; 718 ; 719Begin_Macro(source); 720{; 721 auto ce4 = new TCanvas(""ce4"",""ce4"",600,400);; 722 ce4->Divide(2,1);; 723 auto he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; 724 Int_t i;; 725 for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; 726 he4->SetFillColor(kRed);; 727 he4->GetXaxis()->SetRange(40,48);; 728 ce4->cd(1);; 729 he4->Draw(""E4"");; 730 ce4->cd(2);; 731 auto he3 = (TH1F*)he4->DrawClone(""E3"");; 732 he3->SetTitle(""Distribution drawn option E3"");; 733}; 734End_Macro; 735 ; 7362D histograms can be drawn with error bars as shown is the following example:; 737 ; 738Begin_Macro(source); 739{; 740 auto c2e = new TCanvas(""c2e"",""c2e"",600,400);; 741 auto h2e = new TH2F(""h2e"",""TH2 drawn with option E"",40,-4,4,40,-20,20);; 742 float px, py;; 743 for (Int_t i = 0; i <",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:32305,Availability,error,error,32305,"om->Gaus(0,1));; 706 gStyle->SetEndErrorSize(3);; 707 gStyle->SetErrorX(1.);; 708 he->SetMarkerStyle(20);; 709 he->Draw(""E1"");; 710}; 711End_Macro; 712 ; 713The options ""E3"" and ""E4"" draw an error band through the end points of the; 714vertical error bars. With ""E4"" the error band is smoothed. Because of the; 715smoothing algorithm used some artefacts may appear at the end of the band; 716like in the following example. In such cases ""E3"" should be used instead; 717of ""E4"".; 718 ; 719Begin_Macro(source); 720{; 721 auto ce4 = new TCanvas(""ce4"",""ce4"",600,400);; 722 ce4->Divide(2,1);; 723 auto he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; 724 Int_t i;; 725 for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; 726 he4->SetFillColor(kRed);; 727 he4->GetXaxis()->SetRange(40,48);; 728 ce4->cd(1);; 729 he4->Draw(""E4"");; 730 ce4->cd(2);; 731 auto he3 = (TH1F*)he4->DrawClone(""E3"");; 732 he3->SetTitle(""Distribution drawn option E3"");; 733}; 734End_Macro; 735 ; 7362D histograms can be drawn with error bars as shown is the following example:; 737 ; 738Begin_Macro(source); 739{; 740 auto c2e = new TCanvas(""c2e"",""c2e"",600,400);; 741 auto h2e = new TH2F(""h2e"",""TH2 drawn with option E"",40,-4,4,40,-20,20);; 742 float px, py;; 743 for (Int_t i = 0; i < 25000; i++) {; 744 gRandom->Rannor(px,py);; 745 h2e->Fill(px,5*py);; 746 }; 747 h2e->Draw(""E"");; 748}; 749End_Macro; 750 ; 751 ; 752\anchor HP100; 753### The bar chart option; 754 ; 755 ; 756The option ""B"" allows to draw simple vertical bar charts.; 757The bar width is controlled with `TH1::SetBarWidth()`,; 758and the bar offset within the bin, with `TH1::SetBarOffset()`.; 759These two settings are useful to draw several histograms on the; 760same plot as shown in the following example:; 761 ; 762Begin_Macro(source); 763{; 764 int i;; 765 const Int_t nx = 8;; 766 string os_X[nx] = {""8"",""32"",""128"",""512"",""2048"",""8192"",""32768"",""131072""};; 767 float d_35_0[nx] = {0.75, -3.30, -0.92, 0.10, 0.08, -1.69, -1.29, -2.37};; 76",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:34980,Availability,error,errors,34980,"auto h2b = new TH1F(""h2b"",""h2b"",nx,0,nx);; 791 h2b->SetFillColor(38);; 792 h2b->SetBarWidth(0.4);; 793 h2b->SetBarOffset(0.5);; 794 h2b->SetStats(0);; 795 for (i=1;i<=nx;i++) h2b->SetBinContent(i, d_35_1[i-1]);; 796 ; 797 h2b->Draw(""b same"");; 798}; 799End_Macro; 800 ; 801 ; 802\anchor HP10; 803### The ""BAR"" and ""HBAR"" options; 804 ; 805 ; 806When the option `bar` or `hbar` is specified, a bar chart is drawn. A vertical; 807bar-chart is drawn with the options `bar`, `bar0`, `bar1`, `bar2`, `bar3`, `bar4`.; 808An horizontal bar-chart is drawn with the options `hbar`, `hbar0`, `hbar1`,; 809`hbar2`, `hbar3`, `hbar4` (hbars.C).; 810 ; 811- The bar is filled with the histogram fill color.; 812- The left side of the bar is drawn with a light fill color.; 813- The right side of the bar is drawn with a dark fill color.; 814- The percentage of the bar drawn with either the light or dark color is:; 815 - 0% for option ""(h)bar"" or ""(h)bar0""; 816 - 10% for option ""(h)bar1""; 817 - 20% for option ""(h)bar2""; 818 - 30% for option ""(h)bar3""; 819 - 40% for option ""(h)bar4""; 820 ; 821When an histogram has errors the option [""HIST""](\ref OPTHIST) together with the `(h)bar` option.; 822 ; 823Begin_Macro(source); 824../../../tutorials/hist/hbars.C; 825End_Macro; 826 ; 827To control the bar width (default is the bin width) `TH1::SetBarWidth()`; 828should be used.; 829 ; 830To control the bar offset (default is 0) `TH1::SetBarOffset()` should; 831be used.; 832 ; 833These two parameters are useful when several histograms are plotted using; 834the option `SAME`. They allow to plot the histograms next to each other.; 835 ; 836 ; 837\anchor HP11; 838### The SCATter plot option (legacy draw option); 839 ; 840\attention; 841Use of option `SCAT` has been deprecated. It was the default drawing option for 2D and; 8423D histograms. The new default option is `COL` (heat-map).; 843 ; 844 ; 845For each cell (i,j) a number of points proportional to the cell content is; 846drawn. A maximum of `kNMAX` poin",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:47555,Availability,avail,available,47555,"new TH2F(""h3"",""h3"",40,-3,3,40,-3,3);; 1148 auto h4 = new TH2F(""h4"",""h4"",40,-3,3,40,-3,3);; 1149 h1->SetBit(TH1::kNoStats);; 1150 for (Int_t i=0;i<5000;i++) {; 1151 double x,y;; 1152 gRandom->Rannor(x,y);; 1153 if(x>0 && y>0) h1->Fill(x,y,4);; 1154 if(x<0 && y<0) h2->Fill(x,y,3);; 1155 if(x>0 && y<0) h3->Fill(x,y,2);; 1156 if(x<0 && y>0) h4->Fill(x,y,1);; 1157 }; 1158 h1->Draw(""colz"");; 1159 h2->Draw(""col same"");; 1160 h3->Draw(""col same"");; 1161 h4->Draw(""col same"");; 1162}; 1163End_Macro; 1164 ; 1165The option `COL` can be combined with the option `POL`:; 1166 ; 1167Begin_Macro(source); 1168{; 1169 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 1170 auto hcol1 = new TH2F(""hcol1"",""Option COLor combined with POL"",40,-4,4,40,-4,4);; 1171 float px, py;; 1172 for (Int_t i = 0; i < 25000; i++) {; 1173 gRandom->Rannor(px,py);; 1174 hcol1->Fill(px,py);; 1175 }; 1176 hcol1->Draw(""COLZPOL"");; 1177}; 1178End_Macro; 1179 ; 1180\since **ROOT version 6.07/03:**; 1181 ; 1182A second rendering technique is also available with the COL2 and COLZ2 options.; 1183 ; 1184These options provide potential performance improvements compared to the standard; 1185COL option. The performance comparison of the COL2 to the COL option depends on; 1186the histogram and the size of the rendering region in the current pad. In general,; 1187a small (approx. less than 100 bins per axis), sparsely populated TH2 will render; 1188faster with the COL option.; 1189 ; 1190However, for larger histograms (approx. more than 100 bins per axis); 1191that are not sparse, the COL2 option will provide up to 20 times performance improvements.; 1192For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude; 1193faster with the COL2 option.; 1194 ; 1195The COL2 option will also scale its performance based on the size of the; 1196pixmap the histogram image is being rendered into. It also is much better optimized for; 1197sessions where the user is forwarding X11 windows through an `ssh` connection",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:50501,Availability,error,errors,50501,"rizontal projections) and/or predefined definitions; 1215(1-6 for candles, 1-2 for violins). The order doesn't matter. Default is X and 1.; 1216 ; 1217Instead of using the predefined representations, the candle and violin parameters can be; 1218changed individually. In that case the option have the following form:; 1219 ; 1220 CANDLEX(<option-string>); 1221 CANDLEY(<option-string>); 1222 VIOLINX(<option-string>); 1223 VIOLINY(<option-string>).; 1224 ; 1225All zeros at the beginning of `option-string` can be omitted.; 1226 ; 1227`option-string` consists eight values, defined as follow:; 1228 ; 1229 ""CANDLEX(zhpawMmb)""; 1230 ; 1231Where:; 1232 ; 1233 - `b = 0`; no box drawn; 1234 - `b = 1`; the box is drawn. As the candle-plot is also called a box-plot it; 1235 makes sense in the very most cases to always draw the box; 1236 - `b = 2`; draw a filled box with border; 1237 ; 1238 - `m = 0`; no median drawn; 1239 - `m = 1`; median is drawn as a line; 1240 - `m = 2`; median is drawn with errors (notches); 1241 - `m = 3`; median is drawn as a circle; 1242 ; 1243 - `M = 0`; no mean drawn; 1244 - `M = 1`; mean is drawn as a dashed line; 1245 - `M = 3`; mean is drawn as a circle; 1246 ; 1247 - `w = 0`; no whisker drawn; 1248 - `w = 1`; whisker is drawn to end of distribution.; 1249 - `w = 2`; whisker is drawn to max 1.5*iqr; 1250 ; 1251 - `a = 0`; no anchor drawn; 1252 - `a = 1`; the anchors are drawn; 1253 ; 1254 - `p = 0`; no points drawn; 1255 - `p = 1`; only outliers are drawn; 1256 - `p = 2`; all datapoints are drawn; 1257 - `p = 3`: all datapoints are drawn scattered; 1258 ; 1259 - `h = 0`; no histogram is drawn; 1260 - `h = 1`; histogram at the left or bottom side is drawn; 1261 - `h = 2`; histogram at the right or top side is drawn; 1262 - `h = 3`; histogram at left and right or top and bottom (violin-style) is drawn; 1263 ; 1264 - `z = 0`; no zero indicator line is drawn; 1265 - `z = 1`; zero indicator line is drawn.; 1266 ; 1267As one can see all individual options f",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:53940,Availability,avail,available,53940,"s one candle.; 1294 ; 1295Begin_Macro(source); 1296../../../tutorials/hist/candleplotwhiskers.C; 1297End_Macro; 1298 ; 1299The candle reduces the information coming from a whole distribution into few values.; 1300Independently from the number of entries or the significance of the underlying distribution; 1301a candle will always look like a candle. So candle plots should be used carefully in; 1302particular with unknown distributions. The definition of a candle is based on; 1303__unbinned data__. Here, candles are created from binned data. Because of this, the; 1304deviation is connected to the bin width used. The calculation of the quantiles; 1305normally done on unbinned data also. Because data are binned, this will; 1306only work the best possible way within the resolution of one bin; 1307 ; 1308Because of all these facts one should take care that:; 1309 ; 1310 - there are enough points per candle; 1311 - the bin width is small enough (more bins will increase the maximum; 1312 available resolution of the quantiles although there will be some; 1313 bins with no entries); 1314 - never make a candle-plot if the underlying distribution is double-distributed; 1315 - only create candles of distributions that are more-or-less gaussian (the; 1316 MPV should be not too far away from the mean).; 1317 ; 1318#### What a candle is made of; 1319 ; 1320\since **ROOT version 6.07/05**; 1321 ; 1322##### The box; 1323The box displays the position of the inter-quantile-range of the underlying; 1324distribution. The box contains 25% of the distribution below the median; 1325and 25% of the distribution above the median. If the underlying distribution is large; 1326enough and gaussian shaped the end-points of the box represent \f$ 0.6745\times\sigma \f$; 1327(Where \f$ \sigma \f$ is the standard deviation of the gaussian). The width and; 1328the position of the box can be modified by SetBarWidth() and SetBarOffset().; 1329The +-25% quantiles are calculated by the GetQuantiles() method",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:58862,Availability,avail,available,58862,"mber of entries of the whole; 1386distribution). Candle plots like these are usually called ""notched candle plots"".; 1387 ; 1388In case the significance of the median is greater that the size of the box, the; 1389box will have an unnatural shape. Usually it means the chart has not enough data,; 1390or that representing this uncertainty is not useful; 1391 ; 1392##### The Mean; 1393The mean can be drawn as a dashed line or as a circle or not drawn at all.; 1394The mean is the arithmetic average of the values in the distribution.; 1395It is calculated using GetMean(). Because histograms are; 1396binned data, the mean value can differ from a calculation on the raw-data.; 1397If the distribution is large enough and gaussian shaped the mean will be; 1398exactly the median.; 1399 ; 1400##### The Whiskers; 1401The whiskers represent the part of the distribution not covered by the box.; 1402The upper 25% and the lower 25% of the distribution are located within the whiskers.; 1403Two representations are available.; 1404 ; 1405 - A simple one (using w=1) defining the lower whisker from the lowest data value; 1406 to the bottom of the box, and the upper whisker from the top of the box to the; 1407 highest data value. In this representation the whisker-lines are dashed.; 1408 - A more complex one having a further restriction. The whiskers are still connected; 1409 to the box but their length cannot exceed \f$ 1.5\times iqr \f$. So it might; 1410 be that the outermost part of the underlying distribution will not be covered; 1411 by the whiskers. Usually these missing parts will be represented by the outliers; 1412 (see points). Of course the upper and the lower whisker may differ in length.; 1413 In this representation the whiskers are drawn as solid lines.; 1414 ; 1415\since **ROOT version 6.11/01**; 1416 ; 1417Using the static function TCandle::SetWhiskerRange(double) the whisker definition w=1; 1418will be overwritten. E.g. using a whisker-range of 0.95 and w=1 will redefine ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:70249,Availability,error,errors,70249,"The TEXT and TEXTnn Option; 1627 ; 1628 ; 1629For each bin the content is printed. The text attributes are:; 1630 ; 1631- text font = current TStyle font (`gStyle->SetTextFont()`).; 1632- text size = 0.02*padheight*markersize (if `h` is the histogram drawn; 1633 with the option `TEXT` the marker size can be changed with; 1634 `h->SetMarkerSize(markersize)`).; 1635- text color = marker color.; 1636 ; 1637By default the format `g` is used. This format can be redefined; 1638by calling `gStyle->SetPaintTextFormat()`.; 1639 ; 1640It is also possible to use `TEXTnn` in order to draw the text with; 1641the angle `nn` (`0 < nn <= 90`).; 1642 ; 1643For 2D histograms the text is plotted in the center of each non empty cells.; 1644It is possible to plot empty cells by calling `gStyle->SetHistMinimumZero()`; 1645or providing MIN0 draw option. For 1D histogram the text is plotted at a y; 1646position equal to the bin content.; 1647 ; 1648For 2D histograms when the option ""E"" (errors) is combined with the option; 1649text (""TEXTE""), the error for each bin is also printed.; 1650 ; 1651Begin_Macro(source); 1652{; 1653 auto c01 = new TCanvas(""c01"",""c01"",700,400);; 1654 c01->Divide(2,1);; 1655 auto htext1 = new TH1F(""htext1"",""Option TEXT on 1D histograms "",10,-4,4);; 1656 auto htext2 = new TH2F(""htext2"",""Option TEXT on 2D histograms "",10,-4,4,10,-20,20);; 1657 float px, py;; 1658 for (Int_t i = 0; i < 25000; i++) {; 1659 gRandom->Rannor(px,py);; 1660 htext1->Fill(px,0.1);; 1661 htext2->Fill(px,5*py,0.1);; 1662 }; 1663 gStyle->SetPaintTextFormat(""4.1f m"");; 1664 htext2->SetMarkerSize(1.8);; 1665 c01->cd(1);; 1666 htext2->Draw(""TEXT45"");; 1667 c01->cd(2);; 1668 htext1->Draw();; 1669 htext1->Draw(""HIST TEXT0 SAME"");; 1670}; 1671End_Macro; 1672 ; 1673\since **ROOT version 6.07/07:**; 1674 ; 1675In case several histograms are drawn on top ot each other (using option `SAME`),; 1676the text can be shifted using `SetBarOffset()`. It specifies an offset for the; 1677text position in each cell",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:70310,Availability,error,error,70310,"The TEXT and TEXTnn Option; 1627 ; 1628 ; 1629For each bin the content is printed. The text attributes are:; 1630 ; 1631- text font = current TStyle font (`gStyle->SetTextFont()`).; 1632- text size = 0.02*padheight*markersize (if `h` is the histogram drawn; 1633 with the option `TEXT` the marker size can be changed with; 1634 `h->SetMarkerSize(markersize)`).; 1635- text color = marker color.; 1636 ; 1637By default the format `g` is used. This format can be redefined; 1638by calling `gStyle->SetPaintTextFormat()`.; 1639 ; 1640It is also possible to use `TEXTnn` in order to draw the text with; 1641the angle `nn` (`0 < nn <= 90`).; 1642 ; 1643For 2D histograms the text is plotted in the center of each non empty cells.; 1644It is possible to plot empty cells by calling `gStyle->SetHistMinimumZero()`; 1645or providing MIN0 draw option. For 1D histogram the text is plotted at a y; 1646position equal to the bin content.; 1647 ; 1648For 2D histograms when the option ""E"" (errors) is combined with the option; 1649text (""TEXTE""), the error for each bin is also printed.; 1650 ; 1651Begin_Macro(source); 1652{; 1653 auto c01 = new TCanvas(""c01"",""c01"",700,400);; 1654 c01->Divide(2,1);; 1655 auto htext1 = new TH1F(""htext1"",""Option TEXT on 1D histograms "",10,-4,4);; 1656 auto htext2 = new TH2F(""htext2"",""Option TEXT on 2D histograms "",10,-4,4,10,-20,20);; 1657 float px, py;; 1658 for (Int_t i = 0; i < 25000; i++) {; 1659 gRandom->Rannor(px,py);; 1660 htext1->Fill(px,0.1);; 1661 htext2->Fill(px,5*py,0.1);; 1662 }; 1663 gStyle->SetPaintTextFormat(""4.1f m"");; 1664 htext2->SetMarkerSize(1.8);; 1665 c01->cd(1);; 1666 htext2->Draw(""TEXT45"");; 1667 c01->cd(2);; 1668 htext1->Draw();; 1669 htext1->Draw(""HIST TEXT0 SAME"");; 1670}; 1671End_Macro; 1672 ; 1673\since **ROOT version 6.07/07:**; 1674 ; 1675In case several histograms are drawn on top ot each other (using option `SAME`),; 1676the text can be shifted using `SetBarOffset()`. It specifies an offset for the; 1677text position in each cell",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:102216,Availability,avail,available,102216,"2493<b>WARNING:</b> The palette axis is always drawn vertically.; 2494 ; 2495 ; 2496\anchor HP23; 2497### Setting the color palette; 2498 ; 2499 ; 2500To change the color palette `TStyle::SetPalette` should be used, eg:; 2501 ; 2502 gStyle->SetPalette(ncolors,colors);; 2503 ; 2504For example the option `COL` draws a 2D histogram with cells; 2505represented by a box filled with a color index which is a function; 2506of the cell content.; 2507If the cell content is N, the color index used will be the color number; 2508in `colors[N]`, etc. If the maximum cell content is greater than; 2509`ncolors`, all cell contents are scaled to `ncolors`.; 2510 ; 2511If ` ncolors <= 0`, a default palette (see below) of 50 colors is; 2512defined. This palette is recommended for pads, labels ...; 2513 ; 2514`if ncolors == 1 && colors == 0`, then a Pretty Palette with a; 2515Spectrum Violet->Red is created with 50 colors. That's the default rain bow; 2516palette.; 2517 ; 2518Other pre-defined palettes with 255 colors are available when `colors == 0`.; 2519The following value of `ncolors` give access to:; 2520 ; 2521 ; 2522 if ncolors = 51 and colors=0, a Deep Sea palette is used.; 2523 if ncolors = 52 and colors=0, a Grey Scale palette is used.; 2524 if ncolors = 53 and colors=0, a Dark Body Radiator palette is used.; 2525 if ncolors = 54 and colors=0, a two-color hue palette palette is used.(dark blue through neutral gray to bright yellow); 2526 if ncolors = 55 and colors=0, a Rain Bow palette is used.; 2527 if ncolors = 56 and colors=0, an inverted Dark Body Radiator palette is used.; 2528 ; 2529 ; 2530If `ncolors > 0 && colors == 0`, the default palette is used with a maximum of ncolors.; 2531 ; 2532The default palette defines:; 2533 ; 2534- index 0 to 9 : shades of grey; 2535- index 10 to 19 : shades of brown; 2536- index 20 to 29 : shades of blue; 2537- index 30 to 39 : shades of red; 2538- index 40 to 49 : basic colors; 2539 ; 2540The color numbers specified in the palette can be v",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:111310,Availability,error,errors,111310,"he same pad as if the option `SAME` had been specified. This allows to; 2735compute X and Y scales common to all the histograms, like; 2736`TMultiGraph` does for graphs.; 2737 ; 2738If the option `PADS` is specified, the current pad/canvas is; 2739subdivided into a number of pads equal to the number of histograms and each; 2740histogram is paint into a separate pad.; 2741 ; 2742The following example shows various types of stacks (hstack.C).; 2743 ; 2744Begin_Macro(source); 2745../../../tutorials/hist/hstack.C; 2746End_Macro; 2747 ; 2748The option `nostackb` allows to draw the histograms next to each; 2749other as bar charts:; 2750 ; 2751Begin_Macro(source); 2752{; 2753 auto cst0 = new TCanvas(""cst0"",""cst0"",600,400);; 2754 auto hs = new THStack(""hs"",""Stacked 1D histograms: option #font[82]{\""nostackb\""}"");; 2755 ; 2756 auto h1 = new TH1F(""h1"",""h1"",10,-4,4);; 2757 h1->FillRandom(""gaus"",20000);; 2758 h1->SetFillColor(kRed);; 2759 hs->Add(h1);; 2760 ; 2761 auto h2 = new TH1F(""h2"",""h2"",10,-4,4);; 2762 h2->FillRandom(""gaus"",15000);; 2763 h2->SetFillColor(kBlue);; 2764 hs->Add(h2);; 2765 ; 2766 auto h3 = new TH1F(""h3"",""h3"",10,-4,4);; 2767 h3->FillRandom(""gaus"",10000);; 2768 h3->SetFillColor(kGreen);; 2769 hs->Add(h3);; 2770 ; 2771 hs->Draw(""nostackb"");; 2772 hs->GetXaxis()->SetNdivisions(-10);; 2773 cst0->SetGridx();; 2774}; 2775End_Macro; 2776 ; 2777If at least one of the histograms in the stack has errors, the whole stack is; 2778visualized by default with error bars. To visualize it without errors the; 2779option `HIST` should be used.; 2780 ; 2781Begin_Macro(source); 2782{; 2783 auto cst1 = new TCanvas(""cst1"",""cst1"",700,400);; 2784 cst1->Divide(2,1);; 2785 ; 2786 auto hst11 = new TH1F(""hst11"", """", 20, -10, 10);; 2787 hst11->Sumw2();; 2788 hst11->FillRandom(""gaus"", 1000);; 2789 hst11->SetFillColor(kViolet);; 2790 hst11->SetLineColor(kViolet);; 2791 ; 2792 auto hst12 = new TH1F(""hst12"", """", 20, -10, 10);; 2793 hst12->FillRandom(""gaus"", 500);; 2794 hst12->SetFillColor(kBl",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:111369,Availability,error,error,111369,"he same pad as if the option `SAME` had been specified. This allows to; 2735compute X and Y scales common to all the histograms, like; 2736`TMultiGraph` does for graphs.; 2737 ; 2738If the option `PADS` is specified, the current pad/canvas is; 2739subdivided into a number of pads equal to the number of histograms and each; 2740histogram is paint into a separate pad.; 2741 ; 2742The following example shows various types of stacks (hstack.C).; 2743 ; 2744Begin_Macro(source); 2745../../../tutorials/hist/hstack.C; 2746End_Macro; 2747 ; 2748The option `nostackb` allows to draw the histograms next to each; 2749other as bar charts:; 2750 ; 2751Begin_Macro(source); 2752{; 2753 auto cst0 = new TCanvas(""cst0"",""cst0"",600,400);; 2754 auto hs = new THStack(""hs"",""Stacked 1D histograms: option #font[82]{\""nostackb\""}"");; 2755 ; 2756 auto h1 = new TH1F(""h1"",""h1"",10,-4,4);; 2757 h1->FillRandom(""gaus"",20000);; 2758 h1->SetFillColor(kRed);; 2759 hs->Add(h1);; 2760 ; 2761 auto h2 = new TH1F(""h2"",""h2"",10,-4,4);; 2762 h2->FillRandom(""gaus"",15000);; 2763 h2->SetFillColor(kBlue);; 2764 hs->Add(h2);; 2765 ; 2766 auto h3 = new TH1F(""h3"",""h3"",10,-4,4);; 2767 h3->FillRandom(""gaus"",10000);; 2768 h3->SetFillColor(kGreen);; 2769 hs->Add(h3);; 2770 ; 2771 hs->Draw(""nostackb"");; 2772 hs->GetXaxis()->SetNdivisions(-10);; 2773 cst0->SetGridx();; 2774}; 2775End_Macro; 2776 ; 2777If at least one of the histograms in the stack has errors, the whole stack is; 2778visualized by default with error bars. To visualize it without errors the; 2779option `HIST` should be used.; 2780 ; 2781Begin_Macro(source); 2782{; 2783 auto cst1 = new TCanvas(""cst1"",""cst1"",700,400);; 2784 cst1->Divide(2,1);; 2785 ; 2786 auto hst11 = new TH1F(""hst11"", """", 20, -10, 10);; 2787 hst11->Sumw2();; 2788 hst11->FillRandom(""gaus"", 1000);; 2789 hst11->SetFillColor(kViolet);; 2790 hst11->SetLineColor(kViolet);; 2791 ; 2792 auto hst12 = new TH1F(""hst12"", """", 20, -10, 10);; 2793 hst12->FillRandom(""gaus"", 500);; 2794 hst12->SetFillColor(kBl",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:111405,Availability,error,errors,111405,"d_Macro; 2747 ; 2748The option `nostackb` allows to draw the histograms next to each; 2749other as bar charts:; 2750 ; 2751Begin_Macro(source); 2752{; 2753 auto cst0 = new TCanvas(""cst0"",""cst0"",600,400);; 2754 auto hs = new THStack(""hs"",""Stacked 1D histograms: option #font[82]{\""nostackb\""}"");; 2755 ; 2756 auto h1 = new TH1F(""h1"",""h1"",10,-4,4);; 2757 h1->FillRandom(""gaus"",20000);; 2758 h1->SetFillColor(kRed);; 2759 hs->Add(h1);; 2760 ; 2761 auto h2 = new TH1F(""h2"",""h2"",10,-4,4);; 2762 h2->FillRandom(""gaus"",15000);; 2763 h2->SetFillColor(kBlue);; 2764 hs->Add(h2);; 2765 ; 2766 auto h3 = new TH1F(""h3"",""h3"",10,-4,4);; 2767 h3->FillRandom(""gaus"",10000);; 2768 h3->SetFillColor(kGreen);; 2769 hs->Add(h3);; 2770 ; 2771 hs->Draw(""nostackb"");; 2772 hs->GetXaxis()->SetNdivisions(-10);; 2773 cst0->SetGridx();; 2774}; 2775End_Macro; 2776 ; 2777If at least one of the histograms in the stack has errors, the whole stack is; 2778visualized by default with error bars. To visualize it without errors the; 2779option `HIST` should be used.; 2780 ; 2781Begin_Macro(source); 2782{; 2783 auto cst1 = new TCanvas(""cst1"",""cst1"",700,400);; 2784 cst1->Divide(2,1);; 2785 ; 2786 auto hst11 = new TH1F(""hst11"", """", 20, -10, 10);; 2787 hst11->Sumw2();; 2788 hst11->FillRandom(""gaus"", 1000);; 2789 hst11->SetFillColor(kViolet);; 2790 hst11->SetLineColor(kViolet);; 2791 ; 2792 auto hst12 = new TH1F(""hst12"", """", 20, -10, 10);; 2793 hst12->FillRandom(""gaus"", 500);; 2794 hst12->SetFillColor(kBlue);; 2795 hst12->SetLineColor(kBlue);; 2796 ; 2797 THStack st1(""st1"", ""st1"");; 2798 st1.Add(hst11);; 2799 st1.Add(hst12);; 2800 ; 2801 cst1->cd(1); st1.Draw();; 2802 cst1->cd(2); st1.Draw(""hist"");; 2803}; 2804End_Macro; 2805 ; 2806\anchor HP27; 2807### Drawing of 3D implicit functions; 2808 ; 2809 ; 28103D implicit functions (`TF3`) can be drawn as iso-surfaces.; 2811The implicit function f(x,y,z) = 0 is drawn in cartesian coordinates.; 2812In the following example the options ""FB"" and ""BB"" suppress the; 2813""Front ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:174522,Availability,error,error,174522,"Changed() signal to sync axes; 4579 // fill Hparam structure with histo parameters; 4580 if (!PaintInit()) {; 4581 fXbuf.clear();; 4582 fYbuf.clear();; 4583 return;; 4584 }; 4585 ; 4586 // Picture surround (if new page) and page number (if requested).; 4587 // Histogram surround (if not option ""Same"").; 4588 PaintFrame();; 4589 ; 4590 // Paint histogram axis only; 4591 Bool_t gridx = gPad->GetGridx();; 4592 Bool_t gridy = gPad->GetGridy();; 4593 if (Hoption.Axis > 0) {; 4594 if (Hoption.Axis > 1) PaintAxis(kTRUE); //axis with grid; 4595 else {; 4596 if (gridx) gPad->SetGridx(0);; 4597 if (gridy) gPad->SetGridy(0);; 4598 PaintAxis(kFALSE);; 4599 if (gridx) gPad->SetGridx(1);; 4600 if (gridy) gPad->SetGridy(1);; 4601 }; 4602 if ((Hoption.Same%10) ==1) Hoption.Same += 1;; 4603 goto paintstat;; 4604 }; 4605 if (gridx || gridy) PaintAxis(kTRUE); // Draw the grid only; 4606 ; 4607 // test for options BAR or HBAR; 4608 if (Hoption.Bar >= 10) {; 4609 PaintBar(option);; 4610 }; 4611 ; 4612 // do not draw histogram if error bars required; 4613 if (!Hoption.Error) {; 4614 if (Hoption.Hist && Hoption.Bar<10) PaintHist(option);; 4615 }; 4616 ; 4617 // test for error bars or option E; 4618 if (Hoption.Error) {; 4619 PaintErrors(option);; 4620 if (Hoption.Hist == 2) PaintHist(option);; 4621 }; 4622 ; 4623 if (Hoption.Text) PaintText(option);; 4624 ; 4625 // test for associated function; 4626 if (Hoption.Func) {; 4627 Hoption_t hoptsave = Hoption;; 4628 Hparam_t hparsave = Hparam;; 4629 PaintFunction(option);; 4630 SetHistogram(hsave);; 4631 Hoption = hoptsave;; 4632 Hparam = hparsave;; 4633 }; 4634 ; 4635 if (gridx) gPad->SetGridx(0);; 4636 if (gridy) gPad->SetGridy(0);; 4637 PaintAxis(kFALSE);; 4638 if (gridx) gPad->SetGridx(1);; 4639 if (gridy) gPad->SetGridy(1);; 4640 ; 4641 PaintTitle(); // Draw histogram title; 4642 ; 4643 // Draw box with histogram statistics and/or fit parameters; 4644paintstat:; 4645 if ((Hoption.Same%10) != 1 && !fH->TestBit(TH1::kNoStats)) { // bit set vi",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:174664,Availability,error,error,174664," return;; 4584 }; 4585 ; 4586 // Picture surround (if new page) and page number (if requested).; 4587 // Histogram surround (if not option ""Same"").; 4588 PaintFrame();; 4589 ; 4590 // Paint histogram axis only; 4591 Bool_t gridx = gPad->GetGridx();; 4592 Bool_t gridy = gPad->GetGridy();; 4593 if (Hoption.Axis > 0) {; 4594 if (Hoption.Axis > 1) PaintAxis(kTRUE); //axis with grid; 4595 else {; 4596 if (gridx) gPad->SetGridx(0);; 4597 if (gridy) gPad->SetGridy(0);; 4598 PaintAxis(kFALSE);; 4599 if (gridx) gPad->SetGridx(1);; 4600 if (gridy) gPad->SetGridy(1);; 4601 }; 4602 if ((Hoption.Same%10) ==1) Hoption.Same += 1;; 4603 goto paintstat;; 4604 }; 4605 if (gridx || gridy) PaintAxis(kTRUE); // Draw the grid only; 4606 ; 4607 // test for options BAR or HBAR; 4608 if (Hoption.Bar >= 10) {; 4609 PaintBar(option);; 4610 }; 4611 ; 4612 // do not draw histogram if error bars required; 4613 if (!Hoption.Error) {; 4614 if (Hoption.Hist && Hoption.Bar<10) PaintHist(option);; 4615 }; 4616 ; 4617 // test for error bars or option E; 4618 if (Hoption.Error) {; 4619 PaintErrors(option);; 4620 if (Hoption.Hist == 2) PaintHist(option);; 4621 }; 4622 ; 4623 if (Hoption.Text) PaintText(option);; 4624 ; 4625 // test for associated function; 4626 if (Hoption.Func) {; 4627 Hoption_t hoptsave = Hoption;; 4628 Hparam_t hparsave = Hparam;; 4629 PaintFunction(option);; 4630 SetHistogram(hsave);; 4631 Hoption = hoptsave;; 4632 Hparam = hparsave;; 4633 }; 4634 ; 4635 if (gridx) gPad->SetGridx(0);; 4636 if (gridy) gPad->SetGridy(0);; 4637 PaintAxis(kFALSE);; 4638 if (gridx) gPad->SetGridx(1);; 4639 if (gridy) gPad->SetGridy(1);; 4640 ; 4641 PaintTitle(); // Draw histogram title; 4642 ; 4643 // Draw box with histogram statistics and/or fit parameters; 4644paintstat:; 4645 if ((Hoption.Same%10) != 1 && !fH->TestBit(TH1::kNoStats)) { // bit set via TH1::SetStats; 4646 TIter next(fFunctions);; 4647 TObject *obj = nullptr;; 4648 while ((obj = next())) {; 4649 if (obj->InheritsFrom(TF1::Class())) break;",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:205540,Availability,error,error,205540,"ore iterating; 5465/// through all of the bins.; 5466///; 5467/// \param pAxis the axis to consider; 5468/// \param nPixels the number of pixels to render axis into; 5469/// \param isLog whether the axis is log scale; 5470 ; 5471std::vector<THistRenderingRegion>; 5472THistPainter::ComputeRenderingRegions(TAxis* pAxis, Int_t nPixels, Bool_t isLog); 5473{; 5474 std::vector<THistRenderingRegion> regions;; 5475 ; 5476 enum STRATEGY { Bins, Pixels } strategy;; 5477 ; 5478 Int_t nBins = (pAxis->GetLast() - pAxis->GetFirst() + 1);; 5479 ; 5480 if (nBins >= nPixels) {; 5481 // more bins than pixels... we should loop over pixels and sample; 5482 strategy = Pixels;; 5483 } else {; 5484 // fewer bins than pixels... we should loop over bins; 5485 strategy = Bins;; 5486 }; 5487 ; 5488 if (isLog) {; 5489 ; 5490 Double_t xMin = pAxis->GetBinLowEdge(pAxis->GetFirst());; 5491 Int_t binOffset=0;; 5492 while (xMin <= 0 && ((pAxis->GetFirst()+binOffset) != pAxis->GetLast()) ) {; 5493 binOffset++;; 5494 xMin = pAxis->GetBinLowEdge(pAxis->GetFirst()+binOffset);; 5495 }; 5496 if (xMin <= 0) {; 5497 // this should cause an error if we have; 5498 return regions;; 5499 }; 5500 Double_t xMax = pAxis->GetBinUpEdge(pAxis->GetLast());; 5501 ; 5502 if (strategy == Bins) {; 5503 // logarithmic plot. we find the pixel for the bin; 5504 // pixel = eta * log10(V) - alpha; 5505 // where eta = nPixels/(log10(Vmax)-log10(Vmin)); 5506 // and alpha = nPixels*log10(Vmin)/(log10(Vmax)-log10(Vmin)); 5507 // and V is axis value; 5508 Double_t eta = (nPixels-1.0)/(TMath::Log10(xMax) - TMath::Log10(xMin));; 5509 Double_t offset = -1.0 * eta * TMath::Log10(xMin);; 5510 ; 5511 for (Int_t bin=pAxis->GetFirst()+binOffset; bin<=pAxis->GetLast(); bin++) {; 5512 ; 5513 // linear plot. we simply need to find the appropriate bin; 5514 // for the; 5515 Double_t xLowValue = pAxis->GetBinLowEdge(bin);; 5516 Double_t xUpValue = pAxis->GetBinUpEdge(bin);; 5517 Int_t xPx0 = eta*TMath::Log10(xLowValue)+ offset;; 5518 Int_t xPx1",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:211159,Availability,error,error,211159,"> colorBounds(ndiv);; 5633 std::vector<Double_t> contours(ndiv, 0);; 5634 if (!fH->TestBit(TH1::kUserContour)) {; 5635 fH->SetContour(ndiv);; 5636 } else {; 5637 fH->GetContour(contours.data());; 5638 }; 5639 ; 5640 Double_t step = 1.0/ndiv;; 5641 for (Int_t i=0; i<ndiv; ++i) {; 5642 colorBounds[i] = step*i;; 5643 }; 5644 ; 5645 auto pFrame = gPad->GetFrame();; 5646 Int_t px0 = gPad->XtoPixel(pFrame->GetX1());; 5647 Int_t px1 = gPad->XtoPixel(pFrame->GetX2());; 5648 Int_t py0 = gPad->YtoPixel(pFrame->GetY1());; 5649 Int_t py1 = gPad->YtoPixel(pFrame->GetY2());; 5650 Int_t nXPixels = px1-px0;; 5651 Int_t nYPixels = py0-py1; // y=0 is at the top of the screen; 5652 ; 5653 std::vector<Double_t> buffer(nXPixels*nYPixels, 0);; 5654 ; 5655 auto xRegions = ComputeRenderingRegions(fXaxis, nXPixels, Hoption.Logx);; 5656 auto yRegions = ComputeRenderingRegions(fYaxis, nYPixels, Hoption.Logy);; 5657 if (xRegions.empty() || yRegions.empty()) {; 5658 Error(""THistPainter::PaintColorLevelFast(Option_t*)"",; 5659 ""Encountered error while computing rendering regions."");; 5660 return;; 5661 }; 5662 ; 5663 Bool_t minExists = kFALSE;; 5664 Bool_t maxExists = kFALSE;; 5665 Double_t minValue = 1.;; 5666 Double_t maxValue = 0.;; 5667 for (auto& yRegion : yRegions) {; 5668 for (auto& xRegion : xRegions ) {; 5669 ; 5670 const auto& xBinRange = xRegion.fBinRange;; 5671 const auto& yBinRange = yRegion.fBinRange;; 5672 ; 5673 // sample the range; 5674 z = fH->GetBinContent(xBinRange.second-1, yBinRange.second-1);; 5675 ; 5676 if (Hoption.Logz) {; 5677 if (z > 0) z = TMath::Log10(z);; 5678 else z = zmin;; 5679 }; 5680 ; 5681 // obey the user's max and min values if they were set; 5682 if (z > zmax) z = zmax;; 5683 if (z < zmin) z = zmin;; 5684 ; 5685 if (fH->TestBit(TH1::kUserContour)) {; 5686 // contours are absolute values; 5687 auto index = TMath::BinarySearch(contours.size(), contours.data(), z);; 5688 z = colorBounds[index];; 5689 } else {; 5690 Int_t index = 0;; 5691 if (dz != 0) {; 5692 i",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:231844,Availability,error,error,231844,"t vert;; 6263 Double_t tlen, tdif, elev, diff, pdif, xlen;; 6264 Int_t n, i, icount;; 6265 ; 6266 if (x1 == x2) {; 6267 vert = kTRUE;; 6268 tlen = y2 - y1;; 6269 } else {; 6270 vert = kFALSE;; 6271 tlen = x2 - x1;; 6272 }; 6273 ; 6274 n = icont1 +1;; 6275 tdif = elev2 - elev1;; 6276 i = 0;; 6277 icount = 0;; 6278 while (n <= icont2 && i <= kMAXCONTOUR/2 -3) {; 6279 //elev = fH->GetContourLevel(n);; 6280 elev = levels[n];; 6281 diff = elev - elev1;; 6282 pdif = diff/tdif;; 6283 xlen = tlen*pdif;; 6284 if (vert) {; 6285 if (Hoption.Logx); 6286 xarr[i] = TMath::Log10(x1);; 6287 else; 6288 xarr[i] = x1;; 6289 if (Hoption.Logy); 6290 yarr[i] = TMath::Log10(y1 + xlen);; 6291 else; 6292 yarr[i] = y1 + xlen;; 6293 } else {; 6294 if (Hoption.Logx); 6295 xarr[i] = TMath::Log10(x1 + xlen);; 6296 else; 6297 xarr[i] = x1 + xlen;; 6298 if (Hoption.Logy); 6299 yarr[i] = TMath::Log10(y1);; 6300 else; 6301 yarr[i] = y1;; 6302 }; 6303 itarr[i] = n;; 6304 icount++;; 6305 i +=2;; 6306 n++;; 6307 }; 6308 return icount;; 6309}; 6310 ; 6311////////////////////////////////////////////////////////////////////////////////; 6312/// [Draw 1D histograms error bars.](\ref HP09); 6313 ; 6314void THistPainter::PaintErrors(Option_t *); 6315{; 6316 ; 6317 // On iOS, we do not highlight histogram, if it's not picked at the moment; 6318 // (but part of histogram (axis or pavestat) was picked, that's why this code; 6319 // is called at all. This conditional statement never executes on non-iOS platform.; 6320 if (gPad->PadInHighlightMode() && gPad->GetSelected() != fH) return;; 6321 ; 6322 const Int_t kBASEMARKER=8;; 6323 Double_t xp, yp, ex1, ex2, ey1, ey2;; 6324 Double_t delta;; 6325 Double_t s2x, s2y, bxsize, bysize, symbolsize, xerror, sbasex, sbasey;; 6326 Double_t xi1, xi2, xi3, xi4, yi1, yi2, yi3, yi4;; 6327 Double_t xmin, xmax, ymin, ymax;; 6328 Double_t logxmin = 0;; 6329 Double_t logymin = 0;; 6330 Double_t offset = 0.;; 6331 Double_t width = 0.;; 6332 Int_t i, k, npoints, first, last, fixbin;",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:232768,Availability,error,errormarker,232768,"/////////////////////////////////////; 6312/// [Draw 1D histograms error bars.](\ref HP09); 6313 ; 6314void THistPainter::PaintErrors(Option_t *); 6315{; 6316 ; 6317 // On iOS, we do not highlight histogram, if it's not picked at the moment; 6318 // (but part of histogram (axis or pavestat) was picked, that's why this code; 6319 // is called at all. This conditional statement never executes on non-iOS platform.; 6320 if (gPad->PadInHighlightMode() && gPad->GetSelected() != fH) return;; 6321 ; 6322 const Int_t kBASEMARKER=8;; 6323 Double_t xp, yp, ex1, ex2, ey1, ey2;; 6324 Double_t delta;; 6325 Double_t s2x, s2y, bxsize, bysize, symbolsize, xerror, sbasex, sbasey;; 6326 Double_t xi1, xi2, xi3, xi4, yi1, yi2, yi3, yi4;; 6327 Double_t xmin, xmax, ymin, ymax;; 6328 Double_t logxmin = 0;; 6329 Double_t logymin = 0;; 6330 Double_t offset = 0.;; 6331 Double_t width = 0.;; 6332 Int_t i, k, npoints, first, last, fixbin;; 6333 Int_t if1 = 0;; 6334 Int_t if2 = 0;; 6335 Int_t drawmarker, errormarker;; 6336 Int_t option0, option1, option2, option3, option4, optionE, optionEX0, optionI0;; 6337 static Float_t cxx[30] = {1.0,1.0,0.5,0.5,1.0,1.0,0.5,0.6,1.0,0.5,0.5,1.0,0.5,0.6,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 6338 static Float_t cyy[30] = {1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.5,0.5,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 6339 ; 6340 std::vector<Double_t> xline, yline;; 6341 option0 = option1 = option2 = option3 = option4 = optionE = optionEX0 = optionI0 = 0;; 6342 if (Hoption.Error >= 40) {Hoption.Error -=40; option0 = 1;}; 6343 if (Int_t(Hoption.Error/10) == 2) {optionEX0 = 1; Hoption.Error -= 10;}; 6344 if (Hoption.Error == 31) {optionEX0 = 1; Hoption.Error = 1;}; 6345 if (Hoption.Error == 11) option1 = 1;; 6346 if (Hoption.Error == 12) option2 = 1;; 6347 if (Hoption.Error == 13) option3 = 1;; 6348 if (Hoption.Error == 14) {option4 = 1; option3 = 1;}; 6349 if (Hoption.Error == 15) {optionI0 = 1; option3 = 1;",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:234097,Availability,error,errormarker,234097,".0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 6339 ; 6340 std::vector<Double_t> xline, yline;; 6341 option0 = option1 = option2 = option3 = option4 = optionE = optionEX0 = optionI0 = 0;; 6342 if (Hoption.Error >= 40) {Hoption.Error -=40; option0 = 1;}; 6343 if (Int_t(Hoption.Error/10) == 2) {optionEX0 = 1; Hoption.Error -= 10;}; 6344 if (Hoption.Error == 31) {optionEX0 = 1; Hoption.Error = 1;}; 6345 if (Hoption.Error == 11) option1 = 1;; 6346 if (Hoption.Error == 12) option2 = 1;; 6347 if (Hoption.Error == 13) option3 = 1;; 6348 if (Hoption.Error == 14) {option4 = 1; option3 = 1;}; 6349 if (Hoption.Error == 15) {optionI0 = 1; option3 = 1;}; 6350 if (Hoption.Error == 16) {optionI0 = 1; option4 = 1; option3 = 1;}; 6351 if (option2+option3 == 0) optionE = 1;; 6352 if (Hoption.Error == 0) optionE = 0;; 6353 if (fXaxis->GetXbins()->fN) fixbin = 0;; 6354 else fixbin = 1;; 6355 ; 6356 offset = fH->GetBarOffset();; 6357 width = fH->GetBarWidth();; 6358 ; 6359 errormarker = TAttMarker::GetMarkerStyleBase(fH->GetMarkerStyle());; 6360 if (optionEX0) {; 6361 xerror = 0;; 6362 } else {; 6363 xerror = gStyle->GetErrorX();; 6364 }; 6365 symbolsize = fH->GetMarkerSize();; 6366 if (errormarker == 1) symbolsize = 0.01;; 6367 sbasex = sbasey = symbolsize*kBASEMARKER;; 6368 if (errormarker >= 20 && errormarker <= 49) {; 6369 sbasex *= cxx[errormarker-20];; 6370 sbasey *= cyy[errormarker-20];; 6371 }; 6372 // set the graphics attributes; 6373 ; 6374 fH->TAttLine::Modify();; 6375 fH->TAttFill::Modify();; 6376 fH->TAttMarker::Modify();; 6377 ; 6378 // set the first and last bin; 6379 ; 6380 Double_t factor = Hparam.factor;; 6381 first = Hparam.xfirst;; 6382 last = Hparam.xlast;; 6383 npoints = last - first +1;; 6384 xmin = gPad->GetUxmin();; 6385 xmax = gPad->GetUxmax();; 6386 ymin = gPad->GetUymin();; 6387 ymax = gPad->GetUymax();; 6388 ; 6389 ; 6390 if (option3) {; 6391 xline.resize(2*npoints);; 6392 yline.resize(2*npoints);; 6393 if ((npoints > 0) && (xline.empty() || yline.empty())) {;",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:234315,Availability,error,errormarker,234315,".0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 6339 ; 6340 std::vector<Double_t> xline, yline;; 6341 option0 = option1 = option2 = option3 = option4 = optionE = optionEX0 = optionI0 = 0;; 6342 if (Hoption.Error >= 40) {Hoption.Error -=40; option0 = 1;}; 6343 if (Int_t(Hoption.Error/10) == 2) {optionEX0 = 1; Hoption.Error -= 10;}; 6344 if (Hoption.Error == 31) {optionEX0 = 1; Hoption.Error = 1;}; 6345 if (Hoption.Error == 11) option1 = 1;; 6346 if (Hoption.Error == 12) option2 = 1;; 6347 if (Hoption.Error == 13) option3 = 1;; 6348 if (Hoption.Error == 14) {option4 = 1; option3 = 1;}; 6349 if (Hoption.Error == 15) {optionI0 = 1; option3 = 1;}; 6350 if (Hoption.Error == 16) {optionI0 = 1; option4 = 1; option3 = 1;}; 6351 if (option2+option3 == 0) optionE = 1;; 6352 if (Hoption.Error == 0) optionE = 0;; 6353 if (fXaxis->GetXbins()->fN) fixbin = 0;; 6354 else fixbin = 1;; 6355 ; 6356 offset = fH->GetBarOffset();; 6357 width = fH->GetBarWidth();; 6358 ; 6359 errormarker = TAttMarker::GetMarkerStyleBase(fH->GetMarkerStyle());; 6360 if (optionEX0) {; 6361 xerror = 0;; 6362 } else {; 6363 xerror = gStyle->GetErrorX();; 6364 }; 6365 symbolsize = fH->GetMarkerSize();; 6366 if (errormarker == 1) symbolsize = 0.01;; 6367 sbasex = sbasey = symbolsize*kBASEMARKER;; 6368 if (errormarker >= 20 && errormarker <= 49) {; 6369 sbasex *= cxx[errormarker-20];; 6370 sbasey *= cyy[errormarker-20];; 6371 }; 6372 // set the graphics attributes; 6373 ; 6374 fH->TAttLine::Modify();; 6375 fH->TAttFill::Modify();; 6376 fH->TAttMarker::Modify();; 6377 ; 6378 // set the first and last bin; 6379 ; 6380 Double_t factor = Hparam.factor;; 6381 first = Hparam.xfirst;; 6382 last = Hparam.xlast;; 6383 npoints = last - first +1;; 6384 xmin = gPad->GetUxmin();; 6385 xmax = gPad->GetUxmax();; 6386 ymin = gPad->GetUymin();; 6387 ymax = gPad->GetUymax();; 6388 ; 6389 ; 6390 if (option3) {; 6391 xline.resize(2*npoints);; 6392 yline.resize(2*npoints);; 6393 if ((npoints > 0) && (xline.empty() || yline.empty())) {;",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:234410,Availability,error,errormarker,234410,"or == 11) option1 = 1;; 6346 if (Hoption.Error == 12) option2 = 1;; 6347 if (Hoption.Error == 13) option3 = 1;; 6348 if (Hoption.Error == 14) {option4 = 1; option3 = 1;}; 6349 if (Hoption.Error == 15) {optionI0 = 1; option3 = 1;}; 6350 if (Hoption.Error == 16) {optionI0 = 1; option4 = 1; option3 = 1;}; 6351 if (option2+option3 == 0) optionE = 1;; 6352 if (Hoption.Error == 0) optionE = 0;; 6353 if (fXaxis->GetXbins()->fN) fixbin = 0;; 6354 else fixbin = 1;; 6355 ; 6356 offset = fH->GetBarOffset();; 6357 width = fH->GetBarWidth();; 6358 ; 6359 errormarker = TAttMarker::GetMarkerStyleBase(fH->GetMarkerStyle());; 6360 if (optionEX0) {; 6361 xerror = 0;; 6362 } else {; 6363 xerror = gStyle->GetErrorX();; 6364 }; 6365 symbolsize = fH->GetMarkerSize();; 6366 if (errormarker == 1) symbolsize = 0.01;; 6367 sbasex = sbasey = symbolsize*kBASEMARKER;; 6368 if (errormarker >= 20 && errormarker <= 49) {; 6369 sbasex *= cxx[errormarker-20];; 6370 sbasey *= cyy[errormarker-20];; 6371 }; 6372 // set the graphics attributes; 6373 ; 6374 fH->TAttLine::Modify();; 6375 fH->TAttFill::Modify();; 6376 fH->TAttMarker::Modify();; 6377 ; 6378 // set the first and last bin; 6379 ; 6380 Double_t factor = Hparam.factor;; 6381 first = Hparam.xfirst;; 6382 last = Hparam.xlast;; 6383 npoints = last - first +1;; 6384 xmin = gPad->GetUxmin();; 6385 xmax = gPad->GetUxmax();; 6386 ymin = gPad->GetUymin();; 6387 ymax = gPad->GetUymax();; 6388 ; 6389 ; 6390 if (option3) {; 6391 xline.resize(2*npoints);; 6392 yline.resize(2*npoints);; 6393 if ((npoints > 0) && (xline.empty() || yline.empty())) {; 6394 Error(""PaintErrors"", ""too many points, out of memory"");; 6395 return;; 6396 }; 6397 if1 = 1;; 6398 if2 = 2*npoints;; 6399 }; 6400 ; 6401 // compute the offset of the error bars due to the symbol size; 6402 s2x = gPad->PixeltoX(Int_t(0.5*sbasex)) - gPad->PixeltoX(0);; 6403 s2y =-gPad->PixeltoY(Int_t(0.5*sbasey)) + gPad->PixeltoY(0);; 6404 ; 6405 // compute size of the lines at the end of the error bars; 6406 I",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:234431,Availability,error,errormarker,234431,"or == 11) option1 = 1;; 6346 if (Hoption.Error == 12) option2 = 1;; 6347 if (Hoption.Error == 13) option3 = 1;; 6348 if (Hoption.Error == 14) {option4 = 1; option3 = 1;}; 6349 if (Hoption.Error == 15) {optionI0 = 1; option3 = 1;}; 6350 if (Hoption.Error == 16) {optionI0 = 1; option4 = 1; option3 = 1;}; 6351 if (option2+option3 == 0) optionE = 1;; 6352 if (Hoption.Error == 0) optionE = 0;; 6353 if (fXaxis->GetXbins()->fN) fixbin = 0;; 6354 else fixbin = 1;; 6355 ; 6356 offset = fH->GetBarOffset();; 6357 width = fH->GetBarWidth();; 6358 ; 6359 errormarker = TAttMarker::GetMarkerStyleBase(fH->GetMarkerStyle());; 6360 if (optionEX0) {; 6361 xerror = 0;; 6362 } else {; 6363 xerror = gStyle->GetErrorX();; 6364 }; 6365 symbolsize = fH->GetMarkerSize();; 6366 if (errormarker == 1) symbolsize = 0.01;; 6367 sbasex = sbasey = symbolsize*kBASEMARKER;; 6368 if (errormarker >= 20 && errormarker <= 49) {; 6369 sbasex *= cxx[errormarker-20];; 6370 sbasey *= cyy[errormarker-20];; 6371 }; 6372 // set the graphics attributes; 6373 ; 6374 fH->TAttLine::Modify();; 6375 fH->TAttFill::Modify();; 6376 fH->TAttMarker::Modify();; 6377 ; 6378 // set the first and last bin; 6379 ; 6380 Double_t factor = Hparam.factor;; 6381 first = Hparam.xfirst;; 6382 last = Hparam.xlast;; 6383 npoints = last - first +1;; 6384 xmin = gPad->GetUxmin();; 6385 xmax = gPad->GetUxmax();; 6386 ymin = gPad->GetUymin();; 6387 ymax = gPad->GetUymax();; 6388 ; 6389 ; 6390 if (option3) {; 6391 xline.resize(2*npoints);; 6392 yline.resize(2*npoints);; 6393 if ((npoints > 0) && (xline.empty() || yline.empty())) {; 6394 Error(""PaintErrors"", ""too many points, out of memory"");; 6395 return;; 6396 }; 6397 if1 = 1;; 6398 if2 = 2*npoints;; 6399 }; 6400 ; 6401 // compute the offset of the error bars due to the symbol size; 6402 s2x = gPad->PixeltoX(Int_t(0.5*sbasex)) - gPad->PixeltoX(0);; 6403 s2y =-gPad->PixeltoY(Int_t(0.5*sbasey)) + gPad->PixeltoY(0);; 6404 ; 6405 // compute size of the lines at the end of the error bars; 6406 I",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:234472,Availability,error,errormarker-,234472,"or == 11) option1 = 1;; 6346 if (Hoption.Error == 12) option2 = 1;; 6347 if (Hoption.Error == 13) option3 = 1;; 6348 if (Hoption.Error == 14) {option4 = 1; option3 = 1;}; 6349 if (Hoption.Error == 15) {optionI0 = 1; option3 = 1;}; 6350 if (Hoption.Error == 16) {optionI0 = 1; option4 = 1; option3 = 1;}; 6351 if (option2+option3 == 0) optionE = 1;; 6352 if (Hoption.Error == 0) optionE = 0;; 6353 if (fXaxis->GetXbins()->fN) fixbin = 0;; 6354 else fixbin = 1;; 6355 ; 6356 offset = fH->GetBarOffset();; 6357 width = fH->GetBarWidth();; 6358 ; 6359 errormarker = TAttMarker::GetMarkerStyleBase(fH->GetMarkerStyle());; 6360 if (optionEX0) {; 6361 xerror = 0;; 6362 } else {; 6363 xerror = gStyle->GetErrorX();; 6364 }; 6365 symbolsize = fH->GetMarkerSize();; 6366 if (errormarker == 1) symbolsize = 0.01;; 6367 sbasex = sbasey = symbolsize*kBASEMARKER;; 6368 if (errormarker >= 20 && errormarker <= 49) {; 6369 sbasex *= cxx[errormarker-20];; 6370 sbasey *= cyy[errormarker-20];; 6371 }; 6372 // set the graphics attributes; 6373 ; 6374 fH->TAttLine::Modify();; 6375 fH->TAttFill::Modify();; 6376 fH->TAttMarker::Modify();; 6377 ; 6378 // set the first and last bin; 6379 ; 6380 Double_t factor = Hparam.factor;; 6381 first = Hparam.xfirst;; 6382 last = Hparam.xlast;; 6383 npoints = last - first +1;; 6384 xmin = gPad->GetUxmin();; 6385 xmax = gPad->GetUxmax();; 6386 ymin = gPad->GetUymin();; 6387 ymax = gPad->GetUymax();; 6388 ; 6389 ; 6390 if (option3) {; 6391 xline.resize(2*npoints);; 6392 yline.resize(2*npoints);; 6393 if ((npoints > 0) && (xline.empty() || yline.empty())) {; 6394 Error(""PaintErrors"", ""too many points, out of memory"");; 6395 return;; 6396 }; 6397 if1 = 1;; 6398 if2 = 2*npoints;; 6399 }; 6400 ; 6401 // compute the offset of the error bars due to the symbol size; 6402 s2x = gPad->PixeltoX(Int_t(0.5*sbasex)) - gPad->PixeltoX(0);; 6403 s2y =-gPad->PixeltoY(Int_t(0.5*sbasey)) + gPad->PixeltoY(0);; 6404 ; 6405 // compute size of the lines at the end of the error bars; 6406 I",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:234509,Availability,error,errormarker-,234509,"or == 11) option1 = 1;; 6346 if (Hoption.Error == 12) option2 = 1;; 6347 if (Hoption.Error == 13) option3 = 1;; 6348 if (Hoption.Error == 14) {option4 = 1; option3 = 1;}; 6349 if (Hoption.Error == 15) {optionI0 = 1; option3 = 1;}; 6350 if (Hoption.Error == 16) {optionI0 = 1; option4 = 1; option3 = 1;}; 6351 if (option2+option3 == 0) optionE = 1;; 6352 if (Hoption.Error == 0) optionE = 0;; 6353 if (fXaxis->GetXbins()->fN) fixbin = 0;; 6354 else fixbin = 1;; 6355 ; 6356 offset = fH->GetBarOffset();; 6357 width = fH->GetBarWidth();; 6358 ; 6359 errormarker = TAttMarker::GetMarkerStyleBase(fH->GetMarkerStyle());; 6360 if (optionEX0) {; 6361 xerror = 0;; 6362 } else {; 6363 xerror = gStyle->GetErrorX();; 6364 }; 6365 symbolsize = fH->GetMarkerSize();; 6366 if (errormarker == 1) symbolsize = 0.01;; 6367 sbasex = sbasey = symbolsize*kBASEMARKER;; 6368 if (errormarker >= 20 && errormarker <= 49) {; 6369 sbasex *= cxx[errormarker-20];; 6370 sbasey *= cyy[errormarker-20];; 6371 }; 6372 // set the graphics attributes; 6373 ; 6374 fH->TAttLine::Modify();; 6375 fH->TAttFill::Modify();; 6376 fH->TAttMarker::Modify();; 6377 ; 6378 // set the first and last bin; 6379 ; 6380 Double_t factor = Hparam.factor;; 6381 first = Hparam.xfirst;; 6382 last = Hparam.xlast;; 6383 npoints = last - first +1;; 6384 xmin = gPad->GetUxmin();; 6385 xmax = gPad->GetUxmax();; 6386 ymin = gPad->GetUymin();; 6387 ymax = gPad->GetUymax();; 6388 ; 6389 ; 6390 if (option3) {; 6391 xline.resize(2*npoints);; 6392 yline.resize(2*npoints);; 6393 if ((npoints > 0) && (xline.empty() || yline.empty())) {; 6394 Error(""PaintErrors"", ""too many points, out of memory"");; 6395 return;; 6396 }; 6397 if1 = 1;; 6398 if2 = 2*npoints;; 6399 }; 6400 ; 6401 // compute the offset of the error bars due to the symbol size; 6402 s2x = gPad->PixeltoX(Int_t(0.5*sbasex)) - gPad->PixeltoX(0);; 6403 s2y =-gPad->PixeltoY(Int_t(0.5*sbasey)) + gPad->PixeltoY(0);; 6404 ; 6405 // compute size of the lines at the end of the error bars; 6406 I",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:235304,Availability,error,error,235304,"tErrorX();; 6364 }; 6365 symbolsize = fH->GetMarkerSize();; 6366 if (errormarker == 1) symbolsize = 0.01;; 6367 sbasex = sbasey = symbolsize*kBASEMARKER;; 6368 if (errormarker >= 20 && errormarker <= 49) {; 6369 sbasex *= cxx[errormarker-20];; 6370 sbasey *= cyy[errormarker-20];; 6371 }; 6372 // set the graphics attributes; 6373 ; 6374 fH->TAttLine::Modify();; 6375 fH->TAttFill::Modify();; 6376 fH->TAttMarker::Modify();; 6377 ; 6378 // set the first and last bin; 6379 ; 6380 Double_t factor = Hparam.factor;; 6381 first = Hparam.xfirst;; 6382 last = Hparam.xlast;; 6383 npoints = last - first +1;; 6384 xmin = gPad->GetUxmin();; 6385 xmax = gPad->GetUxmax();; 6386 ymin = gPad->GetUymin();; 6387 ymax = gPad->GetUymax();; 6388 ; 6389 ; 6390 if (option3) {; 6391 xline.resize(2*npoints);; 6392 yline.resize(2*npoints);; 6393 if ((npoints > 0) && (xline.empty() || yline.empty())) {; 6394 Error(""PaintErrors"", ""too many points, out of memory"");; 6395 return;; 6396 }; 6397 if1 = 1;; 6398 if2 = 2*npoints;; 6399 }; 6400 ; 6401 // compute the offset of the error bars due to the symbol size; 6402 s2x = gPad->PixeltoX(Int_t(0.5*sbasex)) - gPad->PixeltoX(0);; 6403 s2y =-gPad->PixeltoY(Int_t(0.5*sbasey)) + gPad->PixeltoY(0);; 6404 ; 6405 // compute size of the lines at the end of the error bars; 6406 Int_t dxend = Int_t(gStyle->GetEndErrorSize());; 6407 bxsize = gPad->PixeltoX(dxend) - gPad->PixeltoX(0);; 6408 bysize =-gPad->PixeltoY(dxend) + gPad->PixeltoY(0);; 6409 ; 6410 ; 6411 if (fixbin) {; 6412 if (Hoption.Logx) xp = TMath::Power(10,Hparam.xmin) + 0.5*Hparam.xbinsize;; 6413 else xp = Hparam.xmin + 0.5*Hparam.xbinsize;; 6414 } else {; 6415 delta = fH->GetBinWidth(first);; 6416 xp = fH->GetBinLowEdge(first) + 0.5*delta;; 6417 }; 6418 ; 6419 // if errormarker = 0 or symbolsize = 0. no symbol is drawn; 6420 if (Hoption.Logx) logxmin = TMath::Power(10,Hparam.xmin);; 6421 if (Hoption.Logy) logymin = TMath::Power(10,Hparam.ymin);; 6422 ; 6423 // ---------------------- Loop over the poin",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:235532,Availability,error,error,235532,"fy();; 6375 fH->TAttFill::Modify();; 6376 fH->TAttMarker::Modify();; 6377 ; 6378 // set the first and last bin; 6379 ; 6380 Double_t factor = Hparam.factor;; 6381 first = Hparam.xfirst;; 6382 last = Hparam.xlast;; 6383 npoints = last - first +1;; 6384 xmin = gPad->GetUxmin();; 6385 xmax = gPad->GetUxmax();; 6386 ymin = gPad->GetUymin();; 6387 ymax = gPad->GetUymax();; 6388 ; 6389 ; 6390 if (option3) {; 6391 xline.resize(2*npoints);; 6392 yline.resize(2*npoints);; 6393 if ((npoints > 0) && (xline.empty() || yline.empty())) {; 6394 Error(""PaintErrors"", ""too many points, out of memory"");; 6395 return;; 6396 }; 6397 if1 = 1;; 6398 if2 = 2*npoints;; 6399 }; 6400 ; 6401 // compute the offset of the error bars due to the symbol size; 6402 s2x = gPad->PixeltoX(Int_t(0.5*sbasex)) - gPad->PixeltoX(0);; 6403 s2y =-gPad->PixeltoY(Int_t(0.5*sbasey)) + gPad->PixeltoY(0);; 6404 ; 6405 // compute size of the lines at the end of the error bars; 6406 Int_t dxend = Int_t(gStyle->GetEndErrorSize());; 6407 bxsize = gPad->PixeltoX(dxend) - gPad->PixeltoX(0);; 6408 bysize =-gPad->PixeltoY(dxend) + gPad->PixeltoY(0);; 6409 ; 6410 ; 6411 if (fixbin) {; 6412 if (Hoption.Logx) xp = TMath::Power(10,Hparam.xmin) + 0.5*Hparam.xbinsize;; 6413 else xp = Hparam.xmin + 0.5*Hparam.xbinsize;; 6414 } else {; 6415 delta = fH->GetBinWidth(first);; 6416 xp = fH->GetBinLowEdge(first) + 0.5*delta;; 6417 }; 6418 ; 6419 // if errormarker = 0 or symbolsize = 0. no symbol is drawn; 6420 if (Hoption.Logx) logxmin = TMath::Power(10,Hparam.xmin);; 6421 if (Hoption.Logy) logymin = TMath::Power(10,Hparam.ymin);; 6422 ; 6423 // ---------------------- Loop over the points---------------------; 6424 for (k=first; k<=last; k++) {; 6425 ; 6426 // get the data; 6427 // xp = X position of the current point; 6428 // yp = Y position of the current point; 6429 // ex1 = Low X error; 6430 // ex2 = Up X error; 6431 // ey1 = Low Y error; 6432 // ey2 = Up Y error; 6433 // (xi,yi) = Error bars coordinates; 6434 ; 6435 // apply offse",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:236008,Availability,error,errormarker,236008," 6391 xline.resize(2*npoints);; 6392 yline.resize(2*npoints);; 6393 if ((npoints > 0) && (xline.empty() || yline.empty())) {; 6394 Error(""PaintErrors"", ""too many points, out of memory"");; 6395 return;; 6396 }; 6397 if1 = 1;; 6398 if2 = 2*npoints;; 6399 }; 6400 ; 6401 // compute the offset of the error bars due to the symbol size; 6402 s2x = gPad->PixeltoX(Int_t(0.5*sbasex)) - gPad->PixeltoX(0);; 6403 s2y =-gPad->PixeltoY(Int_t(0.5*sbasey)) + gPad->PixeltoY(0);; 6404 ; 6405 // compute size of the lines at the end of the error bars; 6406 Int_t dxend = Int_t(gStyle->GetEndErrorSize());; 6407 bxsize = gPad->PixeltoX(dxend) - gPad->PixeltoX(0);; 6408 bysize =-gPad->PixeltoY(dxend) + gPad->PixeltoY(0);; 6409 ; 6410 ; 6411 if (fixbin) {; 6412 if (Hoption.Logx) xp = TMath::Power(10,Hparam.xmin) + 0.5*Hparam.xbinsize;; 6413 else xp = Hparam.xmin + 0.5*Hparam.xbinsize;; 6414 } else {; 6415 delta = fH->GetBinWidth(first);; 6416 xp = fH->GetBinLowEdge(first) + 0.5*delta;; 6417 }; 6418 ; 6419 // if errormarker = 0 or symbolsize = 0. no symbol is drawn; 6420 if (Hoption.Logx) logxmin = TMath::Power(10,Hparam.xmin);; 6421 if (Hoption.Logy) logymin = TMath::Power(10,Hparam.ymin);; 6422 ; 6423 // ---------------------- Loop over the points---------------------; 6424 for (k=first; k<=last; k++) {; 6425 ; 6426 // get the data; 6427 // xp = X position of the current point; 6428 // yp = Y position of the current point; 6429 // ex1 = Low X error; 6430 // ex2 = Up X error; 6431 // ey1 = Low Y error; 6432 // ey2 = Up Y error; 6433 // (xi,yi) = Error bars coordinates; 6434 ; 6435 // apply offset on errors for bar histograms; 6436 Double_t xminTmp = gPad->XtoPad(fXaxis->GetBinLowEdge(k));; 6437 Double_t xmaxTmp = gPad->XtoPad(fXaxis->GetBinUpEdge(k));; 6438 if (Hoption.Logx) {; 6439 xminTmp = TMath::Power(10, xminTmp);; 6440 xmaxTmp = TMath::Power(10, xmaxTmp);; 6441 }; 6442 Double_t w = (xmaxTmp-xminTmp)*width;; 6443 xminTmp += offset*(xmaxTmp-xminTmp);; 6444 xmaxTmp = xminTmp + w;; 6445 xp",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:236449,Availability,error,error,236449,"05 // compute size of the lines at the end of the error bars; 6406 Int_t dxend = Int_t(gStyle->GetEndErrorSize());; 6407 bxsize = gPad->PixeltoX(dxend) - gPad->PixeltoX(0);; 6408 bysize =-gPad->PixeltoY(dxend) + gPad->PixeltoY(0);; 6409 ; 6410 ; 6411 if (fixbin) {; 6412 if (Hoption.Logx) xp = TMath::Power(10,Hparam.xmin) + 0.5*Hparam.xbinsize;; 6413 else xp = Hparam.xmin + 0.5*Hparam.xbinsize;; 6414 } else {; 6415 delta = fH->GetBinWidth(first);; 6416 xp = fH->GetBinLowEdge(first) + 0.5*delta;; 6417 }; 6418 ; 6419 // if errormarker = 0 or symbolsize = 0. no symbol is drawn; 6420 if (Hoption.Logx) logxmin = TMath::Power(10,Hparam.xmin);; 6421 if (Hoption.Logy) logymin = TMath::Power(10,Hparam.ymin);; 6422 ; 6423 // ---------------------- Loop over the points---------------------; 6424 for (k=first; k<=last; k++) {; 6425 ; 6426 // get the data; 6427 // xp = X position of the current point; 6428 // yp = Y position of the current point; 6429 // ex1 = Low X error; 6430 // ex2 = Up X error; 6431 // ey1 = Low Y error; 6432 // ey2 = Up Y error; 6433 // (xi,yi) = Error bars coordinates; 6434 ; 6435 // apply offset on errors for bar histograms; 6436 Double_t xminTmp = gPad->XtoPad(fXaxis->GetBinLowEdge(k));; 6437 Double_t xmaxTmp = gPad->XtoPad(fXaxis->GetBinUpEdge(k));; 6438 if (Hoption.Logx) {; 6439 xminTmp = TMath::Power(10, xminTmp);; 6440 xmaxTmp = TMath::Power(10, xmaxTmp);; 6441 }; 6442 Double_t w = (xmaxTmp-xminTmp)*width;; 6443 xminTmp += offset*(xmaxTmp-xminTmp);; 6444 xmaxTmp = xminTmp + w;; 6445 xp = (xminTmp+xmaxTmp)/2.;; 6446 ; 6447 if (Hoption.Logx) {; 6448 if (xp <= 0) goto L30;; 6449 if (xp < logxmin) goto L30;; 6450 if (xp > TMath::Power(10,xmax)) break;; 6451 } else {; 6452 if (xp < xmin) goto L30;; 6453 if (xp > xmax) break;; 6454 }; 6455 yp = factor*fH->GetBinContent(k);; 6456 if (optionI0 && yp==0) goto L30;; 6457 if (fixbin) {; 6458 ex1 = xerror*Hparam.xbinsize;; 6459 } else {; 6460 delta = fH->GetBinWidth(k);; 6461 ex1 = xerror*delta;; 6462 }; 6463 if ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:236475,Availability,error,error,236475,"05 // compute size of the lines at the end of the error bars; 6406 Int_t dxend = Int_t(gStyle->GetEndErrorSize());; 6407 bxsize = gPad->PixeltoX(dxend) - gPad->PixeltoX(0);; 6408 bysize =-gPad->PixeltoY(dxend) + gPad->PixeltoY(0);; 6409 ; 6410 ; 6411 if (fixbin) {; 6412 if (Hoption.Logx) xp = TMath::Power(10,Hparam.xmin) + 0.5*Hparam.xbinsize;; 6413 else xp = Hparam.xmin + 0.5*Hparam.xbinsize;; 6414 } else {; 6415 delta = fH->GetBinWidth(first);; 6416 xp = fH->GetBinLowEdge(first) + 0.5*delta;; 6417 }; 6418 ; 6419 // if errormarker = 0 or symbolsize = 0. no symbol is drawn; 6420 if (Hoption.Logx) logxmin = TMath::Power(10,Hparam.xmin);; 6421 if (Hoption.Logy) logymin = TMath::Power(10,Hparam.ymin);; 6422 ; 6423 // ---------------------- Loop over the points---------------------; 6424 for (k=first; k<=last; k++) {; 6425 ; 6426 // get the data; 6427 // xp = X position of the current point; 6428 // yp = Y position of the current point; 6429 // ex1 = Low X error; 6430 // ex2 = Up X error; 6431 // ey1 = Low Y error; 6432 // ey2 = Up Y error; 6433 // (xi,yi) = Error bars coordinates; 6434 ; 6435 // apply offset on errors for bar histograms; 6436 Double_t xminTmp = gPad->XtoPad(fXaxis->GetBinLowEdge(k));; 6437 Double_t xmaxTmp = gPad->XtoPad(fXaxis->GetBinUpEdge(k));; 6438 if (Hoption.Logx) {; 6439 xminTmp = TMath::Power(10, xminTmp);; 6440 xmaxTmp = TMath::Power(10, xmaxTmp);; 6441 }; 6442 Double_t w = (xmaxTmp-xminTmp)*width;; 6443 xminTmp += offset*(xmaxTmp-xminTmp);; 6444 xmaxTmp = xminTmp + w;; 6445 xp = (xminTmp+xmaxTmp)/2.;; 6446 ; 6447 if (Hoption.Logx) {; 6448 if (xp <= 0) goto L30;; 6449 if (xp < logxmin) goto L30;; 6450 if (xp > TMath::Power(10,xmax)) break;; 6451 } else {; 6452 if (xp < xmin) goto L30;; 6453 if (xp > xmax) break;; 6454 }; 6455 yp = factor*fH->GetBinContent(k);; 6456 if (optionI0 && yp==0) goto L30;; 6457 if (fixbin) {; 6458 ex1 = xerror*Hparam.xbinsize;; 6459 } else {; 6460 delta = fH->GetBinWidth(k);; 6461 ex1 = xerror*delta;; 6462 }; 6463 if ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:236502,Availability,error,error,236502,"05 // compute size of the lines at the end of the error bars; 6406 Int_t dxend = Int_t(gStyle->GetEndErrorSize());; 6407 bxsize = gPad->PixeltoX(dxend) - gPad->PixeltoX(0);; 6408 bysize =-gPad->PixeltoY(dxend) + gPad->PixeltoY(0);; 6409 ; 6410 ; 6411 if (fixbin) {; 6412 if (Hoption.Logx) xp = TMath::Power(10,Hparam.xmin) + 0.5*Hparam.xbinsize;; 6413 else xp = Hparam.xmin + 0.5*Hparam.xbinsize;; 6414 } else {; 6415 delta = fH->GetBinWidth(first);; 6416 xp = fH->GetBinLowEdge(first) + 0.5*delta;; 6417 }; 6418 ; 6419 // if errormarker = 0 or symbolsize = 0. no symbol is drawn; 6420 if (Hoption.Logx) logxmin = TMath::Power(10,Hparam.xmin);; 6421 if (Hoption.Logy) logymin = TMath::Power(10,Hparam.ymin);; 6422 ; 6423 // ---------------------- Loop over the points---------------------; 6424 for (k=first; k<=last; k++) {; 6425 ; 6426 // get the data; 6427 // xp = X position of the current point; 6428 // yp = Y position of the current point; 6429 // ex1 = Low X error; 6430 // ex2 = Up X error; 6431 // ey1 = Low Y error; 6432 // ey2 = Up Y error; 6433 // (xi,yi) = Error bars coordinates; 6434 ; 6435 // apply offset on errors for bar histograms; 6436 Double_t xminTmp = gPad->XtoPad(fXaxis->GetBinLowEdge(k));; 6437 Double_t xmaxTmp = gPad->XtoPad(fXaxis->GetBinUpEdge(k));; 6438 if (Hoption.Logx) {; 6439 xminTmp = TMath::Power(10, xminTmp);; 6440 xmaxTmp = TMath::Power(10, xmaxTmp);; 6441 }; 6442 Double_t w = (xmaxTmp-xminTmp)*width;; 6443 xminTmp += offset*(xmaxTmp-xminTmp);; 6444 xmaxTmp = xminTmp + w;; 6445 xp = (xminTmp+xmaxTmp)/2.;; 6446 ; 6447 if (Hoption.Logx) {; 6448 if (xp <= 0) goto L30;; 6449 if (xp < logxmin) goto L30;; 6450 if (xp > TMath::Power(10,xmax)) break;; 6451 } else {; 6452 if (xp < xmin) goto L30;; 6453 if (xp > xmax) break;; 6454 }; 6455 yp = factor*fH->GetBinContent(k);; 6456 if (optionI0 && yp==0) goto L30;; 6457 if (fixbin) {; 6458 ex1 = xerror*Hparam.xbinsize;; 6459 } else {; 6460 delta = fH->GetBinWidth(k);; 6461 ex1 = xerror*delta;; 6462 }; 6463 if ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:236528,Availability,error,error,236528,"05 // compute size of the lines at the end of the error bars; 6406 Int_t dxend = Int_t(gStyle->GetEndErrorSize());; 6407 bxsize = gPad->PixeltoX(dxend) - gPad->PixeltoX(0);; 6408 bysize =-gPad->PixeltoY(dxend) + gPad->PixeltoY(0);; 6409 ; 6410 ; 6411 if (fixbin) {; 6412 if (Hoption.Logx) xp = TMath::Power(10,Hparam.xmin) + 0.5*Hparam.xbinsize;; 6413 else xp = Hparam.xmin + 0.5*Hparam.xbinsize;; 6414 } else {; 6415 delta = fH->GetBinWidth(first);; 6416 xp = fH->GetBinLowEdge(first) + 0.5*delta;; 6417 }; 6418 ; 6419 // if errormarker = 0 or symbolsize = 0. no symbol is drawn; 6420 if (Hoption.Logx) logxmin = TMath::Power(10,Hparam.xmin);; 6421 if (Hoption.Logy) logymin = TMath::Power(10,Hparam.ymin);; 6422 ; 6423 // ---------------------- Loop over the points---------------------; 6424 for (k=first; k<=last; k++) {; 6425 ; 6426 // get the data; 6427 // xp = X position of the current point; 6428 // yp = Y position of the current point; 6429 // ex1 = Low X error; 6430 // ex2 = Up X error; 6431 // ey1 = Low Y error; 6432 // ey2 = Up Y error; 6433 // (xi,yi) = Error bars coordinates; 6434 ; 6435 // apply offset on errors for bar histograms; 6436 Double_t xminTmp = gPad->XtoPad(fXaxis->GetBinLowEdge(k));; 6437 Double_t xmaxTmp = gPad->XtoPad(fXaxis->GetBinUpEdge(k));; 6438 if (Hoption.Logx) {; 6439 xminTmp = TMath::Power(10, xminTmp);; 6440 xmaxTmp = TMath::Power(10, xmaxTmp);; 6441 }; 6442 Double_t w = (xmaxTmp-xminTmp)*width;; 6443 xminTmp += offset*(xmaxTmp-xminTmp);; 6444 xmaxTmp = xminTmp + w;; 6445 xp = (xminTmp+xmaxTmp)/2.;; 6446 ; 6447 if (Hoption.Logx) {; 6448 if (xp <= 0) goto L30;; 6449 if (xp < logxmin) goto L30;; 6450 if (xp > TMath::Power(10,xmax)) break;; 6451 } else {; 6452 if (xp < xmin) goto L30;; 6453 if (xp > xmax) break;; 6454 }; 6455 yp = factor*fH->GetBinContent(k);; 6456 if (optionI0 && yp==0) goto L30;; 6457 if (fixbin) {; 6458 ex1 = xerror*Hparam.xbinsize;; 6459 } else {; 6460 delta = fH->GetBinWidth(k);; 6461 ex1 = xerror*delta;; 6462 }; 6463 if ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:236608,Availability,error,errors,236608,"05 // compute size of the lines at the end of the error bars; 6406 Int_t dxend = Int_t(gStyle->GetEndErrorSize());; 6407 bxsize = gPad->PixeltoX(dxend) - gPad->PixeltoX(0);; 6408 bysize =-gPad->PixeltoY(dxend) + gPad->PixeltoY(0);; 6409 ; 6410 ; 6411 if (fixbin) {; 6412 if (Hoption.Logx) xp = TMath::Power(10,Hparam.xmin) + 0.5*Hparam.xbinsize;; 6413 else xp = Hparam.xmin + 0.5*Hparam.xbinsize;; 6414 } else {; 6415 delta = fH->GetBinWidth(first);; 6416 xp = fH->GetBinLowEdge(first) + 0.5*delta;; 6417 }; 6418 ; 6419 // if errormarker = 0 or symbolsize = 0. no symbol is drawn; 6420 if (Hoption.Logx) logxmin = TMath::Power(10,Hparam.xmin);; 6421 if (Hoption.Logy) logymin = TMath::Power(10,Hparam.ymin);; 6422 ; 6423 // ---------------------- Loop over the points---------------------; 6424 for (k=first; k<=last; k++) {; 6425 ; 6426 // get the data; 6427 // xp = X position of the current point; 6428 // yp = Y position of the current point; 6429 // ex1 = Low X error; 6430 // ex2 = Up X error; 6431 // ey1 = Low Y error; 6432 // ey2 = Up Y error; 6433 // (xi,yi) = Error bars coordinates; 6434 ; 6435 // apply offset on errors for bar histograms; 6436 Double_t xminTmp = gPad->XtoPad(fXaxis->GetBinLowEdge(k));; 6437 Double_t xmaxTmp = gPad->XtoPad(fXaxis->GetBinUpEdge(k));; 6438 if (Hoption.Logx) {; 6439 xminTmp = TMath::Power(10, xminTmp);; 6440 xmaxTmp = TMath::Power(10, xmaxTmp);; 6441 }; 6442 Double_t w = (xmaxTmp-xminTmp)*width;; 6443 xminTmp += offset*(xmaxTmp-xminTmp);; 6444 xmaxTmp = xminTmp + w;; 6445 xp = (xminTmp+xmaxTmp)/2.;; 6446 ; 6447 if (Hoption.Logx) {; 6448 if (xp <= 0) goto L30;; 6449 if (xp < logxmin) goto L30;; 6450 if (xp > TMath::Power(10,xmax)) break;; 6451 } else {; 6452 if (xp < xmin) goto L30;; 6453 if (xp > xmax) break;; 6454 }; 6455 yp = factor*fH->GetBinContent(k);; 6456 if (optionI0 && yp==0) goto L30;; 6457 if (fixbin) {; 6458 ex1 = xerror*Hparam.xbinsize;; 6459 } else {; 6460 delta = fH->GetBinWidth(k);; 6461 ex1 = xerror*delta;; 6462 }; 6463 if ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:238413,Availability,error,error,238413,"Width(k);; 6461 ex1 = xerror*delta;; 6462 }; 6463 if (fH->GetBinErrorOption() == TH1::kNormal) {; 6464 ey1 = factor*fH->GetBinError(k);; 6465 ey2 = ey1;; 6466 } else {; 6467 ey1 = factor*fH->GetBinErrorLow(k);; 6468 ey2 = factor*fH->GetBinErrorUp(k);; 6469 }; 6470 ex2 = ex1;; 6471 ; 6472 xi4 = xp;; 6473 xi3 = xp;; 6474 xi2 = xp + ex2;; 6475 xi1 = xp - ex1;; 6476 ; 6477 yi1 = yp;; 6478 yi2 = yp;; 6479 yi3 = yp - ey1;; 6480 yi4 = yp + ey2;; 6481 ; 6482 // take the LOG if necessary; 6483 if (Hoption.Logx) {; 6484 xi1 = TMath::Log10(TMath::Max(xi1,logxmin));; 6485 xi2 = TMath::Log10(TMath::Max(xi2,logxmin));; 6486 xi3 = TMath::Log10(TMath::Max(xi3,logxmin));; 6487 xi4 = TMath::Log10(TMath::Max(xi4,logxmin));; 6488 }; 6489 if (Hoption.Logy) {; 6490 yi1 = TMath::Log10(TMath::Max(yi1,logymin));; 6491 yi2 = TMath::Log10(TMath::Max(yi2,logymin));; 6492 yi3 = TMath::Log10(TMath::Max(yi3,logymin));; 6493 yi4 = TMath::Log10(TMath::Max(yi4,logymin));; 6494 }; 6495 ; 6496 // test if error bars are not outside the limits; 6497 // otherwise they are truncated; 6498 ; 6499 xi1 = TMath::Max(xi1,xmin);; 6500 xi2 = TMath::Min(xi2,xmax);; 6501 yi3 = TMath::Max(yi3,ymin);; 6502 yi4 = TMath::Min(yi4,ymax);; 6503 ; 6504 // test if the marker is on the frame limits. If ""Yes"", the; 6505 // marker will not be drawn and the error bars will be readjusted.; 6506 ; 6507 drawmarker = kTRUE;; 6508 if (!option0 && !option3) {; 6509 if (Hoption.Logy && yp < logymin) goto L30;; 6510 if (yi1 < ymin || yi1 > ymax) goto L30;; 6511 if (Hoption.Error != 0 && yp == 0 && ey1 <= 0) drawmarker = kFALSE;; 6512 }; 6513 if (!symbolsize || !errormarker) drawmarker = kFALSE;; 6514 ; 6515 // draw the error rectangles; 6516 if (option2) {; 6517 if (yi3 >= ymax) goto L30;; 6518 if (yi4 <= ymin) goto L30;; 6519 gPad->PaintBox(xi1,yi3,xi2,yi4);; 6520 }; 6521 ; 6522 // keep points for fill area drawing; 6523 if (option3) {; 6524 xline[if1-1] = xi3;; 6525 xline[if2-1] = xi3;; 6526 yline[if1-1] = yi4;; 6527 yline[if2-1] = y",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:238747,Availability,error,error,238747," xi3 = xp;; 6474 xi2 = xp + ex2;; 6475 xi1 = xp - ex1;; 6476 ; 6477 yi1 = yp;; 6478 yi2 = yp;; 6479 yi3 = yp - ey1;; 6480 yi4 = yp + ey2;; 6481 ; 6482 // take the LOG if necessary; 6483 if (Hoption.Logx) {; 6484 xi1 = TMath::Log10(TMath::Max(xi1,logxmin));; 6485 xi2 = TMath::Log10(TMath::Max(xi2,logxmin));; 6486 xi3 = TMath::Log10(TMath::Max(xi3,logxmin));; 6487 xi4 = TMath::Log10(TMath::Max(xi4,logxmin));; 6488 }; 6489 if (Hoption.Logy) {; 6490 yi1 = TMath::Log10(TMath::Max(yi1,logymin));; 6491 yi2 = TMath::Log10(TMath::Max(yi2,logymin));; 6492 yi3 = TMath::Log10(TMath::Max(yi3,logymin));; 6493 yi4 = TMath::Log10(TMath::Max(yi4,logymin));; 6494 }; 6495 ; 6496 // test if error bars are not outside the limits; 6497 // otherwise they are truncated; 6498 ; 6499 xi1 = TMath::Max(xi1,xmin);; 6500 xi2 = TMath::Min(xi2,xmax);; 6501 yi3 = TMath::Max(yi3,ymin);; 6502 yi4 = TMath::Min(yi4,ymax);; 6503 ; 6504 // test if the marker is on the frame limits. If ""Yes"", the; 6505 // marker will not be drawn and the error bars will be readjusted.; 6506 ; 6507 drawmarker = kTRUE;; 6508 if (!option0 && !option3) {; 6509 if (Hoption.Logy && yp < logymin) goto L30;; 6510 if (yi1 < ymin || yi1 > ymax) goto L30;; 6511 if (Hoption.Error != 0 && yp == 0 && ey1 <= 0) drawmarker = kFALSE;; 6512 }; 6513 if (!symbolsize || !errormarker) drawmarker = kFALSE;; 6514 ; 6515 // draw the error rectangles; 6516 if (option2) {; 6517 if (yi3 >= ymax) goto L30;; 6518 if (yi4 <= ymin) goto L30;; 6519 gPad->PaintBox(xi1,yi3,xi2,yi4);; 6520 }; 6521 ; 6522 // keep points for fill area drawing; 6523 if (option3) {; 6524 xline[if1-1] = xi3;; 6525 xline[if2-1] = xi3;; 6526 yline[if1-1] = yi4;; 6527 yline[if2-1] = yi3;; 6528 if1++;; 6529 if2--;; 6530 }; 6531 ; 6532 // draw the error bars; 6533 if (Hoption.Logy && yp < logymin) drawmarker = kFALSE;; 6534 if (optionE && drawmarker) {; 6535 if ((yi3 < yi1 - s2y) && (yi3 < ymax)) gPad->PaintLine(xi3,yi3,xi4,TMath::Min(yi1 - s2y,ymax));; 6536 if ((yi1 + s2y < yi4) && (",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:239049,Availability,error,errormarker,239049,"TMath::Log10(TMath::Max(yi2,logymin));; 6492 yi3 = TMath::Log10(TMath::Max(yi3,logymin));; 6493 yi4 = TMath::Log10(TMath::Max(yi4,logymin));; 6494 }; 6495 ; 6496 // test if error bars are not outside the limits; 6497 // otherwise they are truncated; 6498 ; 6499 xi1 = TMath::Max(xi1,xmin);; 6500 xi2 = TMath::Min(xi2,xmax);; 6501 yi3 = TMath::Max(yi3,ymin);; 6502 yi4 = TMath::Min(yi4,ymax);; 6503 ; 6504 // test if the marker is on the frame limits. If ""Yes"", the; 6505 // marker will not be drawn and the error bars will be readjusted.; 6506 ; 6507 drawmarker = kTRUE;; 6508 if (!option0 && !option3) {; 6509 if (Hoption.Logy && yp < logymin) goto L30;; 6510 if (yi1 < ymin || yi1 > ymax) goto L30;; 6511 if (Hoption.Error != 0 && yp == 0 && ey1 <= 0) drawmarker = kFALSE;; 6512 }; 6513 if (!symbolsize || !errormarker) drawmarker = kFALSE;; 6514 ; 6515 // draw the error rectangles; 6516 if (option2) {; 6517 if (yi3 >= ymax) goto L30;; 6518 if (yi4 <= ymin) goto L30;; 6519 gPad->PaintBox(xi1,yi3,xi2,yi4);; 6520 }; 6521 ; 6522 // keep points for fill area drawing; 6523 if (option3) {; 6524 xline[if1-1] = xi3;; 6525 xline[if2-1] = xi3;; 6526 yline[if1-1] = yi4;; 6527 yline[if2-1] = yi3;; 6528 if1++;; 6529 if2--;; 6530 }; 6531 ; 6532 // draw the error bars; 6533 if (Hoption.Logy && yp < logymin) drawmarker = kFALSE;; 6534 if (optionE && drawmarker) {; 6535 if ((yi3 < yi1 - s2y) && (yi3 < ymax)) gPad->PaintLine(xi3,yi3,xi4,TMath::Min(yi1 - s2y,ymax));; 6536 if ((yi1 + s2y < yi4) && (yi4 > ymin)) gPad->PaintLine(xi3,TMath::Max(yi1 + s2y, ymin),xi4,yi4);; 6537 // don't duplicate the horizontal line; 6538 if (Hoption.Hist != 2) {; 6539 if (yi1<ymax && yi1>ymin) {; 6540 if (xi1 < xi3 - s2x) gPad->PaintLine(xi1,yi1,xi3 - s2x,yi2);; 6541 if (xi3 + s2x < xi2) gPad->PaintLine(xi3 + s2x,yi1,xi2,yi2);; 6542 }; 6543 }; 6544 }; 6545 if (optionE && !drawmarker && (ey1 != 0 || ey2 !=0)) {; 6546 if ((yi3 < yi1) && (yi3 < ymax)) gPad->PaintLine(xi3,yi3,xi4,TMath::Min(yi1,ymax));; 6547 if ((yi1 < ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:239108,Availability,error,error,239108,"TMath::Log10(TMath::Max(yi2,logymin));; 6492 yi3 = TMath::Log10(TMath::Max(yi3,logymin));; 6493 yi4 = TMath::Log10(TMath::Max(yi4,logymin));; 6494 }; 6495 ; 6496 // test if error bars are not outside the limits; 6497 // otherwise they are truncated; 6498 ; 6499 xi1 = TMath::Max(xi1,xmin);; 6500 xi2 = TMath::Min(xi2,xmax);; 6501 yi3 = TMath::Max(yi3,ymin);; 6502 yi4 = TMath::Min(yi4,ymax);; 6503 ; 6504 // test if the marker is on the frame limits. If ""Yes"", the; 6505 // marker will not be drawn and the error bars will be readjusted.; 6506 ; 6507 drawmarker = kTRUE;; 6508 if (!option0 && !option3) {; 6509 if (Hoption.Logy && yp < logymin) goto L30;; 6510 if (yi1 < ymin || yi1 > ymax) goto L30;; 6511 if (Hoption.Error != 0 && yp == 0 && ey1 <= 0) drawmarker = kFALSE;; 6512 }; 6513 if (!symbolsize || !errormarker) drawmarker = kFALSE;; 6514 ; 6515 // draw the error rectangles; 6516 if (option2) {; 6517 if (yi3 >= ymax) goto L30;; 6518 if (yi4 <= ymin) goto L30;; 6519 gPad->PaintBox(xi1,yi3,xi2,yi4);; 6520 }; 6521 ; 6522 // keep points for fill area drawing; 6523 if (option3) {; 6524 xline[if1-1] = xi3;; 6525 xline[if2-1] = xi3;; 6526 yline[if1-1] = yi4;; 6527 yline[if2-1] = yi3;; 6528 if1++;; 6529 if2--;; 6530 }; 6531 ; 6532 // draw the error bars; 6533 if (Hoption.Logy && yp < logymin) drawmarker = kFALSE;; 6534 if (optionE && drawmarker) {; 6535 if ((yi3 < yi1 - s2y) && (yi3 < ymax)) gPad->PaintLine(xi3,yi3,xi4,TMath::Min(yi1 - s2y,ymax));; 6536 if ((yi1 + s2y < yi4) && (yi4 > ymin)) gPad->PaintLine(xi3,TMath::Max(yi1 + s2y, ymin),xi4,yi4);; 6537 // don't duplicate the horizontal line; 6538 if (Hoption.Hist != 2) {; 6539 if (yi1<ymax && yi1>ymin) {; 6540 if (xi1 < xi3 - s2x) gPad->PaintLine(xi1,yi1,xi3 - s2x,yi2);; 6541 if (xi3 + s2x < xi2) gPad->PaintLine(xi3 + s2x,yi1,xi2,yi2);; 6542 }; 6543 }; 6544 }; 6545 if (optionE && !drawmarker && (ey1 != 0 || ey2 !=0)) {; 6546 if ((yi3 < yi1) && (yi3 < ymax)) gPad->PaintLine(xi3,yi3,xi4,TMath::Min(yi1,ymax));; 6547 if ((yi1 < ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:239493,Availability,error,error,239493,"TMath::Log10(TMath::Max(yi2,logymin));; 6492 yi3 = TMath::Log10(TMath::Max(yi3,logymin));; 6493 yi4 = TMath::Log10(TMath::Max(yi4,logymin));; 6494 }; 6495 ; 6496 // test if error bars are not outside the limits; 6497 // otherwise they are truncated; 6498 ; 6499 xi1 = TMath::Max(xi1,xmin);; 6500 xi2 = TMath::Min(xi2,xmax);; 6501 yi3 = TMath::Max(yi3,ymin);; 6502 yi4 = TMath::Min(yi4,ymax);; 6503 ; 6504 // test if the marker is on the frame limits. If ""Yes"", the; 6505 // marker will not be drawn and the error bars will be readjusted.; 6506 ; 6507 drawmarker = kTRUE;; 6508 if (!option0 && !option3) {; 6509 if (Hoption.Logy && yp < logymin) goto L30;; 6510 if (yi1 < ymin || yi1 > ymax) goto L30;; 6511 if (Hoption.Error != 0 && yp == 0 && ey1 <= 0) drawmarker = kFALSE;; 6512 }; 6513 if (!symbolsize || !errormarker) drawmarker = kFALSE;; 6514 ; 6515 // draw the error rectangles; 6516 if (option2) {; 6517 if (yi3 >= ymax) goto L30;; 6518 if (yi4 <= ymin) goto L30;; 6519 gPad->PaintBox(xi1,yi3,xi2,yi4);; 6520 }; 6521 ; 6522 // keep points for fill area drawing; 6523 if (option3) {; 6524 xline[if1-1] = xi3;; 6525 xline[if2-1] = xi3;; 6526 yline[if1-1] = yi4;; 6527 yline[if2-1] = yi3;; 6528 if1++;; 6529 if2--;; 6530 }; 6531 ; 6532 // draw the error bars; 6533 if (Hoption.Logy && yp < logymin) drawmarker = kFALSE;; 6534 if (optionE && drawmarker) {; 6535 if ((yi3 < yi1 - s2y) && (yi3 < ymax)) gPad->PaintLine(xi3,yi3,xi4,TMath::Min(yi1 - s2y,ymax));; 6536 if ((yi1 + s2y < yi4) && (yi4 > ymin)) gPad->PaintLine(xi3,TMath::Max(yi1 + s2y, ymin),xi4,yi4);; 6537 // don't duplicate the horizontal line; 6538 if (Hoption.Hist != 2) {; 6539 if (yi1<ymax && yi1>ymin) {; 6540 if (xi1 < xi3 - s2x) gPad->PaintLine(xi1,yi1,xi3 - s2x,yi2);; 6541 if (xi3 + s2x < xi2) gPad->PaintLine(xi3 + s2x,yi1,xi2,yi2);; 6542 }; 6543 }; 6544 }; 6545 if (optionE && !drawmarker && (ey1 != 0 || ey2 !=0)) {; 6546 if ((yi3 < yi1) && (yi3 < ymax)) gPad->PaintLine(xi3,yi3,xi4,TMath::Min(yi1,ymax));; 6547 if ((yi1 < ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:240602,Availability,error,error,240602,"/ don't duplicate the horizontal line; 6538 if (Hoption.Hist != 2) {; 6539 if (yi1<ymax && yi1>ymin) {; 6540 if (xi1 < xi3 - s2x) gPad->PaintLine(xi1,yi1,xi3 - s2x,yi2);; 6541 if (xi3 + s2x < xi2) gPad->PaintLine(xi3 + s2x,yi1,xi2,yi2);; 6542 }; 6543 }; 6544 }; 6545 if (optionE && !drawmarker && (ey1 != 0 || ey2 !=0)) {; 6546 if ((yi3 < yi1) && (yi3 < ymax)) gPad->PaintLine(xi3,yi3,xi4,TMath::Min(yi1,ymax));; 6547 if ((yi1 < yi4) && (yi4 > ymin)) gPad->PaintLine(xi3,TMath::Max(yi1,ymin),xi4,yi4);; 6548 // don't duplicate the horizontal line; 6549 if (Hoption.Hist != 2) {; 6550 if (yi1<ymax && yi1>ymin) {; 6551 if (xi1 < xi3) gPad->PaintLine(xi1,yi1,xi3,yi2);; 6552 if (xi3 < xi2) gPad->PaintLine(xi3,yi1,xi2,yi2);; 6553 }; 6554 }; 6555 }; 6556 ; 6557 // draw line at the end of the error bars; 6558 ; 6559 if (option1 && drawmarker) {; 6560 ; 6561 if (yi3 < yi1-s2y && yi3 < ymax && yi3 > ymin) gPad->PaintLine(xi3 - bxsize, yi3 , xi3 + bxsize, yi3);; 6562 if (yi4 > yi1+s2y && yi4 < ymax && yi4 > ymin) gPad->PaintLine(xi3 - bxsize, yi4 , xi3 + bxsize, yi4);; 6563 if (yi1 <= ymax && yi1 >= ymin) {; 6564 if (xi1 < xi3-s2x) gPad->PaintLine(xi1 , yi1 - bysize, xi1 , yi1 + bysize);; 6565 if (xi2 > xi3+s2x) gPad->PaintLine(xi2 , yi1 - bysize, xi2 , yi1 + bysize);; 6566 }; 6567 }; 6568 ; 6569 // draw the marker; 6570 ; 6571 if (drawmarker) gPad->PaintPolyMarker(1, &xi3, &yi1);; 6572 ; 6573L30:; 6574 if (fixbin) xp += Hparam.xbinsize;; 6575 else {; 6576 if (k < last) {; 6577 delta = fH->GetBinWidth(k+1);; 6578 xp = fH->GetBinLowEdge(k+1) + 0.5*delta;; 6579 }; 6580 }; 6581 } //end of for loop; 6582 ; 6583 // draw the filled area; 6584 ; 6585 if (option3) {; 6586 TGraph graph;; 6587 graph.SetLineStyle(fH->GetLineStyle());; 6588 graph.SetLineColor(fH->GetLineColor());; 6589 graph.SetLineWidth(fH->GetLineWidth());; 6590 graph.SetFillStyle(fH->GetFillStyle());; 6591 graph.SetFillColor(fH->GetFillColor());; 6592 Int_t logx = gPad->GetLogx();; 6593 Int_t logy = gPad->GetLogy();; 6594 gP",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:242582,Availability,error,errors,242582,"586 TGraph graph;; 6587 graph.SetLineStyle(fH->GetLineStyle());; 6588 graph.SetLineColor(fH->GetLineColor());; 6589 graph.SetLineWidth(fH->GetLineWidth());; 6590 graph.SetFillStyle(fH->GetFillStyle());; 6591 graph.SetFillColor(fH->GetFillColor());; 6592 Int_t logx = gPad->GetLogx();; 6593 Int_t logy = gPad->GetLogy();; 6594 gPad->SetLogx(0);; 6595 gPad->SetLogy(0);; 6596 ; 6597 // In some cases the number of points in the fill area is smaller than; 6598 // 2*npoints. In such cases the array xline and yline must be arranged; 6599 // before being plotted. The next loop does that.; 6600 if (if2 > npoints) {; 6601 for (i=1; i<if1; i++) {; 6602 xline[if1-2+i] = xline[if2-1+i];; 6603 yline[if1-2+i] = yline[if2-1+i];; 6604 }; 6605 npoints = if1-1;; 6606 }; 6607 if (option4) graph.PaintGraph(2*npoints,xline.data(),yline.data(),""FC"");; 6608 else graph.PaintGraph(2*npoints,xline.data(),yline.data(),""F"");; 6609 gPad->SetLogx(logx);; 6610 gPad->SetLogy(logy);; 6611 }; 6612}; 6613 ; 6614////////////////////////////////////////////////////////////////////////////////; 6615/// Draw 2D histograms errors.; 6616 ; 6617void THistPainter::Paint2DErrors(Option_t *); 6618{; 6619 ; 6620 fH->TAttMarker::Modify();; 6621 fH->TAttLine::Modify();; 6622 ; 6623 // Define the 3D view; 6624 fXbuf[0] = Hparam.xmin;; 6625 fYbuf[0] = Hparam.xmax;; 6626 fXbuf[1] = Hparam.ymin;; 6627 fYbuf[1] = Hparam.ymax;; 6628 fXbuf[2] = Hparam.zmin;; 6629 fYbuf[2] = Hparam.zmax*(1. + gStyle->GetHistTopMargin());; 6630 fLego = std::make_unique<TPainter3dAlgorithms>(fXbuf.data(), fYbuf.data());; 6631 TView *view = gPad ? gPad->GetView() : nullptr;; 6632 if (!view) {; 6633 Error(""Paint2DErrors"", ""no TView in current pad"");; 6634 return;; 6635 }; 6636 Double_t thedeg = 90 - gPad->GetTheta();; 6637 Double_t phideg = -90 - gPad->GetPhi();; 6638 Double_t psideg = view->GetPsi();; 6639 Int_t irep;; 6640 view->SetView(phideg, thedeg, psideg, irep);; 6641 ; 6642 // Set color/style for back box; 6643 fLego->SetFillStyle(gPad-",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:384729,Availability,error,error,384729," height if HMAXIM; 10678 // has not been called.; 10679 // MAX% is the value in percent which has been set in HPLSET; 10680 // (default is 90%).; 10681 if (!maximum) {; 10682 zmax += yMARGIN*(zmax-zmin);; 10683 }; 10684 ; 10685 // final adjustment of ymin for linear scale.; 10686 // if minimum is not set , then ymin is set to zero if >0; 10687 // or to ymin - yMARGIN if <0.; 10688 if (!minimum) {; 10689 if (Hoption.MinimumZero) {; 10690 if (zmin >= 0) zmin = 0;; 10691 else zmin -= yMARGIN*(zmax-zmin);; 10692 } else {; 10693 Double_t dzmin = yMARGIN*(zmax-zmin);; 10694 if (zmin >= 0 && (zmin-dzmin <= 0)) zmin = 0;; 10695 else zmin -= dzmin;; 10696 }; 10697 }; 10698 ; 10699LZMIN:; 10700 Hparam.zmin = zmin;; 10701 Hparam.zmax = zmax;; 10702 ; 10703 // Set bar offset and width; 10704 Hparam.baroffset = fH->GetBarOffset();; 10705 Hparam.barwidth = fH->GetBarWidth();; 10706 ; 10707 return 1;; 10708}; 10709 ; 10710////////////////////////////////////////////////////////////////////////////////; 10711/// This function returns the best format to print the error value (e); 10712/// knowing the parameter value (v) and the format (f) used to print it.; 10713 ; 10714const char * THistPainter::GetBestFormat(Double_t v, Double_t e, const char *f); 10715{; 10716 ; 10717 static TString ef;; 10718 TString tf, tv;; 10719 ; 10720 // print v with the format f in tv.; 10721 tf.Form(""%s%s"",""%"",f);; 10722 tv.Form(tf.Data(),v);; 10723 ; 10724 // Analyse tv.; 10725 int ie = tv.Index(""e"");; 10726 int iE = tv.Index(""E"");; 10727 int id = tv.Index(""."");; 10728 ; 10729 // v has been printed with the exponent notation.; 10730 // There is 2 cases, the exponent is positive or negative; 10731 if (ie >= 0 || iE >= 0) {; 10732 if (tv.Index(""+"") >= 0) {; 10733 if (e < 1) {; 10734 ef.Form(""%s.1f"",""%"");; 10735 } else {; 10736 if (ie >= 0) {; 10737 ef.Form(""%s.%de"",""%"",ie-id-1);; 10738 } else {; 10739 ef.Form(""%s.%dE"",""%"",iE-id-1);; 10740 }; 10741 }; 10742 } else {; 10743 if (ie >= 0) {; 10744 ef.Form(""%s.%",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:456085,Availability,error,error,456085,"istogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::SetTitlevoid SetTitle(const char *title) overrideChange/set the title.Definition TH1.cxx:6718; TH1::GetBinErrorOptionvirtual EBinErrorOpt GetBinErrorOption() constDefinition TH1.h:273; TH1::GetBarWidthvirtual Float_t GetBarWidth() constDefinition TH1.h:257; TH1::GetMinimumStoredvirtual Double_t GetMinimumStored() constDefinition TH1.h:293; TH1::GetBarOffsetvirtual Float_t GetBarOffset() constDefinition TH1.h:256; TH1::Classstatic TClass * Class(); TH1::GetStdDevvirtual Double_t GetStdDev(Int_t axis=1) constReturns the Standard Deviation (Sigma).Definition TH1.cxx:7607; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associated to bin number bin.Definition TH1.cxx:9063; TH1::GetNbinsZvirtual Int_t GetNbinsZ() constDefinition TH1.h:299; TH1::GetNormFactorvirtual Double_t GetNormFactor() constDefinition TH1.h:301; TH1::GetMeanvirtual Double_t GetMean(Int_t axis=1) constFor axis = 1,2 or 3 returns the mean value of the histogram along X,Y or Z axis.Definition TH1.cxx:7535; TH1::GetSkewnessvirtual Double_t GetSkewness(Int_t axis=1) constDefinition TH1.cxx:7671; TH1::GetContourLevelPadvirtual Double_t GetContourLevelPad(Int_t level) constReturn the value of contour number ""level"" in Pad coordinates.Definition TH1.cxx:8440; TH1::SetXTitlevirtual void SetXTitle(const char *title)Definition TH1.h:419; TH1::GetDimensionvirtual Int_t GetDimension() constDefinition TH1.h:283; TH1::AddDirectorystatic void AddDirectory(Bool_t add=kTRUE)Sets the flag controlling the automatic add of histograms in memory.Definition TH1.cxx:1294; TH1::kNoTitle@ kNoTitleDon't draw the histogram title.D",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:457923,Availability,error,error,457923,"ool_t add=kTRUE)Sets the flag controlling the automatic add of histograms in memory.Definition TH1.cxx:1294; TH1::kNoTitle@ kNoTitleDon't draw the histogram title.Definition TH1.h:170; TH1::kUserContour@ kUserContourUser specified contour levels.Definition TH1.h:166; TH1::kNoStats@ kNoStatsDon't draw stats box.Definition TH1.h:165; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetBinvirtual Int_t GetBin(Int_t binx, Int_t biny=0, Int_t binz=0) constReturn Global bin number corresponding to binx,y,z.Definition TH1.cxx:4961; TH1::GetMaximumvirtual Double_t GetMaximum(Double_t maxval=FLT_MAX) constReturn maximum value smaller than maxval of bins in the range, unless the value has been overridden b...Definition TH1.cxx:8545; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Definition TH1.h:404; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::GetBinErrorLowvirtual Double_t GetBinErrorLow(Int_t bin) constReturn lower error associated to bin number bin.Definition TH1.cxx:9079; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TH1::Integralvirtual Double_t Integral(Option_t *option="""") constReturn integral of bin contents.Definition TH1.cxx:7941; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Double_t content)Set bin content see convention for numbering bins in TH1::GetBin In case the bin number is greater th...Definition TH1.cxx:9222; TH1::GetBinLowEdgevirtual Double_t GetBinLowEdge(Int_t bin) constReturn bin lower edge for 1D histogram.Definition TH1.cxx:9152; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::SetZTitlevirtual void SetZTitle(const char *title)Definition TH1.h:421; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:458976,Availability,error,error,458976,"n.Definition TH1.cxx:9079; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TH1::Integralvirtual Double_t Integral(Option_t *option="""") constReturn integral of bin contents.Definition TH1.cxx:7941; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Double_t content)Set bin content see convention for numbering bins in TH1::GetBin In case the bin number is greater th...Definition TH1.cxx:9222; TH1::GetBinLowEdgevirtual Double_t GetBinLowEdge(Int_t bin) constReturn bin lower edge for 1D histogram.Definition TH1.cxx:9152; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::SetZTitlevirtual void SetZTitle(const char *title)Definition TH1.h:421; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1::GetMeanErrorvirtual Double_t GetMeanError(Int_t axis=1) constReturn standard error of mean of this histogram along the X axis.Definition TH1.cxx:7575; TH1::GetMaximumStoredvirtual Double_t GetMaximumStored() constDefinition TH1.h:289; TH1::GetMinimumAndMaximumvirtual void GetMinimumAndMaximum(Double_t &min, Double_t &max) constRetrieve the minimum and maximum values in the histogram.Definition TH1.cxx:8731; TH1::GetMaximumBinvirtual Int_t GetMaximumBin() constReturn location of bin with maximum value in the range.Definition TH1.cxx:8577; TH1::kNormal@ kNormalErrors with Normal (Wald) approximation: errorUp=errorLow= sqrt(N)Definition TH1.h:65; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetContourvirtual Int_t GetContour(Double_t *levels=nullptr)Return contour values into array levels if pointer levels is non zero.Definition TH1.cxx:8411; TH1::GetBufferconst Double_t * GetBuffer() constDefinition TH1.h:239; TH1::IsHighlightvirtual Bool_t IsHighlight() constDe",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:459505,Availability,error,errorUp,459505,"x:9222; TH1::GetBinLowEdgevirtual Double_t GetBinLowEdge(Int_t bin) constReturn bin lower edge for 1D histogram.Definition TH1.cxx:9152; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::SetZTitlevirtual void SetZTitle(const char *title)Definition TH1.h:421; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1::GetMeanErrorvirtual Double_t GetMeanError(Int_t axis=1) constReturn standard error of mean of this histogram along the X axis.Definition TH1.cxx:7575; TH1::GetMaximumStoredvirtual Double_t GetMaximumStored() constDefinition TH1.h:289; TH1::GetMinimumAndMaximumvirtual void GetMinimumAndMaximum(Double_t &min, Double_t &max) constRetrieve the minimum and maximum values in the histogram.Definition TH1.cxx:8731; TH1::GetMaximumBinvirtual Int_t GetMaximumBin() constReturn location of bin with maximum value in the range.Definition TH1.cxx:8577; TH1::kNormal@ kNormalErrors with Normal (Wald) approximation: errorUp=errorLow= sqrt(N)Definition TH1.h:65; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetContourvirtual Int_t GetContour(Double_t *levels=nullptr)Return contour values into array levels if pointer levels is non zero.Definition TH1.cxx:8411; TH1::GetBufferconst Double_t * GetBuffer() constDefinition TH1.h:239; TH1::IsHighlightvirtual Bool_t IsHighlight() constDefinition TH1.h:338; TH1::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width for 1D histogram.Definition TH1.cxx:9163; TH1::SetContourvirtual void SetContour(Int_t nlevels, const Double_t *levels=nullptr)Set the number and values of contour levels.Definition TH1.cxx:8483; TH1::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t bin) constReturn upper error associated to bin number bin.Definition TH1.cxx:9110; TH1::SetYTitlevirtual void SetYTitle(const char *title)Definition TH1.h:420; TH1::GetSumw2Nvirtual In",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:459513,Availability,error,errorLow,459513,"x:9222; TH1::GetBinLowEdgevirtual Double_t GetBinLowEdge(Int_t bin) constReturn bin lower edge for 1D histogram.Definition TH1.cxx:9152; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::SetZTitlevirtual void SetZTitle(const char *title)Definition TH1.h:421; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1::GetMeanErrorvirtual Double_t GetMeanError(Int_t axis=1) constReturn standard error of mean of this histogram along the X axis.Definition TH1.cxx:7575; TH1::GetMaximumStoredvirtual Double_t GetMaximumStored() constDefinition TH1.h:289; TH1::GetMinimumAndMaximumvirtual void GetMinimumAndMaximum(Double_t &min, Double_t &max) constRetrieve the minimum and maximum values in the histogram.Definition TH1.cxx:8731; TH1::GetMaximumBinvirtual Int_t GetMaximumBin() constReturn location of bin with maximum value in the range.Definition TH1.cxx:8577; TH1::kNormal@ kNormalErrors with Normal (Wald) approximation: errorUp=errorLow= sqrt(N)Definition TH1.h:65; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetContourvirtual Int_t GetContour(Double_t *levels=nullptr)Return contour values into array levels if pointer levels is non zero.Definition TH1.cxx:8411; TH1::GetBufferconst Double_t * GetBuffer() constDefinition TH1.h:239; TH1::IsHighlightvirtual Bool_t IsHighlight() constDefinition TH1.h:338; TH1::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width for 1D histogram.Definition TH1.cxx:9163; TH1::SetContourvirtual void SetContour(Int_t nlevels, const Double_t *levels=nullptr)Set the number and values of contour levels.Definition TH1.cxx:8483; TH1::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t bin) constReturn upper error associated to bin number bin.Definition TH1.cxx:9110; TH1::SetYTitlevirtual void SetYTitle(const char *title)Definition TH1.h:420; TH1::GetSumw2Nvirtual In",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:460328,Availability,error,error,460328,"xx:8731; TH1::GetMaximumBinvirtual Int_t GetMaximumBin() constReturn location of bin with maximum value in the range.Definition TH1.cxx:8577; TH1::kNormal@ kNormalErrors with Normal (Wald) approximation: errorUp=errorLow= sqrt(N)Definition TH1.h:65; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetContourvirtual Int_t GetContour(Double_t *levels=nullptr)Return contour values into array levels if pointer levels is non zero.Definition TH1.cxx:8411; TH1::GetBufferconst Double_t * GetBuffer() constDefinition TH1.h:239; TH1::IsHighlightvirtual Bool_t IsHighlight() constDefinition TH1.h:338; TH1::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width for 1D histogram.Definition TH1.cxx:9163; TH1::SetContourvirtual void SetContour(Int_t nlevels, const Double_t *levels=nullptr)Set the number and values of contour levels.Definition TH1.cxx:8483; TH1::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t bin) constReturn upper error associated to bin number bin.Definition TH1.cxx:9110; TH1::SetYTitlevirtual void SetYTitle(const char *title)Definition TH1.h:420; TH1::GetSumw2Nvirtual Int_t GetSumw2N() constDefinition TH1.h:315; TH1::GetStdDevErrorvirtual Double_t GetStdDevError(Int_t axis=1) constReturn error of standard deviation estimation for Normal distribution.Definition TH1.cxx:7655; TH1::GetMinimumvirtual Double_t GetMinimum(Double_t minval=-FLT_MAX) constReturn minimum value larger than minval of bins in the range, unless the value has been overridden by...Definition TH1.cxx:8635; TH1::GetSumOfWeightsvirtual Double_t GetSumOfWeights() constReturn the sum of weights excluding under/overflows.Definition TH1.cxx:7917; TH1::AddDirectoryStatusstatic Bool_t AddDirectoryStatus()Static function: cannot be inlined on Windows/NT.Definition TH1.cxx:754; TH1::LabelsDeflatevirtual void LabelsDeflate(Option_t *axis=""X"")Reduce the number of bins for the axis passed in the option to the numb",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:460609,Availability,error,error,460609,"t(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetContourvirtual Int_t GetContour(Double_t *levels=nullptr)Return contour values into array levels if pointer levels is non zero.Definition TH1.cxx:8411; TH1::GetBufferconst Double_t * GetBuffer() constDefinition TH1.h:239; TH1::IsHighlightvirtual Bool_t IsHighlight() constDefinition TH1.h:338; TH1::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width for 1D histogram.Definition TH1.cxx:9163; TH1::SetContourvirtual void SetContour(Int_t nlevels, const Double_t *levels=nullptr)Set the number and values of contour levels.Definition TH1.cxx:8483; TH1::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t bin) constReturn upper error associated to bin number bin.Definition TH1.cxx:9110; TH1::SetYTitlevirtual void SetYTitle(const char *title)Definition TH1.h:420; TH1::GetSumw2Nvirtual Int_t GetSumw2N() constDefinition TH1.h:315; TH1::GetStdDevErrorvirtual Double_t GetStdDevError(Int_t axis=1) constReturn error of standard deviation estimation for Normal distribution.Definition TH1.cxx:7655; TH1::GetMinimumvirtual Double_t GetMinimum(Double_t minval=-FLT_MAX) constReturn minimum value larger than minval of bins in the range, unless the value has been overridden by...Definition TH1.cxx:8635; TH1::GetSumOfWeightsvirtual Double_t GetSumOfWeights() constReturn the sum of weights excluding under/overflows.Definition TH1.cxx:7917; TH1::AddDirectoryStatusstatic Bool_t AddDirectoryStatus()Static function: cannot be inlined on Windows/NT.Definition TH1.cxx:754; TH1::LabelsDeflatevirtual void LabelsDeflate(Option_t *axis=""X"")Reduce the number of bins for the axis passed in the option to the number of bins having a label.Definition TH1.cxx:5245; TH1::BufferEmptyvirtual Int_t BufferEmpty(Int_t action=0)Fill histogram with all entries in the buffer.Definition TH1.cxx:1414; TH1::GetKurtosisvirtual Double_t GetKurtosis(Int_t axis=1) constDefinition TH1.cxx:7744; TH2D2-D histogram with a doub",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:463301,Availability,error,error,463301,"; THistPainterThe histogram painter class.Definition THistPainter.h:50; THistPainter::ProjectSinusoidal2xystatic Int_t ProjectSinusoidal2xy(Double_t l, Double_t b, Double_t &Al, Double_t &Ab)Static function code for sinusoidal projection from Ernst-Jan Buis Source https://en....Definition THistPainter.cxx:10380; THistPainter::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histogramsDefinition THistPainter.cxx:4470; THistPainter::fYaxisTAxis * fYaxisPointer to Y axis.Definition THistPainter.h:55; THistPainter::fLegostd::unique_ptr< TPainter3dAlgorithms > fLegoPointer to a TPainter3dAlgorithms object.Definition THistPainter.h:58; THistPainter::fXbufstd::vector< Double_t > fXbufX buffer coordinates.Definition THistPainter.h:61; THistPainter::fXHighlightBinInt_t fXHighlightBinX highlight bin.Definition THistPainter.h:70; THistPainter::fCurrentF3TF3 * fCurrentF3Current TF3 function.Definition THistPainter.h:72; THistPainter::PaintErrorsvirtual void PaintErrors(Option_t *option)Draw 1D histograms error bars.Definition THistPainter.cxx:6314; THistPainter::~THistPainter~THistPainter() overridedestructor.Definition THistPainter.cxx:3242; THistPainter::fShowProjection2Int_t fShowProjection2True if a second projection must be drawn (when calling SetShowProjectionXY on a TH2)Definition THistPainter.h:68; THistPainter::PaintTF3virtual void PaintTF3()Control function to draw a 3D implicit functions.Definition THistPainter.cxx:10152; THistPainter::TableInitvirtual Int_t TableInit()Initialize various options to draw 2D histograms.Definition THistPainter.cxx:10536; THistPainter::PaintTH2PolyScatterPlotvirtual void PaintTH2PolyScatterPlot(Option_t *option)Control function to draw a TH2Poly as a scatter plot.Definition THistPainter.cxx:9885; THistPainter::ProjectMollweide2xystatic Int_t ProjectMollweide2xy(Double_t l, Double_t b, Double_t &Al, Double_t &Ab)Static function.Definition THistPainter.cxx:10412; THistPainter::ProjectAitoff2xystatic Int_t Pr",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:465261,Availability,error,errors,465261,"; THistPainter::ProjectAitoff2xystatic Int_t ProjectAitoff2xy(Double_t l, Double_t b, Double_t &Al, Double_t &Ab)Static function.Definition THistPainter.cxx:10331; THistPainter::PaintTextvirtual void PaintText(Option_t *option)Control function to draw a 1D/2D histograms with the bin values.Definition THistPainter.cxx:10056; THistPainter::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute the distance from the point px,py to a line.Definition THistPainter.cxx:3255; THistPainter::PaintAxisvirtual void PaintAxis(Bool_t drawGridOnly=kFALSE)Draw axis (2D case) of an histogram.Definition THistPainter.cxx:4766; THistPainter::PaintColorLevelsFastvirtual void PaintColorLevelsFast(Option_t *option)[Rendering scheme for the COL2 and COLZ2 options] (HP14)Definition THistPainter.cxx:5577; THistPainter::PaintInitvirtual Int_t PaintInit()Compute histogram parameters used by the drawing routines.Definition THistPainter.cxx:7082; THistPainter::Paint2DErrorsvirtual void Paint2DErrors(Option_t *option)Draw 2D histograms errors.Definition THistPainter.cxx:6617; THistPainter::fYHighlightBinInt_t fYHighlightBinY highlight bin.Definition THistPainter.h:71; THistPainter::PaintCandlePlotvirtual void PaintCandlePlot(Option_t *option)Control function to draw a 2D histogram as a candle (box) plot or violin plotDefinition THistPainter.cxx:5353; THistPainter::PaintScatterPlotvirtual void PaintScatterPlot(Option_t *option)Control function to draw a 2D histogram as a scatter plot.Definition THistPainter.cxx:8459; THistPainter::SetShowProjectionXYvoid SetShowProjectionXY(const char *option, Int_t nbinsY, Int_t nbinsX) overrideDefinition THistPainter.cxx:10804; THistPainter::PaintLegovirtual void PaintLego(Option_t *option)Control function to draw a 2D histogram as a lego plot.Definition THistPainter.cxx:8017; THistPainter::PaintH3virtual void PaintH3(Option_t *option="""")Control function to draw a 3D histograms.Definition THistPainter.cxx:6974; THistPainter::fNcutsInt_t ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:473337,Availability,error,error,473337,"hoptin and fill Hoption structure.Definition THistPainter.cxx:4028; THistPainter::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideDisplay the histogram info (bin number, contents, integral up to bin corresponding to cursor position...Definition THistPainter.cxx:3729; THistPainter::GetContourListTList * GetContourList(Double_t contour) const overrideGet a contour (as a list of TGraphs) using the Delaunay triangulation.Definition THistPainter.cxx:3706; THistPainter::ProcessMessagevoid ProcessMessage(const char *mess, const TObject *obj) overrideProcess message mess.Definition THistPainter.cxx:10311; THistPainter::SetShowProjectionvoid SetShowProjection(const char *option, Int_t nbins) overrideSet projection.Definition THistPainter.cxx:10766; THistPainter::ShowProjectionYvirtual void ShowProjectionY(Int_t px, Int_t py)Show projection onto Y.Definition THistPainter.cxx:10933; THistPainter::GetBestFormatstatic const char * GetBestFormat(Double_t v, Double_t e, const char *f)This function returns the best format to print the error value (e) knowing the parameter value (v) an...Definition THistPainter.cxx:10714; THistPainter::PaintContourvirtual void PaintContour(Option_t *option)Control function to draw a 2D histogram as a contour plot.Definition THistPainter.cxx:5932; THistPainter::fCutsTCutG * fCuts[kMaxCuts]Pointers to graphical cuts.Definition THistPainter.h:65; THistPainter::PaintTablevirtual void PaintTable(Option_t *option)Control function to draw 2D/3D histograms (tables).Definition THistPainter.cxx:9629; THistPainter::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute the actions corresponding to event.Definition THistPainter.cxx:3464; THistPainter::PaintInitHvirtual Int_t PaintInitH()Compute histogram parameters used by the drawing routines for a rotated pad.Definition THistPainter.cxx:7334; THistPainter::PaintFramevirtual void PaintFrame()Calculate range and clear pad (canvas).Definition THistPainter.cxx:6777; THi",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:479961,Availability,error,error,479961,"ct.h:119; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Paintvirtual void Paint(Option_t *option="""")This method must be overridden if a class wants to paint itself.Definition TObject.cxx:612; TObject::kCannotPick@ kCannotPickif object in a pad cannot be pickedDefinition TObject.h:67; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPainter3dAlgorithms::DrawFaceMove3void DrawFaceMove3(Int_t *icodes, Double_t *xyz, Int_t np, Int_t *iface, Double_t *tt)Draw face - 3rd variant for ""MOVING SCREEN"" algorithm (draw level lines only)Definition TPainter3dAlgorithms.cxx:705; TPainter3dAlgorithms::DrawLevelLinesvoid DrawLevelLines(Int_t *icodes, Double_t *xyz, Int_t np, Int_t *iface, Do",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:486486,Availability,error,error,486486,"t attributes.Definition TPaveText.cxx:242; TPaveText::Paintvoid Paint(Option_t *option="""") overridePaint this pavetext with its current attributes.Definition TPaveText.cxx:419; TPaveText::GetLinevirtual TText * GetLine(Int_t number) constGet Pointer to line number in this pavetext.Definition TPaveText.cxx:284; TPave::GetNameconst char * GetName() const overrideReturns name of object.Definition TPave.h:56; TPave::SetNamevirtual void SetName(const char *name="""")Definition TPave.h:79; TPave::SetBorderSizevirtual void SetBorderSize(Int_t bordersize=4)Sets the border size of the TPave box and shadow.Definition TPave.h:77; TPave::GetX1NDCDouble_t GetX1NDC() constDefinition TPave.h:59; TPave::SetX2NDCvirtual void SetX2NDC(Double_t x2)Definition TPave.h:83; TPickerStackGuardDefinition TVirtualPad.h:297; TPointDefinition TPoint.h:31; TPoint::SetXvoid SetX(SCoord_t x)Definition TPoint.h:48; TPoint::SetYvoid SetY(SCoord_t y)Definition TPoint.h:49; TProfile2DProfile2D histograms are used to display the mean value of Z and its error for each cell in X,...Definition TProfile2D.h:27; TProfile2D::Classstatic TClass * Class(); TProfile2D::GetBinEntriesvirtual Double_t GetBinEntries(Int_t bin) constReturn bin entries of a Profile2D histogram.Definition TProfile2D.cxx:842; TProfileProfile Histogram.Definition TProfile.h:32; TProfile::GetBinEntriesvirtual Double_t GetBinEntries(Int_t bin) constReturn bin entries of a Profile histogram.Definition TProfile.cxx:837; TProfile::Classstatic TClass * Class(); TRandom2Random number generator class based on the maximally quidistributed combined Tausworthe generator by ...Definition TRandom2.h:27; TRandom2::RndmDouble_t Rndm() overrideTausWorth generator from L'Ecuyer, uses as seed 3x32bits integers Use a mask of 0xffffffffUL to make ...Definition TRandom2.cxx:55; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinit",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:487212,Availability,mask,mask,487212,"id SetX2NDC(Double_t x2)Definition TPave.h:83; TPickerStackGuardDefinition TVirtualPad.h:297; TPointDefinition TPoint.h:31; TPoint::SetXvoid SetX(SCoord_t x)Definition TPoint.h:48; TPoint::SetYvoid SetY(SCoord_t y)Definition TPoint.h:49; TProfile2DProfile2D histograms are used to display the mean value of Z and its error for each cell in X,...Definition TProfile2D.h:27; TProfile2D::Classstatic TClass * Class(); TProfile2D::GetBinEntriesvirtual Double_t GetBinEntries(Int_t bin) constReturn bin entries of a Profile2D histogram.Definition TProfile2D.cxx:842; TProfileProfile Histogram.Definition TProfile.h:32; TProfile::GetBinEntriesvirtual Double_t GetBinEntries(Int_t bin) constReturn bin entries of a Profile histogram.Definition TProfile.cxx:837; TProfile::Classstatic TClass * Class(); TRandom2Random number generator class based on the maximally quidistributed combined Tausworthe generator by ...Definition TRandom2.h:27; TRandom2::RndmDouble_t Rndm() overrideTausWorth generator from L'Ecuyer, uses as seed 3x32bits integers Use a mask of 0xffffffffUL to make ...Definition TRandom2.cxx:55; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:6835,Deployability,update,updated,6835,"D. To choose how the histogram will; 154be drawn, the `Draw()` method can be invoked with an option. For instance; 155to draw a 2D histogram as a lego plot it is enough to do:; 156 ; 157 h->Draw(""lego"");; 158 ; 159`THistPainter` offers many options to paint 1D, 2D and 3D histograms.; 160 ; 161When the `Draw()` method of a histogram is called for the first time; 162(`TH1::Draw`), it creates a `THistPainter` object and saves a; 163pointer to this ""painter"" as a data member of the histogram. The; 164`THistPainter` class specializes in the drawing of histograms. It is; 165separated from the histogram so that one can have histograms without the; 166graphics overhead, for example in a batch program. Each histogram having its own; 167painter (rather than a central singleton painter painting all histograms), allows; 168two histograms to be drawn in two threads without overwriting the painter's; 169values.; 170 ; 171When a displayed histogram is filled again, there is no need to call the; 172`Draw()` method again; the image will be refreshed the next time the; 173pad will be updated.; 174 ; 175A pad is updated after one of these three actions:; 176 ; 1771. a carriage control on the ROOT command line,; 1782. a click inside the pad,; 1793. a call to `TPad::Update`.; 180 ; 181 ; 182By default a call to `TH1::Draw()` clears the pad of all objects; 183before drawing the new image of the histogram. One can use the `SAME`; 184option to leave the previous display intact and superimpose the new histogram.; 185The same histogram can be drawn with different graphics options in different; 186pads.; 187 ; 188When a displayed histogram is deleted, its image is automatically removed; 189from the pad.; 190 ; 191To create a copy of the histogram when drawing it, one can use; 192`TH1::DrawClone()`. This will clone the histogram and allow to change; 193and delete the original one without affecting the clone.; 194 ; 195 ; 196\anchor HP01; 197### Histograms' plotting options; 198 ; 199 ; 200Most ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:6863,Deployability,update,updated,6863,"2D histogram as a lego plot it is enough to do:; 156 ; 157 h->Draw(""lego"");; 158 ; 159`THistPainter` offers many options to paint 1D, 2D and 3D histograms.; 160 ; 161When the `Draw()` method of a histogram is called for the first time; 162(`TH1::Draw`), it creates a `THistPainter` object and saves a; 163pointer to this ""painter"" as a data member of the histogram. The; 164`THistPainter` class specializes in the drawing of histograms. It is; 165separated from the histogram so that one can have histograms without the; 166graphics overhead, for example in a batch program. Each histogram having its own; 167painter (rather than a central singleton painter painting all histograms), allows; 168two histograms to be drawn in two threads without overwriting the painter's; 169values.; 170 ; 171When a displayed histogram is filled again, there is no need to call the; 172`Draw()` method again; the image will be refreshed the next time the; 173pad will be updated.; 174 ; 175A pad is updated after one of these three actions:; 176 ; 1771. a carriage control on the ROOT command line,; 1782. a click inside the pad,; 1793. a call to `TPad::Update`.; 180 ; 181 ; 182By default a call to `TH1::Draw()` clears the pad of all objects; 183before drawing the new image of the histogram. One can use the `SAME`; 184option to leave the previous display intact and superimpose the new histogram.; 185The same histogram can be drawn with different graphics options in different; 186pads.; 187 ; 188When a displayed histogram is deleted, its image is automatically removed; 189from the pad.; 190 ; 191To create a copy of the histogram when drawing it, one can use; 192`TH1::DrawClone()`. This will clone the histogram and allow to change; 193and delete the original one without affecting the clone.; 194 ; 195 ; 196\anchor HP01; 197### Histograms' plotting options; 198 ; 199 ; 200Most options can be concatenated with or without spaces or commas, for example:; 201 ; 202 h->Draw(""E1 SAME"");; 203 ; 204The options",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:60777,Deployability,configurat,configuration,60777,"ing a whisker-range of 0.95 and w=1 will redefine the area of; 1419the lower whisker to the upper whisker in order to cover 95% of the distribution inside; 1420that candle. The static function will affect all candle-charts in the running program.; 1421Default is 1.; 1422 ; 1423If the distribution is large enough and gaussian shaped, the maximum length of; 1424the whisker will be located at \f$ \pm 2.698 \sigma \f$ (when using the; 14251.5*iqr-definition (w=2), where \f$ \sigma \f$ is the standard deviation; 1426(see picture above). In that case 99.3% of the total distribution will be covered; 1427by the box and the whiskers, whereas 0.7% are represented by the outliers.; 1428 ; 1429##### The Anchors; 1430The anchors have no special meaning in terms of statistical calculation. They mark; 1431the end of the whiskers and they have the width of the box. Both representation; 1432with and without anchors are common.; 1433 ; 1434##### The Points; 1435Depending on the configuration the points can have different meanings:; 1436 - If p=1 the points represent the outliers. If they are shown, it means; 1437 some parts of the underlying distribution are not covered by the whiskers.; 1438 This can only occur when the whiskers are set to option w=2. Here the whiskers; 1439 can have a maximum length of \f$ 1.5 \times iqr \f$. So any points outside the; 1440 whiskers will be drawn as outliers. The outliers will be represented by crosses.; 1441 - If p=2 all points in the distribution will be painted as crosses. This is; 1442 useful for small datasets only (up to 10 or 20 points per candle).; 1443 The outliers are shown along the candle. Because the underlying distribution; 1444 is binned, is frequently occurs that a bin contains more than one value.; 1445 Because of this the points will be randomly scattered within their bin along; 1446 the candle axis. If the bin content for a bin is exactly 1 (usually; 1447 this happens for the outliers) if will be drawn in the middle of the bin alo",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:143810,Deployability,release,released,143810,"utine; 3661 RecalculateRange();; 3662 }; 3663 if (opaque && dimension ==2) {; 3664 if (zoombox) {; 3665 Double_t x1 = TMath::Min(zoombox->GetX1(), zoombox->GetX2());; 3666 Double_t x2 = TMath::Max(zoombox->GetX1(), zoombox->GetX2());; 3667 Double_t y1 = TMath::Min(zoombox->GetY1(), zoombox->GetY2());; 3668 Double_t y2 = TMath::Max(zoombox->GetY1(), zoombox->GetY2());; 3669 x1 = TMath::Max(x1,xaxis->GetXmin());; 3670 x2 = TMath::Min(x2,xaxis->GetXmax());; 3671 y1 = TMath::Max(y1,yaxis->GetXmin());; 3672 y2 = TMath::Min(y2,yaxis->GetXmax());; 3673 if (x1<x2 && y1<y2) {; 3674 xaxis->SetRangeUser(x1, x2);; 3675 yaxis->SetRangeUser(y1, y2);; 3676 }; 3677 zoombox.reset();; 3678 }; 3679 }; 3680 gPad->Modified(kTRUE);; 3681 if (opaque) gVirtualX->SetLineColor(-1);; 3682 ; 3683 break;; 3684 ; 3685 case kButton1Locate:; 3686 ; 3687 ExecuteEvent(kButton1Down, px, py);; 3688 ; 3689 while (true) {; 3690 px = py = 0;; 3691 event = gVirtualX->RequestLocator(1, 1, px, py);; 3692 ; 3693 ExecuteEvent(kButton1Motion, px, py);; 3694 ; 3695 if (event != -1) { // button is released; 3696 ExecuteEvent(kButton1Up, px, py);; 3697 return;; 3698 }; 3699 }; 3700 }; 3701}; 3702 ; 3703////////////////////////////////////////////////////////////////////////////////; 3704/// Get a contour (as a list of TGraphs) using the Delaunay triangulation.; 3705 ; 3706TList *THistPainter::GetContourList(Double_t contour) const; 3707{; 3708 // Check if fH contains a TGraphDelaunay2D; 3709 TList *hl = fH->GetListOfFunctions();; 3710 TGraphDelaunay2D *dt = (TGraphDelaunay2D*)hl->FindObject(""TGraphDelaunay2D"");; 3711 // try with the old painter; 3712 TGraphDelaunay *dtOld = nullptr;; 3713 if (!dt) dtOld = (TGraphDelaunay*)hl->FindObject(""TGraphDelaunay"");; 3714 ; 3715 if (!dt && !dtOld) return nullptr;; 3716 ; 3717 gCurrentHist = fH;; 3718 ; 3719 if (!fGraph2DPainter); 3720 ((THistPainter*)this)->fGraph2DPainter = dt ? std::make_unique<TGraph2DPainter>(dt) : std::make_unique<TGraph2DPainter>(dtOld);; 3721 ; 3722 ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:282417,Deployability,update,update,282417,"NDC(&sxyz[k][0],&sxyz[k][0]);; 7795 }; 7796 for (Int_t k=0; k<6; ++k) { // draw box faces; 7797 Double_t zn;; 7798 view->FindNormal(normal[k][0], normal[k][1], normal[k][2], zn);; 7799 if (zn <= 0) continue;; 7800 for (Int_t i=0; i<4; ++i) {; 7801 Int_t ip = iface[k][i];; 7802 pp[i][0] = sxyz[ip][0];; 7803 pp[i][1] = sxyz[ip][1];; 7804 }; 7805 for (Int_t i=0; i<4; ++i) {; 7806 Int_t i1 = i;; 7807 Int_t i2 = (i == 3) ? 0 : i + 1;; 7808 Int_t nt;; 7809 fLego->FindVisibleLine(&pp[i1][0], &pp[i2][0], NTMAX, nt, &tt[0][0]);; 7810 Double_t xdel = pp[i2][0] - pp[i1][0];; 7811 Double_t ydel = pp[i2][1] - pp[i1][1];; 7812 Double_t x[2], y[2];; 7813 for (Int_t it = 0; it < nt; ++it) {; 7814 x[0] = pp[i1][0] + xdel*tt[it][0];; 7815 y[0] = pp[i1][1] + ydel*tt[it][0];; 7816 x[1] = pp[i1][0] + xdel*tt[it][1];; 7817 y[1] = pp[i1][1] + ydel*tt[it][1];; 7818 gPad->PaintPolyLine(2, x, y);; 7819 }; 7820 }; 7821 if (neg) {; 7822 Int_t i1 = 0;; 7823 Int_t i2 = 2;; 7824 Int_t nt;; 7825 fLego->FindVisibleLine(&pp[i1][0], &pp[i2][0], NTMAX, nt, &tt[0][0]);; 7826 Double_t xdel = pp[i2][0] - pp[i1][0];; 7827 Double_t ydel = pp[i2][1] - pp[i1][1];; 7828 Double_t x[2], y[2];; 7829 for (Int_t it = 0; it < nt; ++it) {; 7830 x[0] = pp[i1][0] + xdel*tt[it][0];; 7831 y[0] = pp[i1][1] + ydel*tt[it][0];; 7832 x[1] = pp[i1][0] + xdel*tt[it][1];; 7833 y[1] = pp[i1][1] + ydel*tt[it][1];; 7834 gPad->PaintPolyLine(2, x, y);; 7835 }; 7836 i1 = 1;; 7837 i2 = 3;; 7838 fLego->FindVisibleLine(&pp[i1][0], &pp[i2][0], NTMAX, nt, &tt[0][0]);; 7839 xdel = pp[i2][0] - pp[i1][0];; 7840 ydel = pp[i2][1] - pp[i1][1];; 7841 for (Int_t it = 0; it < nt; ++it) {; 7842 x[0] = pp[i1][0] + xdel*tt[it][0];; 7843 y[0] = pp[i1][1] + ydel*tt[it][0];; 7844 x[1] = pp[i1][0] + xdel*tt[it][1];; 7845 y[1] = pp[i1][1] + ydel*tt[it][1];; 7846 gPad->PaintPolyLine(2, x, y);; 7847 }; 7848 }; 7849 fLego->FillPolygonBorder(4, &pp[0][0]); // update raster screen; 7850 }; 7851 }; 7852 }; 7853 }; 7854 ; 7855 // Draw frame box; 7856 if (Hoption.",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:391674,Deployability,patch,patch,391674,",TVirtualX::kFilled);; 10872 gVirtualX->DrawBox(pxmin,py1,pxmax,py2,TVirtualX::kFilled);; 10873 pyold1 = py1;; 10874 pyold2 = py2;; 10875 ; 10876 // Create or set the new canvas proj x; 10877 TVirtualPad::TContext ctxt(true);; 10878 auto name1 = TString::Format(""c_%zx_projection_%d"", (size_t)fH, fShowProjection);; 10879 TVirtualPad *c = (TVirtualPad*)gROOT->GetListOfCanvases()->FindObject(name1.Data());; 10880 if (c) {; 10881 c->Clear();; 10882 } else {; 10883 fShowProjection = 0;; 10884 fShowProjection2 = 0;; 10885 pyold1 = 0;; 10886 pyold2 = 0;; 10887 return;; 10888 }; 10889 c->cd();; 10890 c->SetLogy(ctxt.GetSaved()->GetLogz());; 10891 c->SetLogx(ctxt.GetSaved()->GetLogx());; 10892 ; 10893 // Draw slice corresponding to mouse position; 10894 TString prjName = TString::Format(""slice_px_of_%s"",fH->GetName());; 10895 TH1D *hp = ((TH2*)fH)->ProjectionX(prjName, biny1, biny2);; 10896 if (hp) {; 10897 hp->SetFillColor(38);; 10898 // apply a patch from Oliver Freyermuth to set the title in the projection; 10899 // using the range of the projected Y values; 10900 if (biny1 == biny2) {; 10901 Double_t valueFrom = fH->GetYaxis()->GetBinLowEdge(biny1);; 10902 Double_t valueTo = fH->GetYaxis()->GetBinUpEdge(biny1);; 10903 // Limit precision to 1 digit more than the difference between upper and lower bound (to also catch 121.5-120.5).; 10904 Int_t valuePrecision = -TMath::Nint(TMath::Log10(valueTo-valueFrom))+1;; 10905 if (fH->GetYaxis()->GetLabels() != nullptr) {; 10906 hp->SetTitle(TString::Format(""ProjectionX of biny=%d [y=%.*lf..%.*lf] %s"", biny1, valuePrecision, valueFrom, valuePrecision, valueTo, fH->GetYaxis()->GetBinLabel(biny1)));; 10907 } else {; 10908 hp->SetTitle(TString::Format(""ProjectionX of biny=%d [y=%.*lf..%.*lf]"", biny1, valuePrecision, valueFrom, valuePrecision, valueTo));; 10909 }; 10910 } else {; 10911 Double_t valueFrom = fH->GetYaxis()->GetBinLowEdge(biny1);; 10912 Double_t valueTo = fH->GetYaxis()->GetBinUpEdge(biny2);; 10913 // Limit precision to 1 d",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:396124,Deployability,patch,patch,396124,"pxold2 = px2;; 10960 ; 10961 // Create or set the new canvas proj y; 10962 TVirtualPad::TContext ctxt(true);; 10963 ; 10964 TString name2 = fShowProjection2 ? TString::Format(""c_%zx_projection2_%d"", (size_t)fH, fShowProjection2); 10965 : TString::Format(""c_%zx_projection_%d"", (size_t)fH, fShowProjection);; 10966 ; 10967 TVirtualPad *c = (TVirtualPad*)gROOT->GetListOfCanvases()->FindObject(name2.Data());; 10968 if (c) {; 10969 c->Clear();; 10970 } else {; 10971 fShowProjection = 0;; 10972 fShowProjection2 = 0;; 10973 pxold1 = 0;; 10974 pxold2 = 0;; 10975 return;; 10976 }; 10977 c->cd();; 10978 c->SetLogy(ctxt.GetSaved()->GetLogz());; 10979 c->SetLogx(ctxt.GetSaved()->GetLogy());; 10980 ; 10981 // Draw slice corresponding to mouse position; 10982 TString prjName = TString::Format(""slice_py_of_%s"",fH->GetName());; 10983 TH1D *hp = ((TH2*)fH)->ProjectionY(prjName, binx1, binx2);; 10984 if (hp) {; 10985 hp->SetFillColor(38);; 10986 // apply a patch from Oliver Freyermuth to set the title in the projection; 10987 // using the range of the projected X values; 10988 if (binx1 == binx2) {; 10989 Double_t valueFrom = fH->GetXaxis()->GetBinLowEdge(binx1);; 10990 Double_t valueTo = fH->GetXaxis()->GetBinUpEdge(binx1);; 10991 // Limit precision to 1 digit more than the difference between upper and lower bound (to also catch 121.5-120.5).; 10992 Int_t valuePrecision = -TMath::Nint(TMath::Log10(valueTo-valueFrom))+1;; 10993 if (fH->GetXaxis()->GetLabels() != nullptr) {; 10994 hp->SetTitle(TString::Format(""ProjectionY of binx=%d [x=%.*lf..%.*lf] [%s]"", binx1, valuePrecision, valueFrom, valuePrecision, valueTo, fH->GetXaxis()->GetBinLabel(binx1)));; 10995 } else {; 10996 hp->SetTitle(TString::Format(""ProjectionY of binx=%d [x=%.*lf..%.*lf]"", binx1, valuePrecision, valueFrom, valuePrecision, valueTo));; 10997 }; 10998 } else {; 10999 Double_t valueFrom = fH->GetXaxis()->GetBinLowEdge(binx1);; 11000 Double_t valueTo = fH->GetXaxis()->GetBinUpEdge(binx2);; 11001 // Limit precision to 1",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:53079,Energy Efficiency,reduce,reduces,53079,"href=""http://en.wikipedia.org/wiki/Box_plot"">A Candle plot</a> (also known as; 1282a ""box plot"" or ""whisker plot"") was invented in 1977 by John Tukey. It is a convenient; 1283way to describe graphically a data distribution (D) with only five numbers:; 1284 ; 1285 1. The minimum value of the distribution D (bottom or left whisker).; 1286 2. The lower quartile (Q1): 25% of the data points in D are less than Q1 (bottom of the box).; 1287 3. The median (M): 50% of the data points in D are less than M.; 1288 4. The upper quartile (Q3): 75% of the data points in D are less than Q3 (top of the box).; 1289 5. The maximum value of the distribution D (top or right whisker).; 1290 ; 1291In this implementation a TH2 is considered as a collection of TH1 along; 1292X (option `CANDLE` or `CANDLEX`) or Y (option `CANDLEY`).; 1293Each TH1 is represented as one candle.; 1294 ; 1295Begin_Macro(source); 1296../../../tutorials/hist/candleplotwhiskers.C; 1297End_Macro; 1298 ; 1299The candle reduces the information coming from a whole distribution into few values.; 1300Independently from the number of entries or the significance of the underlying distribution; 1301a candle will always look like a candle. So candle plots should be used carefully in; 1302particular with unknown distributions. The definition of a candle is based on; 1303__unbinned data__. Here, candles are created from binned data. Because of this, the; 1304deviation is connected to the bin width used. The calculation of the quantiles; 1305normally done on unbinned data also. Because data are binned, this will; 1306only work the best possible way within the resolution of one bin; 1307 ; 1308Because of all these facts one should take care that:; 1309 ; 1310 - there are enough points per candle; 1311 - the bin width is small enough (more bins will increase the maximum; 1312 available resolution of the quantiles although there will be some; 1313 bins with no entries); 1314 - never make a candle-plot if the underlying distributio",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:103300,Energy Efficiency,green,green,103300,"and colors=0, a Deep Sea palette is used.; 2523 if ncolors = 52 and colors=0, a Grey Scale palette is used.; 2524 if ncolors = 53 and colors=0, a Dark Body Radiator palette is used.; 2525 if ncolors = 54 and colors=0, a two-color hue palette palette is used.(dark blue through neutral gray to bright yellow); 2526 if ncolors = 55 and colors=0, a Rain Bow palette is used.; 2527 if ncolors = 56 and colors=0, an inverted Dark Body Radiator palette is used.; 2528 ; 2529 ; 2530If `ncolors > 0 && colors == 0`, the default palette is used with a maximum of ncolors.; 2531 ; 2532The default palette defines:; 2533 ; 2534- index 0 to 9 : shades of grey; 2535- index 10 to 19 : shades of brown; 2536- index 20 to 29 : shades of blue; 2537- index 30 to 39 : shades of red; 2538- index 40 to 49 : basic colors; 2539 ; 2540The color numbers specified in the palette can be viewed by selecting; 2541the item `colors` in the `VIEW` menu of the canvas tool bar.; 2542The red, green, and blue components of a color can be changed thanks to; 2543`TColor::SetRGB()`.; 2544 ; 2545\since **ROOT version 6.19/01**; 2546 ; 2547As default labels and ticks are drawn by `TGAxis` at equidistant (lin or log); 2548points as controlled by SetNdivisions.; 2549If option ""CJUST"" is given labels and ticks are justified at the; 2550color boundaries defined by the contour levels.; 2551For more details see `TPaletteAxis`; 2552 ; 2553\anchor HP24; 2554### Drawing a sub-range of a 2D histogram; the [cutg] option; 2555 ; 2556 ; 2557Using a `TCutG` object, it is possible to draw a sub-range of a 2D; 2558histogram. One must create a graphical cut (mouse or C++) and specify the name; 2559of the cut between `[]` in the `Draw()` option.; 2560For example (fit2a.C), with a `TCutG` named `cutg`, one can call:; 2561 ; 2562 myhist->Draw(""surf1 [cutg]"");; 2563 ; 2564To invert the cut, it is enough to put a `-` in front of its name:; 2565 ; 2566 myhist->Draw(""surf1 [-cutg]"");; 2567 ; 2568It is possible to apply several cuts (`,` m",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:118014,Energy Efficiency,green,green,118014,"is:; 2952 ; 2953| Option | Description |; 2954|----------|-------------------------------------------------------------------|; 2955| ""GL"" | Draw a TF3.|; 2956 ; 2957 ; 2958 ; 2959\anchor HP29e; 2960#### Parametric surfaces; 2961 ; 2962`$ROOTSYS/tutorials/gl/glparametric.C` shows how to create parametric; 2963equations and visualize the surface.; 2964 ; 2965\anchor HP29f; 2966#### Interaction with the plots; 2967 ; 2968All the interactions are implemented via standard methods; 2969`DistancetoPrimitive()` and `ExecuteEvent()`. That's why all the; 2970interactions with the OpenGL plots are possible only when the mouse cursor is; 2971in the plot's area (the plot's area is the part of a the pad occupied by; 2972gl-produced picture). If the mouse cursor is not above gl-picture, the standard; 2973pad interaction is performed.; 2974 ; 2975\anchor HP29g; 2976#### Selectable parts; 2977 ; 2978Different parts of the plot can be selected:; 2979 ; 2980- xoz, yoz, xoy back planes: When such a plane selected, it's highlighted in green; 2981 if the dynamic slicing by this plane is supported, and it's highlighted in red,; 2982 if the dynamic slicing is not supported.; 2983- The plot itself:; 2984 On surfaces, the selected surface is outlined in red. (TF3 and; 2985 ISO are not outlined). On lego plots, the selected bin is; 2986 highlighted. The bin number and content are displayed in pad's; 2987 status bar. In box plots, the box or sphere is highlighted and; 2988 the bin info is displayed in pad's status bar.; 2989 ; 2990 ; 2991\anchor HP29h; 2992#### Rotation and zooming; 2993 ; 2994 ; 2995- Rotation:; 2996 When the plot is selected, it can be rotated by pressing and; 2997 holding the left mouse button and move the cursor.; 2998- Zoom/Unzoom:; 2999 Mouse wheel or 'j', 'J', 'k', 'K' keys.; 3000 ; 3001 ; 3002\anchor HP29i; 3003#### Panning; 3004 ; 3005The selected plot can be moved in a pad's area by pressing and; 3006holding the left mouse button and the shift key.; 3007 ; 3008\anch",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:119718,Energy Efficiency,green,green,119718,"el or 'j', 'J', 'k', 'K' keys.; 3000 ; 3001 ; 3002\anchor HP29i; 3003#### Panning; 3004 ; 3005The selected plot can be moved in a pad's area by pressing and; 3006holding the left mouse button and the shift key.; 3007 ; 3008\anchor HP29j; 3009#### Box cut; 3010 ; 3011Surface, iso, box, TF3 and parametric painters support box cut by; 3012pressing the 'c' or 'C' key when the mouse cursor is in a plot's; 3013area. That will display a transparent box, cutting away part of the; 3014surface (or boxes) in order to show internal part of plot. This box; 3015can be moved inside the plot's area (the full size of the box is; 3016equal to the plot's surrounding box) by selecting one of the box; 3017cut axes and pressing the left mouse button to move it.; 3018 ; 3019\anchor HP29k; 3020#### Plot specific interactions (dynamic slicing etc.); 3021 ; 3022Currently, all gl-plots support some form of slicing. When back plane; 3023is selected (and if it's highlighted in green) you can press and hold; 3024left mouse button and shift key and move this back plane inside; 3025plot's area, creating the slice. During this ""slicing"" plot becomes; 3026semi-transparent. To remove all slices (and projected curves for; 3027surfaces) double click with left mouse button in a plot's area.; 3028 ; 3029\anchor HP29l; 3030#### Surface with option ""GLSURF""; 3031 ; 3032The surface profile is displayed on the slicing plane.; 3033The profile projection is drawn on the back plane; 3034by pressing `'p'` or `'P'` key.; 3035 ; 3036\anchor HP29m; 3037#### TF3; 3038 ; 3039The contour plot is drawn on the slicing plane. For TF3 the color; 3040scheme can be changed by pressing 's' or 'S'.; 3041 ; 3042\anchor HP29n; 3043#### Box; 3044 ; 3045The contour plot corresponding to slice plane position is drawn in real time.; 3046 ; 3047\anchor HP29o; 3048#### Iso; 3049 ; 3050Slicing is similar to ""GLBOX"" option.; 3051 ; 3052\anchor HP29p; 3053#### Parametric plot; 3054 ; 3055No slicing. Additional keys: 's' or 'S' to change",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:495390,Energy Efficiency,power,power,495390,"TF1 * f1Definition legend1.C:11; c2return c2Definition legend2.C:14; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf...Definition TMath.cxx:637; TMath::ATanDouble_t ATan(Double_t)Returns the principal value of the arc tangent of x, expressed in radians.Definition TMath.h:640; TMath::PiOver2constexpr Double_t PiOver2()Definition TMath.h:51; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::DegToRadconstexpr Double_t DegToRad()Conversion from degree to radian: .Definition TMath.h:79; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::AreEqualRelBool_t AreEqualRel(Double_t af, Double_t bf, Double_t relPrec)Comparing floating points.Definition TMath.h:426; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::TanDouble_t Tan(Double_t)Returns the tangent of an angle of x radians.Definition TMath.h:600; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347; TMath::RadToDegconstexpr Double_t RadToDeg()Conversion from radian to degree: .Definition TMath.h:72; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm o",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:47766,Integrability,depend,depends,47766,"(x,y,4);; 1154 if(x<0 && y<0) h2->Fill(x,y,3);; 1155 if(x>0 && y<0) h3->Fill(x,y,2);; 1156 if(x<0 && y>0) h4->Fill(x,y,1);; 1157 }; 1158 h1->Draw(""colz"");; 1159 h2->Draw(""col same"");; 1160 h3->Draw(""col same"");; 1161 h4->Draw(""col same"");; 1162}; 1163End_Macro; 1164 ; 1165The option `COL` can be combined with the option `POL`:; 1166 ; 1167Begin_Macro(source); 1168{; 1169 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 1170 auto hcol1 = new TH2F(""hcol1"",""Option COLor combined with POL"",40,-4,4,40,-4,4);; 1171 float px, py;; 1172 for (Int_t i = 0; i < 25000; i++) {; 1173 gRandom->Rannor(px,py);; 1174 hcol1->Fill(px,py);; 1175 }; 1176 hcol1->Draw(""COLZPOL"");; 1177}; 1178End_Macro; 1179 ; 1180\since **ROOT version 6.07/03:**; 1181 ; 1182A second rendering technique is also available with the COL2 and COLZ2 options.; 1183 ; 1184These options provide potential performance improvements compared to the standard; 1185COL option. The performance comparison of the COL2 to the COL option depends on; 1186the histogram and the size of the rendering region in the current pad. In general,; 1187a small (approx. less than 100 bins per axis), sparsely populated TH2 will render; 1188faster with the COL option.; 1189 ; 1190However, for larger histograms (approx. more than 100 bins per axis); 1191that are not sparse, the COL2 option will provide up to 20 times performance improvements.; 1192For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude; 1193faster with the COL2 option.; 1194 ; 1195The COL2 option will also scale its performance based on the size of the; 1196pixmap the histogram image is being rendered into. It also is much better optimized for; 1197sessions where the user is forwarding X11 windows through an `ssh` connection.; 1198 ; 1199For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; 1200and COLZ options. There is one major difference and that concerns the treatment of; 1201bins with zero content. The COL2 and COLZ2 ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:99768,Integrability,interface,interface,99768,"024748, 3518288, 885122, 18537969,; 2416 9829211, 1545801, 12910409, 6423113, 3007856, 2818747, 4314113, 4492076,; 2417 1318301, 5699478, 6593587, 9969727, 5266214, 2951996, 5987580, 974989,; 2418 1796619, 2643085, 1324575, 8707739, 2009671, 19541453, 9380884, 646844,; 2419 11542645, 3687050, 3825657, 12604767, 1053209, 4561242, 812383, 6296254,; 2420 24782302, 2784572, 621760, 7882590, 6664195, 1819777, 5654774, 544270; 2421 };; 2422 ; 2423 Double_t lon1 = -130;; 2424 Double_t lon2 = -65;; 2425 Double_t lat1 = 24;; 2426 Double_t lat2 = 50;; 2427 auto p = new TH2Poly(""USA"",""USA Population"",lon1,lon2,lat1,lat2);; 2428 ; 2429 TFile::SetCacheFileDir(""."");; 2430 auto f = TFile::Open(""http://root.cern/files/usa.root"", ""CACHEREAD"");; 2431 ; 2432 TMultiGraph *mg;; 2433 TKey *key;; 2434 TIter nextkey(gDirectory->GetListOfKeys());; 2435 while ((key = (TKey*)nextkey())) {; 2436 TObject *obj = key->ReadObj();; 2437 if (obj->InheritsFrom(""TMultiGraph"")) {; 2438 mg = (TMultiGraph*)obj;; 2439 bin = p->AddBin(mg);; 2440 }; 2441 }; 2442 ; 2443 for (i=0; i<nx; i++) p->Fill(states[i], pop[i]);; 2444 ; 2445 gStyle->SetOptStat(11);; 2446 p->Draw(""COLZ L"");; 2447}; 2448End_Macro; 2449 ; 2450`TH2Poly` histograms can also be plotted using the GL interface using; 2451the option ""GLLEGO"".; 2452 ; 2453\since **ROOT version 6.09/01**; 2454 ; 2455In some cases it can be useful to not draw the empty bins. the option ""0""; 2456combined with the option ""COL"" et COLZ allows to do that.; 2457 ; 2458Begin_Macro(source); 2459{; 2460 auto chc = new TCanvas(""chc"",""chc"",600,400);; 2461 ; 2462 auto hc = new TH2Poly();; 2463 hc->Honeycomb(0,0,.1,25,25);; 2464 hc->SetName(""hc"");; 2465 hc->SetTitle(""Option COLZ 0"");; 2466 TRandom ran;; 2467 for (int i = 0; i<300; i++) hc->Fill(ran.Gaus(2.,1), ran.Gaus(2.,1));; 2468 hc->Draw(""colz 0"");; 2469}; 2470End_Macro; 2471 ; 2472\anchor HP21; 2473### The SPEC option; 2474 ; 2475 ; 2476This option allows to use the `TSpectrum2Painter` tools. See the full; 2477documentat",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:142740,Integrability,rout,routine,142740,";; 3618 bin2 = xaxis->GetLast()-1;; 3619 bin1 = TMath::Max(bin1, 1);; 3620 bin2 = TMath::Min(bin2, xaxis->GetNbins());; 3621 if (bin2>bin1) xaxis->SetRange(bin1,bin2);; 3622 bin1 = yaxis->GetFirst()+1;; 3623 bin2 = yaxis->GetLast()-1;; 3624 bin1 = TMath::Max(bin1, 1);; 3625 bin2 = TMath::Min(bin2, yaxis->GetNbins());; 3626 if (bin2>bin1) yaxis->SetRange(bin1,bin2);; 3627 }; 3628 gPad->Modified();; 3629 gPad->Update();; 3630 ; 3631 break;; 3632 ; 3633 case kWheelDown:; 3634 ; 3635 if (dimension == 2) {; 3636 bin1 = xaxis->GetFirst()-1;; 3637 bin2 = xaxis->GetLast()+1;; 3638 bin1 = TMath::Max(bin1, 1);; 3639 bin2 = TMath::Min(bin2, xaxis->GetNbins());; 3640 if (bin2>bin1) xaxis->SetRange(bin1,bin2);; 3641 bin1 = yaxis->GetFirst()-1;; 3642 bin2 = yaxis->GetLast()+1;; 3643 bin1 = TMath::Max(bin1, 1);; 3644 bin2 = TMath::Min(bin2, yaxis->GetNbins());; 3645 if (bin2>bin1) yaxis->SetRange(bin1,bin2);; 3646 }; 3647 gPad->Modified();; 3648 gPad->Update();; 3649 ; 3650 break;; 3651 ; 3652 case kButton1Up:; 3653 if (dimension ==1) {; 3654 if (gROOT->GetEditHistograms()) {; 3655 binval = gPad->PadtoY(gPad->AbsPixeltoY(py2))/factor;; 3656 fH->SetBinContent(bin,binval);; 3657 PaintInit(); // recalculate Hparam structure and recalculate range; 3658 }; 3659 ; 3660 // might resize pad pixmap so should be called before any paint routine; 3661 RecalculateRange();; 3662 }; 3663 if (opaque && dimension ==2) {; 3664 if (zoombox) {; 3665 Double_t x1 = TMath::Min(zoombox->GetX1(), zoombox->GetX2());; 3666 Double_t x2 = TMath::Max(zoombox->GetX1(), zoombox->GetX2());; 3667 Double_t y1 = TMath::Min(zoombox->GetY1(), zoombox->GetY2());; 3668 Double_t y2 = TMath::Max(zoombox->GetY1(), zoombox->GetY2());; 3669 x1 = TMath::Max(x1,xaxis->GetXmin());; 3670 x2 = TMath::Min(x2,xaxis->GetXmax());; 3671 y1 = TMath::Max(y1,yaxis->GetXmin());; 3672 y2 = TMath::Min(y2,yaxis->GetXmax());; 3673 if (x1<x2 && y1<y2) {; 3674 xaxis->SetRangeUser(x1, x2);; 3675 yaxis->SetRangeUser(y1, y2);; 3676 }; 3677 zoombox.",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:170307,Integrability,rout,routine,170307," if (Hoption.Bar == 1) Hoption.Hist = -1;; 4417 return 1;; 4418}; 4419 ; 4420////////////////////////////////////////////////////////////////////////////////; 4421/// Decode string `choptin` and fill Graphical cuts structure.; 4422 ; 4423Int_t THistPainter::MakeCuts(char *choptin); 4424{; 4425 ; 4426 fNcuts = 0;; 4427 char *left = (char*)strchr(choptin,'[');; 4428 if (!left) return 0;; 4429 char *right = (char*)strchr(choptin,']');; 4430 if (!right) return 0;; 4431 Int_t nch = right-left;; 4432 if (nch < 2) return 0;; 4433 char *cuts = left+1;; 4434 *right = 0;; 4435 char *comma, *minus;; 4436 Int_t i;; 4437 while (true) {; 4438 comma = strchr(cuts,',');; 4439 if (comma) *comma = 0;; 4440 minus = strchr(cuts,'-');; 4441 if (minus) cuts = minus+1;; 4442 while (*cuts == ' ') cuts++;; 4443 Int_t nc = strlen(cuts);; 4444 while (cuts[nc-1] == ' ') {cuts[nc-1] = 0; nc--;}; 4445 TIter next(gROOT->GetListOfSpecials());; 4446 TCutG *cut=nullptr;; 4447 TObject *obj;; 4448 while ((obj = next())) {; 4449 if (!obj->InheritsFrom(TCutG::Class())) continue;; 4450 if (strcmp(obj->GetName(),cuts)) continue;; 4451 cut = (TCutG*)obj;; 4452 break;; 4453 }; 4454 if (cut) {; 4455 fCuts[fNcuts] = cut;; 4456 fCutsOpt[fNcuts] = 1;; 4457 if (minus) fCutsOpt[fNcuts] = -1;; 4458 fNcuts++;; 4459 }; 4460 if (!comma) break;; 4461 cuts = comma+1;; 4462 }; 4463 for (i=0;i<=nch;i++) left[i] = ' ';; 4464 return fNcuts;; 4465}; 4466 ; 4467////////////////////////////////////////////////////////////////////////////////; 4468/// [Control routine to paint any kind of histograms](\ref HP00); 4469 ; 4470void THistPainter::Paint(Option_t *option); 4471{; 4472 ; 4473 if (fH->GetBuffer()) fH->BufferEmpty(-1);; 4474 ; 4475 //For iOS: put the histogram on the top of stack of pickable objects.; 4476 const TPickerStackGuard topPush(fH);; 4477 ; 4478 gPad->SetVertical(kTRUE);; 4479 ; 4480 TH1 *oldhist = gCurrentHist;; 4481 gCurrentHist = fH;; 4482 TH1 *hsave = fH;; 4483 Double_t minsav = fH->GetMinimumStored();; 448",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:247852,Integrability,depend,depends,247852,"mp1, &temp2[0]);; 6754 gPad->PaintPolyMarker(1, &temp2[0], &temp2[1]);; 6755 }; 6756 }; 6757 ; 6758 // Paint the Front Box if needed; 6759 if (Hoption.FrontBox) {; 6760 fLego->InitMoveScreen(-1.1,1.1);; 6761 fLego->SetDrawFace(&TPainter3dAlgorithms::DrawFaceMove2);; 6762 fLego->FrontBox(90);; 6763 }; 6764 ; 6765 // Paint the Axis if needed; 6766 if (!Hoption.Axis && !Hoption.Same && !Hoption.Lego && !Hoption.Surf) {; 6767 TGaxis axis;; 6768 PaintLegoAxis(&axis, 90);; 6769 }; 6770 ; 6771 fLego.reset();; 6772}; 6773 ; 6774////////////////////////////////////////////////////////////////////////////////; 6775/// Calculate range and clear pad (canvas).; 6776 ; 6777void THistPainter::PaintFrame(); 6778{; 6779 ; 6780 if (Hoption.Same) return;; 6781 ; 6782 RecalculateRange();; 6783 ; 6784 if (Hoption.Lego || Hoption.Surf || Hoption.Tri ||; 6785 Hoption.Contour == 14 || Hoption.Error >= 100) {; 6786 TObject *frame = gPad->FindObject(""TFrame"");; 6787 if (frame) gPad->Remove(frame);; 6788 return;; 6789 }; 6790 ; 6791 //The next statement is always executed on non-iOS platform,; 6792 //on iOS depends on pad mode.; 6793 if (!gPad->PadInSelectionMode() && !gPad->PadInHighlightMode()); 6794 gPad->PaintPadFrame(Hparam.xmin,Hparam.ymin,Hparam.xmax,Hparam.ymax);; 6795}; 6796 ; 6797////////////////////////////////////////////////////////////////////////////////; 6798/// [Paint functions associated to an histogram.](\ref HP28""); 6799 ; 6800void THistPainter::PaintFunction(Option_t *); 6801{; 6802 auto lnk = fFunctions->FirstLink();; 6803 ; 6804 while (lnk) {; 6805 auto obj = lnk->GetObject();; 6806 TVirtualPad::TContext ctxt(true);; 6807 if (obj->InheritsFrom(TF2::Class())) {; 6808 if (!obj->TestBit(TF2::kNotDraw)) {; 6809 if (Hoption.Lego || Hoption.Surf || Hoption.Error >= 100) {; 6810 TF2 *f2 = (TF2*)obj;; 6811 f2->SetMinimum(fH->GetMinimum());; 6812 f2->SetMaximum(fH->GetMaximum());; 6813 f2->SetRange(fH->GetXaxis()->GetXmin(), fH->GetYaxis()->GetXmin(), fH->GetXaxis()->GetXmax(), ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:249223,Integrability,depend,depends,249223,"; 6799 ; 6800void THistPainter::PaintFunction(Option_t *); 6801{; 6802 auto lnk = fFunctions->FirstLink();; 6803 ; 6804 while (lnk) {; 6805 auto obj = lnk->GetObject();; 6806 TVirtualPad::TContext ctxt(true);; 6807 if (obj->InheritsFrom(TF2::Class())) {; 6808 if (!obj->TestBit(TF2::kNotDraw)) {; 6809 if (Hoption.Lego || Hoption.Surf || Hoption.Error >= 100) {; 6810 TF2 *f2 = (TF2*)obj;; 6811 f2->SetMinimum(fH->GetMinimum());; 6812 f2->SetMaximum(fH->GetMaximum());; 6813 f2->SetRange(fH->GetXaxis()->GetXmin(), fH->GetYaxis()->GetXmin(), fH->GetXaxis()->GetXmax(), fH->GetYaxis()->GetXmax() );; 6814 f2->Paint(""surf same"");; 6815 } else {; 6816 obj->Paint(""cont3 same"");; 6817 }; 6818 }; 6819 } else if (obj->InheritsFrom(TF1::Class())) {; 6820 if (!obj->TestBit(TF1::kNotDraw)) obj->Paint(""lsame"");; 6821 } else {; 6822 //Let's make this 'function' selectable on iOS device (for example, it can be TPaveStat).; 6823 gPad->PushSelectableObject(obj);; 6824 ; 6825 //The next statement is ALWAYS executed on non-iOS platform, on iOS it depends on pad's mode; 6826 //and picked object.; 6827 if (!gPad->PadInHighlightMode() || (gPad->PadInHighlightMode() && obj == gPad->GetSelected())); 6828 obj->Paint(lnk->GetOption());; 6829 }; 6830 lnk = lnk->Next();; 6831 }; 6832}; 6833 ; 6834////////////////////////////////////////////////////////////////////////////////; 6835/// [Control routine to draw 1D histograms](\ref HP01b); 6836 ; 6837void THistPainter::PaintHist(Option_t *); 6838{; 6839 ; 6840 //On iOS: do not highlight hist, if part of it was selected.; 6841 //Never executes on non-iOS platform.; 6842 if (gPad->PadInHighlightMode() && gPad->GetSelected() != fH); 6843 return;; 6844 ; 6845 static char chopth[17];; 6846 ; 6847 Int_t htype, oldhtype;; 6848 Int_t i, j, first, last, nbins, fixbin;; 6849 Double_t c1, yb;; 6850 yb = 0;; 6851 ; 6852 strlcpy(chopth, "" "",17);; 6853 ; 6854 Double_t ymin = Hparam.ymin;; 6855 Double_t ymax = Hparam.ymax;; 6856 Double_t baroffset = fH->GetBarOffset(",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:249568,Integrability,rout,routine,249568,"Hoption.Surf || Hoption.Error >= 100) {; 6810 TF2 *f2 = (TF2*)obj;; 6811 f2->SetMinimum(fH->GetMinimum());; 6812 f2->SetMaximum(fH->GetMaximum());; 6813 f2->SetRange(fH->GetXaxis()->GetXmin(), fH->GetYaxis()->GetXmin(), fH->GetXaxis()->GetXmax(), fH->GetYaxis()->GetXmax() );; 6814 f2->Paint(""surf same"");; 6815 } else {; 6816 obj->Paint(""cont3 same"");; 6817 }; 6818 }; 6819 } else if (obj->InheritsFrom(TF1::Class())) {; 6820 if (!obj->TestBit(TF1::kNotDraw)) obj->Paint(""lsame"");; 6821 } else {; 6822 //Let's make this 'function' selectable on iOS device (for example, it can be TPaveStat).; 6823 gPad->PushSelectableObject(obj);; 6824 ; 6825 //The next statement is ALWAYS executed on non-iOS platform, on iOS it depends on pad's mode; 6826 //and picked object.; 6827 if (!gPad->PadInHighlightMode() || (gPad->PadInHighlightMode() && obj == gPad->GetSelected())); 6828 obj->Paint(lnk->GetOption());; 6829 }; 6830 lnk = lnk->Next();; 6831 }; 6832}; 6833 ; 6834////////////////////////////////////////////////////////////////////////////////; 6835/// [Control routine to draw 1D histograms](\ref HP01b); 6836 ; 6837void THistPainter::PaintHist(Option_t *); 6838{; 6839 ; 6840 //On iOS: do not highlight hist, if part of it was selected.; 6841 //Never executes on non-iOS platform.; 6842 if (gPad->PadInHighlightMode() && gPad->GetSelected() != fH); 6843 return;; 6844 ; 6845 static char chopth[17];; 6846 ; 6847 Int_t htype, oldhtype;; 6848 Int_t i, j, first, last, nbins, fixbin;; 6849 Double_t c1, yb;; 6850 yb = 0;; 6851 ; 6852 strlcpy(chopth, "" "",17);; 6853 ; 6854 Double_t ymin = Hparam.ymin;; 6855 Double_t ymax = Hparam.ymax;; 6856 Double_t baroffset = fH->GetBarOffset();; 6857 Double_t barwidth = fH->GetBarWidth();; 6858 Double_t baroffsetsave = gStyle->GetBarOffset();; 6859 Double_t barwidthsave = gStyle->GetBarWidth();; 6860 gStyle->SetBarOffset(baroffset);; 6861 gStyle->SetBarWidth(barwidth);; 6862 ; 6863 // Create ""LIFE"" structure to keep current histogram status; 6864 ; 6865 first",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:256936,Integrability,rout,routines,256936,"ackBox && Hoption.FrontBox) ol->Paint(option);; 7041 Hoption.System = kCARTESIAN;; 7042 ; 7043 if (!Hoption.Axis && !Hoption.Same) {; 7044 TGaxis axis;; 7045 PaintLegoAxis(&axis, 90);; 7046 }; 7047 ; 7048 // Draw palette. In case of 4D plot with TTree::Draw() the palette should; 7049 // be painted with the option colz.; 7050 if (fH->GetDrawOption() && strstr(opt,""colz"")) {; 7051 Int_t ndiv = fH->GetContour();; 7052 if (ndiv == 0 ) {; 7053 ndiv = gStyle->GetNumberContours();; 7054 fH->SetContour(ndiv);; 7055 }; 7056 PaintPalette();; 7057 }; 7058 ; 7059 // Draw title; 7060 PaintTitle();; 7061 ; 7062 //Draw stats and fit results; 7063 TF1 *fit = nullptr;; 7064 TIter next(fFunctions);; 7065 while (auto obj = next()) {; 7066 if (obj->InheritsFrom(TF1::Class())) {; 7067 fit = (TF1*)obj;; 7068 break;; 7069 }; 7070 }; 7071 if ((Hoption.Same%10) != 1) {; 7072 if (!fH->TestBit(TH1::kNoStats)) { // bit set via TH1::SetStats; 7073 PaintStat3(gStyle->GetOptStat(),fit);; 7074 }; 7075 }; 7076 ; 7077}; 7078 ; 7079////////////////////////////////////////////////////////////////////////////////; 7080/// Compute histogram parameters used by the drawing routines.; 7081 ; 7082Int_t THistPainter::PaintInit(); 7083{; 7084 ; 7085 if (fH->GetDimension() > 1 || Hoption.Lego || Hoption.Surf) return 1;; 7086 ; 7087 Int_t i;; 7088 static const char *where = ""PaintInit"";; 7089 Double_t yMARGIN = gStyle->GetHistTopMargin();; 7090 Int_t maximum = 0;; 7091 Int_t minimum = 0;; 7092 if (fH->GetMaximumStored() != -1111) maximum = 1;; 7093 if (fH->GetMinimumStored() != -1111) minimum = 1;; 7094 ; 7095 // Compute X axis parameters; 7096 ; 7097 Int_t last = fXaxis->GetLast();; 7098 Int_t first = fXaxis->GetFirst();; 7099 Hparam.xlowedge = fXaxis->GetBinLowEdge(first);; 7100 Hparam.xbinsize = fXaxis->GetBinWidth(first);; 7101 Hparam.xlast = last;; 7102 Hparam.xfirst = first;; 7103 Hparam.xmin = Hparam.xlowedge;; 7104 Hparam.xmax = fXaxis->GetBinLowEdge(last)+fXaxis->GetBinWidth(last);; 7105 ; 7106 // if lo",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:264972,Integrability,rout,routines,264972,"f (!maximum) ymax += TMath::Log10(2*(0.9/0.95));; 7298 if (!Hoption.Same) {; 7299 Hparam.ymin = ymin;; 7300 Hparam.ymax = ymax;; 7301 }; 7302 return 1;; 7303 }; 7304 ; 7305 // final adjustment of ymin for linear scale.; 7306 // if minimum is not set , then ymin is set to zero if >0; 7307 // or to ymin - margin if <0.; 7308 if (!minimum) {; 7309 if (Hoption.MinimumZero) {; 7310 if (ymin >= 0) ymin = 0;; 7311 else ymin -= yMARGIN*(ymax-ymin);; 7312 } else {; 7313 Double_t dymin = yMARGIN*(ymax-ymin);; 7314 if (ymin >= 0 && (ymin-dymin <= 0)) ymin = 0;; 7315 else ymin -= dymin;; 7316 }; 7317 }; 7318 ; 7319 // final adjustment of YMAXI for linear scale (if not option ""Same""):; 7320 // decrease histogram height to MAX% of allowed height if HMAXIM; 7321 // has not been called.; 7322 if (!maximum) {; 7323 ymax += yMARGIN*(ymax-ymin);; 7324 }; 7325 ; 7326 Hparam.ymin = ymin;; 7327 Hparam.ymax = ymax;; 7328 return 1;; 7329}; 7330 ; 7331////////////////////////////////////////////////////////////////////////////////; 7332/// Compute histogram parameters used by the drawing routines for a rotated pad.; 7333 ; 7334Int_t THistPainter::PaintInitH(); 7335{; 7336 ; 7337 static const char *where = ""PaintInitH"";; 7338 Double_t yMARGIN = gStyle->GetHistTopMargin();; 7339 Int_t maximum = 0;; 7340 Int_t minimum = 0;; 7341 if (fH->GetMaximumStored() != -1111) maximum = 1;; 7342 if (fH->GetMinimumStored() != -1111) minimum = 1;; 7343 ; 7344 // Compute X axis parameters; 7345 ; 7346 Int_t last = fXaxis->GetLast();; 7347 Int_t first = fXaxis->GetFirst();; 7348 Hparam.xlowedge = fXaxis->GetBinLowEdge(first);; 7349 Hparam.xbinsize = fXaxis->GetBinWidth(first);; 7350 Hparam.xlast = last;; 7351 Hparam.xfirst = first;; 7352 Hparam.ymin = Hparam.xlowedge;; 7353 Hparam.ymax = fXaxis->GetBinLowEdge(last)+fXaxis->GetBinWidth(last);; 7354 ; 7355 // if log scale in Y, replace ymin,max by the log; 7356 if (Hoption.Logy) {; 7357 if (Hparam.xlowedge <=0 ) {; 7358 Hparam.xlowedge = 0.1*Hparam.xbinsize;; 7",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:306885,Integrability,depend,dependency,306885," }; 8545 fXbuf[marker] = (random.Rndm()*xstep) + xk;; 8546 fYbuf[marker] = (random.Rndm()*ystep) + yk;; 8547 if (Hoption.Logx) {; 8548 if (fXbuf[marker] > 0) fXbuf[marker] = TMath::Log10(fXbuf[marker]);; 8549 else break;; 8550 }; 8551 if (Hoption.Logy) {; 8552 if (fYbuf[marker] > 0) fYbuf[marker] = TMath::Log10(fYbuf[marker]);; 8553 else break;; 8554 }; 8555 if (fXbuf[marker] < gPad->GetUxmin()) break;; 8556 if (fYbuf[marker] < gPad->GetUymin()) break;; 8557 if (fXbuf[marker] > gPad->GetUxmax()) break;; 8558 if (fYbuf[marker] > gPad->GetUymax()) break;; 8559 marker++;; 8560 }; 8561 }; 8562 }; 8563 }; 8564 if (marker > 0) gPad->PaintPolyMarker(marker, fXbuf.data(), fYbuf.data());; 8565 ; 8566 if (Hoption.Zscale) PaintPalette();; 8567}; 8568 ; 8569////////////////////////////////////////////////////////////////////////////////; 8570/// Static function to paint special objects like vectors and matrices.; 8571/// This function is called via `gROOT->ProcessLine` to paint these objects; 8572/// without having a direct dependency of the graphics or histogramming; 8573/// system.; 8574 ; 8575void THistPainter::PaintSpecialObjects(const TObject *obj, Option_t *option); 8576{; 8577 ; 8578 if (!obj) return;; 8579 Bool_t status = TH1::AddDirectoryStatus();; 8580 TH1::AddDirectory(kFALSE);; 8581 ; 8582 if (obj->InheritsFrom(TMatrixFBase::Class())) {; 8583 // case TMatrixF; 8584 TH2F *R__TMatrixFBase = new TH2F((TMatrixFBase &)*obj);; 8585 R__TMatrixFBase->SetBit(kCanDelete);; 8586 R__TMatrixFBase->Draw(option);; 8587 ; 8588 } else if (obj->InheritsFrom(TMatrixDBase::Class())) {; 8589 // case TMatrixD; 8590 TH2D *R__TMatrixDBase = new TH2D((TMatrixDBase &)*obj);; 8591 R__TMatrixDBase->SetBit(kCanDelete);; 8592 R__TMatrixDBase->Draw(option);; 8593 ; 8594 } else if (obj->InheritsFrom(TVectorF::Class())) {; 8595 //case TVectorF; 8596 TH1F *R__TVectorF = new TH1F((TVectorF &)*obj);; 8597 R__TVectorF->SetBit(kCanDelete);; 8598 R__TVectorF->Draw(option);; 8599 ; 8600 } else if (obj->Inh",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:350645,Integrability,depend,depends,350645,"; 9672 if (Hoption.Contour) PaintContour(option);; 9673 if (Hoption.Text) PaintText(option);; 9674 if (Hoption.Error >= 100) Paint2DErrors(option);; 9675 if (Hoption.Candle) PaintCandlePlot(option);; 9676 }; 9677 if (Hoption.Lego) PaintLego(option);; 9678 if (Hoption.Surf && !Hoption.Contour) PaintSurface(option);; 9679 if (Hoption.Tri) PaintTriangles(option);; 9680 }; 9681 ; 9682 // Draw histogram title; 9683 PaintTitle();; 9684 ; 9685 // Draw the axes; 9686 if (!Hoption.Lego && !Hoption.Surf &&; 9687 !Hoption.Tri && !(Hoption.Error >= 100)) PaintAxis(kFALSE);; 9688 ; 9689 TF1 *fit = nullptr;; 9690 TIter next(fFunctions);; 9691 while (auto obj = next()) {; 9692 if (obj->InheritsFrom(TF1::Class())) {; 9693 fit = (TF1*)obj;; 9694 break;; 9695 }; 9696 }; 9697 if ((Hoption.Same%10) != 1) {; 9698 if (!fH->TestBit(TH1::kNoStats)) { // bit set via TH1::SetStats; 9699 if (!gPad->PadInSelectionMode() && !gPad->PadInHighlightMode()) {; 9700 //ALWAYS executed on non-iOS platform.; 9701 //On iOS, depends on mode.; 9702 PaintStat2(gStyle->GetOptStat(),fit);; 9703 }; 9704 }; 9705 }; 9706}; 9707 ; 9708////////////////////////////////////////////////////////////////////////////////; 9709/// Control function to draw a TH2Poly bins' contours.; 9710///; 9711/// - option = ""F"" draw the bins as filled areas.; 9712/// - option = ""L"" draw the bins as line.; 9713/// - option = ""P"" draw the bins as markers.; 9714 ; 9715void THistPainter::PaintTH2PolyBins(Option_t *option); 9716{; 9717 ; 9718 //Do not highlight the histogram, if its part was picked.; 9719 if (gPad->PadInHighlightMode() && gPad->GetSelected() != fH) return;; 9720 ; 9721 TString opt = option;; 9722 opt.ToLower();; 9723 Bool_t line = kFALSE;; 9724 Bool_t fill = kFALSE;; 9725 Bool_t mark = kFALSE;; 9726 if (opt.Contains(""l"")) line = kTRUE;; 9727 if (opt.Contains(""f"")) fill = kTRUE;; 9728 if (opt.Contains(""p"")) mark = kTRUE;; 9729 ; 9730 TH2PolyBin *b;; 9731 Double_t z;; 9732 ; 9733 TIter next(((TH2Poly*)fH)->GetBins());; 9734 TO",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:369956,Integrability,message,message,369956,"fH->GetTitle());; 10272 if (wt > 0) title->SetX2NDC(title->GetX1NDC()+wt);; 10273 }; 10274 return;; 10275 }; 10276 ; 10277 Int_t talh = gStyle->GetTitleAlign()/10;; 10278 if (talh < 1) talh = 1; else if (talh > 3) talh = 3;; 10279 Int_t talv = gStyle->GetTitleAlign()%10;; 10280 if (talv < 1) talv = 1; else if (talv > 3) talv = 3;; 10281 Double_t xpos, ypos;; 10282 xpos = gStyle->GetTitleX();; 10283 ypos = gStyle->GetTitleY();; 10284 if (talh == 2) xpos = xpos-wt/2.;; 10285 if (talh == 3) xpos = xpos-wt;; 10286 if (talv == 2) ypos = ypos+ht/2.;; 10287 if (talv == 1) ypos = ypos+ht;; 10288 ; 10289 TPaveText *ptitle = new TPaveText(xpos, ypos-ht, xpos+wt, ypos,""blNDC"");; 10290 ; 10291 // box with the histogram title; 10292 ptitle->SetFillColor(gStyle->GetTitleFillColor());; 10293 ptitle->SetFillStyle(gStyle->GetTitleStyle());; 10294 ptitle->SetName(""title"");; 10295 ptitle->SetBorderSize(gStyle->GetTitleBorderSize());; 10296 ptitle->SetTextColor(gStyle->GetTitleTextColor());; 10297 ptitle->SetTextFont(gStyle->GetTitleFont(""""));; 10298 if (gStyle->GetTitleFont("""")%10 > 2); 10299 ptitle->SetTextSize(gStyle->GetTitleFontSize());; 10300 ptitle->AddText(fH->GetTitle());; 10301 ptitle->SetBit(kCanDelete);; 10302 ptitle->Draw();; 10303 ptitle->Paint();; 10304 ; 10305 if(!gPad->IsEditable()) delete ptitle;; 10306}; 10307 ; 10308////////////////////////////////////////////////////////////////////////////////; 10309/// Process message `mess`.; 10310 ; 10311void THistPainter::ProcessMessage(const char *mess, const TObject *obj); 10312{; 10313 if (!strcmp(mess,""SetF3"")) {; 10314 fCurrentF3 = (TF3 *)obj;; 10315 }; 10316}; 10317 ; 10318////////////////////////////////////////////////////////////////////////////////; 10319/// Static function.; 10320///; 10321/// Convert Right Ascension, Declination to X,Y using an AITOFF projection.; 10322/// This procedure can be used to create an all-sky map in Galactic; 10323/// coordinates with an equal-area Aitoff projection. Output map; 10324///",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:377647,Integrability,rout,routines,377647,"d;; 10490 if (xmax < xmax_aid) xmax = xmax_aid;; 10491 }; 10492 if (Hparam.xmin < 0 && Hparam.xmax > 0) {; 10493 func(0, Hparam.ymin, xmin_aid, ymin_aid);; 10494 func(0, Hparam.ymax, xmax_aid, ymax_aid);; 10495 if (ymin > ymin_aid) ymin = ymin_aid;; 10496 if (ymax < ymax_aid) ymax = ymax_aid;; 10497 }; 10498 }; 10499 ; 10500 Hparam.xmin = xmin;; 10501 Hparam.xmax = xmax;; 10502 Hparam.ymin = ymin;; 10503 Hparam.ymax = ymax;; 10504 ; 10505 Double_t dx = xmax-xmin;; 10506 Double_t dy = ymax-ymin;; 10507 Double_t dxr = dx/(1 - gPad->GetLeftMargin() - gPad->GetRightMargin());; 10508 Double_t dyr = dy/(1 - gPad->GetBottomMargin() - gPad->GetTopMargin());; 10509 ; 10510 // Range() could change the size of the pad pixmap and therefore should; 10511 // be called before the other paint routines; 10512 gPad->Range(xmin - dxr*gPad->GetLeftMargin(),; 10513 ymin - dyr*gPad->GetBottomMargin(),; 10514 xmax + dxr*gPad->GetRightMargin(),; 10515 ymax + dyr*gPad->GetTopMargin());; 10516 gPad->RangeAxis(xmin, ymin, xmax, ymax);; 10517}; 10518 ; 10519////////////////////////////////////////////////////////////////////////////////; 10520/// Set current histogram to `h`; 10521 ; 10522void THistPainter::SetHistogram(TH1 *h); 10523{; 10524 ; 10525 if (h == nullptr) return;; 10526 fH = h;; 10527 fXaxis = h->GetXaxis();; 10528 fYaxis = h->GetYaxis();; 10529 fZaxis = h->GetZaxis();; 10530 fFunctions = fH->GetListOfFunctions();; 10531}; 10532 ; 10533////////////////////////////////////////////////////////////////////////////////; 10534/// Initialize various options to draw 2D histograms.; 10535 ; 10536Int_t THistPainter::TableInit(); 10537{; 10538 ; 10539 static const char *where = ""TableInit"";; 10540 ; 10541 Int_t first, last;; 10542 Double_t yMARGIN= gStyle->GetHistTopMargin();; 10543 Double_t zmin, zmax;; 10544 Int_t maximum = 0;; 10545 Int_t minimum = 0;; 10546 if (fH->GetMaximumStored() != -1111) maximum = 1;; 10547 if (fH->GetMinimumStored() != -1111) minimum = 1;; 10548 ; 10549 // ------",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:462641,Integrability,rout,routine,462641,"ion)Definition TH2.h:357; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH2PolyBinHelper class to represent a bin in the TH2Poly histogram.Definition TH2Poly.h:25; TH2Poly2D Histogram with Polygonal BinsDefinition TH2Poly.h:66; TH2Poly::Classstatic TClass * Class(); TH2Service class for 2-D histogram classes.Definition TH2.h:30; TH2::Classstatic TClass * Class(); TH3The 3-D histogram classes derived from the 1-D histogram classes.Definition TH3.h:31; TH3::Classstatic TClass * Class(); THStackThe Histogram stack class.Definition THStack.h:40; THStack::Classstatic TClass * Class(); THistPainterThe histogram painter class.Definition THistPainter.h:50; THistPainter::ProjectSinusoidal2xystatic Int_t ProjectSinusoidal2xy(Double_t l, Double_t b, Double_t &Al, Double_t &Ab)Static function code for sinusoidal projection from Ernst-Jan Buis Source https://en....Definition THistPainter.cxx:10380; THistPainter::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histogramsDefinition THistPainter.cxx:4470; THistPainter::fYaxisTAxis * fYaxisPointer to Y axis.Definition THistPainter.h:55; THistPainter::fLegostd::unique_ptr< TPainter3dAlgorithms > fLegoPointer to a TPainter3dAlgorithms object.Definition THistPainter.h:58; THistPainter::fXbufstd::vector< Double_t > fXbufX buffer coordinates.Definition THistPainter.h:61; THistPainter::fXHighlightBinInt_t fXHighlightBinX highlight bin.Definition THistPainter.h:70; THistPainter::fCurrentF3TF3 * fCurrentF3Current TF3 function.Definition THistPainter.h:72; THistPainter::PaintErrorsvirtual void PaintErrors(Option_t *option)Draw 1D histograms error bars.Definition THistPainter.cxx:6314; THistPainter::~THistPainter~THistPainter() overridedestructor.Definition THistPainter.cxx:3242; THistPainter::fShowProjection2Int_t fShowProjection2True if a second projection must be drawn (when calling SetShowProjectionXY on a TH2)Definition THistPainter.h:68; THistPainter::PaintTF3vir",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:465128,Integrability,rout,routines,465128,"xystatic Int_t ProjectMollweide2xy(Double_t l, Double_t b, Double_t &Al, Double_t &Ab)Static function.Definition THistPainter.cxx:10412; THistPainter::ProjectAitoff2xystatic Int_t ProjectAitoff2xy(Double_t l, Double_t b, Double_t &Al, Double_t &Ab)Static function.Definition THistPainter.cxx:10331; THistPainter::PaintTextvirtual void PaintText(Option_t *option)Control function to draw a 1D/2D histograms with the bin values.Definition THistPainter.cxx:10056; THistPainter::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute the distance from the point px,py to a line.Definition THistPainter.cxx:3255; THistPainter::PaintAxisvirtual void PaintAxis(Bool_t drawGridOnly=kFALSE)Draw axis (2D case) of an histogram.Definition THistPainter.cxx:4766; THistPainter::PaintColorLevelsFastvirtual void PaintColorLevelsFast(Option_t *option)[Rendering scheme for the COL2 and COLZ2 options] (HP14)Definition THistPainter.cxx:5577; THistPainter::PaintInitvirtual Int_t PaintInit()Compute histogram parameters used by the drawing routines.Definition THistPainter.cxx:7082; THistPainter::Paint2DErrorsvirtual void Paint2DErrors(Option_t *option)Draw 2D histograms errors.Definition THistPainter.cxx:6617; THistPainter::fYHighlightBinInt_t fYHighlightBinY highlight bin.Definition THistPainter.h:71; THistPainter::PaintCandlePlotvirtual void PaintCandlePlot(Option_t *option)Control function to draw a 2D histogram as a candle (box) plot or violin plotDefinition THistPainter.cxx:5353; THistPainter::PaintScatterPlotvirtual void PaintScatterPlot(Option_t *option)Control function to draw a 2D histogram as a scatter plot.Definition THistPainter.cxx:8459; THistPainter::SetShowProjectionXYvoid SetShowProjectionXY(const char *option, Int_t nbinsY, Int_t nbinsX) overrideDefinition THistPainter.cxx:10804; THistPainter::PaintLegovirtual void PaintLego(Option_t *option)Control function to draw a 2D histogram as a lego plot.Definition THistPainter.cxx:8017; THistPainter::PaintH3virtua",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:472859,Integrability,message,message,472859," *option)Draw a bar-chart in a normal pad.Definition THistPainter.cxx:5043; THistPainter::ProjectMercator2xystatic Int_t ProjectMercator2xy(Double_t l, Double_t b, Double_t &Al, Double_t &Ab)Static function.Definition THistPainter.cxx:10366; THistPainter::PaintBoxesvirtual void PaintBoxes(Option_t *option)Control function to draw a 2D histogram as a box plotDefinition THistPainter.cxx:5168; THistPainter::MakeChoptvirtual Int_t MakeChopt(Option_t *option)Decode string choptin and fill Hoption structure.Definition THistPainter.cxx:4028; THistPainter::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideDisplay the histogram info (bin number, contents, integral up to bin corresponding to cursor position...Definition THistPainter.cxx:3729; THistPainter::GetContourListTList * GetContourList(Double_t contour) const overrideGet a contour (as a list of TGraphs) using the Delaunay triangulation.Definition THistPainter.cxx:3706; THistPainter::ProcessMessagevoid ProcessMessage(const char *mess, const TObject *obj) overrideProcess message mess.Definition THistPainter.cxx:10311; THistPainter::SetShowProjectionvoid SetShowProjection(const char *option, Int_t nbins) overrideSet projection.Definition THistPainter.cxx:10766; THistPainter::ShowProjectionYvirtual void ShowProjectionY(Int_t px, Int_t py)Show projection onto Y.Definition THistPainter.cxx:10933; THistPainter::GetBestFormatstatic const char * GetBestFormat(Double_t v, Double_t e, const char *f)This function returns the best format to print the error value (e) knowing the parameter value (v) an...Definition THistPainter.cxx:10714; THistPainter::PaintContourvirtual void PaintContour(Option_t *option)Control function to draw a 2D histogram as a contour plot.Definition THistPainter.cxx:5932; THistPainter::fCutsTCutG * fCuts[kMaxCuts]Pointers to graphical cuts.Definition THistPainter.h:65; THistPainter::PaintTablevirtual void PaintTable(Option_t *option)Control function to draw 2D/3D histograms (tables).Definitio",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:474096,Integrability,rout,routines,474096,"stPainter::ShowProjectionYvirtual void ShowProjectionY(Int_t px, Int_t py)Show projection onto Y.Definition THistPainter.cxx:10933; THistPainter::GetBestFormatstatic const char * GetBestFormat(Double_t v, Double_t e, const char *f)This function returns the best format to print the error value (e) knowing the parameter value (v) an...Definition THistPainter.cxx:10714; THistPainter::PaintContourvirtual void PaintContour(Option_t *option)Control function to draw a 2D histogram as a contour plot.Definition THistPainter.cxx:5932; THistPainter::fCutsTCutG * fCuts[kMaxCuts]Pointers to graphical cuts.Definition THistPainter.h:65; THistPainter::PaintTablevirtual void PaintTable(Option_t *option)Control function to draw 2D/3D histograms (tables).Definition THistPainter.cxx:9629; THistPainter::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute the actions corresponding to event.Definition THistPainter.cxx:3464; THistPainter::PaintInitHvirtual Int_t PaintInitH()Compute histogram parameters used by the drawing routines for a rotated pad.Definition THistPainter.cxx:7334; THistPainter::PaintFramevirtual void PaintFrame()Calculate range and clear pad (canvas).Definition THistPainter.cxx:6777; THistPainter::fCutsOptInt_t fCutsOpt[kMaxCuts]Sign of each cut.Definition THistPainter.h:64; THistPainter::PaintH3Isovirtual void PaintH3Iso()Control function to draw a 3D histogram with Iso Surfaces.Definition THistPainter.cxx:7892; THistPainter::fYbufstd::vector< Double_t > fYbufY buffer coordinates.Definition THistPainter.h:62; THistPainter::PaintH3BoxRastervirtual void PaintH3BoxRaster()Control function to draw a 3D histogram with boxes.Definition THistPainter.cxx:7690; THistPainter::PaintHistvirtual void PaintHist(Option_t *option)Control routine to draw 1D histogramsDefinition THistPainter.cxx:6837; THistPainter::SetHighlightvoid SetHighlight() overrideSet highlight (enable/disable) mode for fH.Definition THistPainter.cxx:3857; THistPainter::DefineColorLevelsv",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:474829,Integrability,rout,routine,474829,"stPainter.cxx:9629; THistPainter::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute the actions corresponding to event.Definition THistPainter.cxx:3464; THistPainter::PaintInitHvirtual Int_t PaintInitH()Compute histogram parameters used by the drawing routines for a rotated pad.Definition THistPainter.cxx:7334; THistPainter::PaintFramevirtual void PaintFrame()Calculate range and clear pad (canvas).Definition THistPainter.cxx:6777; THistPainter::fCutsOptInt_t fCutsOpt[kMaxCuts]Sign of each cut.Definition THistPainter.h:64; THistPainter::PaintH3Isovirtual void PaintH3Iso()Control function to draw a 3D histogram with Iso Surfaces.Definition THistPainter.cxx:7892; THistPainter::fYbufstd::vector< Double_t > fYbufY buffer coordinates.Definition THistPainter.h:62; THistPainter::PaintH3BoxRastervirtual void PaintH3BoxRaster()Control function to draw a 3D histogram with boxes.Definition THistPainter.cxx:7690; THistPainter::PaintHistvirtual void PaintHist(Option_t *option)Control routine to draw 1D histogramsDefinition THistPainter.cxx:6837; THistPainter::SetHighlightvoid SetHighlight() overrideSet highlight (enable/disable) mode for fH.Definition THistPainter.cxx:3857; THistPainter::DefineColorLevelsvirtual void DefineColorLevels(Int_t ndivz)Define the color levels used to paint legos, surfaces etc..Definition THistPainter.cxx:9603; THistPainter::fObjectInfoTString fObjectInfoDefinition THistPainter.h:75; THistPainter::PaintColorLevelsvirtual void PaintColorLevels(Option_t *option)Control function to draw a 2D histogram as a color plot.Definition THistPainter.cxx:5766; THistPainter::IsInsideBool_t IsInside(Int_t x, Int_t y) overrideReturn kTRUE if the cell ix, iy is inside one of the graphical cuts.Definition THistPainter.cxx:3994; TImagePaletteA class to define a conversion from pixel values to pixel color.Definition TAttImage.h:33; TImagePalette::CreateCOLPalettestatic TImagePalette * CreateCOLPalette(Int_t nContours)Factory method to creates a",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:475902,Integrability,interface,interface,475902,"etHighlightvoid SetHighlight() overrideSet highlight (enable/disable) mode for fH.Definition THistPainter.cxx:3857; THistPainter::DefineColorLevelsvirtual void DefineColorLevels(Int_t ndivz)Define the color levels used to paint legos, surfaces etc..Definition THistPainter.cxx:9603; THistPainter::fObjectInfoTString fObjectInfoDefinition THistPainter.h:75; THistPainter::PaintColorLevelsvirtual void PaintColorLevels(Option_t *option)Control function to draw a 2D histogram as a color plot.Definition THistPainter.cxx:5766; THistPainter::IsInsideBool_t IsInside(Int_t x, Int_t y) overrideReturn kTRUE if the cell ix, iy is inside one of the graphical cuts.Definition THistPainter.cxx:3994; TImagePaletteA class to define a conversion from pixel values to pixel color.Definition TAttImage.h:33; TImagePalette::CreateCOLPalettestatic TImagePalette * CreateCOLPalette(Int_t nContours)Factory method to creates an image palette for histogram plotting.Definition TAttImage.cxx:739; TImageAn abstract interface to image processing library.Definition TImage.h:29; TImage::Createstatic TImage * Create()Create an image.Definition TImage.cxx:35; TImage::SetImagevirtual void SetImage(const Double_t *, UInt_t, UInt_t, TImagePalette *=nullptr)Definition TImage.h:116; TImage::PaintImagevirtual void PaintImage(Drawable_t, Int_t, Int_t, Int_t=0, Int_t=0, UInt_t=0, UInt_t=0, Option_t *="""")Definition TImage.h:243; TIterDefinition TCollection.h:235; TIter::Resetvoid Reset()Definition TCollection.h:254; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition TList.cxx:820; TList::FirstTObject * First() const overrideReturn the first object in the list. Returns 0 w",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:479412,Integrability,message,message,479412,"delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TObjArray.cxx:415; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjLink::GetObjectTObject * GetObject() constDefinition TList.h:145; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Clearvirtual void Clear(Option_t *="""")Definition TObject.h:119; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Paintvirtual void Paint(Option_t *option="""")This method must be overridden if a class wants to paint itself.Definition TObject.cxx:612; TObject::kCannotPick@ kCannotPickif object in a pad cannot be pickedDefinition TObject",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:479967,Integrability,message,message,479967,"ct.h:119; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Paintvirtual void Paint(Option_t *option="""")This method must be overridden if a class wants to paint itself.Definition TObject.cxx:612; TObject::kCannotPick@ kCannotPickif object in a pad cannot be pickedDefinition TObject.h:67; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPainter3dAlgorithms::DrawFaceMove3void DrawFaceMove3(Int_t *icodes, Double_t *xyz, Int_t np, Int_t *iface, Double_t *tt)Draw face - 3rd variant for ""MOVING SCREEN"" algorithm (draw level lines only)Definition TPainter3dAlgorithms.cxx:705; TPainter3dAlgorithms::DrawLevelLinesvoid DrawLevelLines(Int_t *icodes, Double_t *xyz, Int_t np, Int_t *iface, Do",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:19639,Modifiability,inherit,inherit,19639," is subdivided into a number of pads equal to the number of histograms in the stack and each histogram is paint into a separate pad.|; 355| ""PFC"" | Palette Fill Color: stack's fill color is taken in the current palette. |; 356| ""PLC"" | Palette Line Color: stack's line color is taken in the current palette. |; 357| ""PMC"" | Palette Marker Color: stack's marker color is taken in the current palette. |; 358 ; 359 ; 360 ; 361\anchor HP02; 362### Setting the Style; 363 ; 364 ; 365Histograms use the current style (`gStyle`). When one changes the current; 366style and would like to propagate the changes to the histogram,; 367`TH1::UseCurrentStyle` should be called. Call `UseCurrentStyle` on; 368each histogram is needed.; 369 ; 370To force all the histogram to use the current style use:; 371 ; 372 gROOT->ForceStyle();; 373 ; 374All the histograms read after this call will use the current style.; 375 ; 376 ; 377\anchor HP03; 378### Setting line, fill, marker, and text attributes; 379 ; 380 ; 381The histogram classes inherit from the attribute classes:; 382`TAttLine`, `TAttFill` and `TAttMarker`.; 383See the description of these classes for the list of options.; 384 ; 385 ; 386\anchor HP04; 387### Setting Tick marks on the histogram axis; 388 ; 389 ; 390The `TPad::SetTicks` method specifies the type of tick marks on the axis.; 391If ` tx = gPad->GetTickx()` and `ty = gPad->GetTicky()` then:; 392 ; 393 tx = 1; tick marks on top side are drawn (inside); 394 tx = 2; tick marks and labels on top side are drawn; 395 ty = 1; tick marks on right side are drawn (inside); 396 ty = 2; tick marks and labels on right side are drawn; 397 ; 398By default only the left Y axis and X bottom axis are drawn; 399(`tx = ty = 0`); 400 ; 401`TPad::SetTicks(tx,ty)` allows to set these options.; 402See also The `TAxis` functions to set specific axis attributes.; 403 ; 404In case multiple color filled histograms are drawn on the same pad, the fill; 405area may hide the axis tick marks. One can force a ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:60777,Modifiability,config,configuration,60777,"ing a whisker-range of 0.95 and w=1 will redefine the area of; 1419the lower whisker to the upper whisker in order to cover 95% of the distribution inside; 1420that candle. The static function will affect all candle-charts in the running program.; 1421Default is 1.; 1422 ; 1423If the distribution is large enough and gaussian shaped, the maximum length of; 1424the whisker will be located at \f$ \pm 2.698 \sigma \f$ (when using the; 14251.5*iqr-definition (w=2), where \f$ \sigma \f$ is the standard deviation; 1426(see picture above). In that case 99.3% of the total distribution will be covered; 1427by the box and the whiskers, whereas 0.7% are represented by the outliers.; 1428 ; 1429##### The Anchors; 1430The anchors have no special meaning in terms of statistical calculation. They mark; 1431the end of the whiskers and they have the width of the box. Both representation; 1432with and without anchors are common.; 1433 ; 1434##### The Points; 1435Depending on the configuration the points can have different meanings:; 1436 - If p=1 the points represent the outliers. If they are shown, it means; 1437 some parts of the underlying distribution are not covered by the whiskers.; 1438 This can only occur when the whiskers are set to option w=2. Here the whiskers; 1439 can have a maximum length of \f$ 1.5 \times iqr \f$. So any points outside the; 1440 whiskers will be drawn as outliers. The outliers will be represented by crosses.; 1441 - If p=2 all points in the distribution will be painted as crosses. This is; 1442 useful for small datasets only (up to 10 or 20 points per candle).; 1443 The outliers are shown along the candle. Because the underlying distribution; 1444 is binned, is frequently occurs that a bin contains more than one value.; 1445 Because of this the points will be randomly scattered within their bin along; 1446 the candle axis. If the bin content for a bin is exactly 1 (usually; 1447 this happens for the outliers) if will be drawn in the middle of the bin alo",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:298303,Modifiability,variab,variable,298303,"chopax, ""SDH=-"",8);; 8296 if (y1[0] > y2[0]) strlcpy(chopay, ""SDH=+"",8);; 8297 else strlcpy(chopay, ""SDH=-"",8);; 8298 if (z2[1] > z1[1]) strlcpy(chopaz, ""SDH=+"",8);; 8299 else strlcpy(chopaz, ""SDH=-"",8);; 8300 ; 8301 // Option LOG is required ?; 8302 if (Hoption.Logx) strlcat(chopax,""G"",8);; 8303 if (Hoption.Logy) strlcat(chopay,""G"",8);; 8304 if (Hoption.Logz) strlcat(chopaz,""G"",8);; 8305 ; 8306 // Initialize the number of divisions. If the; 8307 // number of divisions is negative, option 'N' is required.; 8308 ndivx = fXaxis->GetNdivisions();; 8309 ndivy = fYaxis->GetNdivisions();; 8310 ndivz = fZaxis->GetNdivisions();; 8311 if (ndivx < 0) {; 8312 ndivx = TMath::Abs(ndivx);; 8313 strlcat(chopax, ""N"",8);; 8314 }; 8315 if (ndivy < 0) {; 8316 ndivy = TMath::Abs(ndivy);; 8317 strlcat(chopay, ""N"",8);; 8318 }; 8319 if (ndivz < 0) {; 8320 ndivz = TMath::Abs(ndivz);; 8321 strlcat(chopaz, ""N"",8);; 8322 }; 8323 ; 8324 // Set Axis attributes.; 8325 // The variable SCALE rescales the VSIZ; 8326 // in order to have the same label size for all angles.; 8327 ; 8328 axis->SetLineWidth(1);; 8329 ; 8330 // X axis drawing; 8331 if (TMath::Abs(x1[0] - x2[0]) >= epsil || TMath::Abs(x1[1] - x2[1]) > epsil) {; 8332 axis->ImportAxisAttributes(fXaxis);; 8333 axis->SetLabelOffset(fXaxis->GetLabelOffset()+fXaxis->GetTickLength());; 8334 if (Hoption.Logx && !fH->InheritsFrom(TH3::Class())) {; 8335 bmin = TMath::Power(10, rmin[0]);; 8336 bmax = TMath::Power(10, rmax[0]);; 8337 } else {; 8338 bmin = rmin[0];; 8339 bmax = rmax[0];; 8340 }; 8341 // Option time display is required ?; 8342 if (fXaxis->GetTimeDisplay()) {; 8343 strlcat(chopax,""t"",8);; 8344 if (strlen(fXaxis->GetTimeFormatOnly()) == 0) {; 8345 axis->SetTimeFormat(fXaxis->ChooseTimeFormat(bmax-bmin));; 8346 } else {; 8347 axis->SetTimeFormat(fXaxis->GetTimeFormat());; 8348 }; 8349 }; 8350 axis->SetOption(chopax);; 8351 axis->PaintAxis(x1[0], x1[1], x2[0], x2[1], bmin, bmax, ndivx, chopax);; 8352 }; 8353 ; 8354 // Y axis drawing; 8355 ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:479813,Modifiability,inherit,inherits,479813,"ink::GetObjectTObject * GetObject() constDefinition TList.h:145; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Clearvirtual void Clear(Option_t *="""")Definition TObject.h:119; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Paintvirtual void Paint(Option_t *option="""")This method must be overridden if a class wants to paint itself.Definition TObject.cxx:612; TObject::kCannotPick@ kCannotPickif object in a pad cannot be pickedDefinition TObject.h:67; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPainter3dAlgorithms::DrawFaceMove3void DrawFaceMove3(Int_t *icodes, Double_t *xyz, Int_t np, Int_t *iface, Double_t *tt)Draw face - 3rd variant for ""MOVING SCREEN",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:13779,Performance,perform,performance,13779,"he content's absolute value. A negative content is marked with a X. |; 283| ""BOX1"" | A button is drawn for each cell with surface proportional to content's absolute value. A sunken button is drawn for negative values a raised one for positive.|; 284| ""COL"" | A box is drawn for each cell with a color scale varying with contents. All the none empty bins are painted. Empty bins are not painted unless some bins have a negative content because in that case the null bins might be not empty. `TProfile2D` histograms are handled differently because, for this type of 2D histograms, it is possible to know if an empty bin has been filled or not. So even if all the bins' contents are positive some empty bins might be painted. And vice versa, if some bins have a negative content some empty bins might be not painted (default).|; 285| ""COLZ"" | Same as ""COL"". In addition the color palette is also drawn.|; 286| ""COL2"" | Alternative rendering algorithm to ""COL"". Can significantly improve rendering performance for large, non-sparse 2-D histograms.|; 287| ""COLZ2"" | Same as ""COL2"". In addition the color palette is also drawn.|; 288| ""Z CJUST"" | In combination with colored options ""COL"",""CONT0"" etc: Justify labels in the color palette at color boundaries. For more details see `TPaletteAxis`|; 289| ""CANDLE"" | Draw a candle plot along X axis.|; 290| ""CANDLEX"" | Same as ""CANDLE"".|; 291| ""CANDLEY"" | Draw a candle plot along Y axis.|; 292| ""CANDLEXn"" | Draw a candle plot along X axis. Different candle-styles with n from 1 to 6.|; 293| ""CANDLEYn"" | Draw a candle plot along Y axis. Different candle-styles with n from 1 to 6.|; 294| ""VIOLIN"" | Draw a violin plot along X axis.|; 295| ""VIOLINX"" | Same as ""VIOLIN"".|; 296| ""VIOLINY"" | Draw a violin plot along Y axis.|; 297| ""VIOLINXn"" | Draw a violin plot along X axis. Different violin-styles with n being 1 or 2.|; 298| ""VIOLINYn"" | Draw a violin plot along Y axis. Different violin-styles with n being 1 or 2.|; 299| ""CONT"" | Draw a contour plot (same",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:36235,Performance,scalab,scalable,36235,"828should be used.; 829 ; 830To control the bar offset (default is 0) `TH1::SetBarOffset()` should; 831be used.; 832 ; 833These two parameters are useful when several histograms are plotted using; 834the option `SAME`. They allow to plot the histograms next to each other.; 835 ; 836 ; 837\anchor HP11; 838### The SCATter plot option (legacy draw option); 839 ; 840\attention; 841Use of option `SCAT` has been deprecated. It was the default drawing option for 2D and; 8423D histograms. The new default option is `COL` (heat-map).; 843 ; 844 ; 845For each cell (i,j) a number of points proportional to the cell content is; 846drawn. A maximum of `kNMAX` points per cell is drawn. If the maximum is above; 847`kNMAX` contents are normalized to `kNMAX` (`kNMAX=2000`).; 848If option is of the form `scat=ff`, (eg `scat=1.8`,; 849`scat=1e-3`), then `ff` is used as a scale factor to compute the; 850number of dots. `scat=1` is the default.; 851 ; 852By default the scatter plot is painted with a ""dot marker"" which not scalable; 853(see the `TAttMarker` documentation). To change the marker size, a scalable marker; 854type should be used. For instance a circle (marker style 20).; 855 ; 856Begin_Macro(source); 857{; 858 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 859 auto hscat = new TH2F(""hscat"",""Option SCATter example (default for 2D histograms) "",40,-4,4,40,-20,20);; 860 float px, py;; 861 for (Int_t i = 0; i < 25000; i++) {; 862 gRandom->Rannor(px,py);; 863 hscat->Fill(px,5*py);; 864 hscat->Fill(3+0.5*px,2*py-10.);; 865 }; 866 hscat->Draw(""scat=0.5""); // This a legacy draw option. Please consider using TScatter; 867}; 868End_Macro; 869 ; 870 ; 871\anchor HP12; 872### The ARRow option; 873 ; 874 ; 875Shows gradient between adjacent cells. For each cell (i,j) an arrow is drawn; 876The orientation of the arrow follows the cell gradient.; 877 ; 878Begin_Macro(source); 879{; 880 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 881 auto harr = new TH2F(""harr"",""Option ARRow example"",20,-4,4,20,-20",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:36315,Performance,scalab,scalable,36315,"831be used.; 832 ; 833These two parameters are useful when several histograms are plotted using; 834the option `SAME`. They allow to plot the histograms next to each other.; 835 ; 836 ; 837\anchor HP11; 838### The SCATter plot option (legacy draw option); 839 ; 840\attention; 841Use of option `SCAT` has been deprecated. It was the default drawing option for 2D and; 8423D histograms. The new default option is `COL` (heat-map).; 843 ; 844 ; 845For each cell (i,j) a number of points proportional to the cell content is; 846drawn. A maximum of `kNMAX` points per cell is drawn. If the maximum is above; 847`kNMAX` contents are normalized to `kNMAX` (`kNMAX=2000`).; 848If option is of the form `scat=ff`, (eg `scat=1.8`,; 849`scat=1e-3`), then `ff` is used as a scale factor to compute the; 850number of dots. `scat=1` is the default.; 851 ; 852By default the scatter plot is painted with a ""dot marker"" which not scalable; 853(see the `TAttMarker` documentation). To change the marker size, a scalable marker; 854type should be used. For instance a circle (marker style 20).; 855 ; 856Begin_Macro(source); 857{; 858 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 859 auto hscat = new TH2F(""hscat"",""Option SCATter example (default for 2D histograms) "",40,-4,4,40,-20,20);; 860 float px, py;; 861 for (Int_t i = 0; i < 25000; i++) {; 862 gRandom->Rannor(px,py);; 863 hscat->Fill(px,5*py);; 864 hscat->Fill(3+0.5*px,2*py-10.);; 865 }; 866 hscat->Draw(""scat=0.5""); // This a legacy draw option. Please consider using TScatter; 867}; 868End_Macro; 869 ; 870 ; 871\anchor HP12; 872### The ARRow option; 873 ; 874 ; 875Shows gradient between adjacent cells. For each cell (i,j) an arrow is drawn; 876The orientation of the arrow follows the cell gradient.; 877 ; 878Begin_Macro(source); 879{; 880 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 881 auto harr = new TH2F(""harr"",""Option ARRow example"",20,-4,4,20,-20,20);; 882 harr->SetLineColor(kRed);; 883 float px, py;; 884 for (Int_t i = 0; i < 25000; i++) {; 88",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:47642,Performance,perform,performance,47642,"t(TH1::kNoStats);; 1150 for (Int_t i=0;i<5000;i++) {; 1151 double x,y;; 1152 gRandom->Rannor(x,y);; 1153 if(x>0 && y>0) h1->Fill(x,y,4);; 1154 if(x<0 && y<0) h2->Fill(x,y,3);; 1155 if(x>0 && y<0) h3->Fill(x,y,2);; 1156 if(x<0 && y>0) h4->Fill(x,y,1);; 1157 }; 1158 h1->Draw(""colz"");; 1159 h2->Draw(""col same"");; 1160 h3->Draw(""col same"");; 1161 h4->Draw(""col same"");; 1162}; 1163End_Macro; 1164 ; 1165The option `COL` can be combined with the option `POL`:; 1166 ; 1167Begin_Macro(source); 1168{; 1169 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 1170 auto hcol1 = new TH2F(""hcol1"",""Option COLor combined with POL"",40,-4,4,40,-4,4);; 1171 float px, py;; 1172 for (Int_t i = 0; i < 25000; i++) {; 1173 gRandom->Rannor(px,py);; 1174 hcol1->Fill(px,py);; 1175 }; 1176 hcol1->Draw(""COLZPOL"");; 1177}; 1178End_Macro; 1179 ; 1180\since **ROOT version 6.07/03:**; 1181 ; 1182A second rendering technique is also available with the COL2 and COLZ2 options.; 1183 ; 1184These options provide potential performance improvements compared to the standard; 1185COL option. The performance comparison of the COL2 to the COL option depends on; 1186the histogram and the size of the rendering region in the current pad. In general,; 1187a small (approx. less than 100 bins per axis), sparsely populated TH2 will render; 1188faster with the COL option.; 1189 ; 1190However, for larger histograms (approx. more than 100 bins per axis); 1191that are not sparse, the COL2 option will provide up to 20 times performance improvements.; 1192For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude; 1193faster with the COL2 option.; 1194 ; 1195The COL2 option will also scale its performance based on the size of the; 1196pixmap the histogram image is being rendered into. It also is much better optimized for; 1197sessions where the user is forwarding X11 windows through an `ssh` connection.; 1198 ; 1199For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; 1200and ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:47713,Performance,perform,performance,47713,"(x,y,4);; 1154 if(x<0 && y<0) h2->Fill(x,y,3);; 1155 if(x>0 && y<0) h3->Fill(x,y,2);; 1156 if(x<0 && y>0) h4->Fill(x,y,1);; 1157 }; 1158 h1->Draw(""colz"");; 1159 h2->Draw(""col same"");; 1160 h3->Draw(""col same"");; 1161 h4->Draw(""col same"");; 1162}; 1163End_Macro; 1164 ; 1165The option `COL` can be combined with the option `POL`:; 1166 ; 1167Begin_Macro(source); 1168{; 1169 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 1170 auto hcol1 = new TH2F(""hcol1"",""Option COLor combined with POL"",40,-4,4,40,-4,4);; 1171 float px, py;; 1172 for (Int_t i = 0; i < 25000; i++) {; 1173 gRandom->Rannor(px,py);; 1174 hcol1->Fill(px,py);; 1175 }; 1176 hcol1->Draw(""COLZPOL"");; 1177}; 1178End_Macro; 1179 ; 1180\since **ROOT version 6.07/03:**; 1181 ; 1182A second rendering technique is also available with the COL2 and COLZ2 options.; 1183 ; 1184These options provide potential performance improvements compared to the standard; 1185COL option. The performance comparison of the COL2 to the COL option depends on; 1186the histogram and the size of the rendering region in the current pad. In general,; 1187a small (approx. less than 100 bins per axis), sparsely populated TH2 will render; 1188faster with the COL option.; 1189 ; 1190However, for larger histograms (approx. more than 100 bins per axis); 1191that are not sparse, the COL2 option will provide up to 20 times performance improvements.; 1192For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude; 1193faster with the COL2 option.; 1194 ; 1195The COL2 option will also scale its performance based on the size of the; 1196pixmap the histogram image is being rendered into. It also is much better optimized for; 1197sessions where the user is forwarding X11 windows through an `ssh` connection.; 1198 ; 1199For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; 1200and COLZ options. There is one major difference and that concerns the treatment of; 1201bins with zero content. The COL2 and COLZ2 ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:48136,Performance,perform,performance,48136,"ion `POL`:; 1166 ; 1167Begin_Macro(source); 1168{; 1169 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 1170 auto hcol1 = new TH2F(""hcol1"",""Option COLor combined with POL"",40,-4,4,40,-4,4);; 1171 float px, py;; 1172 for (Int_t i = 0; i < 25000; i++) {; 1173 gRandom->Rannor(px,py);; 1174 hcol1->Fill(px,py);; 1175 }; 1176 hcol1->Draw(""COLZPOL"");; 1177}; 1178End_Macro; 1179 ; 1180\since **ROOT version 6.07/03:**; 1181 ; 1182A second rendering technique is also available with the COL2 and COLZ2 options.; 1183 ; 1184These options provide potential performance improvements compared to the standard; 1185COL option. The performance comparison of the COL2 to the COL option depends on; 1186the histogram and the size of the rendering region in the current pad. In general,; 1187a small (approx. less than 100 bins per axis), sparsely populated TH2 will render; 1188faster with the COL option.; 1189 ; 1190However, for larger histograms (approx. more than 100 bins per axis); 1191that are not sparse, the COL2 option will provide up to 20 times performance improvements.; 1192For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude; 1193faster with the COL2 option.; 1194 ; 1195The COL2 option will also scale its performance based on the size of the; 1196pixmap the histogram image is being rendered into. It also is much better optimized for; 1197sessions where the user is forwarding X11 windows through an `ssh` connection.; 1198 ; 1199For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; 1200and COLZ options. There is one major difference and that concerns the treatment of; 1201bins with zero content. The COL2 and COLZ2 options color these bins the color of zero.; 1202 ; 1203COL2 option renders the histogram as a bitmap. Therefore it cannot be saved in vector; 1204graphics file format like PostScript or PDF (an empty image will be generated). It can; 1205be saved only in bitmap files like PNG format for instance.; 1206 ; 1207 ; 1208\",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:48335,Performance,perform,performance,48335,"om->Rannor(px,py);; 1174 hcol1->Fill(px,py);; 1175 }; 1176 hcol1->Draw(""COLZPOL"");; 1177}; 1178End_Macro; 1179 ; 1180\since **ROOT version 6.07/03:**; 1181 ; 1182A second rendering technique is also available with the COL2 and COLZ2 options.; 1183 ; 1184These options provide potential performance improvements compared to the standard; 1185COL option. The performance comparison of the COL2 to the COL option depends on; 1186the histogram and the size of the rendering region in the current pad. In general,; 1187a small (approx. less than 100 bins per axis), sparsely populated TH2 will render; 1188faster with the COL option.; 1189 ; 1190However, for larger histograms (approx. more than 100 bins per axis); 1191that are not sparse, the COL2 option will provide up to 20 times performance improvements.; 1192For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude; 1193faster with the COL2 option.; 1194 ; 1195The COL2 option will also scale its performance based on the size of the; 1196pixmap the histogram image is being rendered into. It also is much better optimized for; 1197sessions where the user is forwarding X11 windows through an `ssh` connection.; 1198 ; 1199For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; 1200and COLZ options. There is one major difference and that concerns the treatment of; 1201bins with zero content. The COL2 and COLZ2 options color these bins the color of zero.; 1202 ; 1203COL2 option renders the histogram as a bitmap. Therefore it cannot be saved in vector; 1204graphics file format like PostScript or PDF (an empty image will be generated). It can; 1205be saved only in bitmap files like PNG format for instance.; 1206 ; 1207 ; 1208\anchor HP140; 1209### The CANDLE and VIOLIN options; 1210 ; 1211The mechanism behind Candle plots and Violin plots is very similar. Because of this they are; 1212implemented in the same class TCandle. The keywords CANDLE or VIOLIN will initiate the drawing o",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:48451,Performance,optimiz,optimized,48451,"version 6.07/03:**; 1181 ; 1182A second rendering technique is also available with the COL2 and COLZ2 options.; 1183 ; 1184These options provide potential performance improvements compared to the standard; 1185COL option. The performance comparison of the COL2 to the COL option depends on; 1186the histogram and the size of the rendering region in the current pad. In general,; 1187a small (approx. less than 100 bins per axis), sparsely populated TH2 will render; 1188faster with the COL option.; 1189 ; 1190However, for larger histograms (approx. more than 100 bins per axis); 1191that are not sparse, the COL2 option will provide up to 20 times performance improvements.; 1192For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude; 1193faster with the COL2 option.; 1194 ; 1195The COL2 option will also scale its performance based on the size of the; 1196pixmap the histogram image is being rendered into. It also is much better optimized for; 1197sessions where the user is forwarding X11 windows through an `ssh` connection.; 1198 ; 1199For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; 1200and COLZ options. There is one major difference and that concerns the treatment of; 1201bins with zero content. The COL2 and COLZ2 options color these bins the color of zero.; 1202 ; 1203COL2 option renders the histogram as a bitmap. Therefore it cannot be saved in vector; 1204graphics file format like PostScript or PDF (an empty image will be generated). It can; 1205be saved only in bitmap files like PNG format for instance.; 1206 ; 1207 ; 1208\anchor HP140; 1209### The CANDLE and VIOLIN options; 1210 ; 1211The mechanism behind Candle plots and Violin plots is very similar. Because of this they are; 1212implemented in the same class TCandle. The keywords CANDLE or VIOLIN will initiate the drawing of; 1213the corresponding plots. Followed by the keyword the user can select a plot direction (X or V for; 1214vertical projections,",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:61939,Performance,perform,performed,61939,"own, it means; 1437 some parts of the underlying distribution are not covered by the whiskers.; 1438 This can only occur when the whiskers are set to option w=2. Here the whiskers; 1439 can have a maximum length of \f$ 1.5 \times iqr \f$. So any points outside the; 1440 whiskers will be drawn as outliers. The outliers will be represented by crosses.; 1441 - If p=2 all points in the distribution will be painted as crosses. This is; 1442 useful for small datasets only (up to 10 or 20 points per candle).; 1443 The outliers are shown along the candle. Because the underlying distribution; 1444 is binned, is frequently occurs that a bin contains more than one value.; 1445 Because of this the points will be randomly scattered within their bin along; 1446 the candle axis. If the bin content for a bin is exactly 1 (usually; 1447 this happens for the outliers) if will be drawn in the middle of the bin along; 1448 the candle axis. As the maximum number of points per candle is limited by kNMax/2; 1449 on very large datasets scaling will be performed automatically. In that case one; 1450 would loose all outliers because they have usually a bin content of 1 (and a; 1451 bin content between 0 and 1 after the scaling). Because of this all bin contents; 1452 between 0 and 1 - after the scaling - will be forced to be 1.; 1453 - As the drawing of all values on large datasets can lead to big amounts of crosses,; 1454 one can show all values as a scatter plot instead by choosing p=3. The points will be; 1455 drawn as dots and will be scattered within the width of the candle. The color; 1456 of the points will be the color of the candle-chart.; 1457 ; 1458##### Other Options; 1459Is is possible to combine all options of candle and violin plots with each other. E.g. a box-plot; 1460with a histogram.; 1461 ; 1462#### How to use the candle-plots drawing option; 1463 ; 1464There are six predefined candle-plot representations:; 1465 ; 1466 - ""CANDLEX1"": Standard candle (whiskers cover the whol",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:77711,Performance,perform,performed,77711,"lor palette defined by `gStyle->SetPalette()`.; 1828 ; 1829Begin_Macro(source); 1830{; 1831 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 1832 auto hcont4 = new TH2F(""hcont4"",""Option CONT4Z example "",40,-4,4,40,-20,20);; 1833 float px, py;; 1834 for (Int_t i = 0; i < 25000; i++) {; 1835 gRandom->Rannor(px,py);; 1836 hcont4->Fill(px-1,5*py);; 1837 hcont4->Fill(2+0.5*px,2*py-10.,0.1);; 1838 }; 1839 hcont4->Draw(""CONT4Z"");; 1840}; 1841End_Macro; 1842 ; 1843The default number of contour levels is 20 equidistant levels and can be changed; 1844with `TH1::SetContour()` or `TStyle::SetNumberContours()`.; 1845 ; 1846\anchor HP16a; 1847#### The LIST option; 1848 ; 1849When option `LIST` is specified together with option; 1850`CONT`, the points used to draw the contours are saved in; 1851`TGraph` objects:; 1852 ; 1853 h->Draw(""CONT LIST"");; 1854 gPad->Update();; 1855 ; 1856The contour are saved in `TGraph` objects once the pad is painted.; 1857Therefore to use this functionality in a macro, `gPad->Update()`; 1858should be performed after the histogram drawing. Once the list is; 1859built, the contours are accessible in the following way:; 1860 ; 1861 TObjArray *contours = (TObjArray*)gROOT->GetListOfSpecials()->FindObject(""contours"");; 1862 Int_t ncontours = contours->GetSize();; 1863 TList *list = (TList*)contours->At(i);; 1864 ; 1865Where `i` is a contour number, and list contains a list of; 1866`TGraph` objects.; 1867For one given contour, more than one disjoint polyline may be generated.; 1868The number of TGraphs per contour is given by:; 1869 ; 1870 list->GetSize();; 1871 ; 1872To access the first graph in the list one should do:; 1873 ; 1874 TGraph *gr1 = (TGraph*)list->First();; 1875 ; 1876 ; 1877The following example (ContourList.C) shows how to use this functionality.; 1878 ; 1879Begin_Macro(source); 1880../../../tutorials/hist/ContourList.C; 1881End_Macro; 1882 ; 1883\anchor HP16b; 1884#### The AITOFF, MERCATOR, SINUSOIDAL and PARABOLIC options; 1885 ; 1886The followin",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:117804,Performance,perform,performed,117804,"--------------------------------------------------------|; 2944| ""GLISO"" | TH3 is drawn using iso-surfaces.|; 2945 ; 2946 ; 2947 ; 2948\anchor HP29d; 2949#### TF3 (implicit function); 2950 ; 2951The supported option is:; 2952 ; 2953| Option | Description |; 2954|----------|-------------------------------------------------------------------|; 2955| ""GL"" | Draw a TF3.|; 2956 ; 2957 ; 2958 ; 2959\anchor HP29e; 2960#### Parametric surfaces; 2961 ; 2962`$ROOTSYS/tutorials/gl/glparametric.C` shows how to create parametric; 2963equations and visualize the surface.; 2964 ; 2965\anchor HP29f; 2966#### Interaction with the plots; 2967 ; 2968All the interactions are implemented via standard methods; 2969`DistancetoPrimitive()` and `ExecuteEvent()`. That's why all the; 2970interactions with the OpenGL plots are possible only when the mouse cursor is; 2971in the plot's area (the plot's area is the part of a the pad occupied by; 2972gl-produced picture). If the mouse cursor is not above gl-picture, the standard; 2973pad interaction is performed.; 2974 ; 2975\anchor HP29g; 2976#### Selectable parts; 2977 ; 2978Different parts of the plot can be selected:; 2979 ; 2980- xoz, yoz, xoy back planes: When such a plane selected, it's highlighted in green; 2981 if the dynamic slicing by this plane is supported, and it's highlighted in red,; 2982 if the dynamic slicing is not supported.; 2983- The plot itself:; 2984 On surfaces, the selected surface is outlined in red. (TF3 and; 2985 ISO are not outlined). On lego plots, the selected bin is; 2986 highlighted. The bin number and content are displayed in pad's; 2987 status bar. In box plots, the box or sphere is highlighted and; 2988 the bin info is displayed in pad's status bar.; 2989 ; 2990 ; 2991\anchor HP29h; 2992#### Rotation and zooming; 2993 ; 2994 ; 2995- Rotation:; 2996 When the plot is selected, it can be rotated by pressing and; 2997 holding the left mouse button and move the cursor.; 2998- Zoom/Unzoom:; 2999 Mouse wheel or 'j', 'J",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:449946,Performance,load,load,449946,"ndle.cxx:666; TCandle::IsViolinScaledBool_t IsViolinScaled() constReturns true if violin plot should be scaled.Definition TCandle.cxx:191; TCandle::IsHorizontalBool_t IsHorizontal() constDefinition TCandle.h:112; TCandle::ParseOptionint ParseOption(char *optin)Parsing of the option-string.Definition TCandle.cxx:244; TCandle::SetOptionvoid SetOption(CandleOption opt)Definition TCandle.h:117; TCandle::SetHistogramvoid SetHistogram(TH1D *proj)Definition TCandle.h:123; TCandle::IsCandleScaledBool_t IsCandleScaled() constReturns true if candle plot should be scaled.Definition TCandle.cxx:183; TCandle::SetCandleWidthvoid SetCandleWidth(const Double_t width)Definition TCandle.h:121; TCandle::SetAxisPositionvoid SetAxisPosition(const Double_t candlePos)Definition TCandle.h:119; TCanvas::SupportAlphastatic Bool_t SupportAlpha()Static function returning ""true"" if transparency is supported.Definition TCanvas.cxx:2476; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::SetNamevoid SetName(const char *name)Definition TCollection.h:206; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TCollection::Paintvoid Paint(Option_t *option="""") overridePaint all objects in this collection.Definition TCollection.cxx:417; TColorThe color creation and management class.Definition TColor.h:21; TColor::SetRGBvirtual void SetRGB(Float_t r, Float_t g, Float_t b)Initialize this color and its ""dark"" and ""bright"" associated colors.Definition TColor.cxx:1850; TColor::RGBtoHLSstatic void RGBtoHLS(Float_t r, Float_t g, Float_t b, Float_t &h, Float_t &l, Float_t &s)Definition TColor.h:82; TColor::GetRGBvirtual void GetRGB(Float_t &r, Float_t &g, Float_t &b) constDefinition TColor.h:54; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color numbe",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:493199,Performance,load,load,493199,"0; TView::SetOutlineToCubevirtual void SetOutlineToCube()=0; TView::GetDistancetoAxisvirtual Int_t GetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t &ratio)=0; TView::GetTnormvirtual Double_t * GetTnorm()=0; TView::ExecuteRotateViewvirtual void ExecuteRotateView(Int_t event, Int_t px, Int_t py)=0; TView::GetOutlinevirtual TSeqCollection * GetOutline()=0; TView::PadRangevirtual void PadRange(Int_t rback)=0; TView::SetRangevirtual void SetRange(const Double_t *min, const Double_t *max)=0; TView::FindNormalvirtual void FindNormal(Double_t x, Double_t y, Double_t z, Double_t &zn)=0; TView::AxisVertexvirtual void AxisVertex(Double_t ang, Double_t *av, Int_t &ix1, Int_t &ix2, Int_t &iy1, Int_t &iy2, Int_t &iz1, Int_t &iz2)=0; TView::SetViewvirtual void SetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t &irep)=0; TVirtualPadEditorAbstract base class used by ROOT graphics editor.Definition TVirtualPadEditor.h:27; TVirtualPadEditor::GetPadEditorstatic TVirtualPadEditor * GetPadEditor(Bool_t load=kTRUE)Returns the pad editor dialog. Static method.Definition TVirtualPadEditor.cxx:74; TVirtualPadEditor::Showvirtual void Show()Definition TVirtualPadEditor.h:49; TVirtualPad::TContextsmall helper class to store/restore gPad context in TPad methodsDefinition TVirtualPad.h:61; TVirtualPad::TContext::GetSavedauto GetSaved() constDefinition TVirtualPad.h:69; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualPad::Closevirtual void Close(Option_t *option="""")=0; TVirtualX::kInvert@ kInvertDefinition TVirtualX.h:49; TVirtualX::kFilled@ kFilledDefinition TVirtualX.h:50; TVirtualX::kHollow@ kHollowDefinition TVirtualX.h:50; bool; double; int; lineTLine * lineDefinition entrylistblock_figure1.C:235; boxvoid box(Int_t pat, Double_t x1, Double_t y1, Double_t x2, Double_t y2)Definition fillpatterns.C:1; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition leg",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:11323,Safety,avoid,avoids,11323," The Y-axis is drawn on the right side of the plot. |; 244| ""MIN0"" | Set minimum value for the Y axis to 0, equivalent to gStyle->SetHistMinimumZero(). |; 245 ; 246\anchor HP01b; 247#### Options supported for 1D histograms; 248 ; 249| Option | Description |; 250|----------|-------------------------------------------------------------------|; 251| "" "" | Default. |; 252| ""AH"" | Draw histogram without axis. ""A"" can be combined with any drawing option. For instance, ""AC"" draws the histogram as a smooth Curve without axis.|; 253| ""]["" | When this option is selected the first and last vertical lines of the histogram are not drawn.|; 254| ""B"" | Bar chart option.|; 255| ""BAR"" | Like option ""B"", but bars can be drawn with a 3D effect.|; 256| ""HBAR"" | Like option ""BAR"", but bars are drawn horizontally.|; 257| ""C"" | Draw a smooth Curve through the histogram bins.|; 258| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 259| ""E1"" | Draw error bars with perpendicular lines at the edges.|; 260| ""E2"" | Draw error bars with rectangles.|; 261| ""E3"" | Draw a fill area through the end points of the vertical error bars.|; 262| ""E4"" | Draw a smoothed filled area through the end points of the error bars.|; 263| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 264| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 265| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 266| ""L"" | Draw a line through the bin contents.|; 267| ""P"" | Draw current marker at each bin except empty bins.|; 268| ""P*"" | Draw a star marker at each bin except empty bins.|; 269| ""P0"" | Draw current marker at each bin including empty bins.|; 270| ""PIE"" | Draw histogram as a Pie Chart.|; 271| ""*H"" | Draw histogram with a * at each bin.|; 272| ""LF2"" | Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws also a fill area if the hist fill color is set b",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:30796,Safety,avoid,avoids,30796,"e->SetOptFit(1011);; 675 ; 676print fit probability, parameter names/values and errors.; 677 ; 6781. When `v = 1` is specified, only the non-fixed parameters are shown.; 6792. When `v = 2` all parameters are shown.; 680 ; 681Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; 682to `gStyle->SetOptFit(111)`; 683 ; 684 ; 685\anchor HP09; 686### The error bars options; 687 ; 688 ; 689| Option | Description |; 690|----------|-------------------------------------------------------------------|; 691| ""E"" | Default. Shows only the error bars, not a marker.|; 692| ""E1"" | Small lines are drawn at the end of the error bars.|; 693| ""E2"" | Error rectangles are drawn.|; 694| ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; 695| ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; 696| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 697| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 698| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 699| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 700 ; 701Begin_Macro(source); 702{; 703 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 704 auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; 705 for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; 706 gStyle->SetEndErrorSize(3);; 707 gStyle->SetErrorX(1.);; 708 he->SetMarkerStyle(20);; 709 he->Draw(""E1"");; 710}; 711End_Macro; 712 ; 713The options ""E3"" and ""E4"" draw an error band through the end points of the; 714vertical error bars. With ""E4"" the error band is smoothed. Because of the; 715smoothing algorithm used some artefacts may appear at the end of the band; 716like in the following example. In such cases ""E3"" should be used instead; 717of ""E4"".; 718 ; 719Begin_Macro(source); 720{; 721 auto ce4 = new TCanvas",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:113533,Safety,avoid,avoid,113533,",-2,2);; 2819 f3->SetClippingBoxOn(0,0,0);; 2820 f3->SetFillColor(30);; 2821 f3->SetLineColor(15);; 2822 f3->Draw(""FBBB"");; 2823}; 2824End_Macro; 2825 ; 2826 ; 2827\anchor HP28; 2828### Associated functions drawing; 2829 ; 2830 ; 2831An associated function is created by `TH1::Fit`. More than on fitted; 2832function can be associated with one histogram (see `TH1::Fit`).; 2833 ; 2834A `TF1` object `f1` can be added to the list of associated; 2835functions of an histogram `h` without calling `TH1::Fit`; 2836simply doing:; 2837 ; 2838 h->GetListOfFunctions()->Add(f1);; 2839 ; 2840or; 2841 ; 2842 h->GetListOfFunctions()->Add(f1,someoption);; 2843 ; 2844To retrieve a function by name from this list, do:; 2845 ; 2846 TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);; 2847 ; 2848or; 2849 ; 2850 TF1 *f1 = h->GetFunction(name);; 2851 ; 2852Associated functions are automatically painted when an histogram is drawn.; 2853To avoid the painting of the associated functions the option `HIST`; 2854should be added to the list of the options used to paint the histogram.; 2855 ; 2856 ; 2857\anchor HP29; 2858### Drawing using OpenGL; 2859 ; 2860 ; 2861The class `TGLHistPainter` allows to paint data set using the OpenGL 3D; 2862graphics library. The plotting options start with `GL` keyword.; 2863In addition, in order to inform canvases that OpenGL should be used to render; 28643D representations, the following option should be set:; 2865 ; 2866 gStyle->SetCanvasPreferGL(true);; 2867 ; 2868 ; 2869\anchor HP29a; 2870#### General information: plot types and supported options; 2871 ; 2872The following types of plots are provided:; 2873 ; 2874For lego plots the supported options are:; 2875 ; 2876| Option | Description |; 2877|----------|-------------------------------------------------------------------|; 2878| ""GLLEGO"" | Draw a lego plot. It works also for `TH2Poly`.|; 2879| ""GLLEGO2""| Bins with color levels.|; 2880| ""GLLEGO3""| Cylindrical bars.|; 2881 ; 2882 ; 2883 ; 2884Lego painte",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:290885,Safety,avoid,avoid,290885,"Style(),fH->GetLineWidth(),0);; 8106 } else {; 8107 for (Int_t id=0;id<=fStack->GetSize();id++) {; 8108 hid = (TH1*)fStack->At((id==0)?id:id-1);; 8109 fLego->SetEdgeAtt(hid->GetLineColor(),hid->GetLineStyle(),hid->GetLineWidth(),id);; 8110 }; 8111 }; 8112 ; 8113 if (Hoption.Lego == 11) {; 8114 nids = 1;; 8115 if (fStack) nids = fStack->GetSize();; 8116 hid = fH;; 8117 for (Int_t id=0;id<=nids;id++) {; 8118 if (id > 0 && fStack) hid = (TH1*)fStack->At(id-1);; 8119 colormain = hid->GetFillColor();; 8120 if (colormain == 1) colormain = 17; //avoid drawing with black; 8121 if (drawShadowsInLego1) colordark = TColor::GetColorDark(colormain);; 8122 else colordark = colormain;; 8123 fLego->SetColorMain(colormain,id);; 8124 fLego->SetColorDark(colordark,id);; 8125 if (id <= 1) fLego->SetColorMain(colormain,-1); // Set Bottom color; 8126 if (id == nids) fLego->SetColorMain(colormain,99); // Set Top color; 8127 }; 8128 }; 8129 ; 8130 // Now ready to draw the lego plot; 8131 Int_t irep = 0;; 8132 ; 8133 TView *view = gPad ? gPad->GetView() : nullptr;; 8134 if (!view) {; 8135 Error(""PaintLego"", ""no TView in current pad"");; 8136 return;; 8137 }; 8138 ; 8139 Double_t thedeg = 90 - gPad->GetTheta();; 8140 Double_t phideg = -90 - gPad->GetPhi();; 8141 Double_t psideg = view->GetPsi();; 8142 view->SetView(phideg, thedeg, psideg, irep);; 8143 ; 8144 fLego->SetLineColor(kBlack); // zgrid color for lego1 & lego2; 8145 fLego->SetFillStyle(fH->GetFillStyle());; 8146 ; 8147 // Set color/style for back box; 8148 fLego->SetFillStyle(gPad->GetFrameFillStyle());; 8149 fLego->SetFillColor(gPad->GetFrameFillColor());; 8150 fLego->TAttFill::Modify();; 8151 ; 8152 Int_t backcolor = gPad->GetFrameFillColor();; 8153 if (Hoption.System != kCARTESIAN) backcolor = 0;; 8154 view->PadRange(backcolor);; 8155 ; 8156 fLego->SetFillStyle(fH->GetFillStyle());; 8157 fLego->SetFillColor(fH->GetFillColor());; 8158 fLego->TAttFill::Modify();; 8159 ; 8160 fLego->DefineGridLevels(fZaxis->GetNdivisions()%100);; 816",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:304900,Safety,avoid,avoid,304900,"x == 0) return;; 8482 dz = zmax - zmin;; 8483 scale = 100/dz;; 8484 if (ncells > 10000) scale /= 5;; 8485 ltest = kTRUE;; 8486 } else {; 8487 dz = zmax - zmin;; 8488 if (dz >= kNMAX || zmax < 1) {; 8489 scale = (kNMAX-1)/dz;; 8490 if (ncells > 10000) scale /= 5;; 8491 ltest = kTRUE;; 8492 }; 8493 }; 8494 if (fH->GetMinimumStored() == -1111) {; 8495 Double_t yMARGIN = gStyle->GetHistTopMargin();; 8496 if (Hoption.MinimumZero) {; 8497 if (zmin >= 0) zmin = 0;; 8498 else zmin -= yMARGIN*(zmax-zmin);; 8499 } else {; 8500 Double_t dzmin = yMARGIN*(zmax-zmin);; 8501 if (zmin >= 0 && (zmin-dzmin <= 0)) zmin = 0;; 8502 else zmin -= dzmin;; 8503 }; 8504 }; 8505 ; 8506 TString opt = option;; 8507 opt.ToLower();; 8508 if (opt.Contains(""scat="")) {; 8509 char optscat[100];; 8510 strlcpy(optscat,opt.Data(),100);; 8511 char *oscat = strstr(optscat,""scat="");; 8512 char *blank = strstr(oscat,"" ""); if (blank) *blank = 0;; 8513 sscanf(oscat+5,""%lg"",&scale);; 8514 }; 8515 // use an independent instance of a random generator; 8516 // instead of gRandom to avoid conflicts and; 8517 // to get same random numbers when drawing the same histogram; 8518 TRandom2 random;; 8519 marker=0;; 8520 for (Int_t j=Hparam.yfirst; j<=Hparam.ylast;j++) {; 8521 yk = fYaxis->GetBinLowEdge(j);; 8522 ystep = fYaxis->GetBinWidth(j);; 8523 for (Int_t i=Hparam.xfirst; i<=Hparam.xlast;i++) {; 8524 Int_t bin = j*(fXaxis->GetNbins()+2) + i;; 8525 xk = fXaxis->GetBinLowEdge(i);; 8526 xstep = fXaxis->GetBinWidth(i);; 8527 if (!IsInside(xk+0.5*xstep,yk+0.5*ystep)) continue;; 8528 z = fH->GetBinContent(bin);; 8529 if (z < zmin) z = zmin;; 8530 if (z > zmax) z = zmax;; 8531 if (Hoption.Logz) {; 8532 if (z > 0) z = TMath::Log10(z) - zmin;; 8533 } else {; 8534 z -= zmin;; 8535 }; 8536 if (z <= 0) continue;; 8537 k = Int_t(z*scale);; 8538 if (ltest) k++;; 8539 if (k > 0) {; 8540 for (Int_t loop=0; loop<k; loop++) {; 8541 if (k+marker >= kNMAX) {; 8542 gPad->PaintPolyMarker(marker, fXbuf.data(), fYbuf.data());; 8543 marker=0",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:356849,Safety,avoid,avoid,356849,"/////////////////////////////////////////////////; 9883/// [Control function to draw a TH2Poly as a scatter plot.](\ref HP20a); 9884 ; 9885void THistPainter::PaintTH2PolyScatterPlot(Option_t *); 9886{; 9887 ; 9888 //Do not highlight the histogram, if its part was selected.; 9889 if (gPad->PadInHighlightMode() && gPad->GetSelected() != fH); 9890 return;; 9891 ; 9892 Int_t k, loop, marker=0;; 9893 Double_t z, xk,xstep, yk, ystep, xp, yp;; 9894 Double_t scale = 1;; 9895 Double_t zmin = fH->GetMinimum();; 9896 Double_t zmax = fH->GetMaximum();; 9897 if (Hoption.Logz) {; 9898 if (zmax > 0) {; 9899 if (zmin <= 0) zmin = TMath::Min((Double_t)1, (Double_t)0.001*zmax);; 9900 zmin = TMath::Log10(zmin);; 9901 zmax = TMath::Log10(zmax);; 9902 } else {; 9903 return;; 9904 }; 9905 }; 9906 Double_t dz = zmax - zmin;; 9907 scale = (kNMAX-1)/dz;; 9908 ; 9909 ; 9910 // use an independent instance of a random generator; 9911 // instead of gRandom to avoid conflicts and; 9912 // to get same random numbers when drawing the same histogram; 9913 TRandom2 random;; 9914 ; 9915 TH2PolyBin *b;; 9916 ; 9917 TIter next(((TH2Poly*)fH)->GetBins());; 9918 TObject *obj, *poly;; 9919 ; 9920 Double_t maxarea = 0, a;; 9921 while ((obj=next())) {; 9922 b = (TH2PolyBin*)obj;; 9923 a = b->GetArea();; 9924 if (a>maxarea) maxarea = a;; 9925 }; 9926 ; 9927 next.Reset();; 9928 ; 9929 while ((obj=next())) {; 9930 b = (TH2PolyBin*)obj;; 9931 poly = b->GetPolygon();; 9932 z = b->GetContent();; 9933 if (z < zmin) z = zmin;; 9934 if (z > zmax) z = zmax;; 9935 if (Hoption.Logz) {; 9936 if (z > 0) z = TMath::Log10(z) - zmin;; 9937 } else {; 9938 z -= zmin;; 9939 }; 9940 k = Int_t((z*scale)*(b->GetArea()/maxarea));; 9941 xk = b->GetXMin();; 9942 yk = b->GetYMin();; 9943 xstep = b->GetXMax()-xk;; 9944 ystep = b->GetYMax()-yk;; 9945 ; 9946 // Paint the TGraph bins.; 9947 if (poly->IsA() == TGraph::Class()) {; 9948 TGraph *g = (TGraph*)poly;; 9949 if (k <= 0 || z <= 0) continue;; 9950 loop = 0;; 9951 while (loop<k) {; ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:27649,Security,access,accessed,27649,"d; 586 I : integral of bins with option ""width"" printed; 587 o : number of overflows printed; 588 u : number of underflows printed; 589 r : standard deviation printed; 590 R : standard deviation and standard deviation error printed; 591 m : mean value printed; 592 M : mean value mean error values printed; 593 e : number of entries printed; 594 n : name of histogram is printed; 595 ; 596For example, to print only name of histogram and number of entries do:; 597 ; 598 gStyle->SetOptStat(""ne"");; 599 ; 600To print only the name of the histogram do:; 601 ; 602 gStyle->SetOptStat(""n"");; 603 ; 604The default value is:; 605 ; 606 gStyle->SetOptStat(""nemr"");; 607 ; 608When a histogram is painted, a `TPaveStats` object is created and added; 609to the list of functions of the histogram. If a `TPaveStats` object; 610already exists in the histogram list of functions, the existing object is just; 611updated with the current histogram parameters.; 612 ; 613Once a histogram is painted, the statistics box can be accessed using; 614`h->FindObject(""stats"")`. In the command line it is enough to do:; 615 ; 616 Root > h->Draw(); 617 Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); 618 ; 619because after `h->Draw()` the histogram is automatically painted. But; 620in a script file the painting should be forced using `gPad->Update()`; 621in order to make sure the statistics box is created:; 622 ; 623 h->Draw();; 624 gPad->Update();; 625 TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");; 626 ; 627Without `gPad->Update()` the line `h->FindObject(""stats"")` returns a null pointer.; 628 ; 629When a histogram is drawn with the option `SAME`, the statistics box; 630is not drawn. To force the statistics box drawing with the option; 631`SAME`, the option `SAMES` must be used.; 632If the new statistics box hides the previous statistics box, one can change; 633its position with these lines (`h` being the pointer to the histogram):; 634 ; 635 Root > TPaveStats *st = (TPaveStats*)h->Find",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:51544,Security,access,accessed,51544,"es); 1241 - `m = 3`; median is drawn as a circle; 1242 ; 1243 - `M = 0`; no mean drawn; 1244 - `M = 1`; mean is drawn as a dashed line; 1245 - `M = 3`; mean is drawn as a circle; 1246 ; 1247 - `w = 0`; no whisker drawn; 1248 - `w = 1`; whisker is drawn to end of distribution.; 1249 - `w = 2`; whisker is drawn to max 1.5*iqr; 1250 ; 1251 - `a = 0`; no anchor drawn; 1252 - `a = 1`; the anchors are drawn; 1253 ; 1254 - `p = 0`; no points drawn; 1255 - `p = 1`; only outliers are drawn; 1256 - `p = 2`; all datapoints are drawn; 1257 - `p = 3`: all datapoints are drawn scattered; 1258 ; 1259 - `h = 0`; no histogram is drawn; 1260 - `h = 1`; histogram at the left or bottom side is drawn; 1261 - `h = 2`; histogram at the right or top side is drawn; 1262 - `h = 3`; histogram at left and right or top and bottom (violin-style) is drawn; 1263 ; 1264 - `z = 0`; no zero indicator line is drawn; 1265 - `z = 1`; zero indicator line is drawn.; 1266 ; 1267As one can see all individual options for both candle and violin plots can be accessed by this; 1268mechanism. In deed the keywords CANDLE(<option-string>) and VIOLIN(<option-string>) have the same; 1269meaning. So you can parametrise an option-string for a candle plot and use the keywords VIOLIN and; 1270vice versa, if you wish.; 1271 ; 1272Using a logarithmic x- or y-axis is possible for candle and violin charts.; 1273 ; 1274\since **ROOT version 6.11/01**; 1275 ; 1276a logarithmic z-axis is possible, too but will only affect violin charts of course.; 1277 ; 1278\anchor HP140a; 1279#### The CANDLE option; 1280 ; 1281<a href=""http://en.wikipedia.org/wiki/Box_plot"">A Candle plot</a> (also known as; 1282a ""box plot"" or ""whisker plot"") was invented in 1977 by John Tukey. It is a convenient; 1283way to describe graphically a data distribution (D) with only five numbers:; 1284 ; 1285 1. The minimum value of the distribution D (bottom or left whisker).; 1286 2. The lower quartile (Q1): 25% of the data points in D are less than Q1 (bottom ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:67457,Security,hash,hashed,67457,"bin with the maximum content of each individual violin is; 1558set to a constant value using SetBarWidth(). The static function will affect all violin-charts; 1559in the running program. Default is true. Scaling between multiple violin-charts; 1560(using ""same"" or THStack) is not supported, yet.; 1561 ; 1562##### The zero indicator line; 1563Typical for violin charts is a line in the background over the whole histogram indicating; 1564the bins with zero entries. The zero indicator line can be activated with z=1. The line color; 1565will always be the same as the fill-color of the histogram.; 1566 ; 1567##### The Mean; 1568The Mean is illustrated with the same mechanism as used for candle plots. Usually a circle is used.; 1569 ; 1570##### Whiskers; 1571The whiskers are illustrated by the same mechanism as used for candle plots. There is only one; 1572difference. When using the simple whisker definition (w=1) and the zero indicator line (z=1), then; 1573the whiskers will be forced to be solid (usually hashed); 1574 ; 1575##### Points; 1576The points are illustrated by the same mechanism as used for candle plots. E.g. VIOLIN2 uses; 1577better whisker definition (w=2) and outliers (p=1).; 1578 ; 1579##### Other options; 1580It is possible to combine all options of candle or violin plots with each other. E.g. a violin plot; 1581including a box-plot.; 1582 ; 1583#### How to use the violin-plots drawing option; 1584 ; 1585There are two predefined violin-plot representations:; 1586 - ""VIOLINX1"": Standard violin (histogram, mean, whisker over full distribution,; 1587 zero indicator line); 1588 - ""VIOLINX2"": Line VIOLINX1 both with better whisker definition + outliers.; 1589 ; 1590A solid fill style is recommended for this plot (as opposed to a hollow or; 1591hashed style).; 1592 ; 1593Begin_Macro(source); 1594{; 1595 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 1596 Int_t nx(6), ny(40);; 1597 double xmin(0.0), xmax(+6.0), ymin(0.0), ymax(+4.0);; 1598 auto hviolin = new TH2F(""h",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:77796,Security,access,accessible,77796,"for (Int_t i = 0; i < 25000; i++) {; 1835 gRandom->Rannor(px,py);; 1836 hcont4->Fill(px-1,5*py);; 1837 hcont4->Fill(2+0.5*px,2*py-10.,0.1);; 1838 }; 1839 hcont4->Draw(""CONT4Z"");; 1840}; 1841End_Macro; 1842 ; 1843The default number of contour levels is 20 equidistant levels and can be changed; 1844with `TH1::SetContour()` or `TStyle::SetNumberContours()`.; 1845 ; 1846\anchor HP16a; 1847#### The LIST option; 1848 ; 1849When option `LIST` is specified together with option; 1850`CONT`, the points used to draw the contours are saved in; 1851`TGraph` objects:; 1852 ; 1853 h->Draw(""CONT LIST"");; 1854 gPad->Update();; 1855 ; 1856The contour are saved in `TGraph` objects once the pad is painted.; 1857Therefore to use this functionality in a macro, `gPad->Update()`; 1858should be performed after the histogram drawing. Once the list is; 1859built, the contours are accessible in the following way:; 1860 ; 1861 TObjArray *contours = (TObjArray*)gROOT->GetListOfSpecials()->FindObject(""contours"");; 1862 Int_t ncontours = contours->GetSize();; 1863 TList *list = (TList*)contours->At(i);; 1864 ; 1865Where `i` is a contour number, and list contains a list of; 1866`TGraph` objects.; 1867For one given contour, more than one disjoint polyline may be generated.; 1868The number of TGraphs per contour is given by:; 1869 ; 1870 list->GetSize();; 1871 ; 1872To access the first graph in the list one should do:; 1873 ; 1874 TGraph *gr1 = (TGraph*)list->First();; 1875 ; 1876 ; 1877The following example (ContourList.C) shows how to use this functionality.; 1878 ; 1879Begin_Macro(source); 1880../../../tutorials/hist/ContourList.C; 1881End_Macro; 1882 ; 1883\anchor HP16b; 1884#### The AITOFF, MERCATOR, SINUSOIDAL and PARABOLIC options; 1885 ; 1886The following options select the `CONT4` option and are useful for; 1887sky maps or exposure maps (earth.C).; 1888 ; 1889| Option | Description |; 1890|--------------|---------------------------------------------------------------|; 1891| ""AITOFF"" | Draw ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:78287,Security,access,access,78287,"847#### The LIST option; 1848 ; 1849When option `LIST` is specified together with option; 1850`CONT`, the points used to draw the contours are saved in; 1851`TGraph` objects:; 1852 ; 1853 h->Draw(""CONT LIST"");; 1854 gPad->Update();; 1855 ; 1856The contour are saved in `TGraph` objects once the pad is painted.; 1857Therefore to use this functionality in a macro, `gPad->Update()`; 1858should be performed after the histogram drawing. Once the list is; 1859built, the contours are accessible in the following way:; 1860 ; 1861 TObjArray *contours = (TObjArray*)gROOT->GetListOfSpecials()->FindObject(""contours"");; 1862 Int_t ncontours = contours->GetSize();; 1863 TList *list = (TList*)contours->At(i);; 1864 ; 1865Where `i` is a contour number, and list contains a list of; 1866`TGraph` objects.; 1867For one given contour, more than one disjoint polyline may be generated.; 1868The number of TGraphs per contour is given by:; 1869 ; 1870 list->GetSize();; 1871 ; 1872To access the first graph in the list one should do:; 1873 ; 1874 TGraph *gr1 = (TGraph*)list->First();; 1875 ; 1876 ; 1877The following example (ContourList.C) shows how to use this functionality.; 1878 ; 1879Begin_Macro(source); 1880../../../tutorials/hist/ContourList.C; 1881End_Macro; 1882 ; 1883\anchor HP16b; 1884#### The AITOFF, MERCATOR, SINUSOIDAL and PARABOLIC options; 1885 ; 1886The following options select the `CONT4` option and are useful for; 1887sky maps or exposure maps (earth.C).; 1888 ; 1889| Option | Description |; 1890|--------------|---------------------------------------------------------------|; 1891| ""AITOFF"" | Draw a contour via an AITOFF projection.|; 1892| ""MERCATOR"" | Draw a contour via an Mercator projection.|; 1893| ""SINUSOIDAL"" | Draw a contour via an Sinusoidal projection.|; 1894| ""PARABOLIC"" | Draw a contour via an Parabolic projection.|; 1895 ; 1896Begin_Macro(source); 1897../../../tutorials/graphics/earth.C; 1898End_Macro; 1899 ; 1900 ; 1901\anchor HP17; 1902### The LEGO options; 1903",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:102289,Security,access,access,102289,"ng the color palette; 2498 ; 2499 ; 2500To change the color palette `TStyle::SetPalette` should be used, eg:; 2501 ; 2502 gStyle->SetPalette(ncolors,colors);; 2503 ; 2504For example the option `COL` draws a 2D histogram with cells; 2505represented by a box filled with a color index which is a function; 2506of the cell content.; 2507If the cell content is N, the color index used will be the color number; 2508in `colors[N]`, etc. If the maximum cell content is greater than; 2509`ncolors`, all cell contents are scaled to `ncolors`.; 2510 ; 2511If ` ncolors <= 0`, a default palette (see below) of 50 colors is; 2512defined. This palette is recommended for pads, labels ...; 2513 ; 2514`if ncolors == 1 && colors == 0`, then a Pretty Palette with a; 2515Spectrum Violet->Red is created with 50 colors. That's the default rain bow; 2516palette.; 2517 ; 2518Other pre-defined palettes with 255 colors are available when `colors == 0`.; 2519The following value of `ncolors` give access to:; 2520 ; 2521 ; 2522 if ncolors = 51 and colors=0, a Deep Sea palette is used.; 2523 if ncolors = 52 and colors=0, a Grey Scale palette is used.; 2524 if ncolors = 53 and colors=0, a Dark Body Radiator palette is used.; 2525 if ncolors = 54 and colors=0, a two-color hue palette palette is used.(dark blue through neutral gray to bright yellow); 2526 if ncolors = 55 and colors=0, a Rain Bow palette is used.; 2527 if ncolors = 56 and colors=0, an inverted Dark Body Radiator palette is used.; 2528 ; 2529 ; 2530If `ncolors > 0 && colors == 0`, the default palette is used with a maximum of ncolors.; 2531 ; 2532The default palette defines:; 2533 ; 2534- index 0 to 9 : shades of grey; 2535- index 10 to 19 : shades of brown; 2536- index 20 to 29 : shades of blue; 2537- index 30 to 39 : shades of red; 2538- index 40 to 49 : basic colors; 2539 ; 2540The color numbers specified in the palette can be viewed by selecting; 2541the item `colors` in the `VIEW` menu of the canvas tool bar.; 2542The red, green, and ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:51818,Testability,log,logarithmic,51818," 1250 ; 1251 - `a = 0`; no anchor drawn; 1252 - `a = 1`; the anchors are drawn; 1253 ; 1254 - `p = 0`; no points drawn; 1255 - `p = 1`; only outliers are drawn; 1256 - `p = 2`; all datapoints are drawn; 1257 - `p = 3`: all datapoints are drawn scattered; 1258 ; 1259 - `h = 0`; no histogram is drawn; 1260 - `h = 1`; histogram at the left or bottom side is drawn; 1261 - `h = 2`; histogram at the right or top side is drawn; 1262 - `h = 3`; histogram at left and right or top and bottom (violin-style) is drawn; 1263 ; 1264 - `z = 0`; no zero indicator line is drawn; 1265 - `z = 1`; zero indicator line is drawn.; 1266 ; 1267As one can see all individual options for both candle and violin plots can be accessed by this; 1268mechanism. In deed the keywords CANDLE(<option-string>) and VIOLIN(<option-string>) have the same; 1269meaning. So you can parametrise an option-string for a candle plot and use the keywords VIOLIN and; 1270vice versa, if you wish.; 1271 ; 1272Using a logarithmic x- or y-axis is possible for candle and violin charts.; 1273 ; 1274\since **ROOT version 6.11/01**; 1275 ; 1276a logarithmic z-axis is possible, too but will only affect violin charts of course.; 1277 ; 1278\anchor HP140a; 1279#### The CANDLE option; 1280 ; 1281<a href=""http://en.wikipedia.org/wiki/Box_plot"">A Candle plot</a> (also known as; 1282a ""box plot"" or ""whisker plot"") was invented in 1977 by John Tukey. It is a convenient; 1283way to describe graphically a data distribution (D) with only five numbers:; 1284 ; 1285 1. The minimum value of the distribution D (bottom or left whisker).; 1286 2. The lower quartile (Q1): 25% of the data points in D are less than Q1 (bottom of the box).; 1287 3. The median (M): 50% of the data points in D are less than M.; 1288 4. The upper quartile (Q3): 75% of the data points in D are less than Q3 (top of the box).; 1289 5. The maximum value of the distribution D (top or right whisker).; 1290 ; 1291In this implementation a TH2 is considered as a collection of",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:51943,Testability,log,logarithmic,51943,"1`; only outliers are drawn; 1256 - `p = 2`; all datapoints are drawn; 1257 - `p = 3`: all datapoints are drawn scattered; 1258 ; 1259 - `h = 0`; no histogram is drawn; 1260 - `h = 1`; histogram at the left or bottom side is drawn; 1261 - `h = 2`; histogram at the right or top side is drawn; 1262 - `h = 3`; histogram at left and right or top and bottom (violin-style) is drawn; 1263 ; 1264 - `z = 0`; no zero indicator line is drawn; 1265 - `z = 1`; zero indicator line is drawn.; 1266 ; 1267As one can see all individual options for both candle and violin plots can be accessed by this; 1268mechanism. In deed the keywords CANDLE(<option-string>) and VIOLIN(<option-string>) have the same; 1269meaning. So you can parametrise an option-string for a candle plot and use the keywords VIOLIN and; 1270vice versa, if you wish.; 1271 ; 1272Using a logarithmic x- or y-axis is possible for candle and violin charts.; 1273 ; 1274\since **ROOT version 6.11/01**; 1275 ; 1276a logarithmic z-axis is possible, too but will only affect violin charts of course.; 1277 ; 1278\anchor HP140a; 1279#### The CANDLE option; 1280 ; 1281<a href=""http://en.wikipedia.org/wiki/Box_plot"">A Candle plot</a> (also known as; 1282a ""box plot"" or ""whisker plot"") was invented in 1977 by John Tukey. It is a convenient; 1283way to describe graphically a data distribution (D) with only five numbers:; 1284 ; 1285 1. The minimum value of the distribution D (bottom or left whisker).; 1286 2. The lower quartile (Q1): 25% of the data points in D are less than Q1 (bottom of the box).; 1287 3. The median (M): 50% of the data points in D are less than M.; 1288 4. The upper quartile (Q3): 75% of the data points in D are less than Q3 (top of the box).; 1289 5. The maximum value of the distribution D (top or right whisker).; 1290 ; 1291In this implementation a TH2 is considered as a collection of TH1 along; 1292X (option `CANDLE` or `CANDLEX`) or Y (option `CANDLEY`).; 1293Each TH1 is represented as one candle.; 1294 ; 1295Be",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:103517,Testability,log,log,103517,"diator palette is used.; 2525 if ncolors = 54 and colors=0, a two-color hue palette palette is used.(dark blue through neutral gray to bright yellow); 2526 if ncolors = 55 and colors=0, a Rain Bow palette is used.; 2527 if ncolors = 56 and colors=0, an inverted Dark Body Radiator palette is used.; 2528 ; 2529 ; 2530If `ncolors > 0 && colors == 0`, the default palette is used with a maximum of ncolors.; 2531 ; 2532The default palette defines:; 2533 ; 2534- index 0 to 9 : shades of grey; 2535- index 10 to 19 : shades of brown; 2536- index 20 to 29 : shades of blue; 2537- index 30 to 39 : shades of red; 2538- index 40 to 49 : basic colors; 2539 ; 2540The color numbers specified in the palette can be viewed by selecting; 2541the item `colors` in the `VIEW` menu of the canvas tool bar.; 2542The red, green, and blue components of a color can be changed thanks to; 2543`TColor::SetRGB()`.; 2544 ; 2545\since **ROOT version 6.19/01**; 2546 ; 2547As default labels and ticks are drawn by `TGAxis` at equidistant (lin or log); 2548points as controlled by SetNdivisions.; 2549If option ""CJUST"" is given labels and ticks are justified at the; 2550color boundaries defined by the contour levels.; 2551For more details see `TPaletteAxis`; 2552 ; 2553\anchor HP24; 2554### Drawing a sub-range of a 2D histogram; the [cutg] option; 2555 ; 2556 ; 2557Using a `TCutG` object, it is possible to draw a sub-range of a 2D; 2558histogram. One must create a graphical cut (mouse or C++) and specify the name; 2559of the cut between `[]` in the `Draw()` option.; 2560For example (fit2a.C), with a `TCutG` named `cutg`, one can call:; 2561 ; 2562 myhist->Draw(""surf1 [cutg]"");; 2563 ; 2564To invert the cut, it is enough to put a `-` in front of its name:; 2565 ; 2566 myhist->Draw(""surf1 [-cutg]"");; 2567 ; 2568It is possible to apply several cuts (`,` means logical AND):; 2569 ; 2570 myhist->Draw(""surf1 [cutg1,cutg2]"");; 2571 ; 2572Begin_Macro(source); 2573../../../tutorials/fit/fit2a.C; 2574End_Macro; 2575 ;",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:104341,Testability,log,logical,104341,"` menu of the canvas tool bar.; 2542The red, green, and blue components of a color can be changed thanks to; 2543`TColor::SetRGB()`.; 2544 ; 2545\since **ROOT version 6.19/01**; 2546 ; 2547As default labels and ticks are drawn by `TGAxis` at equidistant (lin or log); 2548points as controlled by SetNdivisions.; 2549If option ""CJUST"" is given labels and ticks are justified at the; 2550color boundaries defined by the contour levels.; 2551For more details see `TPaletteAxis`; 2552 ; 2553\anchor HP24; 2554### Drawing a sub-range of a 2D histogram; the [cutg] option; 2555 ; 2556 ; 2557Using a `TCutG` object, it is possible to draw a sub-range of a 2D; 2558histogram. One must create a graphical cut (mouse or C++) and specify the name; 2559of the cut between `[]` in the `Draw()` option.; 2560For example (fit2a.C), with a `TCutG` named `cutg`, one can call:; 2561 ; 2562 myhist->Draw(""surf1 [cutg]"");; 2563 ; 2564To invert the cut, it is enough to put a `-` in front of its name:; 2565 ; 2566 myhist->Draw(""surf1 [-cutg]"");; 2567 ; 2568It is possible to apply several cuts (`,` means logical AND):; 2569 ; 2570 myhist->Draw(""surf1 [cutg1,cutg2]"");; 2571 ; 2572Begin_Macro(source); 2573../../../tutorials/fit/fit2a.C; 2574End_Macro; 2575 ; 2576\anchor HP25; 2577### Drawing options for 3D histograms; 2578 ; 2579 ; 2580| Option | Description |; 2581|----------|-------------------------------------------------------------------|; 2582| ""SCAT"" | Draw a scatter plot (legacy draw option).|; 2583| ""ISO"" | Draw a Gouraud shaded 3d iso surface through a 3d histogram. It paints one surface at the value computed as follow: `SumOfWeights/(NbinsX*NbinsY*NbinsZ)`|; 2584| ""BOX"" | Draw a for each cell with volume proportional to the content's absolute value. An hidden line removal algorithm is used|; 2585| ""BOX1"" | Same as BOX but an hidden surface removal algorithm is used|; 2586| ""BOX2"" | Same as ""COL"". The boxes' colors are picked in the current palette according to the bins' contents (default)|; 2",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:114623,Testability,log,logarithmic,114623,"ld be added to the list of the options used to paint the histogram.; 2855 ; 2856 ; 2857\anchor HP29; 2858### Drawing using OpenGL; 2859 ; 2860 ; 2861The class `TGLHistPainter` allows to paint data set using the OpenGL 3D; 2862graphics library. The plotting options start with `GL` keyword.; 2863In addition, in order to inform canvases that OpenGL should be used to render; 28643D representations, the following option should be set:; 2865 ; 2866 gStyle->SetCanvasPreferGL(true);; 2867 ; 2868 ; 2869\anchor HP29a; 2870#### General information: plot types and supported options; 2871 ; 2872The following types of plots are provided:; 2873 ; 2874For lego plots the supported options are:; 2875 ; 2876| Option | Description |; 2877|----------|-------------------------------------------------------------------|; 2878| ""GLLEGO"" | Draw a lego plot. It works also for `TH2Poly`.|; 2879| ""GLLEGO2""| Bins with color levels.|; 2880| ""GLLEGO3""| Cylindrical bars.|; 2881 ; 2882 ; 2883 ; 2884Lego painter in cartesian supports logarithmic scales for X, Y, Z.; 2885In polar only Z axis can be logarithmic, in cylindrical only Y.; 2886 ; 2887For surface plots (`TF2` and `TH2`) the supported options are:; 2888 ; 2889| Option | Description |; 2890|-----------|------------------------------------------------------------------|; 2891| ""GLSURF"" | Draw a surface.|; 2892| ""GLSURF1"" | Surface with color levels|; 2893| ""GLSURF2"" | The same as ""GLSURF1"" but without polygon outlines.|; 2894| ""GLSURF3"" | Color level projection on top of plot (works only in cartesian coordinate system).|; 2895| ""GLSURF4"" | Same as ""GLSURF"" but without polygon outlines.|; 2896 ; 2897 ; 2898 ; 2899The surface painting in cartesian coordinates supports logarithmic scales along; 2900X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic,; 2901in cylindrical coordinates only the Y axis.; 2902 ; 2903Additional options to SURF and LEGO - Coordinate systems:; 2904 ; 2905| Option | Description |; 2906|----------|-------",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:114688,Testability,log,logarithmic,114688,"; 2857\anchor HP29; 2858### Drawing using OpenGL; 2859 ; 2860 ; 2861The class `TGLHistPainter` allows to paint data set using the OpenGL 3D; 2862graphics library. The plotting options start with `GL` keyword.; 2863In addition, in order to inform canvases that OpenGL should be used to render; 28643D representations, the following option should be set:; 2865 ; 2866 gStyle->SetCanvasPreferGL(true);; 2867 ; 2868 ; 2869\anchor HP29a; 2870#### General information: plot types and supported options; 2871 ; 2872The following types of plots are provided:; 2873 ; 2874For lego plots the supported options are:; 2875 ; 2876| Option | Description |; 2877|----------|-------------------------------------------------------------------|; 2878| ""GLLEGO"" | Draw a lego plot. It works also for `TH2Poly`.|; 2879| ""GLLEGO2""| Bins with color levels.|; 2880| ""GLLEGO3""| Cylindrical bars.|; 2881 ; 2882 ; 2883 ; 2884Lego painter in cartesian supports logarithmic scales for X, Y, Z.; 2885In polar only Z axis can be logarithmic, in cylindrical only Y.; 2886 ; 2887For surface plots (`TF2` and `TH2`) the supported options are:; 2888 ; 2889| Option | Description |; 2890|-----------|------------------------------------------------------------------|; 2891| ""GLSURF"" | Draw a surface.|; 2892| ""GLSURF1"" | Surface with color levels|; 2893| ""GLSURF2"" | The same as ""GLSURF1"" but without polygon outlines.|; 2894| ""GLSURF3"" | Color level projection on top of plot (works only in cartesian coordinate system).|; 2895| ""GLSURF4"" | Same as ""GLSURF"" but without polygon outlines.|; 2896 ; 2897 ; 2898 ; 2899The surface painting in cartesian coordinates supports logarithmic scales along; 2900X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic,; 2901in cylindrical coordinates only the Y axis.; 2902 ; 2903Additional options to SURF and LEGO - Coordinate systems:; 2904 ; 2905| Option | Description |; 2906|----------|-------------------------------------------------------------------|; 2907| "" "" | Default",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:115326,Testability,log,logarithmic,115326," Option | Description |; 2877|----------|-------------------------------------------------------------------|; 2878| ""GLLEGO"" | Draw a lego plot. It works also for `TH2Poly`.|; 2879| ""GLLEGO2""| Bins with color levels.|; 2880| ""GLLEGO3""| Cylindrical bars.|; 2881 ; 2882 ; 2883 ; 2884Lego painter in cartesian supports logarithmic scales for X, Y, Z.; 2885In polar only Z axis can be logarithmic, in cylindrical only Y.; 2886 ; 2887For surface plots (`TF2` and `TH2`) the supported options are:; 2888 ; 2889| Option | Description |; 2890|-----------|------------------------------------------------------------------|; 2891| ""GLSURF"" | Draw a surface.|; 2892| ""GLSURF1"" | Surface with color levels|; 2893| ""GLSURF2"" | The same as ""GLSURF1"" but without polygon outlines.|; 2894| ""GLSURF3"" | Color level projection on top of plot (works only in cartesian coordinate system).|; 2895| ""GLSURF4"" | Same as ""GLSURF"" but without polygon outlines.|; 2896 ; 2897 ; 2898 ; 2899The surface painting in cartesian coordinates supports logarithmic scales along; 2900X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic,; 2901in cylindrical coordinates only the Y axis.; 2902 ; 2903Additional options to SURF and LEGO - Coordinate systems:; 2904 ; 2905| Option | Description |; 2906|----------|-------------------------------------------------------------------|; 2907| "" "" | Default, cartesian coordinates system.|; 2908| ""POL"" | Polar coordinates system.|; 2909| ""CYL"" | Cylindrical coordinates system.|; 2910| ""SPH"" | Spherical coordinates system.|; 2911 ; 2912 ; 2913 ; 2914\anchor HP290; 2915#### TH3 as color boxes; 2916 ; 2917The supported option is:; 2918 ; 2919| Option | Description |; 2920|----------|-------------------------------------------------------------------|; 2921| ""GLCOL"" | H3 is drawn using semi-transparent colored boxes. See `$ROOTSYS/tutorials/gl/glvox1.C`.|; 2922 ; 2923 ; 2924 ; 2925\anchor HP29b; 2926#### TH3 as boxes (spheres); 2927 ; 2928The supported options are:; ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:115414,Testability,log,logarithmic,115414," ""GLLEGO"" | Draw a lego plot. It works also for `TH2Poly`.|; 2879| ""GLLEGO2""| Bins with color levels.|; 2880| ""GLLEGO3""| Cylindrical bars.|; 2881 ; 2882 ; 2883 ; 2884Lego painter in cartesian supports logarithmic scales for X, Y, Z.; 2885In polar only Z axis can be logarithmic, in cylindrical only Y.; 2886 ; 2887For surface plots (`TF2` and `TH2`) the supported options are:; 2888 ; 2889| Option | Description |; 2890|-----------|------------------------------------------------------------------|; 2891| ""GLSURF"" | Draw a surface.|; 2892| ""GLSURF1"" | Surface with color levels|; 2893| ""GLSURF2"" | The same as ""GLSURF1"" but without polygon outlines.|; 2894| ""GLSURF3"" | Color level projection on top of plot (works only in cartesian coordinate system).|; 2895| ""GLSURF4"" | Same as ""GLSURF"" but without polygon outlines.|; 2896 ; 2897 ; 2898 ; 2899The surface painting in cartesian coordinates supports logarithmic scales along; 2900X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic,; 2901in cylindrical coordinates only the Y axis.; 2902 ; 2903Additional options to SURF and LEGO - Coordinate systems:; 2904 ; 2905| Option | Description |; 2906|----------|-------------------------------------------------------------------|; 2907| "" "" | Default, cartesian coordinates system.|; 2908| ""POL"" | Polar coordinates system.|; 2909| ""CYL"" | Cylindrical coordinates system.|; 2910| ""SPH"" | Spherical coordinates system.|; 2911 ; 2912 ; 2913 ; 2914\anchor HP290; 2915#### TH3 as color boxes; 2916 ; 2917The supported option is:; 2918 ; 2919| Option | Description |; 2920|----------|-------------------------------------------------------------------|; 2921| ""GLCOL"" | H3 is drawn using semi-transparent colored boxes. See `$ROOTSYS/tutorials/gl/glvox1.C`.|; 2922 ; 2923 ; 2924 ; 2925\anchor HP29b; 2926#### TH3 as boxes (spheres); 2927 ; 2928The supported options are:; 2929 ; 2930| Option | Description |; 2931|----------|---------------------------------------------------------------",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:152069,Testability,test,testing,152069," paint highlight bin as box (recursive calls PaintHighlightBin); 3898 gPad->Modified(kTRUE);; 3899 gPad->Update();; 3900 ; 3901 // emit Highlighted() signal; 3902 if (gPad->GetCanvas()) gPad->GetCanvas()->Highlighted(gPad, fH, fXHighlightBin, fYHighlightBin);; 3903}; 3904 ; 3905////////////////////////////////////////////////////////////////////////////////; 3906/// Paint highlight bin as TBox object; 3907 ; 3908void THistPainter::PaintHighlightBin(Option_t * /*option*/); 3909{; 3910 // call from PaintTitle; 3911 ; 3912 if (!fH->IsHighlight()) return;; 3913 ; 3914 Double_t uxmin = gPad->GetUxmin();; 3915 Double_t uxmax = gPad->GetUxmax();; 3916 Double_t uymin = gPad->GetUymin();; 3917 Double_t uymax = gPad->GetUymax();; 3918 if (gPad->GetLogx()) {; 3919 uxmin = TMath::Power(10.0, uxmin);; 3920 uxmax = TMath::Power(10.0, uxmax);; 3921 }; 3922 if (gPad->GetLogy()) {; 3923 uymin = TMath::Power(10.0, uymin);; 3924 uymax = TMath::Power(10.0, uymax);; 3925 }; 3926 ; 3927 // testing specific possibility (after zoom, draw with ""same"", log, etc.); 3928 Double_t hcenter;; 3929 if (gPad->IsVertical()) {; 3930 hcenter = fXaxis->GetBinCenter(fXHighlightBin);; 3931 if ((hcenter < uxmin) || (hcenter > uxmax)) return;; 3932 } else {; 3933 hcenter = fYaxis->GetBinCenter(fXHighlightBin);; 3934 if ((hcenter < uymin) || (hcenter > uymax)) return;; 3935 }; 3936 if (fH->GetDimension() == 2) {; 3937 hcenter = fYaxis->GetBinCenter(fYHighlightBin);; 3938 if ((hcenter < uymin) || (hcenter > uymax)) return;; 3939 }; 3940 ; 3941 // paint X highlight bin (for 1D or 2D); 3942 Double_t hbx1, hbx2, hby1, hby2;; 3943 if (gPad->IsVertical()) {; 3944 hbx1 = fXaxis->GetBinLowEdge(fXHighlightBin);; 3945 hbx2 = fXaxis->GetBinUpEdge(fXHighlightBin);; 3946 hby1 = uymin;; 3947 hby2 = uymax;; 3948 } else {; 3949 hbx1 = uxmin;; 3950 hbx2 = uxmax;; 3951 hby1 = fYaxis->GetBinLowEdge(fXHighlightBin);; 3952 hby2 = fYaxis->GetBinUpEdge(fXHighlightBin);; 3953 }; 3954 ; 3955 if (!gXHighlightBox) {; 3956 gXHighlight",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:152129,Testability,log,log,152129," paint highlight bin as box (recursive calls PaintHighlightBin); 3898 gPad->Modified(kTRUE);; 3899 gPad->Update();; 3900 ; 3901 // emit Highlighted() signal; 3902 if (gPad->GetCanvas()) gPad->GetCanvas()->Highlighted(gPad, fH, fXHighlightBin, fYHighlightBin);; 3903}; 3904 ; 3905////////////////////////////////////////////////////////////////////////////////; 3906/// Paint highlight bin as TBox object; 3907 ; 3908void THistPainter::PaintHighlightBin(Option_t * /*option*/); 3909{; 3910 // call from PaintTitle; 3911 ; 3912 if (!fH->IsHighlight()) return;; 3913 ; 3914 Double_t uxmin = gPad->GetUxmin();; 3915 Double_t uxmax = gPad->GetUxmax();; 3916 Double_t uymin = gPad->GetUymin();; 3917 Double_t uymax = gPad->GetUymax();; 3918 if (gPad->GetLogx()) {; 3919 uxmin = TMath::Power(10.0, uxmin);; 3920 uxmax = TMath::Power(10.0, uxmax);; 3921 }; 3922 if (gPad->GetLogy()) {; 3923 uymin = TMath::Power(10.0, uymin);; 3924 uymax = TMath::Power(10.0, uymax);; 3925 }; 3926 ; 3927 // testing specific possibility (after zoom, draw with ""same"", log, etc.); 3928 Double_t hcenter;; 3929 if (gPad->IsVertical()) {; 3930 hcenter = fXaxis->GetBinCenter(fXHighlightBin);; 3931 if ((hcenter < uxmin) || (hcenter > uxmax)) return;; 3932 } else {; 3933 hcenter = fYaxis->GetBinCenter(fXHighlightBin);; 3934 if ((hcenter < uymin) || (hcenter > uymax)) return;; 3935 }; 3936 if (fH->GetDimension() == 2) {; 3937 hcenter = fYaxis->GetBinCenter(fYHighlightBin);; 3938 if ((hcenter < uymin) || (hcenter > uymax)) return;; 3939 }; 3940 ; 3941 // paint X highlight bin (for 1D or 2D); 3942 Double_t hbx1, hbx2, hby1, hby2;; 3943 if (gPad->IsVertical()) {; 3944 hbx1 = fXaxis->GetBinLowEdge(fXHighlightBin);; 3945 hbx2 = fXaxis->GetBinUpEdge(fXHighlightBin);; 3946 hby1 = uymin;; 3947 hby2 = uymax;; 3948 } else {; 3949 hbx1 = uxmin;; 3950 hbx2 = uxmax;; 3951 hby1 = fYaxis->GetBinLowEdge(fXHighlightBin);; 3952 hby2 = fYaxis->GetBinUpEdge(fXHighlightBin);; 3953 }; 3954 ; 3955 if (!gXHighlightBox) {; 3956 gXHighlight",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:172617,Testability,log,logysav,172617,":make_unique<TPie>(fH);; 4505 fPie->Paint(option);; 4506 } else {; 4507 Error(""Paint"", ""Option PIE is for 1D histograms only"");; 4508 }; 4509 return;; 4510 } else {; 4511 fPie.reset();; 4512 }; 4513 ; 4514 fXbuf.resize(kNMAX);; 4515 fYbuf.resize(kNMAX);; 4516 if (fH->GetDimension() > 2) {; 4517 PaintH3(option);; 4518 fH->SetMinimum(minsav);; 4519 if (Hoption.Func) {; 4520 Hoption_t hoptsave = Hoption;; 4521 Hparam_t hparsave = Hparam;; 4522 PaintFunction(option);; 4523 SetHistogram(hsave);; 4524 Hoption = hoptsave;; 4525 Hparam = hparsave;; 4526 }; 4527 gCurrentHist = oldhist;; 4528 fXbuf.clear();; 4529 fYbuf.clear();; 4530 return;; 4531 }; 4532 TView *view = gPad->GetView();; 4533 if (view) {; 4534 if (!Hoption.Lego && !Hoption.Surf && !Hoption.Tri) {; 4535 delete view;; 4536 gPad->SetView(nullptr);; 4537 }; 4538 }; 4539 if (fH->GetDimension() > 1 || Hoption.Lego || Hoption.Surf) {; 4540 // In case of 1D histogram, Z axis becomes Y axis.; 4541 Int_t logysav=0, logzsav=0;; 4542 if (fH->GetDimension() == 1) {; 4543 logysav = Hoption.Logy;; 4544 logzsav = Hoption.Logz;; 4545 Hoption.Logz = 0;; 4546 if (Hoption.Logy) {; 4547 Hoption.Logz = 1;; 4548 Hoption.Logy = 0;; 4549 }; 4550 }; 4551 PaintTable(option);; 4552 if (Hoption.Func) {; 4553 Hoption_t hoptsave = Hoption;; 4554 Hparam_t hparsave = Hparam;; 4555 PaintFunction(option);; 4556 SetHistogram(hsave);; 4557 Hoption = hoptsave;; 4558 Hparam = hparsave;; 4559 }; 4560 fH->SetMinimum(minsav);; 4561 gCurrentHist = oldhist;; 4562 fXbuf.clear();; 4563 fYbuf.clear();; 4564 if (fH->GetDimension() == 1) {; 4565 Hoption.Logy = logysav;; 4566 Hoption.Logz = logzsav;; 4567 }; 4568 return;; 4569 }; 4570 ; 4571 if (Hoption.Bar >= 20) {; 4572 PaintBarH(option);; 4573 fXbuf.clear();; 4574 fYbuf.clear();; 4575 return;; 4576 }; 4577 ; 4578 gPad->RangeAxisChanged(); //emit RangeAxisChanged() signal to sync axes; 4579 // fill Hparam structure with histo parameters; 4580 if (!PaintInit()) {; 4581 fXbuf.clear();; 4582 fYbuf.clear();; 45",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:172628,Testability,log,logzsav,172628,":make_unique<TPie>(fH);; 4505 fPie->Paint(option);; 4506 } else {; 4507 Error(""Paint"", ""Option PIE is for 1D histograms only"");; 4508 }; 4509 return;; 4510 } else {; 4511 fPie.reset();; 4512 }; 4513 ; 4514 fXbuf.resize(kNMAX);; 4515 fYbuf.resize(kNMAX);; 4516 if (fH->GetDimension() > 2) {; 4517 PaintH3(option);; 4518 fH->SetMinimum(minsav);; 4519 if (Hoption.Func) {; 4520 Hoption_t hoptsave = Hoption;; 4521 Hparam_t hparsave = Hparam;; 4522 PaintFunction(option);; 4523 SetHistogram(hsave);; 4524 Hoption = hoptsave;; 4525 Hparam = hparsave;; 4526 }; 4527 gCurrentHist = oldhist;; 4528 fXbuf.clear();; 4529 fYbuf.clear();; 4530 return;; 4531 }; 4532 TView *view = gPad->GetView();; 4533 if (view) {; 4534 if (!Hoption.Lego && !Hoption.Surf && !Hoption.Tri) {; 4535 delete view;; 4536 gPad->SetView(nullptr);; 4537 }; 4538 }; 4539 if (fH->GetDimension() > 1 || Hoption.Lego || Hoption.Surf) {; 4540 // In case of 1D histogram, Z axis becomes Y axis.; 4541 Int_t logysav=0, logzsav=0;; 4542 if (fH->GetDimension() == 1) {; 4543 logysav = Hoption.Logy;; 4544 logzsav = Hoption.Logz;; 4545 Hoption.Logz = 0;; 4546 if (Hoption.Logy) {; 4547 Hoption.Logz = 1;; 4548 Hoption.Logy = 0;; 4549 }; 4550 }; 4551 PaintTable(option);; 4552 if (Hoption.Func) {; 4553 Hoption_t hoptsave = Hoption;; 4554 Hparam_t hparsave = Hparam;; 4555 PaintFunction(option);; 4556 SetHistogram(hsave);; 4557 Hoption = hoptsave;; 4558 Hparam = hparsave;; 4559 }; 4560 fH->SetMinimum(minsav);; 4561 gCurrentHist = oldhist;; 4562 fXbuf.clear();; 4563 fYbuf.clear();; 4564 if (fH->GetDimension() == 1) {; 4565 Hoption.Logy = logysav;; 4566 Hoption.Logz = logzsav;; 4567 }; 4568 return;; 4569 }; 4570 ; 4571 if (Hoption.Bar >= 20) {; 4572 PaintBarH(option);; 4573 fXbuf.clear();; 4574 fYbuf.clear();; 4575 return;; 4576 }; 4577 ; 4578 gPad->RangeAxisChanged(); //emit RangeAxisChanged() signal to sync axes; 4579 // fill Hparam structure with histo parameters; 4580 if (!PaintInit()) {; 4581 fXbuf.clear();; 4582 fYbuf.clear();; 45",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:172682,Testability,log,logysav,172682,":make_unique<TPie>(fH);; 4505 fPie->Paint(option);; 4506 } else {; 4507 Error(""Paint"", ""Option PIE is for 1D histograms only"");; 4508 }; 4509 return;; 4510 } else {; 4511 fPie.reset();; 4512 }; 4513 ; 4514 fXbuf.resize(kNMAX);; 4515 fYbuf.resize(kNMAX);; 4516 if (fH->GetDimension() > 2) {; 4517 PaintH3(option);; 4518 fH->SetMinimum(minsav);; 4519 if (Hoption.Func) {; 4520 Hoption_t hoptsave = Hoption;; 4521 Hparam_t hparsave = Hparam;; 4522 PaintFunction(option);; 4523 SetHistogram(hsave);; 4524 Hoption = hoptsave;; 4525 Hparam = hparsave;; 4526 }; 4527 gCurrentHist = oldhist;; 4528 fXbuf.clear();; 4529 fYbuf.clear();; 4530 return;; 4531 }; 4532 TView *view = gPad->GetView();; 4533 if (view) {; 4534 if (!Hoption.Lego && !Hoption.Surf && !Hoption.Tri) {; 4535 delete view;; 4536 gPad->SetView(nullptr);; 4537 }; 4538 }; 4539 if (fH->GetDimension() > 1 || Hoption.Lego || Hoption.Surf) {; 4540 // In case of 1D histogram, Z axis becomes Y axis.; 4541 Int_t logysav=0, logzsav=0;; 4542 if (fH->GetDimension() == 1) {; 4543 logysav = Hoption.Logy;; 4544 logzsav = Hoption.Logz;; 4545 Hoption.Logz = 0;; 4546 if (Hoption.Logy) {; 4547 Hoption.Logz = 1;; 4548 Hoption.Logy = 0;; 4549 }; 4550 }; 4551 PaintTable(option);; 4552 if (Hoption.Func) {; 4553 Hoption_t hoptsave = Hoption;; 4554 Hparam_t hparsave = Hparam;; 4555 PaintFunction(option);; 4556 SetHistogram(hsave);; 4557 Hoption = hoptsave;; 4558 Hparam = hparsave;; 4559 }; 4560 fH->SetMinimum(minsav);; 4561 gCurrentHist = oldhist;; 4562 fXbuf.clear();; 4563 fYbuf.clear();; 4564 if (fH->GetDimension() == 1) {; 4565 Hoption.Logy = logysav;; 4566 Hoption.Logz = logzsav;; 4567 }; 4568 return;; 4569 }; 4570 ; 4571 if (Hoption.Bar >= 20) {; 4572 PaintBarH(option);; 4573 fXbuf.clear();; 4574 fYbuf.clear();; 4575 return;; 4576 }; 4577 ; 4578 gPad->RangeAxisChanged(); //emit RangeAxisChanged() signal to sync axes; 4579 // fill Hparam structure with histo parameters; 4580 if (!PaintInit()) {; 4581 fXbuf.clear();; 4582 fYbuf.clear();; 45",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:172712,Testability,log,logzsav,172712," {; 4507 Error(""Paint"", ""Option PIE is for 1D histograms only"");; 4508 }; 4509 return;; 4510 } else {; 4511 fPie.reset();; 4512 }; 4513 ; 4514 fXbuf.resize(kNMAX);; 4515 fYbuf.resize(kNMAX);; 4516 if (fH->GetDimension() > 2) {; 4517 PaintH3(option);; 4518 fH->SetMinimum(minsav);; 4519 if (Hoption.Func) {; 4520 Hoption_t hoptsave = Hoption;; 4521 Hparam_t hparsave = Hparam;; 4522 PaintFunction(option);; 4523 SetHistogram(hsave);; 4524 Hoption = hoptsave;; 4525 Hparam = hparsave;; 4526 }; 4527 gCurrentHist = oldhist;; 4528 fXbuf.clear();; 4529 fYbuf.clear();; 4530 return;; 4531 }; 4532 TView *view = gPad->GetView();; 4533 if (view) {; 4534 if (!Hoption.Lego && !Hoption.Surf && !Hoption.Tri) {; 4535 delete view;; 4536 gPad->SetView(nullptr);; 4537 }; 4538 }; 4539 if (fH->GetDimension() > 1 || Hoption.Lego || Hoption.Surf) {; 4540 // In case of 1D histogram, Z axis becomes Y axis.; 4541 Int_t logysav=0, logzsav=0;; 4542 if (fH->GetDimension() == 1) {; 4543 logysav = Hoption.Logy;; 4544 logzsav = Hoption.Logz;; 4545 Hoption.Logz = 0;; 4546 if (Hoption.Logy) {; 4547 Hoption.Logz = 1;; 4548 Hoption.Logy = 0;; 4549 }; 4550 }; 4551 PaintTable(option);; 4552 if (Hoption.Func) {; 4553 Hoption_t hoptsave = Hoption;; 4554 Hparam_t hparsave = Hparam;; 4555 PaintFunction(option);; 4556 SetHistogram(hsave);; 4557 Hoption = hoptsave;; 4558 Hparam = hparsave;; 4559 }; 4560 fH->SetMinimum(minsav);; 4561 gCurrentHist = oldhist;; 4562 fXbuf.clear();; 4563 fYbuf.clear();; 4564 if (fH->GetDimension() == 1) {; 4565 Hoption.Logy = logysav;; 4566 Hoption.Logz = logzsav;; 4567 }; 4568 return;; 4569 }; 4570 ; 4571 if (Hoption.Bar >= 20) {; 4572 PaintBarH(option);; 4573 fXbuf.clear();; 4574 fYbuf.clear();; 4575 return;; 4576 }; 4577 ; 4578 gPad->RangeAxisChanged(); //emit RangeAxisChanged() signal to sync axes; 4579 // fill Hparam structure with histo parameters; 4580 if (!PaintInit()) {; 4581 fXbuf.clear();; 4582 fYbuf.clear();; 4583 return;; 4584 }; 4585 ; 4586 // Picture surround (if new pag",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:173247,Testability,log,logysav,173247,";; 4529 fYbuf.clear();; 4530 return;; 4531 }; 4532 TView *view = gPad->GetView();; 4533 if (view) {; 4534 if (!Hoption.Lego && !Hoption.Surf && !Hoption.Tri) {; 4535 delete view;; 4536 gPad->SetView(nullptr);; 4537 }; 4538 }; 4539 if (fH->GetDimension() > 1 || Hoption.Lego || Hoption.Surf) {; 4540 // In case of 1D histogram, Z axis becomes Y axis.; 4541 Int_t logysav=0, logzsav=0;; 4542 if (fH->GetDimension() == 1) {; 4543 logysav = Hoption.Logy;; 4544 logzsav = Hoption.Logz;; 4545 Hoption.Logz = 0;; 4546 if (Hoption.Logy) {; 4547 Hoption.Logz = 1;; 4548 Hoption.Logy = 0;; 4549 }; 4550 }; 4551 PaintTable(option);; 4552 if (Hoption.Func) {; 4553 Hoption_t hoptsave = Hoption;; 4554 Hparam_t hparsave = Hparam;; 4555 PaintFunction(option);; 4556 SetHistogram(hsave);; 4557 Hoption = hoptsave;; 4558 Hparam = hparsave;; 4559 }; 4560 fH->SetMinimum(minsav);; 4561 gCurrentHist = oldhist;; 4562 fXbuf.clear();; 4563 fYbuf.clear();; 4564 if (fH->GetDimension() == 1) {; 4565 Hoption.Logy = logysav;; 4566 Hoption.Logz = logzsav;; 4567 }; 4568 return;; 4569 }; 4570 ; 4571 if (Hoption.Bar >= 20) {; 4572 PaintBarH(option);; 4573 fXbuf.clear();; 4574 fYbuf.clear();; 4575 return;; 4576 }; 4577 ; 4578 gPad->RangeAxisChanged(); //emit RangeAxisChanged() signal to sync axes; 4579 // fill Hparam structure with histo parameters; 4580 if (!PaintInit()) {; 4581 fXbuf.clear();; 4582 fYbuf.clear();; 4583 return;; 4584 }; 4585 ; 4586 // Picture surround (if new page) and page number (if requested).; 4587 // Histogram surround (if not option ""Same"").; 4588 PaintFrame();; 4589 ; 4590 // Paint histogram axis only; 4591 Bool_t gridx = gPad->GetGridx();; 4592 Bool_t gridy = gPad->GetGridy();; 4593 if (Hoption.Axis > 0) {; 4594 if (Hoption.Axis > 1) PaintAxis(kTRUE); //axis with grid; 4595 else {; 4596 if (gridx) gPad->SetGridx(0);; 4597 if (gridy) gPad->SetGridy(0);; 4598 PaintAxis(kFALSE);; 4599 if (gridx) gPad->SetGridx(1);; 4600 if (gridy) gPad->SetGridy(1);; 4601 }; 4602 if ((Hoption.Same%10) ==",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:173277,Testability,log,logzsav,173277," TView *view = gPad->GetView();; 4533 if (view) {; 4534 if (!Hoption.Lego && !Hoption.Surf && !Hoption.Tri) {; 4535 delete view;; 4536 gPad->SetView(nullptr);; 4537 }; 4538 }; 4539 if (fH->GetDimension() > 1 || Hoption.Lego || Hoption.Surf) {; 4540 // In case of 1D histogram, Z axis becomes Y axis.; 4541 Int_t logysav=0, logzsav=0;; 4542 if (fH->GetDimension() == 1) {; 4543 logysav = Hoption.Logy;; 4544 logzsav = Hoption.Logz;; 4545 Hoption.Logz = 0;; 4546 if (Hoption.Logy) {; 4547 Hoption.Logz = 1;; 4548 Hoption.Logy = 0;; 4549 }; 4550 }; 4551 PaintTable(option);; 4552 if (Hoption.Func) {; 4553 Hoption_t hoptsave = Hoption;; 4554 Hparam_t hparsave = Hparam;; 4555 PaintFunction(option);; 4556 SetHistogram(hsave);; 4557 Hoption = hoptsave;; 4558 Hparam = hparsave;; 4559 }; 4560 fH->SetMinimum(minsav);; 4561 gCurrentHist = oldhist;; 4562 fXbuf.clear();; 4563 fYbuf.clear();; 4564 if (fH->GetDimension() == 1) {; 4565 Hoption.Logy = logysav;; 4566 Hoption.Logz = logzsav;; 4567 }; 4568 return;; 4569 }; 4570 ; 4571 if (Hoption.Bar >= 20) {; 4572 PaintBarH(option);; 4573 fXbuf.clear();; 4574 fYbuf.clear();; 4575 return;; 4576 }; 4577 ; 4578 gPad->RangeAxisChanged(); //emit RangeAxisChanged() signal to sync axes; 4579 // fill Hparam structure with histo parameters; 4580 if (!PaintInit()) {; 4581 fXbuf.clear();; 4582 fYbuf.clear();; 4583 return;; 4584 }; 4585 ; 4586 // Picture surround (if new page) and page number (if requested).; 4587 // Histogram surround (if not option ""Same"").; 4588 PaintFrame();; 4589 ; 4590 // Paint histogram axis only; 4591 Bool_t gridx = gPad->GetGridx();; 4592 Bool_t gridy = gPad->GetGridy();; 4593 if (Hoption.Axis > 0) {; 4594 if (Hoption.Axis > 1) PaintAxis(kTRUE); //axis with grid; 4595 else {; 4596 if (gridx) gPad->SetGridx(0);; 4597 if (gridy) gPad->SetGridy(0);; 4598 PaintAxis(kFALSE);; 4599 if (gridx) gPad->SetGridx(1);; 4600 if (gridy) gPad->SetGridy(1);; 4601 }; 4602 if ((Hoption.Same%10) ==1) Hoption.Same += 1;; 4603 goto paintstat;; 4604 }",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:174389,Testability,test,test,174389," {; 4572 PaintBarH(option);; 4573 fXbuf.clear();; 4574 fYbuf.clear();; 4575 return;; 4576 }; 4577 ; 4578 gPad->RangeAxisChanged(); //emit RangeAxisChanged() signal to sync axes; 4579 // fill Hparam structure with histo parameters; 4580 if (!PaintInit()) {; 4581 fXbuf.clear();; 4582 fYbuf.clear();; 4583 return;; 4584 }; 4585 ; 4586 // Picture surround (if new page) and page number (if requested).; 4587 // Histogram surround (if not option ""Same"").; 4588 PaintFrame();; 4589 ; 4590 // Paint histogram axis only; 4591 Bool_t gridx = gPad->GetGridx();; 4592 Bool_t gridy = gPad->GetGridy();; 4593 if (Hoption.Axis > 0) {; 4594 if (Hoption.Axis > 1) PaintAxis(kTRUE); //axis with grid; 4595 else {; 4596 if (gridx) gPad->SetGridx(0);; 4597 if (gridy) gPad->SetGridy(0);; 4598 PaintAxis(kFALSE);; 4599 if (gridx) gPad->SetGridx(1);; 4600 if (gridy) gPad->SetGridy(1);; 4601 }; 4602 if ((Hoption.Same%10) ==1) Hoption.Same += 1;; 4603 goto paintstat;; 4604 }; 4605 if (gridx || gridy) PaintAxis(kTRUE); // Draw the grid only; 4606 ; 4607 // test for options BAR or HBAR; 4608 if (Hoption.Bar >= 10) {; 4609 PaintBar(option);; 4610 }; 4611 ; 4612 // do not draw histogram if error bars required; 4613 if (!Hoption.Error) {; 4614 if (Hoption.Hist && Hoption.Bar<10) PaintHist(option);; 4615 }; 4616 ; 4617 // test for error bars or option E; 4618 if (Hoption.Error) {; 4619 PaintErrors(option);; 4620 if (Hoption.Hist == 2) PaintHist(option);; 4621 }; 4622 ; 4623 if (Hoption.Text) PaintText(option);; 4624 ; 4625 // test for associated function; 4626 if (Hoption.Func) {; 4627 Hoption_t hoptsave = Hoption;; 4628 Hparam_t hparsave = Hparam;; 4629 PaintFunction(option);; 4630 SetHistogram(hsave);; 4631 Hoption = hoptsave;; 4632 Hparam = hparsave;; 4633 }; 4634 ; 4635 if (gridx) gPad->SetGridx(0);; 4636 if (gridy) gPad->SetGridy(0);; 4637 PaintAxis(kFALSE);; 4638 if (gridx) gPad->SetGridx(1);; 4639 if (gridy) gPad->SetGridy(1);; 4640 ; 4641 PaintTitle(); // Draw histogram title; 4642 ; 4643 // Draw ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:174655,Testability,test,test,174655," return;; 4584 }; 4585 ; 4586 // Picture surround (if new page) and page number (if requested).; 4587 // Histogram surround (if not option ""Same"").; 4588 PaintFrame();; 4589 ; 4590 // Paint histogram axis only; 4591 Bool_t gridx = gPad->GetGridx();; 4592 Bool_t gridy = gPad->GetGridy();; 4593 if (Hoption.Axis > 0) {; 4594 if (Hoption.Axis > 1) PaintAxis(kTRUE); //axis with grid; 4595 else {; 4596 if (gridx) gPad->SetGridx(0);; 4597 if (gridy) gPad->SetGridy(0);; 4598 PaintAxis(kFALSE);; 4599 if (gridx) gPad->SetGridx(1);; 4600 if (gridy) gPad->SetGridy(1);; 4601 }; 4602 if ((Hoption.Same%10) ==1) Hoption.Same += 1;; 4603 goto paintstat;; 4604 }; 4605 if (gridx || gridy) PaintAxis(kTRUE); // Draw the grid only; 4606 ; 4607 // test for options BAR or HBAR; 4608 if (Hoption.Bar >= 10) {; 4609 PaintBar(option);; 4610 }; 4611 ; 4612 // do not draw histogram if error bars required; 4613 if (!Hoption.Error) {; 4614 if (Hoption.Hist && Hoption.Bar<10) PaintHist(option);; 4615 }; 4616 ; 4617 // test for error bars or option E; 4618 if (Hoption.Error) {; 4619 PaintErrors(option);; 4620 if (Hoption.Hist == 2) PaintHist(option);; 4621 }; 4622 ; 4623 if (Hoption.Text) PaintText(option);; 4624 ; 4625 // test for associated function; 4626 if (Hoption.Func) {; 4627 Hoption_t hoptsave = Hoption;; 4628 Hparam_t hparsave = Hparam;; 4629 PaintFunction(option);; 4630 SetHistogram(hsave);; 4631 Hoption = hoptsave;; 4632 Hparam = hparsave;; 4633 }; 4634 ; 4635 if (gridx) gPad->SetGridx(0);; 4636 if (gridy) gPad->SetGridy(0);; 4637 PaintAxis(kFALSE);; 4638 if (gridx) gPad->SetGridx(1);; 4639 if (gridy) gPad->SetGridy(1);; 4640 ; 4641 PaintTitle(); // Draw histogram title; 4642 ; 4643 // Draw box with histogram statistics and/or fit parameters; 4644paintstat:; 4645 if ((Hoption.Same%10) != 1 && !fH->TestBit(TH1::kNoStats)) { // bit set via TH1::SetStats; 4646 TIter next(fFunctions);; 4647 TObject *obj = nullptr;; 4648 while ((obj = next())) {; 4649 if (obj->InheritsFrom(TF1::Class())) break;",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:174863,Testability,test,test,174863,"591 Bool_t gridx = gPad->GetGridx();; 4592 Bool_t gridy = gPad->GetGridy();; 4593 if (Hoption.Axis > 0) {; 4594 if (Hoption.Axis > 1) PaintAxis(kTRUE); //axis with grid; 4595 else {; 4596 if (gridx) gPad->SetGridx(0);; 4597 if (gridy) gPad->SetGridy(0);; 4598 PaintAxis(kFALSE);; 4599 if (gridx) gPad->SetGridx(1);; 4600 if (gridy) gPad->SetGridy(1);; 4601 }; 4602 if ((Hoption.Same%10) ==1) Hoption.Same += 1;; 4603 goto paintstat;; 4604 }; 4605 if (gridx || gridy) PaintAxis(kTRUE); // Draw the grid only; 4606 ; 4607 // test for options BAR or HBAR; 4608 if (Hoption.Bar >= 10) {; 4609 PaintBar(option);; 4610 }; 4611 ; 4612 // do not draw histogram if error bars required; 4613 if (!Hoption.Error) {; 4614 if (Hoption.Hist && Hoption.Bar<10) PaintHist(option);; 4615 }; 4616 ; 4617 // test for error bars or option E; 4618 if (Hoption.Error) {; 4619 PaintErrors(option);; 4620 if (Hoption.Hist == 2) PaintHist(option);; 4621 }; 4622 ; 4623 if (Hoption.Text) PaintText(option);; 4624 ; 4625 // test for associated function; 4626 if (Hoption.Func) {; 4627 Hoption_t hoptsave = Hoption;; 4628 Hparam_t hparsave = Hparam;; 4629 PaintFunction(option);; 4630 SetHistogram(hsave);; 4631 Hoption = hoptsave;; 4632 Hparam = hparsave;; 4633 }; 4634 ; 4635 if (gridx) gPad->SetGridx(0);; 4636 if (gridy) gPad->SetGridy(0);; 4637 PaintAxis(kFALSE);; 4638 if (gridx) gPad->SetGridx(1);; 4639 if (gridy) gPad->SetGridy(1);; 4640 ; 4641 PaintTitle(); // Draw histogram title; 4642 ; 4643 // Draw box with histogram statistics and/or fit parameters; 4644paintstat:; 4645 if ((Hoption.Same%10) != 1 && !fH->TestBit(TH1::kNoStats)) { // bit set via TH1::SetStats; 4646 TIter next(fFunctions);; 4647 TObject *obj = nullptr;; 4648 while ((obj = next())) {; 4649 if (obj->InheritsFrom(TF1::Class())) break;; 4650 obj = nullptr;; 4651 }; 4652 ; 4653 //Stat is painted twice (first, it will be in canvas' list of primitives),; 4654 //second, it will be here, this is not required on iOS.; 4655 //Condition is ALWAYS tru",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:204630,Testability,log,log,204630,"ndleWidth*binWidth);; 5446 myCandle.SetHistoWidth(histoWidth*binWidth);; 5447 myCandle.SetHistogram(hproj);; 5448 myCandle.Paint();; 5449 }; 5450 }; 5451 }; 5452 delete hproj;; 5453}; 5454 ; 5455 ; 5456 ; 5457////////////////////////////////////////////////////////////////////////////////; 5458/// Returns the rendering regions for an axis to use in the COL2 option; 5459///; 5460/// The algorithm analyses the size of the axis compared to the size of; 5461/// the rendering region. It figures out the boundaries to use for each color; 5462/// of the rendering region. Only one axis is computed here.; 5463///; 5464/// This allows for a single computation of the boundaries before iterating; 5465/// through all of the bins.; 5466///; 5467/// \param pAxis the axis to consider; 5468/// \param nPixels the number of pixels to render axis into; 5469/// \param isLog whether the axis is log scale; 5470 ; 5471std::vector<THistRenderingRegion>; 5472THistPainter::ComputeRenderingRegions(TAxis* pAxis, Int_t nPixels, Bool_t isLog); 5473{; 5474 std::vector<THistRenderingRegion> regions;; 5475 ; 5476 enum STRATEGY { Bins, Pixels } strategy;; 5477 ; 5478 Int_t nBins = (pAxis->GetLast() - pAxis->GetFirst() + 1);; 5479 ; 5480 if (nBins >= nPixels) {; 5481 // more bins than pixels... we should loop over pixels and sample; 5482 strategy = Pixels;; 5483 } else {; 5484 // fewer bins than pixels... we should loop over bins; 5485 strategy = Bins;; 5486 }; 5487 ; 5488 if (isLog) {; 5489 ; 5490 Double_t xMin = pAxis->GetBinLowEdge(pAxis->GetFirst());; 5491 Int_t binOffset=0;; 5492 while (xMin <= 0 && ((pAxis->GetFirst()+binOffset) != pAxis->GetLast()) ) {; 5493 binOffset++;; 5494 xMin = pAxis->GetBinLowEdge(pAxis->GetFirst()+binOffset);; 5495 }; 5496 if (xMin <= 0) {; 5497 // this should cause an error if we have; 5498 return regions;; 5499 }; 5500 Double_t xMax = pAxis->GetBinUpEdge(pAxis->GetLast());; 5501 ; 5502 if (strategy == Bins) {; 5503 // logarithmic plot. we find the pixel for the bin; 550",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:205694,Testability,log,logarithmic,205694,"ore iterating; 5465/// through all of the bins.; 5466///; 5467/// \param pAxis the axis to consider; 5468/// \param nPixels the number of pixels to render axis into; 5469/// \param isLog whether the axis is log scale; 5470 ; 5471std::vector<THistRenderingRegion>; 5472THistPainter::ComputeRenderingRegions(TAxis* pAxis, Int_t nPixels, Bool_t isLog); 5473{; 5474 std::vector<THistRenderingRegion> regions;; 5475 ; 5476 enum STRATEGY { Bins, Pixels } strategy;; 5477 ; 5478 Int_t nBins = (pAxis->GetLast() - pAxis->GetFirst() + 1);; 5479 ; 5480 if (nBins >= nPixels) {; 5481 // more bins than pixels... we should loop over pixels and sample; 5482 strategy = Pixels;; 5483 } else {; 5484 // fewer bins than pixels... we should loop over bins; 5485 strategy = Bins;; 5486 }; 5487 ; 5488 if (isLog) {; 5489 ; 5490 Double_t xMin = pAxis->GetBinLowEdge(pAxis->GetFirst());; 5491 Int_t binOffset=0;; 5492 while (xMin <= 0 && ((pAxis->GetFirst()+binOffset) != pAxis->GetLast()) ) {; 5493 binOffset++;; 5494 xMin = pAxis->GetBinLowEdge(pAxis->GetFirst()+binOffset);; 5495 }; 5496 if (xMin <= 0) {; 5497 // this should cause an error if we have; 5498 return regions;; 5499 }; 5500 Double_t xMax = pAxis->GetBinUpEdge(pAxis->GetLast());; 5501 ; 5502 if (strategy == Bins) {; 5503 // logarithmic plot. we find the pixel for the bin; 5504 // pixel = eta * log10(V) - alpha; 5505 // where eta = nPixels/(log10(Vmax)-log10(Vmin)); 5506 // and alpha = nPixels*log10(Vmin)/(log10(Vmax)-log10(Vmin)); 5507 // and V is axis value; 5508 Double_t eta = (nPixels-1.0)/(TMath::Log10(xMax) - TMath::Log10(xMin));; 5509 Double_t offset = -1.0 * eta * TMath::Log10(xMin);; 5510 ; 5511 for (Int_t bin=pAxis->GetFirst()+binOffset; bin<=pAxis->GetLast(); bin++) {; 5512 ; 5513 // linear plot. we simply need to find the appropriate bin; 5514 // for the; 5515 Double_t xLowValue = pAxis->GetBinLowEdge(bin);; 5516 Double_t xUpValue = pAxis->GetBinUpEdge(bin);; 5517 Int_t xPx0 = eta*TMath::Log10(xLowValue)+ offset;; 5518 Int_t xPx1",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:209843,Testability,log,logz,209843,"586 ; 5587 Double_t z;; 5588 ; 5589 // Use existing max or min values. If either is already set; 5590 // the appropriate value to use.; 5591 Double_t zmin = fH->GetMinimumStored();; 5592 Double_t zmax = fH->GetMaximumStored();; 5593 Double_t originalZMin = zmin;; 5594 Double_t originalZMax = zmax;; 5595 if ((zmin == -1111) && (zmax == -1111)) {; 5596 fH->GetMinimumAndMaximum(zmin, zmax);; 5597 fH->SetMinimum(zmin);; 5598 fH->SetMaximum(zmax);; 5599 } else if (zmin == -1111) {; 5600 zmin = fH->GetMinimum();; 5601 fH->SetMinimum(zmin);; 5602 } else if (zmax == -1111) {; 5603 zmax = fH->GetMaximum();; 5604 fH->SetMaximum(zmax);; 5605 }; 5606 ; 5607 Double_t dz = zmax - zmin;; 5608 if (dz <= 0) { // Histogram filled with a constant value; 5609 zmax += 0.1*TMath::Abs(zmax);; 5610 zmin -= 0.1*TMath::Abs(zmin);; 5611 dz = zmax - zmin;; 5612 }; 5613 ; 5614 if (Hoption.Logz) {; 5615 if (zmin > 0) {; 5616 zmin = TMath::Log10(zmin);; 5617 zmax = TMath::Log10(zmax);; 5618 dz = zmax - zmin;; 5619 } else {; 5620 Error(""THistPainter::PaintColorLevelsFast(Option_t*)"",; 5621 ""Cannot plot logz because bin content is less than 0."");; 5622 return;; 5623 }; 5624 }; 5625 ; 5626 // Initialize the levels on the Z axis; 5627 Int_t ndiv = fH->GetContour();; 5628 if (ndiv == 0 ) {; 5629 ndiv = gStyle->GetNumberContours();; 5630 fH->SetContour(ndiv);; 5631 }; 5632 std::vector<Double_t> colorBounds(ndiv);; 5633 std::vector<Double_t> contours(ndiv, 0);; 5634 if (!fH->TestBit(TH1::kUserContour)) {; 5635 fH->SetContour(ndiv);; 5636 } else {; 5637 fH->GetContour(contours.data());; 5638 }; 5639 ; 5640 Double_t step = 1.0/ndiv;; 5641 for (Int_t i=0; i<ndiv; ++i) {; 5642 colorBounds[i] = step*i;; 5643 }; 5644 ; 5645 auto pFrame = gPad->GetFrame();; 5646 Int_t px0 = gPad->XtoPixel(pFrame->GetX1());; 5647 Int_t px1 = gPad->XtoPixel(pFrame->GetX2());; 5648 Int_t py0 = gPad->YtoPixel(pFrame->GetY1());; 5649 Int_t py1 = gPad->YtoPixel(pFrame->GetY2());; 5650 Int_t nXPixels = px1-px0;; 5651 Int_t nYPixels = ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:220456,Testability,test,tested,220456,"crown.SetLineStyle(fH->GetLineStyle());; 5916 crown.Paint();; 5917 }; 5918 }; 5919 }; 5920 ; 5921 if (Hoption.Zscale) PaintPalette();; 5922 ; 5923 fH->SetFillStyle(fillsav);; 5924 fH->SetFillColor(colsav);; 5925 fH->TAttFill::Modify();; 5926 ; 5927}; 5928 ; 5929////////////////////////////////////////////////////////////////////////////////; 5930/// [Control function to draw a 2D histogram as a contour plot.](\ref HP16); 5931 ; 5932void THistPainter::PaintContour(Option_t *option); 5933{; 5934 ; 5935 Int_t i, j, count, ncontour, icol, n, lj, m, ix, jx, ljfill;; 5936 Int_t itars, mode, ir[4];; 5937 Double_t xsave, ysave, thesave,phisave,x[4], y[4], zc[4];; 5938 ; 5939 if (Hoption.Contour == 14) {; 5940 Hoption.Surf = 12;; 5941 Hoption.Axis = 1;; 5942 thesave = gPad->GetTheta();; 5943 phisave = gPad->GetPhi();; 5944 gPad->SetPhi(0.);; 5945 gPad->SetTheta(90.);; 5946 PaintSurface(option);; 5947 gPad->SetPhi(phisave);; 5948 gPad->SetTheta(thesave);; 5949 TView *view = gPad->GetView();; 5950 if (view) view->SetBit(kCannotRotate); //tested in ExecuteEvent; 5951 PaintAxis();; 5952 return;; 5953 }; 5954 ; 5955 if (Hoption.Same) {; 5956 // If the contour is painted on a 3d plot, the contour lines are; 5957 // paint in 3d too.; 5958 TObject *obj;; 5959 TIter next(gPad->GetListOfPrimitives());; 5960 while ((obj=next())) {; 5961 if (strstr(obj->GetDrawOption(),""surf"") ||; 5962 strstr(obj->GetDrawOption(),""lego"") ||; 5963 strstr(obj->GetDrawOption(),""tri"")) {; 5964 Hoption.Surf = 16;; 5965 PaintSurface(option);; 5966 return;; 5967 }; 5968 }; 5969 }; 5970 ; 5971 if (Hoption.Contour == 15) {; 5972 TGraphDelaunay2D *dt = nullptr;; 5973 TGraphDelaunay *dtOld = nullptr;; 5974 TList *hl = fH->GetListOfFunctions();; 5975 dt = (TGraphDelaunay2D*)hl->FindObject(""TGraphDelaunay2D"");; 5976 if (!dt) dtOld = (TGraphDelaunay*)hl->FindObject(""TGraphDelaunay"");; 5977 if (!dt && !dtOld) return;; 5978 if (!fGraph2DPainter); 5979 fGraph2DPainter = dt ? std::make_unique<TGraph2DPainter>(dt) : std::",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:232558,Testability,log,logxmin,232558,"n;; 6293 } else {; 6294 if (Hoption.Logx); 6295 xarr[i] = TMath::Log10(x1 + xlen);; 6296 else; 6297 xarr[i] = x1 + xlen;; 6298 if (Hoption.Logy); 6299 yarr[i] = TMath::Log10(y1);; 6300 else; 6301 yarr[i] = y1;; 6302 }; 6303 itarr[i] = n;; 6304 icount++;; 6305 i +=2;; 6306 n++;; 6307 }; 6308 return icount;; 6309}; 6310 ; 6311////////////////////////////////////////////////////////////////////////////////; 6312/// [Draw 1D histograms error bars.](\ref HP09); 6313 ; 6314void THistPainter::PaintErrors(Option_t *); 6315{; 6316 ; 6317 // On iOS, we do not highlight histogram, if it's not picked at the moment; 6318 // (but part of histogram (axis or pavestat) was picked, that's why this code; 6319 // is called at all. This conditional statement never executes on non-iOS platform.; 6320 if (gPad->PadInHighlightMode() && gPad->GetSelected() != fH) return;; 6321 ; 6322 const Int_t kBASEMARKER=8;; 6323 Double_t xp, yp, ex1, ex2, ey1, ey2;; 6324 Double_t delta;; 6325 Double_t s2x, s2y, bxsize, bysize, symbolsize, xerror, sbasex, sbasey;; 6326 Double_t xi1, xi2, xi3, xi4, yi1, yi2, yi3, yi4;; 6327 Double_t xmin, xmax, ymin, ymax;; 6328 Double_t logxmin = 0;; 6329 Double_t logymin = 0;; 6330 Double_t offset = 0.;; 6331 Double_t width = 0.;; 6332 Int_t i, k, npoints, first, last, fixbin;; 6333 Int_t if1 = 0;; 6334 Int_t if2 = 0;; 6335 Int_t drawmarker, errormarker;; 6336 Int_t option0, option1, option2, option3, option4, optionE, optionEX0, optionI0;; 6337 static Float_t cxx[30] = {1.0,1.0,0.5,0.5,1.0,1.0,0.5,0.6,1.0,0.5,0.5,1.0,0.5,0.6,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 6338 static Float_t cyy[30] = {1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.5,0.5,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 6339 ; 6340 std::vector<Double_t> xline, yline;; 6341 option0 = option1 = option2 = option3 = option4 = optionE = optionEX0 = optionI0 = 0;; 6342 if (Hoption.Error >= 40) {Hoption.Error -=40; option0 = 1;}; 6343 if (Int_t(Hoption.E",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:232586,Testability,log,logymin,232586,"n;; 6293 } else {; 6294 if (Hoption.Logx); 6295 xarr[i] = TMath::Log10(x1 + xlen);; 6296 else; 6297 xarr[i] = x1 + xlen;; 6298 if (Hoption.Logy); 6299 yarr[i] = TMath::Log10(y1);; 6300 else; 6301 yarr[i] = y1;; 6302 }; 6303 itarr[i] = n;; 6304 icount++;; 6305 i +=2;; 6306 n++;; 6307 }; 6308 return icount;; 6309}; 6310 ; 6311////////////////////////////////////////////////////////////////////////////////; 6312/// [Draw 1D histograms error bars.](\ref HP09); 6313 ; 6314void THistPainter::PaintErrors(Option_t *); 6315{; 6316 ; 6317 // On iOS, we do not highlight histogram, if it's not picked at the moment; 6318 // (but part of histogram (axis or pavestat) was picked, that's why this code; 6319 // is called at all. This conditional statement never executes on non-iOS platform.; 6320 if (gPad->PadInHighlightMode() && gPad->GetSelected() != fH) return;; 6321 ; 6322 const Int_t kBASEMARKER=8;; 6323 Double_t xp, yp, ex1, ex2, ey1, ey2;; 6324 Double_t delta;; 6325 Double_t s2x, s2y, bxsize, bysize, symbolsize, xerror, sbasex, sbasey;; 6326 Double_t xi1, xi2, xi3, xi4, yi1, yi2, yi3, yi4;; 6327 Double_t xmin, xmax, ymin, ymax;; 6328 Double_t logxmin = 0;; 6329 Double_t logymin = 0;; 6330 Double_t offset = 0.;; 6331 Double_t width = 0.;; 6332 Int_t i, k, npoints, first, last, fixbin;; 6333 Int_t if1 = 0;; 6334 Int_t if2 = 0;; 6335 Int_t drawmarker, errormarker;; 6336 Int_t option0, option1, option2, option3, option4, optionE, optionEX0, optionI0;; 6337 static Float_t cxx[30] = {1.0,1.0,0.5,0.5,1.0,1.0,0.5,0.6,1.0,0.5,0.5,1.0,0.5,0.6,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 6338 static Float_t cyy[30] = {1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.5,0.5,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 6339 ; 6340 std::vector<Double_t> xline, yline;; 6341 option0 = option1 = option2 = option3 = option4 = optionE = optionEX0 = optionI0 = 0;; 6342 if (Hoption.Error >= 40) {Hoption.Error -=40; option0 = 1;}; 6343 if (Int_t(Hoption.E",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:236086,Testability,log,logxmin,236086,"ine.empty() || yline.empty())) {; 6394 Error(""PaintErrors"", ""too many points, out of memory"");; 6395 return;; 6396 }; 6397 if1 = 1;; 6398 if2 = 2*npoints;; 6399 }; 6400 ; 6401 // compute the offset of the error bars due to the symbol size; 6402 s2x = gPad->PixeltoX(Int_t(0.5*sbasex)) - gPad->PixeltoX(0);; 6403 s2y =-gPad->PixeltoY(Int_t(0.5*sbasey)) + gPad->PixeltoY(0);; 6404 ; 6405 // compute size of the lines at the end of the error bars; 6406 Int_t dxend = Int_t(gStyle->GetEndErrorSize());; 6407 bxsize = gPad->PixeltoX(dxend) - gPad->PixeltoX(0);; 6408 bysize =-gPad->PixeltoY(dxend) + gPad->PixeltoY(0);; 6409 ; 6410 ; 6411 if (fixbin) {; 6412 if (Hoption.Logx) xp = TMath::Power(10,Hparam.xmin) + 0.5*Hparam.xbinsize;; 6413 else xp = Hparam.xmin + 0.5*Hparam.xbinsize;; 6414 } else {; 6415 delta = fH->GetBinWidth(first);; 6416 xp = fH->GetBinLowEdge(first) + 0.5*delta;; 6417 }; 6418 ; 6419 // if errormarker = 0 or symbolsize = 0. no symbol is drawn; 6420 if (Hoption.Logx) logxmin = TMath::Power(10,Hparam.xmin);; 6421 if (Hoption.Logy) logymin = TMath::Power(10,Hparam.ymin);; 6422 ; 6423 // ---------------------- Loop over the points---------------------; 6424 for (k=first; k<=last; k++) {; 6425 ; 6426 // get the data; 6427 // xp = X position of the current point; 6428 // yp = Y position of the current point; 6429 // ex1 = Low X error; 6430 // ex2 = Up X error; 6431 // ey1 = Low Y error; 6432 // ey2 = Up Y error; 6433 // (xi,yi) = Error bars coordinates; 6434 ; 6435 // apply offset on errors for bar histograms; 6436 Double_t xminTmp = gPad->XtoPad(fXaxis->GetBinLowEdge(k));; 6437 Double_t xmaxTmp = gPad->XtoPad(fXaxis->GetBinUpEdge(k));; 6438 if (Hoption.Logx) {; 6439 xminTmp = TMath::Power(10, xminTmp);; 6440 xmaxTmp = TMath::Power(10, xmaxTmp);; 6441 }; 6442 Double_t w = (xmaxTmp-xminTmp)*width;; 6443 xminTmp += offset*(xmaxTmp-xminTmp);; 6444 xmaxTmp = xminTmp + w;; 6445 xp = (xminTmp+xmaxTmp)/2.;; 6446 ; 6447 if (Hoption.Logx) {; 6448 if (xp <= 0) goto L30;; 6449 ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:236150,Testability,log,logymin,236150," many points, out of memory"");; 6395 return;; 6396 }; 6397 if1 = 1;; 6398 if2 = 2*npoints;; 6399 }; 6400 ; 6401 // compute the offset of the error bars due to the symbol size; 6402 s2x = gPad->PixeltoX(Int_t(0.5*sbasex)) - gPad->PixeltoX(0);; 6403 s2y =-gPad->PixeltoY(Int_t(0.5*sbasey)) + gPad->PixeltoY(0);; 6404 ; 6405 // compute size of the lines at the end of the error bars; 6406 Int_t dxend = Int_t(gStyle->GetEndErrorSize());; 6407 bxsize = gPad->PixeltoX(dxend) - gPad->PixeltoX(0);; 6408 bysize =-gPad->PixeltoY(dxend) + gPad->PixeltoY(0);; 6409 ; 6410 ; 6411 if (fixbin) {; 6412 if (Hoption.Logx) xp = TMath::Power(10,Hparam.xmin) + 0.5*Hparam.xbinsize;; 6413 else xp = Hparam.xmin + 0.5*Hparam.xbinsize;; 6414 } else {; 6415 delta = fH->GetBinWidth(first);; 6416 xp = fH->GetBinLowEdge(first) + 0.5*delta;; 6417 }; 6418 ; 6419 // if errormarker = 0 or symbolsize = 0. no symbol is drawn; 6420 if (Hoption.Logx) logxmin = TMath::Power(10,Hparam.xmin);; 6421 if (Hoption.Logy) logymin = TMath::Power(10,Hparam.ymin);; 6422 ; 6423 // ---------------------- Loop over the points---------------------; 6424 for (k=first; k<=last; k++) {; 6425 ; 6426 // get the data; 6427 // xp = X position of the current point; 6428 // yp = Y position of the current point; 6429 // ex1 = Low X error; 6430 // ex2 = Up X error; 6431 // ey1 = Low Y error; 6432 // ey2 = Up Y error; 6433 // (xi,yi) = Error bars coordinates; 6434 ; 6435 // apply offset on errors for bar histograms; 6436 Double_t xminTmp = gPad->XtoPad(fXaxis->GetBinLowEdge(k));; 6437 Double_t xmaxTmp = gPad->XtoPad(fXaxis->GetBinUpEdge(k));; 6438 if (Hoption.Logx) {; 6439 xminTmp = TMath::Power(10, xminTmp);; 6440 xmaxTmp = TMath::Power(10, xmaxTmp);; 6441 }; 6442 Double_t w = (xmaxTmp-xminTmp)*width;; 6443 xminTmp += offset*(xmaxTmp-xminTmp);; 6444 xmaxTmp = xminTmp + w;; 6445 xp = (xminTmp+xmaxTmp)/2.;; 6446 ; 6447 if (Hoption.Logx) {; 6448 if (xp <= 0) goto L30;; 6449 if (xp < logxmin) goto L30;; 6450 if (xp > TMath::Power(10,xmax)",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:237109,Testability,log,logxmin,237109,"---------- Loop over the points---------------------; 6424 for (k=first; k<=last; k++) {; 6425 ; 6426 // get the data; 6427 // xp = X position of the current point; 6428 // yp = Y position of the current point; 6429 // ex1 = Low X error; 6430 // ex2 = Up X error; 6431 // ey1 = Low Y error; 6432 // ey2 = Up Y error; 6433 // (xi,yi) = Error bars coordinates; 6434 ; 6435 // apply offset on errors for bar histograms; 6436 Double_t xminTmp = gPad->XtoPad(fXaxis->GetBinLowEdge(k));; 6437 Double_t xmaxTmp = gPad->XtoPad(fXaxis->GetBinUpEdge(k));; 6438 if (Hoption.Logx) {; 6439 xminTmp = TMath::Power(10, xminTmp);; 6440 xmaxTmp = TMath::Power(10, xmaxTmp);; 6441 }; 6442 Double_t w = (xmaxTmp-xminTmp)*width;; 6443 xminTmp += offset*(xmaxTmp-xminTmp);; 6444 xmaxTmp = xminTmp + w;; 6445 xp = (xminTmp+xmaxTmp)/2.;; 6446 ; 6447 if (Hoption.Logx) {; 6448 if (xp <= 0) goto L30;; 6449 if (xp < logxmin) goto L30;; 6450 if (xp > TMath::Power(10,xmax)) break;; 6451 } else {; 6452 if (xp < xmin) goto L30;; 6453 if (xp > xmax) break;; 6454 }; 6455 yp = factor*fH->GetBinContent(k);; 6456 if (optionI0 && yp==0) goto L30;; 6457 if (fixbin) {; 6458 ex1 = xerror*Hparam.xbinsize;; 6459 } else {; 6460 delta = fH->GetBinWidth(k);; 6461 ex1 = xerror*delta;; 6462 }; 6463 if (fH->GetBinErrorOption() == TH1::kNormal) {; 6464 ey1 = factor*fH->GetBinError(k);; 6465 ey2 = ey1;; 6466 } else {; 6467 ey1 = factor*fH->GetBinErrorLow(k);; 6468 ey2 = factor*fH->GetBinErrorUp(k);; 6469 }; 6470 ex2 = ex1;; 6471 ; 6472 xi4 = xp;; 6473 xi3 = xp;; 6474 xi2 = xp + ex2;; 6475 xi1 = xp - ex1;; 6476 ; 6477 yi1 = yp;; 6478 yi2 = yp;; 6479 yi3 = yp - ey1;; 6480 yi4 = yp + ey2;; 6481 ; 6482 // take the LOG if necessary; 6483 if (Hoption.Logx) {; 6484 xi1 = TMath::Log10(TMath::Max(xi1,logxmin));; 6485 xi2 = TMath::Log10(TMath::Max(xi2,logxmin));; 6486 xi3 = TMath::Log10(TMath::Max(xi3,logxmin));; 6487 xi4 = TMath::Log10(TMath::Max(xi4,logxmin));; 6488 }; 6489 if (Hoption.Logy) {; 6490 yi1 = TMath::Log10(TMath::Max(yi1,lo",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:237979,Testability,log,logxmin,237979,"option.Logx) {; 6448 if (xp <= 0) goto L30;; 6449 if (xp < logxmin) goto L30;; 6450 if (xp > TMath::Power(10,xmax)) break;; 6451 } else {; 6452 if (xp < xmin) goto L30;; 6453 if (xp > xmax) break;; 6454 }; 6455 yp = factor*fH->GetBinContent(k);; 6456 if (optionI0 && yp==0) goto L30;; 6457 if (fixbin) {; 6458 ex1 = xerror*Hparam.xbinsize;; 6459 } else {; 6460 delta = fH->GetBinWidth(k);; 6461 ex1 = xerror*delta;; 6462 }; 6463 if (fH->GetBinErrorOption() == TH1::kNormal) {; 6464 ey1 = factor*fH->GetBinError(k);; 6465 ey2 = ey1;; 6466 } else {; 6467 ey1 = factor*fH->GetBinErrorLow(k);; 6468 ey2 = factor*fH->GetBinErrorUp(k);; 6469 }; 6470 ex2 = ex1;; 6471 ; 6472 xi4 = xp;; 6473 xi3 = xp;; 6474 xi2 = xp + ex2;; 6475 xi1 = xp - ex1;; 6476 ; 6477 yi1 = yp;; 6478 yi2 = yp;; 6479 yi3 = yp - ey1;; 6480 yi4 = yp + ey2;; 6481 ; 6482 // take the LOG if necessary; 6483 if (Hoption.Logx) {; 6484 xi1 = TMath::Log10(TMath::Max(xi1,logxmin));; 6485 xi2 = TMath::Log10(TMath::Max(xi2,logxmin));; 6486 xi3 = TMath::Log10(TMath::Max(xi3,logxmin));; 6487 xi4 = TMath::Log10(TMath::Max(xi4,logxmin));; 6488 }; 6489 if (Hoption.Logy) {; 6490 yi1 = TMath::Log10(TMath::Max(yi1,logymin));; 6491 yi2 = TMath::Log10(TMath::Max(yi2,logymin));; 6492 yi3 = TMath::Log10(TMath::Max(yi3,logymin));; 6493 yi4 = TMath::Log10(TMath::Max(yi4,logymin));; 6494 }; 6495 ; 6496 // test if error bars are not outside the limits; 6497 // otherwise they are truncated; 6498 ; 6499 xi1 = TMath::Max(xi1,xmin);; 6500 xi2 = TMath::Min(xi2,xmax);; 6501 yi3 = TMath::Max(yi3,ymin);; 6502 yi4 = TMath::Min(yi4,ymax);; 6503 ; 6504 // test if the marker is on the frame limits. If ""Yes"", the; 6505 // marker will not be drawn and the error bars will be readjusted.; 6506 ; 6507 drawmarker = kTRUE;; 6508 if (!option0 && !option3) {; 6509 if (Hoption.Logy && yp < logymin) goto L30;; 6510 if (yi1 < ymin || yi1 > ymax) goto L30;; 6511 if (Hoption.Error != 0 && yp == 0 && ey1 <= 0) drawmarker = kFALSE;; 6512 }; 6513 if (!symbolsize || !e",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:238030,Testability,log,logxmin,238030,"option.Logx) {; 6448 if (xp <= 0) goto L30;; 6449 if (xp < logxmin) goto L30;; 6450 if (xp > TMath::Power(10,xmax)) break;; 6451 } else {; 6452 if (xp < xmin) goto L30;; 6453 if (xp > xmax) break;; 6454 }; 6455 yp = factor*fH->GetBinContent(k);; 6456 if (optionI0 && yp==0) goto L30;; 6457 if (fixbin) {; 6458 ex1 = xerror*Hparam.xbinsize;; 6459 } else {; 6460 delta = fH->GetBinWidth(k);; 6461 ex1 = xerror*delta;; 6462 }; 6463 if (fH->GetBinErrorOption() == TH1::kNormal) {; 6464 ey1 = factor*fH->GetBinError(k);; 6465 ey2 = ey1;; 6466 } else {; 6467 ey1 = factor*fH->GetBinErrorLow(k);; 6468 ey2 = factor*fH->GetBinErrorUp(k);; 6469 }; 6470 ex2 = ex1;; 6471 ; 6472 xi4 = xp;; 6473 xi3 = xp;; 6474 xi2 = xp + ex2;; 6475 xi1 = xp - ex1;; 6476 ; 6477 yi1 = yp;; 6478 yi2 = yp;; 6479 yi3 = yp - ey1;; 6480 yi4 = yp + ey2;; 6481 ; 6482 // take the LOG if necessary; 6483 if (Hoption.Logx) {; 6484 xi1 = TMath::Log10(TMath::Max(xi1,logxmin));; 6485 xi2 = TMath::Log10(TMath::Max(xi2,logxmin));; 6486 xi3 = TMath::Log10(TMath::Max(xi3,logxmin));; 6487 xi4 = TMath::Log10(TMath::Max(xi4,logxmin));; 6488 }; 6489 if (Hoption.Logy) {; 6490 yi1 = TMath::Log10(TMath::Max(yi1,logymin));; 6491 yi2 = TMath::Log10(TMath::Max(yi2,logymin));; 6492 yi3 = TMath::Log10(TMath::Max(yi3,logymin));; 6493 yi4 = TMath::Log10(TMath::Max(yi4,logymin));; 6494 }; 6495 ; 6496 // test if error bars are not outside the limits; 6497 // otherwise they are truncated; 6498 ; 6499 xi1 = TMath::Max(xi1,xmin);; 6500 xi2 = TMath::Min(xi2,xmax);; 6501 yi3 = TMath::Max(yi3,ymin);; 6502 yi4 = TMath::Min(yi4,ymax);; 6503 ; 6504 // test if the marker is on the frame limits. If ""Yes"", the; 6505 // marker will not be drawn and the error bars will be readjusted.; 6506 ; 6507 drawmarker = kTRUE;; 6508 if (!option0 && !option3) {; 6509 if (Hoption.Logy && yp < logymin) goto L30;; 6510 if (yi1 < ymin || yi1 > ymax) goto L30;; 6511 if (Hoption.Error != 0 && yp == 0 && ey1 <= 0) drawmarker = kFALSE;; 6512 }; 6513 if (!symbolsize || !e",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:238081,Testability,log,logxmin,238081,"option.Logx) {; 6448 if (xp <= 0) goto L30;; 6449 if (xp < logxmin) goto L30;; 6450 if (xp > TMath::Power(10,xmax)) break;; 6451 } else {; 6452 if (xp < xmin) goto L30;; 6453 if (xp > xmax) break;; 6454 }; 6455 yp = factor*fH->GetBinContent(k);; 6456 if (optionI0 && yp==0) goto L30;; 6457 if (fixbin) {; 6458 ex1 = xerror*Hparam.xbinsize;; 6459 } else {; 6460 delta = fH->GetBinWidth(k);; 6461 ex1 = xerror*delta;; 6462 }; 6463 if (fH->GetBinErrorOption() == TH1::kNormal) {; 6464 ey1 = factor*fH->GetBinError(k);; 6465 ey2 = ey1;; 6466 } else {; 6467 ey1 = factor*fH->GetBinErrorLow(k);; 6468 ey2 = factor*fH->GetBinErrorUp(k);; 6469 }; 6470 ex2 = ex1;; 6471 ; 6472 xi4 = xp;; 6473 xi3 = xp;; 6474 xi2 = xp + ex2;; 6475 xi1 = xp - ex1;; 6476 ; 6477 yi1 = yp;; 6478 yi2 = yp;; 6479 yi3 = yp - ey1;; 6480 yi4 = yp + ey2;; 6481 ; 6482 // take the LOG if necessary; 6483 if (Hoption.Logx) {; 6484 xi1 = TMath::Log10(TMath::Max(xi1,logxmin));; 6485 xi2 = TMath::Log10(TMath::Max(xi2,logxmin));; 6486 xi3 = TMath::Log10(TMath::Max(xi3,logxmin));; 6487 xi4 = TMath::Log10(TMath::Max(xi4,logxmin));; 6488 }; 6489 if (Hoption.Logy) {; 6490 yi1 = TMath::Log10(TMath::Max(yi1,logymin));; 6491 yi2 = TMath::Log10(TMath::Max(yi2,logymin));; 6492 yi3 = TMath::Log10(TMath::Max(yi3,logymin));; 6493 yi4 = TMath::Log10(TMath::Max(yi4,logymin));; 6494 }; 6495 ; 6496 // test if error bars are not outside the limits; 6497 // otherwise they are truncated; 6498 ; 6499 xi1 = TMath::Max(xi1,xmin);; 6500 xi2 = TMath::Min(xi2,xmax);; 6501 yi3 = TMath::Max(yi3,ymin);; 6502 yi4 = TMath::Min(yi4,ymax);; 6503 ; 6504 // test if the marker is on the frame limits. If ""Yes"", the; 6505 // marker will not be drawn and the error bars will be readjusted.; 6506 ; 6507 drawmarker = kTRUE;; 6508 if (!option0 && !option3) {; 6509 if (Hoption.Logy && yp < logymin) goto L30;; 6510 if (yi1 < ymin || yi1 > ymax) goto L30;; 6511 if (Hoption.Error != 0 && yp == 0 && ey1 <= 0) drawmarker = kFALSE;; 6512 }; 6513 if (!symbolsize || !e",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:238132,Testability,log,logxmin,238132,"option.Logx) {; 6448 if (xp <= 0) goto L30;; 6449 if (xp < logxmin) goto L30;; 6450 if (xp > TMath::Power(10,xmax)) break;; 6451 } else {; 6452 if (xp < xmin) goto L30;; 6453 if (xp > xmax) break;; 6454 }; 6455 yp = factor*fH->GetBinContent(k);; 6456 if (optionI0 && yp==0) goto L30;; 6457 if (fixbin) {; 6458 ex1 = xerror*Hparam.xbinsize;; 6459 } else {; 6460 delta = fH->GetBinWidth(k);; 6461 ex1 = xerror*delta;; 6462 }; 6463 if (fH->GetBinErrorOption() == TH1::kNormal) {; 6464 ey1 = factor*fH->GetBinError(k);; 6465 ey2 = ey1;; 6466 } else {; 6467 ey1 = factor*fH->GetBinErrorLow(k);; 6468 ey2 = factor*fH->GetBinErrorUp(k);; 6469 }; 6470 ex2 = ex1;; 6471 ; 6472 xi4 = xp;; 6473 xi3 = xp;; 6474 xi2 = xp + ex2;; 6475 xi1 = xp - ex1;; 6476 ; 6477 yi1 = yp;; 6478 yi2 = yp;; 6479 yi3 = yp - ey1;; 6480 yi4 = yp + ey2;; 6481 ; 6482 // take the LOG if necessary; 6483 if (Hoption.Logx) {; 6484 xi1 = TMath::Log10(TMath::Max(xi1,logxmin));; 6485 xi2 = TMath::Log10(TMath::Max(xi2,logxmin));; 6486 xi3 = TMath::Log10(TMath::Max(xi3,logxmin));; 6487 xi4 = TMath::Log10(TMath::Max(xi4,logxmin));; 6488 }; 6489 if (Hoption.Logy) {; 6490 yi1 = TMath::Log10(TMath::Max(yi1,logymin));; 6491 yi2 = TMath::Log10(TMath::Max(yi2,logymin));; 6492 yi3 = TMath::Log10(TMath::Max(yi3,logymin));; 6493 yi4 = TMath::Log10(TMath::Max(yi4,logymin));; 6494 }; 6495 ; 6496 // test if error bars are not outside the limits; 6497 // otherwise they are truncated; 6498 ; 6499 xi1 = TMath::Max(xi1,xmin);; 6500 xi2 = TMath::Min(xi2,xmax);; 6501 yi3 = TMath::Max(yi3,ymin);; 6502 yi4 = TMath::Min(yi4,ymax);; 6503 ; 6504 // test if the marker is on the frame limits. If ""Yes"", the; 6505 // marker will not be drawn and the error bars will be readjusted.; 6506 ; 6507 drawmarker = kTRUE;; 6508 if (!option0 && !option3) {; 6509 if (Hoption.Logy && yp < logymin) goto L30;; 6510 if (yi1 < ymin || yi1 > ymax) goto L30;; 6511 if (Hoption.Error != 0 && yp == 0 && ey1 <= 0) drawmarker = kFALSE;; 6512 }; 6513 if (!symbolsize || !e",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:238217,Testability,log,logymin,238217,"Width(k);; 6461 ex1 = xerror*delta;; 6462 }; 6463 if (fH->GetBinErrorOption() == TH1::kNormal) {; 6464 ey1 = factor*fH->GetBinError(k);; 6465 ey2 = ey1;; 6466 } else {; 6467 ey1 = factor*fH->GetBinErrorLow(k);; 6468 ey2 = factor*fH->GetBinErrorUp(k);; 6469 }; 6470 ex2 = ex1;; 6471 ; 6472 xi4 = xp;; 6473 xi3 = xp;; 6474 xi2 = xp + ex2;; 6475 xi1 = xp - ex1;; 6476 ; 6477 yi1 = yp;; 6478 yi2 = yp;; 6479 yi3 = yp - ey1;; 6480 yi4 = yp + ey2;; 6481 ; 6482 // take the LOG if necessary; 6483 if (Hoption.Logx) {; 6484 xi1 = TMath::Log10(TMath::Max(xi1,logxmin));; 6485 xi2 = TMath::Log10(TMath::Max(xi2,logxmin));; 6486 xi3 = TMath::Log10(TMath::Max(xi3,logxmin));; 6487 xi4 = TMath::Log10(TMath::Max(xi4,logxmin));; 6488 }; 6489 if (Hoption.Logy) {; 6490 yi1 = TMath::Log10(TMath::Max(yi1,logymin));; 6491 yi2 = TMath::Log10(TMath::Max(yi2,logymin));; 6492 yi3 = TMath::Log10(TMath::Max(yi3,logymin));; 6493 yi4 = TMath::Log10(TMath::Max(yi4,logymin));; 6494 }; 6495 ; 6496 // test if error bars are not outside the limits; 6497 // otherwise they are truncated; 6498 ; 6499 xi1 = TMath::Max(xi1,xmin);; 6500 xi2 = TMath::Min(xi2,xmax);; 6501 yi3 = TMath::Max(yi3,ymin);; 6502 yi4 = TMath::Min(yi4,ymax);; 6503 ; 6504 // test if the marker is on the frame limits. If ""Yes"", the; 6505 // marker will not be drawn and the error bars will be readjusted.; 6506 ; 6507 drawmarker = kTRUE;; 6508 if (!option0 && !option3) {; 6509 if (Hoption.Logy && yp < logymin) goto L30;; 6510 if (yi1 < ymin || yi1 > ymax) goto L30;; 6511 if (Hoption.Error != 0 && yp == 0 && ey1 <= 0) drawmarker = kFALSE;; 6512 }; 6513 if (!symbolsize || !errormarker) drawmarker = kFALSE;; 6514 ; 6515 // draw the error rectangles; 6516 if (option2) {; 6517 if (yi3 >= ymax) goto L30;; 6518 if (yi4 <= ymin) goto L30;; 6519 gPad->PaintBox(xi1,yi3,xi2,yi4);; 6520 }; 6521 ; 6522 // keep points for fill area drawing; 6523 if (option3) {; 6524 xline[if1-1] = xi3;; 6525 xline[if2-1] = xi3;; 6526 yline[if1-1] = yi4;; 6527 yline[if2-1] = y",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:238268,Testability,log,logymin,238268,"Width(k);; 6461 ex1 = xerror*delta;; 6462 }; 6463 if (fH->GetBinErrorOption() == TH1::kNormal) {; 6464 ey1 = factor*fH->GetBinError(k);; 6465 ey2 = ey1;; 6466 } else {; 6467 ey1 = factor*fH->GetBinErrorLow(k);; 6468 ey2 = factor*fH->GetBinErrorUp(k);; 6469 }; 6470 ex2 = ex1;; 6471 ; 6472 xi4 = xp;; 6473 xi3 = xp;; 6474 xi2 = xp + ex2;; 6475 xi1 = xp - ex1;; 6476 ; 6477 yi1 = yp;; 6478 yi2 = yp;; 6479 yi3 = yp - ey1;; 6480 yi4 = yp + ey2;; 6481 ; 6482 // take the LOG if necessary; 6483 if (Hoption.Logx) {; 6484 xi1 = TMath::Log10(TMath::Max(xi1,logxmin));; 6485 xi2 = TMath::Log10(TMath::Max(xi2,logxmin));; 6486 xi3 = TMath::Log10(TMath::Max(xi3,logxmin));; 6487 xi4 = TMath::Log10(TMath::Max(xi4,logxmin));; 6488 }; 6489 if (Hoption.Logy) {; 6490 yi1 = TMath::Log10(TMath::Max(yi1,logymin));; 6491 yi2 = TMath::Log10(TMath::Max(yi2,logymin));; 6492 yi3 = TMath::Log10(TMath::Max(yi3,logymin));; 6493 yi4 = TMath::Log10(TMath::Max(yi4,logymin));; 6494 }; 6495 ; 6496 // test if error bars are not outside the limits; 6497 // otherwise they are truncated; 6498 ; 6499 xi1 = TMath::Max(xi1,xmin);; 6500 xi2 = TMath::Min(xi2,xmax);; 6501 yi3 = TMath::Max(yi3,ymin);; 6502 yi4 = TMath::Min(yi4,ymax);; 6503 ; 6504 // test if the marker is on the frame limits. If ""Yes"", the; 6505 // marker will not be drawn and the error bars will be readjusted.; 6506 ; 6507 drawmarker = kTRUE;; 6508 if (!option0 && !option3) {; 6509 if (Hoption.Logy && yp < logymin) goto L30;; 6510 if (yi1 < ymin || yi1 > ymax) goto L30;; 6511 if (Hoption.Error != 0 && yp == 0 && ey1 <= 0) drawmarker = kFALSE;; 6512 }; 6513 if (!symbolsize || !errormarker) drawmarker = kFALSE;; 6514 ; 6515 // draw the error rectangles; 6516 if (option2) {; 6517 if (yi3 >= ymax) goto L30;; 6518 if (yi4 <= ymin) goto L30;; 6519 gPad->PaintBox(xi1,yi3,xi2,yi4);; 6520 }; 6521 ; 6522 // keep points for fill area drawing; 6523 if (option3) {; 6524 xline[if1-1] = xi3;; 6525 xline[if2-1] = xi3;; 6526 yline[if1-1] = yi4;; 6527 yline[if2-1] = y",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:238319,Testability,log,logymin,238319,"Width(k);; 6461 ex1 = xerror*delta;; 6462 }; 6463 if (fH->GetBinErrorOption() == TH1::kNormal) {; 6464 ey1 = factor*fH->GetBinError(k);; 6465 ey2 = ey1;; 6466 } else {; 6467 ey1 = factor*fH->GetBinErrorLow(k);; 6468 ey2 = factor*fH->GetBinErrorUp(k);; 6469 }; 6470 ex2 = ex1;; 6471 ; 6472 xi4 = xp;; 6473 xi3 = xp;; 6474 xi2 = xp + ex2;; 6475 xi1 = xp - ex1;; 6476 ; 6477 yi1 = yp;; 6478 yi2 = yp;; 6479 yi3 = yp - ey1;; 6480 yi4 = yp + ey2;; 6481 ; 6482 // take the LOG if necessary; 6483 if (Hoption.Logx) {; 6484 xi1 = TMath::Log10(TMath::Max(xi1,logxmin));; 6485 xi2 = TMath::Log10(TMath::Max(xi2,logxmin));; 6486 xi3 = TMath::Log10(TMath::Max(xi3,logxmin));; 6487 xi4 = TMath::Log10(TMath::Max(xi4,logxmin));; 6488 }; 6489 if (Hoption.Logy) {; 6490 yi1 = TMath::Log10(TMath::Max(yi1,logymin));; 6491 yi2 = TMath::Log10(TMath::Max(yi2,logymin));; 6492 yi3 = TMath::Log10(TMath::Max(yi3,logymin));; 6493 yi4 = TMath::Log10(TMath::Max(yi4,logymin));; 6494 }; 6495 ; 6496 // test if error bars are not outside the limits; 6497 // otherwise they are truncated; 6498 ; 6499 xi1 = TMath::Max(xi1,xmin);; 6500 xi2 = TMath::Min(xi2,xmax);; 6501 yi3 = TMath::Max(yi3,ymin);; 6502 yi4 = TMath::Min(yi4,ymax);; 6503 ; 6504 // test if the marker is on the frame limits. If ""Yes"", the; 6505 // marker will not be drawn and the error bars will be readjusted.; 6506 ; 6507 drawmarker = kTRUE;; 6508 if (!option0 && !option3) {; 6509 if (Hoption.Logy && yp < logymin) goto L30;; 6510 if (yi1 < ymin || yi1 > ymax) goto L30;; 6511 if (Hoption.Error != 0 && yp == 0 && ey1 <= 0) drawmarker = kFALSE;; 6512 }; 6513 if (!symbolsize || !errormarker) drawmarker = kFALSE;; 6514 ; 6515 // draw the error rectangles; 6516 if (option2) {; 6517 if (yi3 >= ymax) goto L30;; 6518 if (yi4 <= ymin) goto L30;; 6519 gPad->PaintBox(xi1,yi3,xi2,yi4);; 6520 }; 6521 ; 6522 // keep points for fill area drawing; 6523 if (option3) {; 6524 xline[if1-1] = xi3;; 6525 xline[if2-1] = xi3;; 6526 yline[if1-1] = yi4;; 6527 yline[if2-1] = y",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:238370,Testability,log,logymin,238370,"Width(k);; 6461 ex1 = xerror*delta;; 6462 }; 6463 if (fH->GetBinErrorOption() == TH1::kNormal) {; 6464 ey1 = factor*fH->GetBinError(k);; 6465 ey2 = ey1;; 6466 } else {; 6467 ey1 = factor*fH->GetBinErrorLow(k);; 6468 ey2 = factor*fH->GetBinErrorUp(k);; 6469 }; 6470 ex2 = ex1;; 6471 ; 6472 xi4 = xp;; 6473 xi3 = xp;; 6474 xi2 = xp + ex2;; 6475 xi1 = xp - ex1;; 6476 ; 6477 yi1 = yp;; 6478 yi2 = yp;; 6479 yi3 = yp - ey1;; 6480 yi4 = yp + ey2;; 6481 ; 6482 // take the LOG if necessary; 6483 if (Hoption.Logx) {; 6484 xi1 = TMath::Log10(TMath::Max(xi1,logxmin));; 6485 xi2 = TMath::Log10(TMath::Max(xi2,logxmin));; 6486 xi3 = TMath::Log10(TMath::Max(xi3,logxmin));; 6487 xi4 = TMath::Log10(TMath::Max(xi4,logxmin));; 6488 }; 6489 if (Hoption.Logy) {; 6490 yi1 = TMath::Log10(TMath::Max(yi1,logymin));; 6491 yi2 = TMath::Log10(TMath::Max(yi2,logymin));; 6492 yi3 = TMath::Log10(TMath::Max(yi3,logymin));; 6493 yi4 = TMath::Log10(TMath::Max(yi4,logymin));; 6494 }; 6495 ; 6496 // test if error bars are not outside the limits; 6497 // otherwise they are truncated; 6498 ; 6499 xi1 = TMath::Max(xi1,xmin);; 6500 xi2 = TMath::Min(xi2,xmax);; 6501 yi3 = TMath::Max(yi3,ymin);; 6502 yi4 = TMath::Min(yi4,ymax);; 6503 ; 6504 // test if the marker is on the frame limits. If ""Yes"", the; 6505 // marker will not be drawn and the error bars will be readjusted.; 6506 ; 6507 drawmarker = kTRUE;; 6508 if (!option0 && !option3) {; 6509 if (Hoption.Logy && yp < logymin) goto L30;; 6510 if (yi1 < ymin || yi1 > ymax) goto L30;; 6511 if (Hoption.Error != 0 && yp == 0 && ey1 <= 0) drawmarker = kFALSE;; 6512 }; 6513 if (!symbolsize || !errormarker) drawmarker = kFALSE;; 6514 ; 6515 // draw the error rectangles; 6516 if (option2) {; 6517 if (yi3 >= ymax) goto L30;; 6518 if (yi4 <= ymin) goto L30;; 6519 gPad->PaintBox(xi1,yi3,xi2,yi4);; 6520 }; 6521 ; 6522 // keep points for fill area drawing; 6523 if (option3) {; 6524 xline[if1-1] = xi3;; 6525 xline[if2-1] = xi3;; 6526 yline[if1-1] = yi4;; 6527 yline[if2-1] = y",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:238405,Testability,test,test,238405,"Width(k);; 6461 ex1 = xerror*delta;; 6462 }; 6463 if (fH->GetBinErrorOption() == TH1::kNormal) {; 6464 ey1 = factor*fH->GetBinError(k);; 6465 ey2 = ey1;; 6466 } else {; 6467 ey1 = factor*fH->GetBinErrorLow(k);; 6468 ey2 = factor*fH->GetBinErrorUp(k);; 6469 }; 6470 ex2 = ex1;; 6471 ; 6472 xi4 = xp;; 6473 xi3 = xp;; 6474 xi2 = xp + ex2;; 6475 xi1 = xp - ex1;; 6476 ; 6477 yi1 = yp;; 6478 yi2 = yp;; 6479 yi3 = yp - ey1;; 6480 yi4 = yp + ey2;; 6481 ; 6482 // take the LOG if necessary; 6483 if (Hoption.Logx) {; 6484 xi1 = TMath::Log10(TMath::Max(xi1,logxmin));; 6485 xi2 = TMath::Log10(TMath::Max(xi2,logxmin));; 6486 xi3 = TMath::Log10(TMath::Max(xi3,logxmin));; 6487 xi4 = TMath::Log10(TMath::Max(xi4,logxmin));; 6488 }; 6489 if (Hoption.Logy) {; 6490 yi1 = TMath::Log10(TMath::Max(yi1,logymin));; 6491 yi2 = TMath::Log10(TMath::Max(yi2,logymin));; 6492 yi3 = TMath::Log10(TMath::Max(yi3,logymin));; 6493 yi4 = TMath::Log10(TMath::Max(yi4,logymin));; 6494 }; 6495 ; 6496 // test if error bars are not outside the limits; 6497 // otherwise they are truncated; 6498 ; 6499 xi1 = TMath::Max(xi1,xmin);; 6500 xi2 = TMath::Min(xi2,xmax);; 6501 yi3 = TMath::Max(yi3,ymin);; 6502 yi4 = TMath::Min(yi4,ymax);; 6503 ; 6504 // test if the marker is on the frame limits. If ""Yes"", the; 6505 // marker will not be drawn and the error bars will be readjusted.; 6506 ; 6507 drawmarker = kTRUE;; 6508 if (!option0 && !option3) {; 6509 if (Hoption.Logy && yp < logymin) goto L30;; 6510 if (yi1 < ymin || yi1 > ymax) goto L30;; 6511 if (Hoption.Error != 0 && yp == 0 && ey1 <= 0) drawmarker = kFALSE;; 6512 }; 6513 if (!symbolsize || !errormarker) drawmarker = kFALSE;; 6514 ; 6515 // draw the error rectangles; 6516 if (option2) {; 6517 if (yi3 >= ymax) goto L30;; 6518 if (yi4 <= ymin) goto L30;; 6519 gPad->PaintBox(xi1,yi3,xi2,yi4);; 6520 }; 6521 ; 6522 // keep points for fill area drawing; 6523 if (option3) {; 6524 xline[if1-1] = xi3;; 6525 xline[if2-1] = xi3;; 6526 yline[if1-1] = yi4;; 6527 yline[if2-1] = y",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:238648,Testability,test,test,238648,"Width(k);; 6461 ex1 = xerror*delta;; 6462 }; 6463 if (fH->GetBinErrorOption() == TH1::kNormal) {; 6464 ey1 = factor*fH->GetBinError(k);; 6465 ey2 = ey1;; 6466 } else {; 6467 ey1 = factor*fH->GetBinErrorLow(k);; 6468 ey2 = factor*fH->GetBinErrorUp(k);; 6469 }; 6470 ex2 = ex1;; 6471 ; 6472 xi4 = xp;; 6473 xi3 = xp;; 6474 xi2 = xp + ex2;; 6475 xi1 = xp - ex1;; 6476 ; 6477 yi1 = yp;; 6478 yi2 = yp;; 6479 yi3 = yp - ey1;; 6480 yi4 = yp + ey2;; 6481 ; 6482 // take the LOG if necessary; 6483 if (Hoption.Logx) {; 6484 xi1 = TMath::Log10(TMath::Max(xi1,logxmin));; 6485 xi2 = TMath::Log10(TMath::Max(xi2,logxmin));; 6486 xi3 = TMath::Log10(TMath::Max(xi3,logxmin));; 6487 xi4 = TMath::Log10(TMath::Max(xi4,logxmin));; 6488 }; 6489 if (Hoption.Logy) {; 6490 yi1 = TMath::Log10(TMath::Max(yi1,logymin));; 6491 yi2 = TMath::Log10(TMath::Max(yi2,logymin));; 6492 yi3 = TMath::Log10(TMath::Max(yi3,logymin));; 6493 yi4 = TMath::Log10(TMath::Max(yi4,logymin));; 6494 }; 6495 ; 6496 // test if error bars are not outside the limits; 6497 // otherwise they are truncated; 6498 ; 6499 xi1 = TMath::Max(xi1,xmin);; 6500 xi2 = TMath::Min(xi2,xmax);; 6501 yi3 = TMath::Max(yi3,ymin);; 6502 yi4 = TMath::Min(yi4,ymax);; 6503 ; 6504 // test if the marker is on the frame limits. If ""Yes"", the; 6505 // marker will not be drawn and the error bars will be readjusted.; 6506 ; 6507 drawmarker = kTRUE;; 6508 if (!option0 && !option3) {; 6509 if (Hoption.Logy && yp < logymin) goto L30;; 6510 if (yi1 < ymin || yi1 > ymax) goto L30;; 6511 if (Hoption.Error != 0 && yp == 0 && ey1 <= 0) drawmarker = kFALSE;; 6512 }; 6513 if (!symbolsize || !errormarker) drawmarker = kFALSE;; 6514 ; 6515 // draw the error rectangles; 6516 if (option2) {; 6517 if (yi3 >= ymax) goto L30;; 6518 if (yi4 <= ymin) goto L30;; 6519 gPad->PaintBox(xi1,yi3,xi2,yi4);; 6520 }; 6521 ; 6522 // keep points for fill area drawing; 6523 if (option3) {; 6524 xline[if1-1] = xi3;; 6525 xline[if2-1] = xi3;; 6526 yline[if1-1] = yi4;; 6527 yline[if2-1] = y",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:238876,Testability,log,logymin,238876,"y; 6483 if (Hoption.Logx) {; 6484 xi1 = TMath::Log10(TMath::Max(xi1,logxmin));; 6485 xi2 = TMath::Log10(TMath::Max(xi2,logxmin));; 6486 xi3 = TMath::Log10(TMath::Max(xi3,logxmin));; 6487 xi4 = TMath::Log10(TMath::Max(xi4,logxmin));; 6488 }; 6489 if (Hoption.Logy) {; 6490 yi1 = TMath::Log10(TMath::Max(yi1,logymin));; 6491 yi2 = TMath::Log10(TMath::Max(yi2,logymin));; 6492 yi3 = TMath::Log10(TMath::Max(yi3,logymin));; 6493 yi4 = TMath::Log10(TMath::Max(yi4,logymin));; 6494 }; 6495 ; 6496 // test if error bars are not outside the limits; 6497 // otherwise they are truncated; 6498 ; 6499 xi1 = TMath::Max(xi1,xmin);; 6500 xi2 = TMath::Min(xi2,xmax);; 6501 yi3 = TMath::Max(yi3,ymin);; 6502 yi4 = TMath::Min(yi4,ymax);; 6503 ; 6504 // test if the marker is on the frame limits. If ""Yes"", the; 6505 // marker will not be drawn and the error bars will be readjusted.; 6506 ; 6507 drawmarker = kTRUE;; 6508 if (!option0 && !option3) {; 6509 if (Hoption.Logy && yp < logymin) goto L30;; 6510 if (yi1 < ymin || yi1 > ymax) goto L30;; 6511 if (Hoption.Error != 0 && yp == 0 && ey1 <= 0) drawmarker = kFALSE;; 6512 }; 6513 if (!symbolsize || !errormarker) drawmarker = kFALSE;; 6514 ; 6515 // draw the error rectangles; 6516 if (option2) {; 6517 if (yi3 >= ymax) goto L30;; 6518 if (yi4 <= ymin) goto L30;; 6519 gPad->PaintBox(xi1,yi3,xi2,yi4);; 6520 }; 6521 ; 6522 // keep points for fill area drawing; 6523 if (option3) {; 6524 xline[if1-1] = xi3;; 6525 xline[if2-1] = xi3;; 6526 yline[if1-1] = yi4;; 6527 yline[if2-1] = yi3;; 6528 if1++;; 6529 if2--;; 6530 }; 6531 ; 6532 // draw the error bars; 6533 if (Hoption.Logy && yp < logymin) drawmarker = kFALSE;; 6534 if (optionE && drawmarker) {; 6535 if ((yi3 < yi1 - s2y) && (yi3 < ymax)) gPad->PaintLine(xi3,yi3,xi4,TMath::Min(yi1 - s2y,ymax));; 6536 if ((yi1 + s2y < yi4) && (yi4 > ymin)) gPad->PaintLine(xi3,TMath::Max(yi1 + s2y, ymin),xi4,yi4);; 6537 // don't duplicate the horizontal line; 6538 if (Hoption.Hist != 2) {; 6539 if (yi1<ymax && yi1>ymin",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:239535,Testability,log,logymin,239535,"Yes"", the; 6505 // marker will not be drawn and the error bars will be readjusted.; 6506 ; 6507 drawmarker = kTRUE;; 6508 if (!option0 && !option3) {; 6509 if (Hoption.Logy && yp < logymin) goto L30;; 6510 if (yi1 < ymin || yi1 > ymax) goto L30;; 6511 if (Hoption.Error != 0 && yp == 0 && ey1 <= 0) drawmarker = kFALSE;; 6512 }; 6513 if (!symbolsize || !errormarker) drawmarker = kFALSE;; 6514 ; 6515 // draw the error rectangles; 6516 if (option2) {; 6517 if (yi3 >= ymax) goto L30;; 6518 if (yi4 <= ymin) goto L30;; 6519 gPad->PaintBox(xi1,yi3,xi2,yi4);; 6520 }; 6521 ; 6522 // keep points for fill area drawing; 6523 if (option3) {; 6524 xline[if1-1] = xi3;; 6525 xline[if2-1] = xi3;; 6526 yline[if1-1] = yi4;; 6527 yline[if2-1] = yi3;; 6528 if1++;; 6529 if2--;; 6530 }; 6531 ; 6532 // draw the error bars; 6533 if (Hoption.Logy && yp < logymin) drawmarker = kFALSE;; 6534 if (optionE && drawmarker) {; 6535 if ((yi3 < yi1 - s2y) && (yi3 < ymax)) gPad->PaintLine(xi3,yi3,xi4,TMath::Min(yi1 - s2y,ymax));; 6536 if ((yi1 + s2y < yi4) && (yi4 > ymin)) gPad->PaintLine(xi3,TMath::Max(yi1 + s2y, ymin),xi4,yi4);; 6537 // don't duplicate the horizontal line; 6538 if (Hoption.Hist != 2) {; 6539 if (yi1<ymax && yi1>ymin) {; 6540 if (xi1 < xi3 - s2x) gPad->PaintLine(xi1,yi1,xi3 - s2x,yi2);; 6541 if (xi3 + s2x < xi2) gPad->PaintLine(xi3 + s2x,yi1,xi2,yi2);; 6542 }; 6543 }; 6544 }; 6545 if (optionE && !drawmarker && (ey1 != 0 || ey2 !=0)) {; 6546 if ((yi3 < yi1) && (yi3 < ymax)) gPad->PaintLine(xi3,yi3,xi4,TMath::Min(yi1,ymax));; 6547 if ((yi1 < yi4) && (yi4 > ymin)) gPad->PaintLine(xi3,TMath::Max(yi1,ymin),xi4,yi4);; 6548 // don't duplicate the horizontal line; 6549 if (Hoption.Hist != 2) {; 6550 if (yi1<ymax && yi1>ymin) {; 6551 if (xi1 < xi3) gPad->PaintLine(xi1,yi1,xi3,yi2);; 6552 if (xi3 < xi2) gPad->PaintLine(xi3,yi1,xi2,yi2);; 6553 }; 6554 }; 6555 }; 6556 ; 6557 // draw line at the end of the error bars; 6558 ; 6559 if (option1 && drawmarker) {; 6560 ; 6561 if (yi3 < yi1-s2y && yi3 < ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:241744,Testability,log,logx,241744,"ad->PaintLine(xi3 - bxsize, yi4 , xi3 + bxsize, yi4);; 6563 if (yi1 <= ymax && yi1 >= ymin) {; 6564 if (xi1 < xi3-s2x) gPad->PaintLine(xi1 , yi1 - bysize, xi1 , yi1 + bysize);; 6565 if (xi2 > xi3+s2x) gPad->PaintLine(xi2 , yi1 - bysize, xi2 , yi1 + bysize);; 6566 }; 6567 }; 6568 ; 6569 // draw the marker; 6570 ; 6571 if (drawmarker) gPad->PaintPolyMarker(1, &xi3, &yi1);; 6572 ; 6573L30:; 6574 if (fixbin) xp += Hparam.xbinsize;; 6575 else {; 6576 if (k < last) {; 6577 delta = fH->GetBinWidth(k+1);; 6578 xp = fH->GetBinLowEdge(k+1) + 0.5*delta;; 6579 }; 6580 }; 6581 } //end of for loop; 6582 ; 6583 // draw the filled area; 6584 ; 6585 if (option3) {; 6586 TGraph graph;; 6587 graph.SetLineStyle(fH->GetLineStyle());; 6588 graph.SetLineColor(fH->GetLineColor());; 6589 graph.SetLineWidth(fH->GetLineWidth());; 6590 graph.SetFillStyle(fH->GetFillStyle());; 6591 graph.SetFillColor(fH->GetFillColor());; 6592 Int_t logx = gPad->GetLogx();; 6593 Int_t logy = gPad->GetLogy();; 6594 gPad->SetLogx(0);; 6595 gPad->SetLogy(0);; 6596 ; 6597 // In some cases the number of points in the fill area is smaller than; 6598 // 2*npoints. In such cases the array xline and yline must be arranged; 6599 // before being plotted. The next loop does that.; 6600 if (if2 > npoints) {; 6601 for (i=1; i<if1; i++) {; 6602 xline[if1-2+i] = xline[if2-1+i];; 6603 yline[if1-2+i] = yline[if2-1+i];; 6604 }; 6605 npoints = if1-1;; 6606 }; 6607 if (option4) graph.PaintGraph(2*npoints,xline.data(),yline.data(),""FC"");; 6608 else graph.PaintGraph(2*npoints,xline.data(),yline.data(),""F"");; 6609 gPad->SetLogx(logx);; 6610 gPad->SetLogy(logy);; 6611 }; 6612}; 6613 ; 6614////////////////////////////////////////////////////////////////////////////////; 6615/// Draw 2D histograms errors.; 6616 ; 6617void THistPainter::Paint2DErrors(Option_t *); 6618{; 6619 ; 6620 fH->TAttMarker::Modify();; 6621 fH->TAttLine::Modify();; 6622 ; 6623 // Define the 3D view; 6624 fXbuf[0] = Hparam.xmin;; 6625 fYbuf[0] = Hparam.xmax;; 6626 fXb",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:241780,Testability,log,logy,241780,"ad->PaintLine(xi3 - bxsize, yi4 , xi3 + bxsize, yi4);; 6563 if (yi1 <= ymax && yi1 >= ymin) {; 6564 if (xi1 < xi3-s2x) gPad->PaintLine(xi1 , yi1 - bysize, xi1 , yi1 + bysize);; 6565 if (xi2 > xi3+s2x) gPad->PaintLine(xi2 , yi1 - bysize, xi2 , yi1 + bysize);; 6566 }; 6567 }; 6568 ; 6569 // draw the marker; 6570 ; 6571 if (drawmarker) gPad->PaintPolyMarker(1, &xi3, &yi1);; 6572 ; 6573L30:; 6574 if (fixbin) xp += Hparam.xbinsize;; 6575 else {; 6576 if (k < last) {; 6577 delta = fH->GetBinWidth(k+1);; 6578 xp = fH->GetBinLowEdge(k+1) + 0.5*delta;; 6579 }; 6580 }; 6581 } //end of for loop; 6582 ; 6583 // draw the filled area; 6584 ; 6585 if (option3) {; 6586 TGraph graph;; 6587 graph.SetLineStyle(fH->GetLineStyle());; 6588 graph.SetLineColor(fH->GetLineColor());; 6589 graph.SetLineWidth(fH->GetLineWidth());; 6590 graph.SetFillStyle(fH->GetFillStyle());; 6591 graph.SetFillColor(fH->GetFillColor());; 6592 Int_t logx = gPad->GetLogx();; 6593 Int_t logy = gPad->GetLogy();; 6594 gPad->SetLogx(0);; 6595 gPad->SetLogy(0);; 6596 ; 6597 // In some cases the number of points in the fill area is smaller than; 6598 // 2*npoints. In such cases the array xline and yline must be arranged; 6599 // before being plotted. The next loop does that.; 6600 if (if2 > npoints) {; 6601 for (i=1; i<if1; i++) {; 6602 xline[if1-2+i] = xline[if2-1+i];; 6603 yline[if1-2+i] = yline[if2-1+i];; 6604 }; 6605 npoints = if1-1;; 6606 }; 6607 if (option4) graph.PaintGraph(2*npoints,xline.data(),yline.data(),""FC"");; 6608 else graph.PaintGraph(2*npoints,xline.data(),yline.data(),""F"");; 6609 gPad->SetLogx(logx);; 6610 gPad->SetLogy(logy);; 6611 }; 6612}; 6613 ; 6614////////////////////////////////////////////////////////////////////////////////; 6615/// Draw 2D histograms errors.; 6616 ; 6617void THistPainter::Paint2DErrors(Option_t *); 6618{; 6619 ; 6620 fH->TAttMarker::Modify();; 6621 fH->TAttLine::Modify();; 6622 ; 6623 // Define the 3D view; 6624 fXbuf[0] = Hparam.xmin;; 6625 fYbuf[0] = Hparam.xmax;; 6626 fXb",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:242412,Testability,log,logx,242412,"586 TGraph graph;; 6587 graph.SetLineStyle(fH->GetLineStyle());; 6588 graph.SetLineColor(fH->GetLineColor());; 6589 graph.SetLineWidth(fH->GetLineWidth());; 6590 graph.SetFillStyle(fH->GetFillStyle());; 6591 graph.SetFillColor(fH->GetFillColor());; 6592 Int_t logx = gPad->GetLogx();; 6593 Int_t logy = gPad->GetLogy();; 6594 gPad->SetLogx(0);; 6595 gPad->SetLogy(0);; 6596 ; 6597 // In some cases the number of points in the fill area is smaller than; 6598 // 2*npoints. In such cases the array xline and yline must be arranged; 6599 // before being plotted. The next loop does that.; 6600 if (if2 > npoints) {; 6601 for (i=1; i<if1; i++) {; 6602 xline[if1-2+i] = xline[if2-1+i];; 6603 yline[if1-2+i] = yline[if2-1+i];; 6604 }; 6605 npoints = if1-1;; 6606 }; 6607 if (option4) graph.PaintGraph(2*npoints,xline.data(),yline.data(),""FC"");; 6608 else graph.PaintGraph(2*npoints,xline.data(),yline.data(),""F"");; 6609 gPad->SetLogx(logx);; 6610 gPad->SetLogy(logy);; 6611 }; 6612}; 6613 ; 6614////////////////////////////////////////////////////////////////////////////////; 6615/// Draw 2D histograms errors.; 6616 ; 6617void THistPainter::Paint2DErrors(Option_t *); 6618{; 6619 ; 6620 fH->TAttMarker::Modify();; 6621 fH->TAttLine::Modify();; 6622 ; 6623 // Define the 3D view; 6624 fXbuf[0] = Hparam.xmin;; 6625 fYbuf[0] = Hparam.xmax;; 6626 fXbuf[1] = Hparam.ymin;; 6627 fYbuf[1] = Hparam.ymax;; 6628 fXbuf[2] = Hparam.zmin;; 6629 fYbuf[2] = Hparam.zmax*(1. + gStyle->GetHistTopMargin());; 6630 fLego = std::make_unique<TPainter3dAlgorithms>(fXbuf.data(), fYbuf.data());; 6631 TView *view = gPad ? gPad->GetView() : nullptr;; 6632 if (!view) {; 6633 Error(""Paint2DErrors"", ""no TView in current pad"");; 6634 return;; 6635 }; 6636 Double_t thedeg = 90 - gPad->GetTheta();; 6637 Double_t phideg = -90 - gPad->GetPhi();; 6638 Double_t psideg = view->GetPsi();; 6639 Int_t irep;; 6640 view->SetView(phideg, thedeg, psideg, irep);; 6641 ; 6642 // Set color/style for back box; 6643 fLego->SetFillStyle(gPad-",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:242439,Testability,log,logy,242439,"586 TGraph graph;; 6587 graph.SetLineStyle(fH->GetLineStyle());; 6588 graph.SetLineColor(fH->GetLineColor());; 6589 graph.SetLineWidth(fH->GetLineWidth());; 6590 graph.SetFillStyle(fH->GetFillStyle());; 6591 graph.SetFillColor(fH->GetFillColor());; 6592 Int_t logx = gPad->GetLogx();; 6593 Int_t logy = gPad->GetLogy();; 6594 gPad->SetLogx(0);; 6595 gPad->SetLogy(0);; 6596 ; 6597 // In some cases the number of points in the fill area is smaller than; 6598 // 2*npoints. In such cases the array xline and yline must be arranged; 6599 // before being plotted. The next loop does that.; 6600 if (if2 > npoints) {; 6601 for (i=1; i<if1; i++) {; 6602 xline[if1-2+i] = xline[if2-1+i];; 6603 yline[if1-2+i] = yline[if2-1+i];; 6604 }; 6605 npoints = if1-1;; 6606 }; 6607 if (option4) graph.PaintGraph(2*npoints,xline.data(),yline.data(),""FC"");; 6608 else graph.PaintGraph(2*npoints,xline.data(),yline.data(),""F"");; 6609 gPad->SetLogx(logx);; 6610 gPad->SetLogy(logy);; 6611 }; 6612}; 6613 ; 6614////////////////////////////////////////////////////////////////////////////////; 6615/// Draw 2D histograms errors.; 6616 ; 6617void THistPainter::Paint2DErrors(Option_t *); 6618{; 6619 ; 6620 fH->TAttMarker::Modify();; 6621 fH->TAttLine::Modify();; 6622 ; 6623 // Define the 3D view; 6624 fXbuf[0] = Hparam.xmin;; 6625 fYbuf[0] = Hparam.xmax;; 6626 fXbuf[1] = Hparam.ymin;; 6627 fYbuf[1] = Hparam.ymax;; 6628 fXbuf[2] = Hparam.zmin;; 6629 fYbuf[2] = Hparam.zmax*(1. + gStyle->GetHistTopMargin());; 6630 fLego = std::make_unique<TPainter3dAlgorithms>(fXbuf.data(), fYbuf.data());; 6631 TView *view = gPad ? gPad->GetView() : nullptr;; 6632 if (!view) {; 6633 Error(""Paint2DErrors"", ""no TView in current pad"");; 6634 return;; 6635 }; 6636 Double_t thedeg = 90 - gPad->GetTheta();; 6637 Double_t phideg = -90 - gPad->GetPhi();; 6638 Double_t psideg = view->GetPsi();; 6639 Int_t irep;; 6640 view->SetView(phideg, thedeg, psideg, irep);; 6641 ; 6642 // Set color/style for back box; 6643 fLego->SetFillStyle(gPad-",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:250814,Testability,log,logymin,250814,"lightMode() && gPad->GetSelected() != fH); 6843 return;; 6844 ; 6845 static char chopth[17];; 6846 ; 6847 Int_t htype, oldhtype;; 6848 Int_t i, j, first, last, nbins, fixbin;; 6849 Double_t c1, yb;; 6850 yb = 0;; 6851 ; 6852 strlcpy(chopth, "" "",17);; 6853 ; 6854 Double_t ymin = Hparam.ymin;; 6855 Double_t ymax = Hparam.ymax;; 6856 Double_t baroffset = fH->GetBarOffset();; 6857 Double_t barwidth = fH->GetBarWidth();; 6858 Double_t baroffsetsave = gStyle->GetBarOffset();; 6859 Double_t barwidthsave = gStyle->GetBarWidth();; 6860 gStyle->SetBarOffset(baroffset);; 6861 gStyle->SetBarWidth(barwidth);; 6862 ; 6863 // Create ""LIFE"" structure to keep current histogram status; 6864 ; 6865 first = Hparam.xfirst;; 6866 last = Hparam.xlast;; 6867 nbins = last - first + 1;; 6868 ; 6869 std::vector<Double_t> keepx, keepy;; 6870 if (fXaxis->GetXbins()->fN) fixbin = 0;; 6871 else fixbin = 1;; 6872 if (fixbin) keepx.resize(2);; 6873 else keepx.resize(nbins+1);; 6874 keepy.resize(nbins);; 6875 Double_t logymin = 0;; 6876 if (Hoption.Logy) logymin = TMath::Power(10,ymin);; 6877 ; 6878 // Loop on histogram bins; 6879 ; 6880 for (j=first; j<=last;j++) {; 6881 c1 = Hparam.factor*fH->GetBinContent(j);; 6882 if (TMath::Abs(ymax-ymin) > 0) {; 6883 if (Hoption.Logy) yb = TMath::Log10(TMath::Max(c1,.1*logymin));; 6884 else yb = c1;; 6885 }; 6886 if (!Hoption.Line) {; 6887 yb = TMath::Max(yb, ymin);; 6888 yb = TMath::Min(yb, ymax);; 6889 }; 6890 keepy[j-first] = yb;; 6891 }; 6892 ; 6893 // Draw histogram according to value of FillStyle and FillColor; 6894 ; 6895 if (fixbin) { keepx[0] = Hparam.xmin; keepx[1] = Hparam.xmax; }; 6896 else {; 6897 for (i=0; i<nbins; i++) keepx[i] = fXaxis->GetBinLowEdge(i+first);; 6898 keepx[nbins] = fXaxis->GetBinUpEdge(nbins-1+first);; 6899 }; 6900 ; 6901 // Prepare Fill area (systematic with option ""Bar"").; 6902 ; 6903 oldhtype = fH->GetFillStyle();; 6904 htype = oldhtype;; 6905 if (Hoption.Bar) {; 6906 if (htype == 0 || htype == 1000) htype = 1001;; 6907 }; 690",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:250851,Testability,log,logymin,250851," 6847 Int_t htype, oldhtype;; 6848 Int_t i, j, first, last, nbins, fixbin;; 6849 Double_t c1, yb;; 6850 yb = 0;; 6851 ; 6852 strlcpy(chopth, "" "",17);; 6853 ; 6854 Double_t ymin = Hparam.ymin;; 6855 Double_t ymax = Hparam.ymax;; 6856 Double_t baroffset = fH->GetBarOffset();; 6857 Double_t barwidth = fH->GetBarWidth();; 6858 Double_t baroffsetsave = gStyle->GetBarOffset();; 6859 Double_t barwidthsave = gStyle->GetBarWidth();; 6860 gStyle->SetBarOffset(baroffset);; 6861 gStyle->SetBarWidth(barwidth);; 6862 ; 6863 // Create ""LIFE"" structure to keep current histogram status; 6864 ; 6865 first = Hparam.xfirst;; 6866 last = Hparam.xlast;; 6867 nbins = last - first + 1;; 6868 ; 6869 std::vector<Double_t> keepx, keepy;; 6870 if (fXaxis->GetXbins()->fN) fixbin = 0;; 6871 else fixbin = 1;; 6872 if (fixbin) keepx.resize(2);; 6873 else keepx.resize(nbins+1);; 6874 keepy.resize(nbins);; 6875 Double_t logymin = 0;; 6876 if (Hoption.Logy) logymin = TMath::Power(10,ymin);; 6877 ; 6878 // Loop on histogram bins; 6879 ; 6880 for (j=first; j<=last;j++) {; 6881 c1 = Hparam.factor*fH->GetBinContent(j);; 6882 if (TMath::Abs(ymax-ymin) > 0) {; 6883 if (Hoption.Logy) yb = TMath::Log10(TMath::Max(c1,.1*logymin));; 6884 else yb = c1;; 6885 }; 6886 if (!Hoption.Line) {; 6887 yb = TMath::Max(yb, ymin);; 6888 yb = TMath::Min(yb, ymax);; 6889 }; 6890 keepy[j-first] = yb;; 6891 }; 6892 ; 6893 // Draw histogram according to value of FillStyle and FillColor; 6894 ; 6895 if (fixbin) { keepx[0] = Hparam.xmin; keepx[1] = Hparam.xmax; }; 6896 else {; 6897 for (i=0; i<nbins; i++) keepx[i] = fXaxis->GetBinLowEdge(i+first);; 6898 keepx[nbins] = fXaxis->GetBinUpEdge(nbins-1+first);; 6899 }; 6900 ; 6901 // Prepare Fill area (systematic with option ""Bar"").; 6902 ; 6903 oldhtype = fH->GetFillStyle();; 6904 htype = oldhtype;; 6905 if (Hoption.Bar) {; 6906 if (htype == 0 || htype == 1000) htype = 1001;; 6907 }; 6908 ; 6909 Width_t lw = (Width_t)fH->GetLineWidth();; 6910 ; 6911 // Code option for GrapHist; 6912 ;",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:251110,Testability,log,logymin,251110,"x;; 6856 Double_t baroffset = fH->GetBarOffset();; 6857 Double_t barwidth = fH->GetBarWidth();; 6858 Double_t baroffsetsave = gStyle->GetBarOffset();; 6859 Double_t barwidthsave = gStyle->GetBarWidth();; 6860 gStyle->SetBarOffset(baroffset);; 6861 gStyle->SetBarWidth(barwidth);; 6862 ; 6863 // Create ""LIFE"" structure to keep current histogram status; 6864 ; 6865 first = Hparam.xfirst;; 6866 last = Hparam.xlast;; 6867 nbins = last - first + 1;; 6868 ; 6869 std::vector<Double_t> keepx, keepy;; 6870 if (fXaxis->GetXbins()->fN) fixbin = 0;; 6871 else fixbin = 1;; 6872 if (fixbin) keepx.resize(2);; 6873 else keepx.resize(nbins+1);; 6874 keepy.resize(nbins);; 6875 Double_t logymin = 0;; 6876 if (Hoption.Logy) logymin = TMath::Power(10,ymin);; 6877 ; 6878 // Loop on histogram bins; 6879 ; 6880 for (j=first; j<=last;j++) {; 6881 c1 = Hparam.factor*fH->GetBinContent(j);; 6882 if (TMath::Abs(ymax-ymin) > 0) {; 6883 if (Hoption.Logy) yb = TMath::Log10(TMath::Max(c1,.1*logymin));; 6884 else yb = c1;; 6885 }; 6886 if (!Hoption.Line) {; 6887 yb = TMath::Max(yb, ymin);; 6888 yb = TMath::Min(yb, ymax);; 6889 }; 6890 keepy[j-first] = yb;; 6891 }; 6892 ; 6893 // Draw histogram according to value of FillStyle and FillColor; 6894 ; 6895 if (fixbin) { keepx[0] = Hparam.xmin; keepx[1] = Hparam.xmax; }; 6896 else {; 6897 for (i=0; i<nbins; i++) keepx[i] = fXaxis->GetBinLowEdge(i+first);; 6898 keepx[nbins] = fXaxis->GetBinUpEdge(nbins-1+first);; 6899 }; 6900 ; 6901 // Prepare Fill area (systematic with option ""Bar"").; 6902 ; 6903 oldhtype = fH->GetFillStyle();; 6904 htype = oldhtype;; 6905 if (Hoption.Bar) {; 6906 if (htype == 0 || htype == 1000) htype = 1001;; 6907 }; 6908 ; 6909 Width_t lw = (Width_t)fH->GetLineWidth();; 6910 ; 6911 // Code option for GrapHist; 6912 ; 6913 if (Hoption.Line) chopth[0] = 'L';; 6914 if (Hoption.Star) chopth[1] = '*';; 6915 if (Hoption.Mark) chopth[2] = 'P';; 6916 if (Hoption.Mark == 10) chopth[3] = '0';; 6917 if (Hoption.Line || Hoption.Curve || Hoption.His",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:257783,Testability,log,log,257783,"076 ; 7077}; 7078 ; 7079////////////////////////////////////////////////////////////////////////////////; 7080/// Compute histogram parameters used by the drawing routines.; 7081 ; 7082Int_t THistPainter::PaintInit(); 7083{; 7084 ; 7085 if (fH->GetDimension() > 1 || Hoption.Lego || Hoption.Surf) return 1;; 7086 ; 7087 Int_t i;; 7088 static const char *where = ""PaintInit"";; 7089 Double_t yMARGIN = gStyle->GetHistTopMargin();; 7090 Int_t maximum = 0;; 7091 Int_t minimum = 0;; 7092 if (fH->GetMaximumStored() != -1111) maximum = 1;; 7093 if (fH->GetMinimumStored() != -1111) minimum = 1;; 7094 ; 7095 // Compute X axis parameters; 7096 ; 7097 Int_t last = fXaxis->GetLast();; 7098 Int_t first = fXaxis->GetFirst();; 7099 Hparam.xlowedge = fXaxis->GetBinLowEdge(first);; 7100 Hparam.xbinsize = fXaxis->GetBinWidth(first);; 7101 Hparam.xlast = last;; 7102 Hparam.xfirst = first;; 7103 Hparam.xmin = Hparam.xlowedge;; 7104 Hparam.xmax = fXaxis->GetBinLowEdge(last)+fXaxis->GetBinWidth(last);; 7105 ; 7106 // if log scale in X, replace xmin,max by the log; 7107 if (Hoption.Logx) {; 7108 if (Hparam.xmax<=0) {; 7109 Error(where, ""cannot set X axis to log scale"");; 7110 return 0;; 7111 }; 7112 if (Hparam.xlowedge <=0 ) {; 7113 if (Hoption.Same) {; 7114 TH1* h1 = nullptr;; 7115 TObject *obj;; 7116 TIter next(gPad->GetListOfPrimitives());; 7117 while ((obj = (TObject *)next())) {; 7118 if (obj->InheritsFrom(TH1::Class())) { h1 = (TH1*)(obj) ; break; }; 7119 if (obj->InheritsFrom(THStack::Class())) { h1 = ((THStack*)(obj))->GetHistogram() ; break; }; 7120 if (obj->InheritsFrom(TGraph::Class())) { h1 = ((TGraph*)(obj))->GetHistogram() ; break; }; 7121 if (obj->InheritsFrom(TMultiGraph::Class())) { h1 = ((TMultiGraph*)(obj))->GetHistogram(); break; }; 7122 if (obj->InheritsFrom(TGraph2D::Class())) { h1 = ((TGraph2D*)(obj))->GetHistogram(); break; }; 7123 if (obj->InheritsFrom(TF1::Class())) { h1 = ((TF1*)(obj))->GetHistogram(); break; }; 7124 }; 7125 if (h1) {; 7126 Hparam.xlowedge = h1->GetX",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:257823,Testability,log,log,257823,"076 ; 7077}; 7078 ; 7079////////////////////////////////////////////////////////////////////////////////; 7080/// Compute histogram parameters used by the drawing routines.; 7081 ; 7082Int_t THistPainter::PaintInit(); 7083{; 7084 ; 7085 if (fH->GetDimension() > 1 || Hoption.Lego || Hoption.Surf) return 1;; 7086 ; 7087 Int_t i;; 7088 static const char *where = ""PaintInit"";; 7089 Double_t yMARGIN = gStyle->GetHistTopMargin();; 7090 Int_t maximum = 0;; 7091 Int_t minimum = 0;; 7092 if (fH->GetMaximumStored() != -1111) maximum = 1;; 7093 if (fH->GetMinimumStored() != -1111) minimum = 1;; 7094 ; 7095 // Compute X axis parameters; 7096 ; 7097 Int_t last = fXaxis->GetLast();; 7098 Int_t first = fXaxis->GetFirst();; 7099 Hparam.xlowedge = fXaxis->GetBinLowEdge(first);; 7100 Hparam.xbinsize = fXaxis->GetBinWidth(first);; 7101 Hparam.xlast = last;; 7102 Hparam.xfirst = first;; 7103 Hparam.xmin = Hparam.xlowedge;; 7104 Hparam.xmax = fXaxis->GetBinLowEdge(last)+fXaxis->GetBinWidth(last);; 7105 ; 7106 // if log scale in X, replace xmin,max by the log; 7107 if (Hoption.Logx) {; 7108 if (Hparam.xmax<=0) {; 7109 Error(where, ""cannot set X axis to log scale"");; 7110 return 0;; 7111 }; 7112 if (Hparam.xlowedge <=0 ) {; 7113 if (Hoption.Same) {; 7114 TH1* h1 = nullptr;; 7115 TObject *obj;; 7116 TIter next(gPad->GetListOfPrimitives());; 7117 while ((obj = (TObject *)next())) {; 7118 if (obj->InheritsFrom(TH1::Class())) { h1 = (TH1*)(obj) ; break; }; 7119 if (obj->InheritsFrom(THStack::Class())) { h1 = ((THStack*)(obj))->GetHistogram() ; break; }; 7120 if (obj->InheritsFrom(TGraph::Class())) { h1 = ((TGraph*)(obj))->GetHistogram() ; break; }; 7121 if (obj->InheritsFrom(TMultiGraph::Class())) { h1 = ((TMultiGraph*)(obj))->GetHistogram(); break; }; 7122 if (obj->InheritsFrom(TGraph2D::Class())) { h1 = ((TGraph2D*)(obj))->GetHistogram(); break; }; 7123 if (obj->InheritsFrom(TF1::Class())) { h1 = ((TF1*)(obj))->GetHistogram(); break; }; 7124 }; 7125 if (h1) {; 7126 Hparam.xlowedge = h1->GetX",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:257922,Testability,log,log,257922," the drawing routines.; 7081 ; 7082Int_t THistPainter::PaintInit(); 7083{; 7084 ; 7085 if (fH->GetDimension() > 1 || Hoption.Lego || Hoption.Surf) return 1;; 7086 ; 7087 Int_t i;; 7088 static const char *where = ""PaintInit"";; 7089 Double_t yMARGIN = gStyle->GetHistTopMargin();; 7090 Int_t maximum = 0;; 7091 Int_t minimum = 0;; 7092 if (fH->GetMaximumStored() != -1111) maximum = 1;; 7093 if (fH->GetMinimumStored() != -1111) minimum = 1;; 7094 ; 7095 // Compute X axis parameters; 7096 ; 7097 Int_t last = fXaxis->GetLast();; 7098 Int_t first = fXaxis->GetFirst();; 7099 Hparam.xlowedge = fXaxis->GetBinLowEdge(first);; 7100 Hparam.xbinsize = fXaxis->GetBinWidth(first);; 7101 Hparam.xlast = last;; 7102 Hparam.xfirst = first;; 7103 Hparam.xmin = Hparam.xlowedge;; 7104 Hparam.xmax = fXaxis->GetBinLowEdge(last)+fXaxis->GetBinWidth(last);; 7105 ; 7106 // if log scale in X, replace xmin,max by the log; 7107 if (Hoption.Logx) {; 7108 if (Hparam.xmax<=0) {; 7109 Error(where, ""cannot set X axis to log scale"");; 7110 return 0;; 7111 }; 7112 if (Hparam.xlowedge <=0 ) {; 7113 if (Hoption.Same) {; 7114 TH1* h1 = nullptr;; 7115 TObject *obj;; 7116 TIter next(gPad->GetListOfPrimitives());; 7117 while ((obj = (TObject *)next())) {; 7118 if (obj->InheritsFrom(TH1::Class())) { h1 = (TH1*)(obj) ; break; }; 7119 if (obj->InheritsFrom(THStack::Class())) { h1 = ((THStack*)(obj))->GetHistogram() ; break; }; 7120 if (obj->InheritsFrom(TGraph::Class())) { h1 = ((TGraph*)(obj))->GetHistogram() ; break; }; 7121 if (obj->InheritsFrom(TMultiGraph::Class())) { h1 = ((TMultiGraph*)(obj))->GetHistogram(); break; }; 7122 if (obj->InheritsFrom(TGraph2D::Class())) { h1 = ((TGraph2D*)(obj))->GetHistogram(); break; }; 7123 if (obj->InheritsFrom(TF1::Class())) { h1 = ((TF1*)(obj))->GetHistogram(); break; }; 7124 }; 7125 if (h1) {; 7126 Hparam.xlowedge = h1->GetXaxis()->GetBinLowEdge(h1->GetXaxis()->GetFirst());; 7127 } else {; 7128 Error(where, ""undefined user's coordinates. Cannot use option SAME"");; 7129 r",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:259326,Testability,log,log,259326,"120 if (obj->InheritsFrom(TGraph::Class())) { h1 = ((TGraph*)(obj))->GetHistogram() ; break; }; 7121 if (obj->InheritsFrom(TMultiGraph::Class())) { h1 = ((TMultiGraph*)(obj))->GetHistogram(); break; }; 7122 if (obj->InheritsFrom(TGraph2D::Class())) { h1 = ((TGraph2D*)(obj))->GetHistogram(); break; }; 7123 if (obj->InheritsFrom(TF1::Class())) { h1 = ((TF1*)(obj))->GetHistogram(); break; }; 7124 }; 7125 if (h1) {; 7126 Hparam.xlowedge = h1->GetXaxis()->GetBinLowEdge(h1->GetXaxis()->GetFirst());; 7127 } else {; 7128 Error(where, ""undefined user's coordinates. Cannot use option SAME"");; 7129 return 0;; 7130 }; 7131 } else {; 7132 for (i=first; i<=last; i++) {; 7133 Double_t binLow = fXaxis->GetBinLowEdge(i);; 7134 if (binLow>0) {; 7135 Hparam.xlowedge = binLow;; 7136 break;; 7137 }; 7138 if (binLow == 0 && fH->GetBinContent(i) !=0) {; 7139 Hparam.xlowedge = fXaxis->GetBinUpEdge(i)*0.001;; 7140 break;; 7141 }; 7142 }; 7143 if (Hparam.xlowedge<=0) {; 7144 Error(where, ""cannot set X axis to log scale"");; 7145 return 0;; 7146 }; 7147 }; 7148 Hparam.xmin = Hparam.xlowedge;; 7149 }; 7150 Hparam.xfirst= fXaxis->FindFixBin(Hparam.xmin);; 7151 Hparam.xlast = fXaxis->FindFixBin(Hparam.xmax);; 7152 Hparam.xmin = TMath::Log10(Hparam.xmin);; 7153 Hparam.xmax = TMath::Log10(Hparam.xmax);; 7154 if (Hparam.xlast > last) Hparam.xlast = last;; 7155 if (Hparam.xfirst < first) Hparam.xfirst = first;; 7156 }; 7157 ; 7158 // Compute Y axis parameters; 7159 Double_t bigp = TMath::Power(10,32);; 7160 Double_t ymax = -bigp;; 7161 Double_t ymin = bigp;; 7162 Double_t c1, e1;; 7163 Double_t xv[1];; 7164 Double_t fval;; 7165 TObject *f;; 7166 TF1 *f1;; 7167 Double_t allchan = 0;; 7168 Int_t nonNullErrors = 0;; 7169 TIter next(fFunctions);; 7170 for (i=first; i<=last;i++) {; 7171 c1 = fH->GetBinContent(i);; 7172 ymax = TMath::Max(ymax,c1);; 7173 if (Hoption.Logy) {; 7174 if (c1 > 0) ymin = TMath::Min(ymin,c1);; 7175 } else {; 7176 ymin = TMath::Min(ymin,c1);; 7177 }; 7178 if (Hoption.Error) {; 7179",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:261915,Testability,log,log,261915," (xv[0] < f1->GetXmin() || xv[0] > f1->GetXmax()) continue;; 7200 fval = f1->Eval(xv[0],0,0);; 7201 if (f1->GetMaximumStored() != -1111) fval = TMath::Min(f1->GetMaximumStored(), fval);; 7202 ymax = TMath::Max(ymax,fval);; 7203 if (Hoption.Logy) {; 7204 if (c1 > 0 && fval > 0.3*c1) ymin = TMath::Min(ymin,fval);; 7205 }; 7206 }; 7207 }; 7208 next.Reset();; 7209 }; 7210 allchan += c1;; 7211 }; 7212 if (!nonNullErrors) {; 7213 if (Hoption.Error) {; 7214 if (!Hoption.Mark && !Hoption.Line && !Hoption.Star && !Hoption.Curve) Hoption.Hist = 2;; 7215 Hoption.Error=0;; 7216 }; 7217 }; 7218 ; 7219 ; 7220 // Take into account maximum , minimum; 7221 ; 7222 if (Hoption.Logy && ymin <= 0) {; 7223 if (ymax >= 1) ymin = TMath::Max(.005,ymax*1e-10);; 7224 else ymin = 0.001*ymax;; 7225 }; 7226 ; 7227 Double_t xm = ymin;; 7228 if (maximum) ymax = fH->GetMaximumStored();; 7229 if (minimum) xm = fH->GetMinimumStored();; 7230 if (Hoption.Logy && xm < 0) {; 7231 Error(where, ""log scale requested with a negative argument (%f)"", xm);; 7232 return 0;; 7233 } else if (Hoption.Logy && xm>=0 && ymax==0) { // empty histogram in log scale; 7234 ymin = 0.01;; 7235 ymax = 10.;; 7236 } else {; 7237 ymin = xm;; 7238 }; 7239 ; 7240 if (ymin >= ymax) {; 7241 if (Hoption.Logy) {; 7242 if (ymax > 0) ymin = 0.001*ymax;; 7243 else {; 7244 if (!Hoption.Same) Error(where, ""log scale is requested but maximum is less or equal 0 (%f)"", ymax);; 7245 return 0;; 7246 }; 7247 }; 7248 else {; 7249 if (ymin > 0) {; 7250 ymin = 0;; 7251 ymax *= 2;; 7252 } else if (ymin < 0) {; 7253 ymax = 0;; 7254 ymin *= 2;; 7255 } else {; 7256 ymin = 0;; 7257 ymax = 1;; 7258 }; 7259 }; 7260 }; 7261 ; 7262 // In some cases, mainly because of precision issues, ymin and ymax could almost equal.; 7263 if (TMath::AreEqualRel(ymin,ymax,1E-15)) {; 7264 ymin = ymin*(1-1E-14);; 7265 ymax = ymax*(1+1E-14);; 7266 }; 7267 ; 7268 // take into account normalization factor; 7269 Hparam.allchan = allchan;; 7270 Double_t factor = allchan;; 7271 if",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:262063,Testability,log,log,262063,"1->GetMaximumStored() != -1111) fval = TMath::Min(f1->GetMaximumStored(), fval);; 7202 ymax = TMath::Max(ymax,fval);; 7203 if (Hoption.Logy) {; 7204 if (c1 > 0 && fval > 0.3*c1) ymin = TMath::Min(ymin,fval);; 7205 }; 7206 }; 7207 }; 7208 next.Reset();; 7209 }; 7210 allchan += c1;; 7211 }; 7212 if (!nonNullErrors) {; 7213 if (Hoption.Error) {; 7214 if (!Hoption.Mark && !Hoption.Line && !Hoption.Star && !Hoption.Curve) Hoption.Hist = 2;; 7215 Hoption.Error=0;; 7216 }; 7217 }; 7218 ; 7219 ; 7220 // Take into account maximum , minimum; 7221 ; 7222 if (Hoption.Logy && ymin <= 0) {; 7223 if (ymax >= 1) ymin = TMath::Max(.005,ymax*1e-10);; 7224 else ymin = 0.001*ymax;; 7225 }; 7226 ; 7227 Double_t xm = ymin;; 7228 if (maximum) ymax = fH->GetMaximumStored();; 7229 if (minimum) xm = fH->GetMinimumStored();; 7230 if (Hoption.Logy && xm < 0) {; 7231 Error(where, ""log scale requested with a negative argument (%f)"", xm);; 7232 return 0;; 7233 } else if (Hoption.Logy && xm>=0 && ymax==0) { // empty histogram in log scale; 7234 ymin = 0.01;; 7235 ymax = 10.;; 7236 } else {; 7237 ymin = xm;; 7238 }; 7239 ; 7240 if (ymin >= ymax) {; 7241 if (Hoption.Logy) {; 7242 if (ymax > 0) ymin = 0.001*ymax;; 7243 else {; 7244 if (!Hoption.Same) Error(where, ""log scale is requested but maximum is less or equal 0 (%f)"", ymax);; 7245 return 0;; 7246 }; 7247 }; 7248 else {; 7249 if (ymin > 0) {; 7250 ymin = 0;; 7251 ymax *= 2;; 7252 } else if (ymin < 0) {; 7253 ymax = 0;; 7254 ymin *= 2;; 7255 } else {; 7256 ymin = 0;; 7257 ymax = 1;; 7258 }; 7259 }; 7260 }; 7261 ; 7262 // In some cases, mainly because of precision issues, ymin and ymax could almost equal.; 7263 if (TMath::AreEqualRel(ymin,ymax,1E-15)) {; 7264 ymin = ymin*(1-1E-14);; 7265 ymax = ymax*(1+1E-14);; 7266 }; 7267 ; 7268 // take into account normalization factor; 7269 Hparam.allchan = allchan;; 7270 Double_t factor = allchan;; 7271 if (fH->GetNormFactor() > 0) factor = fH->GetNormFactor();; 7272 if (allchan) factor /= allchan;; 7273 if (f",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:262300,Testability,log,log,262300,"7215 Hoption.Error=0;; 7216 }; 7217 }; 7218 ; 7219 ; 7220 // Take into account maximum , minimum; 7221 ; 7222 if (Hoption.Logy && ymin <= 0) {; 7223 if (ymax >= 1) ymin = TMath::Max(.005,ymax*1e-10);; 7224 else ymin = 0.001*ymax;; 7225 }; 7226 ; 7227 Double_t xm = ymin;; 7228 if (maximum) ymax = fH->GetMaximumStored();; 7229 if (minimum) xm = fH->GetMinimumStored();; 7230 if (Hoption.Logy && xm < 0) {; 7231 Error(where, ""log scale requested with a negative argument (%f)"", xm);; 7232 return 0;; 7233 } else if (Hoption.Logy && xm>=0 && ymax==0) { // empty histogram in log scale; 7234 ymin = 0.01;; 7235 ymax = 10.;; 7236 } else {; 7237 ymin = xm;; 7238 }; 7239 ; 7240 if (ymin >= ymax) {; 7241 if (Hoption.Logy) {; 7242 if (ymax > 0) ymin = 0.001*ymax;; 7243 else {; 7244 if (!Hoption.Same) Error(where, ""log scale is requested but maximum is less or equal 0 (%f)"", ymax);; 7245 return 0;; 7246 }; 7247 }; 7248 else {; 7249 if (ymin > 0) {; 7250 ymin = 0;; 7251 ymax *= 2;; 7252 } else if (ymin < 0) {; 7253 ymax = 0;; 7254 ymin *= 2;; 7255 } else {; 7256 ymin = 0;; 7257 ymax = 1;; 7258 }; 7259 }; 7260 }; 7261 ; 7262 // In some cases, mainly because of precision issues, ymin and ymax could almost equal.; 7263 if (TMath::AreEqualRel(ymin,ymax,1E-15)) {; 7264 ymin = ymin*(1-1E-14);; 7265 ymax = ymax*(1+1E-14);; 7266 }; 7267 ; 7268 // take into account normalization factor; 7269 Hparam.allchan = allchan;; 7270 Double_t factor = allchan;; 7271 if (fH->GetNormFactor() > 0) factor = fH->GetNormFactor();; 7272 if (allchan) factor /= allchan;; 7273 if (factor == 0) factor = 1;; 7274 Hparam.factor = factor;; 7275 ymax = factor*ymax;; 7276 ymin = factor*ymin;; 7277 //just in case the norm factor is negative; 7278 // this may happen with a positive norm factor and a negative integral !; 7279 if (ymax < ymin) {; 7280 Double_t temp = ymax;; 7281 ymax = ymin;; 7282 ymin = temp;; 7283 }; 7284 ; 7285 // For log scales, histogram coordinates are LOG10(ymin) and; 7286 // LOG10(ymax). Final adjus",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:263404,Testability,log,log,263404,"e) Error(where, ""log scale is requested but maximum is less or equal 0 (%f)"", ymax);; 7245 return 0;; 7246 }; 7247 }; 7248 else {; 7249 if (ymin > 0) {; 7250 ymin = 0;; 7251 ymax *= 2;; 7252 } else if (ymin < 0) {; 7253 ymax = 0;; 7254 ymin *= 2;; 7255 } else {; 7256 ymin = 0;; 7257 ymax = 1;; 7258 }; 7259 }; 7260 }; 7261 ; 7262 // In some cases, mainly because of precision issues, ymin and ymax could almost equal.; 7263 if (TMath::AreEqualRel(ymin,ymax,1E-15)) {; 7264 ymin = ymin*(1-1E-14);; 7265 ymax = ymax*(1+1E-14);; 7266 }; 7267 ; 7268 // take into account normalization factor; 7269 Hparam.allchan = allchan;; 7270 Double_t factor = allchan;; 7271 if (fH->GetNormFactor() > 0) factor = fH->GetNormFactor();; 7272 if (allchan) factor /= allchan;; 7273 if (factor == 0) factor = 1;; 7274 Hparam.factor = factor;; 7275 ymax = factor*ymax;; 7276 ymin = factor*ymin;; 7277 //just in case the norm factor is negative; 7278 // this may happen with a positive norm factor and a negative integral !; 7279 if (ymax < ymin) {; 7280 Double_t temp = ymax;; 7281 ymax = ymin;; 7282 ymin = temp;; 7283 }; 7284 ; 7285 // For log scales, histogram coordinates are LOG10(ymin) and; 7286 // LOG10(ymax). Final adjustment (if not option ""Same""; 7287 // or ""+"" for ymax) of ymax and ymin for logarithmic scale, if; 7288 // Maximum and Minimum are not defined.; 7289 if (Hoption.Logy) {; 7290 if (ymin <=0 || ymax <=0) {; 7291 Error(where, ""Cannot set Y axis to log scale"");; 7292 return 0;; 7293 }; 7294 ymin = TMath::Log10(ymin);; 7295 if (!minimum) ymin += TMath::Log10(0.5);; 7296 ymax = TMath::Log10(ymax);; 7297 if (!maximum) ymax += TMath::Log10(2*(0.9/0.95));; 7298 if (!Hoption.Same) {; 7299 Hparam.ymin = ymin;; 7300 Hparam.ymax = ymax;; 7301 }; 7302 return 1;; 7303 }; 7304 ; 7305 // final adjustment of ymin for linear scale.; 7306 // if minimum is not set , then ymin is set to zero if >0; 7307 // or to ymin - margin if <0.; 7308 if (!minimum) {; 7309 if (Hoption.MinimumZero) {; 7310 if (ymin >= ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:263566,Testability,log,logarithmic,263566,"= 0;; 7257 ymax = 1;; 7258 }; 7259 }; 7260 }; 7261 ; 7262 // In some cases, mainly because of precision issues, ymin and ymax could almost equal.; 7263 if (TMath::AreEqualRel(ymin,ymax,1E-15)) {; 7264 ymin = ymin*(1-1E-14);; 7265 ymax = ymax*(1+1E-14);; 7266 }; 7267 ; 7268 // take into account normalization factor; 7269 Hparam.allchan = allchan;; 7270 Double_t factor = allchan;; 7271 if (fH->GetNormFactor() > 0) factor = fH->GetNormFactor();; 7272 if (allchan) factor /= allchan;; 7273 if (factor == 0) factor = 1;; 7274 Hparam.factor = factor;; 7275 ymax = factor*ymax;; 7276 ymin = factor*ymin;; 7277 //just in case the norm factor is negative; 7278 // this may happen with a positive norm factor and a negative integral !; 7279 if (ymax < ymin) {; 7280 Double_t temp = ymax;; 7281 ymax = ymin;; 7282 ymin = temp;; 7283 }; 7284 ; 7285 // For log scales, histogram coordinates are LOG10(ymin) and; 7286 // LOG10(ymax). Final adjustment (if not option ""Same""; 7287 // or ""+"" for ymax) of ymax and ymin for logarithmic scale, if; 7288 // Maximum and Minimum are not defined.; 7289 if (Hoption.Logy) {; 7290 if (ymin <=0 || ymax <=0) {; 7291 Error(where, ""Cannot set Y axis to log scale"");; 7292 return 0;; 7293 }; 7294 ymin = TMath::Log10(ymin);; 7295 if (!minimum) ymin += TMath::Log10(0.5);; 7296 ymax = TMath::Log10(ymax);; 7297 if (!maximum) ymax += TMath::Log10(2*(0.9/0.95));; 7298 if (!Hoption.Same) {; 7299 Hparam.ymin = ymin;; 7300 Hparam.ymax = ymax;; 7301 }; 7302 return 1;; 7303 }; 7304 ; 7305 // final adjustment of ymin for linear scale.; 7306 // if minimum is not set , then ymin is set to zero if >0; 7307 // or to ymin - margin if <0.; 7308 if (!minimum) {; 7309 if (Hoption.MinimumZero) {; 7310 if (ymin >= 0) ymin = 0;; 7311 else ymin -= yMARGIN*(ymax-ymin);; 7312 } else {; 7313 Double_t dymin = yMARGIN*(ymax-ymin);; 7314 if (ymin >= 0 && (ymin-dymin <= 0)) ymin = 0;; 7315 else ymin -= dymin;; 7316 }; 7317 }; 7318 ; 7319 // final adjustment of YMAXI for linear scale (if not",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:263735,Testability,log,log,263735,"; 7264 ymin = ymin*(1-1E-14);; 7265 ymax = ymax*(1+1E-14);; 7266 }; 7267 ; 7268 // take into account normalization factor; 7269 Hparam.allchan = allchan;; 7270 Double_t factor = allchan;; 7271 if (fH->GetNormFactor() > 0) factor = fH->GetNormFactor();; 7272 if (allchan) factor /= allchan;; 7273 if (factor == 0) factor = 1;; 7274 Hparam.factor = factor;; 7275 ymax = factor*ymax;; 7276 ymin = factor*ymin;; 7277 //just in case the norm factor is negative; 7278 // this may happen with a positive norm factor and a negative integral !; 7279 if (ymax < ymin) {; 7280 Double_t temp = ymax;; 7281 ymax = ymin;; 7282 ymin = temp;; 7283 }; 7284 ; 7285 // For log scales, histogram coordinates are LOG10(ymin) and; 7286 // LOG10(ymax). Final adjustment (if not option ""Same""; 7287 // or ""+"" for ymax) of ymax and ymin for logarithmic scale, if; 7288 // Maximum and Minimum are not defined.; 7289 if (Hoption.Logy) {; 7290 if (ymin <=0 || ymax <=0) {; 7291 Error(where, ""Cannot set Y axis to log scale"");; 7292 return 0;; 7293 }; 7294 ymin = TMath::Log10(ymin);; 7295 if (!minimum) ymin += TMath::Log10(0.5);; 7296 ymax = TMath::Log10(ymax);; 7297 if (!maximum) ymax += TMath::Log10(2*(0.9/0.95));; 7298 if (!Hoption.Same) {; 7299 Hparam.ymin = ymin;; 7300 Hparam.ymax = ymax;; 7301 }; 7302 return 1;; 7303 }; 7304 ; 7305 // final adjustment of ymin for linear scale.; 7306 // if minimum is not set , then ymin is set to zero if >0; 7307 // or to ymin - margin if <0.; 7308 if (!minimum) {; 7309 if (Hoption.MinimumZero) {; 7310 if (ymin >= 0) ymin = 0;; 7311 else ymin -= yMARGIN*(ymax-ymin);; 7312 } else {; 7313 Double_t dymin = yMARGIN*(ymax-ymin);; 7314 if (ymin >= 0 && (ymin-dymin <= 0)) ymin = 0;; 7315 else ymin -= dymin;; 7316 }; 7317 }; 7318 ; 7319 // final adjustment of YMAXI for linear scale (if not option ""Same""):; 7320 // decrease histogram height to MAX% of allowed height if HMAXIM; 7321 // has not been called.; 7322 if (!maximum) {; 7323 ymax += yMARGIN*(ymax-ymin);; 7324 }; 7325 ; 732",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:265741,Testability,log,log,265741," 7324 }; 7325 ; 7326 Hparam.ymin = ymin;; 7327 Hparam.ymax = ymax;; 7328 return 1;; 7329}; 7330 ; 7331////////////////////////////////////////////////////////////////////////////////; 7332/// Compute histogram parameters used by the drawing routines for a rotated pad.; 7333 ; 7334Int_t THistPainter::PaintInitH(); 7335{; 7336 ; 7337 static const char *where = ""PaintInitH"";; 7338 Double_t yMARGIN = gStyle->GetHistTopMargin();; 7339 Int_t maximum = 0;; 7340 Int_t minimum = 0;; 7341 if (fH->GetMaximumStored() != -1111) maximum = 1;; 7342 if (fH->GetMinimumStored() != -1111) minimum = 1;; 7343 ; 7344 // Compute X axis parameters; 7345 ; 7346 Int_t last = fXaxis->GetLast();; 7347 Int_t first = fXaxis->GetFirst();; 7348 Hparam.xlowedge = fXaxis->GetBinLowEdge(first);; 7349 Hparam.xbinsize = fXaxis->GetBinWidth(first);; 7350 Hparam.xlast = last;; 7351 Hparam.xfirst = first;; 7352 Hparam.ymin = Hparam.xlowedge;; 7353 Hparam.ymax = fXaxis->GetBinLowEdge(last)+fXaxis->GetBinWidth(last);; 7354 ; 7355 // if log scale in Y, replace ymin,max by the log; 7356 if (Hoption.Logy) {; 7357 if (Hparam.xlowedge <=0 ) {; 7358 Hparam.xlowedge = 0.1*Hparam.xbinsize;; 7359 Hparam.ymin = Hparam.xlowedge;; 7360 }; 7361 if (Hparam.ymin <=0 || Hparam.ymax <=0) {; 7362 Error(where, ""cannot set Y axis to log scale"");; 7363 return 0;; 7364 }; 7365 Hparam.xfirst= fXaxis->FindFixBin(Hparam.ymin);; 7366 Hparam.xlast = fXaxis->FindFixBin(Hparam.ymax);; 7367 Hparam.ymin = TMath::Log10(Hparam.ymin);; 7368 Hparam.ymax = TMath::Log10(Hparam.ymax);; 7369 if (Hparam.xlast > last) Hparam.xlast = last;; 7370 }; 7371 ; 7372 // Compute Y axis parameters; 7373 Double_t bigp = TMath::Power(10,32);; 7374 Double_t xmax = -bigp;; 7375 Double_t xmin = bigp;; 7376 Double_t c1, e1;; 7377 Double_t xv[1];; 7378 Double_t fval;; 7379 Int_t i;; 7380 TObject *f;; 7381 TF1 *f1;; 7382 Double_t allchan = 0;; 7383 TIter next(fFunctions);; 7384 for (i=first; i<=last;i++) {; 7385 c1 = fH->GetBinContent(i);; 7386 xmax = TMath::Max(xma",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:265781,Testability,log,log,265781," 7324 }; 7325 ; 7326 Hparam.ymin = ymin;; 7327 Hparam.ymax = ymax;; 7328 return 1;; 7329}; 7330 ; 7331////////////////////////////////////////////////////////////////////////////////; 7332/// Compute histogram parameters used by the drawing routines for a rotated pad.; 7333 ; 7334Int_t THistPainter::PaintInitH(); 7335{; 7336 ; 7337 static const char *where = ""PaintInitH"";; 7338 Double_t yMARGIN = gStyle->GetHistTopMargin();; 7339 Int_t maximum = 0;; 7340 Int_t minimum = 0;; 7341 if (fH->GetMaximumStored() != -1111) maximum = 1;; 7342 if (fH->GetMinimumStored() != -1111) minimum = 1;; 7343 ; 7344 // Compute X axis parameters; 7345 ; 7346 Int_t last = fXaxis->GetLast();; 7347 Int_t first = fXaxis->GetFirst();; 7348 Hparam.xlowedge = fXaxis->GetBinLowEdge(first);; 7349 Hparam.xbinsize = fXaxis->GetBinWidth(first);; 7350 Hparam.xlast = last;; 7351 Hparam.xfirst = first;; 7352 Hparam.ymin = Hparam.xlowedge;; 7353 Hparam.ymax = fXaxis->GetBinLowEdge(last)+fXaxis->GetBinWidth(last);; 7354 ; 7355 // if log scale in Y, replace ymin,max by the log; 7356 if (Hoption.Logy) {; 7357 if (Hparam.xlowedge <=0 ) {; 7358 Hparam.xlowedge = 0.1*Hparam.xbinsize;; 7359 Hparam.ymin = Hparam.xlowedge;; 7360 }; 7361 if (Hparam.ymin <=0 || Hparam.ymax <=0) {; 7362 Error(where, ""cannot set Y axis to log scale"");; 7363 return 0;; 7364 }; 7365 Hparam.xfirst= fXaxis->FindFixBin(Hparam.ymin);; 7366 Hparam.xlast = fXaxis->FindFixBin(Hparam.ymax);; 7367 Hparam.ymin = TMath::Log10(Hparam.ymin);; 7368 Hparam.ymax = TMath::Log10(Hparam.ymax);; 7369 if (Hparam.xlast > last) Hparam.xlast = last;; 7370 }; 7371 ; 7372 // Compute Y axis parameters; 7373 Double_t bigp = TMath::Power(10,32);; 7374 Double_t xmax = -bigp;; 7375 Double_t xmin = bigp;; 7376 Double_t c1, e1;; 7377 Double_t xv[1];; 7378 Double_t fval;; 7379 Int_t i;; 7380 TObject *f;; 7381 TF1 *f1;; 7382 Double_t allchan = 0;; 7383 TIter next(fFunctions);; 7384 for (i=first; i<=last;i++) {; 7385 c1 = fH->GetBinContent(i);; 7386 xmax = TMath::Max(xma",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:266024,Testability,log,log,266024,"tPainter::PaintInitH(); 7335{; 7336 ; 7337 static const char *where = ""PaintInitH"";; 7338 Double_t yMARGIN = gStyle->GetHistTopMargin();; 7339 Int_t maximum = 0;; 7340 Int_t minimum = 0;; 7341 if (fH->GetMaximumStored() != -1111) maximum = 1;; 7342 if (fH->GetMinimumStored() != -1111) minimum = 1;; 7343 ; 7344 // Compute X axis parameters; 7345 ; 7346 Int_t last = fXaxis->GetLast();; 7347 Int_t first = fXaxis->GetFirst();; 7348 Hparam.xlowedge = fXaxis->GetBinLowEdge(first);; 7349 Hparam.xbinsize = fXaxis->GetBinWidth(first);; 7350 Hparam.xlast = last;; 7351 Hparam.xfirst = first;; 7352 Hparam.ymin = Hparam.xlowedge;; 7353 Hparam.ymax = fXaxis->GetBinLowEdge(last)+fXaxis->GetBinWidth(last);; 7354 ; 7355 // if log scale in Y, replace ymin,max by the log; 7356 if (Hoption.Logy) {; 7357 if (Hparam.xlowedge <=0 ) {; 7358 Hparam.xlowedge = 0.1*Hparam.xbinsize;; 7359 Hparam.ymin = Hparam.xlowedge;; 7360 }; 7361 if (Hparam.ymin <=0 || Hparam.ymax <=0) {; 7362 Error(where, ""cannot set Y axis to log scale"");; 7363 return 0;; 7364 }; 7365 Hparam.xfirst= fXaxis->FindFixBin(Hparam.ymin);; 7366 Hparam.xlast = fXaxis->FindFixBin(Hparam.ymax);; 7367 Hparam.ymin = TMath::Log10(Hparam.ymin);; 7368 Hparam.ymax = TMath::Log10(Hparam.ymax);; 7369 if (Hparam.xlast > last) Hparam.xlast = last;; 7370 }; 7371 ; 7372 // Compute Y axis parameters; 7373 Double_t bigp = TMath::Power(10,32);; 7374 Double_t xmax = -bigp;; 7375 Double_t xmin = bigp;; 7376 Double_t c1, e1;; 7377 Double_t xv[1];; 7378 Double_t fval;; 7379 Int_t i;; 7380 TObject *f;; 7381 TF1 *f1;; 7382 Double_t allchan = 0;; 7383 TIter next(fFunctions);; 7384 for (i=first; i<=last;i++) {; 7385 c1 = fH->GetBinContent(i);; 7386 xmax = TMath::Max(xmax,c1);; 7387 xmin = TMath::Min(xmin,c1);; 7388 if (Hoption.Error) {; 7389 e1 = fH->GetBinError(i);; 7390 xmax = TMath::Max(xmax,c1+e1);; 7391 xmin = TMath::Min(xmin,c1-e1);; 7392 }; 7393 if (Hoption.Func) {; 7394 xv[0] = fXaxis->GetBinCenter(i);; 7395 while ((f = (TObject*) next())) {; 7396",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:267748,Testability,log,log,267748," e1 = fH->GetBinError(i);; 7390 xmax = TMath::Max(xmax,c1+e1);; 7391 xmin = TMath::Min(xmin,c1-e1);; 7392 }; 7393 if (Hoption.Func) {; 7394 xv[0] = fXaxis->GetBinCenter(i);; 7395 while ((f = (TObject*) next())) {; 7396 if (f->IsA() == TF1::Class()) {; 7397 f1 = (TF1*)f;; 7398 if (xv[0] < f1->GetXmin() || xv[0] > f1->GetXmax()) continue;; 7399 fval = f1->Eval(xv[0],0,0);; 7400 xmax = TMath::Max(xmax,fval);; 7401 if (Hoption.Logy) {; 7402 if (fval > 0.3*c1) xmin = TMath::Min(xmin,fval);; 7403 }; 7404 }; 7405 }; 7406 next.Reset();; 7407 }; 7408 allchan += c1;; 7409 }; 7410 ; 7411 // Take into account maximum , minimum; 7412 ; 7413 if (Hoption.Logx && xmin <= 0) {; 7414 if (xmax >= 1) xmin = TMath::Max(.5,xmax*1e-10);; 7415 else xmin = 0.001*xmax;; 7416 }; 7417 Double_t xm = xmin;; 7418 if (maximum) xmax = fH->GetMaximumStored();; 7419 if (minimum) xm = fH->GetMinimumStored();; 7420 if (Hoption.Logx && xm <= 0) {; 7421 Error(where, ""log scale requested with zero or negative argument (%f)"", xm);; 7422 return 0;; 7423 }; 7424 else xmin = xm;; 7425 if (xmin >= xmax) {; 7426 if (Hoption.Logx) {; 7427 if (xmax > 0) xmin = 0.001*xmax;; 7428 else {; 7429 if (!Hoption.Same) Error(where, ""log scale is requested but maximum is less or equal 0 (%f)"", xmax);; 7430 return 0;; 7431 }; 7432 }; 7433 else {; 7434 if (xmin > 0) {; 7435 xmin = 0;; 7436 xmax *= 2;; 7437 } else if (xmin < 0) {; 7438 xmax = 0;; 7439 xmin *= 2;; 7440 } else {; 7441 xmin = 0;; 7442 xmax = 1;; 7443 }; 7444 }; 7445 }; 7446 ; 7447 // take into account normalization factor; 7448 Hparam.allchan = allchan;; 7449 Double_t factor = allchan;; 7450 if (fH->GetNormFactor() > 0) factor = fH->GetNormFactor();; 7451 if (allchan) factor /= allchan;; 7452 if (factor == 0) factor = 1;; 7453 Hparam.factor = factor;; 7454 xmax = factor*xmax;; 7455 xmin = factor*xmin;; 7456 ; 7457 // For log scales, histogram coordinates are LOG10(ymin) and; 7458 // LOG10(ymax). Final adjustment (if not option ""Same""; 7459 // or ""+"" for ymax) of ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:268000,Testability,log,log,268000,"0);; 7400 xmax = TMath::Max(xmax,fval);; 7401 if (Hoption.Logy) {; 7402 if (fval > 0.3*c1) xmin = TMath::Min(xmin,fval);; 7403 }; 7404 }; 7405 }; 7406 next.Reset();; 7407 }; 7408 allchan += c1;; 7409 }; 7410 ; 7411 // Take into account maximum , minimum; 7412 ; 7413 if (Hoption.Logx && xmin <= 0) {; 7414 if (xmax >= 1) xmin = TMath::Max(.5,xmax*1e-10);; 7415 else xmin = 0.001*xmax;; 7416 }; 7417 Double_t xm = xmin;; 7418 if (maximum) xmax = fH->GetMaximumStored();; 7419 if (minimum) xm = fH->GetMinimumStored();; 7420 if (Hoption.Logx && xm <= 0) {; 7421 Error(where, ""log scale requested with zero or negative argument (%f)"", xm);; 7422 return 0;; 7423 }; 7424 else xmin = xm;; 7425 if (xmin >= xmax) {; 7426 if (Hoption.Logx) {; 7427 if (xmax > 0) xmin = 0.001*xmax;; 7428 else {; 7429 if (!Hoption.Same) Error(where, ""log scale is requested but maximum is less or equal 0 (%f)"", xmax);; 7430 return 0;; 7431 }; 7432 }; 7433 else {; 7434 if (xmin > 0) {; 7435 xmin = 0;; 7436 xmax *= 2;; 7437 } else if (xmin < 0) {; 7438 xmax = 0;; 7439 xmin *= 2;; 7440 } else {; 7441 xmin = 0;; 7442 xmax = 1;; 7443 }; 7444 }; 7445 }; 7446 ; 7447 // take into account normalization factor; 7448 Hparam.allchan = allchan;; 7449 Double_t factor = allchan;; 7450 if (fH->GetNormFactor() > 0) factor = fH->GetNormFactor();; 7451 if (allchan) factor /= allchan;; 7452 if (factor == 0) factor = 1;; 7453 Hparam.factor = factor;; 7454 xmax = factor*xmax;; 7455 xmin = factor*xmin;; 7456 ; 7457 // For log scales, histogram coordinates are LOG10(ymin) and; 7458 // LOG10(ymax). Final adjustment (if not option ""Same""; 7459 // or ""+"" for ymax) of ymax and ymin for logarithmic scale, if; 7460 // Maximum and Minimum are not defined.; 7461 if (Hoption.Logx) {; 7462 if (xmin <=0 || xmax <=0) {; 7463 Error(where, ""Cannot set Y axis to log scale"");; 7464 return 0;; 7465 }; 7466 xmin = TMath::Log10(xmin);; 7467 if (!minimum) xmin += TMath::Log10(0.5);; 7468 xmax = TMath::Log10(xmax);; 7469 if (!maximum) xmax += TMath",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:268661,Testability,log,log,268661,"inimum) xm = fH->GetMinimumStored();; 7420 if (Hoption.Logx && xm <= 0) {; 7421 Error(where, ""log scale requested with zero or negative argument (%f)"", xm);; 7422 return 0;; 7423 }; 7424 else xmin = xm;; 7425 if (xmin >= xmax) {; 7426 if (Hoption.Logx) {; 7427 if (xmax > 0) xmin = 0.001*xmax;; 7428 else {; 7429 if (!Hoption.Same) Error(where, ""log scale is requested but maximum is less or equal 0 (%f)"", xmax);; 7430 return 0;; 7431 }; 7432 }; 7433 else {; 7434 if (xmin > 0) {; 7435 xmin = 0;; 7436 xmax *= 2;; 7437 } else if (xmin < 0) {; 7438 xmax = 0;; 7439 xmin *= 2;; 7440 } else {; 7441 xmin = 0;; 7442 xmax = 1;; 7443 }; 7444 }; 7445 }; 7446 ; 7447 // take into account normalization factor; 7448 Hparam.allchan = allchan;; 7449 Double_t factor = allchan;; 7450 if (fH->GetNormFactor() > 0) factor = fH->GetNormFactor();; 7451 if (allchan) factor /= allchan;; 7452 if (factor == 0) factor = 1;; 7453 Hparam.factor = factor;; 7454 xmax = factor*xmax;; 7455 xmin = factor*xmin;; 7456 ; 7457 // For log scales, histogram coordinates are LOG10(ymin) and; 7458 // LOG10(ymax). Final adjustment (if not option ""Same""; 7459 // or ""+"" for ymax) of ymax and ymin for logarithmic scale, if; 7460 // Maximum and Minimum are not defined.; 7461 if (Hoption.Logx) {; 7462 if (xmin <=0 || xmax <=0) {; 7463 Error(where, ""Cannot set Y axis to log scale"");; 7464 return 0;; 7465 }; 7466 xmin = TMath::Log10(xmin);; 7467 if (!minimum) xmin += TMath::Log10(0.5);; 7468 xmax = TMath::Log10(xmax);; 7469 if (!maximum) xmax += TMath::Log10(2*(0.9/0.95));; 7470 if (!Hoption.Same) {; 7471 Hparam.xmin = xmin;; 7472 Hparam.xmax = xmax;; 7473 }; 7474 return 1;; 7475 }; 7476 ; 7477 // final adjustment of ymin for linear scale.; 7478 // if minimum is not set , then ymin is set to zero if >0; 7479 // or to ymin - margin if <0.; 7480 if (!minimum) {; 7481 if (xmin >= 0) xmin = 0;; 7482 else xmin -= yMARGIN*(xmax-xmin);; 7483 }; 7484 ; 7485 // final adjustment of YMAXI for linear scale (if not option ""Same""):; 7",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:268823,Testability,log,logarithmic,268823,"422 return 0;; 7423 }; 7424 else xmin = xm;; 7425 if (xmin >= xmax) {; 7426 if (Hoption.Logx) {; 7427 if (xmax > 0) xmin = 0.001*xmax;; 7428 else {; 7429 if (!Hoption.Same) Error(where, ""log scale is requested but maximum is less or equal 0 (%f)"", xmax);; 7430 return 0;; 7431 }; 7432 }; 7433 else {; 7434 if (xmin > 0) {; 7435 xmin = 0;; 7436 xmax *= 2;; 7437 } else if (xmin < 0) {; 7438 xmax = 0;; 7439 xmin *= 2;; 7440 } else {; 7441 xmin = 0;; 7442 xmax = 1;; 7443 }; 7444 }; 7445 }; 7446 ; 7447 // take into account normalization factor; 7448 Hparam.allchan = allchan;; 7449 Double_t factor = allchan;; 7450 if (fH->GetNormFactor() > 0) factor = fH->GetNormFactor();; 7451 if (allchan) factor /= allchan;; 7452 if (factor == 0) factor = 1;; 7453 Hparam.factor = factor;; 7454 xmax = factor*xmax;; 7455 xmin = factor*xmin;; 7456 ; 7457 // For log scales, histogram coordinates are LOG10(ymin) and; 7458 // LOG10(ymax). Final adjustment (if not option ""Same""; 7459 // or ""+"" for ymax) of ymax and ymin for logarithmic scale, if; 7460 // Maximum and Minimum are not defined.; 7461 if (Hoption.Logx) {; 7462 if (xmin <=0 || xmax <=0) {; 7463 Error(where, ""Cannot set Y axis to log scale"");; 7464 return 0;; 7465 }; 7466 xmin = TMath::Log10(xmin);; 7467 if (!minimum) xmin += TMath::Log10(0.5);; 7468 xmax = TMath::Log10(xmax);; 7469 if (!maximum) xmax += TMath::Log10(2*(0.9/0.95));; 7470 if (!Hoption.Same) {; 7471 Hparam.xmin = xmin;; 7472 Hparam.xmax = xmax;; 7473 }; 7474 return 1;; 7475 }; 7476 ; 7477 // final adjustment of ymin for linear scale.; 7478 // if minimum is not set , then ymin is set to zero if >0; 7479 // or to ymin - margin if <0.; 7480 if (!minimum) {; 7481 if (xmin >= 0) xmin = 0;; 7482 else xmin -= yMARGIN*(xmax-xmin);; 7483 }; 7484 ; 7485 // final adjustment of YMAXI for linear scale (if not option ""Same""):; 7486 // decrease histogram height to MAX% of allowed height if HMAXIM; 7487 // has not been called.; 7488 if (!maximum) {; 7489 xmax += yMARGIN*(xmax-xmin);; 74",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:268992,Testability,log,log,268992,"le is requested but maximum is less or equal 0 (%f)"", xmax);; 7430 return 0;; 7431 }; 7432 }; 7433 else {; 7434 if (xmin > 0) {; 7435 xmin = 0;; 7436 xmax *= 2;; 7437 } else if (xmin < 0) {; 7438 xmax = 0;; 7439 xmin *= 2;; 7440 } else {; 7441 xmin = 0;; 7442 xmax = 1;; 7443 }; 7444 }; 7445 }; 7446 ; 7447 // take into account normalization factor; 7448 Hparam.allchan = allchan;; 7449 Double_t factor = allchan;; 7450 if (fH->GetNormFactor() > 0) factor = fH->GetNormFactor();; 7451 if (allchan) factor /= allchan;; 7452 if (factor == 0) factor = 1;; 7453 Hparam.factor = factor;; 7454 xmax = factor*xmax;; 7455 xmin = factor*xmin;; 7456 ; 7457 // For log scales, histogram coordinates are LOG10(ymin) and; 7458 // LOG10(ymax). Final adjustment (if not option ""Same""; 7459 // or ""+"" for ymax) of ymax and ymin for logarithmic scale, if; 7460 // Maximum and Minimum are not defined.; 7461 if (Hoption.Logx) {; 7462 if (xmin <=0 || xmax <=0) {; 7463 Error(where, ""Cannot set Y axis to log scale"");; 7464 return 0;; 7465 }; 7466 xmin = TMath::Log10(xmin);; 7467 if (!minimum) xmin += TMath::Log10(0.5);; 7468 xmax = TMath::Log10(xmax);; 7469 if (!maximum) xmax += TMath::Log10(2*(0.9/0.95));; 7470 if (!Hoption.Same) {; 7471 Hparam.xmin = xmin;; 7472 Hparam.xmax = xmax;; 7473 }; 7474 return 1;; 7475 }; 7476 ; 7477 // final adjustment of ymin for linear scale.; 7478 // if minimum is not set , then ymin is set to zero if >0; 7479 // or to ymin - margin if <0.; 7480 if (!minimum) {; 7481 if (xmin >= 0) xmin = 0;; 7482 else xmin -= yMARGIN*(xmax-xmin);; 7483 }; 7484 ; 7485 // final adjustment of YMAXI for linear scale (if not option ""Same""):; 7486 // decrease histogram height to MAX% of allowed height if HMAXIM; 7487 // has not been called.; 7488 if (!maximum) {; 7489 xmax += yMARGIN*(xmax-xmin);; 7490 }; 7491 Hparam.xmin = xmin;; 7492 Hparam.xmax = xmax;; 7493 return 1;; 7494}; 7495 ; 7496////////////////////////////////////////////////////////////////////////////////; 7497/// [Control fun",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:379266,Testability,log,log,379266,"fH->GetListOfFunctions();; 10531}; 10532 ; 10533////////////////////////////////////////////////////////////////////////////////; 10534/// Initialize various options to draw 2D histograms.; 10535 ; 10536Int_t THistPainter::TableInit(); 10537{; 10538 ; 10539 static const char *where = ""TableInit"";; 10540 ; 10541 Int_t first, last;; 10542 Double_t yMARGIN= gStyle->GetHistTopMargin();; 10543 Double_t zmin, zmax;; 10544 Int_t maximum = 0;; 10545 Int_t minimum = 0;; 10546 if (fH->GetMaximumStored() != -1111) maximum = 1;; 10547 if (fH->GetMinimumStored() != -1111) minimum = 1;; 10548 ; 10549 // ----------------- Compute X axis parameters; 10550 first = fXaxis->GetFirst();; 10551 last = fXaxis->GetLast();; 10552 Hparam.xlast = last;; 10553 Hparam.xfirst = first;; 10554 Hparam.xlowedge = fXaxis->GetBinLowEdge(first);; 10555 Hparam.xbinsize = fXaxis->GetBinWidth(first);; 10556 Hparam.xmin = Hparam.xlowedge;; 10557 Hparam.xmax = fXaxis->GetBinLowEdge(last)+fXaxis->GetBinWidth(last);; 10558 ; 10559 // if log scale in X, replace xmin,max by the log; 10560 if (Hoption.Logx) {; 10561 // find the first edge of a bin that is > 0; 10562 if (Hparam.xlowedge <=0 ) {; 10563 Hparam.xlowedge = fXaxis->GetBinUpEdge(fXaxis->FindFixBin(0.01*Hparam.xbinsize));; 10564 Hparam.xmin = Hparam.xlowedge;; 10565 }; 10566 if (Hparam.xmin <=0 || Hparam.xmax <=0) {; 10567 Error(where, ""cannot set X axis to log scale"");; 10568 return 0;; 10569 }; 10570 Hparam.xfirst= fXaxis->FindFixBin(Hparam.xmin);; 10571 if (Hparam.xfirst < first) Hparam.xfirst = first;; 10572 Hparam.xlast = fXaxis->FindFixBin(Hparam.xmax);; 10573 if (Hparam.xlast > last) Hparam.xlast = last;; 10574 Hparam.xmin = TMath::Log10(Hparam.xmin);; 10575 Hparam.xmax = TMath::Log10(Hparam.xmax);; 10576 }; 10577 ; 10578 // ----------------- Compute Y axis parameters; 10579 first = fYaxis->GetFirst();; 10580 last = fYaxis->GetLast();; 10581 Hparam.ylast = last;; 10582 Hparam.yfirst = first;; 10583 Hparam.ylowedge = fYaxis->GetBinLowEdge(first);",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:379306,Testability,log,log,379306,"fH->GetListOfFunctions();; 10531}; 10532 ; 10533////////////////////////////////////////////////////////////////////////////////; 10534/// Initialize various options to draw 2D histograms.; 10535 ; 10536Int_t THistPainter::TableInit(); 10537{; 10538 ; 10539 static const char *where = ""TableInit"";; 10540 ; 10541 Int_t first, last;; 10542 Double_t yMARGIN= gStyle->GetHistTopMargin();; 10543 Double_t zmin, zmax;; 10544 Int_t maximum = 0;; 10545 Int_t minimum = 0;; 10546 if (fH->GetMaximumStored() != -1111) maximum = 1;; 10547 if (fH->GetMinimumStored() != -1111) minimum = 1;; 10548 ; 10549 // ----------------- Compute X axis parameters; 10550 first = fXaxis->GetFirst();; 10551 last = fXaxis->GetLast();; 10552 Hparam.xlast = last;; 10553 Hparam.xfirst = first;; 10554 Hparam.xlowedge = fXaxis->GetBinLowEdge(first);; 10555 Hparam.xbinsize = fXaxis->GetBinWidth(first);; 10556 Hparam.xmin = Hparam.xlowedge;; 10557 Hparam.xmax = fXaxis->GetBinLowEdge(last)+fXaxis->GetBinWidth(last);; 10558 ; 10559 // if log scale in X, replace xmin,max by the log; 10560 if (Hoption.Logx) {; 10561 // find the first edge of a bin that is > 0; 10562 if (Hparam.xlowedge <=0 ) {; 10563 Hparam.xlowedge = fXaxis->GetBinUpEdge(fXaxis->FindFixBin(0.01*Hparam.xbinsize));; 10564 Hparam.xmin = Hparam.xlowedge;; 10565 }; 10566 if (Hparam.xmin <=0 || Hparam.xmax <=0) {; 10567 Error(where, ""cannot set X axis to log scale"");; 10568 return 0;; 10569 }; 10570 Hparam.xfirst= fXaxis->FindFixBin(Hparam.xmin);; 10571 if (Hparam.xfirst < first) Hparam.xfirst = first;; 10572 Hparam.xlast = fXaxis->FindFixBin(Hparam.xmax);; 10573 if (Hparam.xlast > last) Hparam.xlast = last;; 10574 Hparam.xmin = TMath::Log10(Hparam.xmin);; 10575 Hparam.xmax = TMath::Log10(Hparam.xmax);; 10576 }; 10577 ; 10578 // ----------------- Compute Y axis parameters; 10579 first = fYaxis->GetFirst();; 10580 last = fYaxis->GetLast();; 10581 Hparam.ylast = last;; 10582 Hparam.yfirst = first;; 10583 Hparam.ylowedge = fYaxis->GetBinLowEdge(first);",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:379650,Testability,log,log,379650,"ouble_t zmin, zmax;; 10544 Int_t maximum = 0;; 10545 Int_t minimum = 0;; 10546 if (fH->GetMaximumStored() != -1111) maximum = 1;; 10547 if (fH->GetMinimumStored() != -1111) minimum = 1;; 10548 ; 10549 // ----------------- Compute X axis parameters; 10550 first = fXaxis->GetFirst();; 10551 last = fXaxis->GetLast();; 10552 Hparam.xlast = last;; 10553 Hparam.xfirst = first;; 10554 Hparam.xlowedge = fXaxis->GetBinLowEdge(first);; 10555 Hparam.xbinsize = fXaxis->GetBinWidth(first);; 10556 Hparam.xmin = Hparam.xlowedge;; 10557 Hparam.xmax = fXaxis->GetBinLowEdge(last)+fXaxis->GetBinWidth(last);; 10558 ; 10559 // if log scale in X, replace xmin,max by the log; 10560 if (Hoption.Logx) {; 10561 // find the first edge of a bin that is > 0; 10562 if (Hparam.xlowedge <=0 ) {; 10563 Hparam.xlowedge = fXaxis->GetBinUpEdge(fXaxis->FindFixBin(0.01*Hparam.xbinsize));; 10564 Hparam.xmin = Hparam.xlowedge;; 10565 }; 10566 if (Hparam.xmin <=0 || Hparam.xmax <=0) {; 10567 Error(where, ""cannot set X axis to log scale"");; 10568 return 0;; 10569 }; 10570 Hparam.xfirst= fXaxis->FindFixBin(Hparam.xmin);; 10571 if (Hparam.xfirst < first) Hparam.xfirst = first;; 10572 Hparam.xlast = fXaxis->FindFixBin(Hparam.xmax);; 10573 if (Hparam.xlast > last) Hparam.xlast = last;; 10574 Hparam.xmin = TMath::Log10(Hparam.xmin);; 10575 Hparam.xmax = TMath::Log10(Hparam.xmax);; 10576 }; 10577 ; 10578 // ----------------- Compute Y axis parameters; 10579 first = fYaxis->GetFirst();; 10580 last = fYaxis->GetLast();; 10581 Hparam.ylast = last;; 10582 Hparam.yfirst = first;; 10583 Hparam.ylowedge = fYaxis->GetBinLowEdge(first);; 10584 Hparam.ybinsize = fYaxis->GetBinWidth(first);; 10585 if (!Hparam.ybinsize) Hparam.ybinsize = 1;; 10586 Hparam.ymin = Hparam.ylowedge;; 10587 Hparam.ymax = fYaxis->GetBinLowEdge(last)+fYaxis->GetBinWidth(last);; 10588 ; 10589 // if log scale in Y, replace ymin,max by the log; 10590 if (Hoption.Logy) {; 10591 if (Hparam.ylowedge <=0 ) {; 10592 Hparam.ylowedge = fYaxis->GetBinUpEdge(fYa",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:380495,Testability,log,log,380495,"in(0.01*Hparam.xbinsize));; 10564 Hparam.xmin = Hparam.xlowedge;; 10565 }; 10566 if (Hparam.xmin <=0 || Hparam.xmax <=0) {; 10567 Error(where, ""cannot set X axis to log scale"");; 10568 return 0;; 10569 }; 10570 Hparam.xfirst= fXaxis->FindFixBin(Hparam.xmin);; 10571 if (Hparam.xfirst < first) Hparam.xfirst = first;; 10572 Hparam.xlast = fXaxis->FindFixBin(Hparam.xmax);; 10573 if (Hparam.xlast > last) Hparam.xlast = last;; 10574 Hparam.xmin = TMath::Log10(Hparam.xmin);; 10575 Hparam.xmax = TMath::Log10(Hparam.xmax);; 10576 }; 10577 ; 10578 // ----------------- Compute Y axis parameters; 10579 first = fYaxis->GetFirst();; 10580 last = fYaxis->GetLast();; 10581 Hparam.ylast = last;; 10582 Hparam.yfirst = first;; 10583 Hparam.ylowedge = fYaxis->GetBinLowEdge(first);; 10584 Hparam.ybinsize = fYaxis->GetBinWidth(first);; 10585 if (!Hparam.ybinsize) Hparam.ybinsize = 1;; 10586 Hparam.ymin = Hparam.ylowedge;; 10587 Hparam.ymax = fYaxis->GetBinLowEdge(last)+fYaxis->GetBinWidth(last);; 10588 ; 10589 // if log scale in Y, replace ymin,max by the log; 10590 if (Hoption.Logy) {; 10591 if (Hparam.ylowedge <=0 ) {; 10592 Hparam.ylowedge = fYaxis->GetBinUpEdge(fYaxis->FindFixBin(0.01*Hparam.ybinsize));; 10593 Hparam.ymin = Hparam.ylowedge;; 10594 }; 10595 if (Hparam.ymin <=0 || Hparam.ymax <=0) {; 10596 Error(where, ""cannot set Y axis to log scale"");; 10597 return 0;; 10598 }; 10599 Hparam.yfirst= fYaxis->FindFixBin(Hparam.ymin);; 10600 if (Hparam.yfirst < first) Hparam.yfirst = first;; 10601 Hparam.ylast = fYaxis->FindFixBin(Hparam.ymax);; 10602 if (Hparam.ylast > last) Hparam.ylast = last;; 10603 Hparam.ymin = TMath::Log10(Hparam.ymin);; 10604 Hparam.ymax = TMath::Log10(Hparam.ymax);; 10605 }; 10606 ; 10607 ; 10608 // ----------------- Compute Z axis parameters; 10609 Double_t bigp = TMath::Power(10,32);; 10610 zmax = -bigp;; 10611 zmin = bigp;; 10612 Double_t c1, e1;; 10613 Double_t allchan = 0;; 10614 for (Int_t j=Hparam.yfirst; j<=Hparam.ylast;j++) {; 10615 for (Int_t i=Hparam.",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:380535,Testability,log,log,380535,"in(0.01*Hparam.xbinsize));; 10564 Hparam.xmin = Hparam.xlowedge;; 10565 }; 10566 if (Hparam.xmin <=0 || Hparam.xmax <=0) {; 10567 Error(where, ""cannot set X axis to log scale"");; 10568 return 0;; 10569 }; 10570 Hparam.xfirst= fXaxis->FindFixBin(Hparam.xmin);; 10571 if (Hparam.xfirst < first) Hparam.xfirst = first;; 10572 Hparam.xlast = fXaxis->FindFixBin(Hparam.xmax);; 10573 if (Hparam.xlast > last) Hparam.xlast = last;; 10574 Hparam.xmin = TMath::Log10(Hparam.xmin);; 10575 Hparam.xmax = TMath::Log10(Hparam.xmax);; 10576 }; 10577 ; 10578 // ----------------- Compute Y axis parameters; 10579 first = fYaxis->GetFirst();; 10580 last = fYaxis->GetLast();; 10581 Hparam.ylast = last;; 10582 Hparam.yfirst = first;; 10583 Hparam.ylowedge = fYaxis->GetBinLowEdge(first);; 10584 Hparam.ybinsize = fYaxis->GetBinWidth(first);; 10585 if (!Hparam.ybinsize) Hparam.ybinsize = 1;; 10586 Hparam.ymin = Hparam.ylowedge;; 10587 Hparam.ymax = fYaxis->GetBinLowEdge(last)+fYaxis->GetBinWidth(last);; 10588 ; 10589 // if log scale in Y, replace ymin,max by the log; 10590 if (Hoption.Logy) {; 10591 if (Hparam.ylowedge <=0 ) {; 10592 Hparam.ylowedge = fYaxis->GetBinUpEdge(fYaxis->FindFixBin(0.01*Hparam.ybinsize));; 10593 Hparam.ymin = Hparam.ylowedge;; 10594 }; 10595 if (Hparam.ymin <=0 || Hparam.ymax <=0) {; 10596 Error(where, ""cannot set Y axis to log scale"");; 10597 return 0;; 10598 }; 10599 Hparam.yfirst= fYaxis->FindFixBin(Hparam.ymin);; 10600 if (Hparam.yfirst < first) Hparam.yfirst = first;; 10601 Hparam.ylast = fYaxis->FindFixBin(Hparam.ymax);; 10602 if (Hparam.ylast > last) Hparam.ylast = last;; 10603 Hparam.ymin = TMath::Log10(Hparam.ymin);; 10604 Hparam.ymax = TMath::Log10(Hparam.ymax);; 10605 }; 10606 ; 10607 ; 10608 // ----------------- Compute Z axis parameters; 10609 Double_t bigp = TMath::Power(10,32);; 10610 zmax = -bigp;; 10611 zmin = bigp;; 10612 Double_t c1, e1;; 10613 Double_t allchan = 0;; 10614 for (Int_t j=Hparam.yfirst; j<=Hparam.ylast;j++) {; 10615 for (Int_t i=Hparam.",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:380828,Testability,log,log,380828,"is->FindFixBin(Hparam.xmax);; 10573 if (Hparam.xlast > last) Hparam.xlast = last;; 10574 Hparam.xmin = TMath::Log10(Hparam.xmin);; 10575 Hparam.xmax = TMath::Log10(Hparam.xmax);; 10576 }; 10577 ; 10578 // ----------------- Compute Y axis parameters; 10579 first = fYaxis->GetFirst();; 10580 last = fYaxis->GetLast();; 10581 Hparam.ylast = last;; 10582 Hparam.yfirst = first;; 10583 Hparam.ylowedge = fYaxis->GetBinLowEdge(first);; 10584 Hparam.ybinsize = fYaxis->GetBinWidth(first);; 10585 if (!Hparam.ybinsize) Hparam.ybinsize = 1;; 10586 Hparam.ymin = Hparam.ylowedge;; 10587 Hparam.ymax = fYaxis->GetBinLowEdge(last)+fYaxis->GetBinWidth(last);; 10588 ; 10589 // if log scale in Y, replace ymin,max by the log; 10590 if (Hoption.Logy) {; 10591 if (Hparam.ylowedge <=0 ) {; 10592 Hparam.ylowedge = fYaxis->GetBinUpEdge(fYaxis->FindFixBin(0.01*Hparam.ybinsize));; 10593 Hparam.ymin = Hparam.ylowedge;; 10594 }; 10595 if (Hparam.ymin <=0 || Hparam.ymax <=0) {; 10596 Error(where, ""cannot set Y axis to log scale"");; 10597 return 0;; 10598 }; 10599 Hparam.yfirst= fYaxis->FindFixBin(Hparam.ymin);; 10600 if (Hparam.yfirst < first) Hparam.yfirst = first;; 10601 Hparam.ylast = fYaxis->FindFixBin(Hparam.ymax);; 10602 if (Hparam.ylast > last) Hparam.ylast = last;; 10603 Hparam.ymin = TMath::Log10(Hparam.ymin);; 10604 Hparam.ymax = TMath::Log10(Hparam.ymax);; 10605 }; 10606 ; 10607 ; 10608 // ----------------- Compute Z axis parameters; 10609 Double_t bigp = TMath::Power(10,32);; 10610 zmax = -bigp;; 10611 zmin = bigp;; 10612 Double_t c1, e1;; 10613 Double_t allchan = 0;; 10614 for (Int_t j=Hparam.yfirst; j<=Hparam.ylast;j++) {; 10615 for (Int_t i=Hparam.xfirst; i<=Hparam.xlast;i++) {; 10616 c1 = fH->GetBinContent(i,j);; 10617 zmax = TMath::Max(zmax,c1);; 10618 if (Hoption.Error) {; 10619 e1 = fH->GetBinError(i,j);; 10620 zmax = TMath::Max(zmax,c1+e1);; 10621 }; 10622 zmin = TMath::Min(zmin,c1);; 10623 allchan += c1;; 10624 }; 10625 }; 10626 ; 10627 // Take into account maximum , minimum; 10",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:382014,Testability,log,log,382014," last) Hparam.ylast = last;; 10603 Hparam.ymin = TMath::Log10(Hparam.ymin);; 10604 Hparam.ymax = TMath::Log10(Hparam.ymax);; 10605 }; 10606 ; 10607 ; 10608 // ----------------- Compute Z axis parameters; 10609 Double_t bigp = TMath::Power(10,32);; 10610 zmax = -bigp;; 10611 zmin = bigp;; 10612 Double_t c1, e1;; 10613 Double_t allchan = 0;; 10614 for (Int_t j=Hparam.yfirst; j<=Hparam.ylast;j++) {; 10615 for (Int_t i=Hparam.xfirst; i<=Hparam.xlast;i++) {; 10616 c1 = fH->GetBinContent(i,j);; 10617 zmax = TMath::Max(zmax,c1);; 10618 if (Hoption.Error) {; 10619 e1 = fH->GetBinError(i,j);; 10620 zmax = TMath::Max(zmax,c1+e1);; 10621 }; 10622 zmin = TMath::Min(zmin,c1);; 10623 allchan += c1;; 10624 }; 10625 }; 10626 ; 10627 // Take into account maximum , minimum; 10628 ; 10629 if (maximum) zmax = fH->GetMaximumStored();; 10630 if (minimum) zmin = fH->GetMinimumStored();; 10631 if (Hoption.Logz && zmax < 0) {; 10632 if (!Hoption.Same) Error(where, ""log scale is requested but maximum is less or equal 0 (%f)"", zmax);; 10633 return 0;; 10634 } else if (Hoption.Logz && zmin>=0 && zmax==0) { // empty histogram in log scale; 10635 zmin = 0.01;; 10636 zmax = 10.;; 10637 }; 10638 if (zmin >= zmax) {; 10639 if (Hoption.Logz) {; 10640 if (zmax > 0) zmin = 0.001*zmax;; 10641 else {; 10642 if (!Hoption.Same) Error(where, ""log scale is requested but maximum is less or equal 0 (%f)"", zmax);; 10643 return 0;; 10644 }; 10645 }; 10646 }; 10647 ; 10648 // take into account normalization factor; 10649 Hparam.allchan = allchan;; 10650 Double_t factor = allchan;; 10651 if (fH->GetNormFactor() > 0) factor = fH->GetNormFactor();; 10652 if (allchan) factor /= allchan;; 10653 if (factor == 0) factor = 1;; 10654 Hparam.factor = factor;; 10655 zmax = factor*zmax;; 10656 zmin = factor*zmin;; 10657 c1 = zmax;; 10658 if (TMath::Abs(zmin) > TMath::Abs(c1)) c1 = zmin;; 10659 ; 10660 // For log scales, histogram coordinates are log10(ymin) and; 10661 // log10(ymax). Final adjustment (if not option ""Same""); ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:382177,Testability,log,log,382177,"og10(Hparam.ymax);; 10605 }; 10606 ; 10607 ; 10608 // ----------------- Compute Z axis parameters; 10609 Double_t bigp = TMath::Power(10,32);; 10610 zmax = -bigp;; 10611 zmin = bigp;; 10612 Double_t c1, e1;; 10613 Double_t allchan = 0;; 10614 for (Int_t j=Hparam.yfirst; j<=Hparam.ylast;j++) {; 10615 for (Int_t i=Hparam.xfirst; i<=Hparam.xlast;i++) {; 10616 c1 = fH->GetBinContent(i,j);; 10617 zmax = TMath::Max(zmax,c1);; 10618 if (Hoption.Error) {; 10619 e1 = fH->GetBinError(i,j);; 10620 zmax = TMath::Max(zmax,c1+e1);; 10621 }; 10622 zmin = TMath::Min(zmin,c1);; 10623 allchan += c1;; 10624 }; 10625 }; 10626 ; 10627 // Take into account maximum , minimum; 10628 ; 10629 if (maximum) zmax = fH->GetMaximumStored();; 10630 if (minimum) zmin = fH->GetMinimumStored();; 10631 if (Hoption.Logz && zmax < 0) {; 10632 if (!Hoption.Same) Error(where, ""log scale is requested but maximum is less or equal 0 (%f)"", zmax);; 10633 return 0;; 10634 } else if (Hoption.Logz && zmin>=0 && zmax==0) { // empty histogram in log scale; 10635 zmin = 0.01;; 10636 zmax = 10.;; 10637 }; 10638 if (zmin >= zmax) {; 10639 if (Hoption.Logz) {; 10640 if (zmax > 0) zmin = 0.001*zmax;; 10641 else {; 10642 if (!Hoption.Same) Error(where, ""log scale is requested but maximum is less or equal 0 (%f)"", zmax);; 10643 return 0;; 10644 }; 10645 }; 10646 }; 10647 ; 10648 // take into account normalization factor; 10649 Hparam.allchan = allchan;; 10650 Double_t factor = allchan;; 10651 if (fH->GetNormFactor() > 0) factor = fH->GetNormFactor();; 10652 if (allchan) factor /= allchan;; 10653 if (factor == 0) factor = 1;; 10654 Hparam.factor = factor;; 10655 zmax = factor*zmax;; 10656 zmin = factor*zmin;; 10657 c1 = zmax;; 10658 if (TMath::Abs(zmin) > TMath::Abs(c1)) c1 = zmin;; 10659 ; 10660 // For log scales, histogram coordinates are log10(ymin) and; 10661 // log10(ymax). Final adjustment (if not option ""Same""); 10662 // or ""+"" for ymax) of ymax and ymin for logarithmic scale, if; 10663 // Maximum and Minimum are n",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:382383,Testability,log,log,382383," for (Int_t i=Hparam.xfirst; i<=Hparam.xlast;i++) {; 10616 c1 = fH->GetBinContent(i,j);; 10617 zmax = TMath::Max(zmax,c1);; 10618 if (Hoption.Error) {; 10619 e1 = fH->GetBinError(i,j);; 10620 zmax = TMath::Max(zmax,c1+e1);; 10621 }; 10622 zmin = TMath::Min(zmin,c1);; 10623 allchan += c1;; 10624 }; 10625 }; 10626 ; 10627 // Take into account maximum , minimum; 10628 ; 10629 if (maximum) zmax = fH->GetMaximumStored();; 10630 if (minimum) zmin = fH->GetMinimumStored();; 10631 if (Hoption.Logz && zmax < 0) {; 10632 if (!Hoption.Same) Error(where, ""log scale is requested but maximum is less or equal 0 (%f)"", zmax);; 10633 return 0;; 10634 } else if (Hoption.Logz && zmin>=0 && zmax==0) { // empty histogram in log scale; 10635 zmin = 0.01;; 10636 zmax = 10.;; 10637 }; 10638 if (zmin >= zmax) {; 10639 if (Hoption.Logz) {; 10640 if (zmax > 0) zmin = 0.001*zmax;; 10641 else {; 10642 if (!Hoption.Same) Error(where, ""log scale is requested but maximum is less or equal 0 (%f)"", zmax);; 10643 return 0;; 10644 }; 10645 }; 10646 }; 10647 ; 10648 // take into account normalization factor; 10649 Hparam.allchan = allchan;; 10650 Double_t factor = allchan;; 10651 if (fH->GetNormFactor() > 0) factor = fH->GetNormFactor();; 10652 if (allchan) factor /= allchan;; 10653 if (factor == 0) factor = 1;; 10654 Hparam.factor = factor;; 10655 zmax = factor*zmax;; 10656 zmin = factor*zmin;; 10657 c1 = zmax;; 10658 if (TMath::Abs(zmin) > TMath::Abs(c1)) c1 = zmin;; 10659 ; 10660 // For log scales, histogram coordinates are log10(ymin) and; 10661 // log10(ymax). Final adjustment (if not option ""Same""); 10662 // or ""+"" for ymax) of ymax and ymin for logarithmic scale, if; 10663 // Maximum and Minimum are not defined.; 10664 if (Hoption.Logz) {; 10665 if (zmin <= 0) {; 10666 zmin = TMath::Min((Double_t)1, (Double_t)0.001*zmax);; 10667 fH->SetMinimum(zmin);; 10668 }; 10669 zmin = TMath::Log10(zmin);; 10670 if (!minimum) zmin += TMath::Log10(0.5);; 10671 zmax = TMath::Log10(zmax);; 10672 if (!maximum) zm",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:382942,Testability,log,log,382942,"inimum) zmin = fH->GetMinimumStored();; 10631 if (Hoption.Logz && zmax < 0) {; 10632 if (!Hoption.Same) Error(where, ""log scale is requested but maximum is less or equal 0 (%f)"", zmax);; 10633 return 0;; 10634 } else if (Hoption.Logz && zmin>=0 && zmax==0) { // empty histogram in log scale; 10635 zmin = 0.01;; 10636 zmax = 10.;; 10637 }; 10638 if (zmin >= zmax) {; 10639 if (Hoption.Logz) {; 10640 if (zmax > 0) zmin = 0.001*zmax;; 10641 else {; 10642 if (!Hoption.Same) Error(where, ""log scale is requested but maximum is less or equal 0 (%f)"", zmax);; 10643 return 0;; 10644 }; 10645 }; 10646 }; 10647 ; 10648 // take into account normalization factor; 10649 Hparam.allchan = allchan;; 10650 Double_t factor = allchan;; 10651 if (fH->GetNormFactor() > 0) factor = fH->GetNormFactor();; 10652 if (allchan) factor /= allchan;; 10653 if (factor == 0) factor = 1;; 10654 Hparam.factor = factor;; 10655 zmax = factor*zmax;; 10656 zmin = factor*zmin;; 10657 c1 = zmax;; 10658 if (TMath::Abs(zmin) > TMath::Abs(c1)) c1 = zmin;; 10659 ; 10660 // For log scales, histogram coordinates are log10(ymin) and; 10661 // log10(ymax). Final adjustment (if not option ""Same""); 10662 // or ""+"" for ymax) of ymax and ymin for logarithmic scale, if; 10663 // Maximum and Minimum are not defined.; 10664 if (Hoption.Logz) {; 10665 if (zmin <= 0) {; 10666 zmin = TMath::Min((Double_t)1, (Double_t)0.001*zmax);; 10667 fH->SetMinimum(zmin);; 10668 }; 10669 zmin = TMath::Log10(zmin);; 10670 if (!minimum) zmin += TMath::Log10(0.5);; 10671 zmax = TMath::Log10(zmax);; 10672 if (!maximum) zmax += TMath::Log10(2*(0.9/0.95));; 10673 goto LZMIN;; 10674 }; 10675 ; 10676 // final adjustment of YMAXI for linear scale (if not option ""Same""):; 10677 // decrease histogram height to MAX% of allowed height if HMAXIM; 10678 // has not been called.; 10679 // MAX% is the value in percent which has been set in HPLSET; 10680 // (default is 90%).; 10681 if (!maximum) {; 10682 zmax += yMARGIN*(zmax-zmin);; 10683 }; 10684 ; 10685 //",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:383107,Testability,log,logarithmic,383107,"0;; 10634 } else if (Hoption.Logz && zmin>=0 && zmax==0) { // empty histogram in log scale; 10635 zmin = 0.01;; 10636 zmax = 10.;; 10637 }; 10638 if (zmin >= zmax) {; 10639 if (Hoption.Logz) {; 10640 if (zmax > 0) zmin = 0.001*zmax;; 10641 else {; 10642 if (!Hoption.Same) Error(where, ""log scale is requested but maximum is less or equal 0 (%f)"", zmax);; 10643 return 0;; 10644 }; 10645 }; 10646 }; 10647 ; 10648 // take into account normalization factor; 10649 Hparam.allchan = allchan;; 10650 Double_t factor = allchan;; 10651 if (fH->GetNormFactor() > 0) factor = fH->GetNormFactor();; 10652 if (allchan) factor /= allchan;; 10653 if (factor == 0) factor = 1;; 10654 Hparam.factor = factor;; 10655 zmax = factor*zmax;; 10656 zmin = factor*zmin;; 10657 c1 = zmax;; 10658 if (TMath::Abs(zmin) > TMath::Abs(c1)) c1 = zmin;; 10659 ; 10660 // For log scales, histogram coordinates are log10(ymin) and; 10661 // log10(ymax). Final adjustment (if not option ""Same""); 10662 // or ""+"" for ymax) of ymax and ymin for logarithmic scale, if; 10663 // Maximum and Minimum are not defined.; 10664 if (Hoption.Logz) {; 10665 if (zmin <= 0) {; 10666 zmin = TMath::Min((Double_t)1, (Double_t)0.001*zmax);; 10667 fH->SetMinimum(zmin);; 10668 }; 10669 zmin = TMath::Log10(zmin);; 10670 if (!minimum) zmin += TMath::Log10(0.5);; 10671 zmax = TMath::Log10(zmax);; 10672 if (!maximum) zmax += TMath::Log10(2*(0.9/0.95));; 10673 goto LZMIN;; 10674 }; 10675 ; 10676 // final adjustment of YMAXI for linear scale (if not option ""Same""):; 10677 // decrease histogram height to MAX% of allowed height if HMAXIM; 10678 // has not been called.; 10679 // MAX% is the value in percent which has been set in HPLSET; 10680 // (default is 90%).; 10681 if (!maximum) {; 10682 zmax += yMARGIN*(zmax-zmin);; 10683 }; 10684 ; 10685 // final adjustment of ymin for linear scale.; 10686 // if minimum is not set , then ymin is set to zero if >0; 10687 // or to ymin - yMARGIN if <0.; 10688 if (!minimum) {; 10689 if (Hoption.MinimumZero)",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:495074,Testability,log,logarithm,495074,"ition fillpatterns.C:1; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; exDouble_t ex[n]Definition legend1.C:17; h1TH1F * h1Definition legend1.C:5; f1TF1 * f1Definition legend1.C:11; c2return c2Definition legend2.C:14; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf...Definition TMath.cxx:637; TMath::ATanDouble_t ATan(Double_t)Returns the principal value of the arc tangent of x, expressed in radians.Definition TMath.h:640; TMath::PiOver2constexpr Double_t PiOver2()Definition TMath.h:51; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::DegToRadconstexpr Double_t DegToRad()Conversion from degree to radian: .Definition TMath.h:79; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::AreEqualRelBool_t AreEqualRel(Double_t af, Double_t bf, Double_t relPrec)Comparing floating points.Definition TMath.h:426; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::TanDouble_t Tan(Double_t)Returns the tangent of an angle of x radians.Definition TMath.h:600; TMath::BinarySearchLong64_t BinarySearch(Lo",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:496337,Testability,log,logarithm,496337,"h::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::AreEqualRelBool_t AreEqualRel(Double_t af, Double_t bf, Double_t relPrec)Comparing floating points.Definition TMath.h:426; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::TanDouble_t Tan(Double_t)Returns the tangent of an angle of x radians.Definition TMath.h:600; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347; TMath::RadToDegconstexpr Double_t RadToDeg()Conversion from radian to degree: .Definition TMath.h:72; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; arrowDefinition RArrowDS.hxx:17; graphDefinition graph.py:1; v@ vDefinition rootcling_impl.cxx:3699; Hoption_tHistograms' drawing options structure.Definition Hoption.h:24; Hoption_t::Curveint Curve""C"" A smooth Curve is drawn.Definition Hoption.h:32; Hoption_t::Projint Proj""AITOFF"", ""MERCATOR"", ""SINUSOIDAL"" and ""PARABOLIC"" projections for 2d plots.Definition Hoption.h:59; Hoption_t::Axisint Axis""A"" Axis are not drawn around the graph.Definition Hoption.h:30; Hoption_t::Boxint Box""BOX"" Draw 2D plot with proportional Boxes.Definition Hoption.h:41; Hoption_t::Scatint Scat""SCAT"" Draw 2D plot a Scatter plot.Definition Hoption.h:48; Hoption_t::Textint Text""TEXT"" Draw 2D plot with the content of each cell.Definition Hoption.h:50; Hoption_t::Colorint Color""COL"" Draw 2D plot with Colored boxes.Definition Hoption.h:43; H",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:5413,Usability,usab,usable,5413,"ing using OpenGL](\ref HP29); 118 - [General information: plot types and supported options](\ref HP29a); 119 - [TH3 as color boxes](\ref HP290); 120 - [TH3 as boxes (spheres)](\ref HP29b); 121 - [TH3 as iso-surface(s)](\ref HP29c); 122 - [TF3 (implicit function)](\ref HP29d); 123 - [Parametric surfaces](\ref HP29e); 124 - [Interaction with the plots](\ref HP29f); 125 - [Selectable parts](\ref HP29g); 126 - [Rotation and zooming](\ref HP29h); 127 - [Panning](\ref HP29i); 128 - [Box cut](\ref HP29j); 129 - [Plot specific interactions (dynamic slicing etc.)](\ref HP29k); 130 - [Surface with option ""GLSURF""](\ref HP29l); 131 - [TF3](\ref HP29m); 132 - [Box](\ref HP29n); 133 - [Iso](\ref HP29o); 134 - [Parametric plot](\ref HP29p); 135- [Highlight mode for histogram](\ref HP30); 136 - [Highlight mode and user function](\ref HP30a); 137 ; 138 ; 139\anchor HP00; 140## Introduction; 141 ; 142 ; 143Histograms are drawn via the `THistPainter` class. Each histogram has a; 144pointer to its own painter (to be usable in a multithreaded program). When the; 145canvas has to be redrawn, the `Paint` function of each objects in the; 146pad is called. In case of histograms, `TH1::Paint` invokes directly; 147`THistPainter::Paint`.; 148 ; 149To draw a histogram `h` it is enough to do:; 150 ; 151 h->Draw();; 152 ; 153`h` can be of any kind: 1D, 2D or 3D. To choose how the histogram will; 154be drawn, the `Draw()` method can be invoked with an option. For instance; 155to draw a 2D histogram as a lego plot it is enough to do:; 156 ; 157 h->Draw(""lego"");; 158 ; 159`THistPainter` offers many options to paint 1D, 2D and 3D histograms.; 160 ; 161When the `Draw()` method of a histogram is called for the first time; 162(`TH1::Draw`), it creates a `THistPainter` object and saves a; 163pointer to this ""painter"" as a data member of the histogram. The; 164`THistPainter` class specializes in the drawing of histograms. It is; 165separated from the histogram so that one can have histograms without the; ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:7078,Usability,clear,clears,7078,"led for the first time; 162(`TH1::Draw`), it creates a `THistPainter` object and saves a; 163pointer to this ""painter"" as a data member of the histogram. The; 164`THistPainter` class specializes in the drawing of histograms. It is; 165separated from the histogram so that one can have histograms without the; 166graphics overhead, for example in a batch program. Each histogram having its own; 167painter (rather than a central singleton painter painting all histograms), allows; 168two histograms to be drawn in two threads without overwriting the painter's; 169values.; 170 ; 171When a displayed histogram is filled again, there is no need to call the; 172`Draw()` method again; the image will be refreshed the next time the; 173pad will be updated.; 174 ; 175A pad is updated after one of these three actions:; 176 ; 1771. a carriage control on the ROOT command line,; 1782. a click inside the pad,; 1793. a call to `TPad::Update`.; 180 ; 181 ; 182By default a call to `TH1::Draw()` clears the pad of all objects; 183before drawing the new image of the histogram. One can use the `SAME`; 184option to leave the previous display intact and superimpose the new histogram.; 185The same histogram can be drawn with different graphics options in different; 186pads.; 187 ; 188When a displayed histogram is deleted, its image is automatically removed; 189from the pad.; 190 ; 191To create a copy of the histogram when drawing it, one can use; 192`TH1::DrawClone()`. This will clone the histogram and allow to change; 193and delete the original one without affecting the clone.; 194 ; 195 ; 196\anchor HP01; 197### Histograms' plotting options; 198 ; 199 ; 200Most options can be concatenated with or without spaces or commas, for example:; 201 ; 202 h->Draw(""E1 SAME"");; 203 ; 204The options are not case sensitive:; 205 ; 206 h->Draw(""e1 same"");; 207 ; 208 ; 209The default drawing option can be set with `TH1::SetOption` and retrieve; 210using `TH1::GetOption`:; 211 ; 212 root [0] h->Draw(); // Draw ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:21147,Usability,clear,cleared,21147,"tick marks and labels on top side are drawn; 395 ty = 1; tick marks on right side are drawn (inside); 396 ty = 2; tick marks and labels on right side are drawn; 397 ; 398By default only the left Y axis and X bottom axis are drawn; 399(`tx = ty = 0`); 400 ; 401`TPad::SetTicks(tx,ty)` allows to set these options.; 402See also The `TAxis` functions to set specific axis attributes.; 403 ; 404In case multiple color filled histograms are drawn on the same pad, the fill; 405area may hide the axis tick marks. One can force a redraw of the axis over all; 406the histograms by calling:; 407 ; 408 gPad->RedrawAxis();; 409 ; 410 ; 411\anchor HP05; 412### Giving titles to the X, Y and Z axis; 413 ; 414 ; 415 h->GetXaxis()->SetTitle(""X axis title"");; 416 h->GetYaxis()->SetTitle(""Y axis title"");; 417 ; 418The histogram title and the axis titles can be any `TLatex` string.; 419The titles are part of the persistent histogram.; 420 ; 421 ; 422\anchor HP060; 423### The option ""SAME""; 424 ; 425 ; 426By default, when an histogram is drawn, the current pad is cleared before; 427drawing. In order to keep the previous drawing and draw on top of it the; 428option `SAME` should be use. The histogram drawn with the option; 429`SAME` uses the coordinates system available in the current pad.; 430 ; 431This option can be used alone or combined with any valid drawing option but; 432some combinations must be use with care.; 433 ; 434\anchor HP060a; 435#### Limitations; 436 ; 437- It does not work when combined with the `LEGO` and `SURF` options unless the; 438 histogram plotted with the option `SAME` has exactly the same; 439 ranges on the X, Y and Z axis as the currently drawn histogram. To superimpose; 440 lego plots [histograms' stacks](\ref HP26) should be used.; 441 ; 442 ; 443\anchor HP061; 444### Colors automatically picked in palette; 445 ; 446\since **ROOT version 6.09/01**; 447 ; 448When several histograms are painted in the same canvas thanks to the option ""SAME""; 449or via a `THStack` it",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:22177,Usability,simpl,simplest,22177,"ng and draw on top of it the; 428option `SAME` should be use. The histogram drawn with the option; 429`SAME` uses the coordinates system available in the current pad.; 430 ; 431This option can be used alone or combined with any valid drawing option but; 432some combinations must be use with care.; 433 ; 434\anchor HP060a; 435#### Limitations; 436 ; 437- It does not work when combined with the `LEGO` and `SURF` options unless the; 438 histogram plotted with the option `SAME` has exactly the same; 439 ranges on the X, Y and Z axis as the currently drawn histogram. To superimpose; 440 lego plots [histograms' stacks](\ref HP26) should be used.; 441 ; 442 ; 443\anchor HP061; 444### Colors automatically picked in palette; 445 ; 446\since **ROOT version 6.09/01**; 447 ; 448When several histograms are painted in the same canvas thanks to the option ""SAME""; 449or via a `THStack` it might be useful to have an easy and automatic way to choose; 450their color. The simplest way is to pick colors in the current active color; 451palette. Palette coloring for histogram is activated thanks to the options `PFC`; 452(Palette Fill Color), `PLC` (Palette Line Color) and `PMC` (Palette Marker Color).; 453When one of these options is given to `TH1::Draw` the histogram get its color; 454from the current color palette defined by `gStyle->SetPalette(...)`. The color; 455is determined according to the number of objects having palette coloring in; 456the current pad.; 457 ; 458Begin_Macro(source); 459../../../tutorials/hist/histpalettecolor.C; 460End_Macro; 461 ; 462Begin_Macro(source); 463../../../tutorials/hist/thstackpalettecolor.C; 464End_Macro; 465 ; 466Begin_Macro(source); 467../../../tutorials/hist/thstack2palettecolor.C; 468End_Macro; 469 ; 470\anchor HP06; 471### Superimposing two histograms with different scales in the same pad; 472 ; 473 ; 474The following example creates two histograms, the second histogram is the bins; 475integral of the first one. It shows a procedure to draw the",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:32781,Usability,simpl,simple,32781,"om->Gaus(0,1));; 706 gStyle->SetEndErrorSize(3);; 707 gStyle->SetErrorX(1.);; 708 he->SetMarkerStyle(20);; 709 he->Draw(""E1"");; 710}; 711End_Macro; 712 ; 713The options ""E3"" and ""E4"" draw an error band through the end points of the; 714vertical error bars. With ""E4"" the error band is smoothed. Because of the; 715smoothing algorithm used some artefacts may appear at the end of the band; 716like in the following example. In such cases ""E3"" should be used instead; 717of ""E4"".; 718 ; 719Begin_Macro(source); 720{; 721 auto ce4 = new TCanvas(""ce4"",""ce4"",600,400);; 722 ce4->Divide(2,1);; 723 auto he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; 724 Int_t i;; 725 for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; 726 he4->SetFillColor(kRed);; 727 he4->GetXaxis()->SetRange(40,48);; 728 ce4->cd(1);; 729 he4->Draw(""E4"");; 730 ce4->cd(2);; 731 auto he3 = (TH1F*)he4->DrawClone(""E3"");; 732 he3->SetTitle(""Distribution drawn option E3"");; 733}; 734End_Macro; 735 ; 7362D histograms can be drawn with error bars as shown is the following example:; 737 ; 738Begin_Macro(source); 739{; 740 auto c2e = new TCanvas(""c2e"",""c2e"",600,400);; 741 auto h2e = new TH2F(""h2e"",""TH2 drawn with option E"",40,-4,4,40,-20,20);; 742 float px, py;; 743 for (Int_t i = 0; i < 25000; i++) {; 744 gRandom->Rannor(px,py);; 745 h2e->Fill(px,5*py);; 746 }; 747 h2e->Draw(""E"");; 748}; 749End_Macro; 750 ; 751 ; 752\anchor HP100; 753### The bar chart option; 754 ; 755 ; 756The option ""B"" allows to draw simple vertical bar charts.; 757The bar width is controlled with `TH1::SetBarWidth()`,; 758and the bar offset within the bin, with `TH1::SetBarOffset()`.; 759These two settings are useful to draw several histograms on the; 760same plot as shown in the following example:; 761 ; 762Begin_Macro(source); 763{; 764 int i;; 765 const Int_t nx = 8;; 766 string os_X[nx] = {""8"",""32"",""128"",""512"",""2048"",""8192"",""32768"",""131072""};; 767 float d_35_0[nx] = {0.75, -3.30, -0.92, 0.10, 0.08, -1.69, -1.29, -2.37};; 76",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:58890,Usability,simpl,simple,58890,"; 1388In case the significance of the median is greater that the size of the box, the; 1389box will have an unnatural shape. Usually it means the chart has not enough data,; 1390or that representing this uncertainty is not useful; 1391 ; 1392##### The Mean; 1393The mean can be drawn as a dashed line or as a circle or not drawn at all.; 1394The mean is the arithmetic average of the values in the distribution.; 1395It is calculated using GetMean(). Because histograms are; 1396binned data, the mean value can differ from a calculation on the raw-data.; 1397If the distribution is large enough and gaussian shaped the mean will be; 1398exactly the median.; 1399 ; 1400##### The Whiskers; 1401The whiskers represent the part of the distribution not covered by the box.; 1402The upper 25% and the lower 25% of the distribution are located within the whiskers.; 1403Two representations are available.; 1404 ; 1405 - A simple one (using w=1) defining the lower whisker from the lowest data value; 1406 to the bottom of the box, and the upper whisker from the top of the box to the; 1407 highest data value. In this representation the whisker-lines are dashed.; 1408 - A more complex one having a further restriction. The whiskers are still connected; 1409 to the box but their length cannot exceed \f$ 1.5\times iqr \f$. So it might; 1410 be that the outermost part of the underlying distribution will not be covered; 1411 by the whiskers. Usually these missing parts will be represented by the outliers; 1412 (see points). Of course the upper and the lower whisker may differ in length.; 1413 In this representation the whiskers are drawn as solid lines.; 1414 ; 1415\since **ROOT version 6.11/01**; 1416 ; 1417Using the static function TCandle::SetWhiskerRange(double) the whisker definition w=1; 1418will be overwritten. E.g. using a whisker-range of 0.95 and w=1 will redefine the area of; 1419the lower whisker to the upper whisker in order to cover 95% of the distribution inside; 1420that candle. ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:67331,Usability,simpl,simple,67331,"bin with the maximum content of each individual violin is; 1558set to a constant value using SetBarWidth(). The static function will affect all violin-charts; 1559in the running program. Default is true. Scaling between multiple violin-charts; 1560(using ""same"" or THStack) is not supported, yet.; 1561 ; 1562##### The zero indicator line; 1563Typical for violin charts is a line in the background over the whole histogram indicating; 1564the bins with zero entries. The zero indicator line can be activated with z=1. The line color; 1565will always be the same as the fill-color of the histogram.; 1566 ; 1567##### The Mean; 1568The Mean is illustrated with the same mechanism as used for candle plots. Usually a circle is used.; 1569 ; 1570##### Whiskers; 1571The whiskers are illustrated by the same mechanism as used for candle plots. There is only one; 1572difference. When using the simple whisker definition (w=1) and the zero indicator line (z=1), then; 1573the whiskers will be forced to be solid (usually hashed); 1574 ; 1575##### Points; 1576The points are illustrated by the same mechanism as used for candle plots. E.g. VIOLIN2 uses; 1577better whisker definition (w=2) and outliers (p=1).; 1578 ; 1579##### Other options; 1580It is possible to combine all options of candle or violin plots with each other. E.g. a violin plot; 1581including a box-plot.; 1582 ; 1583#### How to use the violin-plots drawing option; 1584 ; 1585There are two predefined violin-plot representations:; 1586 - ""VIOLINX1"": Standard violin (histogram, mean, whisker over full distribution,; 1587 zero indicator line); 1588 - ""VIOLINX2"": Line VIOLINX1 both with better whisker definition + outliers.; 1589 ; 1590A solid fill style is recommended for this plot (as opposed to a hollow or; 1591hashed style).; 1592 ; 1593Begin_Macro(source); 1594{; 1595 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 1596 Int_t nx(6), ny(40);; 1597 double xmin(0.0), xmax(+6.0), ymin(0.0), ymax(+4.0);; 1598 auto hviolin = new TH2F(""h",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:96231,Usability,simpl,simple,96231,"| ""SCAT"" | Draw a scatter plot (legacy draw option).|; 2339| ""COL"" | Draw a color plot. All the bins are painted even the empty bins (default).|; 2340| ""COLZ"" | Same as ""COL"". In addition the color palette is also drawn.|; 2341| ""0"" | When used with any COL options, the empty bins are not drawn.|; 2342| ""TEXT"" | Draw bin contents as text (format set via `gStyle->SetPaintTextFormat`).|; 2343| ""TEXTN"" | Draw bin names as text.|; 2344| ""TEXTnn"" | Draw bin contents as text at angle nn (0 < nn <= 90).|; 2345| ""L"" | Draw the bins boundaries as lines. The lines attributes are the TGraphs ones.|; 2346| ""P"" | Draw the bins boundaries as markers. The markers attributes are the TGraphs ones.|; 2347| ""F"" | Draw the bins boundaries as filled polygons. The filled polygons attributes are the TGraphs ones.|; 2348 ; 2349 ; 2350 ; 2351`TH2Poly` can be drawn as a color plot (option COL). `TH2Poly` bins can have any; 2352shapes. The bins are defined as graphs. The following macro is a very simple; 2353example showing how to book a TH2Poly and draw it.; 2354 ; 2355Begin_Macro(source); 2356{; 2357 auto ch2p1 = new TCanvas(""ch2p1"",""ch2p1"",600,400);; 2358 auto h2p = new TH2Poly();; 2359 h2p->SetName(""h2poly_name"");; 2360 h2p->SetTitle(""h2poly_title"");; 2361 double px1[] = {0, 5, 6};; 2362 double py1[] = {0, 0, 5};; 2363 double px2[] = {0, -1, -1, 0};; 2364 double py2[] = {0, 0, -1, 3};; 2365 double px3[] = {4, 3, 0, 1, 2.4};; 2366 double py3[] = {4, 3.7, 1, 3.7, 2.5};; 2367 h2p->AddBin(3, px1, py1);; 2368 h2p->AddBin(4, px2, py2);; 2369 h2p->AddBin(5, px3, py3);; 2370 h2p->Fill(0.1, 0.01, 3);; 2371 h2p->Fill(-0.5, -0.5, 7);; 2372 h2p->Fill(-0.7, -0.5, 1);; 2373 h2p->Fill(1, 3, 1.5);; 2374 double fx[] = {0.1, -0.5, -0.7, 1};; 2375 double fy[] = {0.01, -0.5, -0.5, 3};; 2376 double fw[] = {3, 1, 1, 1.5};; 2377 h2p->FillN(4, fx, fy, fw);; 2378 h2p->Draw(""col"");; 2379}; 2380End_Macro; 2381 ; 2382Rectangular bins are a frequent case. The special version of; 2383the `AddBin` method allows to defin",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:123630,Usability,simpl,simplified,123630,"hanism. `TCanvas::Highlighted()` is similar; 3094`TCanvas::Picked()`; 3095 ; 3096- when selected object (histogram as a whole) is different from previous; 3097then emit `Picked()` signal; 3098- when selected (highlighted) bin from histogram is different from previous; 3099then emit `Highlighted()` signal; 3100 ; 3101Any user function (or functions) has to be defined; 3102`UserFunction(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y)`.; 3103In example (see below) has name `PrintInfo()`. All parameters of user; 3104function are taken from; 3105 ; 3106 void TCanvas::Highlighted(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y); 3107 ; 3108- `pad` is pointer to pad with highlighted histogram; 3109- `obj` is pointer to highlighted histogram; 3110- `x` is highlighted x bin for 1D histogram; 3111- `y` is highlighted y bin for 2D histogram (for 1D histogram not in use); 3112 ; 3113Example how to create a connection from any `TCanvas` object to a user; 3114`UserFunction()` slot (see also `TQObject::Connect()` for additional info); 3115 ; 3116 TQObject::Connect(""TCanvas"", ""Highlighted(TVirtualPad*,TObject*,Int_t,Int_t)"",; 3117 0, 0, ""UserFunction(TVirtualPad*,TObject*,Int_t,Int_t)"");; 3118 ; 3119or use non-static ""simplified"" function; 3120`TCanvas::HighlightConnect(const char *slot)`; 3121 ; 3122 c1->HighlightConnect(""UserFunction(TVirtualPad*,TObject*,Int_t,Int_t)"");; 3123 ; 3124NOTE the signal and slot string must have a form; 3125""(TVirtualPad*,TObject*,Int_t,Int_t)""; 3126 ; 3127 root [0] .x $ROOTSYS/tutorials/hsimple.C; 3128 root [1] hpx->SetHighlight(kTRUE); 3129 root [2] .x hlprint.C; 3130 ; 3131file `hlprint.C`; 3132~~~ {.cpp}; 3133void PrintInfo(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y); 3134{; 3135 auto h = (TH1F *)obj;; 3136 if (!h->IsHighlight()) // after highlight disabled; 3137 h->SetTitle(""highlight disable"");; 3138 else; 3139 h->SetTitle(TString::Format(""bin[%03d] (%5.2f) content %g"", x,; 3140 h->GetBinCenter(x), h->GetBinContent(x)));; 3141 pad->Updat",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:124641,Usability,simpl,simple,124641,"t char *slot)`; 3121 ; 3122 c1->HighlightConnect(""UserFunction(TVirtualPad*,TObject*,Int_t,Int_t)"");; 3123 ; 3124NOTE the signal and slot string must have a form; 3125""(TVirtualPad*,TObject*,Int_t,Int_t)""; 3126 ; 3127 root [0] .x $ROOTSYS/tutorials/hsimple.C; 3128 root [1] hpx->SetHighlight(kTRUE); 3129 root [2] .x hlprint.C; 3130 ; 3131file `hlprint.C`; 3132~~~ {.cpp}; 3133void PrintInfo(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y); 3134{; 3135 auto h = (TH1F *)obj;; 3136 if (!h->IsHighlight()) // after highlight disabled; 3137 h->SetTitle(""highlight disable"");; 3138 else; 3139 h->SetTitle(TString::Format(""bin[%03d] (%5.2f) content %g"", x,; 3140 h->GetBinCenter(x), h->GetBinContent(x)));; 3141 pad->Update();; 3142}; 3143 ; 3144void hlprint(); 3145{; 3146 if (!gPad) return;; 3147 gPad->GetCanvas()->HighlightConnect(""PrintInfo(TVirtualPad*,TObject*,Int_t,Int_t)"");; 3148}; 3149~~~; 3150 ; 3151\image html hlsimple.gif ""Highlight mode and simple user function""; 3152 ; 3153For more complex demo please see for example `$ROOTSYS/tutorials/tree/temperature.C` file.; 3154 ; 3155*/; 3156 ; 3157TH1 *gCurrentHist = nullptr;; 3158 ; 3159Hoption_t Hoption;; 3160Hparam_t Hparam;; 3161 ; 3162const Int_t kNMAX = 2000;; 3163 ; 3164const Int_t kMAXCONTOUR = 104;; 3165const UInt_t kCannotRotate = BIT(11);; 3166 ; 3167static std::unique_ptr<TBox> gXHighlightBox, gYHighlightBox; // highlight X and Y box; 3168 ; 3169static TString gStringEntries;; 3170static TString gStringMean;; 3171static TString gStringMeanX;; 3172static TString gStringMeanY;; 3173static TString gStringMeanZ;; 3174static TString gStringStdDev;; 3175static TString gStringStdDevX;; 3176static TString gStringStdDevY;; 3177static TString gStringStdDevZ;; 3178static TString gStringUnderflow;; 3179static TString gStringOverflow;; 3180static TString gStringIntegral;; 3181static TString gStringIntegralBinWidth;; 3182static TString gStringSkewness;; 3183static TString gStringSkewnessX;; 3184static TString gStringSkewnessY;",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:128617,Usability,simpl,simple,128617," gEnv->GetValue(""Hist.Stats.SkewnessY"", ""Skewness y"");; 3232 gStringSkewnessZ = gEnv->GetValue(""Hist.Stats.SkewnessZ"", ""Skewness z"");; 3233 gStringKurtosis = gEnv->GetValue(""Hist.Stats.Kurtosis"", ""Kurtosis"");; 3234 gStringKurtosisX = gEnv->GetValue(""Hist.Stats.KurtosisX"", ""Kurtosis x"");; 3235 gStringKurtosisY = gEnv->GetValue(""Hist.Stats.KurtosisY"", ""Kurtosis y"");; 3236 gStringKurtosisZ = gEnv->GetValue(""Hist.Stats.KurtosisZ"", ""Kurtosis z"");; 3237}; 3238 ; 3239////////////////////////////////////////////////////////////////////////////////; 3240/// destructor.; 3241 ; 3242THistPainter::~THistPainter(); 3243{; 3244}; 3245 ; 3246////////////////////////////////////////////////////////////////////////////////; 3247/// Compute the distance from the point px,py to a line.; 3248///; 3249/// Compute the closest distance of approach from point px,py to elements of; 3250/// an histogram. The distance is computed in pixels units.; 3251///; 3252/// Algorithm: Currently, this simple model computes the distance from the mouse; 3253/// to the histogram contour only.; 3254 ; 3255Int_t THistPainter::DistancetoPrimitive(Int_t px, Int_t py); 3256{; 3257 ; 3258 Double_t defaultLabelSize = 0.04; // See TAttAxis.h for source of this value; 3259 ; 3260 const Int_t big = 9999;; 3261 const Int_t kMaxDiff = 7;; 3262 ; 3263 if (fPie); 3264 return fPie->DistancetoPrimitive(px, py);; 3265 ; 3266 Double_t x = gPad->AbsPixeltoX(px);; 3267 Double_t x1 = gPad->AbsPixeltoX(px+1);; 3268 ; 3269 Int_t puxmin = gPad->XtoAbsPixel(gPad->GetUxmin());; 3270 Int_t puymin = gPad->YtoAbsPixel(gPad->GetUymin());; 3271 Int_t puxmax = gPad->XtoAbsPixel(gPad->GetUxmax());; 3272 Int_t puymax = gPad->YtoAbsPixel(gPad->GetUymax());; 3273 Int_t curdist = big;; 3274 Int_t yxaxis, dyaxis,xyaxis, dxaxis;; 3275 Bool_t dsame;; 3276 TObject *PadPointer = gPad->GetPadPointer();; 3277 if (!PadPointer) return 0;; 3278 TString doption = PadPointer->GetDrawOption();; 3279 Double_t factor = 1;; 3280 if (fH->GetNormFactor() != 0) ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:172248,Usability,clear,clear,172248,"the labels in case of alphanumeric labels; 4497 if (fXaxis->CanExtend() && fXaxis->IsAlphanumeric()) fH->LabelsDeflate(""X"");; 4498 if (fYaxis->CanExtend() && fYaxis->IsAlphanumeric()) fH->LabelsDeflate(""Y"");; 4499 if (fZaxis->CanExtend() && fZaxis->IsAlphanumeric()) fH->LabelsDeflate(""Z"");; 4500 ; 4501 if (Hoption.Pie) {; 4502 if (fH->GetDimension() == 1) {; 4503 if (!fPie); 4504 fPie = std::make_unique<TPie>(fH);; 4505 fPie->Paint(option);; 4506 } else {; 4507 Error(""Paint"", ""Option PIE is for 1D histograms only"");; 4508 }; 4509 return;; 4510 } else {; 4511 fPie.reset();; 4512 }; 4513 ; 4514 fXbuf.resize(kNMAX);; 4515 fYbuf.resize(kNMAX);; 4516 if (fH->GetDimension() > 2) {; 4517 PaintH3(option);; 4518 fH->SetMinimum(minsav);; 4519 if (Hoption.Func) {; 4520 Hoption_t hoptsave = Hoption;; 4521 Hparam_t hparsave = Hparam;; 4522 PaintFunction(option);; 4523 SetHistogram(hsave);; 4524 Hoption = hoptsave;; 4525 Hparam = hparsave;; 4526 }; 4527 gCurrentHist = oldhist;; 4528 fXbuf.clear();; 4529 fYbuf.clear();; 4530 return;; 4531 }; 4532 TView *view = gPad->GetView();; 4533 if (view) {; 4534 if (!Hoption.Lego && !Hoption.Surf && !Hoption.Tri) {; 4535 delete view;; 4536 gPad->SetView(nullptr);; 4537 }; 4538 }; 4539 if (fH->GetDimension() > 1 || Hoption.Lego || Hoption.Surf) {; 4540 // In case of 1D histogram, Z axis becomes Y axis.; 4541 Int_t logysav=0, logzsav=0;; 4542 if (fH->GetDimension() == 1) {; 4543 logysav = Hoption.Logy;; 4544 logzsav = Hoption.Logz;; 4545 Hoption.Logz = 0;; 4546 if (Hoption.Logy) {; 4547 Hoption.Logz = 1;; 4548 Hoption.Logy = 0;; 4549 }; 4550 }; 4551 PaintTable(option);; 4552 if (Hoption.Func) {; 4553 Hoption_t hoptsave = Hoption;; 4554 Hparam_t hparsave = Hparam;; 4555 PaintFunction(option);; 4556 SetHistogram(hsave);; 4557 Hoption = hoptsave;; 4558 Hparam = hparsave;; 4559 }; 4560 fH->SetMinimum(minsav);; 4561 gCurrentHist = oldhist;; 4562 fXbuf.clear();; 4563 fYbuf.clear();; 4564 if (fH->GetDimension() == 1) {; 4565 Hoption.Logy = logysav;; 45",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:172269,Usability,clear,clear,172269,"Extend() && fXaxis->IsAlphanumeric()) fH->LabelsDeflate(""X"");; 4498 if (fYaxis->CanExtend() && fYaxis->IsAlphanumeric()) fH->LabelsDeflate(""Y"");; 4499 if (fZaxis->CanExtend() && fZaxis->IsAlphanumeric()) fH->LabelsDeflate(""Z"");; 4500 ; 4501 if (Hoption.Pie) {; 4502 if (fH->GetDimension() == 1) {; 4503 if (!fPie); 4504 fPie = std::make_unique<TPie>(fH);; 4505 fPie->Paint(option);; 4506 } else {; 4507 Error(""Paint"", ""Option PIE is for 1D histograms only"");; 4508 }; 4509 return;; 4510 } else {; 4511 fPie.reset();; 4512 }; 4513 ; 4514 fXbuf.resize(kNMAX);; 4515 fYbuf.resize(kNMAX);; 4516 if (fH->GetDimension() > 2) {; 4517 PaintH3(option);; 4518 fH->SetMinimum(minsav);; 4519 if (Hoption.Func) {; 4520 Hoption_t hoptsave = Hoption;; 4521 Hparam_t hparsave = Hparam;; 4522 PaintFunction(option);; 4523 SetHistogram(hsave);; 4524 Hoption = hoptsave;; 4525 Hparam = hparsave;; 4526 }; 4527 gCurrentHist = oldhist;; 4528 fXbuf.clear();; 4529 fYbuf.clear();; 4530 return;; 4531 }; 4532 TView *view = gPad->GetView();; 4533 if (view) {; 4534 if (!Hoption.Lego && !Hoption.Surf && !Hoption.Tri) {; 4535 delete view;; 4536 gPad->SetView(nullptr);; 4537 }; 4538 }; 4539 if (fH->GetDimension() > 1 || Hoption.Lego || Hoption.Surf) {; 4540 // In case of 1D histogram, Z axis becomes Y axis.; 4541 Int_t logysav=0, logzsav=0;; 4542 if (fH->GetDimension() == 1) {; 4543 logysav = Hoption.Logy;; 4544 logzsav = Hoption.Logz;; 4545 Hoption.Logz = 0;; 4546 if (Hoption.Logy) {; 4547 Hoption.Logz = 1;; 4548 Hoption.Logy = 0;; 4549 }; 4550 }; 4551 PaintTable(option);; 4552 if (Hoption.Func) {; 4553 Hoption_t hoptsave = Hoption;; 4554 Hparam_t hparsave = Hparam;; 4555 PaintFunction(option);; 4556 SetHistogram(hsave);; 4557 Hoption = hoptsave;; 4558 Hparam = hparsave;; 4559 }; 4560 fH->SetMinimum(minsav);; 4561 gCurrentHist = oldhist;; 4562 fXbuf.clear();; 4563 fYbuf.clear();; 4564 if (fH->GetDimension() == 1) {; 4565 Hoption.Logy = logysav;; 4566 Hoption.Logz = logzsav;; 4567 }; 4568 return;; 4569 }; 4570 ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:173159,Usability,clear,clear,173159,"ve;; 4525 Hparam = hparsave;; 4526 }; 4527 gCurrentHist = oldhist;; 4528 fXbuf.clear();; 4529 fYbuf.clear();; 4530 return;; 4531 }; 4532 TView *view = gPad->GetView();; 4533 if (view) {; 4534 if (!Hoption.Lego && !Hoption.Surf && !Hoption.Tri) {; 4535 delete view;; 4536 gPad->SetView(nullptr);; 4537 }; 4538 }; 4539 if (fH->GetDimension() > 1 || Hoption.Lego || Hoption.Surf) {; 4540 // In case of 1D histogram, Z axis becomes Y axis.; 4541 Int_t logysav=0, logzsav=0;; 4542 if (fH->GetDimension() == 1) {; 4543 logysav = Hoption.Logy;; 4544 logzsav = Hoption.Logz;; 4545 Hoption.Logz = 0;; 4546 if (Hoption.Logy) {; 4547 Hoption.Logz = 1;; 4548 Hoption.Logy = 0;; 4549 }; 4550 }; 4551 PaintTable(option);; 4552 if (Hoption.Func) {; 4553 Hoption_t hoptsave = Hoption;; 4554 Hparam_t hparsave = Hparam;; 4555 PaintFunction(option);; 4556 SetHistogram(hsave);; 4557 Hoption = hoptsave;; 4558 Hparam = hparsave;; 4559 }; 4560 fH->SetMinimum(minsav);; 4561 gCurrentHist = oldhist;; 4562 fXbuf.clear();; 4563 fYbuf.clear();; 4564 if (fH->GetDimension() == 1) {; 4565 Hoption.Logy = logysav;; 4566 Hoption.Logz = logzsav;; 4567 }; 4568 return;; 4569 }; 4570 ; 4571 if (Hoption.Bar >= 20) {; 4572 PaintBarH(option);; 4573 fXbuf.clear();; 4574 fYbuf.clear();; 4575 return;; 4576 }; 4577 ; 4578 gPad->RangeAxisChanged(); //emit RangeAxisChanged() signal to sync axes; 4579 // fill Hparam structure with histo parameters; 4580 if (!PaintInit()) {; 4581 fXbuf.clear();; 4582 fYbuf.clear();; 4583 return;; 4584 }; 4585 ; 4586 // Picture surround (if new page) and page number (if requested).; 4587 // Histogram surround (if not option ""Same"").; 4588 PaintFrame();; 4589 ; 4590 // Paint histogram axis only; 4591 Bool_t gridx = gPad->GetGridx();; 4592 Bool_t gridy = gPad->GetGridy();; 4593 if (Hoption.Axis > 0) {; 4594 if (Hoption.Axis > 1) PaintAxis(kTRUE); //axis with grid; 4595 else {; 4596 if (gridx) gPad->SetGridx(0);; 4597 if (gridy) gPad->SetGridy(0);; 4598 PaintAxis(kFALSE);; 4599 if (gridx) gPad->Se",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:173180,Usability,clear,clear,173180,"7 gCurrentHist = oldhist;; 4528 fXbuf.clear();; 4529 fYbuf.clear();; 4530 return;; 4531 }; 4532 TView *view = gPad->GetView();; 4533 if (view) {; 4534 if (!Hoption.Lego && !Hoption.Surf && !Hoption.Tri) {; 4535 delete view;; 4536 gPad->SetView(nullptr);; 4537 }; 4538 }; 4539 if (fH->GetDimension() > 1 || Hoption.Lego || Hoption.Surf) {; 4540 // In case of 1D histogram, Z axis becomes Y axis.; 4541 Int_t logysav=0, logzsav=0;; 4542 if (fH->GetDimension() == 1) {; 4543 logysav = Hoption.Logy;; 4544 logzsav = Hoption.Logz;; 4545 Hoption.Logz = 0;; 4546 if (Hoption.Logy) {; 4547 Hoption.Logz = 1;; 4548 Hoption.Logy = 0;; 4549 }; 4550 }; 4551 PaintTable(option);; 4552 if (Hoption.Func) {; 4553 Hoption_t hoptsave = Hoption;; 4554 Hparam_t hparsave = Hparam;; 4555 PaintFunction(option);; 4556 SetHistogram(hsave);; 4557 Hoption = hoptsave;; 4558 Hparam = hparsave;; 4559 }; 4560 fH->SetMinimum(minsav);; 4561 gCurrentHist = oldhist;; 4562 fXbuf.clear();; 4563 fYbuf.clear();; 4564 if (fH->GetDimension() == 1) {; 4565 Hoption.Logy = logysav;; 4566 Hoption.Logz = logzsav;; 4567 }; 4568 return;; 4569 }; 4570 ; 4571 if (Hoption.Bar >= 20) {; 4572 PaintBarH(option);; 4573 fXbuf.clear();; 4574 fYbuf.clear();; 4575 return;; 4576 }; 4577 ; 4578 gPad->RangeAxisChanged(); //emit RangeAxisChanged() signal to sync axes; 4579 // fill Hparam structure with histo parameters; 4580 if (!PaintInit()) {; 4581 fXbuf.clear();; 4582 fYbuf.clear();; 4583 return;; 4584 }; 4585 ; 4586 // Picture surround (if new page) and page number (if requested).; 4587 // Histogram surround (if not option ""Same"").; 4588 PaintFrame();; 4589 ; 4590 // Paint histogram axis only; 4591 Bool_t gridx = gPad->GetGridx();; 4592 Bool_t gridy = gPad->GetGridy();; 4593 if (Hoption.Axis > 0) {; 4594 if (Hoption.Axis > 1) PaintAxis(kTRUE); //axis with grid; 4595 else {; 4596 if (gridx) gPad->SetGridx(0);; 4597 if (gridy) gPad->SetGridy(0);; 4598 PaintAxis(kFALSE);; 4599 if (gridx) gPad->SetGridx(1);; 4600 if (gridy) gPad->SetGri",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:173391,Usability,clear,clear,173391,"option.Tri) {; 4535 delete view;; 4536 gPad->SetView(nullptr);; 4537 }; 4538 }; 4539 if (fH->GetDimension() > 1 || Hoption.Lego || Hoption.Surf) {; 4540 // In case of 1D histogram, Z axis becomes Y axis.; 4541 Int_t logysav=0, logzsav=0;; 4542 if (fH->GetDimension() == 1) {; 4543 logysav = Hoption.Logy;; 4544 logzsav = Hoption.Logz;; 4545 Hoption.Logz = 0;; 4546 if (Hoption.Logy) {; 4547 Hoption.Logz = 1;; 4548 Hoption.Logy = 0;; 4549 }; 4550 }; 4551 PaintTable(option);; 4552 if (Hoption.Func) {; 4553 Hoption_t hoptsave = Hoption;; 4554 Hparam_t hparsave = Hparam;; 4555 PaintFunction(option);; 4556 SetHistogram(hsave);; 4557 Hoption = hoptsave;; 4558 Hparam = hparsave;; 4559 }; 4560 fH->SetMinimum(minsav);; 4561 gCurrentHist = oldhist;; 4562 fXbuf.clear();; 4563 fYbuf.clear();; 4564 if (fH->GetDimension() == 1) {; 4565 Hoption.Logy = logysav;; 4566 Hoption.Logz = logzsav;; 4567 }; 4568 return;; 4569 }; 4570 ; 4571 if (Hoption.Bar >= 20) {; 4572 PaintBarH(option);; 4573 fXbuf.clear();; 4574 fYbuf.clear();; 4575 return;; 4576 }; 4577 ; 4578 gPad->RangeAxisChanged(); //emit RangeAxisChanged() signal to sync axes; 4579 // fill Hparam structure with histo parameters; 4580 if (!PaintInit()) {; 4581 fXbuf.clear();; 4582 fYbuf.clear();; 4583 return;; 4584 }; 4585 ; 4586 // Picture surround (if new page) and page number (if requested).; 4587 // Histogram surround (if not option ""Same"").; 4588 PaintFrame();; 4589 ; 4590 // Paint histogram axis only; 4591 Bool_t gridx = gPad->GetGridx();; 4592 Bool_t gridy = gPad->GetGridy();; 4593 if (Hoption.Axis > 0) {; 4594 if (Hoption.Axis > 1) PaintAxis(kTRUE); //axis with grid; 4595 else {; 4596 if (gridx) gPad->SetGridx(0);; 4597 if (gridy) gPad->SetGridy(0);; 4598 PaintAxis(kFALSE);; 4599 if (gridx) gPad->SetGridx(1);; 4600 if (gridy) gPad->SetGridy(1);; 4601 }; 4602 if ((Hoption.Same%10) ==1) Hoption.Same += 1;; 4603 goto paintstat;; 4604 }; 4605 if (gridx || gridy) PaintAxis(kTRUE); // Draw the grid only; 4606 ; 4607 // test for opti",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:173412,Usability,clear,clear,173412," Hoption.Lego || Hoption.Surf) {; 4540 // In case of 1D histogram, Z axis becomes Y axis.; 4541 Int_t logysav=0, logzsav=0;; 4542 if (fH->GetDimension() == 1) {; 4543 logysav = Hoption.Logy;; 4544 logzsav = Hoption.Logz;; 4545 Hoption.Logz = 0;; 4546 if (Hoption.Logy) {; 4547 Hoption.Logz = 1;; 4548 Hoption.Logy = 0;; 4549 }; 4550 }; 4551 PaintTable(option);; 4552 if (Hoption.Func) {; 4553 Hoption_t hoptsave = Hoption;; 4554 Hparam_t hparsave = Hparam;; 4555 PaintFunction(option);; 4556 SetHistogram(hsave);; 4557 Hoption = hoptsave;; 4558 Hparam = hparsave;; 4559 }; 4560 fH->SetMinimum(minsav);; 4561 gCurrentHist = oldhist;; 4562 fXbuf.clear();; 4563 fYbuf.clear();; 4564 if (fH->GetDimension() == 1) {; 4565 Hoption.Logy = logysav;; 4566 Hoption.Logz = logzsav;; 4567 }; 4568 return;; 4569 }; 4570 ; 4571 if (Hoption.Bar >= 20) {; 4572 PaintBarH(option);; 4573 fXbuf.clear();; 4574 fYbuf.clear();; 4575 return;; 4576 }; 4577 ; 4578 gPad->RangeAxisChanged(); //emit RangeAxisChanged() signal to sync axes; 4579 // fill Hparam structure with histo parameters; 4580 if (!PaintInit()) {; 4581 fXbuf.clear();; 4582 fYbuf.clear();; 4583 return;; 4584 }; 4585 ; 4586 // Picture surround (if new page) and page number (if requested).; 4587 // Histogram surround (if not option ""Same"").; 4588 PaintFrame();; 4589 ; 4590 // Paint histogram axis only; 4591 Bool_t gridx = gPad->GetGridx();; 4592 Bool_t gridy = gPad->GetGridy();; 4593 if (Hoption.Axis > 0) {; 4594 if (Hoption.Axis > 1) PaintAxis(kTRUE); //axis with grid; 4595 else {; 4596 if (gridx) gPad->SetGridx(0);; 4597 if (gridy) gPad->SetGridy(0);; 4598 PaintAxis(kFALSE);; 4599 if (gridx) gPad->SetGridx(1);; 4600 if (gridy) gPad->SetGridy(1);; 4601 }; 4602 if ((Hoption.Same%10) ==1) Hoption.Same += 1;; 4603 goto paintstat;; 4604 }; 4605 if (gridx || gridy) PaintAxis(kTRUE); // Draw the grid only; 4606 ; 4607 // test for options BAR or HBAR; 4608 if (Hoption.Bar >= 10) {; 4609 PaintBar(option);; 4610 }; 4611 ; 4612 // do not draw histogr",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:173619,Usability,clear,clear,173619,"ogzsav=0;; 4542 if (fH->GetDimension() == 1) {; 4543 logysav = Hoption.Logy;; 4544 logzsav = Hoption.Logz;; 4545 Hoption.Logz = 0;; 4546 if (Hoption.Logy) {; 4547 Hoption.Logz = 1;; 4548 Hoption.Logy = 0;; 4549 }; 4550 }; 4551 PaintTable(option);; 4552 if (Hoption.Func) {; 4553 Hoption_t hoptsave = Hoption;; 4554 Hparam_t hparsave = Hparam;; 4555 PaintFunction(option);; 4556 SetHistogram(hsave);; 4557 Hoption = hoptsave;; 4558 Hparam = hparsave;; 4559 }; 4560 fH->SetMinimum(minsav);; 4561 gCurrentHist = oldhist;; 4562 fXbuf.clear();; 4563 fYbuf.clear();; 4564 if (fH->GetDimension() == 1) {; 4565 Hoption.Logy = logysav;; 4566 Hoption.Logz = logzsav;; 4567 }; 4568 return;; 4569 }; 4570 ; 4571 if (Hoption.Bar >= 20) {; 4572 PaintBarH(option);; 4573 fXbuf.clear();; 4574 fYbuf.clear();; 4575 return;; 4576 }; 4577 ; 4578 gPad->RangeAxisChanged(); //emit RangeAxisChanged() signal to sync axes; 4579 // fill Hparam structure with histo parameters; 4580 if (!PaintInit()) {; 4581 fXbuf.clear();; 4582 fYbuf.clear();; 4583 return;; 4584 }; 4585 ; 4586 // Picture surround (if new page) and page number (if requested).; 4587 // Histogram surround (if not option ""Same"").; 4588 PaintFrame();; 4589 ; 4590 // Paint histogram axis only; 4591 Bool_t gridx = gPad->GetGridx();; 4592 Bool_t gridy = gPad->GetGridy();; 4593 if (Hoption.Axis > 0) {; 4594 if (Hoption.Axis > 1) PaintAxis(kTRUE); //axis with grid; 4595 else {; 4596 if (gridx) gPad->SetGridx(0);; 4597 if (gridy) gPad->SetGridy(0);; 4598 PaintAxis(kFALSE);; 4599 if (gridx) gPad->SetGridx(1);; 4600 if (gridy) gPad->SetGridy(1);; 4601 }; 4602 if ((Hoption.Same%10) ==1) Hoption.Same += 1;; 4603 goto paintstat;; 4604 }; 4605 if (gridx || gridy) PaintAxis(kTRUE); // Draw the grid only; 4606 ; 4607 // test for options BAR or HBAR; 4608 if (Hoption.Bar >= 10) {; 4609 PaintBar(option);; 4610 }; 4611 ; 4612 // do not draw histogram if error bars required; 4613 if (!Hoption.Error) {; 4614 if (Hoption.Hist && Hoption.Bar<10) PaintHist(option);",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:173640,Usability,clear,clear,173640,"ption.Logy;; 4544 logzsav = Hoption.Logz;; 4545 Hoption.Logz = 0;; 4546 if (Hoption.Logy) {; 4547 Hoption.Logz = 1;; 4548 Hoption.Logy = 0;; 4549 }; 4550 }; 4551 PaintTable(option);; 4552 if (Hoption.Func) {; 4553 Hoption_t hoptsave = Hoption;; 4554 Hparam_t hparsave = Hparam;; 4555 PaintFunction(option);; 4556 SetHistogram(hsave);; 4557 Hoption = hoptsave;; 4558 Hparam = hparsave;; 4559 }; 4560 fH->SetMinimum(minsav);; 4561 gCurrentHist = oldhist;; 4562 fXbuf.clear();; 4563 fYbuf.clear();; 4564 if (fH->GetDimension() == 1) {; 4565 Hoption.Logy = logysav;; 4566 Hoption.Logz = logzsav;; 4567 }; 4568 return;; 4569 }; 4570 ; 4571 if (Hoption.Bar >= 20) {; 4572 PaintBarH(option);; 4573 fXbuf.clear();; 4574 fYbuf.clear();; 4575 return;; 4576 }; 4577 ; 4578 gPad->RangeAxisChanged(); //emit RangeAxisChanged() signal to sync axes; 4579 // fill Hparam structure with histo parameters; 4580 if (!PaintInit()) {; 4581 fXbuf.clear();; 4582 fYbuf.clear();; 4583 return;; 4584 }; 4585 ; 4586 // Picture surround (if new page) and page number (if requested).; 4587 // Histogram surround (if not option ""Same"").; 4588 PaintFrame();; 4589 ; 4590 // Paint histogram axis only; 4591 Bool_t gridx = gPad->GetGridx();; 4592 Bool_t gridy = gPad->GetGridy();; 4593 if (Hoption.Axis > 0) {; 4594 if (Hoption.Axis > 1) PaintAxis(kTRUE); //axis with grid; 4595 else {; 4596 if (gridx) gPad->SetGridx(0);; 4597 if (gridy) gPad->SetGridy(0);; 4598 PaintAxis(kFALSE);; 4599 if (gridx) gPad->SetGridx(1);; 4600 if (gridy) gPad->SetGridy(1);; 4601 }; 4602 if ((Hoption.Same%10) ==1) Hoption.Same += 1;; 4603 goto paintstat;; 4604 }; 4605 if (gridx || gridy) PaintAxis(kTRUE); // Draw the grid only; 4606 ; 4607 // test for options BAR or HBAR; 4608 if (Hoption.Bar >= 10) {; 4609 PaintBar(option);; 4610 }; 4611 ; 4612 // do not draw histogram if error bars required; 4613 if (!Hoption.Error) {; 4614 if (Hoption.Hist && Hoption.Bar<10) PaintHist(option);; 4615 }; 4616 ; 4617 // test for error bars or option E; 4618 if",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:176101,Usability,clear,clear,176101,"4635 if (gridx) gPad->SetGridx(0);; 4636 if (gridy) gPad->SetGridy(0);; 4637 PaintAxis(kFALSE);; 4638 if (gridx) gPad->SetGridx(1);; 4639 if (gridy) gPad->SetGridy(1);; 4640 ; 4641 PaintTitle(); // Draw histogram title; 4642 ; 4643 // Draw box with histogram statistics and/or fit parameters; 4644paintstat:; 4645 if ((Hoption.Same%10) != 1 && !fH->TestBit(TH1::kNoStats)) { // bit set via TH1::SetStats; 4646 TIter next(fFunctions);; 4647 TObject *obj = nullptr;; 4648 while ((obj = next())) {; 4649 if (obj->InheritsFrom(TF1::Class())) break;; 4650 obj = nullptr;; 4651 }; 4652 ; 4653 //Stat is painted twice (first, it will be in canvas' list of primitives),; 4654 //second, it will be here, this is not required on iOS.; 4655 //Condition is ALWAYS true on a platform different from iOS.; 4656 if (!gPad->PadInSelectionMode() && !gPad->PadInHighlightMode()); 4657 PaintStat(gStyle->GetOptStat(),(TF1*)obj);; 4658 }; 4659 fH->SetMinimum(minsav);; 4660 gCurrentHist = oldhist;; 4661 fXbuf.clear();; 4662 fYbuf.clear();; 4663}; 4664 ; 4665////////////////////////////////////////////////////////////////////////////////; 4666/// [Control function to draw a table as an arrow plot](\ref HP12); 4667 ; 4668void THistPainter::PaintArrows(Option_t *); 4669{; 4670 Double_t xk, xstep, yk, ystep;; 4671 Double_t dx, dy, x1, x2, y1, y2, xc, yc, dxn, dyn;; 4672 Int_t ncx = Hparam.xlast - Hparam.xfirst + 1;; 4673 Int_t ncy = Hparam.ylast - Hparam.yfirst + 1;; 4674 Double_t xrg = gPad->GetUxmin();; 4675 Double_t yrg = gPad->GetUymin();; 4676 Double_t xln = gPad->GetUxmax() - xrg;; 4677 Double_t yln = gPad->GetUymax() - yrg;; 4678 Double_t cx = (xln/Double_t(ncx))/2.;; 4679 Double_t cy = (yln/Double_t(ncy))/2.;; 4680 Double_t dn = 1.E-30;; 4681 ; 4682 auto arrow = new TArrow();; 4683 arrow->SetAngle(30);; 4684 arrow->SetFillStyle(1001);; 4685 arrow->SetFillColor(fH->GetLineColor());; 4686 arrow->SetLineColor(fH->GetLineColor());; 4687 arrow->SetLineWidth(fH->GetLineWidth());; 4688 ; 4689 // Initiali",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:176122,Usability,clear,clear,176122,"); // Draw histogram title; 4642 ; 4643 // Draw box with histogram statistics and/or fit parameters; 4644paintstat:; 4645 if ((Hoption.Same%10) != 1 && !fH->TestBit(TH1::kNoStats)) { // bit set via TH1::SetStats; 4646 TIter next(fFunctions);; 4647 TObject *obj = nullptr;; 4648 while ((obj = next())) {; 4649 if (obj->InheritsFrom(TF1::Class())) break;; 4650 obj = nullptr;; 4651 }; 4652 ; 4653 //Stat is painted twice (first, it will be in canvas' list of primitives),; 4654 //second, it will be here, this is not required on iOS.; 4655 //Condition is ALWAYS true on a platform different from iOS.; 4656 if (!gPad->PadInSelectionMode() && !gPad->PadInHighlightMode()); 4657 PaintStat(gStyle->GetOptStat(),(TF1*)obj);; 4658 }; 4659 fH->SetMinimum(minsav);; 4660 gCurrentHist = oldhist;; 4661 fXbuf.clear();; 4662 fYbuf.clear();; 4663}; 4664 ; 4665////////////////////////////////////////////////////////////////////////////////; 4666/// [Control function to draw a table as an arrow plot](\ref HP12); 4667 ; 4668void THistPainter::PaintArrows(Option_t *); 4669{; 4670 Double_t xk, xstep, yk, ystep;; 4671 Double_t dx, dy, x1, x2, y1, y2, xc, yc, dxn, dyn;; 4672 Int_t ncx = Hparam.xlast - Hparam.xfirst + 1;; 4673 Int_t ncy = Hparam.ylast - Hparam.yfirst + 1;; 4674 Double_t xrg = gPad->GetUxmin();; 4675 Double_t yrg = gPad->GetUymin();; 4676 Double_t xln = gPad->GetUxmax() - xrg;; 4677 Double_t yln = gPad->GetUymax() - yrg;; 4678 Double_t cx = (xln/Double_t(ncx))/2.;; 4679 Double_t cy = (yln/Double_t(ncy))/2.;; 4680 Double_t dn = 1.E-30;; 4681 ; 4682 auto arrow = new TArrow();; 4683 arrow->SetAngle(30);; 4684 arrow->SetFillStyle(1001);; 4685 arrow->SetFillColor(fH->GetLineColor());; 4686 arrow->SetLineColor(fH->GetLineColor());; 4687 arrow->SetLineWidth(fH->GetLineWidth());; 4688 ; 4689 // Initialize the levels on the Z axis; 4690 Int_t ncolors=0, ndivz=0;; 4691 Double_t scale=0.;; 4692 if (Hoption.Arrow>1) {; 4693 ncolors = gStyle->GetNumberOfColors();; 4694 Int_t ndiv = fH->GetContou",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:206189,Usability,simpl,simply,206189,"GetLast()) ) {; 5493 binOffset++;; 5494 xMin = pAxis->GetBinLowEdge(pAxis->GetFirst()+binOffset);; 5495 }; 5496 if (xMin <= 0) {; 5497 // this should cause an error if we have; 5498 return regions;; 5499 }; 5500 Double_t xMax = pAxis->GetBinUpEdge(pAxis->GetLast());; 5501 ; 5502 if (strategy == Bins) {; 5503 // logarithmic plot. we find the pixel for the bin; 5504 // pixel = eta * log10(V) - alpha; 5505 // where eta = nPixels/(log10(Vmax)-log10(Vmin)); 5506 // and alpha = nPixels*log10(Vmin)/(log10(Vmax)-log10(Vmin)); 5507 // and V is axis value; 5508 Double_t eta = (nPixels-1.0)/(TMath::Log10(xMax) - TMath::Log10(xMin));; 5509 Double_t offset = -1.0 * eta * TMath::Log10(xMin);; 5510 ; 5511 for (Int_t bin=pAxis->GetFirst()+binOffset; bin<=pAxis->GetLast(); bin++) {; 5512 ; 5513 // linear plot. we simply need to find the appropriate bin; 5514 // for the; 5515 Double_t xLowValue = pAxis->GetBinLowEdge(bin);; 5516 Double_t xUpValue = pAxis->GetBinUpEdge(bin);; 5517 Int_t xPx0 = eta*TMath::Log10(xLowValue)+ offset;; 5518 Int_t xPx1 = eta*TMath::Log10(xUpValue) + offset;; 5519 THistRenderingRegion region = {std::make_pair(xPx0, xPx1),; 5520 std::make_pair(bin, bin+1)};; 5521 regions.push_back(region);; 5522 }; 5523 ; 5524 } else {; 5525 ; 5526 // loop over pixels; 5527 ; 5528 Double_t beta = (TMath::Log10(xMax) - TMath::Log10(xMin))/(nPixels-1.0);; 5529 ; 5530 for (Int_t pixelIndex=0; pixelIndex<(nPixels-1); pixelIndex++) {; 5531 // linear plot; 5532 Int_t binLow = pAxis->FindBin(xMin*TMath::Power(10.0, beta*pixelIndex));; 5533 Int_t binHigh = pAxis->FindBin(xMin*TMath::Power(10.0, beta*(pixelIndex+1)));; 5534 THistRenderingRegion region = { std::make_pair(pixelIndex, pixelIndex+1),; 5535 std::make_pair(binLow, binHigh)};; 5536 regions.push_back(region);; 5537 }; 5538 }; 5539 } else {; 5540 // standard linear plot; 5541 ; 5542 if (strategy == Bins) {; 5543 // loop over bins; 5544 for (Int_t bin=pAxis->GetFirst(); bin<=pAxis->GetLast(); bin++) {; 5545 ; 5546 // linear plot",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:207387,Usability,simpl,simply,207387,"ush_back(region);; 5522 }; 5523 ; 5524 } else {; 5525 ; 5526 // loop over pixels; 5527 ; 5528 Double_t beta = (TMath::Log10(xMax) - TMath::Log10(xMin))/(nPixels-1.0);; 5529 ; 5530 for (Int_t pixelIndex=0; pixelIndex<(nPixels-1); pixelIndex++) {; 5531 // linear plot; 5532 Int_t binLow = pAxis->FindBin(xMin*TMath::Power(10.0, beta*pixelIndex));; 5533 Int_t binHigh = pAxis->FindBin(xMin*TMath::Power(10.0, beta*(pixelIndex+1)));; 5534 THistRenderingRegion region = { std::make_pair(pixelIndex, pixelIndex+1),; 5535 std::make_pair(binLow, binHigh)};; 5536 regions.push_back(region);; 5537 }; 5538 }; 5539 } else {; 5540 // standard linear plot; 5541 ; 5542 if (strategy == Bins) {; 5543 // loop over bins; 5544 for (Int_t bin=pAxis->GetFirst(); bin<=pAxis->GetLast(); bin++) {; 5545 ; 5546 // linear plot. we simply need to find the appropriate bin; 5547 // for the; 5548 Int_t xPx0 = ((bin - pAxis->GetFirst()) * nPixels)/nBins;; 5549 Int_t xPx1 = xPx0 + nPixels/nBins;; 5550 ; 5551 // make sure we don't compute beyond our bounds; 5552 if (xPx1>= nPixels) xPx1 = nPixels-1;; 5553 ; 5554 THistRenderingRegion region = {std::make_pair(xPx0, xPx1),; 5555 std::make_pair(bin, bin+1)};; 5556 regions.push_back(region);; 5557 }; 5558 } else {; 5559 // loop over pixels; 5560 for (Int_t pixelIndex=0; pixelIndex<nPixels-1; pixelIndex++) {; 5561 // linear plot; 5562 Int_t binLow = (nBins*pixelIndex)/nPixels + pAxis->GetFirst();; 5563 Int_t binHigh = binLow + nBins/nPixels;; 5564 THistRenderingRegion region = { std::make_pair(pixelIndex, pixelIndex+1),; 5565 std::make_pair(binLow, binHigh)};; 5566 regions.push_back(region);; 5567 }; 5568 }; 5569 }; 5570 ; 5571 return regions;; 5572}; 5573 ; 5574////////////////////////////////////////////////////////////////////////////////; 5575/// [Rendering scheme for the COL2 and COLZ2 options] (\ref HP14); 5576 ; 5577void THistPainter::PaintColorLevelsFast(Option_t*); 5578{; 5579 ; 5580 if (Hoption.System != kCARTESIAN) {; 5581 Error(""THistPainter::PaintCol",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:247390,Usability,clear,clear,247390,"ne3D(temp1, temp2);; 6736 temp1[0] = x;; 6737 temp1[1] = y1;; 6738 temp1[2] = z;; 6739 temp2[0] = x;; 6740 temp2[1] = y2;; 6741 temp2[2] = z;; 6742 gPad->PaintLine3D(temp1, temp2);; 6743 temp1[0] = x;; 6744 temp1[1] = y;; 6745 temp1[2] = z1;; 6746 temp2[0] = x;; 6747 temp2[1] = y;; 6748 temp2[2] = z2;; 6749 gPad->PaintLine3D(temp1, temp2);; 6750 temp1[0] = x;; 6751 temp1[1] = y;; 6752 temp1[2] = z;; 6753 view->WCtoNDC(temp1, &temp2[0]);; 6754 gPad->PaintPolyMarker(1, &temp2[0], &temp2[1]);; 6755 }; 6756 }; 6757 ; 6758 // Paint the Front Box if needed; 6759 if (Hoption.FrontBox) {; 6760 fLego->InitMoveScreen(-1.1,1.1);; 6761 fLego->SetDrawFace(&TPainter3dAlgorithms::DrawFaceMove2);; 6762 fLego->FrontBox(90);; 6763 }; 6764 ; 6765 // Paint the Axis if needed; 6766 if (!Hoption.Axis && !Hoption.Same && !Hoption.Lego && !Hoption.Surf) {; 6767 TGaxis axis;; 6768 PaintLegoAxis(&axis, 90);; 6769 }; 6770 ; 6771 fLego.reset();; 6772}; 6773 ; 6774////////////////////////////////////////////////////////////////////////////////; 6775/// Calculate range and clear pad (canvas).; 6776 ; 6777void THistPainter::PaintFrame(); 6778{; 6779 ; 6780 if (Hoption.Same) return;; 6781 ; 6782 RecalculateRange();; 6783 ; 6784 if (Hoption.Lego || Hoption.Surf || Hoption.Tri ||; 6785 Hoption.Contour == 14 || Hoption.Error >= 100) {; 6786 TObject *frame = gPad->FindObject(""TFrame"");; 6787 if (frame) gPad->Remove(frame);; 6788 return;; 6789 }; 6790 ; 6791 //The next statement is always executed on non-iOS platform,; 6792 //on iOS depends on pad mode.; 6793 if (!gPad->PadInSelectionMode() && !gPad->PadInHighlightMode()); 6794 gPad->PaintPadFrame(Hparam.xmin,Hparam.ymin,Hparam.xmax,Hparam.ymax);; 6795}; 6796 ; 6797////////////////////////////////////////////////////////////////////////////////; 6798/// [Paint functions associated to an histogram.](\ref HP28""); 6799 ; 6800void THistPainter::PaintFunction(Option_t *); 6801{; 6802 auto lnk = fFunctions->FirstLink();; 6803 ; 6804 while (lnk) {; 6805 auto o",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:474226,Usability,clear,clear,474226,"ter::GetBestFormatstatic const char * GetBestFormat(Double_t v, Double_t e, const char *f)This function returns the best format to print the error value (e) knowing the parameter value (v) an...Definition THistPainter.cxx:10714; THistPainter::PaintContourvirtual void PaintContour(Option_t *option)Control function to draw a 2D histogram as a contour plot.Definition THistPainter.cxx:5932; THistPainter::fCutsTCutG * fCuts[kMaxCuts]Pointers to graphical cuts.Definition THistPainter.h:65; THistPainter::PaintTablevirtual void PaintTable(Option_t *option)Control function to draw 2D/3D histograms (tables).Definition THistPainter.cxx:9629; THistPainter::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute the actions corresponding to event.Definition THistPainter.cxx:3464; THistPainter::PaintInitHvirtual Int_t PaintInitH()Compute histogram parameters used by the drawing routines for a rotated pad.Definition THistPainter.cxx:7334; THistPainter::PaintFramevirtual void PaintFrame()Calculate range and clear pad (canvas).Definition THistPainter.cxx:6777; THistPainter::fCutsOptInt_t fCutsOpt[kMaxCuts]Sign of each cut.Definition THistPainter.h:64; THistPainter::PaintH3Isovirtual void PaintH3Iso()Control function to draw a 3D histogram with Iso Surfaces.Definition THistPainter.cxx:7892; THistPainter::fYbufstd::vector< Double_t > fYbufY buffer coordinates.Definition THistPainter.h:62; THistPainter::PaintH3BoxRastervirtual void PaintH3BoxRaster()Control function to draw a 3D histogram with boxes.Definition THistPainter.cxx:7690; THistPainter::PaintHistvirtual void PaintHist(Option_t *option)Control routine to draw 1D histogramsDefinition THistPainter.cxx:6837; THistPainter::SetHighlightvoid SetHighlight() overrideSet highlight (enable/disable) mode for fH.Definition THistPainter.cxx:3857; THistPainter::DefineColorLevelsvirtual void DefineColorLevels(Int_t ndivz)Define the color levels used to paint legos, surfaces etc..Definition THistPainter.cxx:9603; THistP",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8cxx_source.html:499173,Usability,simpl,simple,499173,"plot or violin plot.Definition Hoption.h:53; Hoption_t::Specint Spec""SPEC"" TSpectrum graphicsDefinition Hoption.h:61; Hoption_t::FrontBoxint FrontBox""FB"" Suppress the front box for the 3D plots.Definition Hoption.h:56; Hoption_t::Pieint Pie""PIE"" Draw 1D plot as a pie chart.Definition Hoption.h:52; Hoption_t::Starint Star""*"" With option ""P"", a * is plotted at each point.Definition Hoption.h:39; Hoption_t::Zeroint Zero""0"" if selected with any LEGO option the empty bins are not drawn.Definition Hoption.h:62; Hoption_t::Logzint Logzlog scale in Z. Also set by histogram optionDefinition Hoption.h:72; Hoption_t::Triint Tri""TRI"" Draw TGraph2D with Delaunay triangles.Definition Hoption.h:51; Hoption_t::BackBoxint BackBox""BB"" Suppress the back box for the 3D plots.Definition Hoption.h:57; Hoption_t::Markint Mark""P"" The current Marker is drawn at each point.Definition Hoption.h:37; Hoption_t::Arrowint Arrow""ARR"" Draw 2D plot with Arrows.Definition Hoption.h:40; Hoption_t::Lineint Line""L"" A simple polyline through every point is drawn.Definition Hoption.h:36; Hoption_t::Sameint Same""SAME"" Histogram is plotted in the current pad.Definition Hoption.h:38; Hoption_t::Legoint Lego""LEGO"" and ""LEGOn"" Draw as a Lego plot(1 <= n <= 4).Definition Hoption.h:47; Hoption_t::Barint Bar""B"", ""BAR"" and ""HBAR"" A Bar chart is drawn at each point.Definition Hoption.h:31; Hoption_t::Fillint Fill""F"" A fill area is drawn (""CF"" draw a smooth fill area).Definition Hoption.h:34; Hoption_t::Histint Hist""HIST"" Draw only the histogram.Definition Hoption.h:46; Hoption_t::Surfint Surf""SURF"" and ""SURFn"" Draw as a Surface ((1 <= n <= 4).Definition Hoption.h:49; Hoption_t::Logyint Logylog scale in Y. Also set by histogram optionDefinition Hoption.h:71; Hoption_t::Systemint System""POL"", ""CYL"", ""SPH"" and ""PSR"" Type of coordinate system for 3D plots.Definition Hoption.h:54; Hoption_t::Errorint Error""En"" Draw Errors with current marker type and size (0 <= n <=6).Definition Hoption.h:33; Hparam_tHistogram parameter",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
https://root.cern/doc/master/THistPainter_8h.html:317,Integrability,depend,dependency,317,". ROOT: hist/histpainter/inc/THistPainter.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Variables ; THistPainter.h File Reference. #include ""TVirtualHistPainter.h""; #include ""TString.h""; #include <vector>; #include <utility>; #include <memory>. Include dependency graph for THistPainter.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  THistPainter;  The histogram painter class. More...;  ; struct  THistRenderingRegion;  . Variables; const Int_t kMaxCuts = 16;  . Variable Documentation. ◆ kMaxCuts. const Int_t kMaxCuts = 16. Definition at line 41 of file THistPainter.h. histhistpainterincTHistPainter.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/THistPainter_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8h.html
https://root.cern/doc/master/THistPainter_8h_source.html:9638,Availability,error,error,9638,"; THistPainterThe histogram painter class.Definition THistPainter.h:50; THistPainter::ProjectSinusoidal2xystatic Int_t ProjectSinusoidal2xy(Double_t l, Double_t b, Double_t &Al, Double_t &Ab)Static function code for sinusoidal projection from Ernst-Jan Buis Source https://en....Definition THistPainter.cxx:10380; THistPainter::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histogramsDefinition THistPainter.cxx:4470; THistPainter::fYaxisTAxis * fYaxisPointer to Y axis.Definition THistPainter.h:55; THistPainter::fLegostd::unique_ptr< TPainter3dAlgorithms > fLegoPointer to a TPainter3dAlgorithms object.Definition THistPainter.h:58; THistPainter::fXbufstd::vector< Double_t > fXbufX buffer coordinates.Definition THistPainter.h:61; THistPainter::fXHighlightBinInt_t fXHighlightBinX highlight bin.Definition THistPainter.h:70; THistPainter::fCurrentF3TF3 * fCurrentF3Current TF3 function.Definition THistPainter.h:72; THistPainter::PaintErrorsvirtual void PaintErrors(Option_t *option)Draw 1D histograms error bars.Definition THistPainter.cxx:6314; THistPainter::~THistPainter~THistPainter() overridedestructor.Definition THistPainter.cxx:3242; THistPainter::fShowProjection2Int_t fShowProjection2True if a second projection must be drawn (when calling SetShowProjectionXY on a TH2)Definition THistPainter.h:68; THistPainter::PaintTF3virtual void PaintTF3()Control function to draw a 3D implicit functions.Definition THistPainter.cxx:10152; THistPainter::TableInitvirtual Int_t TableInit()Initialize various options to draw 2D histograms.Definition THistPainter.cxx:10536; THistPainter::PaintTH2PolyScatterPlotvirtual void PaintTH2PolyScatterPlot(Option_t *option)Control function to draw a TH2Poly as a scatter plot.Definition THistPainter.cxx:9885; THistPainter::ProjectMollweide2xystatic Int_t ProjectMollweide2xy(Double_t l, Double_t b, Double_t &Al, Double_t &Ab)Static function.Definition THistPainter.cxx:10412; THistPainter::ProjectAitoff2xystatic Int_t Pr",MatchSource.WIKI,doc/master/THistPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8h_source.html
https://root.cern/doc/master/THistPainter_8h_source.html:11598,Availability,error,errors,11598,"; THistPainter::ProjectAitoff2xystatic Int_t ProjectAitoff2xy(Double_t l, Double_t b, Double_t &Al, Double_t &Ab)Static function.Definition THistPainter.cxx:10331; THistPainter::PaintTextvirtual void PaintText(Option_t *option)Control function to draw a 1D/2D histograms with the bin values.Definition THistPainter.cxx:10056; THistPainter::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute the distance from the point px,py to a line.Definition THistPainter.cxx:3255; THistPainter::PaintAxisvirtual void PaintAxis(Bool_t drawGridOnly=kFALSE)Draw axis (2D case) of an histogram.Definition THistPainter.cxx:4766; THistPainter::PaintColorLevelsFastvirtual void PaintColorLevelsFast(Option_t *option)[Rendering scheme for the COL2 and COLZ2 options] (HP14)Definition THistPainter.cxx:5577; THistPainter::PaintInitvirtual Int_t PaintInit()Compute histogram parameters used by the drawing routines.Definition THistPainter.cxx:7082; THistPainter::Paint2DErrorsvirtual void Paint2DErrors(Option_t *option)Draw 2D histograms errors.Definition THistPainter.cxx:6617; THistPainter::fYHighlightBinInt_t fYHighlightBinY highlight bin.Definition THistPainter.h:71; THistPainter::PaintCandlePlotvirtual void PaintCandlePlot(Option_t *option)Control function to draw a 2D histogram as a candle (box) plot or violin plotDefinition THistPainter.cxx:5353; THistPainter::PaintScatterPlotvirtual void PaintScatterPlot(Option_t *option)Control function to draw a 2D histogram as a scatter plot.Definition THistPainter.cxx:8459; THistPainter::SetShowProjectionXYvoid SetShowProjectionXY(const char *option, Int_t nbinsY, Int_t nbinsX) overrideDefinition THistPainter.cxx:10804; THistPainter::PaintLegovirtual void PaintLego(Option_t *option)Control function to draw a 2D histogram as a lego plot.Definition THistPainter.cxx:8017; THistPainter::PaintH3virtual void PaintH3(Option_t *option="""")Control function to draw a 3D histograms.Definition THistPainter.cxx:6974; THistPainter::fNcutsInt_t ",MatchSource.WIKI,doc/master/THistPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8h_source.html
https://root.cern/doc/master/THistPainter_8h_source.html:19991,Availability,error,error,19991,"hoptin and fill Hoption structure.Definition THistPainter.cxx:4028; THistPainter::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideDisplay the histogram info (bin number, contents, integral up to bin corresponding to cursor position...Definition THistPainter.cxx:3729; THistPainter::GetContourListTList * GetContourList(Double_t contour) const overrideGet a contour (as a list of TGraphs) using the Delaunay triangulation.Definition THistPainter.cxx:3706; THistPainter::ProcessMessagevoid ProcessMessage(const char *mess, const TObject *obj) overrideProcess message mess.Definition THistPainter.cxx:10311; THistPainter::SetShowProjectionvoid SetShowProjection(const char *option, Int_t nbins) overrideSet projection.Definition THistPainter.cxx:10766; THistPainter::ShowProjectionYvirtual void ShowProjectionY(Int_t px, Int_t py)Show projection onto Y.Definition THistPainter.cxx:10933; THistPainter::GetBestFormatstatic const char * GetBestFormat(Double_t v, Double_t e, const char *f)This function returns the best format to print the error value (e) knowing the parameter value (v) an...Definition THistPainter.cxx:10714; THistPainter::PaintContourvirtual void PaintContour(Option_t *option)Control function to draw a 2D histogram as a contour plot.Definition THistPainter.cxx:5932; THistPainter::fCutsTCutG * fCuts[kMaxCuts]Pointers to graphical cuts.Definition THistPainter.h:65; THistPainter::PaintTablevirtual void PaintTable(Option_t *option)Control function to draw 2D/3D histograms (tables).Definition THistPainter.cxx:9629; THistPainter::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute the actions corresponding to event.Definition THistPainter.cxx:3464; THistPainter::PaintInitHvirtual Int_t PaintInitH()Compute histogram parameters used by the drawing routines for a rotated pad.Definition THistPainter.cxx:7334; THistPainter::PaintFramevirtual void PaintFrame()Calculate range and clear pad (canvas).Definition THistPainter.cxx:6777; THi",MatchSource.WIKI,doc/master/THistPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8h_source.html
https://root.cern/doc/master/THistPainter_8h_source.html:8978,Integrability,rout,routine,8978,"Win32VirtualXProxy.cxx:70; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; kMaxCutsconst Int_t kMaxCutsDefinition THistPainter.h:41; TString.h; TVirtualHistPainter.h; TAxisClass to manage histogram axis.Definition TAxis.h:31; TCutGGraphical cut class.Definition TCutG.h:20; TF11-Dim function classDefinition TF1.h:233; TF3A 3-Dim function with parameters.Definition TF3.h:28; TGaxisThe axis painter class.Definition TGaxis.h:24; TGraph2DPainterThe TGraphDelaunay painting class.Definition TGraph2DPainter.h:31; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; THistPainterThe histogram painter class.Definition THistPainter.h:50; THistPainter::ProjectSinusoidal2xystatic Int_t ProjectSinusoidal2xy(Double_t l, Double_t b, Double_t &Al, Double_t &Ab)Static function code for sinusoidal projection from Ernst-Jan Buis Source https://en....Definition THistPainter.cxx:10380; THistPainter::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histogramsDefinition THistPainter.cxx:4470; THistPainter::fYaxisTAxis * fYaxisPointer to Y axis.Definition THistPainter.h:55; THistPainter::fLegostd::unique_ptr< TPainter3dAlgorithms > fLegoPointer to a TPainter3dAlgorithms object.Definition THistPainter.h:58; THistPainter::fXbufstd::vector< Double_t > fXbufX buffer coordinates.Definition THistPainter.h:61; THistPainter::fXHighlightBinInt_t fXHighlightBinX highlight bin.Definition THistPainter.h:70; THistPainter::fCurrentF3TF3 * fCurrentF3Current TF3 function.Definition THistPainter.h:72; THistPainter::PaintErrorsvirtual void PaintErrors(Option_t *option)Draw 1D histograms error bars.Definition THistPainter.cxx:6314; THistPainter::~THistPainter~THistPainter() overridedestructor.Definition THistPainter.cxx:3242; THistPainter::fShowProjection2Int_t fShowProjection2True if a second projection must be drawn (when calling SetShowProjectionXY on a TH2)Definition THistPainter.h:68; THistPainter::PaintTF3vir",MatchSource.WIKI,doc/master/THistPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8h_source.html
https://root.cern/doc/master/THistPainter_8h_source.html:11465,Integrability,rout,routines,11465,"xystatic Int_t ProjectMollweide2xy(Double_t l, Double_t b, Double_t &Al, Double_t &Ab)Static function.Definition THistPainter.cxx:10412; THistPainter::ProjectAitoff2xystatic Int_t ProjectAitoff2xy(Double_t l, Double_t b, Double_t &Al, Double_t &Ab)Static function.Definition THistPainter.cxx:10331; THistPainter::PaintTextvirtual void PaintText(Option_t *option)Control function to draw a 1D/2D histograms with the bin values.Definition THistPainter.cxx:10056; THistPainter::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute the distance from the point px,py to a line.Definition THistPainter.cxx:3255; THistPainter::PaintAxisvirtual void PaintAxis(Bool_t drawGridOnly=kFALSE)Draw axis (2D case) of an histogram.Definition THistPainter.cxx:4766; THistPainter::PaintColorLevelsFastvirtual void PaintColorLevelsFast(Option_t *option)[Rendering scheme for the COL2 and COLZ2 options] (HP14)Definition THistPainter.cxx:5577; THistPainter::PaintInitvirtual Int_t PaintInit()Compute histogram parameters used by the drawing routines.Definition THistPainter.cxx:7082; THistPainter::Paint2DErrorsvirtual void Paint2DErrors(Option_t *option)Draw 2D histograms errors.Definition THistPainter.cxx:6617; THistPainter::fYHighlightBinInt_t fYHighlightBinY highlight bin.Definition THistPainter.h:71; THistPainter::PaintCandlePlotvirtual void PaintCandlePlot(Option_t *option)Control function to draw a 2D histogram as a candle (box) plot or violin plotDefinition THistPainter.cxx:5353; THistPainter::PaintScatterPlotvirtual void PaintScatterPlot(Option_t *option)Control function to draw a 2D histogram as a scatter plot.Definition THistPainter.cxx:8459; THistPainter::SetShowProjectionXYvoid SetShowProjectionXY(const char *option, Int_t nbinsY, Int_t nbinsX) overrideDefinition THistPainter.cxx:10804; THistPainter::PaintLegovirtual void PaintLego(Option_t *option)Control function to draw a 2D histogram as a lego plot.Definition THistPainter.cxx:8017; THistPainter::PaintH3virtua",MatchSource.WIKI,doc/master/THistPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8h_source.html
https://root.cern/doc/master/THistPainter_8h_source.html:19513,Integrability,message,message,19513," *option)Draw a bar-chart in a normal pad.Definition THistPainter.cxx:5043; THistPainter::ProjectMercator2xystatic Int_t ProjectMercator2xy(Double_t l, Double_t b, Double_t &Al, Double_t &Ab)Static function.Definition THistPainter.cxx:10366; THistPainter::PaintBoxesvirtual void PaintBoxes(Option_t *option)Control function to draw a 2D histogram as a box plotDefinition THistPainter.cxx:5168; THistPainter::MakeChoptvirtual Int_t MakeChopt(Option_t *option)Decode string choptin and fill Hoption structure.Definition THistPainter.cxx:4028; THistPainter::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideDisplay the histogram info (bin number, contents, integral up to bin corresponding to cursor position...Definition THistPainter.cxx:3729; THistPainter::GetContourListTList * GetContourList(Double_t contour) const overrideGet a contour (as a list of TGraphs) using the Delaunay triangulation.Definition THistPainter.cxx:3706; THistPainter::ProcessMessagevoid ProcessMessage(const char *mess, const TObject *obj) overrideProcess message mess.Definition THistPainter.cxx:10311; THistPainter::SetShowProjectionvoid SetShowProjection(const char *option, Int_t nbins) overrideSet projection.Definition THistPainter.cxx:10766; THistPainter::ShowProjectionYvirtual void ShowProjectionY(Int_t px, Int_t py)Show projection onto Y.Definition THistPainter.cxx:10933; THistPainter::GetBestFormatstatic const char * GetBestFormat(Double_t v, Double_t e, const char *f)This function returns the best format to print the error value (e) knowing the parameter value (v) an...Definition THistPainter.cxx:10714; THistPainter::PaintContourvirtual void PaintContour(Option_t *option)Control function to draw a 2D histogram as a contour plot.Definition THistPainter.cxx:5932; THistPainter::fCutsTCutG * fCuts[kMaxCuts]Pointers to graphical cuts.Definition THistPainter.h:65; THistPainter::PaintTablevirtual void PaintTable(Option_t *option)Control function to draw 2D/3D histograms (tables).Definitio",MatchSource.WIKI,doc/master/THistPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8h_source.html
https://root.cern/doc/master/THistPainter_8h_source.html:20750,Integrability,rout,routines,20750,"stPainter::ShowProjectionYvirtual void ShowProjectionY(Int_t px, Int_t py)Show projection onto Y.Definition THistPainter.cxx:10933; THistPainter::GetBestFormatstatic const char * GetBestFormat(Double_t v, Double_t e, const char *f)This function returns the best format to print the error value (e) knowing the parameter value (v) an...Definition THistPainter.cxx:10714; THistPainter::PaintContourvirtual void PaintContour(Option_t *option)Control function to draw a 2D histogram as a contour plot.Definition THistPainter.cxx:5932; THistPainter::fCutsTCutG * fCuts[kMaxCuts]Pointers to graphical cuts.Definition THistPainter.h:65; THistPainter::PaintTablevirtual void PaintTable(Option_t *option)Control function to draw 2D/3D histograms (tables).Definition THistPainter.cxx:9629; THistPainter::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute the actions corresponding to event.Definition THistPainter.cxx:3464; THistPainter::PaintInitHvirtual Int_t PaintInitH()Compute histogram parameters used by the drawing routines for a rotated pad.Definition THistPainter.cxx:7334; THistPainter::PaintFramevirtual void PaintFrame()Calculate range and clear pad (canvas).Definition THistPainter.cxx:6777; THistPainter::fCutsOptInt_t fCutsOpt[kMaxCuts]Sign of each cut.Definition THistPainter.h:64; THistPainter::GetYHighlightBinvirtual Int_t GetYHighlightBin() constDefinition THistPainter.h:88; THistPainter::PaintH3Isovirtual void PaintH3Iso()Control function to draw a 3D histogram with Iso Surfaces.Definition THistPainter.cxx:7892; THistPainter::fYbufstd::vector< Double_t > fYbufY buffer coordinates.Definition THistPainter.h:62; THistPainter::PaintH3BoxRastervirtual void PaintH3BoxRaster()Control function to draw a 3D histogram with boxes.Definition THistPainter.cxx:7690; THistPainter::PaintHistvirtual void PaintHist(Option_t *option)Control routine to draw 1D histogramsDefinition THistPainter.cxx:6837; THistPainter::SetHighlightvoid SetHighlight() overrideSet highlig",MatchSource.WIKI,doc/master/THistPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8h_source.html
https://root.cern/doc/master/THistPainter_8h_source.html:21581,Integrability,rout,routine,21581,"verrideExecute the actions corresponding to event.Definition THistPainter.cxx:3464; THistPainter::PaintInitHvirtual Int_t PaintInitH()Compute histogram parameters used by the drawing routines for a rotated pad.Definition THistPainter.cxx:7334; THistPainter::PaintFramevirtual void PaintFrame()Calculate range and clear pad (canvas).Definition THistPainter.cxx:6777; THistPainter::fCutsOptInt_t fCutsOpt[kMaxCuts]Sign of each cut.Definition THistPainter.h:64; THistPainter::GetYHighlightBinvirtual Int_t GetYHighlightBin() constDefinition THistPainter.h:88; THistPainter::PaintH3Isovirtual void PaintH3Iso()Control function to draw a 3D histogram with Iso Surfaces.Definition THistPainter.cxx:7892; THistPainter::fYbufstd::vector< Double_t > fYbufY buffer coordinates.Definition THistPainter.h:62; THistPainter::PaintH3BoxRastervirtual void PaintH3BoxRaster()Control function to draw a 3D histogram with boxes.Definition THistPainter.cxx:7690; THistPainter::PaintHistvirtual void PaintHist(Option_t *option)Control routine to draw 1D histogramsDefinition THistPainter.cxx:6837; THistPainter::SetHighlightvoid SetHighlight() overrideSet highlight (enable/disable) mode for fH.Definition THistPainter.cxx:3857; THistPainter::DefineColorLevelsvirtual void DefineColorLevels(Int_t ndivz)Define the color levels used to paint legos, surfaces etc..Definition THistPainter.cxx:9603; THistPainter::fObjectInfoTString fObjectInfoDefinition THistPainter.h:75; THistPainter::GetXHighlightBinvirtual Int_t GetXHighlightBin() constDefinition THistPainter.h:87; THistPainter::PaintColorLevelsvirtual void PaintColorLevels(Option_t *option)Control function to draw a 2D histogram as a color plot.Definition THistPainter.cxx:5766; THistPainter::IsInsideBool_t IsInside(Int_t x, Int_t y) overrideReturn kTRUE if the cell ix, iy is inside one of the graphical cuts.Definition THistPainter.cxx:3994; TListA doubly linked list.Definition TList.h:38; TObjectMother of all ROOT objects.Definition TObject.h:41; TPainter3dAl",MatchSource.WIKI,doc/master/THistPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8h_source.html
https://root.cern/doc/master/THistPainter_8h_source.html:22774,Integrability,interface,interface,22774,"rvirtual void PaintH3BoxRaster()Control function to draw a 3D histogram with boxes.Definition THistPainter.cxx:7690; THistPainter::PaintHistvirtual void PaintHist(Option_t *option)Control routine to draw 1D histogramsDefinition THistPainter.cxx:6837; THistPainter::SetHighlightvoid SetHighlight() overrideSet highlight (enable/disable) mode for fH.Definition THistPainter.cxx:3857; THistPainter::DefineColorLevelsvirtual void DefineColorLevels(Int_t ndivz)Define the color levels used to paint legos, surfaces etc..Definition THistPainter.cxx:9603; THistPainter::fObjectInfoTString fObjectInfoDefinition THistPainter.h:75; THistPainter::GetXHighlightBinvirtual Int_t GetXHighlightBin() constDefinition THistPainter.h:87; THistPainter::PaintColorLevelsvirtual void PaintColorLevels(Option_t *option)Control function to draw a 2D histogram as a color plot.Definition THistPainter.cxx:5766; THistPainter::IsInsideBool_t IsInside(Int_t x, Int_t y) overrideReturn kTRUE if the cell ix, iy is inside one of the graphical cuts.Definition THistPainter.cxx:3994; TListA doubly linked list.Definition TList.h:38; TObjectMother of all ROOT objects.Definition TObject.h:41; TPainter3dAlgorithmsThe Legos and Surfaces painter class.Definition TPainter3dAlgorithms.h:28; TPieDraw a Pie Chart,.Definition TPie.h:23; TStringBasic string class.Definition TString.h:139; TVirtualHistPainterAbstract interface to a histogram painter.Definition TVirtualHistPainter.h:30; double; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; v@ vDefinition rootcling_impl.cxx:3699; THistRenderingRegionDefinition THistPainter.h:44; THistRenderingRegion::fBinRangestd::pair< Int_t, Int_t > fBinRangeDefinition THistPainter.h:46; THistRenderingRegion::fPixelRangestd::pair< Int_t, Int_t > fPixelRangeDefinition THistPainter.h:45; lTLine lDefinition textangle.C:4. histhistpainterincTHistPainter.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:35 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/THistPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8h_source.html
https://root.cern/doc/master/THistPainter_8h_source.html:20880,Usability,clear,clear,20880,"ter::GetBestFormatstatic const char * GetBestFormat(Double_t v, Double_t e, const char *f)This function returns the best format to print the error value (e) knowing the parameter value (v) an...Definition THistPainter.cxx:10714; THistPainter::PaintContourvirtual void PaintContour(Option_t *option)Control function to draw a 2D histogram as a contour plot.Definition THistPainter.cxx:5932; THistPainter::fCutsTCutG * fCuts[kMaxCuts]Pointers to graphical cuts.Definition THistPainter.h:65; THistPainter::PaintTablevirtual void PaintTable(Option_t *option)Control function to draw 2D/3D histograms (tables).Definition THistPainter.cxx:9629; THistPainter::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute the actions corresponding to event.Definition THistPainter.cxx:3464; THistPainter::PaintInitHvirtual Int_t PaintInitH()Compute histogram parameters used by the drawing routines for a rotated pad.Definition THistPainter.cxx:7334; THistPainter::PaintFramevirtual void PaintFrame()Calculate range and clear pad (canvas).Definition THistPainter.cxx:6777; THistPainter::fCutsOptInt_t fCutsOpt[kMaxCuts]Sign of each cut.Definition THistPainter.h:64; THistPainter::GetYHighlightBinvirtual Int_t GetYHighlightBin() constDefinition THistPainter.h:88; THistPainter::PaintH3Isovirtual void PaintH3Iso()Control function to draw a 3D histogram with Iso Surfaces.Definition THistPainter.cxx:7892; THistPainter::fYbufstd::vector< Double_t > fYbufY buffer coordinates.Definition THistPainter.h:62; THistPainter::PaintH3BoxRastervirtual void PaintH3BoxRaster()Control function to draw a 3D histogram with boxes.Definition THistPainter.cxx:7690; THistPainter::PaintHistvirtual void PaintHist(Option_t *option)Control routine to draw 1D histogramsDefinition THistPainter.cxx:6837; THistPainter::SetHighlightvoid SetHighlight() overrideSet highlight (enable/disable) mode for fH.Definition THistPainter.cxx:3857; THistPainter::DefineColorLevelsvirtual void DefineColorLevels(Int_t ndivz)D",MatchSource.WIKI,doc/master/THistPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8h_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:14328,Availability,error,errors,14328,"; 388/// Initialize a THnSparseCompactBinCoord object with ""dim"" dimensions; 389/// and ""bins"" holding the number of bins for each dimension.; 390 ; 391THnSparseCompactBinCoord::THnSparseCompactBinCoord(Int_t dim, const Int_t* nbins):; 392 THnSparseCoordCompression(dim, nbins),; 393 fHash(0), fCoordBuffer(nullptr), fCurrentBin(nullptr); 394{; 395 fCurrentBin = new Int_t[dim];; 396 size_t bufAllocSize = GetBufferSize();; 397 if (bufAllocSize < sizeof(Long64_t)); 398 bufAllocSize = sizeof(Long64_t);; 399 fCoordBuffer = new Char_t[bufAllocSize];; 400}; 401 ; 402 ; 403////////////////////////////////////////////////////////////////////////////////; 404/// destruct a THnSparseCompactBinCoord; 405 ; 406THnSparseCompactBinCoord::~THnSparseCompactBinCoord(); 407{; 408 delete [] fCoordBuffer;; 409 delete [] fCurrentBin;; 410}; 411 ; 412/** \class THnSparseArrayChunk; 413THnSparseArrayChunk is used internally by THnSparse.; 414THnSparse stores its (dynamic size) array of bin coordinates and their; 415contents (and possibly errors) in a TObjArray of THnSparseArrayChunk. Each; 416of the chunks holds an array of THnSparseCompactBinCoord and the content; 417(a TArray*), which is created outside (by the templated derived classes of; 418THnSparse) and passed in at construction time.; 419*/; 420 ; 421ClassImp(THnSparseArrayChunk);; 422 ; 423////////////////////////////////////////////////////////////////////////////////; 424/// (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; 425/// and create an ArrayF for errors if ""errors"" is true.; 426 ; 427THnSparseArrayChunk::THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont):; 428 fCoordinateAllocationSize(-1), fSingleCoordinateSize(coordsize), fCoordinatesSize(0),; 429 fCoordinates(nullptr), fContent(cont),; 430 fSumw2(nullptr); 431{; 432 fCoordinateAllocationSize = fSingleCoordinateSize * cont->GetSize();; 433 fCoordinates = new Char_t[fCoordinateAllocationSize];; 434 if (errors) Sumw2();",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:14856,Availability,error,errors,14856,"ew Char_t[bufAllocSize];; 400}; 401 ; 402 ; 403////////////////////////////////////////////////////////////////////////////////; 404/// destruct a THnSparseCompactBinCoord; 405 ; 406THnSparseCompactBinCoord::~THnSparseCompactBinCoord(); 407{; 408 delete [] fCoordBuffer;; 409 delete [] fCurrentBin;; 410}; 411 ; 412/** \class THnSparseArrayChunk; 413THnSparseArrayChunk is used internally by THnSparse.; 414THnSparse stores its (dynamic size) array of bin coordinates and their; 415contents (and possibly errors) in a TObjArray of THnSparseArrayChunk. Each; 416of the chunks holds an array of THnSparseCompactBinCoord and the content; 417(a TArray*), which is created outside (by the templated derived classes of; 418THnSparse) and passed in at construction time.; 419*/; 420 ; 421ClassImp(THnSparseArrayChunk);; 422 ; 423////////////////////////////////////////////////////////////////////////////////; 424/// (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; 425/// and create an ArrayF for errors if ""errors"" is true.; 426 ; 427THnSparseArrayChunk::THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont):; 428 fCoordinateAllocationSize(-1), fSingleCoordinateSize(coordsize), fCoordinatesSize(0),; 429 fCoordinates(nullptr), fContent(cont),; 430 fSumw2(nullptr); 431{; 432 fCoordinateAllocationSize = fSingleCoordinateSize * cont->GetSize();; 433 fCoordinates = new Char_t[fCoordinateAllocationSize];; 434 if (errors) Sumw2();; 435}; 436 ; 437////////////////////////////////////////////////////////////////////////////////; 438/// Destructor; 439 ; 440THnSparseArrayChunk::~THnSparseArrayChunk(); 441{; 442 delete fContent;; 443 delete [] fCoordinates;; 444 delete fSumw2;; 445}; 446 ; 447////////////////////////////////////////////////////////////////////////////////; 448/// Create a new bin in this chunk; 449 ; 450void THnSparseArrayChunk::AddBin(Int_t idx, const Char_t* coordbuf); 451{; 452 // When streaming out only the filled chunk is sav",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:14867,Availability,error,errors,14867,"ew Char_t[bufAllocSize];; 400}; 401 ; 402 ; 403////////////////////////////////////////////////////////////////////////////////; 404/// destruct a THnSparseCompactBinCoord; 405 ; 406THnSparseCompactBinCoord::~THnSparseCompactBinCoord(); 407{; 408 delete [] fCoordBuffer;; 409 delete [] fCurrentBin;; 410}; 411 ; 412/** \class THnSparseArrayChunk; 413THnSparseArrayChunk is used internally by THnSparse.; 414THnSparse stores its (dynamic size) array of bin coordinates and their; 415contents (and possibly errors) in a TObjArray of THnSparseArrayChunk. Each; 416of the chunks holds an array of THnSparseCompactBinCoord and the content; 417(a TArray*), which is created outside (by the templated derived classes of; 418THnSparse) and passed in at construction time.; 419*/; 420 ; 421ClassImp(THnSparseArrayChunk);; 422 ; 423////////////////////////////////////////////////////////////////////////////////; 424/// (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; 425/// and create an ArrayF for errors if ""errors"" is true.; 426 ; 427THnSparseArrayChunk::THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont):; 428 fCoordinateAllocationSize(-1), fSingleCoordinateSize(coordsize), fCoordinatesSize(0),; 429 fCoordinates(nullptr), fContent(cont),; 430 fSumw2(nullptr); 431{; 432 fCoordinateAllocationSize = fSingleCoordinateSize * cont->GetSize();; 433 fCoordinates = new Char_t[fCoordinateAllocationSize];; 434 if (errors) Sumw2();; 435}; 436 ; 437////////////////////////////////////////////////////////////////////////////////; 438/// Destructor; 439 ; 440THnSparseArrayChunk::~THnSparseArrayChunk(); 441{; 442 delete fContent;; 443 delete [] fCoordinates;; 444 delete fSumw2;; 445}; 446 ; 447////////////////////////////////////////////////////////////////////////////////; 448/// Create a new bin in this chunk; 449 ; 450void THnSparseArrayChunk::AddBin(Int_t idx, const Char_t* coordbuf); 451{; 452 // When streaming out only the filled chunk is sav",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:14957,Availability,error,errors,14957,"THnSparseArrayChunk. Each; 416of the chunks holds an array of THnSparseCompactBinCoord and the content; 417(a TArray*), which is created outside (by the templated derived classes of; 418THnSparse) and passed in at construction time.; 419*/; 420 ; 421ClassImp(THnSparseArrayChunk);; 422 ; 423////////////////////////////////////////////////////////////////////////////////; 424/// (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; 425/// and create an ArrayF for errors if ""errors"" is true.; 426 ; 427THnSparseArrayChunk::THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont):; 428 fCoordinateAllocationSize(-1), fSingleCoordinateSize(coordsize), fCoordinatesSize(0),; 429 fCoordinates(nullptr), fContent(cont),; 430 fSumw2(nullptr); 431{; 432 fCoordinateAllocationSize = fSingleCoordinateSize * cont->GetSize();; 433 fCoordinates = new Char_t[fCoordinateAllocationSize];; 434 if (errors) Sumw2();; 435}; 436 ; 437////////////////////////////////////////////////////////////////////////////////; 438/// Destructor; 439 ; 440THnSparseArrayChunk::~THnSparseArrayChunk(); 441{; 442 delete fContent;; 443 delete [] fCoordinates;; 444 delete fSumw2;; 445}; 446 ; 447////////////////////////////////////////////////////////////////////////////////; 448/// Create a new bin in this chunk; 449 ; 450void THnSparseArrayChunk::AddBin(Int_t idx, const Char_t* coordbuf); 451{; 452 // When streaming out only the filled chunk is saved.; 453 // When reading back only the memory needed for that filled part gets; 454 // allocated. We need to check whether the allowed chunk size is; 455 // bigger than the allocated size. If fCoordinateAllocationSize is; 456 // set to -1 this chunk has been allocated by the streamer and the; 457 // buffer allocation size is defined by [fCoordinatesSize]. In that; 458 // case we need to compare fCoordinatesSize to; 459 // fSingleCoordinateSize * fContent->GetSize(); 460 // to determine whether we need to expand the buffer.; 46",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:15284,Availability,error,errors,15284,"THnSparseArrayChunk. Each; 416of the chunks holds an array of THnSparseCompactBinCoord and the content; 417(a TArray*), which is created outside (by the templated derived classes of; 418THnSparse) and passed in at construction time.; 419*/; 420 ; 421ClassImp(THnSparseArrayChunk);; 422 ; 423////////////////////////////////////////////////////////////////////////////////; 424/// (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; 425/// and create an ArrayF for errors if ""errors"" is true.; 426 ; 427THnSparseArrayChunk::THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont):; 428 fCoordinateAllocationSize(-1), fSingleCoordinateSize(coordsize), fCoordinatesSize(0),; 429 fCoordinates(nullptr), fContent(cont),; 430 fSumw2(nullptr); 431{; 432 fCoordinateAllocationSize = fSingleCoordinateSize * cont->GetSize();; 433 fCoordinates = new Char_t[fCoordinateAllocationSize];; 434 if (errors) Sumw2();; 435}; 436 ; 437////////////////////////////////////////////////////////////////////////////////; 438/// Destructor; 439 ; 440THnSparseArrayChunk::~THnSparseArrayChunk(); 441{; 442 delete fContent;; 443 delete [] fCoordinates;; 444 delete fSumw2;; 445}; 446 ; 447////////////////////////////////////////////////////////////////////////////////; 448/// Create a new bin in this chunk; 449 ; 450void THnSparseArrayChunk::AddBin(Int_t idx, const Char_t* coordbuf); 451{; 452 // When streaming out only the filled chunk is saved.; 453 // When reading back only the memory needed for that filled part gets; 454 // allocated. We need to check whether the allowed chunk size is; 455 // bigger than the allocated size. If fCoordinateAllocationSize is; 456 // set to -1 this chunk has been allocated by the streamer and the; 457 // buffer allocation size is defined by [fCoordinatesSize]. In that; 458 // case we need to compare fCoordinatesSize to; 459 // fSingleCoordinateSize * fContent->GetSize(); 460 // to determine whether we need to expand the buffer.; 46",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:17033,Availability,error,errors,17033,"rt gets; 454 // allocated. We need to check whether the allowed chunk size is; 455 // bigger than the allocated size. If fCoordinateAllocationSize is; 456 // set to -1 this chunk has been allocated by the streamer and the; 457 // buffer allocation size is defined by [fCoordinatesSize]. In that; 458 // case we need to compare fCoordinatesSize to; 459 // fSingleCoordinateSize * fContent->GetSize(); 460 // to determine whether we need to expand the buffer.; 461 if (fCoordinateAllocationSize == -1 && fContent) {; 462 Int_t chunksize = fSingleCoordinateSize * fContent->GetSize();; 463 if (fCoordinatesSize < chunksize) {; 464 // need to re-allocate:; 465 Char_t *newcoord = new Char_t[chunksize];; 466 memcpy(newcoord, fCoordinates, fCoordinatesSize);; 467 delete [] fCoordinates;; 468 fCoordinates = newcoord;; 469 }; 470 fCoordinateAllocationSize = chunksize;; 471 }; 472 ; 473 memcpy(fCoordinates + idx * fSingleCoordinateSize, coordbuf, fSingleCoordinateSize);; 474 fCoordinatesSize += fSingleCoordinateSize;; 475}; 476 ; 477////////////////////////////////////////////////////////////////////////////////; 478/// Turn on support of errors; 479 ; 480void THnSparseArrayChunk::Sumw2(); 481{; 482 if (!fSumw2); 483 fSumw2 = new TArrayD(fContent->GetSize());; 484 // fill the structure with the current content; 485 for (Int_t bin=0; bin < fContent->GetSize(); bin++) {; 486 fSumw2->fArray[bin] = fContent->GetAt(bin);; 487 }; 488 ; 489}; 490 ; 491 ; 492/** \class THnSparse; 493 \ingroup Hist; 494 ; 495Efficient multidimensional histogram.; 496 ; 497Use a THnSparse instead of TH1 / TH2 / TH3 / array for histogramming when; 498only a small fraction of bins is filled. A 10-dimensional histogram with 10; 499bins per dimension has 10^10 bins; in a naive implementation this will not; 500fit in memory. THnSparse only allocates memory for the bins that have; 501non-zero bin content instead, drastically reducing both the memory usage; 502and the access time.; 503 ; 504To construct a THnSparse ob",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:19016,Availability,error,errors,19016,"SparseF (typedef for THnSparseT<ArrayF>): bin content held by a Float_t,; 508- THnSparseL (typedef for THnSparseT<ArrayL64>): bin content held by a Long64_t,; 509- THnSparseI (typedef for THnSparseT<ArrayI>): bin content held by an Int_t,; 510- THnSparseS (typedef for THnSparseT<ArrayS>): bin content held by a Short_t,; 511- THnSparseC (typedef for THnSparseT<ArrayC>): bin content held by a Char_t,; 512 ; 513They take name and title, the number of dimensions, and for each dimension; 514the number of bins, the minimal, and the maximal value on the dimension's; 515axis. A TH2 h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; 516 ; 517 Int_t bins[2] = {10, 20};; 518 Double_t xmin[2] = {0., -5.};; 519 Double_t xmax[2] = {10., 5.};; 520 THnSparseD hs(""hs"", ""hs"", 2, bins, xmin, xmax);; 521 ; 522## Filling; 523A THnSparse is filled just like a regular histogram, using; 524THnSparse::Fill(x, weight), where x is a n-dimensional Double_t value.; 525To take errors into account, Sumw2() must be called before filling the; 526histogram.; 527 ; 528Bins are allocated as needed; the status of the allocation can be observed; 529by GetSparseFractionBins(), GetSparseFractionMem().; 530 ; 531## Fast Bin Content Access; 532When iterating over a THnSparse one should only look at filled bins to save; 533processing time. The number of filled bins is returned by; 534THnSparse::GetNbins(); the bin content for each (linear) bin number can; 535be retrieved by THnSparse::GetBinContent(linidx, (Int_t*)coord).; 536After the call, coord will contain the bin coordinate of each axis for the bin; 537with linear index linidx. A possible call would be; 538 ; 539 std::cout << hs.GetBinContent(0, coord);; 540 std::cout <<"" is the content of bin [x = "" << coord[0] ""; 541 << "" | y = "" << coord[1] << ""]"" << std::endl;; 542 ; 543## Efficiency; 544TH1 and TH2 are generally faster than THnSparse for one and two dimensional; 545distributions. THnSparse becomes competitive for a sparsely filled TH3; 546wit",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:28780,Availability,error,error,28780,"////////////////////////////////////////////////////////////////////////; 740/// Return the content of the filled bin number ""idx"".; 741/// If coord is non-null, it will contain the bin's coordinates for each axis; 742/// that correspond to the bin.; 743 ; 744Double_t THnSparse::GetBinContent(Long64_t idx, Int_t* coord /* = 0 */) const; 745{; 746 if (idx >= 0) {; 747 THnSparseArrayChunk* chunk = GetChunk(idx / fChunkSize);; 748 idx %= fChunkSize;; 749 if (chunk && chunk->fContent->GetSize() > idx) {; 750 if (coord) {; 751 THnSparseCompactBinCoord* cc = GetCompactCoord();; 752 Int_t sizeCompact = cc->GetBufferSize();; 753 cc->SetCoordFromBuffer(chunk->fCoordinates + idx * sizeCompact,; 754 coord);; 755 ; 756 }; 757 return chunk->fContent->GetAt(idx);; 758 }; 759 }; 760 if (coord); 761 memset(coord, -1, sizeof(Int_t) * fNdimensions);; 762 return 0.;; 763}; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Get square of the error of bin addressed by linidx as; 767/// \f$\sum weight^{2}\f$; 768/// If errors are not enabled (via Sumw2() or CalculateErrors()); 769/// return contents.; 770 ; 771Double_t THnSparse::GetBinError2(Long64_t linidx) const {; 772 if (!GetCalculateErrors()); 773 return GetBinContent(linidx);; 774 ; 775 if (linidx < 0) return 0.;; 776 THnSparseArrayChunk* chunk = GetChunk(linidx / fChunkSize);; 777 linidx %= fChunkSize;; 778 if (!chunk || chunk->fContent->GetSize() < linidx); 779 return 0.;; 780 ; 781 return chunk->fSumw2->GetAt(linidx);; 782}; 783 ; 784 ; 785////////////////////////////////////////////////////////////////////////////////; 786/// Return the index for fCurrentBinIndex.; 787/// If it doesn't exist then return -1, or allocate a new bin if allocate is set; 788 ; 789Long64_t THnSparse::GetBinIndexForCurrentBin(Bool_t allocate); 790{; 791 THnSparseCompactBinCoord* cc = GetCompactCoord();; 792 ULong64_t hash = cc->GetHash();; 793 if (fBinContent.GetSize() && !fBins.GetSize()); 794 FillExMap(",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:28857,Availability,error,errors,28857,"////////////////////////////////////////////////////////////////////////; 740/// Return the content of the filled bin number ""idx"".; 741/// If coord is non-null, it will contain the bin's coordinates for each axis; 742/// that correspond to the bin.; 743 ; 744Double_t THnSparse::GetBinContent(Long64_t idx, Int_t* coord /* = 0 */) const; 745{; 746 if (idx >= 0) {; 747 THnSparseArrayChunk* chunk = GetChunk(idx / fChunkSize);; 748 idx %= fChunkSize;; 749 if (chunk && chunk->fContent->GetSize() > idx) {; 750 if (coord) {; 751 THnSparseCompactBinCoord* cc = GetCompactCoord();; 752 Int_t sizeCompact = cc->GetBufferSize();; 753 cc->SetCoordFromBuffer(chunk->fCoordinates + idx * sizeCompact,; 754 coord);; 755 ; 756 }; 757 return chunk->fContent->GetAt(idx);; 758 }; 759 }; 760 if (coord); 761 memset(coord, -1, sizeof(Int_t) * fNdimensions);; 762 return 0.;; 763}; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Get square of the error of bin addressed by linidx as; 767/// \f$\sum weight^{2}\f$; 768/// If errors are not enabled (via Sumw2() or CalculateErrors()); 769/// return contents.; 770 ; 771Double_t THnSparse::GetBinError2(Long64_t linidx) const {; 772 if (!GetCalculateErrors()); 773 return GetBinContent(linidx);; 774 ; 775 if (linidx < 0) return 0.;; 776 THnSparseArrayChunk* chunk = GetChunk(linidx / fChunkSize);; 777 linidx %= fChunkSize;; 778 if (!chunk || chunk->fContent->GetSize() < linidx); 779 return 0.;; 780 ; 781 return chunk->fSumw2->GetAt(linidx);; 782}; 783 ; 784 ; 785////////////////////////////////////////////////////////////////////////////////; 786/// Return the index for fCurrentBinIndex.; 787/// If it doesn't exist then return -1, or allocate a new bin if allocate is set; 788 ; 789Long64_t THnSparse::GetBinIndexForCurrentBin(Bool_t allocate); 790{; 791 THnSparseCompactBinCoord* cc = GetCompactCoord();; 792 ULong64_t hash = cc->GetHash();; 793 if (fBinContent.GetSize() && !fBins.GetSize()); 794 FillExMap(",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:34099,Availability,error,error,34099,"// Use THnIter instead.; 895 ; 896ROOT::Internal::THnBaseBinIter* THnSparse::CreateIter(Bool_t respectAxisRange) const; 897{; 898 return new THnSparseBinIter(respectAxisRange, this);; 899}; 900 ; 901////////////////////////////////////////////////////////////////////////////////; 902/// Set content of bin with index ""bin"" to ""v""; 903 ; 904void THnSparse::SetBinContent(Long64_t bin, Double_t v); 905{; 906 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 907 chunk->fContent->SetAt(v, bin % fChunkSize);; 908 ++fEntries;; 909}; 910 ; 911////////////////////////////////////////////////////////////////////////////////; 912/// Set error of bin with index ""bin"" to ""e"", enable errors if needed; 913 ; 914void THnSparse::SetBinError2(Long64_t bin, Double_t e2); 915{; 916 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 917 if (!chunk->fSumw2 ) {; 918 // if fSumw2 is zero GetCalculateErrors should return false; 919 if (GetCalculateErrors()) {; 920 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 921 }; 922 Sumw2(); // enable error calculation; 923 }; 924 ; 925 chunk->fSumw2->SetAt(e2, bin % fChunkSize);; 926}; 927 ; 928////////////////////////////////////////////////////////////////////////////////; 929/// Add ""e"" to error of bin with index ""bin"", enable errors if needed; 930 ; 931void THnSparse::AddBinError2(Long64_t bin, Double_t e2); 932{; 933 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 934 if (!chunk->fSumw2 ) {; 935 // if fSumw2 is zero GetCalculateErrors should return false; 936 if (GetCalculateErrors()) {; 937 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 938 }; 939 Sumw2(); // enable error calculation; 940 }; 941 ; 942 (*chunk->fSumw2)[bin % fChunkSize] += e2;; 943}; 944 ; 945////////////////////////////////////////////////////////////////////////////////; 946/// Enable calculation of errors; 947 ; 948void THnSparse::Sumw2(); 949{; 950 if (GetCalculateErrors()) return;; 951 ; 952 fTsumw2 = 0.;; 953 TIter iChunk(&fB",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:34144,Availability,error,errors,34144,"// Use THnIter instead.; 895 ; 896ROOT::Internal::THnBaseBinIter* THnSparse::CreateIter(Bool_t respectAxisRange) const; 897{; 898 return new THnSparseBinIter(respectAxisRange, this);; 899}; 900 ; 901////////////////////////////////////////////////////////////////////////////////; 902/// Set content of bin with index ""bin"" to ""v""; 903 ; 904void THnSparse::SetBinContent(Long64_t bin, Double_t v); 905{; 906 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 907 chunk->fContent->SetAt(v, bin % fChunkSize);; 908 ++fEntries;; 909}; 910 ; 911////////////////////////////////////////////////////////////////////////////////; 912/// Set error of bin with index ""bin"" to ""e"", enable errors if needed; 913 ; 914void THnSparse::SetBinError2(Long64_t bin, Double_t e2); 915{; 916 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 917 if (!chunk->fSumw2 ) {; 918 // if fSumw2 is zero GetCalculateErrors should return false; 919 if (GetCalculateErrors()) {; 920 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 921 }; 922 Sumw2(); // enable error calculation; 923 }; 924 ; 925 chunk->fSumw2->SetAt(e2, bin % fChunkSize);; 926}; 927 ; 928////////////////////////////////////////////////////////////////////////////////; 929/// Add ""e"" to error of bin with index ""bin"", enable errors if needed; 930 ; 931void THnSparse::AddBinError2(Long64_t bin, Double_t e2); 932{; 933 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 934 if (!chunk->fSumw2 ) {; 935 // if fSumw2 is zero GetCalculateErrors should return false; 936 if (GetCalculateErrors()) {; 937 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 938 }; 939 Sumw2(); // enable error calculation; 940 }; 941 ; 942 (*chunk->fSumw2)[bin % fChunkSize] += e2;; 943}; 944 ; 945////////////////////////////////////////////////////////////////////////////////; 946/// Enable calculation of errors; 947 ; 948void THnSparse::Sumw2(); 949{; 950 if (GetCalculateErrors()) return;; 951 ; 952 fTsumw2 = 0.;; 953 TIter iChunk(&fB",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:34475,Availability,error,error,34475,"// Use THnIter instead.; 895 ; 896ROOT::Internal::THnBaseBinIter* THnSparse::CreateIter(Bool_t respectAxisRange) const; 897{; 898 return new THnSparseBinIter(respectAxisRange, this);; 899}; 900 ; 901////////////////////////////////////////////////////////////////////////////////; 902/// Set content of bin with index ""bin"" to ""v""; 903 ; 904void THnSparse::SetBinContent(Long64_t bin, Double_t v); 905{; 906 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 907 chunk->fContent->SetAt(v, bin % fChunkSize);; 908 ++fEntries;; 909}; 910 ; 911////////////////////////////////////////////////////////////////////////////////; 912/// Set error of bin with index ""bin"" to ""e"", enable errors if needed; 913 ; 914void THnSparse::SetBinError2(Long64_t bin, Double_t e2); 915{; 916 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 917 if (!chunk->fSumw2 ) {; 918 // if fSumw2 is zero GetCalculateErrors should return false; 919 if (GetCalculateErrors()) {; 920 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 921 }; 922 Sumw2(); // enable error calculation; 923 }; 924 ; 925 chunk->fSumw2->SetAt(e2, bin % fChunkSize);; 926}; 927 ; 928////////////////////////////////////////////////////////////////////////////////; 929/// Add ""e"" to error of bin with index ""bin"", enable errors if needed; 930 ; 931void THnSparse::AddBinError2(Long64_t bin, Double_t e2); 932{; 933 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 934 if (!chunk->fSumw2 ) {; 935 // if fSumw2 is zero GetCalculateErrors should return false; 936 if (GetCalculateErrors()) {; 937 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 938 }; 939 Sumw2(); // enable error calculation; 940 }; 941 ; 942 (*chunk->fSumw2)[bin % fChunkSize] += e2;; 943}; 944 ; 945////////////////////////////////////////////////////////////////////////////////; 946/// Enable calculation of errors; 947 ; 948void THnSparse::Sumw2(); 949{; 950 if (GetCalculateErrors()) return;; 951 ; 952 fTsumw2 = 0.;; 953 TIter iChunk(&fB",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:34516,Availability,error,error,34516,"// Use THnIter instead.; 895 ; 896ROOT::Internal::THnBaseBinIter* THnSparse::CreateIter(Bool_t respectAxisRange) const; 897{; 898 return new THnSparseBinIter(respectAxisRange, this);; 899}; 900 ; 901////////////////////////////////////////////////////////////////////////////////; 902/// Set content of bin with index ""bin"" to ""v""; 903 ; 904void THnSparse::SetBinContent(Long64_t bin, Double_t v); 905{; 906 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 907 chunk->fContent->SetAt(v, bin % fChunkSize);; 908 ++fEntries;; 909}; 910 ; 911////////////////////////////////////////////////////////////////////////////////; 912/// Set error of bin with index ""bin"" to ""e"", enable errors if needed; 913 ; 914void THnSparse::SetBinError2(Long64_t bin, Double_t e2); 915{; 916 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 917 if (!chunk->fSumw2 ) {; 918 // if fSumw2 is zero GetCalculateErrors should return false; 919 if (GetCalculateErrors()) {; 920 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 921 }; 922 Sumw2(); // enable error calculation; 923 }; 924 ; 925 chunk->fSumw2->SetAt(e2, bin % fChunkSize);; 926}; 927 ; 928////////////////////////////////////////////////////////////////////////////////; 929/// Add ""e"" to error of bin with index ""bin"", enable errors if needed; 930 ; 931void THnSparse::AddBinError2(Long64_t bin, Double_t e2); 932{; 933 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 934 if (!chunk->fSumw2 ) {; 935 // if fSumw2 is zero GetCalculateErrors should return false; 936 if (GetCalculateErrors()) {; 937 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 938 }; 939 Sumw2(); // enable error calculation; 940 }; 941 ; 942 (*chunk->fSumw2)[bin % fChunkSize] += e2;; 943}; 944 ; 945////////////////////////////////////////////////////////////////////////////////; 946/// Enable calculation of errors; 947 ; 948void THnSparse::Sumw2(); 949{; 950 if (GetCalculateErrors()) return;; 951 ; 952 fTsumw2 = 0.;; 953 TIter iChunk(&fB",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:34712,Availability,error,error,34712,"// Use THnIter instead.; 895 ; 896ROOT::Internal::THnBaseBinIter* THnSparse::CreateIter(Bool_t respectAxisRange) const; 897{; 898 return new THnSparseBinIter(respectAxisRange, this);; 899}; 900 ; 901////////////////////////////////////////////////////////////////////////////////; 902/// Set content of bin with index ""bin"" to ""v""; 903 ; 904void THnSparse::SetBinContent(Long64_t bin, Double_t v); 905{; 906 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 907 chunk->fContent->SetAt(v, bin % fChunkSize);; 908 ++fEntries;; 909}; 910 ; 911////////////////////////////////////////////////////////////////////////////////; 912/// Set error of bin with index ""bin"" to ""e"", enable errors if needed; 913 ; 914void THnSparse::SetBinError2(Long64_t bin, Double_t e2); 915{; 916 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 917 if (!chunk->fSumw2 ) {; 918 // if fSumw2 is zero GetCalculateErrors should return false; 919 if (GetCalculateErrors()) {; 920 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 921 }; 922 Sumw2(); // enable error calculation; 923 }; 924 ; 925 chunk->fSumw2->SetAt(e2, bin % fChunkSize);; 926}; 927 ; 928////////////////////////////////////////////////////////////////////////////////; 929/// Add ""e"" to error of bin with index ""bin"", enable errors if needed; 930 ; 931void THnSparse::AddBinError2(Long64_t bin, Double_t e2); 932{; 933 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 934 if (!chunk->fSumw2 ) {; 935 // if fSumw2 is zero GetCalculateErrors should return false; 936 if (GetCalculateErrors()) {; 937 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 938 }; 939 Sumw2(); // enable error calculation; 940 }; 941 ; 942 (*chunk->fSumw2)[bin % fChunkSize] += e2;; 943}; 944 ; 945////////////////////////////////////////////////////////////////////////////////; 946/// Enable calculation of errors; 947 ; 948void THnSparse::Sumw2(); 949{; 950 if (GetCalculateErrors()) return;; 951 ; 952 fTsumw2 = 0.;; 953 TIter iChunk(&fB",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:34750,Availability,error,errors,34750,"// Use THnIter instead.; 895 ; 896ROOT::Internal::THnBaseBinIter* THnSparse::CreateIter(Bool_t respectAxisRange) const; 897{; 898 return new THnSparseBinIter(respectAxisRange, this);; 899}; 900 ; 901////////////////////////////////////////////////////////////////////////////////; 902/// Set content of bin with index ""bin"" to ""v""; 903 ; 904void THnSparse::SetBinContent(Long64_t bin, Double_t v); 905{; 906 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 907 chunk->fContent->SetAt(v, bin % fChunkSize);; 908 ++fEntries;; 909}; 910 ; 911////////////////////////////////////////////////////////////////////////////////; 912/// Set error of bin with index ""bin"" to ""e"", enable errors if needed; 913 ; 914void THnSparse::SetBinError2(Long64_t bin, Double_t e2); 915{; 916 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 917 if (!chunk->fSumw2 ) {; 918 // if fSumw2 is zero GetCalculateErrors should return false; 919 if (GetCalculateErrors()) {; 920 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 921 }; 922 Sumw2(); // enable error calculation; 923 }; 924 ; 925 chunk->fSumw2->SetAt(e2, bin % fChunkSize);; 926}; 927 ; 928////////////////////////////////////////////////////////////////////////////////; 929/// Add ""e"" to error of bin with index ""bin"", enable errors if needed; 930 ; 931void THnSparse::AddBinError2(Long64_t bin, Double_t e2); 932{; 933 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 934 if (!chunk->fSumw2 ) {; 935 // if fSumw2 is zero GetCalculateErrors should return false; 936 if (GetCalculateErrors()) {; 937 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 938 }; 939 Sumw2(); // enable error calculation; 940 }; 941 ; 942 (*chunk->fSumw2)[bin % fChunkSize] += e2;; 943}; 944 ; 945////////////////////////////////////////////////////////////////////////////////; 946/// Enable calculation of errors; 947 ; 948void THnSparse::Sumw2(); 949{; 950 if (GetCalculateErrors()) return;; 951 ; 952 fTsumw2 = 0.;; 953 TIter iChunk(&fB",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:35081,Availability,error,error,35081,"// Use THnIter instead.; 895 ; 896ROOT::Internal::THnBaseBinIter* THnSparse::CreateIter(Bool_t respectAxisRange) const; 897{; 898 return new THnSparseBinIter(respectAxisRange, this);; 899}; 900 ; 901////////////////////////////////////////////////////////////////////////////////; 902/// Set content of bin with index ""bin"" to ""v""; 903 ; 904void THnSparse::SetBinContent(Long64_t bin, Double_t v); 905{; 906 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 907 chunk->fContent->SetAt(v, bin % fChunkSize);; 908 ++fEntries;; 909}; 910 ; 911////////////////////////////////////////////////////////////////////////////////; 912/// Set error of bin with index ""bin"" to ""e"", enable errors if needed; 913 ; 914void THnSparse::SetBinError2(Long64_t bin, Double_t e2); 915{; 916 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 917 if (!chunk->fSumw2 ) {; 918 // if fSumw2 is zero GetCalculateErrors should return false; 919 if (GetCalculateErrors()) {; 920 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 921 }; 922 Sumw2(); // enable error calculation; 923 }; 924 ; 925 chunk->fSumw2->SetAt(e2, bin % fChunkSize);; 926}; 927 ; 928////////////////////////////////////////////////////////////////////////////////; 929/// Add ""e"" to error of bin with index ""bin"", enable errors if needed; 930 ; 931void THnSparse::AddBinError2(Long64_t bin, Double_t e2); 932{; 933 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 934 if (!chunk->fSumw2 ) {; 935 // if fSumw2 is zero GetCalculateErrors should return false; 936 if (GetCalculateErrors()) {; 937 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 938 }; 939 Sumw2(); // enable error calculation; 940 }; 941 ; 942 (*chunk->fSumw2)[bin % fChunkSize] += e2;; 943}; 944 ; 945////////////////////////////////////////////////////////////////////////////////; 946/// Enable calculation of errors; 947 ; 948void THnSparse::Sumw2(); 949{; 950 if (GetCalculateErrors()) return;; 951 ; 952 fTsumw2 = 0.;; 953 TIter iChunk(&fB",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:35122,Availability,error,error,35122,"// Use THnIter instead.; 895 ; 896ROOT::Internal::THnBaseBinIter* THnSparse::CreateIter(Bool_t respectAxisRange) const; 897{; 898 return new THnSparseBinIter(respectAxisRange, this);; 899}; 900 ; 901////////////////////////////////////////////////////////////////////////////////; 902/// Set content of bin with index ""bin"" to ""v""; 903 ; 904void THnSparse::SetBinContent(Long64_t bin, Double_t v); 905{; 906 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 907 chunk->fContent->SetAt(v, bin % fChunkSize);; 908 ++fEntries;; 909}; 910 ; 911////////////////////////////////////////////////////////////////////////////////; 912/// Set error of bin with index ""bin"" to ""e"", enable errors if needed; 913 ; 914void THnSparse::SetBinError2(Long64_t bin, Double_t e2); 915{; 916 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 917 if (!chunk->fSumw2 ) {; 918 // if fSumw2 is zero GetCalculateErrors should return false; 919 if (GetCalculateErrors()) {; 920 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 921 }; 922 Sumw2(); // enable error calculation; 923 }; 924 ; 925 chunk->fSumw2->SetAt(e2, bin % fChunkSize);; 926}; 927 ; 928////////////////////////////////////////////////////////////////////////////////; 929/// Add ""e"" to error of bin with index ""bin"", enable errors if needed; 930 ; 931void THnSparse::AddBinError2(Long64_t bin, Double_t e2); 932{; 933 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 934 if (!chunk->fSumw2 ) {; 935 // if fSumw2 is zero GetCalculateErrors should return false; 936 if (GetCalculateErrors()) {; 937 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 938 }; 939 Sumw2(); // enable error calculation; 940 }; 941 ; 942 (*chunk->fSumw2)[bin % fChunkSize] += e2;; 943}; 944 ; 945////////////////////////////////////////////////////////////////////////////////; 946/// Enable calculation of errors; 947 ; 948void THnSparse::Sumw2(); 949{; 950 if (GetCalculateErrors()) return;; 951 ; 952 fTsumw2 = 0.;; 953 TIter iChunk(&fB",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:35327,Availability,error,errors,35327,"// Use THnIter instead.; 895 ; 896ROOT::Internal::THnBaseBinIter* THnSparse::CreateIter(Bool_t respectAxisRange) const; 897{; 898 return new THnSparseBinIter(respectAxisRange, this);; 899}; 900 ; 901////////////////////////////////////////////////////////////////////////////////; 902/// Set content of bin with index ""bin"" to ""v""; 903 ; 904void THnSparse::SetBinContent(Long64_t bin, Double_t v); 905{; 906 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 907 chunk->fContent->SetAt(v, bin % fChunkSize);; 908 ++fEntries;; 909}; 910 ; 911////////////////////////////////////////////////////////////////////////////////; 912/// Set error of bin with index ""bin"" to ""e"", enable errors if needed; 913 ; 914void THnSparse::SetBinError2(Long64_t bin, Double_t e2); 915{; 916 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 917 if (!chunk->fSumw2 ) {; 918 // if fSumw2 is zero GetCalculateErrors should return false; 919 if (GetCalculateErrors()) {; 920 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 921 }; 922 Sumw2(); // enable error calculation; 923 }; 924 ; 925 chunk->fSumw2->SetAt(e2, bin % fChunkSize);; 926}; 927 ; 928////////////////////////////////////////////////////////////////////////////////; 929/// Add ""e"" to error of bin with index ""bin"", enable errors if needed; 930 ; 931void THnSparse::AddBinError2(Long64_t bin, Double_t e2); 932{; 933 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 934 if (!chunk->fSumw2 ) {; 935 // if fSumw2 is zero GetCalculateErrors should return false; 936 if (GetCalculateErrors()) {; 937 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 938 }; 939 Sumw2(); // enable error calculation; 940 }; 941 ; 942 (*chunk->fSumw2)[bin % fChunkSize] += e2;; 943}; 944 ; 945////////////////////////////////////////////////////////////////////////////////; 946/// Enable calculation of errors; 947 ; 948void THnSparse::Sumw2(); 949{; 950 if (GetCalculateErrors()) return;; 951 ; 952 fTsumw2 = 0.;; 953 TIter iChunk(&fB",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:40921,Availability,error,errors,40921,"zeInt_t GetSize() constDefinition TExMap.h:71; TExMap::Addvoid Add(ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table. The key should be unique.Definition TExMap.cxx:88; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TExMap::CapacityInt_t Capacity() constDefinition TExMap.h:69; TExMap::Deletevoid Delete(Option_t *opt="""") overrideDelete all entries stored in the TExMap.Definition TExMap.cxx:164; THnBaseMultidimensional histogram base.Definition THnBase.h:43; THnBase::fEntriesDouble_t fEntriesNumber of entries, spread over chunks.Definition THnBase.h:48; THnBase::GetNdimensionsInt_t GetNdimensions() constDefinition THnBase.h:140; THnBase::ResetBasevoid ResetBase(Option_t *option="""")Clear the histogram.Definition THnBase.cxx:1327; THnBase::GetCalculateErrorsBool_t GetCalculateErrors() constDefinition THnBase.h:141; THnBase::fTsumw2Double_t fTsumw2Total sum of weights squared; -1 if no errors are calculated.Definition THnBase.h:50; THnBase::GetAxisTAxis * GetAxis(Int_t dim) constDefinition THnBase.h:130; THnBase::fNdimensionsInt_t fNdimensionsNumber of dimensions.Definition THnBase.h:45; THnSparseArrayChunkTHnSparseArrayChunk is used internally by THnSparse.Definition THnSparse_Internal.h:30; THnSparseArrayChunk::MatchesBool_t Matches(Int_t idx, const Char_t *idxbuf) constCheck whether bin at idx batches idxbuf.Definition THnSparse_Internal.h:63; THnSparseArrayChunk::~THnSparseArrayChunk~THnSparseArrayChunk() overrideDestructor.Definition THnSparse.cxx:440; THnSparseArrayChunk::fSumw2TArrayD * fSumw2Bin errors.Definition THnSparse_Internal.h:49; THnSparseArrayChunk::THnSparseArrayChunkTHnSparseArrayChunk()Definition THnSparse_Internal.h:37; THnSparseArrayChunk::fCoordinatesSizeInt_t fCoordinatesSizeSize of the bin coordinate buffer.Definition THnSparse_Internal.h:46; THnSparseArrayChunk::fSingleCoordinateSizeInt_t fSingleCoordinateSizeSize",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:41551,Availability,error,errors,41551,"er of entries, spread over chunks.Definition THnBase.h:48; THnBase::GetNdimensionsInt_t GetNdimensions() constDefinition THnBase.h:140; THnBase::ResetBasevoid ResetBase(Option_t *option="""")Clear the histogram.Definition THnBase.cxx:1327; THnBase::GetCalculateErrorsBool_t GetCalculateErrors() constDefinition THnBase.h:141; THnBase::fTsumw2Double_t fTsumw2Total sum of weights squared; -1 if no errors are calculated.Definition THnBase.h:50; THnBase::GetAxisTAxis * GetAxis(Int_t dim) constDefinition THnBase.h:130; THnBase::fNdimensionsInt_t fNdimensionsNumber of dimensions.Definition THnBase.h:45; THnSparseArrayChunkTHnSparseArrayChunk is used internally by THnSparse.Definition THnSparse_Internal.h:30; THnSparseArrayChunk::MatchesBool_t Matches(Int_t idx, const Char_t *idxbuf) constCheck whether bin at idx batches idxbuf.Definition THnSparse_Internal.h:63; THnSparseArrayChunk::~THnSparseArrayChunk~THnSparseArrayChunk() overrideDestructor.Definition THnSparse.cxx:440; THnSparseArrayChunk::fSumw2TArrayD * fSumw2Bin errors.Definition THnSparse_Internal.h:49; THnSparseArrayChunk::THnSparseArrayChunkTHnSparseArrayChunk()Definition THnSparse_Internal.h:37; THnSparseArrayChunk::fCoordinatesSizeInt_t fCoordinatesSizeSize of the bin coordinate buffer.Definition THnSparse_Internal.h:46; THnSparseArrayChunk::fSingleCoordinateSizeInt_t fSingleCoordinateSizeSize of a single bin coordinate.Definition THnSparse_Internal.h:45; THnSparseArrayChunk::Sumw2void Sumw2()Turn on support of errors.Definition THnSparse.cxx:480; THnSparseArrayChunk::fCoordinatesChar_t * fCoordinates[fCoordinatesSize] compact bin coordinate bufferDefinition THnSparse_Internal.h:47; THnSparseArrayChunk::fContentTArray * fContentBin content.Definition THnSparse_Internal.h:48; THnSparseArrayChunk::GetEntriesInt_t GetEntries() constDefinition THnSparse_Internal.h:58; THnSparseArrayChunk::AddBinvoid AddBin(Int_t idx, const Char_t *idxbuf)Create a new bin in this chunk.Definition THnSparse.cxx:450; THnSparseArrayChunk::",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:42014,Availability,error,errors,42014,"xis * GetAxis(Int_t dim) constDefinition THnBase.h:130; THnBase::fNdimensionsInt_t fNdimensionsNumber of dimensions.Definition THnBase.h:45; THnSparseArrayChunkTHnSparseArrayChunk is used internally by THnSparse.Definition THnSparse_Internal.h:30; THnSparseArrayChunk::MatchesBool_t Matches(Int_t idx, const Char_t *idxbuf) constCheck whether bin at idx batches idxbuf.Definition THnSparse_Internal.h:63; THnSparseArrayChunk::~THnSparseArrayChunk~THnSparseArrayChunk() overrideDestructor.Definition THnSparse.cxx:440; THnSparseArrayChunk::fSumw2TArrayD * fSumw2Bin errors.Definition THnSparse_Internal.h:49; THnSparseArrayChunk::THnSparseArrayChunkTHnSparseArrayChunk()Definition THnSparse_Internal.h:37; THnSparseArrayChunk::fCoordinatesSizeInt_t fCoordinatesSizeSize of the bin coordinate buffer.Definition THnSparse_Internal.h:46; THnSparseArrayChunk::fSingleCoordinateSizeInt_t fSingleCoordinateSizeSize of a single bin coordinate.Definition THnSparse_Internal.h:45; THnSparseArrayChunk::Sumw2void Sumw2()Turn on support of errors.Definition THnSparse.cxx:480; THnSparseArrayChunk::fCoordinatesChar_t * fCoordinates[fCoordinatesSize] compact bin coordinate bufferDefinition THnSparse_Internal.h:47; THnSparseArrayChunk::fContentTArray * fContentBin content.Definition THnSparse_Internal.h:48; THnSparseArrayChunk::GetEntriesInt_t GetEntries() constDefinition THnSparse_Internal.h:58; THnSparseArrayChunk::AddBinvoid AddBin(Int_t idx, const Char_t *idxbuf)Create a new bin in this chunk.Definition THnSparse.cxx:450; THnSparseArrayChunk::fCoordinateAllocationSizeInt_t fCoordinateAllocationSize! Size of the allocated coordinate buffer; -1 means none or fCoordinatesSizeDefinition THnSparse_Internal.h:44; THnSparseCompactBinCoordTHnSparseCompactBinCoord is a class used by THnSparse internally.Definition THnSparse.cxx:351; THnSparseCompactBinCoord::THnSparseCompactBinCoordTHnSparseCompactBinCoord(Int_t dim, const Int_t *nbins)Initialize a THnSparseCompactBinCoord object with ""dim"" dimensions ",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:46752,Availability,error,error,46752,"nSparse.cxx:134; THnSparseCoordCompression::THnSparseCoordCompressionTHnSparseCoordCompression(Int_t dim, const Int_t *nbins)Initialize a THnSparseCoordCompression object with ""dim"" dimensions and ""bins"" holding the number of ...Definition THnSparse.cxx:149; THnSparseCoordCompression::~THnSparseCoordCompression~THnSparseCoordCompression()destruct a THnSparseCoordCompressionDefinition THnSparse.cxx:195; THnSparseEfficient multidimensional histogram.Definition THnSparse.h:37; THnSparse::GetSparseFractionBinsDouble_t GetSparseFractionBins() constReturn the amount of filled bins over all bins.Definition THnSparse.cxx:854; THnSparse::GetSparseFractionMemDouble_t GetSparseFractionMem() constReturn the amount of used memory over memory that would be used by a non-sparse n-dimensional histogr...Definition THnSparse.cxx:865; THnSparse::Resetvoid Reset(Option_t *option="""") overrideClear the histogram.Definition THnSparse.cxx:962; THnSparse::AddBinError2void AddBinError2(Long64_t bin, Double_t e2) overrideAdd ""e"" to error of bin with index ""bin"", enable errors if needed.Definition THnSparse.cxx:931; THnSparse::SetBinContentvoid SetBinContent(const Int_t *idx, Double_t v)Forwards to THnBase::SetBinContent().Definition THnSparse.h:105; THnSparse::GetChunkTHnSparseArrayChunk * GetChunk(Int_t idx) constDefinition THnSparse.h:56; THnSparse::fCompactCoordTHnSparseCompactBinCoord * fCompactCoord! Compact coordinateDefinition THnSparse.h:44; THnSparse::GetChunkSizeInt_t GetChunkSize() constDefinition THnSparse.h:88; THnSparse::GetBinContentDouble_t GetBinContent(const Int_t *idx) constForwards to THnBase::GetBinContent() overload.Definition THnSparse.h:121; THnSparse::fFilledBinsLong64_t fFilledBinsNumber of filled bins.Definition THnSparse.h:40; THnSparse::GetBinLong64_t GetBin(const Int_t *idx) const overrideDefinition THnSparse.h:96; THnSparse::fBinContentTObjArray fBinContentArray of THnSparseArrayChunk.Definition THnSparse.h:41; THnSparse::GetCompactCoordTHnSparseCompactBinCoord *",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:46790,Availability,error,errors,46790,"nSparse.cxx:134; THnSparseCoordCompression::THnSparseCoordCompressionTHnSparseCoordCompression(Int_t dim, const Int_t *nbins)Initialize a THnSparseCoordCompression object with ""dim"" dimensions and ""bins"" holding the number of ...Definition THnSparse.cxx:149; THnSparseCoordCompression::~THnSparseCoordCompression~THnSparseCoordCompression()destruct a THnSparseCoordCompressionDefinition THnSparse.cxx:195; THnSparseEfficient multidimensional histogram.Definition THnSparse.h:37; THnSparse::GetSparseFractionBinsDouble_t GetSparseFractionBins() constReturn the amount of filled bins over all bins.Definition THnSparse.cxx:854; THnSparse::GetSparseFractionMemDouble_t GetSparseFractionMem() constReturn the amount of used memory over memory that would be used by a non-sparse n-dimensional histogr...Definition THnSparse.cxx:865; THnSparse::Resetvoid Reset(Option_t *option="""") overrideClear the histogram.Definition THnSparse.cxx:962; THnSparse::AddBinError2void AddBinError2(Long64_t bin, Double_t e2) overrideAdd ""e"" to error of bin with index ""bin"", enable errors if needed.Definition THnSparse.cxx:931; THnSparse::SetBinContentvoid SetBinContent(const Int_t *idx, Double_t v)Forwards to THnBase::SetBinContent().Definition THnSparse.h:105; THnSparse::GetChunkTHnSparseArrayChunk * GetChunk(Int_t idx) constDefinition THnSparse.h:56; THnSparse::fCompactCoordTHnSparseCompactBinCoord * fCompactCoord! Compact coordinateDefinition THnSparse.h:44; THnSparse::GetChunkSizeInt_t GetChunkSize() constDefinition THnSparse.h:88; THnSparse::GetBinContentDouble_t GetBinContent(const Int_t *idx) constForwards to THnBase::GetBinContent() overload.Definition THnSparse.h:121; THnSparse::fFilledBinsLong64_t fFilledBinsNumber of filled bins.Definition THnSparse.h:40; THnSparse::GetBinLong64_t GetBin(const Int_t *idx) const overrideDefinition THnSparse.h:96; THnSparse::fBinContentTObjArray fBinContentArray of THnSparseArrayChunk.Definition THnSparse.h:41; THnSparse::GetCompactCoordTHnSparseCompactBinCoord *",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:48083,Availability,error,error,48083,"rse::fCompactCoordTHnSparseCompactBinCoord * fCompactCoord! Compact coordinateDefinition THnSparse.h:44; THnSparse::GetChunkSizeInt_t GetChunkSize() constDefinition THnSparse.h:88; THnSparse::GetBinContentDouble_t GetBinContent(const Int_t *idx) constForwards to THnBase::GetBinContent() overload.Definition THnSparse.h:121; THnSparse::fFilledBinsLong64_t fFilledBinsNumber of filled bins.Definition THnSparse.h:40; THnSparse::GetBinLong64_t GetBin(const Int_t *idx) const overrideDefinition THnSparse.h:96; THnSparse::fBinContentTObjArray fBinContentArray of THnSparseArrayChunk.Definition THnSparse.h:41; THnSparse::GetCompactCoordTHnSparseCompactBinCoord * GetCompactCoord() constReturn THnSparseCompactBinCoord object.Definition THnSparse.cxx:838; THnSparse::InitStoragevoid InitStorage(Int_t *nbins, Int_t chunkSize) overrideInitialize the storage of a histogram created via Init()Definition THnSparse.cxx:646; THnSparse::GetBinError2Double_t GetBinError2(Long64_t linidx) const overrideGet square of the error of bin addressed by linidx as If errors are not enabled (via Sumw2() or Calc...Definition THnSparse.cxx:771; THnSparse::THnSparseTHnSparse()Construct an empty THnSparse.Definition THnSparse.cxx:589; THnSparse::AddChunkTHnSparseArrayChunk * AddChunk()Create a new chunk of bin content.Definition THnSparse.cxx:634; THnSparse::GenerateArrayvirtual TArray * GenerateArray() const =0; THnSparse::SetBinError2void SetBinError2(Long64_t bin, Double_t e2) overrideSet error of bin with index ""bin"" to ""e"", enable errors if needed.Definition THnSparse.cxx:914; THnSparse::FillExMapvoid FillExMap()We have been streamed; set up fBins.Definition THnSparse.cxx:655; THnSparse::~THnSparse~THnSparse() overrideDestruct a THnSparse.Definition THnSparse.cxx:616; THnSparse::fBinsTExMap fBins! Filled binsDefinition THnSparse.h:42; THnSparse::fBinsContinuedTExMap fBinsContinued! Filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1)Definition THnSparse.h:43; THnSparse::A",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:48122,Availability,error,errors,48122,"rse::fCompactCoordTHnSparseCompactBinCoord * fCompactCoord! Compact coordinateDefinition THnSparse.h:44; THnSparse::GetChunkSizeInt_t GetChunkSize() constDefinition THnSparse.h:88; THnSparse::GetBinContentDouble_t GetBinContent(const Int_t *idx) constForwards to THnBase::GetBinContent() overload.Definition THnSparse.h:121; THnSparse::fFilledBinsLong64_t fFilledBinsNumber of filled bins.Definition THnSparse.h:40; THnSparse::GetBinLong64_t GetBin(const Int_t *idx) const overrideDefinition THnSparse.h:96; THnSparse::fBinContentTObjArray fBinContentArray of THnSparseArrayChunk.Definition THnSparse.h:41; THnSparse::GetCompactCoordTHnSparseCompactBinCoord * GetCompactCoord() constReturn THnSparseCompactBinCoord object.Definition THnSparse.cxx:838; THnSparse::InitStoragevoid InitStorage(Int_t *nbins, Int_t chunkSize) overrideInitialize the storage of a histogram created via Init()Definition THnSparse.cxx:646; THnSparse::GetBinError2Double_t GetBinError2(Long64_t linidx) const overrideGet square of the error of bin addressed by linidx as If errors are not enabled (via Sumw2() or Calc...Definition THnSparse.cxx:771; THnSparse::THnSparseTHnSparse()Construct an empty THnSparse.Definition THnSparse.cxx:589; THnSparse::AddChunkTHnSparseArrayChunk * AddChunk()Create a new chunk of bin content.Definition THnSparse.cxx:634; THnSparse::GenerateArrayvirtual TArray * GenerateArray() const =0; THnSparse::SetBinError2void SetBinError2(Long64_t bin, Double_t e2) overrideSet error of bin with index ""bin"" to ""e"", enable errors if needed.Definition THnSparse.cxx:914; THnSparse::FillExMapvoid FillExMap()We have been streamed; set up fBins.Definition THnSparse.cxx:655; THnSparse::~THnSparse~THnSparse() overrideDestruct a THnSparse.Definition THnSparse.cxx:616; THnSparse::fBinsTExMap fBins! Filled binsDefinition THnSparse.h:42; THnSparse::fBinsContinuedTExMap fBinsContinued! Filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1)Definition THnSparse.h:43; THnSparse::A",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:48550,Availability,error,error,48550,"BinLong64_t GetBin(const Int_t *idx) const overrideDefinition THnSparse.h:96; THnSparse::fBinContentTObjArray fBinContentArray of THnSparseArrayChunk.Definition THnSparse.h:41; THnSparse::GetCompactCoordTHnSparseCompactBinCoord * GetCompactCoord() constReturn THnSparseCompactBinCoord object.Definition THnSparse.cxx:838; THnSparse::InitStoragevoid InitStorage(Int_t *nbins, Int_t chunkSize) overrideInitialize the storage of a histogram created via Init()Definition THnSparse.cxx:646; THnSparse::GetBinError2Double_t GetBinError2(Long64_t linidx) const overrideGet square of the error of bin addressed by linidx as If errors are not enabled (via Sumw2() or Calc...Definition THnSparse.cxx:771; THnSparse::THnSparseTHnSparse()Construct an empty THnSparse.Definition THnSparse.cxx:589; THnSparse::AddChunkTHnSparseArrayChunk * AddChunk()Create a new chunk of bin content.Definition THnSparse.cxx:634; THnSparse::GenerateArrayvirtual TArray * GenerateArray() const =0; THnSparse::SetBinError2void SetBinError2(Long64_t bin, Double_t e2) overrideSet error of bin with index ""bin"" to ""e"", enable errors if needed.Definition THnSparse.cxx:914; THnSparse::FillExMapvoid FillExMap()We have been streamed; set up fBins.Definition THnSparse.cxx:655; THnSparse::~THnSparse~THnSparse() overrideDestruct a THnSparse.Definition THnSparse.cxx:616; THnSparse::fBinsTExMap fBins! Filled binsDefinition THnSparse.h:42; THnSparse::fBinsContinuedTExMap fBinsContinued! Filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1)Definition THnSparse.h:43; THnSparse::AddBinContentvoid AddBinContent(const Int_t *idx, Double_t v=1.)Forwards to THnBase::AddBinContent().Definition THnSparse.h:113; THnSparse::Reservevoid Reserve(Long64_t nbins) overrideInitialize storage for nbins.Definition THnSparse.cxx:689; THnSparse::fChunkSizeInt_t fChunkSizeNumber of entries for each chunk.Definition THnSparse.h:39; THnSparse::Sumw2void Sumw2() overrideEnable calculation of errors.Definition THnSparse.cxx:",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:48595,Availability,error,errors,48595,"BinLong64_t GetBin(const Int_t *idx) const overrideDefinition THnSparse.h:96; THnSparse::fBinContentTObjArray fBinContentArray of THnSparseArrayChunk.Definition THnSparse.h:41; THnSparse::GetCompactCoordTHnSparseCompactBinCoord * GetCompactCoord() constReturn THnSparseCompactBinCoord object.Definition THnSparse.cxx:838; THnSparse::InitStoragevoid InitStorage(Int_t *nbins, Int_t chunkSize) overrideInitialize the storage of a histogram created via Init()Definition THnSparse.cxx:646; THnSparse::GetBinError2Double_t GetBinError2(Long64_t linidx) const overrideGet square of the error of bin addressed by linidx as If errors are not enabled (via Sumw2() or Calc...Definition THnSparse.cxx:771; THnSparse::THnSparseTHnSparse()Construct an empty THnSparse.Definition THnSparse.cxx:589; THnSparse::AddChunkTHnSparseArrayChunk * AddChunk()Create a new chunk of bin content.Definition THnSparse.cxx:634; THnSparse::GenerateArrayvirtual TArray * GenerateArray() const =0; THnSparse::SetBinError2void SetBinError2(Long64_t bin, Double_t e2) overrideSet error of bin with index ""bin"" to ""e"", enable errors if needed.Definition THnSparse.cxx:914; THnSparse::FillExMapvoid FillExMap()We have been streamed; set up fBins.Definition THnSparse.cxx:655; THnSparse::~THnSparse~THnSparse() overrideDestruct a THnSparse.Definition THnSparse.cxx:616; THnSparse::fBinsTExMap fBins! Filled binsDefinition THnSparse.h:42; THnSparse::fBinsContinuedTExMap fBinsContinued! Filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1)Definition THnSparse.h:43; THnSparse::AddBinContentvoid AddBinContent(const Int_t *idx, Double_t v=1.)Forwards to THnBase::AddBinContent().Definition THnSparse.h:113; THnSparse::Reservevoid Reserve(Long64_t nbins) overrideInitialize storage for nbins.Definition THnSparse.cxx:689; THnSparse::fChunkSizeInt_t fChunkSizeNumber of entries for each chunk.Definition THnSparse.h:39; THnSparse::Sumw2void Sumw2() overrideEnable calculation of errors.Definition THnSparse.cxx:",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:49471,Availability,error,errors,49471,"* GenerateArray() const =0; THnSparse::SetBinError2void SetBinError2(Long64_t bin, Double_t e2) overrideSet error of bin with index ""bin"" to ""e"", enable errors if needed.Definition THnSparse.cxx:914; THnSparse::FillExMapvoid FillExMap()We have been streamed; set up fBins.Definition THnSparse.cxx:655; THnSparse::~THnSparse~THnSparse() overrideDestruct a THnSparse.Definition THnSparse.cxx:616; THnSparse::fBinsTExMap fBins! Filled binsDefinition THnSparse.h:42; THnSparse::fBinsContinuedTExMap fBinsContinued! Filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1)Definition THnSparse.h:43; THnSparse::AddBinContentvoid AddBinContent(const Int_t *idx, Double_t v=1.)Forwards to THnBase::AddBinContent().Definition THnSparse.h:113; THnSparse::Reservevoid Reserve(Long64_t nbins) overrideInitialize storage for nbins.Definition THnSparse.cxx:689; THnSparse::fChunkSizeInt_t fChunkSizeNumber of entries for each chunk.Definition THnSparse.h:39; THnSparse::Sumw2void Sumw2() overrideEnable calculation of errors.Definition THnSparse.cxx:948; THnSparse::GetNbinsLong64_t GetNbins() const overrideDefinition THnSparse.h:93; THnSparse::CreateIterROOT::Internal::THnBaseBinIter * CreateIter(Bool_t respectAxisRange) const overrideCreate an iterator over all filled bins of a THnSparse.Definition THnSparse.cxx:896; THnSparse::GetBinIndexForCurrentBinLong64_t GetBinIndexForCurrentBin(Bool_t allocate)Return the index for fCurrentBinIndex.Definition THnSparse.cxx:789; TIterDefinition TCollection.h:235; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::LastTObject * Last() const overrideReturn the object in the last filled slot. Returns 0 if no entries.Definition TObjArray.cxx:506; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.D",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:50898,Availability,error,error,50898,"Sumw2void Sumw2() overrideEnable calculation of errors.Definition THnSparse.cxx:948; THnSparse::GetNbinsLong64_t GetNbins() const overrideDefinition THnSparse.h:93; THnSparse::CreateIterROOT::Internal::THnBaseBinIter * CreateIter(Bool_t respectAxisRange) const overrideCreate an iterator over all filled bins of a THnSparse.Definition THnSparse.cxx:896; THnSparse::GetBinIndexForCurrentBinLong64_t GetBinIndexForCurrentBin(Bool_t allocate)Return the index for fCurrentBinIndex.Definition THnSparse.cxx:789; TIterDefinition TCollection.h:235; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::LastTObject * Last() const overrideReturn the object in the last filled slot. Returns 0 if no entries.Definition TObjArray.cxx:506; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::AddLastvoid AddLast(TObject *obj) overrideAdd object in the next empty slot in the array.Definition TObjArray.cxx:178; TObject::Clearvirtual void Clear(Option_t *="""")Definition TObject.h:119; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; bool; double; int; unsigned int; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; v@ vDefinition rootcling_impl.cxx:3699. histhistsrcTHnSparse.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:4661,Energy Efficiency,allocate,allocated,4661,,MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:15910,Energy Efficiency,allocate,allocated,15910,""" is true.; 426 ; 427THnSparseArrayChunk::THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont):; 428 fCoordinateAllocationSize(-1), fSingleCoordinateSize(coordsize), fCoordinatesSize(0),; 429 fCoordinates(nullptr), fContent(cont),; 430 fSumw2(nullptr); 431{; 432 fCoordinateAllocationSize = fSingleCoordinateSize * cont->GetSize();; 433 fCoordinates = new Char_t[fCoordinateAllocationSize];; 434 if (errors) Sumw2();; 435}; 436 ; 437////////////////////////////////////////////////////////////////////////////////; 438/// Destructor; 439 ; 440THnSparseArrayChunk::~THnSparseArrayChunk(); 441{; 442 delete fContent;; 443 delete [] fCoordinates;; 444 delete fSumw2;; 445}; 446 ; 447////////////////////////////////////////////////////////////////////////////////; 448/// Create a new bin in this chunk; 449 ; 450void THnSparseArrayChunk::AddBin(Int_t idx, const Char_t* coordbuf); 451{; 452 // When streaming out only the filled chunk is saved.; 453 // When reading back only the memory needed for that filled part gets; 454 // allocated. We need to check whether the allowed chunk size is; 455 // bigger than the allocated size. If fCoordinateAllocationSize is; 456 // set to -1 this chunk has been allocated by the streamer and the; 457 // buffer allocation size is defined by [fCoordinatesSize]. In that; 458 // case we need to compare fCoordinatesSize to; 459 // fSingleCoordinateSize * fContent->GetSize(); 460 // to determine whether we need to expand the buffer.; 461 if (fCoordinateAllocationSize == -1 && fContent) {; 462 Int_t chunksize = fSingleCoordinateSize * fContent->GetSize();; 463 if (fCoordinatesSize < chunksize) {; 464 // need to re-allocate:; 465 Char_t *newcoord = new Char_t[chunksize];; 466 memcpy(newcoord, fCoordinates, fCoordinatesSize);; 467 delete [] fCoordinates;; 468 fCoordinates = newcoord;; 469 }; 470 fCoordinateAllocationSize = chunksize;; 471 }; 472 ; 473 memcpy(fCoordinates + idx * fSingleCoordinateSize, coordbuf, fSingleCoordinateSize);; 474 fCoordi",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:15996,Energy Efficiency,allocate,allocated,15996,"TArray* cont):; 428 fCoordinateAllocationSize(-1), fSingleCoordinateSize(coordsize), fCoordinatesSize(0),; 429 fCoordinates(nullptr), fContent(cont),; 430 fSumw2(nullptr); 431{; 432 fCoordinateAllocationSize = fSingleCoordinateSize * cont->GetSize();; 433 fCoordinates = new Char_t[fCoordinateAllocationSize];; 434 if (errors) Sumw2();; 435}; 436 ; 437////////////////////////////////////////////////////////////////////////////////; 438/// Destructor; 439 ; 440THnSparseArrayChunk::~THnSparseArrayChunk(); 441{; 442 delete fContent;; 443 delete [] fCoordinates;; 444 delete fSumw2;; 445}; 446 ; 447////////////////////////////////////////////////////////////////////////////////; 448/// Create a new bin in this chunk; 449 ; 450void THnSparseArrayChunk::AddBin(Int_t idx, const Char_t* coordbuf); 451{; 452 // When streaming out only the filled chunk is saved.; 453 // When reading back only the memory needed for that filled part gets; 454 // allocated. We need to check whether the allowed chunk size is; 455 // bigger than the allocated size. If fCoordinateAllocationSize is; 456 // set to -1 this chunk has been allocated by the streamer and the; 457 // buffer allocation size is defined by [fCoordinatesSize]. In that; 458 // case we need to compare fCoordinatesSize to; 459 // fSingleCoordinateSize * fContent->GetSize(); 460 // to determine whether we need to expand the buffer.; 461 if (fCoordinateAllocationSize == -1 && fContent) {; 462 Int_t chunksize = fSingleCoordinateSize * fContent->GetSize();; 463 if (fCoordinatesSize < chunksize) {; 464 // need to re-allocate:; 465 Char_t *newcoord = new Char_t[chunksize];; 466 memcpy(newcoord, fCoordinates, fCoordinatesSize);; 467 delete [] fCoordinates;; 468 fCoordinates = newcoord;; 469 }; 470 fCoordinateAllocationSize = chunksize;; 471 }; 472 ; 473 memcpy(fCoordinates + idx * fSingleCoordinateSize, coordbuf, fSingleCoordinateSize);; 474 fCoordinatesSize += fSingleCoordinateSize;; 475}; 476 ; 477/////////////////////////////////////////",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:16082,Energy Efficiency,allocate,allocated,16082,"r), fContent(cont),; 430 fSumw2(nullptr); 431{; 432 fCoordinateAllocationSize = fSingleCoordinateSize * cont->GetSize();; 433 fCoordinates = new Char_t[fCoordinateAllocationSize];; 434 if (errors) Sumw2();; 435}; 436 ; 437////////////////////////////////////////////////////////////////////////////////; 438/// Destructor; 439 ; 440THnSparseArrayChunk::~THnSparseArrayChunk(); 441{; 442 delete fContent;; 443 delete [] fCoordinates;; 444 delete fSumw2;; 445}; 446 ; 447////////////////////////////////////////////////////////////////////////////////; 448/// Create a new bin in this chunk; 449 ; 450void THnSparseArrayChunk::AddBin(Int_t idx, const Char_t* coordbuf); 451{; 452 // When streaming out only the filled chunk is saved.; 453 // When reading back only the memory needed for that filled part gets; 454 // allocated. We need to check whether the allowed chunk size is; 455 // bigger than the allocated size. If fCoordinateAllocationSize is; 456 // set to -1 this chunk has been allocated by the streamer and the; 457 // buffer allocation size is defined by [fCoordinatesSize]. In that; 458 // case we need to compare fCoordinatesSize to; 459 // fSingleCoordinateSize * fContent->GetSize(); 460 // to determine whether we need to expand the buffer.; 461 if (fCoordinateAllocationSize == -1 && fContent) {; 462 Int_t chunksize = fSingleCoordinateSize * fContent->GetSize();; 463 if (fCoordinatesSize < chunksize) {; 464 // need to re-allocate:; 465 Char_t *newcoord = new Char_t[chunksize];; 466 memcpy(newcoord, fCoordinates, fCoordinatesSize);; 467 delete [] fCoordinates;; 468 fCoordinates = newcoord;; 469 }; 470 fCoordinateAllocationSize = chunksize;; 471 }; 472 ; 473 memcpy(fCoordinates + idx * fSingleCoordinateSize, coordbuf, fSingleCoordinateSize);; 474 fCoordinatesSize += fSingleCoordinateSize;; 475}; 476 ; 477////////////////////////////////////////////////////////////////////////////////; 478/// Turn on support of errors; 479 ; 480void THnSparseArrayChunk::Sumw2(); 481{; 482 i",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:16536,Energy Efficiency,allocate,allocate,16536,"rt gets; 454 // allocated. We need to check whether the allowed chunk size is; 455 // bigger than the allocated size. If fCoordinateAllocationSize is; 456 // set to -1 this chunk has been allocated by the streamer and the; 457 // buffer allocation size is defined by [fCoordinatesSize]. In that; 458 // case we need to compare fCoordinatesSize to; 459 // fSingleCoordinateSize * fContent->GetSize(); 460 // to determine whether we need to expand the buffer.; 461 if (fCoordinateAllocationSize == -1 && fContent) {; 462 Int_t chunksize = fSingleCoordinateSize * fContent->GetSize();; 463 if (fCoordinatesSize < chunksize) {; 464 // need to re-allocate:; 465 Char_t *newcoord = new Char_t[chunksize];; 466 memcpy(newcoord, fCoordinates, fCoordinatesSize);; 467 delete [] fCoordinates;; 468 fCoordinates = newcoord;; 469 }; 470 fCoordinateAllocationSize = chunksize;; 471 }; 472 ; 473 memcpy(fCoordinates + idx * fSingleCoordinateSize, coordbuf, fSingleCoordinateSize);; 474 fCoordinatesSize += fSingleCoordinateSize;; 475}; 476 ; 477////////////////////////////////////////////////////////////////////////////////; 478/// Turn on support of errors; 479 ; 480void THnSparseArrayChunk::Sumw2(); 481{; 482 if (!fSumw2); 483 fSumw2 = new TArrayD(fContent->GetSize());; 484 // fill the structure with the current content; 485 for (Int_t bin=0; bin < fContent->GetSize(); bin++) {; 486 fSumw2->fArray[bin] = fContent->GetAt(bin);; 487 }; 488 ; 489}; 490 ; 491 ; 492/** \class THnSparse; 493 \ingroup Hist; 494 ; 495Efficient multidimensional histogram.; 496 ; 497Use a THnSparse instead of TH1 / TH2 / TH3 / array for histogramming when; 498only a small fraction of bins is filled. A 10-dimensional histogram with 10; 499bins per dimension has 10^10 bins; in a naive implementation this will not; 500fit in memory. THnSparse only allocates memory for the bins that have; 501non-zero bin content instead, drastically reducing both the memory usage; 502and the access time.; 503 ; 504To construct a THnSparse ob",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:17716,Energy Efficiency,allocate,allocates,17716,"mcpy(fCoordinates + idx * fSingleCoordinateSize, coordbuf, fSingleCoordinateSize);; 474 fCoordinatesSize += fSingleCoordinateSize;; 475}; 476 ; 477////////////////////////////////////////////////////////////////////////////////; 478/// Turn on support of errors; 479 ; 480void THnSparseArrayChunk::Sumw2(); 481{; 482 if (!fSumw2); 483 fSumw2 = new TArrayD(fContent->GetSize());; 484 // fill the structure with the current content; 485 for (Int_t bin=0; bin < fContent->GetSize(); bin++) {; 486 fSumw2->fArray[bin] = fContent->GetAt(bin);; 487 }; 488 ; 489}; 490 ; 491 ; 492/** \class THnSparse; 493 \ingroup Hist; 494 ; 495Efficient multidimensional histogram.; 496 ; 497Use a THnSparse instead of TH1 / TH2 / TH3 / array for histogramming when; 498only a small fraction of bins is filled. A 10-dimensional histogram with 10; 499bins per dimension has 10^10 bins; in a naive implementation this will not; 500fit in memory. THnSparse only allocates memory for the bins that have; 501non-zero bin content instead, drastically reducing both the memory usage; 502and the access time.; 503 ; 504To construct a THnSparse object you must use one of its templated, derived; 505classes:; 506- THnSparseD (typedef for THnSparseT<ArrayD>): bin content held by a Double_t,; 507- THnSparseF (typedef for THnSparseT<ArrayF>): bin content held by a Float_t,; 508- THnSparseL (typedef for THnSparseT<ArrayL64>): bin content held by a Long64_t,; 509- THnSparseI (typedef for THnSparseT<ArrayI>): bin content held by an Int_t,; 510- THnSparseS (typedef for THnSparseT<ArrayS>): bin content held by a Short_t,; 511- THnSparseC (typedef for THnSparseT<ArrayC>): bin content held by a Char_t,; 512 ; 513They take name and title, the number of dimensions, and for each dimension; 514the number of bins, the minimal, and the maximal value on the dimension's; 515axis. A TH2 h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; 516 ; 517 Int_t bins[2] = {10, 20};; 518 Double_t xmin[2] = {0., -5.};; 519 Double_t xmax[2] ",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:19113,Energy Efficiency,allocate,allocated,19113,"rrayL64>): bin content held by a Long64_t,; 509- THnSparseI (typedef for THnSparseT<ArrayI>): bin content held by an Int_t,; 510- THnSparseS (typedef for THnSparseT<ArrayS>): bin content held by a Short_t,; 511- THnSparseC (typedef for THnSparseT<ArrayC>): bin content held by a Char_t,; 512 ; 513They take name and title, the number of dimensions, and for each dimension; 514the number of bins, the minimal, and the maximal value on the dimension's; 515axis. A TH2 h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; 516 ; 517 Int_t bins[2] = {10, 20};; 518 Double_t xmin[2] = {0., -5.};; 519 Double_t xmax[2] = {10., 5.};; 520 THnSparseD hs(""hs"", ""hs"", 2, bins, xmin, xmax);; 521 ; 522## Filling; 523A THnSparse is filled just like a regular histogram, using; 524THnSparse::Fill(x, weight), where x is a n-dimensional Double_t value.; 525To take errors into account, Sumw2() must be called before filling the; 526histogram.; 527 ; 528Bins are allocated as needed; the status of the allocation can be observed; 529by GetSparseFractionBins(), GetSparseFractionMem().; 530 ; 531## Fast Bin Content Access; 532When iterating over a THnSparse one should only look at filled bins to save; 533processing time. The number of filled bins is returned by; 534THnSparse::GetNbins(); the bin content for each (linear) bin number can; 535be retrieved by THnSparse::GetBinContent(linidx, (Int_t*)coord).; 536After the call, coord will contain the bin coordinate of each axis for the bin; 537with linear index linidx. A possible call would be; 538 ; 539 std::cout << hs.GetBinContent(0, coord);; 540 std::cout <<"" is the content of bin [x = "" << coord[0] ""; 541 << "" | y = "" << coord[1] << ""]"" << std::endl;; 542 ; 543## Efficiency; 544TH1 and TH2 are generally faster than THnSparse for one and two dimensional; 545distributions. THnSparse becomes competitive for a sparsely filled TH3; 546with large numbers of bins per dimension. The tutorial sparsehist.C; 547shows the turning point. On a AMD64 with 8GB me",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:20415,Energy Efficiency,reduce,reduced,20415," the bin content for each (linear) bin number can; 535be retrieved by THnSparse::GetBinContent(linidx, (Int_t*)coord).; 536After the call, coord will contain the bin coordinate of each axis for the bin; 537with linear index linidx. A possible call would be; 538 ; 539 std::cout << hs.GetBinContent(0, coord);; 540 std::cout <<"" is the content of bin [x = "" << coord[0] ""; 541 << "" | y = "" << coord[1] << ""]"" << std::endl;; 542 ; 543## Efficiency; 544TH1 and TH2 are generally faster than THnSparse for one and two dimensional; 545distributions. THnSparse becomes competitive for a sparsely filled TH3; 546with large numbers of bins per dimension. The tutorial sparsehist.C; 547shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins""; 548starting with a TH3 with 30 bins per dimension. Using a THnSparse for a; 549one-dimensional histogram is only reasonable if it has a huge number of bins.; 550 ; 551## Projections; 552The dimensionality of a THnSparse can be reduced by projecting it to; 5531, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; 554a THnSparse. See the Projection() members. To only project parts of the; 555histogram, call; 556 ; 557 THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);; 558 ; 559## Internal Representation; 560An entry for a filled bin consists of its n-dimensional coordinates and; 561its bin content. The coordinates are compacted to use as few bits as; 562possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; 563use 4 bits for the x representation and 5 bits for the y representation.; 564This is handled by the internal class THnSparseCompactBinCoord.; 565Bin data (content and coordinates) are allocated in chunks of size; 566fChunkSize; this parameter can be set when constructing a THnSparse. Each; 567chunk is represented by an object of class THnSparseArrayChunk.; 568 ; 569Translation from an n-dimensional bin coordinate to the linear index within; 570the chunks is done by GetBin(). It creates a ha",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:21130,Energy Efficiency,allocate,allocated,21130,"8GB memory, THnSparse ""wins""; 548starting with a TH3 with 30 bins per dimension. Using a THnSparse for a; 549one-dimensional histogram is only reasonable if it has a huge number of bins.; 550 ; 551## Projections; 552The dimensionality of a THnSparse can be reduced by projecting it to; 5531, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; 554a THnSparse. See the Projection() members. To only project parts of the; 555histogram, call; 556 ; 557 THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);; 558 ; 559## Internal Representation; 560An entry for a filled bin consists of its n-dimensional coordinates and; 561its bin content. The coordinates are compacted to use as few bits as; 562possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; 563use 4 bits for the x representation and 5 bits for the y representation.; 564This is handled by the internal class THnSparseCompactBinCoord.; 565Bin data (content and coordinates) are allocated in chunks of size; 566fChunkSize; this parameter can be set when constructing a THnSparse. Each; 567chunk is represented by an object of class THnSparseArrayChunk.; 568 ; 569Translation from an n-dimensional bin coordinate to the linear index within; 570the chunks is done by GetBin(). It creates a hash from the compacted bin; 571coordinates (the hash of a bin coordinate is the compacted coordinate itself; 572if it takes less than 8 bytes, the size of a Long64_t.; 573This hash is used to lookup the linear index in the TExMap member fBins;; 574the coordinates of the entry fBins points to is compared to the coordinates; 575passed to GetBin(). If they do not match, these two coordinates have the same; 576hash - which is extremely unlikely but (for the case where the compact bin; 577coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; 578contains a chain of linear indexes with the same hash. Iterating through this; 579chain and comparing each bin coordinates with the one passed to Get",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:26345,Energy Efficiency,allocate,allocate,26345,"ngleCoordinateSize;; 667 const Char_t* endbuf = buf + singleCoordSize * chunkSize;; 668 for (; buf < endbuf; buf += singleCoordSize, ++idx) {; 669 Long64_t hash = compactCoord.GetHashFromBuffer(buf);; 670 Long64_t linidx = fBins.GetValue(hash);; 671 if (linidx) {; 672 Long64_t nextidx = linidx;; 673 while (nextidx) {; 674 // must be a collision, so go to fBinsContinued.; 675 linidx = nextidx;; 676 nextidx = fBinsContinued.GetValue(linidx);; 677 }; 678 fBinsContinued.Add(linidx, idx + 1);; 679 } else {; 680 fBins.Add(hash, idx + 1);; 681 }; 682 }; 683 }; 684}; 685 ; 686////////////////////////////////////////////////////////////////////////////////; 687/// Initialize storage for nbins; 688 ; 689void THnSparse::Reserve(Long64_t nbins) {; 690 if (!fBins.GetSize() && fBinContent.GetSize()) {; 691 FillExMap();; 692 }; 693 if (2 * nbins > fBins.Capacity()) {; 694 fBins.Expand(3 * nbins);; 695 }; 696}; 697 ; 698////////////////////////////////////////////////////////////////////////////////; 699/// Get the bin index for the n dimensional tuple x,; 700/// allocate one if it doesn't exist yet and ""allocate"" is true.; 701 ; 702Long64_t THnSparse::GetBin(const Double_t* x, Bool_t allocate /* = kTRUE */); 703{; 704 THnSparseCompactBinCoord* cc = GetCompactCoord();; 705 Int_t *coord = cc->GetCoord();; 706 for (Int_t i = 0; i < fNdimensions; ++i); 707 coord[i] = GetAxis(i)->FindBin(x[i]);; 708 cc->UpdateCoord();; 709 ; 710 return GetBinIndexForCurrentBin(allocate);; 711}; 712 ; 713 ; 714////////////////////////////////////////////////////////////////////////////////; 715/// Get the bin index for the n dimensional tuple addressed by ""name"",; 716/// allocate one if it doesn't exist yet and ""allocate"" is true.; 717 ; 718Long64_t THnSparse::GetBin(const char* name[], Bool_t allocate /* = kTRUE */); 719{; 720 THnSparseCompactBinCoord* cc = GetCompactCoord();; 721 Int_t *coord = cc->GetCoord();; 722 for (Int_t i = 0; i < fNdimensions; ++i); 723 coord[i] = GetAxis(i)->FindBin(name[i]);;",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:26387,Energy Efficiency,allocate,allocate,26387,"ngleCoordinateSize;; 667 const Char_t* endbuf = buf + singleCoordSize * chunkSize;; 668 for (; buf < endbuf; buf += singleCoordSize, ++idx) {; 669 Long64_t hash = compactCoord.GetHashFromBuffer(buf);; 670 Long64_t linidx = fBins.GetValue(hash);; 671 if (linidx) {; 672 Long64_t nextidx = linidx;; 673 while (nextidx) {; 674 // must be a collision, so go to fBinsContinued.; 675 linidx = nextidx;; 676 nextidx = fBinsContinued.GetValue(linidx);; 677 }; 678 fBinsContinued.Add(linidx, idx + 1);; 679 } else {; 680 fBins.Add(hash, idx + 1);; 681 }; 682 }; 683 }; 684}; 685 ; 686////////////////////////////////////////////////////////////////////////////////; 687/// Initialize storage for nbins; 688 ; 689void THnSparse::Reserve(Long64_t nbins) {; 690 if (!fBins.GetSize() && fBinContent.GetSize()) {; 691 FillExMap();; 692 }; 693 if (2 * nbins > fBins.Capacity()) {; 694 fBins.Expand(3 * nbins);; 695 }; 696}; 697 ; 698////////////////////////////////////////////////////////////////////////////////; 699/// Get the bin index for the n dimensional tuple x,; 700/// allocate one if it doesn't exist yet and ""allocate"" is true.; 701 ; 702Long64_t THnSparse::GetBin(const Double_t* x, Bool_t allocate /* = kTRUE */); 703{; 704 THnSparseCompactBinCoord* cc = GetCompactCoord();; 705 Int_t *coord = cc->GetCoord();; 706 for (Int_t i = 0; i < fNdimensions; ++i); 707 coord[i] = GetAxis(i)->FindBin(x[i]);; 708 cc->UpdateCoord();; 709 ; 710 return GetBinIndexForCurrentBin(allocate);; 711}; 712 ; 713 ; 714////////////////////////////////////////////////////////////////////////////////; 715/// Get the bin index for the n dimensional tuple addressed by ""name"",; 716/// allocate one if it doesn't exist yet and ""allocate"" is true.; 717 ; 718Long64_t THnSparse::GetBin(const char* name[], Bool_t allocate /* = kTRUE */); 719{; 720 THnSparseCompactBinCoord* cc = GetCompactCoord();; 721 Int_t *coord = cc->GetCoord();; 722 for (Int_t i = 0; i < fNdimensions; ++i); 723 coord[i] = GetAxis(i)->FindBin(name[i]);;",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:26469,Energy Efficiency,allocate,allocate,26469,"ed.GetValue(linidx);; 677 }; 678 fBinsContinued.Add(linidx, idx + 1);; 679 } else {; 680 fBins.Add(hash, idx + 1);; 681 }; 682 }; 683 }; 684}; 685 ; 686////////////////////////////////////////////////////////////////////////////////; 687/// Initialize storage for nbins; 688 ; 689void THnSparse::Reserve(Long64_t nbins) {; 690 if (!fBins.GetSize() && fBinContent.GetSize()) {; 691 FillExMap();; 692 }; 693 if (2 * nbins > fBins.Capacity()) {; 694 fBins.Expand(3 * nbins);; 695 }; 696}; 697 ; 698////////////////////////////////////////////////////////////////////////////////; 699/// Get the bin index for the n dimensional tuple x,; 700/// allocate one if it doesn't exist yet and ""allocate"" is true.; 701 ; 702Long64_t THnSparse::GetBin(const Double_t* x, Bool_t allocate /* = kTRUE */); 703{; 704 THnSparseCompactBinCoord* cc = GetCompactCoord();; 705 Int_t *coord = cc->GetCoord();; 706 for (Int_t i = 0; i < fNdimensions; ++i); 707 coord[i] = GetAxis(i)->FindBin(x[i]);; 708 cc->UpdateCoord();; 709 ; 710 return GetBinIndexForCurrentBin(allocate);; 711}; 712 ; 713 ; 714////////////////////////////////////////////////////////////////////////////////; 715/// Get the bin index for the n dimensional tuple addressed by ""name"",; 716/// allocate one if it doesn't exist yet and ""allocate"" is true.; 717 ; 718Long64_t THnSparse::GetBin(const char* name[], Bool_t allocate /* = kTRUE */); 719{; 720 THnSparseCompactBinCoord* cc = GetCompactCoord();; 721 Int_t *coord = cc->GetCoord();; 722 for (Int_t i = 0; i < fNdimensions; ++i); 723 coord[i] = GetAxis(i)->FindBin(name[i]);; 724 cc->UpdateCoord();; 725 ; 726 return GetBinIndexForCurrentBin(allocate);; 727}; 728 ; 729////////////////////////////////////////////////////////////////////////////////; 730/// Get the bin index for the n dimensional coordinates coord,; 731/// allocate one if it doesn't exist yet and ""allocate"" is true.; 732 ; 733Long64_t THnSparse::GetBin(const Int_t* coord, Bool_t allocate /*= kTRUE*/); 734{; 735 GetCompactCoord",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:26746,Energy Efficiency,allocate,allocate,26746,"ed.GetValue(linidx);; 677 }; 678 fBinsContinued.Add(linidx, idx + 1);; 679 } else {; 680 fBins.Add(hash, idx + 1);; 681 }; 682 }; 683 }; 684}; 685 ; 686////////////////////////////////////////////////////////////////////////////////; 687/// Initialize storage for nbins; 688 ; 689void THnSparse::Reserve(Long64_t nbins) {; 690 if (!fBins.GetSize() && fBinContent.GetSize()) {; 691 FillExMap();; 692 }; 693 if (2 * nbins > fBins.Capacity()) {; 694 fBins.Expand(3 * nbins);; 695 }; 696}; 697 ; 698////////////////////////////////////////////////////////////////////////////////; 699/// Get the bin index for the n dimensional tuple x,; 700/// allocate one if it doesn't exist yet and ""allocate"" is true.; 701 ; 702Long64_t THnSparse::GetBin(const Double_t* x, Bool_t allocate /* = kTRUE */); 703{; 704 THnSparseCompactBinCoord* cc = GetCompactCoord();; 705 Int_t *coord = cc->GetCoord();; 706 for (Int_t i = 0; i < fNdimensions; ++i); 707 coord[i] = GetAxis(i)->FindBin(x[i]);; 708 cc->UpdateCoord();; 709 ; 710 return GetBinIndexForCurrentBin(allocate);; 711}; 712 ; 713 ; 714////////////////////////////////////////////////////////////////////////////////; 715/// Get the bin index for the n dimensional tuple addressed by ""name"",; 716/// allocate one if it doesn't exist yet and ""allocate"" is true.; 717 ; 718Long64_t THnSparse::GetBin(const char* name[], Bool_t allocate /* = kTRUE */); 719{; 720 THnSparseCompactBinCoord* cc = GetCompactCoord();; 721 Int_t *coord = cc->GetCoord();; 722 for (Int_t i = 0; i < fNdimensions; ++i); 723 coord[i] = GetAxis(i)->FindBin(name[i]);; 724 cc->UpdateCoord();; 725 ; 726 return GetBinIndexForCurrentBin(allocate);; 727}; 728 ; 729////////////////////////////////////////////////////////////////////////////////; 730/// Get the bin index for the n dimensional coordinates coord,; 731/// allocate one if it doesn't exist yet and ""allocate"" is true.; 732 ; 733Long64_t THnSparse::GetBin(const Int_t* coord, Bool_t allocate /*= kTRUE*/); 734{; 735 GetCompactCoord",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:26943,Energy Efficiency,allocate,allocate,26943,"ed.GetValue(linidx);; 677 }; 678 fBinsContinued.Add(linidx, idx + 1);; 679 } else {; 680 fBins.Add(hash, idx + 1);; 681 }; 682 }; 683 }; 684}; 685 ; 686////////////////////////////////////////////////////////////////////////////////; 687/// Initialize storage for nbins; 688 ; 689void THnSparse::Reserve(Long64_t nbins) {; 690 if (!fBins.GetSize() && fBinContent.GetSize()) {; 691 FillExMap();; 692 }; 693 if (2 * nbins > fBins.Capacity()) {; 694 fBins.Expand(3 * nbins);; 695 }; 696}; 697 ; 698////////////////////////////////////////////////////////////////////////////////; 699/// Get the bin index for the n dimensional tuple x,; 700/// allocate one if it doesn't exist yet and ""allocate"" is true.; 701 ; 702Long64_t THnSparse::GetBin(const Double_t* x, Bool_t allocate /* = kTRUE */); 703{; 704 THnSparseCompactBinCoord* cc = GetCompactCoord();; 705 Int_t *coord = cc->GetCoord();; 706 for (Int_t i = 0; i < fNdimensions; ++i); 707 coord[i] = GetAxis(i)->FindBin(x[i]);; 708 cc->UpdateCoord();; 709 ; 710 return GetBinIndexForCurrentBin(allocate);; 711}; 712 ; 713 ; 714////////////////////////////////////////////////////////////////////////////////; 715/// Get the bin index for the n dimensional tuple addressed by ""name"",; 716/// allocate one if it doesn't exist yet and ""allocate"" is true.; 717 ; 718Long64_t THnSparse::GetBin(const char* name[], Bool_t allocate /* = kTRUE */); 719{; 720 THnSparseCompactBinCoord* cc = GetCompactCoord();; 721 Int_t *coord = cc->GetCoord();; 722 for (Int_t i = 0; i < fNdimensions; ++i); 723 coord[i] = GetAxis(i)->FindBin(name[i]);; 724 cc->UpdateCoord();; 725 ; 726 return GetBinIndexForCurrentBin(allocate);; 727}; 728 ; 729////////////////////////////////////////////////////////////////////////////////; 730/// Get the bin index for the n dimensional coordinates coord,; 731/// allocate one if it doesn't exist yet and ""allocate"" is true.; 732 ; 733Long64_t THnSparse::GetBin(const Int_t* coord, Bool_t allocate /*= kTRUE*/); 734{; 735 GetCompactCoord",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:26985,Energy Efficiency,allocate,allocate,26985,"ed.GetValue(linidx);; 677 }; 678 fBinsContinued.Add(linidx, idx + 1);; 679 } else {; 680 fBins.Add(hash, idx + 1);; 681 }; 682 }; 683 }; 684}; 685 ; 686////////////////////////////////////////////////////////////////////////////////; 687/// Initialize storage for nbins; 688 ; 689void THnSparse::Reserve(Long64_t nbins) {; 690 if (!fBins.GetSize() && fBinContent.GetSize()) {; 691 FillExMap();; 692 }; 693 if (2 * nbins > fBins.Capacity()) {; 694 fBins.Expand(3 * nbins);; 695 }; 696}; 697 ; 698////////////////////////////////////////////////////////////////////////////////; 699/// Get the bin index for the n dimensional tuple x,; 700/// allocate one if it doesn't exist yet and ""allocate"" is true.; 701 ; 702Long64_t THnSparse::GetBin(const Double_t* x, Bool_t allocate /* = kTRUE */); 703{; 704 THnSparseCompactBinCoord* cc = GetCompactCoord();; 705 Int_t *coord = cc->GetCoord();; 706 for (Int_t i = 0; i < fNdimensions; ++i); 707 coord[i] = GetAxis(i)->FindBin(x[i]);; 708 cc->UpdateCoord();; 709 ; 710 return GetBinIndexForCurrentBin(allocate);; 711}; 712 ; 713 ; 714////////////////////////////////////////////////////////////////////////////////; 715/// Get the bin index for the n dimensional tuple addressed by ""name"",; 716/// allocate one if it doesn't exist yet and ""allocate"" is true.; 717 ; 718Long64_t THnSparse::GetBin(const char* name[], Bool_t allocate /* = kTRUE */); 719{; 720 THnSparseCompactBinCoord* cc = GetCompactCoord();; 721 Int_t *coord = cc->GetCoord();; 722 for (Int_t i = 0; i < fNdimensions; ++i); 723 coord[i] = GetAxis(i)->FindBin(name[i]);; 724 cc->UpdateCoord();; 725 ; 726 return GetBinIndexForCurrentBin(allocate);; 727}; 728 ; 729////////////////////////////////////////////////////////////////////////////////; 730/// Get the bin index for the n dimensional coordinates coord,; 731/// allocate one if it doesn't exist yet and ""allocate"" is true.; 732 ; 733Long64_t THnSparse::GetBin(const Int_t* coord, Bool_t allocate /*= kTRUE*/); 734{; 735 GetCompactCoord",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:27068,Energy Efficiency,allocate,allocate,27068,"in index for the n dimensional tuple x,; 700/// allocate one if it doesn't exist yet and ""allocate"" is true.; 701 ; 702Long64_t THnSparse::GetBin(const Double_t* x, Bool_t allocate /* = kTRUE */); 703{; 704 THnSparseCompactBinCoord* cc = GetCompactCoord();; 705 Int_t *coord = cc->GetCoord();; 706 for (Int_t i = 0; i < fNdimensions; ++i); 707 coord[i] = GetAxis(i)->FindBin(x[i]);; 708 cc->UpdateCoord();; 709 ; 710 return GetBinIndexForCurrentBin(allocate);; 711}; 712 ; 713 ; 714////////////////////////////////////////////////////////////////////////////////; 715/// Get the bin index for the n dimensional tuple addressed by ""name"",; 716/// allocate one if it doesn't exist yet and ""allocate"" is true.; 717 ; 718Long64_t THnSparse::GetBin(const char* name[], Bool_t allocate /* = kTRUE */); 719{; 720 THnSparseCompactBinCoord* cc = GetCompactCoord();; 721 Int_t *coord = cc->GetCoord();; 722 for (Int_t i = 0; i < fNdimensions; ++i); 723 coord[i] = GetAxis(i)->FindBin(name[i]);; 724 cc->UpdateCoord();; 725 ; 726 return GetBinIndexForCurrentBin(allocate);; 727}; 728 ; 729////////////////////////////////////////////////////////////////////////////////; 730/// Get the bin index for the n dimensional coordinates coord,; 731/// allocate one if it doesn't exist yet and ""allocate"" is true.; 732 ; 733Long64_t THnSparse::GetBin(const Int_t* coord, Bool_t allocate /*= kTRUE*/); 734{; 735 GetCompactCoord()->SetCoord(coord);; 736 return GetBinIndexForCurrentBin(allocate);; 737}; 738 ; 739////////////////////////////////////////////////////////////////////////////////; 740/// Return the content of the filled bin number ""idx"".; 741/// If coord is non-null, it will contain the bin's coordinates for each axis; 742/// that correspond to the bin.; 743 ; 744Double_t THnSparse::GetBinContent(Long64_t idx, Int_t* coord /* = 0 */) const; 745{; 746 if (idx >= 0) {; 747 THnSparseArrayChunk* chunk = GetChunk(idx / fChunkSize);; 748 idx %= fChunkSize;; 749 if (chunk && chunk->fContent->GetSize() > id",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:27348,Energy Efficiency,allocate,allocate,27348,"in index for the n dimensional tuple x,; 700/// allocate one if it doesn't exist yet and ""allocate"" is true.; 701 ; 702Long64_t THnSparse::GetBin(const Double_t* x, Bool_t allocate /* = kTRUE */); 703{; 704 THnSparseCompactBinCoord* cc = GetCompactCoord();; 705 Int_t *coord = cc->GetCoord();; 706 for (Int_t i = 0; i < fNdimensions; ++i); 707 coord[i] = GetAxis(i)->FindBin(x[i]);; 708 cc->UpdateCoord();; 709 ; 710 return GetBinIndexForCurrentBin(allocate);; 711}; 712 ; 713 ; 714////////////////////////////////////////////////////////////////////////////////; 715/// Get the bin index for the n dimensional tuple addressed by ""name"",; 716/// allocate one if it doesn't exist yet and ""allocate"" is true.; 717 ; 718Long64_t THnSparse::GetBin(const char* name[], Bool_t allocate /* = kTRUE */); 719{; 720 THnSparseCompactBinCoord* cc = GetCompactCoord();; 721 Int_t *coord = cc->GetCoord();; 722 for (Int_t i = 0; i < fNdimensions; ++i); 723 coord[i] = GetAxis(i)->FindBin(name[i]);; 724 cc->UpdateCoord();; 725 ; 726 return GetBinIndexForCurrentBin(allocate);; 727}; 728 ; 729////////////////////////////////////////////////////////////////////////////////; 730/// Get the bin index for the n dimensional coordinates coord,; 731/// allocate one if it doesn't exist yet and ""allocate"" is true.; 732 ; 733Long64_t THnSparse::GetBin(const Int_t* coord, Bool_t allocate /*= kTRUE*/); 734{; 735 GetCompactCoord()->SetCoord(coord);; 736 return GetBinIndexForCurrentBin(allocate);; 737}; 738 ; 739////////////////////////////////////////////////////////////////////////////////; 740/// Return the content of the filled bin number ""idx"".; 741/// If coord is non-null, it will contain the bin's coordinates for each axis; 742/// that correspond to the bin.; 743 ; 744Double_t THnSparse::GetBinContent(Long64_t idx, Int_t* coord /* = 0 */) const; 745{; 746 if (idx >= 0) {; 747 THnSparseArrayChunk* chunk = GetChunk(idx / fChunkSize);; 748 idx %= fChunkSize;; 749 if (chunk && chunk->fContent->GetSize() > id",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:27531,Energy Efficiency,allocate,allocate,27531,"in index for the n dimensional tuple x,; 700/// allocate one if it doesn't exist yet and ""allocate"" is true.; 701 ; 702Long64_t THnSparse::GetBin(const Double_t* x, Bool_t allocate /* = kTRUE */); 703{; 704 THnSparseCompactBinCoord* cc = GetCompactCoord();; 705 Int_t *coord = cc->GetCoord();; 706 for (Int_t i = 0; i < fNdimensions; ++i); 707 coord[i] = GetAxis(i)->FindBin(x[i]);; 708 cc->UpdateCoord();; 709 ; 710 return GetBinIndexForCurrentBin(allocate);; 711}; 712 ; 713 ; 714////////////////////////////////////////////////////////////////////////////////; 715/// Get the bin index for the n dimensional tuple addressed by ""name"",; 716/// allocate one if it doesn't exist yet and ""allocate"" is true.; 717 ; 718Long64_t THnSparse::GetBin(const char* name[], Bool_t allocate /* = kTRUE */); 719{; 720 THnSparseCompactBinCoord* cc = GetCompactCoord();; 721 Int_t *coord = cc->GetCoord();; 722 for (Int_t i = 0; i < fNdimensions; ++i); 723 coord[i] = GetAxis(i)->FindBin(name[i]);; 724 cc->UpdateCoord();; 725 ; 726 return GetBinIndexForCurrentBin(allocate);; 727}; 728 ; 729////////////////////////////////////////////////////////////////////////////////; 730/// Get the bin index for the n dimensional coordinates coord,; 731/// allocate one if it doesn't exist yet and ""allocate"" is true.; 732 ; 733Long64_t THnSparse::GetBin(const Int_t* coord, Bool_t allocate /*= kTRUE*/); 734{; 735 GetCompactCoord()->SetCoord(coord);; 736 return GetBinIndexForCurrentBin(allocate);; 737}; 738 ; 739////////////////////////////////////////////////////////////////////////////////; 740/// Return the content of the filled bin number ""idx"".; 741/// If coord is non-null, it will contain the bin's coordinates for each axis; 742/// that correspond to the bin.; 743 ; 744Double_t THnSparse::GetBinContent(Long64_t idx, Int_t* coord /* = 0 */) const; 745{; 746 if (idx >= 0) {; 747 THnSparseArrayChunk* chunk = GetChunk(idx / fChunkSize);; 748 idx %= fChunkSize;; 749 if (chunk && chunk->fContent->GetSize() > id",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:27573,Energy Efficiency,allocate,allocate,27573,"in index for the n dimensional tuple x,; 700/// allocate one if it doesn't exist yet and ""allocate"" is true.; 701 ; 702Long64_t THnSparse::GetBin(const Double_t* x, Bool_t allocate /* = kTRUE */); 703{; 704 THnSparseCompactBinCoord* cc = GetCompactCoord();; 705 Int_t *coord = cc->GetCoord();; 706 for (Int_t i = 0; i < fNdimensions; ++i); 707 coord[i] = GetAxis(i)->FindBin(x[i]);; 708 cc->UpdateCoord();; 709 ; 710 return GetBinIndexForCurrentBin(allocate);; 711}; 712 ; 713 ; 714////////////////////////////////////////////////////////////////////////////////; 715/// Get the bin index for the n dimensional tuple addressed by ""name"",; 716/// allocate one if it doesn't exist yet and ""allocate"" is true.; 717 ; 718Long64_t THnSparse::GetBin(const char* name[], Bool_t allocate /* = kTRUE */); 719{; 720 THnSparseCompactBinCoord* cc = GetCompactCoord();; 721 Int_t *coord = cc->GetCoord();; 722 for (Int_t i = 0; i < fNdimensions; ++i); 723 coord[i] = GetAxis(i)->FindBin(name[i]);; 724 cc->UpdateCoord();; 725 ; 726 return GetBinIndexForCurrentBin(allocate);; 727}; 728 ; 729////////////////////////////////////////////////////////////////////////////////; 730/// Get the bin index for the n dimensional coordinates coord,; 731/// allocate one if it doesn't exist yet and ""allocate"" is true.; 732 ; 733Long64_t THnSparse::GetBin(const Int_t* coord, Bool_t allocate /*= kTRUE*/); 734{; 735 GetCompactCoord()->SetCoord(coord);; 736 return GetBinIndexForCurrentBin(allocate);; 737}; 738 ; 739////////////////////////////////////////////////////////////////////////////////; 740/// Return the content of the filled bin number ""idx"".; 741/// If coord is non-null, it will contain the bin's coordinates for each axis; 742/// that correspond to the bin.; 743 ; 744Double_t THnSparse::GetBinContent(Long64_t idx, Int_t* coord /* = 0 */) const; 745{; 746 if (idx >= 0) {; 747 THnSparseArrayChunk* chunk = GetChunk(idx / fChunkSize);; 748 idx %= fChunkSize;; 749 if (chunk && chunk->fContent->GetSize() > id",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:27656,Energy Efficiency,allocate,allocate,27656,"11}; 712 ; 713 ; 714////////////////////////////////////////////////////////////////////////////////; 715/// Get the bin index for the n dimensional tuple addressed by ""name"",; 716/// allocate one if it doesn't exist yet and ""allocate"" is true.; 717 ; 718Long64_t THnSparse::GetBin(const char* name[], Bool_t allocate /* = kTRUE */); 719{; 720 THnSparseCompactBinCoord* cc = GetCompactCoord();; 721 Int_t *coord = cc->GetCoord();; 722 for (Int_t i = 0; i < fNdimensions; ++i); 723 coord[i] = GetAxis(i)->FindBin(name[i]);; 724 cc->UpdateCoord();; 725 ; 726 return GetBinIndexForCurrentBin(allocate);; 727}; 728 ; 729////////////////////////////////////////////////////////////////////////////////; 730/// Get the bin index for the n dimensional coordinates coord,; 731/// allocate one if it doesn't exist yet and ""allocate"" is true.; 732 ; 733Long64_t THnSparse::GetBin(const Int_t* coord, Bool_t allocate /*= kTRUE*/); 734{; 735 GetCompactCoord()->SetCoord(coord);; 736 return GetBinIndexForCurrentBin(allocate);; 737}; 738 ; 739////////////////////////////////////////////////////////////////////////////////; 740/// Return the content of the filled bin number ""idx"".; 741/// If coord is non-null, it will contain the bin's coordinates for each axis; 742/// that correspond to the bin.; 743 ; 744Double_t THnSparse::GetBinContent(Long64_t idx, Int_t* coord /* = 0 */) const; 745{; 746 if (idx >= 0) {; 747 THnSparseArrayChunk* chunk = GetChunk(idx / fChunkSize);; 748 idx %= fChunkSize;; 749 if (chunk && chunk->fContent->GetSize() > idx) {; 750 if (coord) {; 751 THnSparseCompactBinCoord* cc = GetCompactCoord();; 752 Int_t sizeCompact = cc->GetBufferSize();; 753 cc->SetCoordFromBuffer(chunk->fCoordinates + idx * sizeCompact,; 754 coord);; 755 ; 756 }; 757 return chunk->fContent->GetAt(idx);; 758 }; 759 }; 760 if (coord); 761 memset(coord, -1, sizeof(Int_t) * fNdimensions);; 762 return 0.;; 763}; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766//",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:27762,Energy Efficiency,allocate,allocate,27762,"11}; 712 ; 713 ; 714////////////////////////////////////////////////////////////////////////////////; 715/// Get the bin index for the n dimensional tuple addressed by ""name"",; 716/// allocate one if it doesn't exist yet and ""allocate"" is true.; 717 ; 718Long64_t THnSparse::GetBin(const char* name[], Bool_t allocate /* = kTRUE */); 719{; 720 THnSparseCompactBinCoord* cc = GetCompactCoord();; 721 Int_t *coord = cc->GetCoord();; 722 for (Int_t i = 0; i < fNdimensions; ++i); 723 coord[i] = GetAxis(i)->FindBin(name[i]);; 724 cc->UpdateCoord();; 725 ; 726 return GetBinIndexForCurrentBin(allocate);; 727}; 728 ; 729////////////////////////////////////////////////////////////////////////////////; 730/// Get the bin index for the n dimensional coordinates coord,; 731/// allocate one if it doesn't exist yet and ""allocate"" is true.; 732 ; 733Long64_t THnSparse::GetBin(const Int_t* coord, Bool_t allocate /*= kTRUE*/); 734{; 735 GetCompactCoord()->SetCoord(coord);; 736 return GetBinIndexForCurrentBin(allocate);; 737}; 738 ; 739////////////////////////////////////////////////////////////////////////////////; 740/// Return the content of the filled bin number ""idx"".; 741/// If coord is non-null, it will contain the bin's coordinates for each axis; 742/// that correspond to the bin.; 743 ; 744Double_t THnSparse::GetBinContent(Long64_t idx, Int_t* coord /* = 0 */) const; 745{; 746 if (idx >= 0) {; 747 THnSparseArrayChunk* chunk = GetChunk(idx / fChunkSize);; 748 idx %= fChunkSize;; 749 if (chunk && chunk->fContent->GetSize() > idx) {; 750 if (coord) {; 751 THnSparseCompactBinCoord* cc = GetCompactCoord();; 752 Int_t sizeCompact = cc->GetBufferSize();; 753 cc->SetCoordFromBuffer(chunk->fCoordinates + idx * sizeCompact,; 754 coord);; 755 ; 756 }; 757 return chunk->fContent->GetAt(idx);; 758 }; 759 }; 760 if (coord); 761 memset(coord, -1, sizeof(Int_t) * fNdimensions);; 762 return 0.;; 763}; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766//",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:29522,Energy Efficiency,allocate,allocate,29522,"zeof(Int_t) * fNdimensions);; 762 return 0.;; 763}; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Get square of the error of bin addressed by linidx as; 767/// \f$\sum weight^{2}\f$; 768/// If errors are not enabled (via Sumw2() or CalculateErrors()); 769/// return contents.; 770 ; 771Double_t THnSparse::GetBinError2(Long64_t linidx) const {; 772 if (!GetCalculateErrors()); 773 return GetBinContent(linidx);; 774 ; 775 if (linidx < 0) return 0.;; 776 THnSparseArrayChunk* chunk = GetChunk(linidx / fChunkSize);; 777 linidx %= fChunkSize;; 778 if (!chunk || chunk->fContent->GetSize() < linidx); 779 return 0.;; 780 ; 781 return chunk->fSumw2->GetAt(linidx);; 782}; 783 ; 784 ; 785////////////////////////////////////////////////////////////////////////////////; 786/// Return the index for fCurrentBinIndex.; 787/// If it doesn't exist then return -1, or allocate a new bin if allocate is set; 788 ; 789Long64_t THnSparse::GetBinIndexForCurrentBin(Bool_t allocate); 790{; 791 THnSparseCompactBinCoord* cc = GetCompactCoord();; 792 ULong64_t hash = cc->GetHash();; 793 if (fBinContent.GetSize() && !fBins.GetSize()); 794 FillExMap();; 795 Long64_t linidx = (Long64_t) fBins.GetValue(hash);; 796 while (linidx) {; 797 // fBins stores index + 1!; 798 THnSparseArrayChunk* chunk = GetChunk((linidx - 1)/ fChunkSize);; 799 if (chunk->Matches((linidx - 1) % fChunkSize, cc->GetBuffer())); 800 return linidx - 1; // we store idx+1, 0 is ""TExMap: not found""; 801 ; 802 Long64_t nextlinidx = fBinsContinued.GetValue(linidx);; 803 if (!nextlinidx) break;; 804 ; 805 linidx = nextlinidx;; 806 }; 807 if (!allocate) return -1;; 808 ; 809 ++fFilledBins;; 810 ; 811 // allocate bin in chunk; 812 THnSparseArrayChunk *chunk = (THnSparseArrayChunk*) fBinContent.Last();; 813 Long64_t newidx = chunk ? ((Long64_t) chunk->GetEntries()) : -1;; 814 if (!chunk || newidx == (Long64_t)fChunkSize) {; 815 chunk = AddChunk();; 816 newidx = 0;; 817 }; 818 chunk->AddBin(n",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:29544,Energy Efficiency,allocate,allocate,29544,"zeof(Int_t) * fNdimensions);; 762 return 0.;; 763}; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Get square of the error of bin addressed by linidx as; 767/// \f$\sum weight^{2}\f$; 768/// If errors are not enabled (via Sumw2() or CalculateErrors()); 769/// return contents.; 770 ; 771Double_t THnSparse::GetBinError2(Long64_t linidx) const {; 772 if (!GetCalculateErrors()); 773 return GetBinContent(linidx);; 774 ; 775 if (linidx < 0) return 0.;; 776 THnSparseArrayChunk* chunk = GetChunk(linidx / fChunkSize);; 777 linidx %= fChunkSize;; 778 if (!chunk || chunk->fContent->GetSize() < linidx); 779 return 0.;; 780 ; 781 return chunk->fSumw2->GetAt(linidx);; 782}; 783 ; 784 ; 785////////////////////////////////////////////////////////////////////////////////; 786/// Return the index for fCurrentBinIndex.; 787/// If it doesn't exist then return -1, or allocate a new bin if allocate is set; 788 ; 789Long64_t THnSparse::GetBinIndexForCurrentBin(Bool_t allocate); 790{; 791 THnSparseCompactBinCoord* cc = GetCompactCoord();; 792 ULong64_t hash = cc->GetHash();; 793 if (fBinContent.GetSize() && !fBins.GetSize()); 794 FillExMap();; 795 Long64_t linidx = (Long64_t) fBins.GetValue(hash);; 796 while (linidx) {; 797 // fBins stores index + 1!; 798 THnSparseArrayChunk* chunk = GetChunk((linidx - 1)/ fChunkSize);; 799 if (chunk->Matches((linidx - 1) % fChunkSize, cc->GetBuffer())); 800 return linidx - 1; // we store idx+1, 0 is ""TExMap: not found""; 801 ; 802 Long64_t nextlinidx = fBinsContinued.GetValue(linidx);; 803 if (!nextlinidx) break;; 804 ; 805 linidx = nextlinidx;; 806 }; 807 if (!allocate) return -1;; 808 ; 809 ++fFilledBins;; 810 ; 811 // allocate bin in chunk; 812 THnSparseArrayChunk *chunk = (THnSparseArrayChunk*) fBinContent.Last();; 813 Long64_t newidx = chunk ? ((Long64_t) chunk->GetEntries()) : -1;; 814 if (!chunk || newidx == (Long64_t)fChunkSize) {; 815 chunk = AddChunk();; 816 newidx = 0;; 817 }; 818 chunk->AddBin(n",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:29622,Energy Efficiency,allocate,allocate,29622,"zeof(Int_t) * fNdimensions);; 762 return 0.;; 763}; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Get square of the error of bin addressed by linidx as; 767/// \f$\sum weight^{2}\f$; 768/// If errors are not enabled (via Sumw2() or CalculateErrors()); 769/// return contents.; 770 ; 771Double_t THnSparse::GetBinError2(Long64_t linidx) const {; 772 if (!GetCalculateErrors()); 773 return GetBinContent(linidx);; 774 ; 775 if (linidx < 0) return 0.;; 776 THnSparseArrayChunk* chunk = GetChunk(linidx / fChunkSize);; 777 linidx %= fChunkSize;; 778 if (!chunk || chunk->fContent->GetSize() < linidx); 779 return 0.;; 780 ; 781 return chunk->fSumw2->GetAt(linidx);; 782}; 783 ; 784 ; 785////////////////////////////////////////////////////////////////////////////////; 786/// Return the index for fCurrentBinIndex.; 787/// If it doesn't exist then return -1, or allocate a new bin if allocate is set; 788 ; 789Long64_t THnSparse::GetBinIndexForCurrentBin(Bool_t allocate); 790{; 791 THnSparseCompactBinCoord* cc = GetCompactCoord();; 792 ULong64_t hash = cc->GetHash();; 793 if (fBinContent.GetSize() && !fBins.GetSize()); 794 FillExMap();; 795 Long64_t linidx = (Long64_t) fBins.GetValue(hash);; 796 while (linidx) {; 797 // fBins stores index + 1!; 798 THnSparseArrayChunk* chunk = GetChunk((linidx - 1)/ fChunkSize);; 799 if (chunk->Matches((linidx - 1) % fChunkSize, cc->GetBuffer())); 800 return linidx - 1; // we store idx+1, 0 is ""TExMap: not found""; 801 ; 802 Long64_t nextlinidx = fBinsContinued.GetValue(linidx);; 803 if (!nextlinidx) break;; 804 ; 805 linidx = nextlinidx;; 806 }; 807 if (!allocate) return -1;; 808 ; 809 ++fFilledBins;; 810 ; 811 // allocate bin in chunk; 812 THnSparseArrayChunk *chunk = (THnSparseArrayChunk*) fBinContent.Last();; 813 Long64_t newidx = chunk ? ((Long64_t) chunk->GetEntries()) : -1;; 814 if (!chunk || newidx == (Long64_t)fChunkSize) {; 815 chunk = AddChunk();; 816 newidx = 0;; 817 }; 818 chunk->AddBin(n",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:30261,Energy Efficiency,allocate,allocate,30261,"eturn chunk->fSumw2->GetAt(linidx);; 782}; 783 ; 784 ; 785////////////////////////////////////////////////////////////////////////////////; 786/// Return the index for fCurrentBinIndex.; 787/// If it doesn't exist then return -1, or allocate a new bin if allocate is set; 788 ; 789Long64_t THnSparse::GetBinIndexForCurrentBin(Bool_t allocate); 790{; 791 THnSparseCompactBinCoord* cc = GetCompactCoord();; 792 ULong64_t hash = cc->GetHash();; 793 if (fBinContent.GetSize() && !fBins.GetSize()); 794 FillExMap();; 795 Long64_t linidx = (Long64_t) fBins.GetValue(hash);; 796 while (linidx) {; 797 // fBins stores index + 1!; 798 THnSparseArrayChunk* chunk = GetChunk((linidx - 1)/ fChunkSize);; 799 if (chunk->Matches((linidx - 1) % fChunkSize, cc->GetBuffer())); 800 return linidx - 1; // we store idx+1, 0 is ""TExMap: not found""; 801 ; 802 Long64_t nextlinidx = fBinsContinued.GetValue(linidx);; 803 if (!nextlinidx) break;; 804 ; 805 linidx = nextlinidx;; 806 }; 807 if (!allocate) return -1;; 808 ; 809 ++fFilledBins;; 810 ; 811 // allocate bin in chunk; 812 THnSparseArrayChunk *chunk = (THnSparseArrayChunk*) fBinContent.Last();; 813 Long64_t newidx = chunk ? ((Long64_t) chunk->GetEntries()) : -1;; 814 if (!chunk || newidx == (Long64_t)fChunkSize) {; 815 chunk = AddChunk();; 816 newidx = 0;; 817 }; 818 chunk->AddBin(newidx, cc->GetBuffer());; 819 ; 820 // store translation between hash and bin; 821 newidx += (fBinContent.GetEntriesFast() - 1) * fChunkSize;; 822 if (!linidx) {; 823 // fBins didn't find it; 824 if (2 * GetNbins() > fBins.Capacity()); 825 fBins.Expand(3 * GetNbins());; 826 fBins.Add(hash, newidx + 1);; 827 } else {; 828 // fBins contains one, but it's the wrong one;; 829 // add entry to fBinsContinued.; 830 fBinsContinued.Add(linidx, newidx + 1);; 831 }; 832 return newidx;; 833}; 834 ; 835////////////////////////////////////////////////////////////////////////////////; 836/// Return THnSparseCompactBinCoord object.; 837 ; 838THnSparseCompactBinCoord* THnSparse::GetCo",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:30322,Energy Efficiency,allocate,allocate,30322,"eturn chunk->fSumw2->GetAt(linidx);; 782}; 783 ; 784 ; 785////////////////////////////////////////////////////////////////////////////////; 786/// Return the index for fCurrentBinIndex.; 787/// If it doesn't exist then return -1, or allocate a new bin if allocate is set; 788 ; 789Long64_t THnSparse::GetBinIndexForCurrentBin(Bool_t allocate); 790{; 791 THnSparseCompactBinCoord* cc = GetCompactCoord();; 792 ULong64_t hash = cc->GetHash();; 793 if (fBinContent.GetSize() && !fBins.GetSize()); 794 FillExMap();; 795 Long64_t linidx = (Long64_t) fBins.GetValue(hash);; 796 while (linidx) {; 797 // fBins stores index + 1!; 798 THnSparseArrayChunk* chunk = GetChunk((linidx - 1)/ fChunkSize);; 799 if (chunk->Matches((linidx - 1) % fChunkSize, cc->GetBuffer())); 800 return linidx - 1; // we store idx+1, 0 is ""TExMap: not found""; 801 ; 802 Long64_t nextlinidx = fBinsContinued.GetValue(linidx);; 803 if (!nextlinidx) break;; 804 ; 805 linidx = nextlinidx;; 806 }; 807 if (!allocate) return -1;; 808 ; 809 ++fFilledBins;; 810 ; 811 // allocate bin in chunk; 812 THnSparseArrayChunk *chunk = (THnSparseArrayChunk*) fBinContent.Last();; 813 Long64_t newidx = chunk ? ((Long64_t) chunk->GetEntries()) : -1;; 814 if (!chunk || newidx == (Long64_t)fChunkSize) {; 815 chunk = AddChunk();; 816 newidx = 0;; 817 }; 818 chunk->AddBin(newidx, cc->GetBuffer());; 819 ; 820 // store translation between hash and bin; 821 newidx += (fBinContent.GetEntriesFast() - 1) * fChunkSize;; 822 if (!linidx) {; 823 // fBins didn't find it; 824 if (2 * GetNbins() > fBins.Capacity()); 825 fBins.Expand(3 * GetNbins());; 826 fBins.Add(hash, newidx + 1);; 827 } else {; 828 // fBins contains one, but it's the wrong one;; 829 // add entry to fBinsContinued.; 830 fBinsContinued.Add(linidx, newidx + 1);; 831 }; 832 return newidx;; 833}; 834 ; 835////////////////////////////////////////////////////////////////////////////////; 836/// Return THnSparseCompactBinCoord object.; 837 ; 838THnSparseCompactBinCoord* THnSparse::GetCo",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:42597,Energy Efficiency,allocate,allocated,42597," THnSparseArrayChunk::THnSparseArrayChunkTHnSparseArrayChunk()Definition THnSparse_Internal.h:37; THnSparseArrayChunk::fCoordinatesSizeInt_t fCoordinatesSizeSize of the bin coordinate buffer.Definition THnSparse_Internal.h:46; THnSparseArrayChunk::fSingleCoordinateSizeInt_t fSingleCoordinateSizeSize of a single bin coordinate.Definition THnSparse_Internal.h:45; THnSparseArrayChunk::Sumw2void Sumw2()Turn on support of errors.Definition THnSparse.cxx:480; THnSparseArrayChunk::fCoordinatesChar_t * fCoordinates[fCoordinatesSize] compact bin coordinate bufferDefinition THnSparse_Internal.h:47; THnSparseArrayChunk::fContentTArray * fContentBin content.Definition THnSparse_Internal.h:48; THnSparseArrayChunk::GetEntriesInt_t GetEntries() constDefinition THnSparse_Internal.h:58; THnSparseArrayChunk::AddBinvoid AddBin(Int_t idx, const Char_t *idxbuf)Create a new bin in this chunk.Definition THnSparse.cxx:450; THnSparseArrayChunk::fCoordinateAllocationSizeInt_t fCoordinateAllocationSize! Size of the allocated coordinate buffer; -1 means none or fCoordinatesSizeDefinition THnSparse_Internal.h:44; THnSparseCompactBinCoordTHnSparseCompactBinCoord is a class used by THnSparse internally.Definition THnSparse.cxx:351; THnSparseCompactBinCoord::THnSparseCompactBinCoordTHnSparseCompactBinCoord(Int_t dim, const Int_t *nbins)Initialize a THnSparseCompactBinCoord object with ""dim"" dimensions and ""bins"" holding the number of b...Definition THnSparse.cxx:391; THnSparseCompactBinCoord::GetHashULong64_t GetHash() constDefinition THnSparse.cxx:357; THnSparseCompactBinCoord::GetCoordInt_t * GetCoord()Definition THnSparse.cxx:355; THnSparseCompactBinCoord::GetBufferconst Char_t * GetBuffer() constDefinition THnSparse.cxx:356; THnSparseCompactBinCoord::~THnSparseCompactBinCoord~THnSparseCompactBinCoord()destruct a THnSparseCompactBinCoordDefinition THnSparse.cxx:406; THnSparseCompactBinCoord::fCoordBufferChar_t * fCoordBufferDefinition THnSparse.cxx:378; THnSparseCompactBinCoord::THnSparseCompac",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:49853,Energy Efficiency,allocate,allocate,49853,"6; THnSparse::fBinsTExMap fBins! Filled binsDefinition THnSparse.h:42; THnSparse::fBinsContinuedTExMap fBinsContinued! Filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1)Definition THnSparse.h:43; THnSparse::AddBinContentvoid AddBinContent(const Int_t *idx, Double_t v=1.)Forwards to THnBase::AddBinContent().Definition THnSparse.h:113; THnSparse::Reservevoid Reserve(Long64_t nbins) overrideInitialize storage for nbins.Definition THnSparse.cxx:689; THnSparse::fChunkSizeInt_t fChunkSizeNumber of entries for each chunk.Definition THnSparse.h:39; THnSparse::Sumw2void Sumw2() overrideEnable calculation of errors.Definition THnSparse.cxx:948; THnSparse::GetNbinsLong64_t GetNbins() const overrideDefinition THnSparse.h:93; THnSparse::CreateIterROOT::Internal::THnBaseBinIter * CreateIter(Bool_t respectAxisRange) const overrideCreate an iterator over all filled bins of a THnSparse.Definition THnSparse.cxx:896; THnSparse::GetBinIndexForCurrentBinLong64_t GetBinIndexForCurrentBin(Bool_t allocate)Return the index for fCurrentBinIndex.Definition THnSparse.cxx:789; TIterDefinition TCollection.h:235; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::LastTObject * Last() const overrideReturn the object in the last filled slot. Returns 0 if no entries.Definition TObjArray.cxx:506; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::AddLastvoid AddLast(TObject *obj) overrideAdd object in the next empty slot in the array.Definition TObjArray.cxx:178; TObject::Clearvirtual void Clear(Option_t *="""")Definition TObject.h:119; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual vo",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:3820,Integrability,depend,depend,3820,"; 82 && !fHist->IsInRange(useCoordBuf); 83 && (fHaveSkippedBin = kTRUE /* assignment! */));; 84 ; 85 if (coord && coord[0] == -1) {; 86 if (fCoord[0] == -1) {; 87 fHist->GetBinContent(fIndex, coord);; 88 } else {; 89 memcpy(coord, fCoord, fHist->GetNdimensions() * sizeof(Int_t));; 90 }; 91 }; 92 ; 93 return fIndex;; 94}; 95 ; 96 ; 97 ; 98/** \class THnSparseCoordCompression; 99THnSparseCoordCompression is a class used by THnSparse internally. It; 100represents a compacted n-dimensional array of bin coordinates (indices).; 101As the total number of bins in each dimension is known by THnSparse, bin; 102indices can be compacted to only use the amount of bins needed by the total; 103number of bins in each dimension. E.g. for a THnSparse with; 104{15, 100, 2, 20, 10, 100} bins per dimension, a bin index will only occupy; 10528 bits (4+7+1+5+4+7), i.e. less than a 32bit integer. The tricky part is; 106the fast compression and decompression, the platform-independent storage; 107(think of endianness: the bits of the number 0x123456 depend on the; 108platform), and the hashing needed by THnSparseArrayChunk.; 109*/; 110 ; 111 ; 112class THnSparseCoordCompression {; 113public:; 114 THnSparseCoordCompression(Int_t dim, const Int_t* nbins);; 115 THnSparseCoordCompression(const THnSparseCoordCompression& other);; 116 ~THnSparseCoordCompression();; 117 ; 118 THnSparseCoordCompression& operator=(const THnSparseCoordCompression& other);; 119 ; 120 ULong64_t GetHashFromBuffer(const Char_t* buf) const;; 121 Int_t GetBufferSize() const { return fCoordBufferSize; }; 122 Int_t GetNdimensions() const { return fNdimensions; }; 123 void SetCoordFromBuffer(const Char_t* buf_in, Int_t* coord_out) const;; 124 ULong64_t SetBufferFromCoord(const Int_t* coord_in, Char_t* buf_out) const;; 125 ; 126protected:; 127 Int_t GetNumBits(Int_t n) const {; 128 // return the number of bits allocated by the number ""n""; 129 Int_t r = (n > 0);; 130 while (n/=2) ++r;; 131 return r;; 132 }; 133private:; 134 Int_",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:9473,Integrability,depend,depending,9473,"237 ULong64_t l64buf = 0;; 238 for (Int_t i = 0; i < fNdimensions; ++i) {; 239 l64buf += ((ULong64_t)((UInt_t)coord_in[i])) << fBitOffsets[i];; 240 }; 241 memcpy(buf_out, &l64buf, sizeof(Long64_t));; 242 return l64buf;; 243 }; 244 ; 245 // else: doesn't fit into a Long64_t:; 246 memset(buf_out, 0, fCoordBufferSize);; 247 for (Int_t i = 0; i < fNdimensions; ++i) {; 248 const Int_t offset = fBitOffsets[i] / 8;; 249 const Int_t shift = fBitOffsets[i] % 8;; 250 ULong64_t val = coord_in[i];; 251 ; 252 Char_t* pbuf = buf_out + offset;; 253 *pbuf += 0xff & (val << shift);; 254 val = val >> (8 - shift);; 255 while (val) {; 256 ++pbuf;; 257 *pbuf += 0xff & val;; 258 val = val >> 8;; 259 }; 260 }; 261 ; 262 return GetHashFromBuffer(buf_out);; 263}; 264 ; 265/*; 266////////////////////////////////////////////////////////////////////////////////; 267/// Calculate hash from bin indexes.; 268 ; 269ULong64_t THnSparseCoordCompression::GetHashFromCoords(const Int_t* coord) const; 270{; 271 // Bins are addressed in two different modes, depending; 272 // on whether the compact bin index fits into a Long64_t or not.; 273 // If it does, we can use it as a ""perfect hash"" for the TExMap.; 274 // If not we build a hash from the compact bin index, and use that; 275 // as the TExMap's hash.; 276 ; 277 if (fCoordBufferSize <= 8) {; 278 // fits into a Long64_t; 279 ULong64_t hash1 = 0;; 280 for (Int_t i = 0; i < fNdimensions; ++i) {; 281 hash1 += coord[i] << fBitOffsets[i];; 282 }; 283 return hash1;; 284 }; 285 ; 286 // else: doesn't fit into a Long64_t:; 287 memset(coord, 0, fCoordBufferSize);; 288 for (Int_t i = 0; i < fNdimensions; ++i) {; 289 const Int_t offset = fBitOffsets[i] / 8;; 290 const Int_t shift = fBitOffsets[i] % 8;; 291 ULong64_t val = coord[i];; 292 ; 293 Char_t* pbuf = fCoordBuffer + offset;; 294 *pbuf += 0xff & (val << shift);; 295 val = val >> (8 - shift);; 296 while (val) {; 297 ++pbuf;; 298 *pbuf += 0xff & val;; 299 val = val >> 8;; 300 }; 301 }; 302 ; 303 ULong64_t hash",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:10901,Integrability,depend,depending,10901,"{; 281 hash1 += coord[i] << fBitOffsets[i];; 282 }; 283 return hash1;; 284 }; 285 ; 286 // else: doesn't fit into a Long64_t:; 287 memset(coord, 0, fCoordBufferSize);; 288 for (Int_t i = 0; i < fNdimensions; ++i) {; 289 const Int_t offset = fBitOffsets[i] / 8;; 290 const Int_t shift = fBitOffsets[i] % 8;; 291 ULong64_t val = coord[i];; 292 ; 293 Char_t* pbuf = fCoordBuffer + offset;; 294 *pbuf += 0xff & (val << shift);; 295 val = val >> (8 - shift);; 296 while (val) {; 297 ++pbuf;; 298 *pbuf += 0xff & val;; 299 val = val >> 8;; 300 }; 301 }; 302 ; 303 ULong64_t hash = 5381;; 304 Char_t* str = fCoordBuffer;; 305 while (str - fCoordBuffer < fCoordBufferSize) {; 306 hash *= 5;; 307 hash += *(str++);; 308 }; 309 return hash;; 310}; 311*/; 312 ; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// Calculate hash from compact bin index.; 316 ; 317ULong64_t THnSparseCoordCompression::GetHashFromBuffer(const Char_t* buf) const; 318{; 319 // Bins are addressed in two different modes, depending; 320 // on whether the compact bin index fits into a Long64_t or not.; 321 // If it does, we can use it as a ""perfect hash"" for the TExMap.; 322 // If not we build a hash from the compact bin index, and use that; 323 // as the TExMap's hash.; 324 ; 325 if (fCoordBufferSize <= 8) {; 326 // fits into a Long64_t; 327 ULong64_t hash1 = 0;; 328 memcpy(&hash1, buf, fCoordBufferSize);; 329 return hash1;; 330 }; 331 ; 332 // else: doesn't fit into a Long64_t:; 333 ULong64_t hash = 5381;; 334 const Char_t* str = buf;; 335 while (str - buf < fCoordBufferSize) {; 336 hash *= 5;; 337 hash += *(str++);; 338 }; 339 return hash;; 340}; 341 ; 342 ; 343 ; 344 ; 345/** \class THnSparseCompactBinCoord; 346THnSparseCompactBinCoord is a class used by THnSparse internally. It; 347maps between an n-dimensional array of bin coordinates (indices) and; 348its compact version, the THnSparseCoordCompression.; 349*/; 350 ; 351class THnSparseCompactBinCoord: public THnSpa",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:50774,Integrability,message,message,50774,"Sumw2void Sumw2() overrideEnable calculation of errors.Definition THnSparse.cxx:948; THnSparse::GetNbinsLong64_t GetNbins() const overrideDefinition THnSparse.h:93; THnSparse::CreateIterROOT::Internal::THnBaseBinIter * CreateIter(Bool_t respectAxisRange) const overrideCreate an iterator over all filled bins of a THnSparse.Definition THnSparse.cxx:896; THnSparse::GetBinIndexForCurrentBinLong64_t GetBinIndexForCurrentBin(Bool_t allocate)Return the index for fCurrentBinIndex.Definition THnSparse.cxx:789; TIterDefinition TCollection.h:235; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::LastTObject * Last() const overrideReturn the object in the last filled slot. Returns 0 if no entries.Definition TObjArray.cxx:506; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::AddLastvoid AddLast(TObject *obj) overrideAdd object in the next empty slot in the array.Definition TObjArray.cxx:178; TObject::Clearvirtual void Clear(Option_t *="""")Definition TObject.h:119; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; bool; double; int; unsigned int; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; v@ vDefinition rootcling_impl.cxx:3699. histhistsrcTHnSparse.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:50904,Integrability,message,message,50904,"Sumw2void Sumw2() overrideEnable calculation of errors.Definition THnSparse.cxx:948; THnSparse::GetNbinsLong64_t GetNbins() const overrideDefinition THnSparse.h:93; THnSparse::CreateIterROOT::Internal::THnBaseBinIter * CreateIter(Bool_t respectAxisRange) const overrideCreate an iterator over all filled bins of a THnSparse.Definition THnSparse.cxx:896; THnSparse::GetBinIndexForCurrentBinLong64_t GetBinIndexForCurrentBin(Bool_t allocate)Return the index for fCurrentBinIndex.Definition THnSparse.cxx:789; TIterDefinition TCollection.h:235; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::LastTObject * Last() const overrideReturn the object in the last filled slot. Returns 0 if no entries.Definition TObjArray.cxx:506; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::AddLastvoid AddLast(TObject *obj) overrideAdd object in the next empty slot in the array.Definition TObjArray.cxx:178; TObject::Clearvirtual void Clear(Option_t *="""")Definition TObject.h:119; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; bool; double; int; unsigned int; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; v@ vDefinition rootcling_impl.cxx:3699. histhistsrcTHnSparse.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:3857,Security,hash,hashing,3857,"; 82 && !fHist->IsInRange(useCoordBuf); 83 && (fHaveSkippedBin = kTRUE /* assignment! */));; 84 ; 85 if (coord && coord[0] == -1) {; 86 if (fCoord[0] == -1) {; 87 fHist->GetBinContent(fIndex, coord);; 88 } else {; 89 memcpy(coord, fCoord, fHist->GetNdimensions() * sizeof(Int_t));; 90 }; 91 }; 92 ; 93 return fIndex;; 94}; 95 ; 96 ; 97 ; 98/** \class THnSparseCoordCompression; 99THnSparseCoordCompression is a class used by THnSparse internally. It; 100represents a compacted n-dimensional array of bin coordinates (indices).; 101As the total number of bins in each dimension is known by THnSparse, bin; 102indices can be compacted to only use the amount of bins needed by the total; 103number of bins in each dimension. E.g. for a THnSparse with; 104{15, 100, 2, 20, 10, 100} bins per dimension, a bin index will only occupy; 10528 bits (4+7+1+5+4+7), i.e. less than a 32bit integer. The tricky part is; 106the fast compression and decompression, the platform-independent storage; 107(think of endianness: the bits of the number 0x123456 depend on the; 108platform), and the hashing needed by THnSparseArrayChunk.; 109*/; 110 ; 111 ; 112class THnSparseCoordCompression {; 113public:; 114 THnSparseCoordCompression(Int_t dim, const Int_t* nbins);; 115 THnSparseCoordCompression(const THnSparseCoordCompression& other);; 116 ~THnSparseCoordCompression();; 117 ; 118 THnSparseCoordCompression& operator=(const THnSparseCoordCompression& other);; 119 ; 120 ULong64_t GetHashFromBuffer(const Char_t* buf) const;; 121 Int_t GetBufferSize() const { return fCoordBufferSize; }; 122 Int_t GetNdimensions() const { return fNdimensions; }; 123 void SetCoordFromBuffer(const Char_t* buf_in, Int_t* coord_out) const;; 124 ULong64_t SetBufferFromCoord(const Int_t* coord_in, Char_t* buf_out) const;; 125 ; 126protected:; 127 Int_t GetNumBits(Int_t n) const {; 128 // return the number of bits allocated by the number ""n""; 129 Int_t r = (n > 0);; 130 while (n/=2) ++r;; 131 return r;; 132 }; 133private:; 134 Int_",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:8268,Security,hash,hash,8268," buf_in, calculate (""decompact""); 203/// the bin coordinates and return them in coord_out.; 204 ; 205void THnSparseCoordCompression::SetCoordFromBuffer(const Char_t* buf_in,; 206 Int_t* coord_out) const; 207{; 208 for (Int_t i = 0; i < fNdimensions; ++i) {; 209 const Int_t offset = fBitOffsets[i] / 8;; 210 Int_t shift = fBitOffsets[i] % 8;; 211 Int_t nbits = fBitOffsets[i + 1] - fBitOffsets[i];; 212 const UChar_t* pbuf = (const UChar_t*) buf_in + offset;; 213 coord_out[i] = *pbuf >> shift;; 214 Int_t subst = (Int_t) -1;; 215 subst = subst << nbits;; 216 nbits -= (8 - shift);; 217 shift = 8 - shift;; 218 for (Int_t n = 0; n * 8 < nbits; ++n) {; 219 ++pbuf;; 220 coord_out[i] += *pbuf << shift;; 221 shift += 8;; 222 }; 223 coord_out[i] &= ~subst;; 224 }; 225}; 226 ; 227 ; 228////////////////////////////////////////////////////////////////////////////////; 229/// Given the cbin coordinates coord_in, calculate (""compact""); 230/// the bin coordinates and return them in buf_in.; 231/// Return the hash value.; 232 ; 233ULong64_t THnSparseCoordCompression::SetBufferFromCoord(const Int_t* coord_in,; 234 Char_t* buf_out) const; 235{; 236 if (fCoordBufferSize <= 8) {; 237 ULong64_t l64buf = 0;; 238 for (Int_t i = 0; i < fNdimensions; ++i) {; 239 l64buf += ((ULong64_t)((UInt_t)coord_in[i])) << fBitOffsets[i];; 240 }; 241 memcpy(buf_out, &l64buf, sizeof(Long64_t));; 242 return l64buf;; 243 }; 244 ; 245 // else: doesn't fit into a Long64_t:; 246 memset(buf_out, 0, fCoordBufferSize);; 247 for (Int_t i = 0; i < fNdimensions; ++i) {; 248 const Int_t offset = fBitOffsets[i] / 8;; 249 const Int_t shift = fBitOffsets[i] % 8;; 250 ULong64_t val = coord_in[i];; 251 ; 252 Char_t* pbuf = buf_out + offset;; 253 *pbuf += 0xff & (val << shift);; 254 val = val >> (8 - shift);; 255 while (val) {; 256 ++pbuf;; 257 *pbuf += 0xff & val;; 258 val = val >> 8;; 259 }; 260 }; 261 ; 262 return GetHashFromBuffer(buf_out);; 263}; 264 ; 265/*; 266/////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:9302,Security,hash,hash,9302," subst << nbits;; 216 nbits -= (8 - shift);; 217 shift = 8 - shift;; 218 for (Int_t n = 0; n * 8 < nbits; ++n) {; 219 ++pbuf;; 220 coord_out[i] += *pbuf << shift;; 221 shift += 8;; 222 }; 223 coord_out[i] &= ~subst;; 224 }; 225}; 226 ; 227 ; 228////////////////////////////////////////////////////////////////////////////////; 229/// Given the cbin coordinates coord_in, calculate (""compact""); 230/// the bin coordinates and return them in buf_in.; 231/// Return the hash value.; 232 ; 233ULong64_t THnSparseCoordCompression::SetBufferFromCoord(const Int_t* coord_in,; 234 Char_t* buf_out) const; 235{; 236 if (fCoordBufferSize <= 8) {; 237 ULong64_t l64buf = 0;; 238 for (Int_t i = 0; i < fNdimensions; ++i) {; 239 l64buf += ((ULong64_t)((UInt_t)coord_in[i])) << fBitOffsets[i];; 240 }; 241 memcpy(buf_out, &l64buf, sizeof(Long64_t));; 242 return l64buf;; 243 }; 244 ; 245 // else: doesn't fit into a Long64_t:; 246 memset(buf_out, 0, fCoordBufferSize);; 247 for (Int_t i = 0; i < fNdimensions; ++i) {; 248 const Int_t offset = fBitOffsets[i] / 8;; 249 const Int_t shift = fBitOffsets[i] % 8;; 250 ULong64_t val = coord_in[i];; 251 ; 252 Char_t* pbuf = buf_out + offset;; 253 *pbuf += 0xff & (val << shift);; 254 val = val >> (8 - shift);; 255 while (val) {; 256 ++pbuf;; 257 *pbuf += 0xff & val;; 258 val = val >> 8;; 259 }; 260 }; 261 ; 262 return GetHashFromBuffer(buf_out);; 263}; 264 ; 265/*; 266////////////////////////////////////////////////////////////////////////////////; 267/// Calculate hash from bin indexes.; 268 ; 269ULong64_t THnSparseCoordCompression::GetHashFromCoords(const Int_t* coord) const; 270{; 271 // Bins are addressed in two different modes, depending; 272 // on whether the compact bin index fits into a Long64_t or not.; 273 // If it does, we can use it as a ""perfect hash"" for the TExMap.; 274 // If not we build a hash from the compact bin index, and use that; 275 // as the TExMap's hash.; 276 ; 277 if (fCoordBufferSize <= 8) {; 278 // fits into a Long64_t; 279 ULo",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:9601,Security,hash,hash,9601,"; 241 memcpy(buf_out, &l64buf, sizeof(Long64_t));; 242 return l64buf;; 243 }; 244 ; 245 // else: doesn't fit into a Long64_t:; 246 memset(buf_out, 0, fCoordBufferSize);; 247 for (Int_t i = 0; i < fNdimensions; ++i) {; 248 const Int_t offset = fBitOffsets[i] / 8;; 249 const Int_t shift = fBitOffsets[i] % 8;; 250 ULong64_t val = coord_in[i];; 251 ; 252 Char_t* pbuf = buf_out + offset;; 253 *pbuf += 0xff & (val << shift);; 254 val = val >> (8 - shift);; 255 while (val) {; 256 ++pbuf;; 257 *pbuf += 0xff & val;; 258 val = val >> 8;; 259 }; 260 }; 261 ; 262 return GetHashFromBuffer(buf_out);; 263}; 264 ; 265/*; 266////////////////////////////////////////////////////////////////////////////////; 267/// Calculate hash from bin indexes.; 268 ; 269ULong64_t THnSparseCoordCompression::GetHashFromCoords(const Int_t* coord) const; 270{; 271 // Bins are addressed in two different modes, depending; 272 // on whether the compact bin index fits into a Long64_t or not.; 273 // If it does, we can use it as a ""perfect hash"" for the TExMap.; 274 // If not we build a hash from the compact bin index, and use that; 275 // as the TExMap's hash.; 276 ; 277 if (fCoordBufferSize <= 8) {; 278 // fits into a Long64_t; 279 ULong64_t hash1 = 0;; 280 for (Int_t i = 0; i < fNdimensions; ++i) {; 281 hash1 += coord[i] << fBitOffsets[i];; 282 }; 283 return hash1;; 284 }; 285 ; 286 // else: doesn't fit into a Long64_t:; 287 memset(coord, 0, fCoordBufferSize);; 288 for (Int_t i = 0; i < fNdimensions; ++i) {; 289 const Int_t offset = fBitOffsets[i] / 8;; 290 const Int_t shift = fBitOffsets[i] % 8;; 291 ULong64_t val = coord[i];; 292 ; 293 Char_t* pbuf = fCoordBuffer + offset;; 294 *pbuf += 0xff & (val << shift);; 295 val = val >> (8 - shift);; 296 while (val) {; 297 ++pbuf;; 298 *pbuf += 0xff & val;; 299 val = val >> 8;; 300 }; 301 }; 302 ; 303 ULong64_t hash = 5381;; 304 Char_t* str = fCoordBuffer;; 305 while (str - fCoordBuffer < fCoordBufferSize) {; 306 hash *= 5;; 307 hash += *(str++);; 308 }; 309 ret",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:9649,Security,hash,hash,9649,"5 // else: doesn't fit into a Long64_t:; 246 memset(buf_out, 0, fCoordBufferSize);; 247 for (Int_t i = 0; i < fNdimensions; ++i) {; 248 const Int_t offset = fBitOffsets[i] / 8;; 249 const Int_t shift = fBitOffsets[i] % 8;; 250 ULong64_t val = coord_in[i];; 251 ; 252 Char_t* pbuf = buf_out + offset;; 253 *pbuf += 0xff & (val << shift);; 254 val = val >> (8 - shift);; 255 while (val) {; 256 ++pbuf;; 257 *pbuf += 0xff & val;; 258 val = val >> 8;; 259 }; 260 }; 261 ; 262 return GetHashFromBuffer(buf_out);; 263}; 264 ; 265/*; 266////////////////////////////////////////////////////////////////////////////////; 267/// Calculate hash from bin indexes.; 268 ; 269ULong64_t THnSparseCoordCompression::GetHashFromCoords(const Int_t* coord) const; 270{; 271 // Bins are addressed in two different modes, depending; 272 // on whether the compact bin index fits into a Long64_t or not.; 273 // If it does, we can use it as a ""perfect hash"" for the TExMap.; 274 // If not we build a hash from the compact bin index, and use that; 275 // as the TExMap's hash.; 276 ; 277 if (fCoordBufferSize <= 8) {; 278 // fits into a Long64_t; 279 ULong64_t hash1 = 0;; 280 for (Int_t i = 0; i < fNdimensions; ++i) {; 281 hash1 += coord[i] << fBitOffsets[i];; 282 }; 283 return hash1;; 284 }; 285 ; 286 // else: doesn't fit into a Long64_t:; 287 memset(coord, 0, fCoordBufferSize);; 288 for (Int_t i = 0; i < fNdimensions; ++i) {; 289 const Int_t offset = fBitOffsets[i] / 8;; 290 const Int_t shift = fBitOffsets[i] % 8;; 291 ULong64_t val = coord[i];; 292 ; 293 Char_t* pbuf = fCoordBuffer + offset;; 294 *pbuf += 0xff & (val << shift);; 295 val = val >> (8 - shift);; 296 while (val) {; 297 ++pbuf;; 298 *pbuf += 0xff & val;; 299 val = val >> 8;; 300 }; 301 }; 302 ; 303 ULong64_t hash = 5381;; 304 Char_t* str = fCoordBuffer;; 305 while (str - fCoordBuffer < fCoordBufferSize) {; 306 hash *= 5;; 307 hash += *(str++);; 308 }; 309 return hash;; 310}; 311*/; 312 ; 313 ; 314///////////////////////////////////////////////",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:9719,Security,hash,hash,9719,"5 // else: doesn't fit into a Long64_t:; 246 memset(buf_out, 0, fCoordBufferSize);; 247 for (Int_t i = 0; i < fNdimensions; ++i) {; 248 const Int_t offset = fBitOffsets[i] / 8;; 249 const Int_t shift = fBitOffsets[i] % 8;; 250 ULong64_t val = coord_in[i];; 251 ; 252 Char_t* pbuf = buf_out + offset;; 253 *pbuf += 0xff & (val << shift);; 254 val = val >> (8 - shift);; 255 while (val) {; 256 ++pbuf;; 257 *pbuf += 0xff & val;; 258 val = val >> 8;; 259 }; 260 }; 261 ; 262 return GetHashFromBuffer(buf_out);; 263}; 264 ; 265/*; 266////////////////////////////////////////////////////////////////////////////////; 267/// Calculate hash from bin indexes.; 268 ; 269ULong64_t THnSparseCoordCompression::GetHashFromCoords(const Int_t* coord) const; 270{; 271 // Bins are addressed in two different modes, depending; 272 // on whether the compact bin index fits into a Long64_t or not.; 273 // If it does, we can use it as a ""perfect hash"" for the TExMap.; 274 // If not we build a hash from the compact bin index, and use that; 275 // as the TExMap's hash.; 276 ; 277 if (fCoordBufferSize <= 8) {; 278 // fits into a Long64_t; 279 ULong64_t hash1 = 0;; 280 for (Int_t i = 0; i < fNdimensions; ++i) {; 281 hash1 += coord[i] << fBitOffsets[i];; 282 }; 283 return hash1;; 284 }; 285 ; 286 // else: doesn't fit into a Long64_t:; 287 memset(coord, 0, fCoordBufferSize);; 288 for (Int_t i = 0; i < fNdimensions; ++i) {; 289 const Int_t offset = fBitOffsets[i] / 8;; 290 const Int_t shift = fBitOffsets[i] % 8;; 291 ULong64_t val = coord[i];; 292 ; 293 Char_t* pbuf = fCoordBuffer + offset;; 294 *pbuf += 0xff & (val << shift);; 295 val = val >> (8 - shift);; 296 while (val) {; 297 ++pbuf;; 298 *pbuf += 0xff & val;; 299 val = val >> 8;; 300 }; 301 }; 302 ; 303 ULong64_t hash = 5381;; 304 Char_t* str = fCoordBuffer;; 305 while (str - fCoordBuffer < fCoordBufferSize) {; 306 hash *= 5;; 307 hash += *(str++);; 308 }; 309 return hash;; 310}; 311*/; 312 ; 313 ; 314///////////////////////////////////////////////",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:10434,Security,hash,hash,10434,"/////////////////////////////////////////////; 267/// Calculate hash from bin indexes.; 268 ; 269ULong64_t THnSparseCoordCompression::GetHashFromCoords(const Int_t* coord) const; 270{; 271 // Bins are addressed in two different modes, depending; 272 // on whether the compact bin index fits into a Long64_t or not.; 273 // If it does, we can use it as a ""perfect hash"" for the TExMap.; 274 // If not we build a hash from the compact bin index, and use that; 275 // as the TExMap's hash.; 276 ; 277 if (fCoordBufferSize <= 8) {; 278 // fits into a Long64_t; 279 ULong64_t hash1 = 0;; 280 for (Int_t i = 0; i < fNdimensions; ++i) {; 281 hash1 += coord[i] << fBitOffsets[i];; 282 }; 283 return hash1;; 284 }; 285 ; 286 // else: doesn't fit into a Long64_t:; 287 memset(coord, 0, fCoordBufferSize);; 288 for (Int_t i = 0; i < fNdimensions; ++i) {; 289 const Int_t offset = fBitOffsets[i] / 8;; 290 const Int_t shift = fBitOffsets[i] % 8;; 291 ULong64_t val = coord[i];; 292 ; 293 Char_t* pbuf = fCoordBuffer + offset;; 294 *pbuf += 0xff & (val << shift);; 295 val = val >> (8 - shift);; 296 while (val) {; 297 ++pbuf;; 298 *pbuf += 0xff & val;; 299 val = val >> 8;; 300 }; 301 }; 302 ; 303 ULong64_t hash = 5381;; 304 Char_t* str = fCoordBuffer;; 305 while (str - fCoordBuffer < fCoordBufferSize) {; 306 hash *= 5;; 307 hash += *(str++);; 308 }; 309 return hash;; 310}; 311*/; 312 ; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// Calculate hash from compact bin index.; 316 ; 317ULong64_t THnSparseCoordCompression::GetHashFromBuffer(const Char_t* buf) const; 318{; 319 // Bins are addressed in two different modes, depending; 320 // on whether the compact bin index fits into a Long64_t or not.; 321 // If it does, we can use it as a ""perfect hash"" for the TExMap.; 322 // If not we build a hash from the compact bin index, and use that; 323 // as the TExMap's hash.; 324 ; 325 if (fCoordBufferSize <= 8) {; 326 // fits into a Long64_t; 327 ULong64_t ha",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:10538,Security,hash,hash,10538,"/////////////////////////////////////////////; 267/// Calculate hash from bin indexes.; 268 ; 269ULong64_t THnSparseCoordCompression::GetHashFromCoords(const Int_t* coord) const; 270{; 271 // Bins are addressed in two different modes, depending; 272 // on whether the compact bin index fits into a Long64_t or not.; 273 // If it does, we can use it as a ""perfect hash"" for the TExMap.; 274 // If not we build a hash from the compact bin index, and use that; 275 // as the TExMap's hash.; 276 ; 277 if (fCoordBufferSize <= 8) {; 278 // fits into a Long64_t; 279 ULong64_t hash1 = 0;; 280 for (Int_t i = 0; i < fNdimensions; ++i) {; 281 hash1 += coord[i] << fBitOffsets[i];; 282 }; 283 return hash1;; 284 }; 285 ; 286 // else: doesn't fit into a Long64_t:; 287 memset(coord, 0, fCoordBufferSize);; 288 for (Int_t i = 0; i < fNdimensions; ++i) {; 289 const Int_t offset = fBitOffsets[i] / 8;; 290 const Int_t shift = fBitOffsets[i] % 8;; 291 ULong64_t val = coord[i];; 292 ; 293 Char_t* pbuf = fCoordBuffer + offset;; 294 *pbuf += 0xff & (val << shift);; 295 val = val >> (8 - shift);; 296 while (val) {; 297 ++pbuf;; 298 *pbuf += 0xff & val;; 299 val = val >> 8;; 300 }; 301 }; 302 ; 303 ULong64_t hash = 5381;; 304 Char_t* str = fCoordBuffer;; 305 while (str - fCoordBuffer < fCoordBufferSize) {; 306 hash *= 5;; 307 hash += *(str++);; 308 }; 309 return hash;; 310}; 311*/; 312 ; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// Calculate hash from compact bin index.; 316 ; 317ULong64_t THnSparseCoordCompression::GetHashFromBuffer(const Char_t* buf) const; 318{; 319 // Bins are addressed in two different modes, depending; 320 // on whether the compact bin index fits into a Long64_t or not.; 321 // If it does, we can use it as a ""perfect hash"" for the TExMap.; 322 // If not we build a hash from the compact bin index, and use that; 323 // as the TExMap's hash.; 324 ; 325 if (fCoordBufferSize <= 8) {; 326 // fits into a Long64_t; 327 ULong64_t ha",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:10554,Security,hash,hash,10554,"/////////////////////////////////////////////; 267/// Calculate hash from bin indexes.; 268 ; 269ULong64_t THnSparseCoordCompression::GetHashFromCoords(const Int_t* coord) const; 270{; 271 // Bins are addressed in two different modes, depending; 272 // on whether the compact bin index fits into a Long64_t or not.; 273 // If it does, we can use it as a ""perfect hash"" for the TExMap.; 274 // If not we build a hash from the compact bin index, and use that; 275 // as the TExMap's hash.; 276 ; 277 if (fCoordBufferSize <= 8) {; 278 // fits into a Long64_t; 279 ULong64_t hash1 = 0;; 280 for (Int_t i = 0; i < fNdimensions; ++i) {; 281 hash1 += coord[i] << fBitOffsets[i];; 282 }; 283 return hash1;; 284 }; 285 ; 286 // else: doesn't fit into a Long64_t:; 287 memset(coord, 0, fCoordBufferSize);; 288 for (Int_t i = 0; i < fNdimensions; ++i) {; 289 const Int_t offset = fBitOffsets[i] / 8;; 290 const Int_t shift = fBitOffsets[i] % 8;; 291 ULong64_t val = coord[i];; 292 ; 293 Char_t* pbuf = fCoordBuffer + offset;; 294 *pbuf += 0xff & (val << shift);; 295 val = val >> (8 - shift);; 296 while (val) {; 297 ++pbuf;; 298 *pbuf += 0xff & val;; 299 val = val >> 8;; 300 }; 301 }; 302 ; 303 ULong64_t hash = 5381;; 304 Char_t* str = fCoordBuffer;; 305 while (str - fCoordBuffer < fCoordBufferSize) {; 306 hash *= 5;; 307 hash += *(str++);; 308 }; 309 return hash;; 310}; 311*/; 312 ; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// Calculate hash from compact bin index.; 316 ; 317ULong64_t THnSparseCoordCompression::GetHashFromBuffer(const Char_t* buf) const; 318{; 319 // Bins are addressed in two different modes, depending; 320 // on whether the compact bin index fits into a Long64_t or not.; 321 // If it does, we can use it as a ""perfect hash"" for the TExMap.; 322 // If not we build a hash from the compact bin index, and use that; 323 // as the TExMap's hash.; 324 ; 325 if (fCoordBufferSize <= 8) {; 326 // fits into a Long64_t; 327 ULong64_t ha",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:10591,Security,hash,hash,10591,"/////////////////////////////////////////////; 267/// Calculate hash from bin indexes.; 268 ; 269ULong64_t THnSparseCoordCompression::GetHashFromCoords(const Int_t* coord) const; 270{; 271 // Bins are addressed in two different modes, depending; 272 // on whether the compact bin index fits into a Long64_t or not.; 273 // If it does, we can use it as a ""perfect hash"" for the TExMap.; 274 // If not we build a hash from the compact bin index, and use that; 275 // as the TExMap's hash.; 276 ; 277 if (fCoordBufferSize <= 8) {; 278 // fits into a Long64_t; 279 ULong64_t hash1 = 0;; 280 for (Int_t i = 0; i < fNdimensions; ++i) {; 281 hash1 += coord[i] << fBitOffsets[i];; 282 }; 283 return hash1;; 284 }; 285 ; 286 // else: doesn't fit into a Long64_t:; 287 memset(coord, 0, fCoordBufferSize);; 288 for (Int_t i = 0; i < fNdimensions; ++i) {; 289 const Int_t offset = fBitOffsets[i] / 8;; 290 const Int_t shift = fBitOffsets[i] % 8;; 291 ULong64_t val = coord[i];; 292 ; 293 Char_t* pbuf = fCoordBuffer + offset;; 294 *pbuf += 0xff & (val << shift);; 295 val = val >> (8 - shift);; 296 while (val) {; 297 ++pbuf;; 298 *pbuf += 0xff & val;; 299 val = val >> 8;; 300 }; 301 }; 302 ; 303 ULong64_t hash = 5381;; 304 Char_t* str = fCoordBuffer;; 305 while (str - fCoordBuffer < fCoordBufferSize) {; 306 hash *= 5;; 307 hash += *(str++);; 308 }; 309 return hash;; 310}; 311*/; 312 ; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// Calculate hash from compact bin index.; 316 ; 317ULong64_t THnSparseCoordCompression::GetHashFromBuffer(const Char_t* buf) const; 318{; 319 // Bins are addressed in two different modes, depending; 320 // on whether the compact bin index fits into a Long64_t or not.; 321 // If it does, we can use it as a ""perfect hash"" for the TExMap.; 322 // If not we build a hash from the compact bin index, and use that; 323 // as the TExMap's hash.; 324 ; 325 if (fCoordBufferSize <= 8) {; 326 // fits into a Long64_t; 327 ULong64_t ha",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:10725,Security,hash,hash,10725,"/////////////////////////////////////////////; 267/// Calculate hash from bin indexes.; 268 ; 269ULong64_t THnSparseCoordCompression::GetHashFromCoords(const Int_t* coord) const; 270{; 271 // Bins are addressed in two different modes, depending; 272 // on whether the compact bin index fits into a Long64_t or not.; 273 // If it does, we can use it as a ""perfect hash"" for the TExMap.; 274 // If not we build a hash from the compact bin index, and use that; 275 // as the TExMap's hash.; 276 ; 277 if (fCoordBufferSize <= 8) {; 278 // fits into a Long64_t; 279 ULong64_t hash1 = 0;; 280 for (Int_t i = 0; i < fNdimensions; ++i) {; 281 hash1 += coord[i] << fBitOffsets[i];; 282 }; 283 return hash1;; 284 }; 285 ; 286 // else: doesn't fit into a Long64_t:; 287 memset(coord, 0, fCoordBufferSize);; 288 for (Int_t i = 0; i < fNdimensions; ++i) {; 289 const Int_t offset = fBitOffsets[i] / 8;; 290 const Int_t shift = fBitOffsets[i] % 8;; 291 ULong64_t val = coord[i];; 292 ; 293 Char_t* pbuf = fCoordBuffer + offset;; 294 *pbuf += 0xff & (val << shift);; 295 val = val >> (8 - shift);; 296 while (val) {; 297 ++pbuf;; 298 *pbuf += 0xff & val;; 299 val = val >> 8;; 300 }; 301 }; 302 ; 303 ULong64_t hash = 5381;; 304 Char_t* str = fCoordBuffer;; 305 while (str - fCoordBuffer < fCoordBufferSize) {; 306 hash *= 5;; 307 hash += *(str++);; 308 }; 309 return hash;; 310}; 311*/; 312 ; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// Calculate hash from compact bin index.; 316 ; 317ULong64_t THnSparseCoordCompression::GetHashFromBuffer(const Char_t* buf) const; 318{; 319 // Bins are addressed in two different modes, depending; 320 // on whether the compact bin index fits into a Long64_t or not.; 321 // If it does, we can use it as a ""perfect hash"" for the TExMap.; 322 // If not we build a hash from the compact bin index, and use that; 323 // as the TExMap's hash.; 324 ; 325 if (fCoordBufferSize <= 8) {; 326 // fits into a Long64_t; 327 ULong64_t ha",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:11029,Security,hash,hash,11029,"CoordBufferSize);; 288 for (Int_t i = 0; i < fNdimensions; ++i) {; 289 const Int_t offset = fBitOffsets[i] / 8;; 290 const Int_t shift = fBitOffsets[i] % 8;; 291 ULong64_t val = coord[i];; 292 ; 293 Char_t* pbuf = fCoordBuffer + offset;; 294 *pbuf += 0xff & (val << shift);; 295 val = val >> (8 - shift);; 296 while (val) {; 297 ++pbuf;; 298 *pbuf += 0xff & val;; 299 val = val >> 8;; 300 }; 301 }; 302 ; 303 ULong64_t hash = 5381;; 304 Char_t* str = fCoordBuffer;; 305 while (str - fCoordBuffer < fCoordBufferSize) {; 306 hash *= 5;; 307 hash += *(str++);; 308 }; 309 return hash;; 310}; 311*/; 312 ; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// Calculate hash from compact bin index.; 316 ; 317ULong64_t THnSparseCoordCompression::GetHashFromBuffer(const Char_t* buf) const; 318{; 319 // Bins are addressed in two different modes, depending; 320 // on whether the compact bin index fits into a Long64_t or not.; 321 // If it does, we can use it as a ""perfect hash"" for the TExMap.; 322 // If not we build a hash from the compact bin index, and use that; 323 // as the TExMap's hash.; 324 ; 325 if (fCoordBufferSize <= 8) {; 326 // fits into a Long64_t; 327 ULong64_t hash1 = 0;; 328 memcpy(&hash1, buf, fCoordBufferSize);; 329 return hash1;; 330 }; 331 ; 332 // else: doesn't fit into a Long64_t:; 333 ULong64_t hash = 5381;; 334 const Char_t* str = buf;; 335 while (str - buf < fCoordBufferSize) {; 336 hash *= 5;; 337 hash += *(str++);; 338 }; 339 return hash;; 340}; 341 ; 342 ; 343 ; 344 ; 345/** \class THnSparseCompactBinCoord; 346THnSparseCompactBinCoord is a class used by THnSparse internally. It; 347maps between an n-dimensional array of bin coordinates (indices) and; 348its compact version, the THnSparseCoordCompression.; 349*/; 350 ; 351class THnSparseCompactBinCoord: public THnSparseCoordCompression {; 352public:; 353 THnSparseCompactBinCoord(Int_t dim, const Int_t* nbins);; 354 ~THnSparseCompactBinCoord();; 355 Int_t* GetCoo",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:11077,Security,hash,hash,11077,"set = fBitOffsets[i] / 8;; 290 const Int_t shift = fBitOffsets[i] % 8;; 291 ULong64_t val = coord[i];; 292 ; 293 Char_t* pbuf = fCoordBuffer + offset;; 294 *pbuf += 0xff & (val << shift);; 295 val = val >> (8 - shift);; 296 while (val) {; 297 ++pbuf;; 298 *pbuf += 0xff & val;; 299 val = val >> 8;; 300 }; 301 }; 302 ; 303 ULong64_t hash = 5381;; 304 Char_t* str = fCoordBuffer;; 305 while (str - fCoordBuffer < fCoordBufferSize) {; 306 hash *= 5;; 307 hash += *(str++);; 308 }; 309 return hash;; 310}; 311*/; 312 ; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// Calculate hash from compact bin index.; 316 ; 317ULong64_t THnSparseCoordCompression::GetHashFromBuffer(const Char_t* buf) const; 318{; 319 // Bins are addressed in two different modes, depending; 320 // on whether the compact bin index fits into a Long64_t or not.; 321 // If it does, we can use it as a ""perfect hash"" for the TExMap.; 322 // If not we build a hash from the compact bin index, and use that; 323 // as the TExMap's hash.; 324 ; 325 if (fCoordBufferSize <= 8) {; 326 // fits into a Long64_t; 327 ULong64_t hash1 = 0;; 328 memcpy(&hash1, buf, fCoordBufferSize);; 329 return hash1;; 330 }; 331 ; 332 // else: doesn't fit into a Long64_t:; 333 ULong64_t hash = 5381;; 334 const Char_t* str = buf;; 335 while (str - buf < fCoordBufferSize) {; 336 hash *= 5;; 337 hash += *(str++);; 338 }; 339 return hash;; 340}; 341 ; 342 ; 343 ; 344 ; 345/** \class THnSparseCompactBinCoord; 346THnSparseCompactBinCoord is a class used by THnSparse internally. It; 347maps between an n-dimensional array of bin coordinates (indices) and; 348its compact version, the THnSparseCoordCompression.; 349*/; 350 ; 351class THnSparseCompactBinCoord: public THnSparseCoordCompression {; 352public:; 353 THnSparseCompactBinCoord(Int_t dim, const Int_t* nbins);; 354 ~THnSparseCompactBinCoord();; 355 Int_t* GetCoord() { return fCurrentBin; }; 356 const Char_t* GetBuffer() const { return fCoordBuffe",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:11147,Security,hash,hash,11147,"set = fBitOffsets[i] / 8;; 290 const Int_t shift = fBitOffsets[i] % 8;; 291 ULong64_t val = coord[i];; 292 ; 293 Char_t* pbuf = fCoordBuffer + offset;; 294 *pbuf += 0xff & (val << shift);; 295 val = val >> (8 - shift);; 296 while (val) {; 297 ++pbuf;; 298 *pbuf += 0xff & val;; 299 val = val >> 8;; 300 }; 301 }; 302 ; 303 ULong64_t hash = 5381;; 304 Char_t* str = fCoordBuffer;; 305 while (str - fCoordBuffer < fCoordBufferSize) {; 306 hash *= 5;; 307 hash += *(str++);; 308 }; 309 return hash;; 310}; 311*/; 312 ; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// Calculate hash from compact bin index.; 316 ; 317ULong64_t THnSparseCoordCompression::GetHashFromBuffer(const Char_t* buf) const; 318{; 319 // Bins are addressed in two different modes, depending; 320 // on whether the compact bin index fits into a Long64_t or not.; 321 // If it does, we can use it as a ""perfect hash"" for the TExMap.; 322 // If not we build a hash from the compact bin index, and use that; 323 // as the TExMap's hash.; 324 ; 325 if (fCoordBufferSize <= 8) {; 326 // fits into a Long64_t; 327 ULong64_t hash1 = 0;; 328 memcpy(&hash1, buf, fCoordBufferSize);; 329 return hash1;; 330 }; 331 ; 332 // else: doesn't fit into a Long64_t:; 333 ULong64_t hash = 5381;; 334 const Char_t* str = buf;; 335 while (str - buf < fCoordBufferSize) {; 336 hash *= 5;; 337 hash += *(str++);; 338 }; 339 return hash;; 340}; 341 ; 342 ; 343 ; 344 ; 345/** \class THnSparseCompactBinCoord; 346THnSparseCompactBinCoord is a class used by THnSparse internally. It; 347maps between an n-dimensional array of bin coordinates (indices) and; 348its compact version, the THnSparseCoordCompression.; 349*/; 350 ; 351class THnSparseCompactBinCoord: public THnSparseCoordCompression {; 352public:; 353 THnSparseCompactBinCoord(Int_t dim, const Int_t* nbins);; 354 ~THnSparseCompactBinCoord();; 355 Int_t* GetCoord() { return fCurrentBin; }; 356 const Char_t* GetBuffer() const { return fCoordBuffe",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:11382,Security,hash,hash,11382,"; 302 ; 303 ULong64_t hash = 5381;; 304 Char_t* str = fCoordBuffer;; 305 while (str - fCoordBuffer < fCoordBufferSize) {; 306 hash *= 5;; 307 hash += *(str++);; 308 }; 309 return hash;; 310}; 311*/; 312 ; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// Calculate hash from compact bin index.; 316 ; 317ULong64_t THnSparseCoordCompression::GetHashFromBuffer(const Char_t* buf) const; 318{; 319 // Bins are addressed in two different modes, depending; 320 // on whether the compact bin index fits into a Long64_t or not.; 321 // If it does, we can use it as a ""perfect hash"" for the TExMap.; 322 // If not we build a hash from the compact bin index, and use that; 323 // as the TExMap's hash.; 324 ; 325 if (fCoordBufferSize <= 8) {; 326 // fits into a Long64_t; 327 ULong64_t hash1 = 0;; 328 memcpy(&hash1, buf, fCoordBufferSize);; 329 return hash1;; 330 }; 331 ; 332 // else: doesn't fit into a Long64_t:; 333 ULong64_t hash = 5381;; 334 const Char_t* str = buf;; 335 while (str - buf < fCoordBufferSize) {; 336 hash *= 5;; 337 hash += *(str++);; 338 }; 339 return hash;; 340}; 341 ; 342 ; 343 ; 344 ; 345/** \class THnSparseCompactBinCoord; 346THnSparseCompactBinCoord is a class used by THnSparse internally. It; 347maps between an n-dimensional array of bin coordinates (indices) and; 348its compact version, the THnSparseCoordCompression.; 349*/; 350 ; 351class THnSparseCompactBinCoord: public THnSparseCoordCompression {; 352public:; 353 THnSparseCompactBinCoord(Int_t dim, const Int_t* nbins);; 354 ~THnSparseCompactBinCoord();; 355 Int_t* GetCoord() { return fCurrentBin; }; 356 const Char_t* GetBuffer() const { return fCoordBuffer; }; 357 ULong64_t GetHash() const { return fHash; }; 358 void UpdateCoord() {; 359 fHash = SetBufferFromCoord(fCurrentBin, fCoordBuffer);; 360 }; 361 void SetCoord(const Int_t* coord) {; 362 memcpy(fCurrentBin, coord, sizeof(Int_t) * GetNdimensions());; 363 fHash = SetBufferFromCoord(coord, fCoordBuffer);; 3",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:11474,Security,hash,hash,11474,"; 302 ; 303 ULong64_t hash = 5381;; 304 Char_t* str = fCoordBuffer;; 305 while (str - fCoordBuffer < fCoordBufferSize) {; 306 hash *= 5;; 307 hash += *(str++);; 308 }; 309 return hash;; 310}; 311*/; 312 ; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// Calculate hash from compact bin index.; 316 ; 317ULong64_t THnSparseCoordCompression::GetHashFromBuffer(const Char_t* buf) const; 318{; 319 // Bins are addressed in two different modes, depending; 320 // on whether the compact bin index fits into a Long64_t or not.; 321 // If it does, we can use it as a ""perfect hash"" for the TExMap.; 322 // If not we build a hash from the compact bin index, and use that; 323 // as the TExMap's hash.; 324 ; 325 if (fCoordBufferSize <= 8) {; 326 // fits into a Long64_t; 327 ULong64_t hash1 = 0;; 328 memcpy(&hash1, buf, fCoordBufferSize);; 329 return hash1;; 330 }; 331 ; 332 // else: doesn't fit into a Long64_t:; 333 ULong64_t hash = 5381;; 334 const Char_t* str = buf;; 335 while (str - buf < fCoordBufferSize) {; 336 hash *= 5;; 337 hash += *(str++);; 338 }; 339 return hash;; 340}; 341 ; 342 ; 343 ; 344 ; 345/** \class THnSparseCompactBinCoord; 346THnSparseCompactBinCoord is a class used by THnSparse internally. It; 347maps between an n-dimensional array of bin coordinates (indices) and; 348its compact version, the THnSparseCoordCompression.; 349*/; 350 ; 351class THnSparseCompactBinCoord: public THnSparseCoordCompression {; 352public:; 353 THnSparseCompactBinCoord(Int_t dim, const Int_t* nbins);; 354 ~THnSparseCompactBinCoord();; 355 Int_t* GetCoord() { return fCurrentBin; }; 356 const Char_t* GetBuffer() const { return fCoordBuffer; }; 357 ULong64_t GetHash() const { return fHash; }; 358 void UpdateCoord() {; 359 fHash = SetBufferFromCoord(fCurrentBin, fCoordBuffer);; 360 }; 361 void SetCoord(const Int_t* coord) {; 362 memcpy(fCurrentBin, coord, sizeof(Int_t) * GetNdimensions());; 363 fHash = SetBufferFromCoord(coord, fCoordBuffer);; 3",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:11490,Security,hash,hash,11490,"; 302 ; 303 ULong64_t hash = 5381;; 304 Char_t* str = fCoordBuffer;; 305 while (str - fCoordBuffer < fCoordBufferSize) {; 306 hash *= 5;; 307 hash += *(str++);; 308 }; 309 return hash;; 310}; 311*/; 312 ; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// Calculate hash from compact bin index.; 316 ; 317ULong64_t THnSparseCoordCompression::GetHashFromBuffer(const Char_t* buf) const; 318{; 319 // Bins are addressed in two different modes, depending; 320 // on whether the compact bin index fits into a Long64_t or not.; 321 // If it does, we can use it as a ""perfect hash"" for the TExMap.; 322 // If not we build a hash from the compact bin index, and use that; 323 // as the TExMap's hash.; 324 ; 325 if (fCoordBufferSize <= 8) {; 326 // fits into a Long64_t; 327 ULong64_t hash1 = 0;; 328 memcpy(&hash1, buf, fCoordBufferSize);; 329 return hash1;; 330 }; 331 ; 332 // else: doesn't fit into a Long64_t:; 333 ULong64_t hash = 5381;; 334 const Char_t* str = buf;; 335 while (str - buf < fCoordBufferSize) {; 336 hash *= 5;; 337 hash += *(str++);; 338 }; 339 return hash;; 340}; 341 ; 342 ; 343 ; 344 ; 345/** \class THnSparseCompactBinCoord; 346THnSparseCompactBinCoord is a class used by THnSparse internally. It; 347maps between an n-dimensional array of bin coordinates (indices) and; 348its compact version, the THnSparseCoordCompression.; 349*/; 350 ; 351class THnSparseCompactBinCoord: public THnSparseCoordCompression {; 352public:; 353 THnSparseCompactBinCoord(Int_t dim, const Int_t* nbins);; 354 ~THnSparseCompactBinCoord();; 355 Int_t* GetCoord() { return fCurrentBin; }; 356 const Char_t* GetBuffer() const { return fCoordBuffer; }; 357 ULong64_t GetHash() const { return fHash; }; 358 void UpdateCoord() {; 359 fHash = SetBufferFromCoord(fCurrentBin, fCoordBuffer);; 360 }; 361 void SetCoord(const Int_t* coord) {; 362 memcpy(fCurrentBin, coord, sizeof(Int_t) * GetNdimensions());; 363 fHash = SetBufferFromCoord(coord, fCoordBuffer);; 3",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:11527,Security,hash,hash,11527,"; 302 ; 303 ULong64_t hash = 5381;; 304 Char_t* str = fCoordBuffer;; 305 while (str - fCoordBuffer < fCoordBufferSize) {; 306 hash *= 5;; 307 hash += *(str++);; 308 }; 309 return hash;; 310}; 311*/; 312 ; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// Calculate hash from compact bin index.; 316 ; 317ULong64_t THnSparseCoordCompression::GetHashFromBuffer(const Char_t* buf) const; 318{; 319 // Bins are addressed in two different modes, depending; 320 // on whether the compact bin index fits into a Long64_t or not.; 321 // If it does, we can use it as a ""perfect hash"" for the TExMap.; 322 // If not we build a hash from the compact bin index, and use that; 323 // as the TExMap's hash.; 324 ; 325 if (fCoordBufferSize <= 8) {; 326 // fits into a Long64_t; 327 ULong64_t hash1 = 0;; 328 memcpy(&hash1, buf, fCoordBufferSize);; 329 return hash1;; 330 }; 331 ; 332 // else: doesn't fit into a Long64_t:; 333 ULong64_t hash = 5381;; 334 const Char_t* str = buf;; 335 while (str - buf < fCoordBufferSize) {; 336 hash *= 5;; 337 hash += *(str++);; 338 }; 339 return hash;; 340}; 341 ; 342 ; 343 ; 344 ; 345/** \class THnSparseCompactBinCoord; 346THnSparseCompactBinCoord is a class used by THnSparse internally. It; 347maps between an n-dimensional array of bin coordinates (indices) and; 348its compact version, the THnSparseCoordCompression.; 349*/; 350 ; 351class THnSparseCompactBinCoord: public THnSparseCoordCompression {; 352public:; 353 THnSparseCompactBinCoord(Int_t dim, const Int_t* nbins);; 354 ~THnSparseCompactBinCoord();; 355 Int_t* GetCoord() { return fCurrentBin; }; 356 const Char_t* GetBuffer() const { return fCoordBuffer; }; 357 ULong64_t GetHash() const { return fHash; }; 358 void UpdateCoord() {; 359 fHash = SetBufferFromCoord(fCurrentBin, fCoordBuffer);; 360 }; 361 void SetCoord(const Int_t* coord) {; 362 memcpy(fCurrentBin, coord, sizeof(Int_t) * GetNdimensions());; 363 fHash = SetBufferFromCoord(coord, fCoordBuffer);; 3",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:12856,Security,hash,hash,12856,"tBinCoord is a class used by THnSparse internally. It; 347maps between an n-dimensional array of bin coordinates (indices) and; 348its compact version, the THnSparseCoordCompression.; 349*/; 350 ; 351class THnSparseCompactBinCoord: public THnSparseCoordCompression {; 352public:; 353 THnSparseCompactBinCoord(Int_t dim, const Int_t* nbins);; 354 ~THnSparseCompactBinCoord();; 355 Int_t* GetCoord() { return fCurrentBin; }; 356 const Char_t* GetBuffer() const { return fCoordBuffer; }; 357 ULong64_t GetHash() const { return fHash; }; 358 void UpdateCoord() {; 359 fHash = SetBufferFromCoord(fCurrentBin, fCoordBuffer);; 360 }; 361 void SetCoord(const Int_t* coord) {; 362 memcpy(fCurrentBin, coord, sizeof(Int_t) * GetNdimensions());; 363 fHash = SetBufferFromCoord(coord, fCoordBuffer);; 364 }; 365 void SetBuffer(const Char_t* buf) {; 366 memcpy(fCoordBuffer, buf, GetBufferSize());; 367 fHash = GetHashFromBuffer(fCoordBuffer);; 368 }; 369 ; 370private:; 371 // intentionally not implemented; 372 THnSparseCompactBinCoord(const THnSparseCompactBinCoord&) = delete;; 373 // intentionally not implemented; 374 THnSparseCompactBinCoord& operator=(const THnSparseCompactBinCoord&) = delete;; 375 ; 376private:; 377 ULong64_t fHash; // hash for current coordinates; 0 if not calculated; 378 Char_t *fCoordBuffer; // compact buffer of coordinates; 379 Int_t *fCurrentBin; // current coordinates; 380};; 381 ; 382 ; 383//______________________________________________________________________________; 384//______________________________________________________________________________; 385 ; 386 ; 387////////////////////////////////////////////////////////////////////////////////; 388/// Initialize a THnSparseCompactBinCoord object with ""dim"" dimensions; 389/// and ""bins"" holding the number of bins for each dimension.; 390 ; 391THnSparseCompactBinCoord::THnSparseCompactBinCoord(Int_t dim, const Int_t* nbins):; 392 THnSparseCoordCompression(dim, nbins),; 393 fHash(0), fCoordBuffer(nullptr), fCurre",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:17845,Security,access,access,17845,"mcpy(fCoordinates + idx * fSingleCoordinateSize, coordbuf, fSingleCoordinateSize);; 474 fCoordinatesSize += fSingleCoordinateSize;; 475}; 476 ; 477////////////////////////////////////////////////////////////////////////////////; 478/// Turn on support of errors; 479 ; 480void THnSparseArrayChunk::Sumw2(); 481{; 482 if (!fSumw2); 483 fSumw2 = new TArrayD(fContent->GetSize());; 484 // fill the structure with the current content; 485 for (Int_t bin=0; bin < fContent->GetSize(); bin++) {; 486 fSumw2->fArray[bin] = fContent->GetAt(bin);; 487 }; 488 ; 489}; 490 ; 491 ; 492/** \class THnSparse; 493 \ingroup Hist; 494 ; 495Efficient multidimensional histogram.; 496 ; 497Use a THnSparse instead of TH1 / TH2 / TH3 / array for histogramming when; 498only a small fraction of bins is filled. A 10-dimensional histogram with 10; 499bins per dimension has 10^10 bins; in a naive implementation this will not; 500fit in memory. THnSparse only allocates memory for the bins that have; 501non-zero bin content instead, drastically reducing both the memory usage; 502and the access time.; 503 ; 504To construct a THnSparse object you must use one of its templated, derived; 505classes:; 506- THnSparseD (typedef for THnSparseT<ArrayD>): bin content held by a Double_t,; 507- THnSparseF (typedef for THnSparseT<ArrayF>): bin content held by a Float_t,; 508- THnSparseL (typedef for THnSparseT<ArrayL64>): bin content held by a Long64_t,; 509- THnSparseI (typedef for THnSparseT<ArrayI>): bin content held by an Int_t,; 510- THnSparseS (typedef for THnSparseT<ArrayS>): bin content held by a Short_t,; 511- THnSparseC (typedef for THnSparseT<ArrayC>): bin content held by a Char_t,; 512 ; 513They take name and title, the number of dimensions, and for each dimension; 514the number of bins, the minimal, and the maximal value on the dimension's; 515axis. A TH2 h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; 516 ; 517 Int_t bins[2] = {10, 20};; 518 Double_t xmin[2] = {0., -5.};; 519 Double_t xmax[2] ",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:21439,Security,hash,hash,21439,"3, or; 554a THnSparse. See the Projection() members. To only project parts of the; 555histogram, call; 556 ; 557 THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);; 558 ; 559## Internal Representation; 560An entry for a filled bin consists of its n-dimensional coordinates and; 561its bin content. The coordinates are compacted to use as few bits as; 562possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; 563use 4 bits for the x representation and 5 bits for the y representation.; 564This is handled by the internal class THnSparseCompactBinCoord.; 565Bin data (content and coordinates) are allocated in chunks of size; 566fChunkSize; this parameter can be set when constructing a THnSparse. Each; 567chunk is represented by an object of class THnSparseArrayChunk.; 568 ; 569Translation from an n-dimensional bin coordinate to the linear index within; 570the chunks is done by GetBin(). It creates a hash from the compacted bin; 571coordinates (the hash of a bin coordinate is the compacted coordinate itself; 572if it takes less than 8 bytes, the size of a Long64_t.; 573This hash is used to lookup the linear index in the TExMap member fBins;; 574the coordinates of the entry fBins points to is compared to the coordinates; 575passed to GetBin(). If they do not match, these two coordinates have the same; 576hash - which is extremely unlikely but (for the case where the compact bin; 577coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; 578contains a chain of linear indexes with the same hash. Iterating through this; 579chain and comparing each bin coordinates with the one passed to GetBin() will; 580retrieve the matching bin.; 581*/; 582 ; 583 ; 584ClassImp(THnSparse);; 585 ; 586////////////////////////////////////////////////////////////////////////////////; 587/// Construct an empty THnSparse.; 588 ; 589THnSparse::THnSparse():; 590 fChunkSize(1024), fFilledBins(0), fCompactCoord(nullptr); 591{; 592 fBinContent.SetOwner();; 593}; 594 ;",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:21488,Security,hash,hash,21488,"3, or; 554a THnSparse. See the Projection() members. To only project parts of the; 555histogram, call; 556 ; 557 THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);; 558 ; 559## Internal Representation; 560An entry for a filled bin consists of its n-dimensional coordinates and; 561its bin content. The coordinates are compacted to use as few bits as; 562possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; 563use 4 bits for the x representation and 5 bits for the y representation.; 564This is handled by the internal class THnSparseCompactBinCoord.; 565Bin data (content and coordinates) are allocated in chunks of size; 566fChunkSize; this parameter can be set when constructing a THnSparse. Each; 567chunk is represented by an object of class THnSparseArrayChunk.; 568 ; 569Translation from an n-dimensional bin coordinate to the linear index within; 570the chunks is done by GetBin(). It creates a hash from the compacted bin; 571coordinates (the hash of a bin coordinate is the compacted coordinate itself; 572if it takes less than 8 bytes, the size of a Long64_t.; 573This hash is used to lookup the linear index in the TExMap member fBins;; 574the coordinates of the entry fBins points to is compared to the coordinates; 575passed to GetBin(). If they do not match, these two coordinates have the same; 576hash - which is extremely unlikely but (for the case where the compact bin; 577coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; 578contains a chain of linear indexes with the same hash. Iterating through this; 579chain and comparing each bin coordinates with the one passed to GetBin() will; 580retrieve the matching bin.; 581*/; 582 ; 583 ; 584ClassImp(THnSparse);; 585 ; 586////////////////////////////////////////////////////////////////////////////////; 587/// Construct an empty THnSparse.; 588 ; 589THnSparse::THnSparse():; 590 fChunkSize(1024), fFilledBins(0), fCompactCoord(nullptr); 591{; 592 fBinContent.SetOwner();; 593}; 594 ;",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:21616,Security,hash,hash,21616,"ernal Representation; 560An entry for a filled bin consists of its n-dimensional coordinates and; 561its bin content. The coordinates are compacted to use as few bits as; 562possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; 563use 4 bits for the x representation and 5 bits for the y representation.; 564This is handled by the internal class THnSparseCompactBinCoord.; 565Bin data (content and coordinates) are allocated in chunks of size; 566fChunkSize; this parameter can be set when constructing a THnSparse. Each; 567chunk is represented by an object of class THnSparseArrayChunk.; 568 ; 569Translation from an n-dimensional bin coordinate to the linear index within; 570the chunks is done by GetBin(). It creates a hash from the compacted bin; 571coordinates (the hash of a bin coordinate is the compacted coordinate itself; 572if it takes less than 8 bytes, the size of a Long64_t.; 573This hash is used to lookup the linear index in the TExMap member fBins;; 574the coordinates of the entry fBins points to is compared to the coordinates; 575passed to GetBin(). If they do not match, these two coordinates have the same; 576hash - which is extremely unlikely but (for the case where the compact bin; 577coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; 578contains a chain of linear indexes with the same hash. Iterating through this; 579chain and comparing each bin coordinates with the one passed to GetBin() will; 580retrieve the matching bin.; 581*/; 582 ; 583 ; 584ClassImp(THnSparse);; 585 ; 586////////////////////////////////////////////////////////////////////////////////; 587/// Construct an empty THnSparse.; 588 ; 589THnSparse::THnSparse():; 590 fChunkSize(1024), fFilledBins(0), fCompactCoord(nullptr); 591{; 592 fBinContent.SetOwner();; 593}; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Construct a THnSparse with ""dim"" dimensions,; 597/// with chunksize as the size of the c",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:22058,Security,hash,hash,22058," 564This is handled by the internal class THnSparseCompactBinCoord.; 565Bin data (content and coordinates) are allocated in chunks of size; 566fChunkSize; this parameter can be set when constructing a THnSparse. Each; 567chunk is represented by an object of class THnSparseArrayChunk.; 568 ; 569Translation from an n-dimensional bin coordinate to the linear index within; 570the chunks is done by GetBin(). It creates a hash from the compacted bin; 571coordinates (the hash of a bin coordinate is the compacted coordinate itself; 572if it takes less than 8 bytes, the size of a Long64_t.; 573This hash is used to lookup the linear index in the TExMap member fBins;; 574the coordinates of the entry fBins points to is compared to the coordinates; 575passed to GetBin(). If they do not match, these two coordinates have the same; 576hash - which is extremely unlikely but (for the case where the compact bin; 577coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; 578contains a chain of linear indexes with the same hash. Iterating through this; 579chain and comparing each bin coordinates with the one passed to GetBin() will; 580retrieve the matching bin.; 581*/; 582 ; 583 ; 584ClassImp(THnSparse);; 585 ; 586////////////////////////////////////////////////////////////////////////////////; 587/// Construct an empty THnSparse.; 588 ; 589THnSparse::THnSparse():; 590 fChunkSize(1024), fFilledBins(0), fCompactCoord(nullptr); 591{; 592 fBinContent.SetOwner();; 593}; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Construct a THnSparse with ""dim"" dimensions,; 597/// with chunksize as the size of the chunks.; 598/// ""nbins"" holds the number of bins for each dimension;; 599/// ""xmin"" and ""xmax"" the minimal and maximal value for each dimension.; 600/// The arrays ""xmin"" and ""xmax"" can be NULL; in that case SetBinEdges(); 601/// must be called for each dimension.; 602 ; 603THnSparse::THnSparse(const char* name, const cha",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:25437,Security,hash,hash,25437,"eArray());; 639 fBinContent.AddLast(chunk);; 640 return chunk;; 641}; 642 ; 643////////////////////////////////////////////////////////////////////////////////; 644/// Initialize the storage of a histogram created via Init(); 645 ; 646void THnSparse::InitStorage(Int_t* nbins, Int_t chunkSize); 647{; 648 fChunkSize = chunkSize;; 649 fCompactCoord = new THnSparseCompactBinCoord(fNdimensions, nbins);; 650}; 651 ; 652////////////////////////////////////////////////////////////////////////////////; 653///We have been streamed; set up fBins; 654 ; 655void THnSparse::FillExMap(); 656{; 657 TIter iChunk(&fBinContent);; 658 THnSparseArrayChunk* chunk = nullptr;; 659 THnSparseCoordCompression compactCoord(*GetCompactCoord());; 660 Long64_t idx = 0;; 661 if (2 * GetNbins() > fBins.Capacity()); 662 fBins.Expand(3 * GetNbins());; 663 while ((chunk = (THnSparseArrayChunk*) iChunk())) {; 664 const Int_t chunkSize = chunk->GetEntries();; 665 Char_t* buf = chunk->fCoordinates;; 666 const Int_t singleCoordSize = chunk->fSingleCoordinateSize;; 667 const Char_t* endbuf = buf + singleCoordSize * chunkSize;; 668 for (; buf < endbuf; buf += singleCoordSize, ++idx) {; 669 Long64_t hash = compactCoord.GetHashFromBuffer(buf);; 670 Long64_t linidx = fBins.GetValue(hash);; 671 if (linidx) {; 672 Long64_t nextidx = linidx;; 673 while (nextidx) {; 674 // must be a collision, so go to fBinsContinued.; 675 linidx = nextidx;; 676 nextidx = fBinsContinued.GetValue(linidx);; 677 }; 678 fBinsContinued.Add(linidx, idx + 1);; 679 } else {; 680 fBins.Add(hash, idx + 1);; 681 }; 682 }; 683 }; 684}; 685 ; 686////////////////////////////////////////////////////////////////////////////////; 687/// Initialize storage for nbins; 688 ; 689void THnSparse::Reserve(Long64_t nbins) {; 690 if (!fBins.GetSize() && fBinContent.GetSize()) {; 691 FillExMap();; 692 }; 693 if (2 * nbins > fBins.Capacity()) {; 694 fBins.Expand(3 * nbins);; 695 }; 696}; 697 ; 698//////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:25519,Security,hash,hash,25519,"unkSize;; 649 fCompactCoord = new THnSparseCompactBinCoord(fNdimensions, nbins);; 650}; 651 ; 652////////////////////////////////////////////////////////////////////////////////; 653///We have been streamed; set up fBins; 654 ; 655void THnSparse::FillExMap(); 656{; 657 TIter iChunk(&fBinContent);; 658 THnSparseArrayChunk* chunk = nullptr;; 659 THnSparseCoordCompression compactCoord(*GetCompactCoord());; 660 Long64_t idx = 0;; 661 if (2 * GetNbins() > fBins.Capacity()); 662 fBins.Expand(3 * GetNbins());; 663 while ((chunk = (THnSparseArrayChunk*) iChunk())) {; 664 const Int_t chunkSize = chunk->GetEntries();; 665 Char_t* buf = chunk->fCoordinates;; 666 const Int_t singleCoordSize = chunk->fSingleCoordinateSize;; 667 const Char_t* endbuf = buf + singleCoordSize * chunkSize;; 668 for (; buf < endbuf; buf += singleCoordSize, ++idx) {; 669 Long64_t hash = compactCoord.GetHashFromBuffer(buf);; 670 Long64_t linidx = fBins.GetValue(hash);; 671 if (linidx) {; 672 Long64_t nextidx = linidx;; 673 while (nextidx) {; 674 // must be a collision, so go to fBinsContinued.; 675 linidx = nextidx;; 676 nextidx = fBinsContinued.GetValue(linidx);; 677 }; 678 fBinsContinued.Add(linidx, idx + 1);; 679 } else {; 680 fBins.Add(hash, idx + 1);; 681 }; 682 }; 683 }; 684}; 685 ; 686////////////////////////////////////////////////////////////////////////////////; 687/// Initialize storage for nbins; 688 ; 689void THnSparse::Reserve(Long64_t nbins) {; 690 if (!fBins.GetSize() && fBinContent.GetSize()) {; 691 FillExMap();; 692 }; 693 if (2 * nbins > fBins.Capacity()) {; 694 fBins.Expand(3 * nbins);; 695 }; 696}; 697 ; 698////////////////////////////////////////////////////////////////////////////////; 699/// Get the bin index for the n dimensional tuple x,; 700/// allocate one if it doesn't exist yet and ""allocate"" is true.; 701 ; 702Long64_t THnSparse::GetBin(const Double_t* x, Bool_t allocate /* = kTRUE */); 703{; 704 THnSparseCompactBinCoord* cc = GetCompactCoord();; 705 Int_t *coord = cc->GetC",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:25803,Security,hash,hash,25803,";; 659 THnSparseCoordCompression compactCoord(*GetCompactCoord());; 660 Long64_t idx = 0;; 661 if (2 * GetNbins() > fBins.Capacity()); 662 fBins.Expand(3 * GetNbins());; 663 while ((chunk = (THnSparseArrayChunk*) iChunk())) {; 664 const Int_t chunkSize = chunk->GetEntries();; 665 Char_t* buf = chunk->fCoordinates;; 666 const Int_t singleCoordSize = chunk->fSingleCoordinateSize;; 667 const Char_t* endbuf = buf + singleCoordSize * chunkSize;; 668 for (; buf < endbuf; buf += singleCoordSize, ++idx) {; 669 Long64_t hash = compactCoord.GetHashFromBuffer(buf);; 670 Long64_t linidx = fBins.GetValue(hash);; 671 if (linidx) {; 672 Long64_t nextidx = linidx;; 673 while (nextidx) {; 674 // must be a collision, so go to fBinsContinued.; 675 linidx = nextidx;; 676 nextidx = fBinsContinued.GetValue(linidx);; 677 }; 678 fBinsContinued.Add(linidx, idx + 1);; 679 } else {; 680 fBins.Add(hash, idx + 1);; 681 }; 682 }; 683 }; 684}; 685 ; 686////////////////////////////////////////////////////////////////////////////////; 687/// Initialize storage for nbins; 688 ; 689void THnSparse::Reserve(Long64_t nbins) {; 690 if (!fBins.GetSize() && fBinContent.GetSize()) {; 691 FillExMap();; 692 }; 693 if (2 * nbins > fBins.Capacity()) {; 694 fBins.Expand(3 * nbins);; 695 }; 696}; 697 ; 698////////////////////////////////////////////////////////////////////////////////; 699/// Get the bin index for the n dimensional tuple x,; 700/// allocate one if it doesn't exist yet and ""allocate"" is true.; 701 ; 702Long64_t THnSparse::GetBin(const Double_t* x, Bool_t allocate /* = kTRUE */); 703{; 704 THnSparseCompactBinCoord* cc = GetCompactCoord();; 705 Int_t *coord = cc->GetCoord();; 706 for (Int_t i = 0; i < fNdimensions; ++i); 707 coord[i] = GetAxis(i)->FindBin(x[i]);; 708 cc->UpdateCoord();; 709 ; 710 return GetBinIndexForCurrentBin(allocate);; 711}; 712 ; 713 ; 714////////////////////////////////////////////////////////////////////////////////; 715/// Get the bin index for the n dimensional tuple address",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:29708,Security,hash,hash,29708,"zeof(Int_t) * fNdimensions);; 762 return 0.;; 763}; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Get square of the error of bin addressed by linidx as; 767/// \f$\sum weight^{2}\f$; 768/// If errors are not enabled (via Sumw2() or CalculateErrors()); 769/// return contents.; 770 ; 771Double_t THnSparse::GetBinError2(Long64_t linidx) const {; 772 if (!GetCalculateErrors()); 773 return GetBinContent(linidx);; 774 ; 775 if (linidx < 0) return 0.;; 776 THnSparseArrayChunk* chunk = GetChunk(linidx / fChunkSize);; 777 linidx %= fChunkSize;; 778 if (!chunk || chunk->fContent->GetSize() < linidx); 779 return 0.;; 780 ; 781 return chunk->fSumw2->GetAt(linidx);; 782}; 783 ; 784 ; 785////////////////////////////////////////////////////////////////////////////////; 786/// Return the index for fCurrentBinIndex.; 787/// If it doesn't exist then return -1, or allocate a new bin if allocate is set; 788 ; 789Long64_t THnSparse::GetBinIndexForCurrentBin(Bool_t allocate); 790{; 791 THnSparseCompactBinCoord* cc = GetCompactCoord();; 792 ULong64_t hash = cc->GetHash();; 793 if (fBinContent.GetSize() && !fBins.GetSize()); 794 FillExMap();; 795 Long64_t linidx = (Long64_t) fBins.GetValue(hash);; 796 while (linidx) {; 797 // fBins stores index + 1!; 798 THnSparseArrayChunk* chunk = GetChunk((linidx - 1)/ fChunkSize);; 799 if (chunk->Matches((linidx - 1) % fChunkSize, cc->GetBuffer())); 800 return linidx - 1; // we store idx+1, 0 is ""TExMap: not found""; 801 ; 802 Long64_t nextlinidx = fBinsContinued.GetValue(linidx);; 803 if (!nextlinidx) break;; 804 ; 805 linidx = nextlinidx;; 806 }; 807 if (!allocate) return -1;; 808 ; 809 ++fFilledBins;; 810 ; 811 // allocate bin in chunk; 812 THnSparseArrayChunk *chunk = (THnSparseArrayChunk*) fBinContent.Last();; 813 Long64_t newidx = chunk ? ((Long64_t) chunk->GetEntries()) : -1;; 814 if (!chunk || newidx == (Long64_t)fChunkSize) {; 815 chunk = AddChunk();; 816 newidx = 0;; 817 }; 818 chunk->AddBin(n",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:29849,Security,hash,hash,29849,"nst {; 772 if (!GetCalculateErrors()); 773 return GetBinContent(linidx);; 774 ; 775 if (linidx < 0) return 0.;; 776 THnSparseArrayChunk* chunk = GetChunk(linidx / fChunkSize);; 777 linidx %= fChunkSize;; 778 if (!chunk || chunk->fContent->GetSize() < linidx); 779 return 0.;; 780 ; 781 return chunk->fSumw2->GetAt(linidx);; 782}; 783 ; 784 ; 785////////////////////////////////////////////////////////////////////////////////; 786/// Return the index for fCurrentBinIndex.; 787/// If it doesn't exist then return -1, or allocate a new bin if allocate is set; 788 ; 789Long64_t THnSparse::GetBinIndexForCurrentBin(Bool_t allocate); 790{; 791 THnSparseCompactBinCoord* cc = GetCompactCoord();; 792 ULong64_t hash = cc->GetHash();; 793 if (fBinContent.GetSize() && !fBins.GetSize()); 794 FillExMap();; 795 Long64_t linidx = (Long64_t) fBins.GetValue(hash);; 796 while (linidx) {; 797 // fBins stores index + 1!; 798 THnSparseArrayChunk* chunk = GetChunk((linidx - 1)/ fChunkSize);; 799 if (chunk->Matches((linidx - 1) % fChunkSize, cc->GetBuffer())); 800 return linidx - 1; // we store idx+1, 0 is ""TExMap: not found""; 801 ; 802 Long64_t nextlinidx = fBinsContinued.GetValue(linidx);; 803 if (!nextlinidx) break;; 804 ; 805 linidx = nextlinidx;; 806 }; 807 if (!allocate) return -1;; 808 ; 809 ++fFilledBins;; 810 ; 811 // allocate bin in chunk; 812 THnSparseArrayChunk *chunk = (THnSparseArrayChunk*) fBinContent.Last();; 813 Long64_t newidx = chunk ? ((Long64_t) chunk->GetEntries()) : -1;; 814 if (!chunk || newidx == (Long64_t)fChunkSize) {; 815 chunk = AddChunk();; 816 newidx = 0;; 817 }; 818 chunk->AddBin(newidx, cc->GetBuffer());; 819 ; 820 // store translation between hash and bin; 821 newidx += (fBinContent.GetEntriesFast() - 1) * fChunkSize;; 822 if (!linidx) {; 823 // fBins didn't find it; 824 if (2 * GetNbins() > fBins.Capacity()); 825 fBins.Expand(3 * GetNbins());; 826 fBins.Add(hash, newidx + 1);; 827 } else {; 828 // fBins contains one, but it's the wrong one;; 829 // add entry to",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:30678,Security,hash,hash,30678," 789Long64_t THnSparse::GetBinIndexForCurrentBin(Bool_t allocate); 790{; 791 THnSparseCompactBinCoord* cc = GetCompactCoord();; 792 ULong64_t hash = cc->GetHash();; 793 if (fBinContent.GetSize() && !fBins.GetSize()); 794 FillExMap();; 795 Long64_t linidx = (Long64_t) fBins.GetValue(hash);; 796 while (linidx) {; 797 // fBins stores index + 1!; 798 THnSparseArrayChunk* chunk = GetChunk((linidx - 1)/ fChunkSize);; 799 if (chunk->Matches((linidx - 1) % fChunkSize, cc->GetBuffer())); 800 return linidx - 1; // we store idx+1, 0 is ""TExMap: not found""; 801 ; 802 Long64_t nextlinidx = fBinsContinued.GetValue(linidx);; 803 if (!nextlinidx) break;; 804 ; 805 linidx = nextlinidx;; 806 }; 807 if (!allocate) return -1;; 808 ; 809 ++fFilledBins;; 810 ; 811 // allocate bin in chunk; 812 THnSparseArrayChunk *chunk = (THnSparseArrayChunk*) fBinContent.Last();; 813 Long64_t newidx = chunk ? ((Long64_t) chunk->GetEntries()) : -1;; 814 if (!chunk || newidx == (Long64_t)fChunkSize) {; 815 chunk = AddChunk();; 816 newidx = 0;; 817 }; 818 chunk->AddBin(newidx, cc->GetBuffer());; 819 ; 820 // store translation between hash and bin; 821 newidx += (fBinContent.GetEntriesFast() - 1) * fChunkSize;; 822 if (!linidx) {; 823 // fBins didn't find it; 824 if (2 * GetNbins() > fBins.Capacity()); 825 fBins.Expand(3 * GetNbins());; 826 fBins.Add(hash, newidx + 1);; 827 } else {; 828 // fBins contains one, but it's the wrong one;; 829 // add entry to fBinsContinued.; 830 fBinsContinued.Add(linidx, newidx + 1);; 831 }; 832 return newidx;; 833}; 834 ; 835////////////////////////////////////////////////////////////////////////////////; 836/// Return THnSparseCompactBinCoord object.; 837 ; 838THnSparseCompactBinCoord* THnSparse::GetCompactCoord() const; 839{; 840 if (!fCompactCoord) {; 841 Int_t *bins = new Int_t[fNdimensions];; 842 for (Int_t d = 0; d < fNdimensions; ++d); 843 bins[d] = GetAxis(d)->GetNbins();; 844 const_cast<THnSparse*>(this)->fCompactCoord; 845 = new THnSparseCompactBinCoord(fNdimension",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:30898,Security,hash,hash,30898,"nidx - 1)/ fChunkSize);; 799 if (chunk->Matches((linidx - 1) % fChunkSize, cc->GetBuffer())); 800 return linidx - 1; // we store idx+1, 0 is ""TExMap: not found""; 801 ; 802 Long64_t nextlinidx = fBinsContinued.GetValue(linidx);; 803 if (!nextlinidx) break;; 804 ; 805 linidx = nextlinidx;; 806 }; 807 if (!allocate) return -1;; 808 ; 809 ++fFilledBins;; 810 ; 811 // allocate bin in chunk; 812 THnSparseArrayChunk *chunk = (THnSparseArrayChunk*) fBinContent.Last();; 813 Long64_t newidx = chunk ? ((Long64_t) chunk->GetEntries()) : -1;; 814 if (!chunk || newidx == (Long64_t)fChunkSize) {; 815 chunk = AddChunk();; 816 newidx = 0;; 817 }; 818 chunk->AddBin(newidx, cc->GetBuffer());; 819 ; 820 // store translation between hash and bin; 821 newidx += (fBinContent.GetEntriesFast() - 1) * fChunkSize;; 822 if (!linidx) {; 823 // fBins didn't find it; 824 if (2 * GetNbins() > fBins.Capacity()); 825 fBins.Expand(3 * GetNbins());; 826 fBins.Add(hash, newidx + 1);; 827 } else {; 828 // fBins contains one, but it's the wrong one;; 829 // add entry to fBinsContinued.; 830 fBinsContinued.Add(linidx, newidx + 1);; 831 }; 832 return newidx;; 833}; 834 ; 835////////////////////////////////////////////////////////////////////////////////; 836/// Return THnSparseCompactBinCoord object.; 837 ; 838THnSparseCompactBinCoord* THnSparse::GetCompactCoord() const; 839{; 840 if (!fCompactCoord) {; 841 Int_t *bins = new Int_t[fNdimensions];; 842 for (Int_t d = 0; d < fNdimensions; ++d); 843 bins[d] = GetAxis(d)->GetNbins();; 844 const_cast<THnSparse*>(this)->fCompactCoord; 845 = new THnSparseCompactBinCoord(fNdimensions, bins);; 846 delete [] bins;; 847 }; 848 return fCompactCoord;; 849}; 850 ; 851////////////////////////////////////////////////////////////////////////////////; 852/// Return the amount of filled bins over all bins; 853 ; 854Double_t THnSparse::GetSparseFractionBins() const {; 855 Double_t nbinsTotal = 1.;; 856 for (Int_t d = 0; d < fNdimensions; ++d); 857 nbinsTotal *= GetAxis(d)->GetN",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:39970,Security,hash,hash,39970,"mespaces in the ROOT type system.Definition TClass.h:81; TClass::GetDataMemberTDataMember * GetDataMember(const char *datamember) constReturn pointer to datamember object with name ""datamember"".Definition TClass.cxx:3506; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDataMemberAll ROOT classes may have RTTI (run time type identification) support added.Definition TDataMember.h:31; TDataMember::GetDataTypeTDataType * GetDataType() constDefinition TDataMember.h:76; TDataType::SizeInt_t Size() constGet size of basic typedef'ed type.Definition TDataType.cxx:375; TExMap::Expandvoid Expand(Int_t newsize)Expand the TExMap.Definition TExMap.cxx:279; TExMap::GetSizeInt_t GetSize() constDefinition TExMap.h:71; TExMap::Addvoid Add(ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table. The key should be unique.Definition TExMap.cxx:88; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TExMap::CapacityInt_t Capacity() constDefinition TExMap.h:69; TExMap::Deletevoid Delete(Option_t *opt="""") overrideDelete all entries stored in the TExMap.Definition TExMap.cxx:164; THnBaseMultidimensional histogram base.Definition THnBase.h:43; THnBase::fEntriesDouble_t fEntriesNumber of entries, spread over chunks.Definition THnBase.h:48; THnBase::GetNdimensionsInt_t GetNdimensions() constDefinition THnBase.h:140; THnBase::ResetBasevoid ResetBase(Option_t *option="""")Clear the histogram.Definition THnBase.cxx:1327; THnBase::GetCalculateErrorsBool_t GetCalculateErrors() constDefinition THnBase.h:141; THnBase::fTsumw2Double_t fTsumw2Total sum of weights squared; -1 if no errors are calculated.Definition THnBase.h:50; THnBase::GetAxisTAxi",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:40138,Security,hash,hash,40138," object with name ""datamember"".Definition TClass.cxx:3506; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDataMemberAll ROOT classes may have RTTI (run time type identification) support added.Definition TDataMember.h:31; TDataMember::GetDataTypeTDataType * GetDataType() constDefinition TDataMember.h:76; TDataType::SizeInt_t Size() constGet size of basic typedef'ed type.Definition TDataType.cxx:375; TExMap::Expandvoid Expand(Int_t newsize)Expand the TExMap.Definition TExMap.cxx:279; TExMap::GetSizeInt_t GetSize() constDefinition TExMap.h:71; TExMap::Addvoid Add(ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table. The key should be unique.Definition TExMap.cxx:88; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TExMap::CapacityInt_t Capacity() constDefinition TExMap.h:69; TExMap::Deletevoid Delete(Option_t *opt="""") overrideDelete all entries stored in the TExMap.Definition TExMap.cxx:164; THnBaseMultidimensional histogram base.Definition THnBase.h:43; THnBase::fEntriesDouble_t fEntriesNumber of entries, spread over chunks.Definition THnBase.h:48; THnBase::GetNdimensionsInt_t GetNdimensions() constDefinition THnBase.h:140; THnBase::ResetBasevoid ResetBase(Option_t *option="""")Clear the histogram.Definition THnBase.cxx:1327; THnBase::GetCalculateErrorsBool_t GetCalculateErrors() constDefinition THnBase.h:141; THnBase::fTsumw2Double_t fTsumw2Total sum of weights squared; -1 if no errors are calculated.Definition THnBase.h:50; THnBase::GetAxisTAxis * GetAxis(Int_t dim) constDefinition THnBase.h:130; THnBase::fNdimensionsInt_t fNdimensionsNumber of dimensions.Definition THnBase.h:45; THnSparseArrayChunkTHnSp",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:40205,Security,hash,hash,40205," object with name ""datamember"".Definition TClass.cxx:3506; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDataMemberAll ROOT classes may have RTTI (run time type identification) support added.Definition TDataMember.h:31; TDataMember::GetDataTypeTDataType * GetDataType() constDefinition TDataMember.h:76; TDataType::SizeInt_t Size() constGet size of basic typedef'ed type.Definition TDataType.cxx:375; TExMap::Expandvoid Expand(Int_t newsize)Expand the TExMap.Definition TExMap.cxx:279; TExMap::GetSizeInt_t GetSize() constDefinition TExMap.h:71; TExMap::Addvoid Add(ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table. The key should be unique.Definition TExMap.cxx:88; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TExMap::CapacityInt_t Capacity() constDefinition TExMap.h:69; TExMap::Deletevoid Delete(Option_t *opt="""") overrideDelete all entries stored in the TExMap.Definition TExMap.cxx:164; THnBaseMultidimensional histogram base.Definition THnBase.h:43; THnBase::fEntriesDouble_t fEntriesNumber of entries, spread over chunks.Definition THnBase.h:48; THnBase::GetNdimensionsInt_t GetNdimensions() constDefinition THnBase.h:140; THnBase::ResetBasevoid ResetBase(Option_t *option="""")Clear the histogram.Definition THnBase.cxx:1327; THnBase::GetCalculateErrorsBool_t GetCalculateErrors() constDefinition THnBase.h:141; THnBase::fTsumw2Double_t fTsumw2Total sum of weights squared; -1 if no errors are calculated.Definition THnBase.h:50; THnBase::GetAxisTAxis * GetAxis(Int_t dim) constDefinition THnBase.h:130; THnBase::fNdimensionsInt_t fNdimensionsNumber of dimensions.Definition THnBase.h:45; THnSparseArrayChunkTHnSp",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:45603,Security,hash,hash,45603,"ession::GetNumBitsInt_t GetNumBits(Int_t n) constDefinition THnSparse.cxx:127; THnSparseCoordCompression::SetCoordFromBuffervoid SetCoordFromBuffer(const Char_t *buf_in, Int_t *coord_out) constGiven the compressed coordinate buffer buf_in, calculate (""decompact"") the bin coordinates and return...Definition THnSparse.cxx:205; THnSparseCoordCompression::SetBufferFromCoordULong64_t SetBufferFromCoord(const Int_t *coord_in, Char_t *buf_out) constGiven the cbin coordinates coord_in, calculate (""compact"") the bin coordinates and return them in buf...Definition THnSparse.cxx:233; THnSparseCoordCompression::fBitOffsetsInt_t * fBitOffsetsDefinition THnSparse.cxx:136; THnSparseCoordCompression::GetBufferSizeInt_t GetBufferSize() constDefinition THnSparse.cxx:121; THnSparseCoordCompression::operator=THnSparseCoordCompression & operator=(const THnSparseCoordCompression &other)Set this to other if different.Definition THnSparse.cxx:179; THnSparseCoordCompression::GetHashFromBufferULong64_t GetHashFromBuffer(const Char_t *buf) constCalculate hash from compact bin index.Definition THnSparse.cxx:317; THnSparseCoordCompression::fNdimensionsInt_t fNdimensionsDefinition THnSparse.cxx:134; THnSparseCoordCompression::THnSparseCoordCompressionTHnSparseCoordCompression(Int_t dim, const Int_t *nbins)Initialize a THnSparseCoordCompression object with ""dim"" dimensions and ""bins"" holding the number of ...Definition THnSparse.cxx:149; THnSparseCoordCompression::~THnSparseCoordCompression~THnSparseCoordCompression()destruct a THnSparseCoordCompressionDefinition THnSparse.cxx:195; THnSparseEfficient multidimensional histogram.Definition THnSparse.h:37; THnSparse::GetSparseFractionBinsDouble_t GetSparseFractionBins() constReturn the amount of filled bins over all bins.Definition THnSparse.cxx:854; THnSparse::GetSparseFractionMemDouble_t GetSparseFractionMem() constReturn the amount of used memory over memory that would be used by a non-sparse n-dimensional histogr...Definition THnSparse.cxx:865; T",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:48980,Security,hash,hashes,48980,"se.cxx:646; THnSparse::GetBinError2Double_t GetBinError2(Long64_t linidx) const overrideGet square of the error of bin addressed by linidx as If errors are not enabled (via Sumw2() or Calc...Definition THnSparse.cxx:771; THnSparse::THnSparseTHnSparse()Construct an empty THnSparse.Definition THnSparse.cxx:589; THnSparse::AddChunkTHnSparseArrayChunk * AddChunk()Create a new chunk of bin content.Definition THnSparse.cxx:634; THnSparse::GenerateArrayvirtual TArray * GenerateArray() const =0; THnSparse::SetBinError2void SetBinError2(Long64_t bin, Double_t e2) overrideSet error of bin with index ""bin"" to ""e"", enable errors if needed.Definition THnSparse.cxx:914; THnSparse::FillExMapvoid FillExMap()We have been streamed; set up fBins.Definition THnSparse.cxx:655; THnSparse::~THnSparse~THnSparse() overrideDestruct a THnSparse.Definition THnSparse.cxx:616; THnSparse::fBinsTExMap fBins! Filled binsDefinition THnSparse.h:42; THnSparse::fBinsContinuedTExMap fBinsContinued! Filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1)Definition THnSparse.h:43; THnSparse::AddBinContentvoid AddBinContent(const Int_t *idx, Double_t v=1.)Forwards to THnBase::AddBinContent().Definition THnSparse.h:113; THnSparse::Reservevoid Reserve(Long64_t nbins) overrideInitialize storage for nbins.Definition THnSparse.cxx:689; THnSparse::fChunkSizeInt_t fChunkSizeNumber of entries for each chunk.Definition THnSparse.h:39; THnSparse::Sumw2void Sumw2() overrideEnable calculation of errors.Definition THnSparse.cxx:948; THnSparse::GetNbinsLong64_t GetNbins() const overrideDefinition THnSparse.h:93; THnSparse::CreateIterROOT::Internal::THnBaseBinIter * CreateIter(Bool_t respectAxisRange) const overrideCreate an iterator over all filled bins of a THnSparse.Definition THnSparse.cxx:896; THnSparse::GetBinIndexForCurrentBinLong64_t GetBinIndexForCurrentBin(Bool_t allocate)Return the index for fCurrentBinIndex.Definition THnSparse.cxx:789; TIterDefinition TCollection.h:235; TObjArray::G",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:34469,Testability,log,logic,34469,"// Use THnIter instead.; 895 ; 896ROOT::Internal::THnBaseBinIter* THnSparse::CreateIter(Bool_t respectAxisRange) const; 897{; 898 return new THnSparseBinIter(respectAxisRange, this);; 899}; 900 ; 901////////////////////////////////////////////////////////////////////////////////; 902/// Set content of bin with index ""bin"" to ""v""; 903 ; 904void THnSparse::SetBinContent(Long64_t bin, Double_t v); 905{; 906 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 907 chunk->fContent->SetAt(v, bin % fChunkSize);; 908 ++fEntries;; 909}; 910 ; 911////////////////////////////////////////////////////////////////////////////////; 912/// Set error of bin with index ""bin"" to ""e"", enable errors if needed; 913 ; 914void THnSparse::SetBinError2(Long64_t bin, Double_t e2); 915{; 916 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 917 if (!chunk->fSumw2 ) {; 918 // if fSumw2 is zero GetCalculateErrors should return false; 919 if (GetCalculateErrors()) {; 920 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 921 }; 922 Sumw2(); // enable error calculation; 923 }; 924 ; 925 chunk->fSumw2->SetAt(e2, bin % fChunkSize);; 926}; 927 ; 928////////////////////////////////////////////////////////////////////////////////; 929/// Add ""e"" to error of bin with index ""bin"", enable errors if needed; 930 ; 931void THnSparse::AddBinError2(Long64_t bin, Double_t e2); 932{; 933 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 934 if (!chunk->fSumw2 ) {; 935 // if fSumw2 is zero GetCalculateErrors should return false; 936 if (GetCalculateErrors()) {; 937 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 938 }; 939 Sumw2(); // enable error calculation; 940 }; 941 ; 942 (*chunk->fSumw2)[bin % fChunkSize] += e2;; 943}; 944 ; 945////////////////////////////////////////////////////////////////////////////////; 946/// Enable calculation of errors; 947 ; 948void THnSparse::Sumw2(); 949{; 950 if (GetCalculateErrors()) return;; 951 ; 952 fTsumw2 = 0.;; 953 TIter iChunk(&fB",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8cxx_source.html:35075,Testability,log,logic,35075,"// Use THnIter instead.; 895 ; 896ROOT::Internal::THnBaseBinIter* THnSparse::CreateIter(Bool_t respectAxisRange) const; 897{; 898 return new THnSparseBinIter(respectAxisRange, this);; 899}; 900 ; 901////////////////////////////////////////////////////////////////////////////////; 902/// Set content of bin with index ""bin"" to ""v""; 903 ; 904void THnSparse::SetBinContent(Long64_t bin, Double_t v); 905{; 906 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 907 chunk->fContent->SetAt(v, bin % fChunkSize);; 908 ++fEntries;; 909}; 910 ; 911////////////////////////////////////////////////////////////////////////////////; 912/// Set error of bin with index ""bin"" to ""e"", enable errors if needed; 913 ; 914void THnSparse::SetBinError2(Long64_t bin, Double_t e2); 915{; 916 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 917 if (!chunk->fSumw2 ) {; 918 // if fSumw2 is zero GetCalculateErrors should return false; 919 if (GetCalculateErrors()) {; 920 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 921 }; 922 Sumw2(); // enable error calculation; 923 }; 924 ; 925 chunk->fSumw2->SetAt(e2, bin % fChunkSize);; 926}; 927 ; 928////////////////////////////////////////////////////////////////////////////////; 929/// Add ""e"" to error of bin with index ""bin"", enable errors if needed; 930 ; 931void THnSparse::AddBinError2(Long64_t bin, Double_t e2); 932{; 933 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 934 if (!chunk->fSumw2 ) {; 935 // if fSumw2 is zero GetCalculateErrors should return false; 936 if (GetCalculateErrors()) {; 937 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 938 }; 939 Sumw2(); // enable error calculation; 940 }; 941 ; 942 (*chunk->fSumw2)[bin % fChunkSize] += e2;; 943}; 944 ; 945////////////////////////////////////////////////////////////////////////////////; 946/// Enable calculation of errors; 947 ; 948void THnSparse::Sumw2(); 949{; 950 if (GetCalculateErrors()) return;; 951 ; 952 fTsumw2 = 0.;; 953 TIter iChunk(&fB",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
https://root.cern/doc/master/THnSparse_8h_source.html:14019,Availability,error,error,14019,"t Double_t *xmax=nullptr, Int_t chunksize=1024 *16)Definition THnSparse.h:210; THnSparseEfficient multidimensional histogram.Definition THnSparse.h:37; THnSparse::ProjectionTH1D * Projection(Int_t xDim, Option_t *option="""") constForwards to THnBase::Projection().Definition THnSparse.h:134; THnSparse::GetSparseFractionBinsDouble_t GetSparseFractionBins() constReturn the amount of filled bins over all bins.Definition THnSparse.cxx:854; THnSparse::GetSparseFractionMemDouble_t GetSparseFractionMem() constReturn the amount of used memory over memory that would be used by a non-sparse n-dimensional histogr...Definition THnSparse.cxx:865; THnSparse::RebinTHnSparse * Rebin(Int_t group) constDefinition THnSparse.h:159; THnSparse::Resetvoid Reset(Option_t *option="""") overrideClear the histogram.Definition THnSparse.cxx:962; THnSparse::GetNChunksInt_t GetNChunks() constDefinition THnSparse.h:89; THnSparse::operator=THnSparse & operator=(const THnSparse &)=delete; THnSparse::AddBinError2void AddBinError2(Long64_t bin, Double_t e2) overrideAdd ""e"" to error of bin with index ""bin"", enable errors if needed.Definition THnSparse.cxx:931; THnSparse::ProjectionTH3D * Projection(Int_t xDim, Int_t yDim, Int_t zDim, Option_t *option="""") constForwards to THnBase::Projection().Definition THnSparse.h:149; THnSparse::SetBinContentvoid SetBinContent(const Int_t *idx, Double_t v)Forwards to THnBase::SetBinContent().Definition THnSparse.h:105; THnSparse::GetChunkTHnSparseArrayChunk * GetChunk(Int_t idx) constDefinition THnSparse.h:56; THnSparse::fCompactCoordTHnSparseCompactBinCoord * fCompactCoord! Compact coordinateDefinition THnSparse.h:44; THnSparse::GetChunkSizeInt_t GetChunkSize() constDefinition THnSparse.h:88; THnSparse::GetBinContentDouble_t GetBinContent(const Int_t *idx) constForwards to THnBase::GetBinContent() overload.Definition THnSparse.h:121; THnSparse::fFilledBinsLong64_t fFilledBinsNumber of filled bins.Definition THnSparse.h:40; THnSparse::GetBinLong64_t GetBin(const Int_t *i",MatchSource.WIKI,doc/master/THnSparse_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html
https://root.cern/doc/master/THnSparse_8h_source.html:14057,Availability,error,errors,14057,"t Double_t *xmax=nullptr, Int_t chunksize=1024 *16)Definition THnSparse.h:210; THnSparseEfficient multidimensional histogram.Definition THnSparse.h:37; THnSparse::ProjectionTH1D * Projection(Int_t xDim, Option_t *option="""") constForwards to THnBase::Projection().Definition THnSparse.h:134; THnSparse::GetSparseFractionBinsDouble_t GetSparseFractionBins() constReturn the amount of filled bins over all bins.Definition THnSparse.cxx:854; THnSparse::GetSparseFractionMemDouble_t GetSparseFractionMem() constReturn the amount of used memory over memory that would be used by a non-sparse n-dimensional histogr...Definition THnSparse.cxx:865; THnSparse::RebinTHnSparse * Rebin(Int_t group) constDefinition THnSparse.h:159; THnSparse::Resetvoid Reset(Option_t *option="""") overrideClear the histogram.Definition THnSparse.cxx:962; THnSparse::GetNChunksInt_t GetNChunks() constDefinition THnSparse.h:89; THnSparse::operator=THnSparse & operator=(const THnSparse &)=delete; THnSparse::AddBinError2void AddBinError2(Long64_t bin, Double_t e2) overrideAdd ""e"" to error of bin with index ""bin"", enable errors if needed.Definition THnSparse.cxx:931; THnSparse::ProjectionTH3D * Projection(Int_t xDim, Int_t yDim, Int_t zDim, Option_t *option="""") constForwards to THnBase::Projection().Definition THnSparse.h:149; THnSparse::SetBinContentvoid SetBinContent(const Int_t *idx, Double_t v)Forwards to THnBase::SetBinContent().Definition THnSparse.h:105; THnSparse::GetChunkTHnSparseArrayChunk * GetChunk(Int_t idx) constDefinition THnSparse.h:56; THnSparse::fCompactCoordTHnSparseCompactBinCoord * fCompactCoord! Compact coordinateDefinition THnSparse.h:44; THnSparse::GetChunkSizeInt_t GetChunkSize() constDefinition THnSparse.h:88; THnSparse::GetBinContentDouble_t GetBinContent(const Int_t *idx) constForwards to THnBase::GetBinContent() overload.Definition THnSparse.h:121; THnSparse::fFilledBinsLong64_t fFilledBinsNumber of filled bins.Definition THnSparse.h:40; THnSparse::GetBinLong64_t GetBin(const Int_t *i",MatchSource.WIKI,doc/master/THnSparse_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html
https://root.cern/doc/master/THnSparse_8h_source.html:15766,Availability,error,error,15766,"wards to THnBase::GetBinContent() overload.Definition THnSparse.h:121; THnSparse::fFilledBinsLong64_t fFilledBinsNumber of filled bins.Definition THnSparse.h:40; THnSparse::GetBinLong64_t GetBin(const Int_t *idx) const overrideDefinition THnSparse.h:96; THnSparse::fBinContentTObjArray fBinContentArray of THnSparseArrayChunk.Definition THnSparse.h:41; THnSparse::GetBinLong64_t GetBin(const char *name[]) const overrideDefinition THnSparse.h:98; THnSparse::GetCompactCoordTHnSparseCompactBinCoord * GetCompactCoord() constReturn THnSparseCompactBinCoord object.Definition THnSparse.cxx:838; THnSparse::InitStoragevoid InitStorage(Int_t *nbins, Int_t chunkSize) overrideInitialize the storage of a histogram created via Init()Definition THnSparse.cxx:646; THnSparse::CreateSparsestatic THnSparse * CreateSparse(const char *name, const char *title, const TH1 *h1, Int_t chunkSize=1024 *16)Definition THnSparse.h:77; THnSparse::GetBinError2Double_t GetBinError2(Long64_t linidx) const overrideGet square of the error of bin addressed by linidx as If errors are not enabled (via Sumw2() or Calc...Definition THnSparse.cxx:771; THnSparse::THnSparseTHnSparse(const THnSparse &)=delete; THnSparse::THnSparseTHnSparse()Construct an empty THnSparse.Definition THnSparse.cxx:589; THnSparse::AddChunkTHnSparseArrayChunk * AddChunk()Create a new chunk of bin content.Definition THnSparse.cxx:634; THnSparse::GenerateArrayvirtual TArray * GenerateArray() const =0; THnSparse::SetBinError2void SetBinError2(Long64_t bin, Double_t e2) overrideSet error of bin with index ""bin"" to ""e"", enable errors if needed.Definition THnSparse.cxx:914; THnSparse::FillExMapvoid FillExMap()We have been streamed; set up fBins.Definition THnSparse.cxx:655; THnSparse::RebinTHnSparse * Rebin(const Int_t *group) constDefinition THnSparse.h:162; THnSparse::ProjectionTH2D * Projection(Int_t yDim, Int_t xDim, Option_t *option="""") constForwards to THnBase::Projection().Definition THnSparse.h:141; THnSparse::~THnSparse~THnSparse() ov",MatchSource.WIKI,doc/master/THnSparse_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html
https://root.cern/doc/master/THnSparse_8h_source.html:15805,Availability,error,errors,15805,"wards to THnBase::GetBinContent() overload.Definition THnSparse.h:121; THnSparse::fFilledBinsLong64_t fFilledBinsNumber of filled bins.Definition THnSparse.h:40; THnSparse::GetBinLong64_t GetBin(const Int_t *idx) const overrideDefinition THnSparse.h:96; THnSparse::fBinContentTObjArray fBinContentArray of THnSparseArrayChunk.Definition THnSparse.h:41; THnSparse::GetBinLong64_t GetBin(const char *name[]) const overrideDefinition THnSparse.h:98; THnSparse::GetCompactCoordTHnSparseCompactBinCoord * GetCompactCoord() constReturn THnSparseCompactBinCoord object.Definition THnSparse.cxx:838; THnSparse::InitStoragevoid InitStorage(Int_t *nbins, Int_t chunkSize) overrideInitialize the storage of a histogram created via Init()Definition THnSparse.cxx:646; THnSparse::CreateSparsestatic THnSparse * CreateSparse(const char *name, const char *title, const TH1 *h1, Int_t chunkSize=1024 *16)Definition THnSparse.h:77; THnSparse::GetBinError2Double_t GetBinError2(Long64_t linidx) const overrideGet square of the error of bin addressed by linidx as If errors are not enabled (via Sumw2() or Calc...Definition THnSparse.cxx:771; THnSparse::THnSparseTHnSparse(const THnSparse &)=delete; THnSparse::THnSparseTHnSparse()Construct an empty THnSparse.Definition THnSparse.cxx:589; THnSparse::AddChunkTHnSparseArrayChunk * AddChunk()Create a new chunk of bin content.Definition THnSparse.cxx:634; THnSparse::GenerateArrayvirtual TArray * GenerateArray() const =0; THnSparse::SetBinError2void SetBinError2(Long64_t bin, Double_t e2) overrideSet error of bin with index ""bin"" to ""e"", enable errors if needed.Definition THnSparse.cxx:914; THnSparse::FillExMapvoid FillExMap()We have been streamed; set up fBins.Definition THnSparse.cxx:655; THnSparse::RebinTHnSparse * Rebin(const Int_t *group) constDefinition THnSparse.h:162; THnSparse::ProjectionTH2D * Projection(Int_t yDim, Int_t xDim, Option_t *option="""") constForwards to THnBase::Projection().Definition THnSparse.h:141; THnSparse::~THnSparse~THnSparse() ov",MatchSource.WIKI,doc/master/THnSparse_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html
https://root.cern/doc/master/THnSparse_8h_source.html:16290,Availability,error,error,16290,"actBinCoord * GetCompactCoord() constReturn THnSparseCompactBinCoord object.Definition THnSparse.cxx:838; THnSparse::InitStoragevoid InitStorage(Int_t *nbins, Int_t chunkSize) overrideInitialize the storage of a histogram created via Init()Definition THnSparse.cxx:646; THnSparse::CreateSparsestatic THnSparse * CreateSparse(const char *name, const char *title, const TH1 *h1, Int_t chunkSize=1024 *16)Definition THnSparse.h:77; THnSparse::GetBinError2Double_t GetBinError2(Long64_t linidx) const overrideGet square of the error of bin addressed by linidx as If errors are not enabled (via Sumw2() or Calc...Definition THnSparse.cxx:771; THnSparse::THnSparseTHnSparse(const THnSparse &)=delete; THnSparse::THnSparseTHnSparse()Construct an empty THnSparse.Definition THnSparse.cxx:589; THnSparse::AddChunkTHnSparseArrayChunk * AddChunk()Create a new chunk of bin content.Definition THnSparse.cxx:634; THnSparse::GenerateArrayvirtual TArray * GenerateArray() const =0; THnSparse::SetBinError2void SetBinError2(Long64_t bin, Double_t e2) overrideSet error of bin with index ""bin"" to ""e"", enable errors if needed.Definition THnSparse.cxx:914; THnSparse::FillExMapvoid FillExMap()We have been streamed; set up fBins.Definition THnSparse.cxx:655; THnSparse::RebinTHnSparse * Rebin(const Int_t *group) constDefinition THnSparse.h:162; THnSparse::ProjectionTH2D * Projection(Int_t yDim, Int_t xDim, Option_t *option="""") constForwards to THnBase::Projection().Definition THnSparse.h:141; THnSparse::~THnSparse~THnSparse() overrideDestruct a THnSparse.Definition THnSparse.cxx:616; THnSparse::FillBinvoid FillBin(Long64_t bin, Double_t w) overrideIncrement the bin content of ""bin"" by ""w"", return the bin index.Definition THnSparse.h:67; THnSparse::fBinsTExMap fBins! Filled binsDefinition THnSparse.h:42; THnSparse::GetBinLong64_t GetBin(const Double_t *x) const overrideDefinition THnSparse.h:97; THnSparse::CreateSparsestatic THnSparse * CreateSparse(const char *name, const char *title, const THnBase *hn, ",MatchSource.WIKI,doc/master/THnSparse_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html
https://root.cern/doc/master/THnSparse_8h_source.html:16335,Availability,error,errors,16335,"actBinCoord * GetCompactCoord() constReturn THnSparseCompactBinCoord object.Definition THnSparse.cxx:838; THnSparse::InitStoragevoid InitStorage(Int_t *nbins, Int_t chunkSize) overrideInitialize the storage of a histogram created via Init()Definition THnSparse.cxx:646; THnSparse::CreateSparsestatic THnSparse * CreateSparse(const char *name, const char *title, const TH1 *h1, Int_t chunkSize=1024 *16)Definition THnSparse.h:77; THnSparse::GetBinError2Double_t GetBinError2(Long64_t linidx) const overrideGet square of the error of bin addressed by linidx as If errors are not enabled (via Sumw2() or Calc...Definition THnSparse.cxx:771; THnSparse::THnSparseTHnSparse(const THnSparse &)=delete; THnSparse::THnSparseTHnSparse()Construct an empty THnSparse.Definition THnSparse.cxx:589; THnSparse::AddChunkTHnSparseArrayChunk * AddChunk()Create a new chunk of bin content.Definition THnSparse.cxx:634; THnSparse::GenerateArrayvirtual TArray * GenerateArray() const =0; THnSparse::SetBinError2void SetBinError2(Long64_t bin, Double_t e2) overrideSet error of bin with index ""bin"" to ""e"", enable errors if needed.Definition THnSparse.cxx:914; THnSparse::FillExMapvoid FillExMap()We have been streamed; set up fBins.Definition THnSparse.cxx:655; THnSparse::RebinTHnSparse * Rebin(const Int_t *group) constDefinition THnSparse.h:162; THnSparse::ProjectionTH2D * Projection(Int_t yDim, Int_t xDim, Option_t *option="""") constForwards to THnBase::Projection().Definition THnSparse.h:141; THnSparse::~THnSparse~THnSparse() overrideDestruct a THnSparse.Definition THnSparse.cxx:616; THnSparse::FillBinvoid FillBin(Long64_t bin, Double_t w) overrideIncrement the bin content of ""bin"" by ""w"", return the bin index.Definition THnSparse.h:67; THnSparse::fBinsTExMap fBins! Filled binsDefinition THnSparse.h:42; THnSparse::GetBinLong64_t GetBin(const Double_t *x) const overrideDefinition THnSparse.h:97; THnSparse::CreateSparsestatic THnSparse * CreateSparse(const char *name, const char *title, const THnBase *hn, ",MatchSource.WIKI,doc/master/THnSparse_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html
https://root.cern/doc/master/THnSparse_8h_source.html:17989,Availability,error,errors,17989,"arse.h:67; THnSparse::fBinsTExMap fBins! Filled binsDefinition THnSparse.h:42; THnSparse::GetBinLong64_t GetBin(const Double_t *x) const overrideDefinition THnSparse.h:97; THnSparse::CreateSparsestatic THnSparse * CreateSparse(const char *name, const char *title, const THnBase *hn, Int_t chunkSize=1024 *16)Definition THnSparse.h:82; THnSparse::ProjectionTHnSparse * Projection(Int_t ndim, const Int_t *dim, Option_t *option="""") constDefinition THnSparse.h:154; THnSparse::fBinsContinuedTExMap fBinsContinued! Filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1)Definition THnSparse.h:43; THnSparse::AddBinContentvoid AddBinContent(const Int_t *idx, Double_t v=1.)Forwards to THnBase::AddBinContent().Definition THnSparse.h:113; THnSparse::Reservevoid Reserve(Long64_t nbins) overrideInitialize storage for nbins.Definition THnSparse.cxx:689; THnSparse::fChunkSizeInt_t fChunkSizeNumber of entries for each chunk.Definition THnSparse.h:39; THnSparse::Sumw2void Sumw2() overrideEnable calculation of errors.Definition THnSparse.cxx:948; THnSparse::GetNbinsLong64_t GetNbins() const overrideDefinition THnSparse.h:93; THnSparse::CreateIterROOT::Internal::THnBaseBinIter * CreateIter(Bool_t respectAxisRange) const overrideCreate an iterator over all filled bins of a THnSparse.Definition THnSparse.cxx:896; THnSparse::SetFilledBinsvoid SetFilledBins(Long64_t nbins) overrideDefinition THnSparse.h:94; THnSparse::GetBinIndexForCurrentBinLong64_t GetBinIndexForCurrentBin(Bool_t allocate)Return the index for fCurrentBinIndex.Definition THnSparse.cxx:789; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; bool; double; int; xDouble_t x[n]Definition legend1.C:17; h1TH1F * h1Definition legend1.C:5; v@ vDefinition rootcling_impl.cxx:3699; groupDefinition TWinNTSystem.h:50. histhistincTHnSparse.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:32 (GVA Time) using Doxyg",MatchSource.WIKI,doc/master/THnSparse_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html
https://root.cern/doc/master/THnSparse_8h_source.html:847,Energy Efficiency,efficient,efficient,847,". ROOT: hist/hist/inc/THnSparse.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. THnSparse.h. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Axel Naumann (2007-09-11); 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_THnSparse; 13#define ROOT_THnSparse; 14 ; 15/*************************************************************************; 16 ; 17 THnSparse: histogramming multi-dimensional, sparse distributions in; 18 a memory-efficient way.; 19 ; 20*************************************************************************/; 21 ; 22 ; 23#include ""THnBase.h""; 24#include ""TExMap.h""; 25#include ""THnSparse_Internal.h""; 26 ; 27// needed only for template instantiations of THnSparseT:; 28#include ""TArrayF.h""; 29#include ""TArrayL.h""; 30#include ""TArrayL64.h""; 31#include ""TArrayI.h""; 32#include ""TArrayS.h""; 33#include ""TArrayC.h""; 34 ; 35class THnSparseCompactBinCoord;; 36 ; 37class THnSparse: public THnBase {; 38 private:; 39 Int_t fChunkSize; ///< Number of entries for each chunk; 40 Long64_t fFilledBins; ///< Number of filled bins; 41 TObjArray fBinContent; ///< Array of THnSparseArrayChunk; 42 TExMap fBins; ///<! Filled bins; 43 TExMap fBinsContinued; ///<! Filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1); 44 THnSparseCompactBinCoord *fCompactCoord; ///<! Compact coordinate; 45 ; 46 THnSparse(const THnSparse&) = delete;; 47 THnSparse& operator=(const THnSparse&) = delete;; 48 ; 49 protected:; 50 ; 51 THnSparse();; 52 THnSparse(const char* name, const char* title, Int_t dim,; 53 const Int_t* nbins, const Double_t* xmin, const Double",MatchSource.WIKI,doc/master/THnSparse_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html
https://root.cern/doc/master/THnSparse_8h_source.html:2394,Energy Efficiency,allocate,allocate,2394,"20*************************************************************************/; 21 ; 22 ; 23#include ""THnBase.h""; 24#include ""TExMap.h""; 25#include ""THnSparse_Internal.h""; 26 ; 27// needed only for template instantiations of THnSparseT:; 28#include ""TArrayF.h""; 29#include ""TArrayL.h""; 30#include ""TArrayL64.h""; 31#include ""TArrayI.h""; 32#include ""TArrayS.h""; 33#include ""TArrayC.h""; 34 ; 35class THnSparseCompactBinCoord;; 36 ; 37class THnSparse: public THnBase {; 38 private:; 39 Int_t fChunkSize; ///< Number of entries for each chunk; 40 Long64_t fFilledBins; ///< Number of filled bins; 41 TObjArray fBinContent; ///< Array of THnSparseArrayChunk; 42 TExMap fBins; ///<! Filled bins; 43 TExMap fBinsContinued; ///<! Filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1); 44 THnSparseCompactBinCoord *fCompactCoord; ///<! Compact coordinate; 45 ; 46 THnSparse(const THnSparse&) = delete;; 47 THnSparse& operator=(const THnSparse&) = delete;; 48 ; 49 protected:; 50 ; 51 THnSparse();; 52 THnSparse(const char* name, const char* title, Int_t dim,; 53 const Int_t* nbins, const Double_t* xmin, const Double_t* xmax,; 54 Int_t chunksize);; 55 THnSparseCompactBinCoord* GetCompactCoord() const;; 56 THnSparseArrayChunk* GetChunk(Int_t idx) const {; 57 return (THnSparseArrayChunk*) fBinContent[idx]; }; 58 ; 59 THnSparseArrayChunk* AddChunk();; 60 void Reserve(Long64_t nbins) override;; 61 void FillExMap();; 62 virtual TArray* GenerateArray() const = 0;; 63 Long64_t GetBinIndexForCurrentBin(Bool_t allocate);; 64 ; 65 /// Increment the bin content of ""bin"" by ""w"",; 66 /// return the bin index.; 67 void FillBin(Long64_t bin, Double_t w) override {; 68 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 69 chunk->AddBinContent(bin % fChunkSize, w);; 70 FillBinBase(w);; 71 }; 72 void InitStorage(Int_t* nbins, Int_t chunkSize) override;; 73 ; 74 public:; 75 ~THnSparse() override;; 76 ; 77 static THnSparse* CreateSparse(const char* name, const char* title,; 78 co",MatchSource.WIKI,doc/master/THnSparse_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html
https://root.cern/doc/master/THnSparse_8h_source.html:3984,Energy Efficiency,allocate,allocate,3984," override;; 76 ; 77 static THnSparse* CreateSparse(const char* name, const char* title,; 78 const TH1* h1, Int_t chunkSize = 1024 * 16) {; 79 return (THnSparse*) CreateHnAny(name, title, h1, kTRUE /*sparse*/,; 80 chunkSize);; 81 }; 82 static THnSparse* CreateSparse(const char* name, const char* title,; 83 const THnBase* hn, Int_t chunkSize = 1024 * 16) {; 84 return (THnSparse*) CreateHnAny(name, title, hn, kTRUE /*sparse*/,; 85 chunkSize);; 86 }; 87 ; 88 Int_t GetChunkSize() const { return fChunkSize; }; 89 Int_t GetNChunks() const { return fBinContent.GetEntriesFast(); }; 90 ; 91 ROOT::Internal::THnBaseBinIter* CreateIter(Bool_t respectAxisRange) const override;; 92 ; 93 Long64_t GetNbins() const override { return fFilledBins; }; 94 void SetFilledBins(Long64_t nbins) override { fFilledBins = nbins; }; 95 ; 96 Long64_t GetBin(const Int_t* idx) const override { return const_cast<THnSparse*>(this)->GetBin(idx, kFALSE); }; 97 Long64_t GetBin(const Double_t* x) const override { return const_cast<THnSparse*>(this)->GetBin(x, kFALSE); }; 98 Long64_t GetBin(const char* name[]) const override { return const_cast<THnSparse*>(this)->GetBin(name, kFALSE); }; 99 Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE) override;; 100 Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE) override;; 101 Long64_t GetBin(const char* name[], Bool_t allocate = kTRUE) override;; 102 ; 103 /// Forwards to THnBase::SetBinContent().; 104 /// Non-virtual, CINT-compatible replacement of a using declaration.; 105 void SetBinContent(const Int_t* idx, Double_t v) {; 106 THnBase::SetBinContent(idx, v);; 107 }; 108 void SetBinContent(Long64_t bin, Double_t v) override;; 109 void SetBinError2(Long64_t bin, Double_t e2) override;; 110 ; 111 /// Forwards to THnBase::AddBinContent().; 112 /// Non-virtual, CINT-compatible replacement of a using declaration.; 113 void AddBinContent(const Int_t* idx, Double_t v = 1.) {; 114 THnBase::AddBinContent(idx, v);; 115 }; 116 void AddBinContent(Long64_t",MatchSource.WIKI,doc/master/THnSparse_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html
https://root.cern/doc/master/THnSparse_8h_source.html:4059,Energy Efficiency,allocate,allocate,4059," override;; 76 ; 77 static THnSparse* CreateSparse(const char* name, const char* title,; 78 const TH1* h1, Int_t chunkSize = 1024 * 16) {; 79 return (THnSparse*) CreateHnAny(name, title, h1, kTRUE /*sparse*/,; 80 chunkSize);; 81 }; 82 static THnSparse* CreateSparse(const char* name, const char* title,; 83 const THnBase* hn, Int_t chunkSize = 1024 * 16) {; 84 return (THnSparse*) CreateHnAny(name, title, hn, kTRUE /*sparse*/,; 85 chunkSize);; 86 }; 87 ; 88 Int_t GetChunkSize() const { return fChunkSize; }; 89 Int_t GetNChunks() const { return fBinContent.GetEntriesFast(); }; 90 ; 91 ROOT::Internal::THnBaseBinIter* CreateIter(Bool_t respectAxisRange) const override;; 92 ; 93 Long64_t GetNbins() const override { return fFilledBins; }; 94 void SetFilledBins(Long64_t nbins) override { fFilledBins = nbins; }; 95 ; 96 Long64_t GetBin(const Int_t* idx) const override { return const_cast<THnSparse*>(this)->GetBin(idx, kFALSE); }; 97 Long64_t GetBin(const Double_t* x) const override { return const_cast<THnSparse*>(this)->GetBin(x, kFALSE); }; 98 Long64_t GetBin(const char* name[]) const override { return const_cast<THnSparse*>(this)->GetBin(name, kFALSE); }; 99 Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE) override;; 100 Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE) override;; 101 Long64_t GetBin(const char* name[], Bool_t allocate = kTRUE) override;; 102 ; 103 /// Forwards to THnBase::SetBinContent().; 104 /// Non-virtual, CINT-compatible replacement of a using declaration.; 105 void SetBinContent(const Int_t* idx, Double_t v) {; 106 THnBase::SetBinContent(idx, v);; 107 }; 108 void SetBinContent(Long64_t bin, Double_t v) override;; 109 void SetBinError2(Long64_t bin, Double_t e2) override;; 110 ; 111 /// Forwards to THnBase::AddBinContent().; 112 /// Non-virtual, CINT-compatible replacement of a using declaration.; 113 void AddBinContent(const Int_t* idx, Double_t v = 1.) {; 114 THnBase::AddBinContent(idx, v);; 115 }; 116 void AddBinContent(Long64_t",MatchSource.WIKI,doc/master/THnSparse_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html
https://root.cern/doc/master/THnSparse_8h_source.html:4135,Energy Efficiency,allocate,allocate,4135," override;; 76 ; 77 static THnSparse* CreateSparse(const char* name, const char* title,; 78 const TH1* h1, Int_t chunkSize = 1024 * 16) {; 79 return (THnSparse*) CreateHnAny(name, title, h1, kTRUE /*sparse*/,; 80 chunkSize);; 81 }; 82 static THnSparse* CreateSparse(const char* name, const char* title,; 83 const THnBase* hn, Int_t chunkSize = 1024 * 16) {; 84 return (THnSparse*) CreateHnAny(name, title, hn, kTRUE /*sparse*/,; 85 chunkSize);; 86 }; 87 ; 88 Int_t GetChunkSize() const { return fChunkSize; }; 89 Int_t GetNChunks() const { return fBinContent.GetEntriesFast(); }; 90 ; 91 ROOT::Internal::THnBaseBinIter* CreateIter(Bool_t respectAxisRange) const override;; 92 ; 93 Long64_t GetNbins() const override { return fFilledBins; }; 94 void SetFilledBins(Long64_t nbins) override { fFilledBins = nbins; }; 95 ; 96 Long64_t GetBin(const Int_t* idx) const override { return const_cast<THnSparse*>(this)->GetBin(idx, kFALSE); }; 97 Long64_t GetBin(const Double_t* x) const override { return const_cast<THnSparse*>(this)->GetBin(x, kFALSE); }; 98 Long64_t GetBin(const char* name[]) const override { return const_cast<THnSparse*>(this)->GetBin(name, kFALSE); }; 99 Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE) override;; 100 Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE) override;; 101 Long64_t GetBin(const char* name[], Bool_t allocate = kTRUE) override;; 102 ; 103 /// Forwards to THnBase::SetBinContent().; 104 /// Non-virtual, CINT-compatible replacement of a using declaration.; 105 void SetBinContent(const Int_t* idx, Double_t v) {; 106 THnBase::SetBinContent(idx, v);; 107 }; 108 void SetBinContent(Long64_t bin, Double_t v) override;; 109 void SetBinError2(Long64_t bin, Double_t e2) override;; 110 ; 111 /// Forwards to THnBase::AddBinContent().; 112 /// Non-virtual, CINT-compatible replacement of a using declaration.; 113 void AddBinContent(const Int_t* idx, Double_t v = 1.) {; 114 THnBase::AddBinContent(idx, v);; 115 }; 116 void AddBinContent(Long64_t",MatchSource.WIKI,doc/master/THnSparse_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html
https://root.cern/doc/master/THnSparse_8h_source.html:18465,Energy Efficiency,allocate,allocate,18465,"parse::fBinsTExMap fBins! Filled binsDefinition THnSparse.h:42; THnSparse::GetBinLong64_t GetBin(const Double_t *x) const overrideDefinition THnSparse.h:97; THnSparse::CreateSparsestatic THnSparse * CreateSparse(const char *name, const char *title, const THnBase *hn, Int_t chunkSize=1024 *16)Definition THnSparse.h:82; THnSparse::ProjectionTHnSparse * Projection(Int_t ndim, const Int_t *dim, Option_t *option="""") constDefinition THnSparse.h:154; THnSparse::fBinsContinuedTExMap fBinsContinued! Filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1)Definition THnSparse.h:43; THnSparse::AddBinContentvoid AddBinContent(const Int_t *idx, Double_t v=1.)Forwards to THnBase::AddBinContent().Definition THnSparse.h:113; THnSparse::Reservevoid Reserve(Long64_t nbins) overrideInitialize storage for nbins.Definition THnSparse.cxx:689; THnSparse::fChunkSizeInt_t fChunkSizeNumber of entries for each chunk.Definition THnSparse.h:39; THnSparse::Sumw2void Sumw2() overrideEnable calculation of errors.Definition THnSparse.cxx:948; THnSparse::GetNbinsLong64_t GetNbins() const overrideDefinition THnSparse.h:93; THnSparse::CreateIterROOT::Internal::THnBaseBinIter * CreateIter(Bool_t respectAxisRange) const overrideCreate an iterator over all filled bins of a THnSparse.Definition THnSparse.cxx:896; THnSparse::SetFilledBinsvoid SetFilledBins(Long64_t nbins) overrideDefinition THnSparse.h:94; THnSparse::GetBinIndexForCurrentBinLong64_t GetBinIndexForCurrentBin(Bool_t allocate)Return the index for fCurrentBinIndex.Definition THnSparse.cxx:789; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; bool; double; int; xDouble_t x[n]Definition legend1.C:17; h1TH1F * h1Definition legend1.C:5; v@ vDefinition rootcling_impl.cxx:3699; groupDefinition TWinNTSystem.h:50. histhistincTHnSparse.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/THnSparse_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html
https://root.cern/doc/master/THnSparse_8h_source.html:6946,Integrability,interface,interfaces,6946,"t of a using; 148 /// declaration.; 149 TH3D* Projection(Int_t xDim, Int_t yDim, Int_t zDim,; 150 Option_t* option = """") const {; 151 return THnBase::Projection(xDim, yDim, zDim, option);; 152 }; 153 ; 154 THnSparse* Projection(Int_t ndim, const Int_t* dim,; 155 Option_t* option = """") const {; 156 return (THnSparse*) ProjectionND(ndim, dim, option);; 157 }; 158 ; 159 THnSparse* Rebin(Int_t group) const {; 160 return (THnSparse*) RebinBase(group);; 161 }; 162 THnSparse* Rebin(const Int_t* group) const {; 163 return (THnSparse*) RebinBase(group);; 164 }; 165 ; 166 void Reset(Option_t* option = """") override;; 167 void Sumw2() override;; 168 ; 169 ClassDefOverride(THnSparse, 3); // Interfaces of sparse n-dimensional histogram; 170};; 171 ; 172 ; 173 ; 174//______________________________________________________________________________; 175/** \class THnSparseT; 176 Templated implementation of the abstract base THnSparse.; 177 All functionality and the interfaces to be used are in THnSparse!; 178 ; 179 THnSparse does not know how to store any bin content itself. Instead, this; 180 is delegated to the derived, templated class: the template parameter decides; 181 what the format for the bin content is. In fact it even defines the array; 182 itself; possible implementations probably derive from TArray.; 183 ; 184 Typedefs exist for template parameters with ROOT's generic types:; 185 ; 186 Templated name | Typedef | Bin content type; 187 ----------------------|---------------|--------------------; 188 THnSparseT<TArrayC> | THnSparseC | Char_t; 189 THnSparseT<TArrayS> | THnSparseS | Short_t; 190 THnSparseT<TArrayI> | THnSparseI | Int_t; 191 THnSparseT<TArrayL64> | THnSparseL | Long64_t; 192 THnSparseT<TArrayF> | THnSparseF | Float_t; 193 THnSparseT<TArrayD> | THnSparseD | Double_t; 194 ; 195 We recommend to use THnSparseC wherever possible, and to map its value space; 196 of 256 possible values to e.g. float values outside the class. This saves an; 197 enormous amount of memory",MatchSource.WIKI,doc/master/THnSparse_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html
https://root.cern/doc/master/THnSparse_8h_source.html:1614,Security,hash,hashes,1614,"20*************************************************************************/; 21 ; 22 ; 23#include ""THnBase.h""; 24#include ""TExMap.h""; 25#include ""THnSparse_Internal.h""; 26 ; 27// needed only for template instantiations of THnSparseT:; 28#include ""TArrayF.h""; 29#include ""TArrayL.h""; 30#include ""TArrayL64.h""; 31#include ""TArrayI.h""; 32#include ""TArrayS.h""; 33#include ""TArrayC.h""; 34 ; 35class THnSparseCompactBinCoord;; 36 ; 37class THnSparse: public THnBase {; 38 private:; 39 Int_t fChunkSize; ///< Number of entries for each chunk; 40 Long64_t fFilledBins; ///< Number of filled bins; 41 TObjArray fBinContent; ///< Array of THnSparseArrayChunk; 42 TExMap fBins; ///<! Filled bins; 43 TExMap fBinsContinued; ///<! Filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1); 44 THnSparseCompactBinCoord *fCompactCoord; ///<! Compact coordinate; 45 ; 46 THnSparse(const THnSparse&) = delete;; 47 THnSparse& operator=(const THnSparse&) = delete;; 48 ; 49 protected:; 50 ; 51 THnSparse();; 52 THnSparse(const char* name, const char* title, Int_t dim,; 53 const Int_t* nbins, const Double_t* xmin, const Double_t* xmax,; 54 Int_t chunksize);; 55 THnSparseCompactBinCoord* GetCompactCoord() const;; 56 THnSparseArrayChunk* GetChunk(Int_t idx) const {; 57 return (THnSparseArrayChunk*) fBinContent[idx]; }; 58 ; 59 THnSparseArrayChunk* AddChunk();; 60 void Reserve(Long64_t nbins) override;; 61 void FillExMap();; 62 virtual TArray* GenerateArray() const = 0;; 63 Long64_t GetBinIndexForCurrentBin(Bool_t allocate);; 64 ; 65 /// Increment the bin content of ""bin"" by ""w"",; 66 /// return the bin index.; 67 void FillBin(Long64_t bin, Double_t w) override {; 68 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 69 chunk->AddBinContent(bin % fChunkSize, w);; 70 FillBinBase(w);; 71 }; 72 void InitStorage(Int_t* nbins, Int_t chunkSize) override;; 73 ; 74 public:; 75 ~THnSparse() override;; 76 ; 77 static THnSparse* CreateSparse(const char* name, const char* title,; 78 co",MatchSource.WIKI,doc/master/THnSparse_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html
https://root.cern/doc/master/THnSparse_8h_source.html:10674,Security,hash,hash,10674,"inition Rtypes.h:346; TArrayC.h; TArrayF.h; TArrayI.h; TArrayL64.h; TArrayL.h; TArrayS.h; TExMap.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; THnBase.h; THnSparseLTHnSparseT< TArrayL64 > THnSparseLDefinition THnSparse.h:222; THnSparseSTHnSparseT< TArrayS > THnSparseSDefinition THnSparse.h:224; THnSparseFTHnSparseT< TArrayF > THnSparseFDefinition THnSparse.h:221; THnSparseCTHnSparseT< TArrayC > THnSparseCDefinition THnSparse.h:225; THnSparseDTHnSparseT< TArrayD > THnSparseDDefinition THnSparse.h:220; THnSparseITHnSparseT< TArrayI > THnSparseIDefinition THnSparse.h:223; THnSparse_Internal.h; ROOT::Internal::THnBaseBinIterIterator over THnBase bins (internal implementation).Definition THnBase.h:315; TArrayAbstract array base class.Definition TArray.h:31; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH2D2-D histogram with a double per channel (see TH1 documentation)Definition TH2.h:357; TH3D3-D histogram with a double per channel (see TH1 documentation)Definition TH3.h:363; THnBaseMultidimensional histogram base.Definition THnBase.h:43; THnBase::AddBinContentvoid AddBinContent(const Int_t *x, Double_t v=1.)Definition THnBase.h:191; THnBase::ProjectionTH1D * Projection(Int_t xDim, Option_t *option="""") constProject all bins into a 1-dimensional histogram, keeping only axis ""xDim"".Definition THnBase.h:226; THnBase::CreateHnAnystatic THnBase * CreateHnAny(const char *name, const char *title, const TH1 *h1, Bool_t sparse, Int_t chunkSize=1024 *16)Create a THn / THnSparse object from a histogram deriving from TH1.Definition THnBase.cxx:323; THnBase::RebinBaseTHnB",MatchSource.WIKI,doc/master/THnSparse_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html
https://root.cern/doc/master/THnSparse_8h_source.html:17498,Security,hash,hashes,17498,":RebinTHnSparse * Rebin(const Int_t *group) constDefinition THnSparse.h:162; THnSparse::ProjectionTH2D * Projection(Int_t yDim, Int_t xDim, Option_t *option="""") constForwards to THnBase::Projection().Definition THnSparse.h:141; THnSparse::~THnSparse~THnSparse() overrideDestruct a THnSparse.Definition THnSparse.cxx:616; THnSparse::FillBinvoid FillBin(Long64_t bin, Double_t w) overrideIncrement the bin content of ""bin"" by ""w"", return the bin index.Definition THnSparse.h:67; THnSparse::fBinsTExMap fBins! Filled binsDefinition THnSparse.h:42; THnSparse::GetBinLong64_t GetBin(const Double_t *x) const overrideDefinition THnSparse.h:97; THnSparse::CreateSparsestatic THnSparse * CreateSparse(const char *name, const char *title, const THnBase *hn, Int_t chunkSize=1024 *16)Definition THnSparse.h:82; THnSparse::ProjectionTHnSparse * Projection(Int_t ndim, const Int_t *dim, Option_t *option="""") constDefinition THnSparse.h:154; THnSparse::fBinsContinuedTExMap fBinsContinued! Filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1)Definition THnSparse.h:43; THnSparse::AddBinContentvoid AddBinContent(const Int_t *idx, Double_t v=1.)Forwards to THnBase::AddBinContent().Definition THnSparse.h:113; THnSparse::Reservevoid Reserve(Long64_t nbins) overrideInitialize storage for nbins.Definition THnSparse.cxx:689; THnSparse::fChunkSizeInt_t fChunkSizeNumber of entries for each chunk.Definition THnSparse.h:39; THnSparse::Sumw2void Sumw2() overrideEnable calculation of errors.Definition THnSparse.cxx:948; THnSparse::GetNbinsLong64_t GetNbins() const overrideDefinition THnSparse.h:93; THnSparse::CreateIterROOT::Internal::THnBaseBinIter * CreateIter(Bool_t respectAxisRange) const overrideCreate an iterator over all filled bins of a THnSparse.Definition THnSparse.cxx:896; THnSparse::SetFilledBinsvoid SetFilledBins(Long64_t nbins) overrideDefinition THnSparse.h:94; THnSparse::GetBinIndexForCurrentBinLong64_t GetBinIndexForCurrentBin(Bool_t allocate)Return the index for ",MatchSource.WIKI,doc/master/THnSparse_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html
https://root.cern/doc/master/THn_8cxx_source.html:5868,Availability,error,errors,5868," 139 THnD (typedef for THnT<Double_t>): bin content held by a Double_t,; 140 THnF (typedef for THnT<Float_t>): bin content held by a Float_t,; 141 THnL (typedef for THnT<Long64_t>): bin content held by a Long64_t,; 142 THnI (typedef for THnT<Int_t>): bin content held by an Int_t,; 143 THnS (typedef for THnT<Short_t>): bin content held by a Short_t,; 144 THnC (typedef for THnT<Char_t>): bin content held by a Char_t,; 145 ; 146They take name and title, the number of dimensions, and for each dimension; 147the number of bins, the minimal, and the maximal value on the dimension's; 148axis. A TH2F h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; 149 ; 150 Int_t bins[2] = {10, 20};; 151 Double_t xmin[2] = {0., -5.};; 152 Double_t xmax[2] = {10., 5.};; 153 THnF hn(""hn"", ""hn"", 2, bins, xmin, xmax);; 154 ; 155## Filling; 156A THn is filled just like a regular histogram, using; 157THn::Fill(x, weight), where x is a n-dimensional Double_t value.; 158To take errors into account, Sumw2() must be called before filling the; 159histogram.; 160Storage is allocated when the first bin content is stored.; 161 ; 162## Projections; 163The dimensionality of a THn can be reduced by projecting it to; 1641, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; 165a THn. See the Projection() members. To only project parts of the; 166histogram, call; 167 ; 168 hn->GetAxis(12)->SetRange(from_bin, to_bin);; 169 ; 170## Conversion from other histogram classes; 171The static factory function THn::CreateHn() can be used to create a THn; 172from a TH1, TH2, TH3, THnSparse and (for copying) even from a THn. The; 173created THn will have compatble storage type, i.e. calling CreateHn() on; 174a TH2F will create a THnF.; 175*/; 176 ; 177ClassImp(THn);; 178 ; 179////////////////////////////////////////////////////////////////////////////////; 180/// Construct a THn.; 181 ; 182THn::THn(const char* name, const char* title,; 183 Int_t dim, const Int_t* nbins,; 184 const Double_t* xm",MatchSource.WIKI,doc/master/THn_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THn_8cxx_source.html
https://root.cern/doc/master/THn_8cxx_source.html:7909,Availability,error,errors,7909,"182THn::THn(const char* name, const char* title,; 183 Int_t dim, const Int_t* nbins,; 184 const Double_t* xmin, const Double_t* xmax):; 185 THnBase(name, title, dim, nbins, xmin, xmax),; 186 fSumw2(dim, nbins, kTRUE /*overflow*/); 187{; 188}; 189 ; 190THn::THn(const char *name, const char *title, Int_t dim, const Int_t *nbins,; 191 const std::vector<std::vector<double>> &xbins); 192 : THnBase(name, title, dim, nbins, xbins), fSumw2(dim, nbins, kTRUE /*overflow*/); 193{; 194}; 195 ; 196////////////////////////////////////////////////////////////////////////////////; 197/// Destruct a THn; 198 ; 199THn::~THn(); 200{; 201}; 202 ; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Create an iterator over all bins. Public interface is THnIter.; 206 ; 207ROOT::Internal::THnBaseBinIter* THn::CreateIter(Bool_t respectAxisRange) const; 208{; 209 return new THnBinIter(GetNdimensions(), GetListOfAxes(), &GetArray(),; 210 respectAxisRange);; 211}; 212 ; 213////////////////////////////////////////////////////////////////////////////////; 214/// Enable calculation of errors; 215 ; 216void THn::Sumw2() {; 217 if (!GetCalculateErrors()) {; 218 fTsumw2 = 0.;; 219 }; 220 // fill sumw2 array with current content; 221 TNDArray & content = GetArray();; 222 Long64_t nbins = GetNbins();; 223 for (Long64_t ibin = 0; ibin < nbins; ++ibin); 224 fSumw2.At(ibin) = content.AtAsDouble(ibin);; 225}; 226 ; 227 ; 228////////////////////////////////////////////////////////////////////////////////; 229/// Create the coordinate buffer. Outlined to hide allocation; 230/// from inlined functions.; 231 ; 232void THn::AllocCoordBuf() const; 233{; 234 fCoordBuf.assign(fNdimensions, 0);; 235}; 236 ; 237////////////////////////////////////////////////////////////////////////////////; 238/// Initialize the storage of a histogram created via Init(); 239 ; 240void THn::InitStorage(Int_t* nbins, Int_t /*chunkSize*/); 241{; 242 fCoordBuf.assign(fNdimensions, 0);; 243",MatchSource.WIKI,doc/master/THn_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THn_8cxx_source.html
https://root.cern/doc/master/THn_8cxx_source.html:11655,Availability,error,errors,11655,"ace_Binding.h:15; ROOT::Internal::THnBaseBinIterIterator over THnBase bins (internal implementation).Definition THnBase.h:315; ROOT::Internal::THnBaseBinIter::GetCoordvirtual Int_t GetCoord(Int_t dim) const =0; ROOT::Internal::THnBaseBinIter::Nextvirtual Long64_t Next(Int_t *coord=nullptr)=0; TAxisClass to manage histogram axis.Definition TAxis.h:31; TAxis::kAxisRange@ kAxisRangeDefinition TAxis.h:65; TAxis::GetLastInt_t GetLast() constReturn last bin on the axis i.e.Definition TAxis.cxx:469; TAxis::GetNbinsInt_t GetNbins() constDefinition TAxis.h:125; TAxis::GetFirstInt_t GetFirst() constReturn first bin on the axis i.e.Definition TAxis.cxx:458; THnBaseMultidimensional histogram base.Definition THnBase.h:43; THnBase::GetListOfAxesTObjArray * GetListOfAxes()Definition THnBase.h:128; THnBase::GetNdimensionsInt_t GetNdimensions() constDefinition THnBase.h:140; THnBase::GetCalculateErrorsBool_t GetCalculateErrors() constDefinition THnBase.h:141; THnBase::fTsumw2Double_t fTsumw2Total sum of weights squared; -1 if no errors are calculated.Definition THnBase.h:50; THnBase::fNdimensionsInt_t fNdimensionsNumber of dimensions.Definition THnBase.h:45; THnMultidimensional histogram.Definition THn.h:30; THn::AllocCoordBufvoid AllocCoordBuf() constCreate the coordinate buffer.Definition THn.cxx:232; THn::InitStoragevoid InitStorage(Int_t *nbins, Int_t chunkSize) overrideInitialize the storage of a histogram created via Init()Definition THn.cxx:240; THn::~THn~THn() overrideDestruct a THn.Definition THn.cxx:199; THn::fCoordBufstd::vector< Int_t > fCoordBufDefinition THn.h:181; THn::fSumw2TNDArrayT< Double_t > fSumw2Definition THn.h:180; THn::CreateIterROOT::Internal::THnBaseBinIter * CreateIter(Bool_t respectAxisRange) const overrideCreate an iterator over all bins. Public interface is THnIter.Definition THn.cxx:207; THn::Resetvoid Reset(Option_t *option="""") overrideReset the contents of a THn.Definition THn.cxx:250; THn::Sumw2void Sumw2() overrideEnable calculation of errors.Defi",MatchSource.WIKI,doc/master/THn_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THn_8cxx_source.html
https://root.cern/doc/master/THn_8cxx_source.html:12616,Availability,error,errors,12616,"ase::fTsumw2Double_t fTsumw2Total sum of weights squared; -1 if no errors are calculated.Definition THnBase.h:50; THnBase::fNdimensionsInt_t fNdimensionsNumber of dimensions.Definition THnBase.h:45; THnMultidimensional histogram.Definition THn.h:30; THn::AllocCoordBufvoid AllocCoordBuf() constCreate the coordinate buffer.Definition THn.cxx:232; THn::InitStoragevoid InitStorage(Int_t *nbins, Int_t chunkSize) overrideInitialize the storage of a histogram created via Init()Definition THn.cxx:240; THn::~THn~THn() overrideDestruct a THn.Definition THn.cxx:199; THn::fCoordBufstd::vector< Int_t > fCoordBufDefinition THn.h:181; THn::fSumw2TNDArrayT< Double_t > fSumw2Definition THn.h:180; THn::CreateIterROOT::Internal::THnBaseBinIter * CreateIter(Bool_t respectAxisRange) const overrideCreate an iterator over all bins. Public interface is THnIter.Definition THn.cxx:207; THn::Resetvoid Reset(Option_t *option="""") overrideReset the contents of a THn.Definition THn.cxx:250; THn::Sumw2void Sumw2() overrideEnable calculation of errors.Definition THn.cxx:216; THn::THnTHn()=default; THn::GetNbinsLong64_t GetNbins() const overrideDefinition THn.h:54; THn::GetArrayvirtual const TNDArray & GetArray() const =0; TNDArrayN-Dim array class.Definition TNDArray.h:46; TNDArray::AtAsDoublevirtual Double_t AtAsDouble(ULong64_t linidx) const =0; TNDArray::GetCellSizeLong64_t GetCellSize(Int_t dim) constDefinition TNDArray.h:70; TNDArray::Initvirtual void Init(Int_t ndim, const Int_t *nbins, bool addOverflow=false)Definition TNDArray.h:55; TNDArray::Resetvirtual void Reset(Option_t *option="""")=0; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; bool; double; int; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb.",MatchSource.WIKI,doc/master/THn_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THn_8cxx_source.html
https://root.cern/doc/master/THn_8cxx_source.html:5961,Energy Efficiency,allocate,allocated,5961," THnF (typedef for THnT<Float_t>): bin content held by a Float_t,; 141 THnL (typedef for THnT<Long64_t>): bin content held by a Long64_t,; 142 THnI (typedef for THnT<Int_t>): bin content held by an Int_t,; 143 THnS (typedef for THnT<Short_t>): bin content held by a Short_t,; 144 THnC (typedef for THnT<Char_t>): bin content held by a Char_t,; 145 ; 146They take name and title, the number of dimensions, and for each dimension; 147the number of bins, the minimal, and the maximal value on the dimension's; 148axis. A TH2F h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; 149 ; 150 Int_t bins[2] = {10, 20};; 151 Double_t xmin[2] = {0., -5.};; 152 Double_t xmax[2] = {10., 5.};; 153 THnF hn(""hn"", ""hn"", 2, bins, xmin, xmax);; 154 ; 155## Filling; 156A THn is filled just like a regular histogram, using; 157THn::Fill(x, weight), where x is a n-dimensional Double_t value.; 158To take errors into account, Sumw2() must be called before filling the; 159histogram.; 160Storage is allocated when the first bin content is stored.; 161 ; 162## Projections; 163The dimensionality of a THn can be reduced by projecting it to; 1641, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; 165a THn. See the Projection() members. To only project parts of the; 166histogram, call; 167 ; 168 hn->GetAxis(12)->SetRange(from_bin, to_bin);; 169 ; 170## Conversion from other histogram classes; 171The static factory function THn::CreateHn() can be used to create a THn; 172from a TH1, TH2, TH3, THnSparse and (for copying) even from a THn. The; 173created THn will have compatble storage type, i.e. calling CreateHn() on; 174a TH2F will create a THnF.; 175*/; 176 ; 177ClassImp(THn);; 178 ; 179////////////////////////////////////////////////////////////////////////////////; 180/// Construct a THn.; 181 ; 182THn::THn(const char* name, const char* title,; 183 Int_t dim, const Int_t* nbins,; 184 const Double_t* xmin, const Double_t* xmax):; 185 THnBase(name, title, dim, nbins, xmin, xmax),",MatchSource.WIKI,doc/master/THn_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THn_8cxx_source.html
https://root.cern/doc/master/THn_8cxx_source.html:6073,Energy Efficiency,reduce,reduced,6073," by a Long64_t,; 142 THnI (typedef for THnT<Int_t>): bin content held by an Int_t,; 143 THnS (typedef for THnT<Short_t>): bin content held by a Short_t,; 144 THnC (typedef for THnT<Char_t>): bin content held by a Char_t,; 145 ; 146They take name and title, the number of dimensions, and for each dimension; 147the number of bins, the minimal, and the maximal value on the dimension's; 148axis. A TH2F h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; 149 ; 150 Int_t bins[2] = {10, 20};; 151 Double_t xmin[2] = {0., -5.};; 152 Double_t xmax[2] = {10., 5.};; 153 THnF hn(""hn"", ""hn"", 2, bins, xmin, xmax);; 154 ; 155## Filling; 156A THn is filled just like a regular histogram, using; 157THn::Fill(x, weight), where x is a n-dimensional Double_t value.; 158To take errors into account, Sumw2() must be called before filling the; 159histogram.; 160Storage is allocated when the first bin content is stored.; 161 ; 162## Projections; 163The dimensionality of a THn can be reduced by projecting it to; 1641, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; 165a THn. See the Projection() members. To only project parts of the; 166histogram, call; 167 ; 168 hn->GetAxis(12)->SetRange(from_bin, to_bin);; 169 ; 170## Conversion from other histogram classes; 171The static factory function THn::CreateHn() can be used to create a THn; 172from a TH1, TH2, TH3, THnSparse and (for copying) even from a THn. The; 173created THn will have compatble storage type, i.e. calling CreateHn() on; 174a TH2F will create a THnF.; 175*/; 176 ; 177ClassImp(THn);; 178 ; 179////////////////////////////////////////////////////////////////////////////////; 180/// Construct a THn.; 181 ; 182THn::THn(const char* name, const char* title,; 183 Int_t dim, const Int_t* nbins,; 184 const Double_t* xmin, const Double_t* xmax):; 185 THnBase(name, title, dim, nbins, xmin, xmax),; 186 fSumw2(dim, nbins, kTRUE /*overflow*/); 187{; 188}; 189 ; 190THn::THn(const char *name, const char *title, Int_t dim",MatchSource.WIKI,doc/master/THn_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THn_8cxx_source.html
https://root.cern/doc/master/THn_8cxx_source.html:7566,Integrability,interface,interface,7566," type, i.e. calling CreateHn() on; 174a TH2F will create a THnF.; 175*/; 176 ; 177ClassImp(THn);; 178 ; 179////////////////////////////////////////////////////////////////////////////////; 180/// Construct a THn.; 181 ; 182THn::THn(const char* name, const char* title,; 183 Int_t dim, const Int_t* nbins,; 184 const Double_t* xmin, const Double_t* xmax):; 185 THnBase(name, title, dim, nbins, xmin, xmax),; 186 fSumw2(dim, nbins, kTRUE /*overflow*/); 187{; 188}; 189 ; 190THn::THn(const char *name, const char *title, Int_t dim, const Int_t *nbins,; 191 const std::vector<std::vector<double>> &xbins); 192 : THnBase(name, title, dim, nbins, xbins), fSumw2(dim, nbins, kTRUE /*overflow*/); 193{; 194}; 195 ; 196////////////////////////////////////////////////////////////////////////////////; 197/// Destruct a THn; 198 ; 199THn::~THn(); 200{; 201}; 202 ; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Create an iterator over all bins. Public interface is THnIter.; 206 ; 207ROOT::Internal::THnBaseBinIter* THn::CreateIter(Bool_t respectAxisRange) const; 208{; 209 return new THnBinIter(GetNdimensions(), GetListOfAxes(), &GetArray(),; 210 respectAxisRange);; 211}; 212 ; 213////////////////////////////////////////////////////////////////////////////////; 214/// Enable calculation of errors; 215 ; 216void THn::Sumw2() {; 217 if (!GetCalculateErrors()) {; 218 fTsumw2 = 0.;; 219 }; 220 // fill sumw2 array with current content; 221 TNDArray & content = GetArray();; 222 Long64_t nbins = GetNbins();; 223 for (Long64_t ibin = 0; ibin < nbins; ++ibin); 224 fSumw2.At(ibin) = content.AtAsDouble(ibin);; 225}; 226 ; 227 ; 228////////////////////////////////////////////////////////////////////////////////; 229/// Create the coordinate buffer. Outlined to hide allocation; 230/// from inlined functions.; 231 ; 232void THn::AllocCoordBuf() const; 233{; 234 fCoordBuf.assign(fNdimensions, 0);; 235}; 236 ; 237////////////////////////////////////////////",MatchSource.WIKI,doc/master/THn_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THn_8cxx_source.html
https://root.cern/doc/master/THn_8cxx_source.html:12416,Integrability,interface,interface,12416,"HnBase::GetNdimensionsInt_t GetNdimensions() constDefinition THnBase.h:140; THnBase::GetCalculateErrorsBool_t GetCalculateErrors() constDefinition THnBase.h:141; THnBase::fTsumw2Double_t fTsumw2Total sum of weights squared; -1 if no errors are calculated.Definition THnBase.h:50; THnBase::fNdimensionsInt_t fNdimensionsNumber of dimensions.Definition THnBase.h:45; THnMultidimensional histogram.Definition THn.h:30; THn::AllocCoordBufvoid AllocCoordBuf() constCreate the coordinate buffer.Definition THn.cxx:232; THn::InitStoragevoid InitStorage(Int_t *nbins, Int_t chunkSize) overrideInitialize the storage of a histogram created via Init()Definition THn.cxx:240; THn::~THn~THn() overrideDestruct a THn.Definition THn.cxx:199; THn::fCoordBufstd::vector< Int_t > fCoordBufDefinition THn.h:181; THn::fSumw2TNDArrayT< Double_t > fSumw2Definition THn.h:180; THn::CreateIterROOT::Internal::THnBaseBinIter * CreateIter(Bool_t respectAxisRange) const overrideCreate an iterator over all bins. Public interface is THnIter.Definition THn.cxx:207; THn::Resetvoid Reset(Option_t *option="""") overrideReset the contents of a THn.Definition THn.cxx:250; THn::Sumw2void Sumw2() overrideEnable calculation of errors.Definition THn.cxx:216; THn::THnTHn()=default; THn::GetNbinsLong64_t GetNbins() const overrideDefinition THn.h:54; THn::GetArrayvirtual const TNDArray & GetArray() const =0; TNDArrayN-Dim array class.Definition TNDArray.h:46; TNDArray::AtAsDoublevirtual Double_t AtAsDouble(ULong64_t linidx) const =0; TNDArray::GetCellSizeLong64_t GetCellSize(Int_t dim) constDefinition TNDArray.h:70; TNDArray::Initvirtual void Init(Int_t ndim, const Int_t *nbins, bool addOverflow=false)Definition TNDArray.h:55; TNDArray::Resetvirtual void Reset(Option_t *option="""")=0; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; bool; double; int;",MatchSource.WIKI,doc/master/THn_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THn_8cxx_source.html
https://root.cern/doc/master/THn_8h.html:264,Integrability,depend,dependency,264,". ROOT: hist/hist/inc/THn.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Typedefs ; THn.h File Reference. #include ""THnBase.h""; #include ""TNDArray.h""; #include ""TArrayD.h""; #include ""TAxis.h"". Include dependency graph for THn.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  THn;  Multidimensional histogram. More...;  ; class  THnT< T >;  Templated implementation of the abstract base THn. More...;  . Typedefs; typedef THnT< Char_t > THnC;  ; typedef THnT< Double_t > THnD;  ; typedef THnT< Float_t > THnF;  ; typedef THnT< Int_t > THnI;  ; typedef THnT< Long64_t > THnL;  ; typedef THnT< Long64_t > THnL64;  ; typedef THnT< Short_t > THnS;  . Typedef Documentation. ◆ THnC. typedef THnT<Char_t> THnC. Definition at line 245 of file THn.h. ◆ THnD. typedef THnT<Double_t> THnD. Definition at line 244 of file THn.h. ◆ THnF. typedef THnT<Float_t> THnF. Definition at line 243 of file THn.h. ◆ THnI. typedef THnT<Int_t> THnI. Definition at line 247 of file THn.h. ◆ THnL. typedef THnT<Long64_t> THnL. Definition at line 248 of file THn.h. ◆ THnL64. typedef THnT<Long64_t> THnL64. Definition at line 249 of file THn.h. ◆ THnS. typedef THnT<Short_t> THnS. Definition at line 246 of file THn.h. histhistincTHn.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/THn_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THn_8h.html
https://root.cern/doc/master/THn_8h_source.html:6238,Availability,error,error,6238," TH1D* Projection(Int_t xDim, Option_t* option = """") const {; 148 return THnBase::Projection(xDim, option);; 149 }; 150 ; 151 /// Forwards to THnBase::Projection().; 152 /// Non-virtual, as a CINT-compatible replacement of a using declaration.; 153 TH2D* Projection(Int_t yDim, Int_t xDim,; 154 Option_t* option = """") const {; 155 return THnBase::Projection(yDim, xDim, option);; 156 }; 157 ; 158 /// Forwards to THnBase::Projection().; 159 /// Non-virtual, as a CINT-compatible replacement of a using declaration.; 160 TH3D* Projection(Int_t xDim, Int_t yDim, Int_t zDim,; 161 Option_t* option = """") const {; 162 return THnBase::Projection(xDim, yDim, zDim, option);; 163 }; 164 ; 165 THn* Projection(Int_t ndim, const Int_t* dim,; 166 Option_t* option = """") const {; 167 return (THn*) ProjectionND(ndim, dim, option);; 168 }; 169 ; 170 THn* Rebin(Int_t group) const {; 171 return (THn*) RebinBase(group);; 172 }; 173 THn* Rebin(const Int_t* group) const {; 174 return (THn*) RebinBase(group);; 175 }; 176 ; 177 void Reset(Option_t* option = """") override;; 178 ; 179protected:; 180 TNDArrayT<Double_t> fSumw2; // bin error, lazy allocation happens in TNDArrayT; 181 mutable std::vector<Int_t> fCoordBuf; //! Temporary buffer; 182 ; 183 ClassDefOverride(THn, 1); //Base class for multi-dimensional histogram; 184};; 185 ; 186 ; 187//______________________________________________________________________________; 188/** \class THnT; 189 Templated implementation of the abstract base THn.; 190 All functionality and the interfaces to be used are in THn!; 191 ; 192 THn does not know how to store any bin content itself. Instead, this; 193 is delegated to the derived, templated class: the template parameter decides; 194 what the format for the bin content is. The actual storage is delegated to; 195 TNDArrayT<T>.; 196 ; 197 Typedefs exist for template parameters with ROOT's generic types:; 198 ; 199 Templated name | Typedef | Bin content type; 200 -----------------|---------------|----------------",MatchSource.WIKI,doc/master/THn_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THn_8h_source.html
https://root.cern/doc/master/THn_8h_source.html:15764,Availability,error,errors,15764,"NDArrayT< Double_t > fSumw2Definition THn.h:180; THn::SetBinContentvoid SetBinContent(const Int_t *idx, Double_t v)Forwards to THnBase::SetBinContent().Definition THn.h:97; THn::SetBinError2void SetBinError2(Long64_t bin, Double_t e2) overrideDefinition THn.h:103; THn::GetBinContentDouble_t GetBinContent(Long64_t bin, Int_t *idx=nullptr) const overrideGet the content of bin, and set its index if idx is != 0.Definition THn.h:124; THn::GetBinError2Double_t GetBinError2(Long64_t linidx) const overrideDefinition THn.h:136; THn::CreateIterROOT::Internal::THnBaseBinIter * CreateIter(Bool_t respectAxisRange) const overrideCreate an iterator over all bins. Public interface is THnIter.Definition THn.cxx:207; THn::Resetvoid Reset(Option_t *option="""") overrideReset the contents of a THn.Definition THn.cxx:250; THn::GetBinLong64_t GetBin(const Int_t *idx) const overrideDefinition THn.h:56; THn::GetBinLong64_t GetBin(const char *name[]) const overrideDefinition THn.h:67; THn::Sumw2void Sumw2() overrideEnable calculation of errors.Definition THn.cxx:216; THn::THnTHn()=default; THn::GetBinLong64_t GetBin(const Double_t *x) const overrideDefinition THn.h:59; THn::AddBinContentvoid AddBinContent(Long64_t bin, Double_t v=1.) overrideDefinition THn.h:112; THn::GetNbinsLong64_t GetNbins() const overrideDefinition THn.h:54; THn::ProjectionTH3D * Projection(Int_t xDim, Int_t yDim, Int_t zDim, Option_t *option="""") constForwards to THnBase::Projection().Definition THn.h:160; THn::SetBinContentvoid SetBinContent(Long64_t bin, Double_t v) overrideDefinition THn.h:100; THn::GetArrayvirtual TNDArray & GetArray()=0; THn::GetArrayvirtual const TNDArray & GetArray() const =0; THn::ProjectionTHn * Projection(Int_t ndim, const Int_t *dim, Option_t *option="""") constDefinition THn.h:165; TNDArrayTDefinition TNDArray.h:114; TNDArrayN-Dim array class.Definition TNDArray.h:46; TNDArray::AddAtvirtual void AddAt(ULong64_t linidx, Double_t value)=0; TNDArray::AtAsDoublevirtual Double_t AtAsDouble(ULong64_t",MatchSource.WIKI,doc/master/THn_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THn_8h_source.html
https://root.cern/doc/master/THn_8h_source.html:2485,Energy Efficiency,allocate,allocate,2485,"aseBinIter* CreateIter(Bool_t respectAxisRange) const override;; 54 Long64_t GetNbins() const override { return GetArray().GetNbins(); }; 55 ; 56 Long64_t GetBin(const Int_t* idx) const override {; 57 return GetArray().GetBin(idx);; 58 }; 59 Long64_t GetBin(const Double_t* x) const override {; 60 if (fCoordBuf.empty()); 61 AllocCoordBuf();; 62 for (Int_t d = 0; d < fNdimensions; ++d) {; 63 fCoordBuf[d] = GetAxis(d)->FindFixBin(x[d]);; 64 }; 65 return GetArray().GetBin(fCoordBuf.data());; 66 }; 67 Long64_t GetBin(const char* name[]) const override {; 68 if (fCoordBuf.empty()); 69 AllocCoordBuf();; 70 for (Int_t d = 0; d < fNdimensions; ++d) {; 71 fCoordBuf[d] = GetAxis(d)->FindBin(name[d]);; 72 }; 73 return GetArray().GetBin(fCoordBuf.data());; 74 }; 75 ; 76 Long64_t GetBin(const Int_t* idx, Bool_t /*allocate*/ = kTRUE) override {; 77 return const_cast<const THn*>(this)->GetBin(idx);; 78 }; 79 Long64_t GetBin(const Double_t* x, Bool_t /*allocate*/ = kTRUE) override {; 80 return const_cast<const THn*>(this)->GetBin(x);; 81 }; 82 Long64_t GetBin(const char* name[], Bool_t /*allocate*/ = kTRUE) override {; 83 return const_cast<const THn*>(this)->GetBin(name);; 84 }; 85 ; 86 /// Increment the bin content of ""bin"" by ""w"", return the bin index.; 87 void FillBin(Long64_t bin, Double_t w) override {; 88 GetArray().AddAt(bin, w);; 89 if (GetCalculateErrors()) {; 90 fSumw2.AddAt(bin, w * w);; 91 }; 92 FillBinBase(w);; 93 }; 94 ; 95 /// Forwards to THnBase::SetBinContent().; 96 /// Non-virtual, CINT-compatible replacement of a using declaration.; 97 void SetBinContent(const Int_t* idx, Double_t v) {; 98 THnBase::SetBinContent(idx, v);; 99 }; 100 void SetBinContent(Long64_t bin, Double_t v) override {; 101 GetArray().SetAsDouble(bin, v);; 102 }; 103 void SetBinError2(Long64_t bin, Double_t e2) override {; 104 if (!GetCalculateErrors()) Sumw2();; 105 fSumw2.At(bin) = e2;; 106 }; 107 /// Forwards to THnBase::SetBinContent().; 108 /// Non-virtual, CINT-compatible replacement of a us",MatchSource.WIKI,doc/master/THn_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THn_8h_source.html
https://root.cern/doc/master/THn_8h_source.html:2624,Energy Efficiency,allocate,allocate,2624,"aseBinIter* CreateIter(Bool_t respectAxisRange) const override;; 54 Long64_t GetNbins() const override { return GetArray().GetNbins(); }; 55 ; 56 Long64_t GetBin(const Int_t* idx) const override {; 57 return GetArray().GetBin(idx);; 58 }; 59 Long64_t GetBin(const Double_t* x) const override {; 60 if (fCoordBuf.empty()); 61 AllocCoordBuf();; 62 for (Int_t d = 0; d < fNdimensions; ++d) {; 63 fCoordBuf[d] = GetAxis(d)->FindFixBin(x[d]);; 64 }; 65 return GetArray().GetBin(fCoordBuf.data());; 66 }; 67 Long64_t GetBin(const char* name[]) const override {; 68 if (fCoordBuf.empty()); 69 AllocCoordBuf();; 70 for (Int_t d = 0; d < fNdimensions; ++d) {; 71 fCoordBuf[d] = GetAxis(d)->FindBin(name[d]);; 72 }; 73 return GetArray().GetBin(fCoordBuf.data());; 74 }; 75 ; 76 Long64_t GetBin(const Int_t* idx, Bool_t /*allocate*/ = kTRUE) override {; 77 return const_cast<const THn*>(this)->GetBin(idx);; 78 }; 79 Long64_t GetBin(const Double_t* x, Bool_t /*allocate*/ = kTRUE) override {; 80 return const_cast<const THn*>(this)->GetBin(x);; 81 }; 82 Long64_t GetBin(const char* name[], Bool_t /*allocate*/ = kTRUE) override {; 83 return const_cast<const THn*>(this)->GetBin(name);; 84 }; 85 ; 86 /// Increment the bin content of ""bin"" by ""w"", return the bin index.; 87 void FillBin(Long64_t bin, Double_t w) override {; 88 GetArray().AddAt(bin, w);; 89 if (GetCalculateErrors()) {; 90 fSumw2.AddAt(bin, w * w);; 91 }; 92 FillBinBase(w);; 93 }; 94 ; 95 /// Forwards to THnBase::SetBinContent().; 96 /// Non-virtual, CINT-compatible replacement of a using declaration.; 97 void SetBinContent(const Int_t* idx, Double_t v) {; 98 THnBase::SetBinContent(idx, v);; 99 }; 100 void SetBinContent(Long64_t bin, Double_t v) override {; 101 GetArray().SetAsDouble(bin, v);; 102 }; 103 void SetBinError2(Long64_t bin, Double_t e2) override {; 104 if (!GetCalculateErrors()) Sumw2();; 105 fSumw2.At(bin) = e2;; 106 }; 107 /// Forwards to THnBase::SetBinContent().; 108 /// Non-virtual, CINT-compatible replacement of a us",MatchSource.WIKI,doc/master/THn_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THn_8h_source.html
https://root.cern/doc/master/THn_8h_source.html:2762,Energy Efficiency,allocate,allocate,2762,"aseBinIter* CreateIter(Bool_t respectAxisRange) const override;; 54 Long64_t GetNbins() const override { return GetArray().GetNbins(); }; 55 ; 56 Long64_t GetBin(const Int_t* idx) const override {; 57 return GetArray().GetBin(idx);; 58 }; 59 Long64_t GetBin(const Double_t* x) const override {; 60 if (fCoordBuf.empty()); 61 AllocCoordBuf();; 62 for (Int_t d = 0; d < fNdimensions; ++d) {; 63 fCoordBuf[d] = GetAxis(d)->FindFixBin(x[d]);; 64 }; 65 return GetArray().GetBin(fCoordBuf.data());; 66 }; 67 Long64_t GetBin(const char* name[]) const override {; 68 if (fCoordBuf.empty()); 69 AllocCoordBuf();; 70 for (Int_t d = 0; d < fNdimensions; ++d) {; 71 fCoordBuf[d] = GetAxis(d)->FindBin(name[d]);; 72 }; 73 return GetArray().GetBin(fCoordBuf.data());; 74 }; 75 ; 76 Long64_t GetBin(const Int_t* idx, Bool_t /*allocate*/ = kTRUE) override {; 77 return const_cast<const THn*>(this)->GetBin(idx);; 78 }; 79 Long64_t GetBin(const Double_t* x, Bool_t /*allocate*/ = kTRUE) override {; 80 return const_cast<const THn*>(this)->GetBin(x);; 81 }; 82 Long64_t GetBin(const char* name[], Bool_t /*allocate*/ = kTRUE) override {; 83 return const_cast<const THn*>(this)->GetBin(name);; 84 }; 85 ; 86 /// Increment the bin content of ""bin"" by ""w"", return the bin index.; 87 void FillBin(Long64_t bin, Double_t w) override {; 88 GetArray().AddAt(bin, w);; 89 if (GetCalculateErrors()) {; 90 fSumw2.AddAt(bin, w * w);; 91 }; 92 FillBinBase(w);; 93 }; 94 ; 95 /// Forwards to THnBase::SetBinContent().; 96 /// Non-virtual, CINT-compatible replacement of a using declaration.; 97 void SetBinContent(const Int_t* idx, Double_t v) {; 98 THnBase::SetBinContent(idx, v);; 99 }; 100 void SetBinContent(Long64_t bin, Double_t v) override {; 101 GetArray().SetAsDouble(bin, v);; 102 }; 103 void SetBinError2(Long64_t bin, Double_t e2) override {; 104 if (!GetCalculateErrors()) Sumw2();; 105 fSumw2.At(bin) = e2;; 106 }; 107 /// Forwards to THnBase::SetBinContent().; 108 /// Non-virtual, CINT-compatible replacement of a us",MatchSource.WIKI,doc/master/THn_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THn_8h_source.html
https://root.cern/doc/master/THn_8h_source.html:6639,Integrability,interface,interfaces,6639,"_t yDim, Int_t zDim,; 161 Option_t* option = """") const {; 162 return THnBase::Projection(xDim, yDim, zDim, option);; 163 }; 164 ; 165 THn* Projection(Int_t ndim, const Int_t* dim,; 166 Option_t* option = """") const {; 167 return (THn*) ProjectionND(ndim, dim, option);; 168 }; 169 ; 170 THn* Rebin(Int_t group) const {; 171 return (THn*) RebinBase(group);; 172 }; 173 THn* Rebin(const Int_t* group) const {; 174 return (THn*) RebinBase(group);; 175 }; 176 ; 177 void Reset(Option_t* option = """") override;; 178 ; 179protected:; 180 TNDArrayT<Double_t> fSumw2; // bin error, lazy allocation happens in TNDArrayT; 181 mutable std::vector<Int_t> fCoordBuf; //! Temporary buffer; 182 ; 183 ClassDefOverride(THn, 1); //Base class for multi-dimensional histogram; 184};; 185 ; 186 ; 187//______________________________________________________________________________; 188/** \class THnT; 189 Templated implementation of the abstract base THn.; 190 All functionality and the interfaces to be used are in THn!; 191 ; 192 THn does not know how to store any bin content itself. Instead, this; 193 is delegated to the derived, templated class: the template parameter decides; 194 what the format for the bin content is. The actual storage is delegated to; 195 TNDArrayT<T>.; 196 ; 197 Typedefs exist for template parameters with ROOT's generic types:; 198 ; 199 Templated name | Typedef | Bin content type; 200 -----------------|---------------|--------------------; 201 THnT<Char_t> | THnC | Char_t; 202 THnT<Short_t> | THnS | Short_t; 203 THnT<Int_t> | THnI | Int_t; 204 THnT<Long64_t> | THnL | Long64_t; 205 THnT<Float_t> | THnF | Float_t; 206 THnT<Double_t> | THnD | Double_t; 207 ; 208 We recommend to use THnC wherever possible, and to map its value space; 209 of 256 possible values to e.g. float values outside the class. This saves an; 210 enormous amount of memory. Only if more than 256 values need to be; 211 distinguished should e.g. THnS or even THnF be chosen.; 212 ; 213 Implementation detail: the",MatchSource.WIKI,doc/master/THn_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THn_8h_source.html
https://root.cern/doc/master/THn_8h_source.html:15402,Integrability,interface,interface,15402,"d AddBinError2(Long64_t bin, Double_t e2) overrideDefinition THn.h:115; THn::RebinTHn * Rebin(const Int_t *group) constDefinition THn.h:173; THn::CreateHnstatic THn * CreateHn(const char *name, const char *title, const THnBase *hn)Definition THn.h:49; THn::fCoordBufstd::vector< Int_t > fCoordBufDefinition THn.h:181; THn::fSumw2TNDArrayT< Double_t > fSumw2Definition THn.h:180; THn::SetBinContentvoid SetBinContent(const Int_t *idx, Double_t v)Forwards to THnBase::SetBinContent().Definition THn.h:97; THn::SetBinError2void SetBinError2(Long64_t bin, Double_t e2) overrideDefinition THn.h:103; THn::GetBinContentDouble_t GetBinContent(Long64_t bin, Int_t *idx=nullptr) const overrideGet the content of bin, and set its index if idx is != 0.Definition THn.h:124; THn::GetBinError2Double_t GetBinError2(Long64_t linidx) const overrideDefinition THn.h:136; THn::CreateIterROOT::Internal::THnBaseBinIter * CreateIter(Bool_t respectAxisRange) const overrideCreate an iterator over all bins. Public interface is THnIter.Definition THn.cxx:207; THn::Resetvoid Reset(Option_t *option="""") overrideReset the contents of a THn.Definition THn.cxx:250; THn::GetBinLong64_t GetBin(const Int_t *idx) const overrideDefinition THn.h:56; THn::GetBinLong64_t GetBin(const char *name[]) const overrideDefinition THn.h:67; THn::Sumw2void Sumw2() overrideEnable calculation of errors.Definition THn.cxx:216; THn::THnTHn()=default; THn::GetBinLong64_t GetBin(const Double_t *x) const overrideDefinition THn.h:59; THn::AddBinContentvoid AddBinContent(Long64_t bin, Double_t v=1.) overrideDefinition THn.h:112; THn::GetNbinsLong64_t GetNbins() const overrideDefinition THn.h:54; THn::ProjectionTH3D * Projection(Int_t xDim, Int_t yDim, Int_t zDim, Option_t *option="""") constForwards to THnBase::Projection().Definition THn.h:160; THn::SetBinContentvoid SetBinContent(Long64_t bin, Double_t v) overrideDefinition THn.h:100; THn::GetArrayvirtual TNDArray & GetArray()=0; THn::GetArrayvirtual const TNDArray & GetArray() const =",MatchSource.WIKI,doc/master/THn_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THn_8h_source.html
https://root.cern/doc/master/thstackcolorscheme_8C.html:273,Security,access,accessible,273,". ROOT: tutorials/hist/thstackcolorscheme.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. thstackcolorscheme.C File ReferenceTutorials » Histograms tutorials. Detailed Description; This example demonstrates how to use the accessible color schemes with THStack. ; In this example, the color scheme with six colors is used. It also shows that the grayscale version is an acceptable alternative. ; void thstackcolorscheme(); {; auto c1 = new TCanvas();; auto hs = new THStack(""hs"",""Stacked 1D histograms colored using 6-colors scheme"");; ; // Create six 1-d histograms and add them in the stack; auto h1st = new TH1F(""h1st"",""A"",100,-4,4);; h1st->FillRandom(""gaus"",20000);; h1st->SetFillColor(kP6Blue);; hs->Add(h1st);; ; auto h2st = new TH1F(""h2st"",""B"",100,-4,4);; h2st->FillRandom(""gaus"",15000);; h2st->SetFillColor(kP6Yellow);; hs->Add(h2st);; ; auto h3st = new TH1F(""h3st"",""C"",100,-4,4);; h3st->FillRandom(""gaus"",10000);; h3st->SetFillColor(kP6Red);; hs->Add(h3st);; ; auto h4st = new TH1F(""h4st"",""D"",100,-4,4);; h4st->FillRandom(""gaus"",10000);; h4st->SetFillColor(kP6Grape);; hs->Add(h4st);; ; auto h5st = new TH1F(""h5st"",""E"",100,-4,4);; h5st->FillRandom(""gaus"",10000);; h5st->SetFillColor(kP6Gray);; hs->Add(h5st);; ; auto h6st = new TH1F(""h6st"",""F"",100,-4,4);; h6st->FillRandom(""gaus"",10000);; h6st->SetFillColor(kP6Violet);; hs->Add(h6st);; ; // draw the stack with colors; hs->Draw();; TLegend *l = gPad->BuildLegend(.8,.55,1.,.9,"""",""F"");; l->SetLineWidth(0);; l->SetFillStyle(0);; ; // draw the stack using gray-scale; auto c2 = new TCanvas();; c2->SetGrayscale();; hs->Draw();; l->Draw();; }; kP6Red@ kP6RedDefinition Rtypes.h:69; kP6Grape@ kP6GrapeDefinition Rtypes.h:69; kP6Gray@ kP6GrayDefinition Rtypes.h:69; kP6Yellow@ kP6YellowDefinition Rtypes.h:69; kP6Violet@ kP6VioletDefinition Rtypes.h:69; kP6Blue@ kP6BlueDefinition Rtypes.h:69; gPad#define gPadDefinition TVirtualPad.h:308; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t ",MatchSource.WIKI,doc/master/thstackcolorscheme_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/thstackcolorscheme_8C.html
https://root.cern/doc/master/thstackpalettecolor_8C.html:992,Testability,test,test,992,". ROOT: tutorials/hist/thstackpalettecolor.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. thstackpalettecolor.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Palette coloring for histograms' stack is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; When one of these options is given to THStack::Draw the histograms in the THStack get their color from the current color palette defined by gStyle->SetPalette(...). The color is determined according to the number of histograms.; In this example four histograms are displayed with palette coloring. The color of each histogram is picked inside the palette kOcean. ; void thstackpalettecolor(); {; auto hs = new THStack(""hs"",""Stacked 1D histograms colored using kOcean palette"");; ; gStyle->SetPalette(kOcean);; ; // Create three 1-d histograms and add them in the stack; auto h1st = new TH1F(""h1st"",""test hstack"",100,-4,4);; h1st->FillRandom(""gaus"",20000);; hs->Add(h1st);; ; auto h2st = new TH1F(""h2st"",""test hstack"",100,-4,4);; h2st->FillRandom(""gaus"",15000);; hs->Add(h2st);; ; auto h3st = new TH1F(""h3st"",""test hstack"",100,-4,4);; h3st->FillRandom(""gaus"",10000);; hs->Add(h3st);; ; // draw the stack; hs->Draw(""pfc nostack"");; }; kOcean@ kOceanDefinition TColor.h:119; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; THStackThe Histogram stack class.Definition THStack.h:40; TStyle::SetPalettevoid SetPalette(Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.)See TColor::SetPalette.Definition TStyle.cxx:1888; AuthorOlivier Couet ; Definition in file thstackpalettecolor.C. tutorialshistthstackpalettecolor.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/thstackpalettecolor_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/thstackpalettecolor_8C.html
https://root.cern/doc/master/thstackpalettecolor_8C.html:1097,Testability,test,test,1097,". ROOT: tutorials/hist/thstackpalettecolor.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. thstackpalettecolor.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Palette coloring for histograms' stack is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; When one of these options is given to THStack::Draw the histograms in the THStack get their color from the current color palette defined by gStyle->SetPalette(...). The color is determined according to the number of histograms.; In this example four histograms are displayed with palette coloring. The color of each histogram is picked inside the palette kOcean. ; void thstackpalettecolor(); {; auto hs = new THStack(""hs"",""Stacked 1D histograms colored using kOcean palette"");; ; gStyle->SetPalette(kOcean);; ; // Create three 1-d histograms and add them in the stack; auto h1st = new TH1F(""h1st"",""test hstack"",100,-4,4);; h1st->FillRandom(""gaus"",20000);; hs->Add(h1st);; ; auto h2st = new TH1F(""h2st"",""test hstack"",100,-4,4);; h2st->FillRandom(""gaus"",15000);; hs->Add(h2st);; ; auto h3st = new TH1F(""h3st"",""test hstack"",100,-4,4);; h3st->FillRandom(""gaus"",10000);; hs->Add(h3st);; ; // draw the stack; hs->Draw(""pfc nostack"");; }; kOcean@ kOceanDefinition TColor.h:119; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; THStackThe Histogram stack class.Definition THStack.h:40; TStyle::SetPalettevoid SetPalette(Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.)See TColor::SetPalette.Definition TStyle.cxx:1888; AuthorOlivier Couet ; Definition in file thstackpalettecolor.C. tutorialshistthstackpalettecolor.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/thstackpalettecolor_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/thstackpalettecolor_8C.html
https://root.cern/doc/master/thstackpalettecolor_8C.html:1202,Testability,test,test,1202,". ROOT: tutorials/hist/thstackpalettecolor.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. thstackpalettecolor.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Palette coloring for histograms' stack is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; When one of these options is given to THStack::Draw the histograms in the THStack get their color from the current color palette defined by gStyle->SetPalette(...). The color is determined according to the number of histograms.; In this example four histograms are displayed with palette coloring. The color of each histogram is picked inside the palette kOcean. ; void thstackpalettecolor(); {; auto hs = new THStack(""hs"",""Stacked 1D histograms colored using kOcean palette"");; ; gStyle->SetPalette(kOcean);; ; // Create three 1-d histograms and add them in the stack; auto h1st = new TH1F(""h1st"",""test hstack"",100,-4,4);; h1st->FillRandom(""gaus"",20000);; hs->Add(h1st);; ; auto h2st = new TH1F(""h2st"",""test hstack"",100,-4,4);; h2st->FillRandom(""gaus"",15000);; hs->Add(h2st);; ; auto h3st = new TH1F(""h3st"",""test hstack"",100,-4,4);; h3st->FillRandom(""gaus"",10000);; hs->Add(h3st);; ; // draw the stack; hs->Draw(""pfc nostack"");; }; kOcean@ kOceanDefinition TColor.h:119; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; THStackThe Histogram stack class.Definition THStack.h:40; TStyle::SetPalettevoid SetPalette(Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.)See TColor::SetPalette.Definition TStyle.cxx:1888; AuthorOlivier Couet ; Definition in file thstackpalettecolor.C. tutorialshistthstackpalettecolor.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/thstackpalettecolor_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/thstackpalettecolor_8C.html
https://root.cern/doc/master/THStack_8cxx_source.html:4508,Availability,avail,available,4508,"extFont(42); T.SetTextAlign(21);; 97 cs->Divide(2,2);; 98 cs->cd(1); hs->Draw(); T.DrawTextNDC(.5,.95,""Default drawing option"");; 99 cs->cd(2); hs->Draw(""nostack""); T.DrawTextNDC(.5,.95,""Option \""nostack\"""");; 100 cs->cd(3); hs->Draw(""nostackb""); T.DrawTextNDC(.5,.95,""Option \""nostackb\"""");; 101 cs->cd(4); hs->Draw(""lego1""); T.DrawTextNDC(.5,.95,""Option \""lego1\"""");; 102}; 103End_Macro; 104 ; 105A more complex example:; 106 ; 107Begin_Macro(source); 108../../../tutorials/hist/hstack.C; 109End_Macro; 110 ; 111Note that picking is supported for all drawing modes.; 112 ; 113\since **ROOT version 6.07/07:**; 114Stacks of 2D histograms can also be painted as candle plots:; 115\since **ROOT version 6.09/02:**; 116Stacks of 2D histograms can also be painted as violin plots, combinations of candle and; 117violin plots are possible as well:; 118 ; 119Begin_Macro(source); 120../../../tutorials/hist/candleplotstack.C; 121End_Macro; 122 ; 123Automatic coloring according to the current palette is available as shown in the; 124following example:; 125 ; 126Begin_Macro(source); 127../../../tutorials/hist/thstackpalettecolor.C; 128End_Macro; 129*/; 130 ; 131 ; 132////////////////////////////////////////////////////////////////////////////////; 133/// constructor with name and title; 134 ; 135THStack::THStack(const char *name, const char *title); 136 : TNamed(name,title); 137{; 138 R__LOCKGUARD(gROOTMutex);; 139 gROOT->GetListOfCleanups()->Add(this);; 140}; 141 ; 142 ; 143////////////////////////////////////////////////////////////////////////////////; 144/// Creates a new THStack from a TH2 or TH3.; 145/// It is filled with the 1D histograms from GetProjectionX or GetProjectionY; 146/// for each bin of the histogram. It illustrates the differences and total; 147/// sum along an axis.; 148///; 149/// Parameters:; 150/// - hist: the histogram used for the projections. Can be an object deriving; 151/// from TH2 or TH3.; 152/// - axis: for TH2: ""x"" for ProjectionX, ""y"" for ProjectionY.; ",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
https://root.cern/doc/master/THStack_8cxx_source.html:22706,Availability,error,error,22706," IMPORTANT NOTE; 643/// You must call Draw before calling this function. The returned histogram; 644/// depends on the selected Draw options.; 645 ; 646TAxis *THStack::GetZaxis() const; 647{; 648 TH1 *h = GetHistogram();; 649 if (!h) return nullptr;; 650 if (h->GetDimension() == 1); 651 Warning(""GetZaxis"",""1D Histograms don't have a Z axis"");; 652 return h->GetZaxis();; 653}; 654 ; 655////////////////////////////////////////////////////////////////////////////////; 656/// List histograms in the stack.; 657 ; 658void THStack::ls(Option_t *option) const; 659{; 660 TROOT::IndentLevel();; 661 std::cout <<IsA()->GetName(); 662 <<"" Name= ""<<GetName()<<"" Title= ""<<GetTitle()<<"" Option=""<<option<<std::endl;; 663 TROOT::IncreaseDirLevel();; 664 if (fHists) fHists->ls(option);; 665 TROOT::DecreaseDirLevel();; 666}; 667////////////////////////////////////////////////////////////////////////////////; 668/// Merge the THStack in the TList into this stack.; 669/// Returns the total number of histograms in the result or -1 in case of an error.; 670 ; 671Long64_t THStack::Merge(TCollection* li, TFileMergeInfo * /* info */); 672{; 673 if (li==nullptr || li->GetEntries()==0) {; 674 return fHists->GetEntries();; 675 }; 676 TIter next(li);; 677 TList histLists;; 678 while (TObject* o = next()) {; 679 THStack *stack = dynamic_cast<THStack*> (o);; 680 if (!stack) {; 681 Error(""Merge"",; 682 ""Cannot merge - an object which doesn't inherit from THStack found in the list"");; 683 return -1;; 684 }; 685 histLists.Add(stack->GetHists());; 686 }; 687 fHists->Merge(&histLists);; 688 return fHists->GetEntries();; 689}; 690 ; 691////////////////////////////////////////////////////////////////////////////////; 692/// Note: this method invalidates the sum of histograms.; 693 ; 694void THStack::Modified(); 695{; 696 if (!fStack) return;; 697 fStack->Delete();; 698 delete fStack;; 699 fStack = nullptr;; 700 delete fHistogram;; 701 fHistogram = nullptr;; 702}; 703 ; 704//////////////////////////////////",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
https://root.cern/doc/master/THStack_8cxx_source.html:50822,Availability,error,error,50822,"AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjStringCollectable string class.Definition TObjString.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Clonevirtual TObject * Clone(const char *newname="""") constMake a clone of an object using the Streamer facility.Definition TObject.cxx:229; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetDrawOptionvirtual void SetDrawOption(Option_t *option="""")Set drawing option for object.Definition TObject.cxx:770; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2887; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TROOT::DecreaseDirLevelstatic Int_t DecreaseDirLevel()Decrease the indentation level for ls().Definition TROOT.cxx:2746; TSeqCollection::IndexOfvirtual Int_t IndexOf(const TObject *obj) constReturn index of object in collection.Definition TSeqCollection.cxx:30; TSeqCollection::MergeLong64_t Merge(TCollection *list)Merge this collection with all collections coming in the input list.Definition TSeqCollection.cxx:185; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Lengt",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
https://root.cern/doc/master/THStack_8cxx_source.html:16377,Integrability,depend,depends,16377,"; 451/// stacked on top of each other.; 452 ; 453void THStack::Draw(Option_t *option); 454{; 455 TString opt = option;; 456 opt.ToLower();; 457 if (gPad) {; 458 if (!gPad->IsEditable()) gROOT->MakeDefCanvas();; 459 if (!opt.Contains(""same"") && !opt.Contains(""pads"")) {; 460 //the following statement is necessary in case one attempts to draw; 461 //a temporary histogram already in the current pad; 462 if (TestBit(kCanDelete)) gPad->Remove(this);; 463 gPad->Clear();; 464 }; 465 }; 466 AppendPad(opt.Data());; 467}; 468 ; 469////////////////////////////////////////////////////////////////////////////////; 470/// Returns a pointer to the histogram used to draw the axis.; 471/// Takes into account the two following cases:; 472/// 1- option 'A' was specified in THStack::Draw. Return fHistogram; 473/// 2- user had called TPad::DrawFrame. return pointer to hframe histogram; 474///; 475/// IMPORTANT NOTES; 476/// - You must call Draw before calling this function. The returned histogram; 477/// depends on the selected Draw options.; 478/// - This function returns a pointer to an intermediate fixed bin size; 479/// histogram used to set the range and for picking.; 480/// You cannot use this histogram to return the bin information.; 481/// You must get a pointer to one of the histograms in the stack,; 482/// the first one, for example.; 483 ; 484TH1 *THStack::GetHistogram() const; 485{; 486 if (fHistogram) return fHistogram;; 487 if (!gPad) return nullptr;; 488 gPad->Modified();; 489 gPad->Update();; 490 if (fHistogram) return fHistogram;; 491 return (TH1*)gPad->FindObject(""hframe"");; 492}; 493 ; 494////////////////////////////////////////////////////////////////////////////////; 495/// Returns the maximum of all added histograms smaller than maxval.; 496/// Returns the maximum of all histograms, smaller than maxval, if option ""nostack"".; 497 ; 498Double_t THStack::GetMaximum(Option_t *option, Double_t maxval); 499{; 500 TString opt = option;; 501 opt.ToLower();; 502 Bool_t lerr =",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
https://root.cern/doc/master/THStack_8cxx_source.html:20896,Integrability,depend,depends,20896,2 Double_t them = h->GetMinimum(minval);; 583 if (them <= 0 && logy); 584 them = h->GetMinimum(0);; 585 if (them < themin); 586 themin = them;; 587 if (lerr); 588 check_error(h);; 589 }; 590 }; 591 ; 592 return themin;; 593}; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Return the number of histograms in the stack; 597 ; 598Int_t THStack::GetNhists() const; 599{; 600 if (fHists) return fHists->GetSize();; 601 return 0;; 602}; 603 ; 604////////////////////////////////////////////////////////////////////////////////; 605/// Return pointer to Stack. Build it if not yet done.; 606 ; 607TObjArray *THStack::GetStack(); 608{; 609 BuildStack();; 610 return fStack;; 611}; 612 ; 613////////////////////////////////////////////////////////////////////////////////; 614/// Get the x-axis of the histogram used to draw the stack.; 615///; 616/// IMPORTANT NOTE; 617/// You must call Draw before calling this function. The returned histogram; 618/// depends on the selected Draw options.; 619 ; 620TAxis *THStack::GetXaxis() const; 621{; 622 TH1 *h = GetHistogram();; 623 return h ? h->GetXaxis() : nullptr;; 624}; 625 ; 626////////////////////////////////////////////////////////////////////////////////; 627/// Get the y-axis of the histogram used to draw the stack.; 628///; 629/// IMPORTANT NOTE; 630/// You must call Draw before calling this function. The returned histogram; 631/// depends on the selected Draw options.; 632 ; 633TAxis *THStack::GetYaxis() const; 634{; 635 TH1 *h = GetHistogram();; 636 return h ? h->GetYaxis() : nullptr;; 637}; 638 ; 639////////////////////////////////////////////////////////////////////////////////; 640/// Get the z-axis of the histogram used to draw the stack.; 641///; 642/// IMPORTANT NOTE; 643/// You must call Draw before calling this function. The returned histogram; 644/// depends on the selected Draw options.; 645 ; 646TAxis *THStack::GetZaxis() const; 647{; 648 TH1 *h = GetHistogram();; 649 if (!,MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
https://root.cern/doc/master/THStack_8cxx_source.html:21334,Integrability,depend,depends,21334,"urn fHists->GetSize();; 601 return 0;; 602}; 603 ; 604////////////////////////////////////////////////////////////////////////////////; 605/// Return pointer to Stack. Build it if not yet done.; 606 ; 607TObjArray *THStack::GetStack(); 608{; 609 BuildStack();; 610 return fStack;; 611}; 612 ; 613////////////////////////////////////////////////////////////////////////////////; 614/// Get the x-axis of the histogram used to draw the stack.; 615///; 616/// IMPORTANT NOTE; 617/// You must call Draw before calling this function. The returned histogram; 618/// depends on the selected Draw options.; 619 ; 620TAxis *THStack::GetXaxis() const; 621{; 622 TH1 *h = GetHistogram();; 623 return h ? h->GetXaxis() : nullptr;; 624}; 625 ; 626////////////////////////////////////////////////////////////////////////////////; 627/// Get the y-axis of the histogram used to draw the stack.; 628///; 629/// IMPORTANT NOTE; 630/// You must call Draw before calling this function. The returned histogram; 631/// depends on the selected Draw options.; 632 ; 633TAxis *THStack::GetYaxis() const; 634{; 635 TH1 *h = GetHistogram();; 636 return h ? h->GetYaxis() : nullptr;; 637}; 638 ; 639////////////////////////////////////////////////////////////////////////////////; 640/// Get the z-axis of the histogram used to draw the stack.; 641///; 642/// IMPORTANT NOTE; 643/// You must call Draw before calling this function. The returned histogram; 644/// depends on the selected Draw options.; 645 ; 646TAxis *THStack::GetZaxis() const; 647{; 648 TH1 *h = GetHistogram();; 649 if (!h) return nullptr;; 650 if (h->GetDimension() == 1); 651 Warning(""GetZaxis"",""1D Histograms don't have a Z axis"");; 652 return h->GetZaxis();; 653}; 654 ; 655////////////////////////////////////////////////////////////////////////////////; 656/// List histograms in the stack.; 657 ; 658void THStack::ls(Option_t *option) const; 659{; 660 TROOT::IndentLevel();; 661 std::cout <<IsA()->GetName(); 662 <<"" Name= ""<<GetName()<<"" Title= ""<<Get",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
https://root.cern/doc/master/THStack_8cxx_source.html:21772,Integrability,depend,depends,21772,"k.; 615///; 616/// IMPORTANT NOTE; 617/// You must call Draw before calling this function. The returned histogram; 618/// depends on the selected Draw options.; 619 ; 620TAxis *THStack::GetXaxis() const; 621{; 622 TH1 *h = GetHistogram();; 623 return h ? h->GetXaxis() : nullptr;; 624}; 625 ; 626////////////////////////////////////////////////////////////////////////////////; 627/// Get the y-axis of the histogram used to draw the stack.; 628///; 629/// IMPORTANT NOTE; 630/// You must call Draw before calling this function. The returned histogram; 631/// depends on the selected Draw options.; 632 ; 633TAxis *THStack::GetYaxis() const; 634{; 635 TH1 *h = GetHistogram();; 636 return h ? h->GetYaxis() : nullptr;; 637}; 638 ; 639////////////////////////////////////////////////////////////////////////////////; 640/// Get the z-axis of the histogram used to draw the stack.; 641///; 642/// IMPORTANT NOTE; 643/// You must call Draw before calling this function. The returned histogram; 644/// depends on the selected Draw options.; 645 ; 646TAxis *THStack::GetZaxis() const; 647{; 648 TH1 *h = GetHistogram();; 649 if (!h) return nullptr;; 650 if (h->GetDimension() == 1); 651 Warning(""GetZaxis"",""1D Histograms don't have a Z axis"");; 652 return h->GetZaxis();; 653}; 654 ; 655////////////////////////////////////////////////////////////////////////////////; 656/// List histograms in the stack.; 657 ; 658void THStack::ls(Option_t *option) const; 659{; 660 TROOT::IndentLevel();; 661 std::cout <<IsA()->GetName(); 662 <<"" Name= ""<<GetName()<<"" Title= ""<<GetTitle()<<"" Option=""<<option<<std::endl;; 663 TROOT::IncreaseDirLevel();; 664 if (fHists) fHists->ls(option);; 665 TROOT::DecreaseDirLevel();; 666}; 667////////////////////////////////////////////////////////////////////////////////; 668/// Merge the THStack in the TList into this stack.; 669/// Returns the total number of histograms in the result or -1 in case of an error.; 670 ; 671Long64_t THStack::Merge(TCollection* li, TFileMergeI",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
https://root.cern/doc/master/THStack_8cxx_source.html:42547,Integrability,rout,routine,42547," automatic add of histograms in memory.Definition TH1.cxx:1294; TH1::kIsZoomed@ kIsZoomedBit set when zooming on Y axis.Definition TH1.h:169; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetPainterTVirtualHistPainter * GetPainter(Option_t *option="""")Return pointer to painter.Definition TH1.cxx:4511; TH1::FindObjectTObject * FindObject(const char *name) const overrideSearch object named name in the list of functions.Definition TH1.cxx:3857; TH1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Definition TH1.h:404; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TH1::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TH1.cxx:7237; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::IsATClass * IsA() const overrideDefinition TH1.h:444; TH1::AddDirectoryStatusstatic Bool_t AddDirectoryStatus()Static function: cannot be inlined on Windows/NT.Definition TH1.cxx:754; TH1::SetBarWidthvirtual void SetBarWidth(Float_t width=0.5)Set the width of bars as fraction of the bin width for drawing mode ""B"".Definition TH1.h:365; TH1::SetStatsvirtual void SetStats(Bool_t stats=kTRUE)Set statistics option on/off.Definition TH1.cxx:8990; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TH2::ProjectionYTH1D * ProjectionY(const char *name=""_py"", Int_t firstxbin=0, Int_t lastxbin=-1, Option_t *option="""") constProject a 2-D histogram into a 1-D histogram along Y.Definition TH2.cxx:2476; TH2::ProjectionXTH1D * ProjectionX(const char *name=""_px"", Int_t firstybin=0, Int_t lastybin=-1, Option_t *option="""") ",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
https://root.cern/doc/master/THStack_8cxx_source.html:43889,Integrability,depend,depending,43889," SetBarWidth(Float_t width=0.5)Set the width of bars as fraction of the bin width for drawing mode ""B"".Definition TH1.h:365; TH1::SetStatsvirtual void SetStats(Bool_t stats=kTRUE)Set statistics option on/off.Definition TH1.cxx:8990; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TH2::ProjectionYTH1D * ProjectionY(const char *name=""_py"", Int_t firstxbin=0, Int_t lastxbin=-1, Option_t *option="""") constProject a 2-D histogram into a 1-D histogram along Y.Definition TH2.cxx:2476; TH2::ProjectionXTH1D * ProjectionX(const char *name=""_px"", Int_t firstybin=0, Int_t lastybin=-1, Option_t *option="""") constProject a 2-D histogram into a 1-D histogram along X.Definition TH2.cxx:2436; TH2::Classstatic TClass * Class(); TH3The 3-D histogram classes derived from the 1-D histogram classes.Definition TH3.h:31; TH3::Classstatic TClass * Class(); TH3::Project3Dvirtual TH1 * Project3D(Option_t *option=""x"") constProject a 3-d histogram into 1 or 2-d histograms depending on the option parameter,...Definition TH3.cxx:2409; THStackThe Histogram stack class.Definition THStack.h:40; THStack::beginTIter begin() constGet an iterator over internal hists list.Definition THStack.cxx:1099; THStack::IsATClass * IsA() const overrideDefinition THStack.h:93; THStack::~THStack~THStack() overrideTHStack destructor.Definition THStack.cxx:323; THStack::THStackTHStack()Definition THStack.h:57; THStack::BuildAndPaintvoid BuildAndPaint(Option_t *chopt, Bool_t paint, Bool_t rebuild_stack=kFALSE)Create all additional objects and stack (if specified).Definition THStack.cxx:715; THStack::GetMinimumvirtual Double_t GetMinimum(Option_t *option="""", Double_t minval=-std::numeric_limits< Double_t >::max())Returns the minimum of all added histograms larger than minval.Definition THStack.cxx:549; THStack::lsvoid ls(Option_t *option="""") const overrideList histograms in the stack.Definition THStack.cxx:658; THStack::",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
https://root.cern/doc/master/THStack_8cxx_source.html:50571,Integrability,message,message,50571,"(TObject *obj, Int_t idx) overrideAdd object at position ids.Definition TObjArray.cxx:254; TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjStringCollectable string class.Definition TObjString.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Clonevirtual TObject * Clone(const char *newname="""") constMake a clone of an object using the Streamer facility.Definition TObject.cxx:229; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetDrawOptionvirtual void SetDrawOption(Option_t *option="""")Set drawing option for object.Definition TObject.cxx:770; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2887; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TROOT::DecreaseDirLevelstatic Int_t DecreaseDirLevel()Decrease the indentation level for ls().Definition TROOT.cxx:2746; TSeqCollection::IndexOfvirtual Int_t IndexOf(const TObject *obj) constReturn index of object in collection.Definition T",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
https://root.cern/doc/master/THStack_8cxx_source.html:50828,Integrability,message,message,50828,"AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjStringCollectable string class.Definition TObjString.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Clonevirtual TObject * Clone(const char *newname="""") constMake a clone of an object using the Streamer facility.Definition TObject.cxx:229; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetDrawOptionvirtual void SetDrawOption(Option_t *option="""")Set drawing option for object.Definition TObject.cxx:770; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2887; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TROOT::DecreaseDirLevelstatic Int_t DecreaseDirLevel()Decrease the indentation level for ls().Definition TROOT.cxx:2746; TSeqCollection::IndexOfvirtual Int_t IndexOf(const TObject *obj) constReturn index of object in collection.Definition TSeqCollection.cxx:30; TSeqCollection::MergeLong64_t Merge(TCollection *list)Merge this collection with all collections coming in the input list.Definition TSeqCollection.cxx:185; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Lengt",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
https://root.cern/doc/master/THStack_8cxx_source.html:23099,Modifiability,inherit,inherit,23099,"== 1); 651 Warning(""GetZaxis"",""1D Histograms don't have a Z axis"");; 652 return h->GetZaxis();; 653}; 654 ; 655////////////////////////////////////////////////////////////////////////////////; 656/// List histograms in the stack.; 657 ; 658void THStack::ls(Option_t *option) const; 659{; 660 TROOT::IndentLevel();; 661 std::cout <<IsA()->GetName(); 662 <<"" Name= ""<<GetName()<<"" Title= ""<<GetTitle()<<"" Option=""<<option<<std::endl;; 663 TROOT::IncreaseDirLevel();; 664 if (fHists) fHists->ls(option);; 665 TROOT::DecreaseDirLevel();; 666}; 667////////////////////////////////////////////////////////////////////////////////; 668/// Merge the THStack in the TList into this stack.; 669/// Returns the total number of histograms in the result or -1 in case of an error.; 670 ; 671Long64_t THStack::Merge(TCollection* li, TFileMergeInfo * /* info */); 672{; 673 if (li==nullptr || li->GetEntries()==0) {; 674 return fHists->GetEntries();; 675 }; 676 TIter next(li);; 677 TList histLists;; 678 while (TObject* o = next()) {; 679 THStack *stack = dynamic_cast<THStack*> (o);; 680 if (!stack) {; 681 Error(""Merge"",; 682 ""Cannot merge - an object which doesn't inherit from THStack found in the list"");; 683 return -1;; 684 }; 685 histLists.Add(stack->GetHists());; 686 }; 687 fHists->Merge(&histLists);; 688 return fHists->GetEntries();; 689}; 690 ; 691////////////////////////////////////////////////////////////////////////////////; 692/// Note: this method invalidates the sum of histograms.; 693 ; 694void THStack::Modified(); 695{; 696 if (!fStack) return;; 697 fStack->Delete();; 698 delete fStack;; 699 fStack = nullptr;; 700 delete fHistogram;; 701 fHistogram = nullptr;; 702}; 703 ; 704////////////////////////////////////////////////////////////////////////////////; 705/// [Paint the list of histograms.](#HS00); 706 ; 707void THStack::Paint(Option_t *chopt); 708{; 709 BuildAndPaint(chopt, kTRUE);; 710}; 711 ; 712////////////////////////////////////////////////////////////////////////////////;",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
https://root.cern/doc/master/THStack_8cxx_source.html:40027,Modifiability,inherit,inherits,40027," for bin.Definition TAxis.cxx:886; TAxis::GetXbinsconst TArrayD * GetXbins() constDefinition TAxis.h:136; TAxis::GetLastInt_t GetLast() constReturn last bin on the axis i.e.Definition TAxis.cxx:469; TAxis::GetNbinsInt_t GetNbins() constDefinition TAxis.h:125; TAxis::SetRangevirtual void SetRange(Int_t first=0, Int_t last=0)Set the viewing range for the axis using bin numbers.Definition TAxis.cxx:1052; TAxis::GetFirstInt_t GetFirst() constReturn first bin on the axis i.e.Definition TAxis.cxx:458; TAxis::GetLabelsTHashList * GetLabels() constDefinition TAxis.h:121; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4982; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::lsvoid ls(Option_t *option="""") const overrideList (ls) all objects in this collection.Definition TCollection.cxx:382; TCollection::GetEntriesvirtual Int_t GetEntries() constDefinition TCollection.h:179; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TFileMergeInfoDefinition TFileMergeInfo.h:42; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::SetBarOffsetvirtual void SetBarOffset(Float_t offset=0.25)Set the bar off",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
https://root.cern/doc/master/THStack_8cxx_source.html:40165,Performance,load,load,40165," TAxis.cxx:469; TAxis::GetNbinsInt_t GetNbins() constDefinition TAxis.h:125; TAxis::SetRangevirtual void SetRange(Int_t first=0, Int_t last=0)Set the viewing range for the axis using bin numbers.Definition TAxis.cxx:1052; TAxis::GetFirstInt_t GetFirst() constReturn first bin on the axis i.e.Definition TAxis.cxx:458; TAxis::GetLabelsTHashList * GetLabels() constDefinition TAxis.h:121; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4982; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::lsvoid ls(Option_t *option="""") const overrideList (ls) all objects in this collection.Definition TCollection.cxx:382; TCollection::GetEntriesvirtual Int_t GetEntries() constDefinition TCollection.h:179; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TFileMergeInfoDefinition TFileMergeInfo.h:42; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::SetBarOffsetvirtual void SetBarOffset(Float_t offset=0.25)Set the bar offset as fraction of the bin width for drawing mode ""B"".Definition TH1.h:364; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
https://root.cern/doc/master/THStack_8cxx_source.html:2660,Safety,avoid,avoids,2660,"is painted; 49 - then the sum of the first and second histograms is painted, and so on; 50 ; 51The axis ranges are computed automatically along the X and Y axes to display the complete; 52histogram collection.; 53 ; 54Warning: Histogram bins with negative content may produce wrong plots.; 55 ; 56### Stack's drawing options; 57 ; 58The specific stack's drawing options are:; 59 ; 60 - **NOSTACK** If option ""nostack"" is specified, histograms are all painted in the same pad; 61 as if the option ""same"" had been specified.; 62 ; 63 - **NOSTACKB** If the option ""nostackb"" is specified histograms are all painted on the same pad; 64 next to each other as bar plots.; 65 ; 66 - **PADS** if option ""pads"" is specified, the current pad/canvas is subdivided into; 67 a number of pads equal to the number of histograms and each histogram; 68 is painted into a separate pad.; 69 ; 70 - **NOCLEAR** By default the background of the histograms is erased before drawing the; 71 histograms. The option ""noclear"" avoids this behavior. This is useful when drawing a; 72 THStack on top of another plot. If the patterns used to draw the histograms in the; 73 stack are transparent, then the plot behind will be visible.; 74 ; 75See the THistPainter class for the list of valid histograms' painting options.; 76 ; 77 ; 78Example;; 79 ; 80Begin_Macro(source); 81{; 82 auto hs = new THStack(""hs"","""");; 83 auto h1 = new TH1F(""h1"",""test hstack"",10,-4,4);; 84 h1->FillRandom(""gaus"",20000);; 85 h1->SetFillColor(kRed);; 86 hs->Add(h1);; 87 auto h2 = new TH1F(""h2"",""test hstack"",10,-4,4);; 88 h2->FillRandom(""gaus"",15000);; 89 h2->SetFillColor(kBlue);; 90 hs->Add(h2);; 91 auto h3 = new TH1F(""h3"",""test hstack"",10,-4,4);; 92 h3->FillRandom(""gaus"",10000);; 93 h3->SetFillColor(kGreen);; 94 hs->Add(h3);; 95 auto cs = new TCanvas(""cs"",""cs"",10,10,700,900);; 96 TText T; T.SetTextFont(42); T.SetTextAlign(21);; 97 cs->Divide(2,2);; 98 cs->cd(1); hs->Draw(); T.DrawTextNDC(.5,.95,""Default drawing option"");; 99 cs->cd(2); hs->Dra",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
https://root.cern/doc/master/THStack_8cxx_source.html:48030,Security,hash,hash,48030,"to draw the stack.Definition THStack.cxx:646; THStack::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition THStack.cxx:1031; THStack::Browsevoid Browse(TBrowser *b) overrideBrowse.Definition THStack.cxx:381; THStack::Classstatic TClass * Class(); THStack::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute distance from point px, py to each graph.Definition THStack.cxx:416; THStack::Modifiedvirtual void Modified()Note: this method invalidates the sum of histograms.Definition THStack.cxx:694; THStack::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Set minimum.Definition THStack.cxx:1090; THStack::GetXaxisTAxis * GetXaxis() constGet the x-axis of the histogram used to draw the stack.Definition THStack.cxx:620; THStack::fMaximumDouble_t fMaximumMaximum value for plotting along y.Definition THStack.h:48; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TList::Clearvoid Clear(Option_t *option="""") overrideRemove all objects from the list.Definition TList.cxx:400; TList::LastLinkvirtual TObjLink * LastLink() constDefinition TList.h:107; TList::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TList.cxx:762; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition TList.cxx:820; TList::FirstTObject * First() const overrideReturn the first object in the list. Returns 0 when list is empty.Definition TList.cxx:657; TList::FirstLinkvirtual TObjLink * FirstLink() constDefinition TList.h:104; TList::AtTObject * At(Int_t idx) const overrideReturns the object a",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
https://root.cern/doc/master/THStack_8cxx_source.html:3071,Testability,test,test,3071,"kb"" is specified histograms are all painted on the same pad; 64 next to each other as bar plots.; 65 ; 66 - **PADS** if option ""pads"" is specified, the current pad/canvas is subdivided into; 67 a number of pads equal to the number of histograms and each histogram; 68 is painted into a separate pad.; 69 ; 70 - **NOCLEAR** By default the background of the histograms is erased before drawing the; 71 histograms. The option ""noclear"" avoids this behavior. This is useful when drawing a; 72 THStack on top of another plot. If the patterns used to draw the histograms in the; 73 stack are transparent, then the plot behind will be visible.; 74 ; 75See the THistPainter class for the list of valid histograms' painting options.; 76 ; 77 ; 78Example;; 79 ; 80Begin_Macro(source); 81{; 82 auto hs = new THStack(""hs"","""");; 83 auto h1 = new TH1F(""h1"",""test hstack"",10,-4,4);; 84 h1->FillRandom(""gaus"",20000);; 85 h1->SetFillColor(kRed);; 86 hs->Add(h1);; 87 auto h2 = new TH1F(""h2"",""test hstack"",10,-4,4);; 88 h2->FillRandom(""gaus"",15000);; 89 h2->SetFillColor(kBlue);; 90 hs->Add(h2);; 91 auto h3 = new TH1F(""h3"",""test hstack"",10,-4,4);; 92 h3->FillRandom(""gaus"",10000);; 93 h3->SetFillColor(kGreen);; 94 hs->Add(h3);; 95 auto cs = new TCanvas(""cs"",""cs"",10,10,700,900);; 96 TText T; T.SetTextFont(42); T.SetTextAlign(21);; 97 cs->Divide(2,2);; 98 cs->cd(1); hs->Draw(); T.DrawTextNDC(.5,.95,""Default drawing option"");; 99 cs->cd(2); hs->Draw(""nostack""); T.DrawTextNDC(.5,.95,""Option \""nostack\"""");; 100 cs->cd(3); hs->Draw(""nostackb""); T.DrawTextNDC(.5,.95,""Option \""nostackb\"""");; 101 cs->cd(4); hs->Draw(""lego1""); T.DrawTextNDC(.5,.95,""Option \""lego1\"""");; 102}; 103End_Macro; 104 ; 105A more complex example:; 106 ; 107Begin_Macro(source); 108../../../tutorials/hist/hstack.C; 109End_Macro; 110 ; 111Note that picking is supported for all drawing modes.; 112 ; 113\since **ROOT version 6.07/07:**; 114Stacks of 2D histograms can also be painted as candle plots:; 115\since **ROOT version 6.09/02:**; 116St",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
https://root.cern/doc/master/THStack_8cxx_source.html:3202,Testability,test,test,3202,"kb"" is specified histograms are all painted on the same pad; 64 next to each other as bar plots.; 65 ; 66 - **PADS** if option ""pads"" is specified, the current pad/canvas is subdivided into; 67 a number of pads equal to the number of histograms and each histogram; 68 is painted into a separate pad.; 69 ; 70 - **NOCLEAR** By default the background of the histograms is erased before drawing the; 71 histograms. The option ""noclear"" avoids this behavior. This is useful when drawing a; 72 THStack on top of another plot. If the patterns used to draw the histograms in the; 73 stack are transparent, then the plot behind will be visible.; 74 ; 75See the THistPainter class for the list of valid histograms' painting options.; 76 ; 77 ; 78Example;; 79 ; 80Begin_Macro(source); 81{; 82 auto hs = new THStack(""hs"","""");; 83 auto h1 = new TH1F(""h1"",""test hstack"",10,-4,4);; 84 h1->FillRandom(""gaus"",20000);; 85 h1->SetFillColor(kRed);; 86 hs->Add(h1);; 87 auto h2 = new TH1F(""h2"",""test hstack"",10,-4,4);; 88 h2->FillRandom(""gaus"",15000);; 89 h2->SetFillColor(kBlue);; 90 hs->Add(h2);; 91 auto h3 = new TH1F(""h3"",""test hstack"",10,-4,4);; 92 h3->FillRandom(""gaus"",10000);; 93 h3->SetFillColor(kGreen);; 94 hs->Add(h3);; 95 auto cs = new TCanvas(""cs"",""cs"",10,10,700,900);; 96 TText T; T.SetTextFont(42); T.SetTextAlign(21);; 97 cs->Divide(2,2);; 98 cs->cd(1); hs->Draw(); T.DrawTextNDC(.5,.95,""Default drawing option"");; 99 cs->cd(2); hs->Draw(""nostack""); T.DrawTextNDC(.5,.95,""Option \""nostack\"""");; 100 cs->cd(3); hs->Draw(""nostackb""); T.DrawTextNDC(.5,.95,""Option \""nostackb\"""");; 101 cs->cd(4); hs->Draw(""lego1""); T.DrawTextNDC(.5,.95,""Option \""lego1\"""");; 102}; 103End_Macro; 104 ; 105A more complex example:; 106 ; 107Begin_Macro(source); 108../../../tutorials/hist/hstack.C; 109End_Macro; 110 ; 111Note that picking is supported for all drawing modes.; 112 ; 113\since **ROOT version 6.07/07:**; 114Stacks of 2D histograms can also be painted as candle plots:; 115\since **ROOT version 6.09/02:**; 116St",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
https://root.cern/doc/master/THStack_8cxx_source.html:3334,Testability,test,test,3334,"kb"" is specified histograms are all painted on the same pad; 64 next to each other as bar plots.; 65 ; 66 - **PADS** if option ""pads"" is specified, the current pad/canvas is subdivided into; 67 a number of pads equal to the number of histograms and each histogram; 68 is painted into a separate pad.; 69 ; 70 - **NOCLEAR** By default the background of the histograms is erased before drawing the; 71 histograms. The option ""noclear"" avoids this behavior. This is useful when drawing a; 72 THStack on top of another plot. If the patterns used to draw the histograms in the; 73 stack are transparent, then the plot behind will be visible.; 74 ; 75See the THistPainter class for the list of valid histograms' painting options.; 76 ; 77 ; 78Example;; 79 ; 80Begin_Macro(source); 81{; 82 auto hs = new THStack(""hs"","""");; 83 auto h1 = new TH1F(""h1"",""test hstack"",10,-4,4);; 84 h1->FillRandom(""gaus"",20000);; 85 h1->SetFillColor(kRed);; 86 hs->Add(h1);; 87 auto h2 = new TH1F(""h2"",""test hstack"",10,-4,4);; 88 h2->FillRandom(""gaus"",15000);; 89 h2->SetFillColor(kBlue);; 90 hs->Add(h2);; 91 auto h3 = new TH1F(""h3"",""test hstack"",10,-4,4);; 92 h3->FillRandom(""gaus"",10000);; 93 h3->SetFillColor(kGreen);; 94 hs->Add(h3);; 95 auto cs = new TCanvas(""cs"",""cs"",10,10,700,900);; 96 TText T; T.SetTextFont(42); T.SetTextAlign(21);; 97 cs->Divide(2,2);; 98 cs->cd(1); hs->Draw(); T.DrawTextNDC(.5,.95,""Default drawing option"");; 99 cs->cd(2); hs->Draw(""nostack""); T.DrawTextNDC(.5,.95,""Option \""nostack\"""");; 100 cs->cd(3); hs->Draw(""nostackb""); T.DrawTextNDC(.5,.95,""Option \""nostackb\"""");; 101 cs->cd(4); hs->Draw(""lego1""); T.DrawTextNDC(.5,.95,""Option \""lego1\"""");; 102}; 103End_Macro; 104 ; 105A more complex example:; 106 ; 107Begin_Macro(source); 108../../../tutorials/hist/hstack.C; 109End_Macro; 110 ; 111Note that picking is supported for all drawing modes.; 112 ; 113\since **ROOT version 6.07/07:**; 114Stacks of 2D histograms can also be painted as candle plots:; 115\since **ROOT version 6.09/02:**; 116St",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
https://root.cern/doc/master/THStack_8cxx_source.html:19064,Testability,log,logy,19064,">GetXaxis()->GetFirst(),; 531 fHistogram->GetXaxis()->GetLast());; 532 Double_t them = h->GetMaximum(maxval);; 533 if (them > themax); 534 themax = them;; 535 if (lerr); 536 check_error(h);; 537 if (fHistogram); 538 h->GetXaxis()->SetRange(0,0);; 539 }; 540 }; 541 ; 542 return themax;; 543}; 544 ; 545////////////////////////////////////////////////////////////////////////////////; 546/// Returns the minimum of all added histograms larger than minval.; 547/// Returns the minimum of all histograms, larger than minval, if option ""nostack"".; 548 ; 549Double_t THStack::GetMinimum(Option_t *option, Double_t minval); 550{; 551 if (!fHists) return 0;; 552 ; 553 TString opt = option;; 554 opt.ToLower();; 555 Bool_t lerr = opt.Contains(""e"");; 556 Bool_t logy = gPad ? gPad->GetLogy() : kFALSE;; 557 Double_t themin = std::numeric_limits<Double_t>::max();; 558 Int_t nhists = fHists->GetSize();; 559 ; 560 auto check_error = [logy, &themin](TH1 *h) {; 561 Int_t first = h->GetXaxis()->GetFirst();; 562 Int_t last = h->GetXaxis()->GetLast();; 563 for (Int_t j = first; j <= last; j++) {; 564 Double_t e1 = h->GetBinError(j);; 565 Double_t c1 = h->GetBinContent(j);; 566 if (!logy || (c1 - e1 > 0)); 567 themin = TMath::Min(themin, c1 - e1);; 568 }; 569 };; 570 ; 571 if (!opt.Contains(""nostack"")) {; 572 BuildStack();; 573 auto h = (TH1*)fStack->At(nhists-1);; 574 themin = h->GetMinimum(minval);; 575 if (themin <= 0 && logy); 576 themin = h->GetMinimum(0);; 577 if (lerr); 578 check_error(h);; 579 } else {; 580 for (Int_t i = 0; i < nhists; i++) {; 581 auto h = (TH1 *)fHists->At(i);; 582 Double_t them = h->GetMinimum(minval);; 583 if (them <= 0 && logy); 584 them = h->GetMinimum(0);; 585 if (them < themin); 586 themin = them;; 587 if (lerr); 588 check_error(h);; 589 }; 590 }; 591 ; 592 return themin;; 593}; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Return the number of histograms in the stack; 597 ; 598Int_t THStack::GetNhists() const; ",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
https://root.cern/doc/master/THStack_8cxx_source.html:19235,Testability,log,logy,19235,">GetXaxis()->GetFirst(),; 531 fHistogram->GetXaxis()->GetLast());; 532 Double_t them = h->GetMaximum(maxval);; 533 if (them > themax); 534 themax = them;; 535 if (lerr); 536 check_error(h);; 537 if (fHistogram); 538 h->GetXaxis()->SetRange(0,0);; 539 }; 540 }; 541 ; 542 return themax;; 543}; 544 ; 545////////////////////////////////////////////////////////////////////////////////; 546/// Returns the minimum of all added histograms larger than minval.; 547/// Returns the minimum of all histograms, larger than minval, if option ""nostack"".; 548 ; 549Double_t THStack::GetMinimum(Option_t *option, Double_t minval); 550{; 551 if (!fHists) return 0;; 552 ; 553 TString opt = option;; 554 opt.ToLower();; 555 Bool_t lerr = opt.Contains(""e"");; 556 Bool_t logy = gPad ? gPad->GetLogy() : kFALSE;; 557 Double_t themin = std::numeric_limits<Double_t>::max();; 558 Int_t nhists = fHists->GetSize();; 559 ; 560 auto check_error = [logy, &themin](TH1 *h) {; 561 Int_t first = h->GetXaxis()->GetFirst();; 562 Int_t last = h->GetXaxis()->GetLast();; 563 for (Int_t j = first; j <= last; j++) {; 564 Double_t e1 = h->GetBinError(j);; 565 Double_t c1 = h->GetBinContent(j);; 566 if (!logy || (c1 - e1 > 0)); 567 themin = TMath::Min(themin, c1 - e1);; 568 }; 569 };; 570 ; 571 if (!opt.Contains(""nostack"")) {; 572 BuildStack();; 573 auto h = (TH1*)fStack->At(nhists-1);; 574 themin = h->GetMinimum(minval);; 575 if (themin <= 0 && logy); 576 themin = h->GetMinimum(0);; 577 if (lerr); 578 check_error(h);; 579 } else {; 580 for (Int_t i = 0; i < nhists; i++) {; 581 auto h = (TH1 *)fHists->At(i);; 582 Double_t them = h->GetMinimum(minval);; 583 if (them <= 0 && logy); 584 them = h->GetMinimum(0);; 585 if (them < themin); 586 themin = them;; 587 if (lerr); 588 check_error(h);; 589 }; 590 }; 591 ; 592 return themin;; 593}; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Return the number of histograms in the stack; 597 ; 598Int_t THStack::GetNhists() const; ",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
https://root.cern/doc/master/THStack_8cxx_source.html:19483,Testability,log,logy,19483,">GetXaxis()->GetFirst(),; 531 fHistogram->GetXaxis()->GetLast());; 532 Double_t them = h->GetMaximum(maxval);; 533 if (them > themax); 534 themax = them;; 535 if (lerr); 536 check_error(h);; 537 if (fHistogram); 538 h->GetXaxis()->SetRange(0,0);; 539 }; 540 }; 541 ; 542 return themax;; 543}; 544 ; 545////////////////////////////////////////////////////////////////////////////////; 546/// Returns the minimum of all added histograms larger than minval.; 547/// Returns the minimum of all histograms, larger than minval, if option ""nostack"".; 548 ; 549Double_t THStack::GetMinimum(Option_t *option, Double_t minval); 550{; 551 if (!fHists) return 0;; 552 ; 553 TString opt = option;; 554 opt.ToLower();; 555 Bool_t lerr = opt.Contains(""e"");; 556 Bool_t logy = gPad ? gPad->GetLogy() : kFALSE;; 557 Double_t themin = std::numeric_limits<Double_t>::max();; 558 Int_t nhists = fHists->GetSize();; 559 ; 560 auto check_error = [logy, &themin](TH1 *h) {; 561 Int_t first = h->GetXaxis()->GetFirst();; 562 Int_t last = h->GetXaxis()->GetLast();; 563 for (Int_t j = first; j <= last; j++) {; 564 Double_t e1 = h->GetBinError(j);; 565 Double_t c1 = h->GetBinContent(j);; 566 if (!logy || (c1 - e1 > 0)); 567 themin = TMath::Min(themin, c1 - e1);; 568 }; 569 };; 570 ; 571 if (!opt.Contains(""nostack"")) {; 572 BuildStack();; 573 auto h = (TH1*)fStack->At(nhists-1);; 574 themin = h->GetMinimum(minval);; 575 if (themin <= 0 && logy); 576 themin = h->GetMinimum(0);; 577 if (lerr); 578 check_error(h);; 579 } else {; 580 for (Int_t i = 0; i < nhists; i++) {; 581 auto h = (TH1 *)fHists->At(i);; 582 Double_t them = h->GetMinimum(minval);; 583 if (them <= 0 && logy); 584 them = h->GetMinimum(0);; 585 if (them < themin); 586 themin = them;; 587 if (lerr); 588 check_error(h);; 589 }; 590 }; 591 ; 592 return themin;; 593}; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Return the number of histograms in the stack; 597 ; 598Int_t THStack::GetNhists() const; ",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
https://root.cern/doc/master/THStack_8cxx_source.html:19729,Testability,log,logy,19729,"ns(""e"");; 556 Bool_t logy = gPad ? gPad->GetLogy() : kFALSE;; 557 Double_t themin = std::numeric_limits<Double_t>::max();; 558 Int_t nhists = fHists->GetSize();; 559 ; 560 auto check_error = [logy, &themin](TH1 *h) {; 561 Int_t first = h->GetXaxis()->GetFirst();; 562 Int_t last = h->GetXaxis()->GetLast();; 563 for (Int_t j = first; j <= last; j++) {; 564 Double_t e1 = h->GetBinError(j);; 565 Double_t c1 = h->GetBinContent(j);; 566 if (!logy || (c1 - e1 > 0)); 567 themin = TMath::Min(themin, c1 - e1);; 568 }; 569 };; 570 ; 571 if (!opt.Contains(""nostack"")) {; 572 BuildStack();; 573 auto h = (TH1*)fStack->At(nhists-1);; 574 themin = h->GetMinimum(minval);; 575 if (themin <= 0 && logy); 576 themin = h->GetMinimum(0);; 577 if (lerr); 578 check_error(h);; 579 } else {; 580 for (Int_t i = 0; i < nhists; i++) {; 581 auto h = (TH1 *)fHists->At(i);; 582 Double_t them = h->GetMinimum(minval);; 583 if (them <= 0 && logy); 584 them = h->GetMinimum(0);; 585 if (them < themin); 586 themin = them;; 587 if (lerr); 588 check_error(h);; 589 }; 590 }; 591 ; 592 return themin;; 593}; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Return the number of histograms in the stack; 597 ; 598Int_t THStack::GetNhists() const; 599{; 600 if (fHists) return fHists->GetSize();; 601 return 0;; 602}; 603 ; 604////////////////////////////////////////////////////////////////////////////////; 605/// Return pointer to Stack. Build it if not yet done.; 606 ; 607TObjArray *THStack::GetStack(); 608{; 609 BuildStack();; 610 return fStack;; 611}; 612 ; 613////////////////////////////////////////////////////////////////////////////////; 614/// Get the x-axis of the histogram used to draw the stack.; 615///; 616/// IMPORTANT NOTE; 617/// You must call Draw before calling this function. The returned histogram; 618/// depends on the selected Draw options.; 619 ; 620TAxis *THStack::GetXaxis() const; 621{; 622 TH1 *h = GetHistogram();; 623 return h ? h->GetXaxis() :",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
https://root.cern/doc/master/THStack_8cxx_source.html:19961,Testability,log,logy,19961,"ns(""e"");; 556 Bool_t logy = gPad ? gPad->GetLogy() : kFALSE;; 557 Double_t themin = std::numeric_limits<Double_t>::max();; 558 Int_t nhists = fHists->GetSize();; 559 ; 560 auto check_error = [logy, &themin](TH1 *h) {; 561 Int_t first = h->GetXaxis()->GetFirst();; 562 Int_t last = h->GetXaxis()->GetLast();; 563 for (Int_t j = first; j <= last; j++) {; 564 Double_t e1 = h->GetBinError(j);; 565 Double_t c1 = h->GetBinContent(j);; 566 if (!logy || (c1 - e1 > 0)); 567 themin = TMath::Min(themin, c1 - e1);; 568 }; 569 };; 570 ; 571 if (!opt.Contains(""nostack"")) {; 572 BuildStack();; 573 auto h = (TH1*)fStack->At(nhists-1);; 574 themin = h->GetMinimum(minval);; 575 if (themin <= 0 && logy); 576 themin = h->GetMinimum(0);; 577 if (lerr); 578 check_error(h);; 579 } else {; 580 for (Int_t i = 0; i < nhists; i++) {; 581 auto h = (TH1 *)fHists->At(i);; 582 Double_t them = h->GetMinimum(minval);; 583 if (them <= 0 && logy); 584 them = h->GetMinimum(0);; 585 if (them < themin); 586 themin = them;; 587 if (lerr); 588 check_error(h);; 589 }; 590 }; 591 ; 592 return themin;; 593}; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Return the number of histograms in the stack; 597 ; 598Int_t THStack::GetNhists() const; 599{; 600 if (fHists) return fHists->GetSize();; 601 return 0;; 602}; 603 ; 604////////////////////////////////////////////////////////////////////////////////; 605/// Return pointer to Stack. Build it if not yet done.; 606 ; 607TObjArray *THStack::GetStack(); 608{; 609 BuildStack();; 610 return fStack;; 611}; 612 ; 613////////////////////////////////////////////////////////////////////////////////; 614/// Get the x-axis of the histogram used to draw the stack.; 615///; 616/// IMPORTANT NOTE; 617/// You must call Draw before calling this function. The returned histogram; 618/// depends on the selected Draw options.; 619 ; 620TAxis *THStack::GetXaxis() const; 621{; 622 TH1 *h = GetHistogram();; 623 return h ? h->GetXaxis() :",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
https://root.cern/doc/master/THStack_8cxx_source.html:54047,Testability,log,logarithm,54047,"NullBool_t IsNull() constDefinition TString.h:414; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::IsWhitespaceBool_t IsWhitespace() constDefinition TString.h:415; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TStyle::GetHistTopMarginDouble_t GetHistTopMargin() constDefinition TStyle.h:238; TVirtualHistPainter::SetStackvirtual void SetStack(TList *stack)=0; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualPad::GetListOfPrimitivesvirtual TList * GetListOfPrimitives() const =0; TVirtualPad::cdvirtual TVirtualPad * cd(Int_t subpadnumber=0)=0; TVirtualPad::GetPadvirtual TVirtualPad * GetPad(Int_t subpadnumber) const =0; TVirtualPad::Dividevirtual void Divide(Int_t nx=1, Int_t ny=1, Float_t xmargin=0.01, Float_t ymargin=0.01, Int_t color=0)=0; TVirtualPad::Classstatic TClass * Class(); TVirtualPad::Clearvoid Clear(Option_t *option="""") override=0; bool; double; int; c1return c1Definition legend1.C:41; h1TH1F * h1Definition legend1.C:5; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; Drawth1 Draw(). histhistsrcTHStack.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:32747,Availability,avail,available,32747,"OTSYS + ""/files/online.htm"").Data());; 998 ; 999 } else {; 1000 auto wsptr = FindWS(arg->GetPathName());; 1001 ; 1002 auto handler = wsptr.get();; 1003 ; 1004 if (!handler); 1005 handler = dynamic_cast<THttpWSHandler *>(fSniffer->FindTObjectInHierarchy(arg->fPathName.Data()));; 1006 ; 1007 if (handler) {; 1008 ; 1009 arg->fContent = handler->GetDefaultPageContent().Data();; 1010 ; 1011 if (arg->fContent.find(""file:"") == 0) {; 1012 const char *fname = arg->fContent.c_str() + 5;; 1013 TString resolve;; 1014 if (!IsFileRequested(fname, resolve)) resolve = fname;; 1015 arg->fContent = ReadFileContent(resolve.Data());; 1016 }; 1017 ; 1018 version = handler->GetCodeVersion();; 1019 ; 1020 handler->VerifyDefaultPageContent(arg);; 1021 }; 1022 }; 1023 ; 1024 if (arg->fContent.empty() && arg->fFileName.IsNull() && arg->fPathName.IsNull() && IsWSOnly()) {; 1025 // Creating page with list of available widgets is disabled now for security reasons; 1026 // Later one can provide functionality back only if explicitly desired by the user; 1027 // BuildWSEntryPage();; 1028 ; 1029 arg->SetContent(""refused"");; 1030 arg->Set404();; 1031 }; 1032 ; 1033 if (arg->fContent.empty() && !IsWSOnly()) {; 1034 ; 1035 if (fDefaultPageCont.empty()); 1036 fDefaultPageCont = ReadFileContent(fDefaultPage);; 1037 ; 1038 arg->fContent = fDefaultPageCont;; 1039 }; 1040 ; 1041 if (arg->fContent.empty()) {; 1042 ; 1043 arg->Set404();; 1044 } else if (!arg->Is404()) {; 1045 ; 1046 ReplaceJSROOTLinks(arg, version);; 1047 ; 1048 const char *hjsontag = ""\""$$$h.json$$$\"""";; 1049 ; 1050 // add h.json caching; 1051 if (arg->fContent.find(hjsontag) != std::string::npos) {; 1052 TString h_json;; 1053 TRootSnifferStoreJson store(h_json, kTRUE);; 1054 const char *topname = fTopName.Data();; 1055 if (arg->fTopName.Length() > 0); 1056 topname = arg->fTopName.Data();; 1057 fSniffer->ScanHierarchy(topname, arg->fPathName.Data(), &store);; 1058 ; 1059 arg->ReplaceAllinContent(hjsontag, h_json.Data());; 1060 ; 1061 arg->A",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:56211,Availability,error,error,56211,"1; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5816; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TFastCgiTHttpEngine implementation, based on fastcgi package.Definition TFastCgi.h:20; THttpCallArgContains arguments for single HTTP call.Definition THttpCallArg.h:27; THttpCallArg::Set404void Set404()mark reply as 404 error - page/request not exists or refusedDefinition THttpCallArg.h:163; THttpCallArg::kZipAlways@ kZipAlwaysDefinition THttpCallArg.h:38; THttpEngineAbstract class for implementing http protocol for THttpServer.Definition THttpEngine.h:19; THttpEngine::SetServervoid SetServer(THttpServer *serv)Definition THttpEngine.h:27; THttpEngine::Createvirtual Bool_t Create(const char *)Method to create all components of engine.Definition THttpEngine.h:37; THttpLongPollEngineEmulation of websocket with long poll requests.Definition THttpLongPollEngine.h:23; THttpServerOnline http server for arbitrary ROOT application.Definition THttpServer.h:31; THttpServer::IsReadOnlyBool_t IsReadOnly() constreturns read-only modeDefinition THttpServer.cxx:285; THttpServer::RegisterCommandBool_t RegisterCommand(const char *cmdname, const char *method, const char *icon=nullptr)Register command which can be executed from web interface.Definition THttpServer.cxx:1428; THttpServer::fJSROOTTString fJSROOT! location of ext",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:68103,Availability,error,error,68103,"ion THttpWSHandler.h:79; TIterDefinition TCollection.h:235; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::GetLastInt_t GetLast() const overrideReturn index of last object in array.Definition TObjArray.cxx:577; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::GetRootSysstatic const TString & GetRootSys()Get the rootsys directory in the installation. Static utility function.Definition TROOT.cxx:2983; TROOT::GetDataDirstatic const TString & GetDataDir()Get the data directory in the installation. Static utility function.Definition TROOT.cxx:3066; TRootSnifferStoreJsonStorage of hierarchy scan in TRootSniffer in JSON format.Definition TRootSnifferStore.h:79; TRootSnifferStoreXmlStorage of hierarchy scan in TRootSniffer in XML format.Definition TRootSnifferStore.h:55; TRootSnifferSniffer of ROOT objects, data provider for THttpServer.Definition TRootSniffer.h:115; TRootSniffer::CreateOwnTopFoldervoid CreateOwnTopFolder()Create own TFolder structures independent from gROOT This allows to have many independent TRootSniffe...Definition TRootSniffer.cxx:913; TRootSniffer::SetReadOnlyvoid SetReadOnly(Bool_t on=kTRUE)When readonly on (default), sniffer is not allowed to change ROOT structures For instanc",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:3651,Deployability,update,updated,3651,"ipt user interface.; 95Any registered object can be requested and displayed in the browser.; 96There are many benefits of such approach:; 97 ; 981. standard http interface to ROOT application; 992. no any temporary ROOT files when access data; 1003. user interface running in all browsers; 101 ; 102To start http server simply create instance; 103of the THttpServer class like:; 104 ; 105 serv = new THttpServer(""http:8080"");; 106 ; 107This will starts civetweb-based http server with http port 8080.; 108Than one should be able to open address ""http://localhost:8080""; 109in any modern web browser (Firefox, Chrome, Opera, ...) and browse objects,; 110created in ROOT application. By default, server can access files,; 111canvases and histograms via `gROOT` pointer. All such objects; 112can be displayed with JSROOT graphics.; 113 ; 114At any time one could register other objects with the command:; 115 ; 116 TGraph* gr = new TGraph(10);; 117 gr->SetName(""gr1"");; 118 serv->Register(""graphs/subfolder"", gr);; 119 ; 120If objects content is changing in the application, one could; 121enable monitoring flag in the browser - than objects view; 122will be regularly updated.; 123 ; 124More information: https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html; 125*/; 126 ; 127ClassImp(THttpServer);; 128 ; 129////////////////////////////////////////////////////////////////////////////////; 130/// constructor; 131///; 132/// As argument, one specifies engine kind which should be; 133/// created like ""http:8080"". One could specify several engines; 134/// at once, separating them with semicolon ("";""). Following engines are supported:; 135///; 136/// http - TCivetweb, civetweb-based implementation of http protocol; 137/// fastcgi - TFastCgi, special protocol for communicating with web servers; 138///; 139/// For each created engine one should provide socket port number like ""http:8080"" or ""fastcgi:9000"".; 140/// Additional engine-specific options can be supplied with URL syntax like ",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:26416,Deployability,install,installation,26416,"ng arr = ""["";; 816 ; 817 {; 818 std::lock_guard<std::mutex> grd(fWSMutex);; 819 for (auto &ws : fWSHandlers) {; 820 if (arr.length() > 1); 821 arr.append("", "");; 822 ; 823 arr.append(TString::Format(""{ name: \""%s\"", title: \""%s\"" }"", ws->GetName(), ws->GetTitle()).Data());; 824 }; 825 }; 826 ; 827 arr.append(""]"");; 828 ; 829 std::string res = ReadFileContent((TROOT::GetDataDir() + ""/js/files/wslist.htm"").Data());; 830 ; 831 std::string arg = ""\""$$$wslist$$$\"""";; 832 ; 833 auto pos = res.find(arg);; 834 if (pos != std::string::npos); 835 res.replace(pos, arg.length(), arr);; 836 ; 837 return res;; 838}; 839 ; 840////////////////////////////////////////////////////////////////////////////////; 841/// Replaces all references like ""jsrootsys/..."" or other pre-configured pathes; 842///; 843/// Either using pre-configured JSROOT installation from web or; 844/// redirect to jsrootsys from the main server path to benefit from browser caching; 845/// Creates appropriate importmap instead of <!--jsroot_importmap--> placeholder; 846 ; 847void THttpServer::ReplaceJSROOTLinks(std::shared_ptr<THttpCallArg> &arg, const std::string &version); 848{; 849 const std::string place_holder = ""<!--jsroot_importmap-->"";; 850 ; 851 auto p = arg->fContent.find(place_holder);; 852 ; 853 bool old_format = (p == std::string::npos);; 854 ; 855 // count slashes to handler relative paths to jsroot; 856 Int_t slash_cnt = 0;; 857 if (arg->fPathName.Length() > 0); 858 slash_cnt++;; 859 for (Int_t n = 1; n < arg->fPathName.Length()-1; ++n); 860 if (arg->fPathName[n] == '/') {; 861 if (arg->fPathName[n-1] != '/') {; 862 slash_cnt++; // normal slash in the middle, count it; 863 } else {; 864 slash_cnt = 0; // double slash, do not touch such path; 865 break;; 866 }; 867 }; 868 ; 869 ; 870 if (old_format) {; 871 // old functionality; 872 ; 873 if (!version.empty()) {; 874 // replace link to JSROOT modules in import statements emulating new version for browser; 875 std::string search = ""from './jsrootsys/"";",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:68230,Deployability,install,installation,68230," *obj) overrideDefinition TList.h:83; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::GetLastInt_t GetLast() const overrideReturn index of last object in array.Definition TObjArray.cxx:577; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::GetRootSysstatic const TString & GetRootSys()Get the rootsys directory in the installation. Static utility function.Definition TROOT.cxx:2983; TROOT::GetDataDirstatic const TString & GetDataDir()Get the data directory in the installation. Static utility function.Definition TROOT.cxx:3066; TRootSnifferStoreJsonStorage of hierarchy scan in TRootSniffer in JSON format.Definition TRootSnifferStore.h:79; TRootSnifferStoreXmlStorage of hierarchy scan in TRootSniffer in XML format.Definition TRootSnifferStore.h:55; TRootSnifferSniffer of ROOT objects, data provider for THttpServer.Definition TRootSniffer.h:115; TRootSniffer::CreateOwnTopFoldervoid CreateOwnTopFolder()Create own TFolder structures independent from gROOT This allows to have many independent TRootSniffe...Definition TRootSniffer.cxx:913; TRootSniffer::SetReadOnlyvoid SetReadOnly(Bool_t on=kTRUE)When readonly on (default), sniffer is not allowed to change ROOT structures For instance,...Definition TRootSniffer.h:190; TRootSniffer::SetScanGlobalDirvoid SetScanGlobalDi",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:68377,Deployability,install,installation,68377,"ed objects.Definition TList.cxx:468; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::GetLastInt_t GetLast() const overrideReturn index of last object in array.Definition TObjArray.cxx:577; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::GetRootSysstatic const TString & GetRootSys()Get the rootsys directory in the installation. Static utility function.Definition TROOT.cxx:2983; TROOT::GetDataDirstatic const TString & GetDataDir()Get the data directory in the installation. Static utility function.Definition TROOT.cxx:3066; TRootSnifferStoreJsonStorage of hierarchy scan in TRootSniffer in JSON format.Definition TRootSnifferStore.h:79; TRootSnifferStoreXmlStorage of hierarchy scan in TRootSniffer in XML format.Definition TRootSnifferStore.h:55; TRootSnifferSniffer of ROOT objects, data provider for THttpServer.Definition TRootSniffer.h:115; TRootSniffer::CreateOwnTopFoldervoid CreateOwnTopFolder()Create own TFolder structures independent from gROOT This allows to have many independent TRootSniffe...Definition TRootSniffer.cxx:913; TRootSniffer::SetReadOnlyvoid SetReadOnly(Bool_t on=kTRUE)When readonly on (default), sniffer is not allowed to change ROOT structures For instance,...Definition TRootSniffer.h:190; TRootSniffer::SetScanGlobalDirvoid SetScanGlobalDir(Bool_t on=kTRUE)When enabled (default), sniffer scans gROOT for files, canvases, histograms.Definition TRootSniffer.h:206; TStringBasic string cla",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:3578,Energy Efficiency,monitor,monitoring,3578,"ipt user interface.; 95Any registered object can be requested and displayed in the browser.; 96There are many benefits of such approach:; 97 ; 981. standard http interface to ROOT application; 992. no any temporary ROOT files when access data; 1003. user interface running in all browsers; 101 ; 102To start http server simply create instance; 103of the THttpServer class like:; 104 ; 105 serv = new THttpServer(""http:8080"");; 106 ; 107This will starts civetweb-based http server with http port 8080.; 108Than one should be able to open address ""http://localhost:8080""; 109in any modern web browser (Firefox, Chrome, Opera, ...) and browse objects,; 110created in ROOT application. By default, server can access files,; 111canvases and histograms via `gROOT` pointer. All such objects; 112can be displayed with JSROOT graphics.; 113 ; 114At any time one could register other objects with the command:; 115 ; 116 TGraph* gr = new TGraph(10);; 117 gr->SetName(""gr1"");; 118 serv->Register(""graphs/subfolder"", gr);; 119 ; 120If objects content is changing in the application, one could; 121enable monitoring flag in the browser - than objects view; 122will be regularly updated.; 123 ; 124More information: https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html; 125*/; 126 ; 127ClassImp(THttpServer);; 128 ; 129////////////////////////////////////////////////////////////////////////////////; 130/// constructor; 131///; 132/// As argument, one specifies engine kind which should be; 133/// created like ""http:8080"". One could specify several engines; 134/// at once, separating them with semicolon ("";""). Following engines are supported:; 135///; 136/// http - TCivetweb, civetweb-based implementation of http protocol; 137/// fastcgi - TFastCgi, special protocol for communicating with web servers; 138///; 139/// For each created engine one should provide socket port number like ""http:8080"" or ""fastcgi:9000"".; 140/// Additional engine-specific options can be supplied with URL syntax like ",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:11525,Energy Efficiency,reduce,reduce,11525,"8/// serv->AddLocation(""mydir/"", ""/home/user/specials"");; 329///; 330/// Than files from this directory could be addressed via server like `http://localhost:8080/mydir/myfile.root`; 331 ; 332void THttpServer::AddLocation(const char *prefix, const char *path); 333{; 334 if (!prefix || (*prefix == 0)); 335 return;; 336 ; 337 if (!path); 338 fLocations.erase(fLocations.find(prefix));; 339 else; 340 fLocations[prefix] = path;; 341}; 342 ; 343////////////////////////////////////////////////////////////////////////////////; 344/// Set location of JSROOT to use with the server; 345///; 346/// One could specify address like:; 347///; 348/// * https://root.cern/js/7.6.0/; 349/// * https://jsroot.gsi.de/7.6.0/; 350///; 351/// This allows to get new JSROOT features with old server,; 352/// reduce load on THttpServer instance, also startup time can be improved; 353/// When empty string specified (default), local copy of JSROOT is used (distributed with ROOT); 354 ; 355void THttpServer::SetJSROOT(const char *location); 356{; 357 fJSROOT = location ? location : """";; 358}; 359 ; 360////////////////////////////////////////////////////////////////////////////////; 361/// Set default HTML page; 362///; 363/// Sets file name, delivered by the server when http address is opened in the browser.; 364///; 365/// By default, $ROOTSYS/js/files/online.htm page is used; 366/// When empty filename is specified, default page will be used; 367 ; 368void THttpServer::SetDefaultPage(const std::string &filename); 369{; 370 if (!filename.empty()); 371 fDefaultPage = filename;; 372 else; 373 fDefaultPage = fJSROOTSYS + ""/files/online.htm"";; 374 ; 375 // force to read page content next time again; 376 fDefaultPageCont.clear();; 377}; 378 ; 379////////////////////////////////////////////////////////////////////////////////; 380/// Set drawing HTML page; 381///; 382/// Set file name of HTML page, delivered by the server when; 383/// objects drawing page is requested from the browser; 384/// By default, $",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:55442,Energy Efficiency,allocate,allocated,55442,"Win32VirtualXProxy.cxx:68; namechar name[80]Definition TGX11.cxx:110; THttpEngine.h; THttpLongPollEngine.h; THttpServer.h; THttpWSHandler.h; TObjArray.h; gDebugInt_t gDebugDefinition TROOT.cxx:597; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TRegexp.h; TRootSnifferStore.h; TRootSniffer.h; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TThread.h; TTimer.h; TUrl.h; mime_typeconst char * mime_typeDefinition civetweb.c:8027; ext_lensize_t ext_lenDefinition civetweb.c:8026; free#define freeDefinition civetweb.c:1539; extensionconst char * extensionDefinition civetweb.c:8025; builtin_mime_typesstatic const struct @142 builtin_mime_types[]; malloc#define mallocDefinition civetweb.c:1536; TCivetwebTHttpEngine implementation, based on civetweb embedded server.Definition TCivetweb.h:21; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5816; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TFastCgiTHttpEngine implementation, based on fastcgi package.Definition TFastCgi.h:20; THttpCallArgContains arguments for single HTTP call.Definition THttpCallArg.h:27; THttpCallArg::Set404void Set404()mark reply as 404 error - page/request not exists or refusedDefinition THttpCallArg.h:163; THttpCallArg::kZipAlways@ kZipAlwaysDefinition THttpCallArg.h:38; THttpEngineAbstract class for implementing http p",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:58665,Energy Efficiency,allocate,allocated,58665," ROOT objects hierarchyDefinition THttpServer.h:36; THttpServer::SetTimervoid SetTimer(Long_t milliSec=100, Bool_t mode=kTRUE)Create timer which will invoke ProcessRequests() function periodically.Definition THttpServer.cxx:490; THttpServer::ProcessBatchHoldervirtual void ProcessBatchHolder(std::shared_ptr< THttpCallArg > &arg)Process special http request for root_batch_holder.js script.Definition THttpServer.cxx:799; THttpServer::fWSHandlersstd::vector< std::shared_ptr< THttpWSHandler > > fWSHandlers! list of WS handlersDefinition THttpServer.h:61; THttpServer::~THttpServervirtual ~THttpServer()destructorDefinition THttpServer.cxx:245; THttpServer::SetTerminatevoid SetTerminate()set termination flag, no any further requests will be processedDefinition THttpServer.cxx:277; THttpServer::MissedRequestvirtual void MissedRequest(THttpCallArg *arg)Method called when THttpServer cannot process request.Definition THttpServer.cxx:788; THttpServer::fOwnThreadBool_t fOwnThread! true when specialized thread allocated for processing requestsDefinition THttpServer.h:40; THttpServer::SetSniffervoid SetSniffer(TRootSniffer *sniff)Set TRootSniffer to the server.Definition THttpServer.cxx:267; THttpServer::IsFileRequestedBool_t IsFileRequested(const char *uri, TString &res) constCheck if file is requested, thread safe.Definition THttpServer.cxx:612; THttpServer::SetReadOnlyvoid SetReadOnly(Bool_t readonly=kTRUE)Set read-only mode for the server (default on)Definition THttpServer.cxx:296; THttpServer::GetItemFieldconst char * GetItemField(const char *fullname, const char *name)Get item field from sniffer.Definition THttpServer.cxx:1471; THttpServer::GetCorsconst char * GetCors() constReturns specified CORS domain.Definition THttpServer.h:115; THttpServer::fThrdstd::thread fThrd! own threadDefinition THttpServer.h:41; THttpServer::StopServerThreadvoid StopServerThread()Stop server thread.Definition THttpServer.cxx:547; THttpServer::ProcessRequestsInt_t ProcessRequests()Process submitt",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:2494,Integrability,interface,interface,2494,"THttpTimer : public TTimer {; 43 Long_t fNormalTmout{0};; 44 Bool_t fSlow{kFALSE};; 45 Int_t fSlowCnt{0};; 46 ; 47public:; 48 THttpServer &fServer; ///!< server processing requests; 49 ; 50 /// constructor; 51 THttpTimer(Long_t milliSec, Bool_t mode, THttpServer &serv) : TTimer(milliSec, mode), fNormalTmout(milliSec), fServer(serv) {}; 52 ; 53 void SetSlow(Bool_t flag); 54 {; 55 fSlow = flag;; 56 fSlowCnt = 0;; 57 Long_t ms = fNormalTmout;; 58 if (fSlow) {; 59 if (ms < 100); 60 ms = 500;; 61 else if (ms < 500); 62 ms = 3000;; 63 else; 64 ms = 10000;; 65 }; 66 ; 67 SetTime(ms);; 68 }; 69 Bool_t IsSlow() const { return fSlow; }; 70 ; 71 /// timeout handler; 72 /// used to process http requests in main ROOT thread; 73 void Timeout() override; 74 {; 75 Int_t nprocess = fServer.ProcessRequests();; 76 ; 77 if (nprocess > 0) {; 78 fSlowCnt = 0;; 79 if (IsSlow()); 80 SetSlow(kFALSE);; 81 } else if (!IsSlow() && (fSlowCnt++ > 10)) {; 82 SetSlow(kTRUE);; 83 }; 84 }; 85};; 86 ; 87 ; 88/** \class THttpServer; 89\ingroup http; 90 ; 91Online http server for arbitrary ROOT application; 92 ; 93Idea of THttpServer - provide remote http access to running; 94ROOT application and enable HTML/JavaScript user interface.; 95Any registered object can be requested and displayed in the browser.; 96There are many benefits of such approach:; 97 ; 981. standard http interface to ROOT application; 992. no any temporary ROOT files when access data; 1003. user interface running in all browsers; 101 ; 102To start http server simply create instance; 103of the THttpServer class like:; 104 ; 105 serv = new THttpServer(""http:8080"");; 106 ; 107This will starts civetweb-based http server with http port 8080.; 108Than one should be able to open address ""http://localhost:8080""; 109in any modern web browser (Firefox, Chrome, Opera, ...) and browse objects,; 110created in ROOT application. By default, server can access files,; 111canvases and histograms via `gROOT` pointer. All such objects; 112can be display",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:2647,Integrability,interface,interface,2647,"); 54 {; 55 fSlow = flag;; 56 fSlowCnt = 0;; 57 Long_t ms = fNormalTmout;; 58 if (fSlow) {; 59 if (ms < 100); 60 ms = 500;; 61 else if (ms < 500); 62 ms = 3000;; 63 else; 64 ms = 10000;; 65 }; 66 ; 67 SetTime(ms);; 68 }; 69 Bool_t IsSlow() const { return fSlow; }; 70 ; 71 /// timeout handler; 72 /// used to process http requests in main ROOT thread; 73 void Timeout() override; 74 {; 75 Int_t nprocess = fServer.ProcessRequests();; 76 ; 77 if (nprocess > 0) {; 78 fSlowCnt = 0;; 79 if (IsSlow()); 80 SetSlow(kFALSE);; 81 } else if (!IsSlow() && (fSlowCnt++ > 10)) {; 82 SetSlow(kTRUE);; 83 }; 84 }; 85};; 86 ; 87 ; 88/** \class THttpServer; 89\ingroup http; 90 ; 91Online http server for arbitrary ROOT application; 92 ; 93Idea of THttpServer - provide remote http access to running; 94ROOT application and enable HTML/JavaScript user interface.; 95Any registered object can be requested and displayed in the browser.; 96There are many benefits of such approach:; 97 ; 981. standard http interface to ROOT application; 992. no any temporary ROOT files when access data; 1003. user interface running in all browsers; 101 ; 102To start http server simply create instance; 103of the THttpServer class like:; 104 ; 105 serv = new THttpServer(""http:8080"");; 106 ; 107This will starts civetweb-based http server with http port 8080.; 108Than one should be able to open address ""http://localhost:8080""; 109in any modern web browser (Firefox, Chrome, Opera, ...) and browse objects,; 110created in ROOT application. By default, server can access files,; 111canvases and histograms via `gROOT` pointer. All such objects; 112can be displayed with JSROOT graphics.; 113 ; 114At any time one could register other objects with the command:; 115 ; 116 TGraph* gr = new TGraph(10);; 117 gr->SetName(""gr1"");; 118 serv->Register(""graphs/subfolder"", gr);; 119 ; 120If objects content is changing in the application, one could; 121enable monitoring flag in the browser - than objects view; 122will be regularly update",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:2740,Integrability,interface,interface,2740,"etTime(ms);; 68 }; 69 Bool_t IsSlow() const { return fSlow; }; 70 ; 71 /// timeout handler; 72 /// used to process http requests in main ROOT thread; 73 void Timeout() override; 74 {; 75 Int_t nprocess = fServer.ProcessRequests();; 76 ; 77 if (nprocess > 0) {; 78 fSlowCnt = 0;; 79 if (IsSlow()); 80 SetSlow(kFALSE);; 81 } else if (!IsSlow() && (fSlowCnt++ > 10)) {; 82 SetSlow(kTRUE);; 83 }; 84 }; 85};; 86 ; 87 ; 88/** \class THttpServer; 89\ingroup http; 90 ; 91Online http server for arbitrary ROOT application; 92 ; 93Idea of THttpServer - provide remote http access to running; 94ROOT application and enable HTML/JavaScript user interface.; 95Any registered object can be requested and displayed in the browser.; 96There are many benefits of such approach:; 97 ; 981. standard http interface to ROOT application; 992. no any temporary ROOT files when access data; 1003. user interface running in all browsers; 101 ; 102To start http server simply create instance; 103of the THttpServer class like:; 104 ; 105 serv = new THttpServer(""http:8080"");; 106 ; 107This will starts civetweb-based http server with http port 8080.; 108Than one should be able to open address ""http://localhost:8080""; 109in any modern web browser (Firefox, Chrome, Opera, ...) and browse objects,; 110created in ROOT application. By default, server can access files,; 111canvases and histograms via `gROOT` pointer. All such objects; 112can be displayed with JSROOT graphics.; 113 ; 114At any time one could register other objects with the command:; 115 ; 116 TGraph* gr = new TGraph(10);; 117 gr->SetName(""gr1"");; 118 serv->Register(""graphs/subfolder"", gr);; 119 ; 120If objects content is changing in the application, one could; 121enable monitoring flag in the browser - than objects view; 122will be regularly updated.; 123 ; 124More information: https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html; 125*/; 126 ; 127ClassImp(THttpServer);; 128 ; 129/////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:4203,Integrability,protocol,protocol,4203,". All such objects; 112can be displayed with JSROOT graphics.; 113 ; 114At any time one could register other objects with the command:; 115 ; 116 TGraph* gr = new TGraph(10);; 117 gr->SetName(""gr1"");; 118 serv->Register(""graphs/subfolder"", gr);; 119 ; 120If objects content is changing in the application, one could; 121enable monitoring flag in the browser - than objects view; 122will be regularly updated.; 123 ; 124More information: https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html; 125*/; 126 ; 127ClassImp(THttpServer);; 128 ; 129////////////////////////////////////////////////////////////////////////////////; 130/// constructor; 131///; 132/// As argument, one specifies engine kind which should be; 133/// created like ""http:8080"". One could specify several engines; 134/// at once, separating them with semicolon ("";""). Following engines are supported:; 135///; 136/// http - TCivetweb, civetweb-based implementation of http protocol; 137/// fastcgi - TFastCgi, special protocol for communicating with web servers; 138///; 139/// For each created engine one should provide socket port number like ""http:8080"" or ""fastcgi:9000"".; 140/// Additional engine-specific options can be supplied with URL syntax like ""http:8080?thrds=10"".; 141/// Full list of supported options should be checked in engines docu.; 142///; 143/// One also can configure following options, separated by semicolon:; 144///; 145/// readonly, ro - set read-only mode (default); 146/// readwrite, rw - allows methods execution of registered objects; 147/// global - scans global ROOT lists for existing objects (default); 148/// noglobal - disable scan of global lists; 149/// cors - enable CORS header with origin=""*""; 150/// cors=domain - enable CORS header with origin=""domain""; 151/// basic_sniffer - use basic sniffer without support of hist, gpad, graph classes; 152///; 153/// For example, create http server, which allows cors headers and disable scan of global lists,; 154/// one should provide """,MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:4248,Integrability,protocol,protocol,4248,". All such objects; 112can be displayed with JSROOT graphics.; 113 ; 114At any time one could register other objects with the command:; 115 ; 116 TGraph* gr = new TGraph(10);; 117 gr->SetName(""gr1"");; 118 serv->Register(""graphs/subfolder"", gr);; 119 ; 120If objects content is changing in the application, one could; 121enable monitoring flag in the browser - than objects view; 122will be regularly updated.; 123 ; 124More information: https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html; 125*/; 126 ; 127ClassImp(THttpServer);; 128 ; 129////////////////////////////////////////////////////////////////////////////////; 130/// constructor; 131///; 132/// As argument, one specifies engine kind which should be; 133/// created like ""http:8080"". One could specify several engines; 134/// at once, separating them with semicolon ("";""). Following engines are supported:; 135///; 136/// http - TCivetweb, civetweb-based implementation of http protocol; 137/// fastcgi - TFastCgi, special protocol for communicating with web servers; 138///; 139/// For each created engine one should provide socket port number like ""http:8080"" or ""fastcgi:9000"".; 140/// Additional engine-specific options can be supplied with URL syntax like ""http:8080?thrds=10"".; 141/// Full list of supported options should be checked in engines docu.; 142///; 143/// One also can configure following options, separated by semicolon:; 144///; 145/// readonly, ro - set read-only mode (default); 146/// readwrite, rw - allows methods execution of registered objects; 147/// global - scans global ROOT lists for existing objects (default); 148/// noglobal - disable scan of global lists; 149/// cors - enable CORS header with origin=""*""; 150/// cors=domain - enable CORS header with origin=""domain""; 151/// basic_sniffer - use basic sniffer without support of hist, gpad, graph classes; 152///; 153/// For example, create http server, which allows cors headers and disable scan of global lists,; 154/// one should provide """,MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:44500,Integrability,interface,interface,44500," 1346 ; 1347 if (handler->HandleWS(arg)) {; 1348 arg->SetMethod(""WS_READY"");; 1349 ; 1350 if (handler->HandleWS(arg)); 1351 arg->SetTextContent(std::string(israw ? ""txt:"" : """") + std::to_string(arg->GetWSId()));; 1352 } else {; 1353 arg->TakeWSEngine(); // delete handle; 1354 }; 1355 ; 1356 process = arg->IsText();; 1357 } else {; 1358 TUrl url;; 1359 url.SetOptions(arg->fQuery);; 1360 url.ParseOptions();; 1361 const char *connid = url.GetValueFromOptions(""connection"");; 1362 if (connid); 1363 arg->SetWSId(std::stoul(connid));; 1364 if (url.HasOption(""close"")) {; 1365 arg->SetMethod(""WS_CLOSE"");; 1366 arg->SetTextContent(""OK"");; 1367 } else {; 1368 arg->SetMethod(""WS_DATA"");; 1369 }; 1370 ; 1371 process = handler->HandleWS(arg);; 1372 }; 1373 }; 1374 ; 1375 if (!process); 1376 arg->Set404();; 1377 ; 1378 return process;; 1379}; 1380 ; 1381////////////////////////////////////////////////////////////////////////////////; 1382/// Restrict access to specified object; 1383///; 1384/// See TRootSniffer::Restrict() for more details; 1385 ; 1386void THttpServer::Restrict(const char *path, const char *options); 1387{; 1388 fSniffer->Restrict(path, options);; 1389}; 1390 ; 1391////////////////////////////////////////////////////////////////////////////////; 1392/// Register command which can be executed from web interface; 1393///; 1394/// As method one typically specifies string, which is executed with; 1395/// gROOT->ProcessLine() method. For instance:; 1396///; 1397/// serv->RegisterCommand(""Invoke"",""InvokeFunction()"");; 1398///; 1399/// Or one could specify any method of the object which is already registered; 1400/// to the server. For instance:; 1401///; 1402/// serv->Register(""/"", hpx);; 1403/// serv->RegisterCommand(""/ResetHPX"", ""/hpx/->Reset()"");; 1404///; 1405/// Here symbols '/->' separates item name from method to be executed; 1406///; 1407/// One could specify additional arguments in the command with; 1408/// syntax like %arg1%, %arg2% and so on. For example:; 140",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:56398,Integrability,protocol,protocol,56398,"New, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5816; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TFastCgiTHttpEngine implementation, based on fastcgi package.Definition TFastCgi.h:20; THttpCallArgContains arguments for single HTTP call.Definition THttpCallArg.h:27; THttpCallArg::Set404void Set404()mark reply as 404 error - page/request not exists or refusedDefinition THttpCallArg.h:163; THttpCallArg::kZipAlways@ kZipAlwaysDefinition THttpCallArg.h:38; THttpEngineAbstract class for implementing http protocol for THttpServer.Definition THttpEngine.h:19; THttpEngine::SetServervoid SetServer(THttpServer *serv)Definition THttpEngine.h:27; THttpEngine::Createvirtual Bool_t Create(const char *)Method to create all components of engine.Definition THttpEngine.h:37; THttpLongPollEngineEmulation of websocket with long poll requests.Definition THttpLongPollEngine.h:23; THttpServerOnline http server for arbitrary ROOT application.Definition THttpServer.h:31; THttpServer::IsReadOnlyBool_t IsReadOnly() constreturns read-only modeDefinition THttpServer.cxx:285; THttpServer::RegisterCommandBool_t RegisterCommand(const char *cmdname, const char *method, const char *icon=nullptr)Register command which can be executed from web interface.Definition THttpServer.cxx:1428; THttpServer::fJSROOTTString fJSROOT! location of external JSROOT filesDefinition THttpServer.h:46; THttpServer::ProcessRequestvirtual void ProcessRequest(std::shared_ptr< THttpCallArg > arg)Process single http request.De",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:57121,Integrability,interface,interface,57121,"tcgi package.Definition TFastCgi.h:20; THttpCallArgContains arguments for single HTTP call.Definition THttpCallArg.h:27; THttpCallArg::Set404void Set404()mark reply as 404 error - page/request not exists or refusedDefinition THttpCallArg.h:163; THttpCallArg::kZipAlways@ kZipAlwaysDefinition THttpCallArg.h:38; THttpEngineAbstract class for implementing http protocol for THttpServer.Definition THttpEngine.h:19; THttpEngine::SetServervoid SetServer(THttpServer *serv)Definition THttpEngine.h:27; THttpEngine::Createvirtual Bool_t Create(const char *)Method to create all components of engine.Definition THttpEngine.h:37; THttpLongPollEngineEmulation of websocket with long poll requests.Definition THttpLongPollEngine.h:23; THttpServerOnline http server for arbitrary ROOT application.Definition THttpServer.h:31; THttpServer::IsReadOnlyBool_t IsReadOnly() constreturns read-only modeDefinition THttpServer.cxx:285; THttpServer::RegisterCommandBool_t RegisterCommand(const char *cmdname, const char *method, const char *icon=nullptr)Register command which can be executed from web interface.Definition THttpServer.cxx:1428; THttpServer::fJSROOTTString fJSROOT! location of external JSROOT filesDefinition THttpServer.h:46; THttpServer::ProcessRequestvirtual void ProcessRequest(std::shared_ptr< THttpCallArg > arg)Process single http request.Definition THttpServer.cxx:978; THttpServer::FindWSstd::shared_ptr< THttpWSHandler > FindWS(const char *name)Find web-socket handler with given name.Definition THttpServer.cxx:1285; THttpServer::fSnifferstd::unique_ptr< TRootSniffer > fSniffer! sniffer provides access to ROOT objects hierarchyDefinition THttpServer.h:36; THttpServer::SetTimervoid SetTimer(Long_t milliSec=100, Bool_t mode=kTRUE)Create timer which will invoke ProcessRequests() function periodically.Definition THttpServer.cxx:490; THttpServer::ProcessBatchHoldervirtual void ProcessBatchHolder(std::shared_ptr< THttpCallArg > &arg)Process special http request for root_batch_holder.js scr",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:67979,Integrability,message,message,67979,"DefaultPageContent()Provides content of default web page for registered web-socket handler Can be content of HTML page or...Definition THttpWSHandler.h:79; TIterDefinition TCollection.h:235; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::GetLastInt_t GetLast() const overrideReturn index of last object in array.Definition TObjArray.cxx:577; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::GetRootSysstatic const TString & GetRootSys()Get the rootsys directory in the installation. Static utility function.Definition TROOT.cxx:2983; TROOT::GetDataDirstatic const TString & GetDataDir()Get the data directory in the installation. Static utility function.Definition TROOT.cxx:3066; TRootSnifferStoreJsonStorage of hierarchy scan in TRootSniffer in JSON format.Definition TRootSnifferStore.h:79; TRootSnifferStoreXmlStorage of hierarchy scan in TRootSniffer in XML format.Definition TRootSnifferStore.h:55; TRootSnifferSniffer of ROOT objects, data provider for THttpServer.Definition TRootSniffer.h:115; TRootSniffer::CreateOwnTopFoldervoid CreateOwnTopFolder()Create own TFolder structures independent from gROOT This allows to have many independent TRootSniffe...Definition TRootSniffer.cxx:913; TRootSniffer::S",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:68109,Integrability,message,message,68109,"ion THttpWSHandler.h:79; TIterDefinition TCollection.h:235; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::GetLastInt_t GetLast() const overrideReturn index of last object in array.Definition TObjArray.cxx:577; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::GetRootSysstatic const TString & GetRootSys()Get the rootsys directory in the installation. Static utility function.Definition TROOT.cxx:2983; TROOT::GetDataDirstatic const TString & GetDataDir()Get the data directory in the installation. Static utility function.Definition TROOT.cxx:3066; TRootSnifferStoreJsonStorage of hierarchy scan in TRootSniffer in JSON format.Definition TRootSnifferStore.h:79; TRootSnifferStoreXmlStorage of hierarchy scan in TRootSniffer in XML format.Definition TRootSnifferStore.h:55; TRootSnifferSniffer of ROOT objects, data provider for THttpServer.Definition TRootSniffer.h:115; TRootSniffer::CreateOwnTopFoldervoid CreateOwnTopFolder()Create own TFolder structures independent from gROOT This allows to have many independent TRootSniffe...Definition TRootSniffer.cxx:913; TRootSniffer::SetReadOnlyvoid SetReadOnly(Bool_t on=kTRUE)When readonly on (default), sniffer is not allowed to change ROOT structures For instanc",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:4611,Modifiability,config,configure,4611,"hould be; 133/// created like ""http:8080"". One could specify several engines; 134/// at once, separating them with semicolon ("";""). Following engines are supported:; 135///; 136/// http - TCivetweb, civetweb-based implementation of http protocol; 137/// fastcgi - TFastCgi, special protocol for communicating with web servers; 138///; 139/// For each created engine one should provide socket port number like ""http:8080"" or ""fastcgi:9000"".; 140/// Additional engine-specific options can be supplied with URL syntax like ""http:8080?thrds=10"".; 141/// Full list of supported options should be checked in engines docu.; 142///; 143/// One also can configure following options, separated by semicolon:; 144///; 145/// readonly, ro - set read-only mode (default); 146/// readwrite, rw - allows methods execution of registered objects; 147/// global - scans global ROOT lists for existing objects (default); 148/// noglobal - disable scan of global lists; 149/// cors - enable CORS header with origin=""*""; 150/// cors=domain - enable CORS header with origin=""domain""; 151/// basic_sniffer - use basic sniffer without support of hist, gpad, graph classes; 152///; 153/// For example, create http server, which allows cors headers and disable scan of global lists,; 154/// one should provide ""http:8080;cors;noglobal"" as parameter; 155///; 156/// THttpServer uses JavaScript ROOT (https://root.cern/js) to implement web clients UI.; 157/// Normally JSROOT sources are used from $ROOTSYS/js directory,; 158/// but one could set JSROOTSYS shell variable to specify alternative location; 159 ; 160THttpServer::THttpServer(const char *engine) : TNamed(""http"", ""ROOT http server""); 161{; 162 const char *jsrootsys = gSystem->Getenv(""JSROOTSYS"");; 163 if (!jsrootsys); 164 jsrootsys = gEnv->GetValue(""HttpServ.JSRootPath"", jsrootsys);; 165 ; 166 if (jsrootsys && *jsrootsys) {; 167 if ((strncmp(jsrootsys, ""http://"", 7)==0) || (strncmp(jsrootsys, ""https://"", 8)==0)); 168 fJSROOT = jsrootsys;; 169 else; 170 fJSROOT",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:5501,Modifiability,variab,variable,5501," docu.; 142///; 143/// One also can configure following options, separated by semicolon:; 144///; 145/// readonly, ro - set read-only mode (default); 146/// readwrite, rw - allows methods execution of registered objects; 147/// global - scans global ROOT lists for existing objects (default); 148/// noglobal - disable scan of global lists; 149/// cors - enable CORS header with origin=""*""; 150/// cors=domain - enable CORS header with origin=""domain""; 151/// basic_sniffer - use basic sniffer without support of hist, gpad, graph classes; 152///; 153/// For example, create http server, which allows cors headers and disable scan of global lists,; 154/// one should provide ""http:8080;cors;noglobal"" as parameter; 155///; 156/// THttpServer uses JavaScript ROOT (https://root.cern/js) to implement web clients UI.; 157/// Normally JSROOT sources are used from $ROOTSYS/js directory,; 158/// but one could set JSROOTSYS shell variable to specify alternative location; 159 ; 160THttpServer::THttpServer(const char *engine) : TNamed(""http"", ""ROOT http server""); 161{; 162 const char *jsrootsys = gSystem->Getenv(""JSROOTSYS"");; 163 if (!jsrootsys); 164 jsrootsys = gEnv->GetValue(""HttpServ.JSRootPath"", jsrootsys);; 165 ; 166 if (jsrootsys && *jsrootsys) {; 167 if ((strncmp(jsrootsys, ""http://"", 7)==0) || (strncmp(jsrootsys, ""https://"", 8)==0)); 168 fJSROOT = jsrootsys;; 169 else; 170 fJSROOTSYS = jsrootsys;; 171 }; 172 ; 173 if (fJSROOTSYS.Length() == 0) {; 174 TString jsdir = TString::Format(""%s/js"", TROOT::GetDataDir().Data());; 175 if (gSystem->ExpandPathName(jsdir)) {; 176 ::Warning(""THttpServer::THttpServer"", ""problems resolving '%s', set JSROOTSYS to proper JavaScript ROOT location"",; 177 jsdir.Data());; 178 fJSROOTSYS = ""."";; 179 } else {; 180 fJSROOTSYS = jsdir;; 181 }; 182 }; 183 ; 184 Bool_t basic_sniffer = strstr(engine, ""basic_sniffer"") != nullptr;; 185 ; 186 AddLocation(""jsrootsys/"", fJSROOTSYS.Data());; 187 ; 188 if (basic_sniffer) {; 189 AddLocation(""rootsys_fonts/"", TStrin",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:26347,Modifiability,config,configured,26347,"ng arr = ""["";; 816 ; 817 {; 818 std::lock_guard<std::mutex> grd(fWSMutex);; 819 for (auto &ws : fWSHandlers) {; 820 if (arr.length() > 1); 821 arr.append("", "");; 822 ; 823 arr.append(TString::Format(""{ name: \""%s\"", title: \""%s\"" }"", ws->GetName(), ws->GetTitle()).Data());; 824 }; 825 }; 826 ; 827 arr.append(""]"");; 828 ; 829 std::string res = ReadFileContent((TROOT::GetDataDir() + ""/js/files/wslist.htm"").Data());; 830 ; 831 std::string arg = ""\""$$$wslist$$$\"""";; 832 ; 833 auto pos = res.find(arg);; 834 if (pos != std::string::npos); 835 res.replace(pos, arg.length(), arr);; 836 ; 837 return res;; 838}; 839 ; 840////////////////////////////////////////////////////////////////////////////////; 841/// Replaces all references like ""jsrootsys/..."" or other pre-configured pathes; 842///; 843/// Either using pre-configured JSROOT installation from web or; 844/// redirect to jsrootsys from the main server path to benefit from browser caching; 845/// Creates appropriate importmap instead of <!--jsroot_importmap--> placeholder; 846 ; 847void THttpServer::ReplaceJSROOTLinks(std::shared_ptr<THttpCallArg> &arg, const std::string &version); 848{; 849 const std::string place_holder = ""<!--jsroot_importmap-->"";; 850 ; 851 auto p = arg->fContent.find(place_holder);; 852 ; 853 bool old_format = (p == std::string::npos);; 854 ; 855 // count slashes to handler relative paths to jsroot; 856 Int_t slash_cnt = 0;; 857 if (arg->fPathName.Length() > 0); 858 slash_cnt++;; 859 for (Int_t n = 1; n < arg->fPathName.Length()-1; ++n); 860 if (arg->fPathName[n] == '/') {; 861 if (arg->fPathName[n-1] != '/') {; 862 slash_cnt++; // normal slash in the middle, count it; 863 } else {; 864 slash_cnt = 0; // double slash, do not touch such path; 865 break;; 866 }; 867 }; 868 ; 869 ; 870 if (old_format) {; 871 // old functionality; 872 ; 873 if (!version.empty()) {; 874 // replace link to JSROOT modules in import statements emulating new version for browser; 875 std::string search = ""from './jsrootsys/"";",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:26398,Modifiability,config,configured,26398,"ng arr = ""["";; 816 ; 817 {; 818 std::lock_guard<std::mutex> grd(fWSMutex);; 819 for (auto &ws : fWSHandlers) {; 820 if (arr.length() > 1); 821 arr.append("", "");; 822 ; 823 arr.append(TString::Format(""{ name: \""%s\"", title: \""%s\"" }"", ws->GetName(), ws->GetTitle()).Data());; 824 }; 825 }; 826 ; 827 arr.append(""]"");; 828 ; 829 std::string res = ReadFileContent((TROOT::GetDataDir() + ""/js/files/wslist.htm"").Data());; 830 ; 831 std::string arg = ""\""$$$wslist$$$\"""";; 832 ; 833 auto pos = res.find(arg);; 834 if (pos != std::string::npos); 835 res.replace(pos, arg.length(), arr);; 836 ; 837 return res;; 838}; 839 ; 840////////////////////////////////////////////////////////////////////////////////; 841/// Replaces all references like ""jsrootsys/..."" or other pre-configured pathes; 842///; 843/// Either using pre-configured JSROOT installation from web or; 844/// redirect to jsrootsys from the main server path to benefit from browser caching; 845/// Creates appropriate importmap instead of <!--jsroot_importmap--> placeholder; 846 ; 847void THttpServer::ReplaceJSROOTLinks(std::shared_ptr<THttpCallArg> &arg, const std::string &version); 848{; 849 const std::string place_holder = ""<!--jsroot_importmap-->"";; 850 ; 851 auto p = arg->fContent.find(place_holder);; 852 ; 853 bool old_format = (p == std::string::npos);; 854 ; 855 // count slashes to handler relative paths to jsroot; 856 Int_t slash_cnt = 0;; 857 if (arg->fPathName.Length() > 0); 858 slash_cnt++;; 859 for (Int_t n = 1; n < arg->fPathName.Length()-1; ++n); 860 if (arg->fPathName[n] == '/') {; 861 if (arg->fPathName[n-1] != '/') {; 862 slash_cnt++; // normal slash in the middle, count it; 863 } else {; 864 slash_cnt = 0; // double slash, do not touch such path; 865 break;; 866 }; 867 }; 868 ; 869 ; 870 if (old_format) {; 871 // old functionality; 872 ; 873 if (!version.empty()) {; 874 // replace link to JSROOT modules in import statements emulating new version for browser; 875 std::string search = ""from './jsrootsys/"";",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:62424,Modifiability,config,configured,62424,", Bool_t can_run_immediately=kFALSE)Submit HTTP request.Definition THttpServer.cxx:681; THttpServer::fMainThrdIdLong_t fMainThrdId! id of the thread for processing requestsDefinition THttpServer.h:38; THttpServer::fJSROOTSYSTString fJSROOTSYS! location of local JSROOT filesDefinition THttpServer.h:44; THttpServer::fTimerstd::unique_ptr< THttpTimer > fTimer! timer used to access main threadDefinition THttpServer.h:35; THttpServer::fWSOnlyBool_t fWSOnly! when true, handle only websockets / longpoll engineDefinition THttpServer.h:42; THttpServer::RegisterBool_t Register(const char *subfolder, TObject *obj)Register object in subfolder.Definition THttpServer.cxx:1243; THttpServer::fEnginesTList fEngines! engines which runs http serverDefinition THttpServer.h:34; THttpServer::SetCorsvoid SetCors(const std::string &domain=""*"")Enable CORS header to ProcessRequests() responses Specified location (typically ""*"") add as ""Access-C...Definition THttpServer.h:109; THttpServer::IsCorsBool_t IsCors() constReturns kTRUE if CORS was configured.Definition THttpServer.h:112; THttpServer::GetCorsCredentialsconst char * GetCorsCredentials() constReturns specified CORS credentials value - if any.Definition THttpServer.h:124; THttpServer::fArgsstd::queue< std::shared_ptr< THttpCallArg > > fArgs! submitted argumentsDefinition THttpServer.h:58; THttpServer::SetDefaultPagevoid SetDefaultPage(const std::string &filename="""")Set default HTML page.Definition THttpServer.cxx:368; THttpServer::THttpServerTHttpServer(const THttpServer &)=delete; THttpServer::ReadFileContentstatic char * ReadFileContent(const char *filename, Int_t &len)Reads content of file from the disk.Definition THttpServer.cxx:1557; THttpServer::CreateServerThreadvoid CreateServerThread()Creates special thread to process all requests, directed to http server.Definition THttpServer.cxx:515; THttpServer::fDrawPageContstd::string fDrawPageCont! content of draw html pageDefinition THttpServer.h:53; THttpServer::UnregisterBool_t Unreg",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:65761,Modifiability,config,configured,65761,"ar *value)Set item field in sniffer.Definition THttpServer.cxx:1463; THttpServer::SetJSROOTvoid SetJSROOT(const char *location)Set location of JSROOT to use with the server.Definition THttpServer.cxx:355; THttpServer::fMutexstd::mutex fMutex! mutex to protect list with argumentsDefinition THttpServer.h:57; THttpServer::fDefaultPagestd::string fDefaultPage! file name for default page nameDefinition THttpServer.h:50; THttpServer::UnregisterWSvoid UnregisterWS(std::shared_ptr< THttpWSHandler > ws)Unregister WS handler.Definition THttpServer.cxx:1272; THttpServer::GetMimeTypestatic const char * GetMimeType(const char *path)Guess mime type base on file extension.Definition THttpServer.cxx:1479; THttpServer::GetSnifferTRootSniffer * GetSniffer() constreturns pointer on objects snifferDefinition THttpServer.h:89; THttpServer::ReplaceJSROOTLinksvoid ReplaceJSROOTLinks(std::shared_ptr< THttpCallArg > &arg, const std::string &version="""")Replaces all references like ""jsrootsys/..."" or other pre-configured pathes.Definition THttpServer.cxx:847; THttpServer::fTerminatedBool_t fTerminated! termination flag, disables all requests processingDefinition THttpServer.h:37; THttpServer::Restrictvoid Restrict(const char *path, const char *options)Restrict access to specified object.Definition THttpServer.cxx:1386; THttpTimerDefinition THttpServer.cxx:42; THttpTimer::fNormalTmoutLong_t fNormalTmoutDefinition THttpServer.cxx:43; THttpTimer::fSlowBool_t fSlowDefinition THttpServer.cxx:44; THttpTimer::fSlowCntInt_t fSlowCntDefinition THttpServer.cxx:45; THttpTimer::Timeoutvoid Timeout() overridetimeout handler used to process http requests in main ROOT threadDefinition THttpServer.cxx:73; THttpTimer::IsSlowBool_t IsSlow() constDefinition THttpServer.cxx:69; THttpTimer::SetSlowvoid SetSlow(Bool_t flag)Definition THttpServer.cxx:53; THttpTimer::fServerTHttpServer & fServerDefinition THttpServer.cxx:48; THttpTimer::THttpTimerTHttpTimer(Long_t milliSec, Bool_t mode, THttpServer &serv)!< server pr",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:70783,Modifiability,variab,variable,70783,"char c) constFind last occurrence of a character c.Definition TString.cxx:931; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TThread::SelfIdstatic Long_t SelfId()Static method returning the id for the current thread.Definition TThread.cxx:549; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::SetTimevoid SetTime(Long_t milliSec)Definition TTimer.h:91; TUrlThis class represents a WWW compatible URL.Definition TUrl.h:33; TUrl::GetValueFromOptionsconst char * GetValueFromOptions(const char *key) constReturn a value for a given key from the URL options.Definition TUrl.cxx:660; TUrl::SetOptionsvoid SetOptions(const char *opt)Definition TUrl.h:87; TUrl::ParseOptionsvoid ParseOptions() constParse URL options into a key/value map.Definition TUrl.cxx:626; TUrl::HasOptionBool_t HasOption(const char *key) constReturns true if the given key appears in the URL options list.Definition TUrl.cxx:683; bool; int; nconst Int_t nDefinition legend1.C:16. nethttpsrcTHttpServer.cxx. ROOT master - Reference Guide Gener",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:11532,Performance,load,load,11532,"8/// serv->AddLocation(""mydir/"", ""/home/user/specials"");; 329///; 330/// Than files from this directory could be addressed via server like `http://localhost:8080/mydir/myfile.root`; 331 ; 332void THttpServer::AddLocation(const char *prefix, const char *path); 333{; 334 if (!prefix || (*prefix == 0)); 335 return;; 336 ; 337 if (!path); 338 fLocations.erase(fLocations.find(prefix));; 339 else; 340 fLocations[prefix] = path;; 341}; 342 ; 343////////////////////////////////////////////////////////////////////////////////; 344/// Set location of JSROOT to use with the server; 345///; 346/// One could specify address like:; 347///; 348/// * https://root.cern/js/7.6.0/; 349/// * https://jsroot.gsi.de/7.6.0/; 350///; 351/// This allows to get new JSROOT features with old server,; 352/// reduce load on THttpServer instance, also startup time can be improved; 353/// When empty string specified (default), local copy of JSROOT is used (distributed with ROOT); 354 ; 355void THttpServer::SetJSROOT(const char *location); 356{; 357 fJSROOT = location ? location : """";; 358}; 359 ; 360////////////////////////////////////////////////////////////////////////////////; 361/// Set default HTML page; 362///; 363/// Sets file name, delivered by the server when http address is opened in the browser.; 364///; 365/// By default, $ROOTSYS/js/files/online.htm page is used; 366/// When empty filename is specified, default page will be used; 367 ; 368void THttpServer::SetDefaultPage(const std::string &filename); 369{; 370 if (!filename.empty()); 371 fDefaultPage = filename;; 372 else; 373 fDefaultPage = fJSROOTSYS + ""/files/online.htm"";; 374 ; 375 // force to read page content next time again; 376 fDefaultPageCont.clear();; 377}; 378 ; 379////////////////////////////////////////////////////////////////////////////////; 380/// Set drawing HTML page; 381///; 382/// Set file name of HTML page, delivered by the server when; 383/// objects drawing page is requested from the browser; 384/// By default, $",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:15348,Performance,perform,perform,15348,"t"") {; 439 eng = new TCivetweb(kFALSE);; 440 sarg = ""x""; // civetweb require x before socket name; 441 sarg.Append(arg);; 442 arg = sarg.Data();; 443#endif; 444 } else if (clname == ""https"") {; 445 eng = new TCivetweb(kTRUE);; 446 } else if (clname == ""fastcgi"") {; 447 eng = new TFastCgi();; 448 }; 449 ; 450 if (!eng) {; 451 // ensure that required engine class exists before we try to create it; 452 TClass *engine_class = gROOT->LoadClass(clname.Data());; 453 if (!engine_class); 454 return kFALSE;; 455 ; 456 eng = (THttpEngine *)engine_class->New();; 457 if (!eng); 458 return kFALSE;; 459 }; 460 ; 461 eng->SetServer(this);; 462 ; 463 if (!eng->Create(arg)) {; 464 delete eng;; 465 return kFALSE;; 466 }; 467 ; 468 fEngines.Add(eng);; 469 ; 470 return kTRUE;; 471}; 472 ; 473////////////////////////////////////////////////////////////////////////////////; 474/// Create timer which will invoke ProcessRequests() function periodically; 475///; 476/// Timer is required to perform all actions in main ROOT thread; 477/// Method arguments are the same as for TTimer constructor; 478/// By default, sync timer with 100 ms period is created; 479///; 480/// It is recommended to always use sync timer mode and only change period to; 481/// adjust server reaction time. Use of async timer requires, that application regularly; 482/// calls gSystem->ProcessEvents(). It happens automatically in ROOT interactive shell.; 483/// If milliSec == 0, no timer will be created.; 484/// In this case application should regularly call ProcessRequests() method.; 485///; 486/// Async timer allows to use THttpServer in applications, which does not have explicit; 487/// gSystem->ProcessEvents() calls. But be aware, that such timer can interrupt any system call; 488/// (like malloc) and can lead to dead locks, especially in multi-threaded applications.; 489 ; 490void THttpServer::SetTimer(Long_t milliSec, Bool_t mode); 491{; 492 if (fTimer) {; 493 fTimer->Stop();; 494 fTimer.reset();; 495 }; 496 if (milliS",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:16185,Performance,multi-thread,multi-threaded,16185,"471}; 472 ; 473////////////////////////////////////////////////////////////////////////////////; 474/// Create timer which will invoke ProcessRequests() function periodically; 475///; 476/// Timer is required to perform all actions in main ROOT thread; 477/// Method arguments are the same as for TTimer constructor; 478/// By default, sync timer with 100 ms period is created; 479///; 480/// It is recommended to always use sync timer mode and only change period to; 481/// adjust server reaction time. Use of async timer requires, that application regularly; 482/// calls gSystem->ProcessEvents(). It happens automatically in ROOT interactive shell.; 483/// If milliSec == 0, no timer will be created.; 484/// In this case application should regularly call ProcessRequests() method.; 485///; 486/// Async timer allows to use THttpServer in applications, which does not have explicit; 487/// gSystem->ProcessEvents() calls. But be aware, that such timer can interrupt any system call; 488/// (like malloc) and can lead to dead locks, especially in multi-threaded applications.; 489 ; 490void THttpServer::SetTimer(Long_t milliSec, Bool_t mode); 491{; 492 if (fTimer) {; 493 fTimer->Stop();; 494 fTimer.reset();; 495 }; 496 if (milliSec > 0) {; 497 if (fOwnThread) {; 498 Error(""SetTimer"", ""Server runs already in special thread, therefore no any timer can be created"");; 499 } else {; 500 fTimer = std::make_unique<THttpTimer>(milliSec, mode, *this);; 501 fTimer->TurnOn();; 502 }; 503 }; 504}; 505 ; 506////////////////////////////////////////////////////////////////////////////////; 507/// Creates special thread to process all requests, directed to http server; 508///; 509/// Should be used with care - only dedicated instance of TRootSniffer is allowed; 510/// By default THttpServer allows to access global lists pointers gROOT or gFile.; 511/// To be on the safe side, all kind of such access performed from the main thread.; 512/// Therefore usage of specialized thread means that no any glo",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:17038,Performance,perform,performed,17038,"/// gSystem->ProcessEvents() calls. But be aware, that such timer can interrupt any system call; 488/// (like malloc) and can lead to dead locks, especially in multi-threaded applications.; 489 ; 490void THttpServer::SetTimer(Long_t milliSec, Bool_t mode); 491{; 492 if (fTimer) {; 493 fTimer->Stop();; 494 fTimer.reset();; 495 }; 496 if (milliSec > 0) {; 497 if (fOwnThread) {; 498 Error(""SetTimer"", ""Server runs already in special thread, therefore no any timer can be created"");; 499 } else {; 500 fTimer = std::make_unique<THttpTimer>(milliSec, mode, *this);; 501 fTimer->TurnOn();; 502 }; 503 }; 504}; 505 ; 506////////////////////////////////////////////////////////////////////////////////; 507/// Creates special thread to process all requests, directed to http server; 508///; 509/// Should be used with care - only dedicated instance of TRootSniffer is allowed; 510/// By default THttpServer allows to access global lists pointers gROOT or gFile.; 511/// To be on the safe side, all kind of such access performed from the main thread.; 512/// Therefore usage of specialized thread means that no any global pointers will; 513/// be accessible by THttpServer; 514 ; 515void THttpServer::CreateServerThread(); 516{; 517 if (fOwnThread); 518 return;; 519 ; 520 SetTimer(0);; 521 fMainThrdId = 0;; 522 fOwnThread = true;; 523 ; 524 std::thread thrd([this] {; 525 int nempty = 0;; 526 while (fOwnThread && !fTerminated) {; 527 int nprocess = ProcessRequests();; 528 if (nprocess > 0); 529 nempty = 0;; 530 else; 531 nempty++;; 532 if (nempty > 1000) {; 533 nempty = 0;; 534 std::this_thread::sleep_for(std::chrono::milliseconds(1));; 535 }; 536 }; 537 });; 538 ; 539 fThrd = std::move(thrd);; 540}; 541 ; 542////////////////////////////////////////////////////////////////////////////////; 543/// Stop server thread; 544///; 545/// Normally called shortly before http server destructor; 546 ; 547void THttpServer::StopServerThread(); 548{; 549 if (!fOwnThread); 550 return;; 551 ; 552 fOwnThread ",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:23430,Performance,queue,queue,23430,";; 689 return kTRUE;; 690 }; 691 ; 692 // add call arg to the list; 693 std::unique_lock<std::mutex> lk(fMutex);; 694 fArgs.push(arg);; 695 return kFALSE;; 696}; 697 ; 698////////////////////////////////////////////////////////////////////////////////; 699/// Process requests, submitted for execution; 700///; 701/// Returns number of processed requests; 702///; 703/// Normally invoked by THttpTimer, when somewhere in the code; 704/// gSystem->ProcessEvents() is called.; 705/// User can call serv->ProcessRequests() directly, but only from main thread.; 706/// If special server thread is created, called from that thread; 707 ; 708Int_t THttpServer::ProcessRequests(); 709{; 710 auto id = TThread::SelfId();; 711 ; 712 if (fMainThrdId != id) {; 713 if (gDebug > 0 && fMainThrdId); 714 Warning(""ProcessRequests"", ""Changing main thread to %ld"", (long)id);; 715 fMainThrdId = id;; 716 }; 717 ; 718 Bool_t recursion = kFALSE;; 719 ; 720 if (fProcessingThrdId) {; 721 if (fProcessingThrdId == id) {; 722 recursion = kTRUE;; 723 } else {; 724 Error(""ProcessRequests"", ""Processing already running from %ld thread"", (long) fProcessingThrdId);; 725 return 0;; 726 }; 727 }; 728 ; 729 if (!recursion); 730 fProcessingThrdId = id;; 731 ; 732 Int_t cnt = 0;; 733 ; 734 std::unique_lock<std::mutex> lk(fMutex, std::defer_lock);; 735 ; 736 // first process requests in the queue; 737 while (true) {; 738 std::shared_ptr<THttpCallArg> arg;; 739 ; 740 lk.lock();; 741 if (!fArgs.empty()) {; 742 arg = fArgs.front();; 743 fArgs.pop();; 744 }; 745 lk.unlock();; 746 ; 747 if (!arg); 748 break;; 749 ; 750 if (arg->fFileName == ""root_batch_holder.js"") {; 751 ProcessBatchHolder(arg);; 752 continue;; 753 }; 754 ; 755 auto prev = fSniffer->SetCurrentCallArg(arg.get());; 756 ; 757 try {; 758 cnt++;; 759 ProcessRequest(arg);; 760 fSniffer->SetCurrentCallArg(prev);; 761 } catch (...) {; 762 fSniffer->SetCurrentCallArg(prev);; 763 }; 764 ; 765 arg->NotifyCondition();; 766 }; 767 ; 768 // regularly call Process() m",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:24089,Performance,perform,perform,24089,"37 while (true) {; 738 std::shared_ptr<THttpCallArg> arg;; 739 ; 740 lk.lock();; 741 if (!fArgs.empty()) {; 742 arg = fArgs.front();; 743 fArgs.pop();; 744 }; 745 lk.unlock();; 746 ; 747 if (!arg); 748 break;; 749 ; 750 if (arg->fFileName == ""root_batch_holder.js"") {; 751 ProcessBatchHolder(arg);; 752 continue;; 753 }; 754 ; 755 auto prev = fSniffer->SetCurrentCallArg(arg.get());; 756 ; 757 try {; 758 cnt++;; 759 ProcessRequest(arg);; 760 fSniffer->SetCurrentCallArg(prev);; 761 } catch (...) {; 762 fSniffer->SetCurrentCallArg(prev);; 763 }; 764 ; 765 arg->NotifyCondition();; 766 }; 767 ; 768 // regularly call Process() method of engine to let perform actions in ROOT context; 769 TIter iter(&fEngines);; 770 while (auto engine = static_cast<THttpEngine *>(iter())) {; 771 if (fTerminated); 772 engine->Terminate();; 773 engine->Process();; 774 }; 775 ; 776 if (!recursion); 777 fProcessingThrdId = 0;; 778 ; 779 return cnt;; 780}; 781 ; 782////////////////////////////////////////////////////////////////////////////////; 783/// Method called when THttpServer cannot process request; 784///; 785/// By default such requests replied with 404 code; 786/// One could overwrite with method in derived class to process all kinds of such non-standard requests; 787 ; 788void THttpServer::MissedRequest(THttpCallArg *arg); 789{; 790 arg->Set404();; 791}; 792 ; 793////////////////////////////////////////////////////////////////////////////////; 794/// Process special http request for root_batch_holder.js script; 795///; 796/// This kind of requests used to hold web browser running in headless mode; 797/// Intentionally requests does not replied immediately; 798 ; 799void THttpServer::ProcessBatchHolder(std::shared_ptr<THttpCallArg> &arg); 800{; 801 auto wsptr = FindWS(arg->GetPathName());; 802 ; 803 if (!wsptr || !wsptr->ProcessBatchHolder(arg)) {; 804 arg->Set404();; 805 arg->NotifyCondition();; 806 }; 807}; 808 ; 809//////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:31224,Performance,perform,performed,31224,""" + entry.second + ""';"";; 947 arg->ReplaceAllinContent(search, replace);; 948 }; 949 ; 950 } else {; 951 ; 952 bool first = true;; 953 TString importmap = ""<script type=\""importmap\"">\n{\n \""imports\"": "";; 954 for (auto &entry : modules) {; 955 importmap.Append(TString::Format(""%s\n \""%s\"": \""%smodules/%s\"""", first ? ""{"" : "","", entry.first.c_str(), jsroot_prefix.c_str(), entry.second.c_str()));; 956 first = false;; 957 }; 958 importmap.Append(TString::Format("",\n \""jsrootsys/\"": \""%s\"""", jsroot_prefix.c_str()));; 959 ; 960 for (auto &entry : fLocations); 961 if (entry.first != ""jsrootsys/""); 962 importmap.Append(TString::Format("",\n \""%s\"": \""%s%s\"""", entry.first.c_str(), path_prefix.c_str(), entry.first.c_str()));; 963 importmap.Append(""\n }\n}\n</script>\n"");; 964 ; 965 arg->fContent.erase(p, place_holder.length());; 966 ; 967 arg->fContent.insert(p, importmap.Data());; 968 }; 969 }; 970}; 971 ; 972////////////////////////////////////////////////////////////////////////////////; 973/// Process single http request; 974///; 975/// Depending from requested path and filename different actions will be performed.; 976/// In most cases information is provided by TRootSniffer class; 977 ; 978void THttpServer::ProcessRequest(std::shared_ptr<THttpCallArg> arg); 979{; 980 if (fTerminated) {; 981 arg->Set404();; 982 return;; 983 }; 984 ; 985 if ((arg->fFileName == ""root.websocket"") || (arg->fFileName == ""root.longpoll"")) {; 986 ExecuteWS(arg);; 987 return;; 988 }; 989 ; 990 if (arg->fFileName.IsNull() || (arg->fFileName == ""index.htm"") || (arg->fFileName == ""default.htm"")) {; 991 ; 992 std::string version;; 993 ; 994 if (arg->fFileName == ""default.htm"") {; 995 ; 996 if (!IsWSOnly()); 997 arg->fContent = ReadFileContent((fJSROOTSYS + ""/files/online.htm"").Data());; 998 ; 999 } else {; 1000 auto wsptr = FindWS(arg->GetPathName());; 1001 ; 1002 auto handler = wsptr.get();; 1003 ; 1004 if (!handler); 1005 handler = dynamic_cast<THttpWSHandler *>(fSniffer->FindTObjectInHierarchy(arg",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:40294,Performance,multi-thread,multi-threaded,40294,"ta master version is important; 1223 // it allows to detect if streamer info was modified; 1224 const char *parname = fSniffer->IsStreamerInfoItem(arg->fPathName.Data()) ? ""BVersion"" : ""MVersion"";; 1225 arg->AddHeader(parname, TString::Format(""%u"", (unsigned)fSniffer->GetStreamerInfoHash()).Data());; 1226 }; 1227 ; 1228 // try to avoid caching on the browser; 1229 arg->AddNoCacheHeader();; 1230 ; 1231 // potentially add cors headers; 1232 if (IsCors()); 1233 arg->AddHeader(""Access-Control-Allow-Origin"", GetCors());; 1234 if (IsCorsCredentials()); 1235 arg->AddHeader(""Access-Control-Allow-Credentials"", GetCorsCredentials());; 1236}; 1237 ; 1238////////////////////////////////////////////////////////////////////////////////; 1239/// Register object in folders hierarchy; 1240///; 1241/// See TRootSniffer::RegisterObject() for more details; 1242 ; 1243Bool_t THttpServer::Register(const char *subfolder, TObject *obj); 1244{; 1245 return fSniffer->RegisterObject(subfolder, obj);; 1246}; 1247 ; 1248////////////////////////////////////////////////////////////////////////////////; 1249/// Unregister object in folders hierarchy; 1250///; 1251/// See TRootSniffer::UnregisterObject() for more details; 1252 ; 1253Bool_t THttpServer::Unregister(TObject *obj); 1254{; 1255 return fSniffer->UnregisterObject(obj);; 1256}; 1257 ; 1258////////////////////////////////////////////////////////////////////////////////; 1259/// Register WS handler to the THttpServer; 1260///; 1261/// Only such handler can be used in multi-threaded processing of websockets; 1262 ; 1263void THttpServer::RegisterWS(std::shared_ptr<THttpWSHandler> ws); 1264{; 1265 std::lock_guard<std::mutex> grd(fWSMutex);; 1266 fWSHandlers.emplace_back(ws);; 1267}; 1268 ; 1269////////////////////////////////////////////////////////////////////////////////; 1270/// Unregister WS handler to the THttpServer; 1271 ; 1272void THttpServer::UnregisterWS(std::shared_ptr<THttpWSHandler> ws); 1273{; 1274 std::lock_guard<std::mutex> grd(",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:55722,Performance,load,load,55722,"SystemDefinition TSystem.h:561; TThread.h; TTimer.h; TUrl.h; mime_typeconst char * mime_typeDefinition civetweb.c:8027; ext_lensize_t ext_lenDefinition civetweb.c:8026; free#define freeDefinition civetweb.c:1539; extensionconst char * extensionDefinition civetweb.c:8025; builtin_mime_typesstatic const struct @142 builtin_mime_types[]; malloc#define mallocDefinition civetweb.c:1536; TCivetwebTHttpEngine implementation, based on civetweb embedded server.Definition TCivetweb.h:21; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5816; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TFastCgiTHttpEngine implementation, based on fastcgi package.Definition TFastCgi.h:20; THttpCallArgContains arguments for single HTTP call.Definition THttpCallArg.h:27; THttpCallArg::Set404void Set404()mark reply as 404 error - page/request not exists or refusedDefinition THttpCallArg.h:163; THttpCallArg::kZipAlways@ kZipAlwaysDefinition THttpCallArg.h:38; THttpEngineAbstract class for implementing http protocol for THttpServer.Definition THttpEngine.h:19; THttpEngine::SetServervoid SetServer(THttpServer *serv)Definition THttpEngine.h:27; THttpEngine::Createvirtual Bool_t Create(const char *)Method to create all components of engine.Definition THttpEngine.h:37; THttpLongPollEngineEmulation of websocket with long poll requests.Definitio",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:62638,Performance,queue,queue,62638,"efinition THttpServer.h:44; THttpServer::fTimerstd::unique_ptr< THttpTimer > fTimer! timer used to access main threadDefinition THttpServer.h:35; THttpServer::fWSOnlyBool_t fWSOnly! when true, handle only websockets / longpoll engineDefinition THttpServer.h:42; THttpServer::RegisterBool_t Register(const char *subfolder, TObject *obj)Register object in subfolder.Definition THttpServer.cxx:1243; THttpServer::fEnginesTList fEngines! engines which runs http serverDefinition THttpServer.h:34; THttpServer::SetCorsvoid SetCors(const std::string &domain=""*"")Enable CORS header to ProcessRequests() responses Specified location (typically ""*"") add as ""Access-C...Definition THttpServer.h:109; THttpServer::IsCorsBool_t IsCors() constReturns kTRUE if CORS was configured.Definition THttpServer.h:112; THttpServer::GetCorsCredentialsconst char * GetCorsCredentials() constReturns specified CORS credentials value - if any.Definition THttpServer.h:124; THttpServer::fArgsstd::queue< std::shared_ptr< THttpCallArg > > fArgs! submitted argumentsDefinition THttpServer.h:58; THttpServer::SetDefaultPagevoid SetDefaultPage(const std::string &filename="""")Set default HTML page.Definition THttpServer.cxx:368; THttpServer::THttpServerTHttpServer(const THttpServer &)=delete; THttpServer::ReadFileContentstatic char * ReadFileContent(const char *filename, Int_t &len)Reads content of file from the disk.Definition THttpServer.cxx:1557; THttpServer::CreateServerThreadvoid CreateServerThread()Creates special thread to process all requests, directed to http server.Definition THttpServer.cxx:515; THttpServer::fDrawPageContstd::string fDrawPageCont! content of draw html pageDefinition THttpServer.h:53; THttpServer::UnregisterBool_t Unregister(TObject *obj)Unregister object.Definition THttpServer.cxx:1253; THttpServer::SetWSOnlyvoid SetWSOnly(Bool_t on=kTRUE)Set websocket-only mode.Definition THttpServer.cxx:318; THttpServer::BuildWSEntryPagestd::string BuildWSEntryPage()Create summary page with active WS ha",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:1934,Safety,timeout,timeout,1934,"*************/; 11 ; 12#include ""THttpServer.h""; 13 ; 14#include ""TThread.h""; 15#include ""TTimer.h""; 16#include ""TSystem.h""; 17#include ""TROOT.h""; 18#include ""TUrl.h""; 19#include ""TEnv.h""; 20#include ""TError.h""; 21#include ""TClass.h""; 22#include ""RConfigure.h""; 23#include ""TRegexp.h""; 24#include ""TObjArray.h""; 25 ; 26#include ""THttpEngine.h""; 27#include ""THttpLongPollEngine.h""; 28#include ""THttpWSHandler.h""; 29#include ""TRootSniffer.h""; 30#include ""TRootSnifferStore.h""; 31#include ""TCivetweb.h""; 32#include ""TFastCgi.h""; 33 ; 34#include <chrono>; 35#include <cstdlib>; 36#include <cstring>; 37#include <fstream>; 38#include <memory>; 39#include <string>; 40#include <thread>; 41 ; 42class THttpTimer : public TTimer {; 43 Long_t fNormalTmout{0};; 44 Bool_t fSlow{kFALSE};; 45 Int_t fSlowCnt{0};; 46 ; 47public:; 48 THttpServer &fServer; ///!< server processing requests; 49 ; 50 /// constructor; 51 THttpTimer(Long_t milliSec, Bool_t mode, THttpServer &serv) : TTimer(milliSec, mode), fNormalTmout(milliSec), fServer(serv) {}; 52 ; 53 void SetSlow(Bool_t flag); 54 {; 55 fSlow = flag;; 56 fSlowCnt = 0;; 57 Long_t ms = fNormalTmout;; 58 if (fSlow) {; 59 if (ms < 100); 60 ms = 500;; 61 else if (ms < 500); 62 ms = 3000;; 63 else; 64 ms = 10000;; 65 }; 66 ; 67 SetTime(ms);; 68 }; 69 Bool_t IsSlow() const { return fSlow; }; 70 ; 71 /// timeout handler; 72 /// used to process http requests in main ROOT thread; 73 void Timeout() override; 74 {; 75 Int_t nprocess = fServer.ProcessRequests();; 76 ; 77 if (nprocess > 0) {; 78 fSlowCnt = 0;; 79 if (IsSlow()); 80 SetSlow(kFALSE);; 81 } else if (!IsSlow() && (fSlowCnt++ > 10)) {; 82 SetSlow(kTRUE);; 83 }; 84 }; 85};; 86 ; 87 ; 88/** \class THttpServer; 89\ingroup http; 90 ; 91Online http server for arbitrary ROOT application; 92 ; 93Idea of THttpServer - provide remote http access to running; 94ROOT application and enable HTML/JavaScript user interface.; 95Any registered object can be requested and displayed in the browser.; 96There are man",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:17003,Safety,safe,safe,17003,"/// gSystem->ProcessEvents() calls. But be aware, that such timer can interrupt any system call; 488/// (like malloc) and can lead to dead locks, especially in multi-threaded applications.; 489 ; 490void THttpServer::SetTimer(Long_t milliSec, Bool_t mode); 491{; 492 if (fTimer) {; 493 fTimer->Stop();; 494 fTimer.reset();; 495 }; 496 if (milliSec > 0) {; 497 if (fOwnThread) {; 498 Error(""SetTimer"", ""Server runs already in special thread, therefore no any timer can be created"");; 499 } else {; 500 fTimer = std::make_unique<THttpTimer>(milliSec, mode, *this);; 501 fTimer->TurnOn();; 502 }; 503 }; 504}; 505 ; 506////////////////////////////////////////////////////////////////////////////////; 507/// Creates special thread to process all requests, directed to http server; 508///; 509/// Should be used with care - only dedicated instance of TRootSniffer is allowed; 510/// By default THttpServer allows to access global lists pointers gROOT or gFile.; 511/// To be on the safe side, all kind of such access performed from the main thread.; 512/// Therefore usage of specialized thread means that no any global pointers will; 513/// be accessible by THttpServer; 514 ; 515void THttpServer::CreateServerThread(); 516{; 517 if (fOwnThread); 518 return;; 519 ; 520 SetTimer(0);; 521 fMainThrdId = 0;; 522 fOwnThread = true;; 523 ; 524 std::thread thrd([this] {; 525 int nempty = 0;; 526 while (fOwnThread && !fTerminated) {; 527 int nprocess = ProcessRequests();; 528 if (nprocess > 0); 529 nempty = 0;; 530 else; 531 nempty++;; 532 if (nempty > 1000) {; 533 nempty = 0;; 534 std::this_thread::sleep_for(std::chrono::milliseconds(1));; 535 }; 536 }; 537 });; 538 ; 539 fThrd = std::move(thrd);; 540}; 541 ; 542////////////////////////////////////////////////////////////////////////////////; 543/// Stop server thread; 544///; 545/// Normally called shortly before http server destructor; 546 ; 547void THttpServer::StopServerThread(); 548{; 549 if (!fOwnThread); 550 return;; 551 ; 552 fOwnThread ",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:19510,Safety,safe,safe,19510,"yFilePath(const char *fname); 563{; 564 if (!fname || (*fname == 0)); 565 return kFALSE;; 566 ; 567 Int_t level = 0;; 568 ; 569 while (*fname) {; 570 ; 571 // find next slash or backslash; 572 const char *next = strpbrk(fname, ""/\\"");; 573 if (next == 0); 574 return kTRUE;; 575 ; 576 // most important - change to parent dir; 577 if ((next == fname + 2) && (*fname == '.') && (*(fname + 1) == '.')) {; 578 fname += 3;; 579 level--;; 580 if (level < 0); 581 return kFALSE;; 582 continue;; 583 }; 584 ; 585 // ignore current directory; 586 if ((next == fname + 1) && (*fname == '.')) {; 587 fname += 2;; 588 continue;; 589 }; 590 ; 591 // ignore slash at the front; 592 if (next == fname) {; 593 fname++;; 594 continue;; 595 }; 596 ; 597 fname = next + 1;; 598 level++;; 599 }; 600 ; 601 return kTRUE;; 602}; 603 ; 604////////////////////////////////////////////////////////////////////////////////; 605/// Verifies that request is just file name; 606///; 607/// File names typically contains prefix like ""jsrootsys/""; 608/// If true, method returns real name of the file,; 609/// which should be delivered to the client; 610/// Method is thread safe and can be called from any thread; 611 ; 612Bool_t THttpServer::IsFileRequested(const char *uri, TString &res) const; 613{; 614 if (!uri || (*uri == 0)); 615 return kFALSE;; 616 ; 617 TString fname(uri);; 618 ; 619 for (auto &entry : fLocations) {; 620 Ssiz_t pos = fname.Index(entry.first.c_str());; 621 if (pos == kNPOS); 622 continue;; 623 fname.Remove(0, pos + (entry.first.length() - 1));; 624 if (!VerifyFilePath(fname.Data())); 625 return kFALSE;; 626 res = entry.second.c_str();; 627 if ((fname[0] == '/') && (res[res.Length() - 1] == '/')); 628 res.Resize(res.Length() - 1);; 629 res.Append(fname);; 630 return kTRUE;; 631 }; 632 ; 633 return kFALSE;; 634}; 635 ; 636////////////////////////////////////////////////////////////////////////////////; 637/// Executes http request, specified in THttpCallArg structure; 638///; 639/// Method can ",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:38830,Safety,detect,detect,38830,"ta()));; 1196 ; 1197 arg->SetXml();; 1198 } else if (filename == ""h.json"") {; 1199 TString res;; 1200 TRootSnifferStoreJson store(res, arg->fQuery.Index(""compact"") != kNPOS);; 1201 const char *topname = fTopName.Data();; 1202 if (arg->fTopName.Length() > 0); 1203 topname = arg->fTopName.Data();; 1204 fSniffer->ScanHierarchy(topname, arg->fPathName.Data(), &store);; 1205 arg->SetContent(std::string(res.Data()));; 1206 arg->SetJson();; 1207 } else if (fSniffer->Produce(arg->fPathName.Data(), filename.Data(), arg->fQuery.Data(), arg->fContent)) {; 1208 // define content type base on extension; 1209 arg->SetContentType(GetMimeType(filename.Data()));; 1210 } else {; 1211 // miss request, user may process; 1212 MissedRequest(arg.get());; 1213 }; 1214 ; 1215 if (arg->Is404()); 1216 return;; 1217 ; 1218 if (iszip); 1219 arg->SetZipping(THttpCallArg::kZipAlways);; 1220 ; 1221 if (filename == ""root.bin"") {; 1222 // only for binary data master version is important; 1223 // it allows to detect if streamer info was modified; 1224 const char *parname = fSniffer->IsStreamerInfoItem(arg->fPathName.Data()) ? ""BVersion"" : ""MVersion"";; 1225 arg->AddHeader(parname, TString::Format(""%u"", (unsigned)fSniffer->GetStreamerInfoHash()).Data());; 1226 }; 1227 ; 1228 // try to avoid caching on the browser; 1229 arg->AddNoCacheHeader();; 1230 ; 1231 // potentially add cors headers; 1232 if (IsCors()); 1233 arg->AddHeader(""Access-Control-Allow-Origin"", GetCors());; 1234 if (IsCorsCredentials()); 1235 arg->AddHeader(""Access-Control-Allow-Credentials"", GetCorsCredentials());; 1236}; 1237 ; 1238////////////////////////////////////////////////////////////////////////////////; 1239/// Register object in folders hierarchy; 1240///; 1241/// See TRootSniffer::RegisterObject() for more details; 1242 ; 1243Bool_t THttpServer::Register(const char *subfolder, TObject *obj); 1244{; 1245 return fSniffer->RegisterObject(subfolder, obj);; 1246}; 1247 ; 1248/////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:39109,Safety,avoid,avoid,39109,"ta master version is important; 1223 // it allows to detect if streamer info was modified; 1224 const char *parname = fSniffer->IsStreamerInfoItem(arg->fPathName.Data()) ? ""BVersion"" : ""MVersion"";; 1225 arg->AddHeader(parname, TString::Format(""%u"", (unsigned)fSniffer->GetStreamerInfoHash()).Data());; 1226 }; 1227 ; 1228 // try to avoid caching on the browser; 1229 arg->AddNoCacheHeader();; 1230 ; 1231 // potentially add cors headers; 1232 if (IsCors()); 1233 arg->AddHeader(""Access-Control-Allow-Origin"", GetCors());; 1234 if (IsCorsCredentials()); 1235 arg->AddHeader(""Access-Control-Allow-Credentials"", GetCorsCredentials());; 1236}; 1237 ; 1238////////////////////////////////////////////////////////////////////////////////; 1239/// Register object in folders hierarchy; 1240///; 1241/// See TRootSniffer::RegisterObject() for more details; 1242 ; 1243Bool_t THttpServer::Register(const char *subfolder, TObject *obj); 1244{; 1245 return fSniffer->RegisterObject(subfolder, obj);; 1246}; 1247 ; 1248////////////////////////////////////////////////////////////////////////////////; 1249/// Unregister object in folders hierarchy; 1250///; 1251/// See TRootSniffer::UnregisterObject() for more details; 1252 ; 1253Bool_t THttpServer::Unregister(TObject *obj); 1254{; 1255 return fSniffer->UnregisterObject(obj);; 1256}; 1257 ; 1258////////////////////////////////////////////////////////////////////////////////; 1259/// Register WS handler to the THttpServer; 1260///; 1261/// Only such handler can be used in multi-threaded processing of websockets; 1262 ; 1263void THttpServer::RegisterWS(std::shared_ptr<THttpWSHandler> ws); 1264{; 1265 std::lock_guard<std::mutex> grd(fWSMutex);; 1266 fWSHandlers.emplace_back(ws);; 1267}; 1268 ; 1269////////////////////////////////////////////////////////////////////////////////; 1270/// Unregister WS handler to the THttpServer; 1271 ; 1272void THttpServer::UnregisterWS(std::shared_ptr<THttpWSHandler> ws); 1273{; 1274 std::lock_guard<std::mutex> grd(",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:58971,Safety,safe,safe,58971,"oldervirtual void ProcessBatchHolder(std::shared_ptr< THttpCallArg > &arg)Process special http request for root_batch_holder.js script.Definition THttpServer.cxx:799; THttpServer::fWSHandlersstd::vector< std::shared_ptr< THttpWSHandler > > fWSHandlers! list of WS handlersDefinition THttpServer.h:61; THttpServer::~THttpServervirtual ~THttpServer()destructorDefinition THttpServer.cxx:245; THttpServer::SetTerminatevoid SetTerminate()set termination flag, no any further requests will be processedDefinition THttpServer.cxx:277; THttpServer::MissedRequestvirtual void MissedRequest(THttpCallArg *arg)Method called when THttpServer cannot process request.Definition THttpServer.cxx:788; THttpServer::fOwnThreadBool_t fOwnThread! true when specialized thread allocated for processing requestsDefinition THttpServer.h:40; THttpServer::SetSniffervoid SetSniffer(TRootSniffer *sniff)Set TRootSniffer to the server.Definition THttpServer.cxx:267; THttpServer::IsFileRequestedBool_t IsFileRequested(const char *uri, TString &res) constCheck if file is requested, thread safe.Definition THttpServer.cxx:612; THttpServer::SetReadOnlyvoid SetReadOnly(Bool_t readonly=kTRUE)Set read-only mode for the server (default on)Definition THttpServer.cxx:296; THttpServer::GetItemFieldconst char * GetItemField(const char *fullname, const char *name)Get item field from sniffer.Definition THttpServer.cxx:1471; THttpServer::GetCorsconst char * GetCors() constReturns specified CORS domain.Definition THttpServer.h:115; THttpServer::fThrdstd::thread fThrd! own threadDefinition THttpServer.h:41; THttpServer::StopServerThreadvoid StopServerThread()Stop server thread.Definition THttpServer.cxx:547; THttpServer::ProcessRequestsInt_t ProcessRequests()Process submitted requests, must be called from appropriate thread.Definition THttpServer.cxx:708; THttpServer::ExecuteWSBool_t ExecuteWS(std::shared_ptr< THttpCallArg > &arg, Bool_t external_thrd=kFALSE, Bool_t wait_process=kFALSE)Execute WS request.Definition THttpSer",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:2424,Security,access,access,2424,"THttpTimer : public TTimer {; 43 Long_t fNormalTmout{0};; 44 Bool_t fSlow{kFALSE};; 45 Int_t fSlowCnt{0};; 46 ; 47public:; 48 THttpServer &fServer; ///!< server processing requests; 49 ; 50 /// constructor; 51 THttpTimer(Long_t milliSec, Bool_t mode, THttpServer &serv) : TTimer(milliSec, mode), fNormalTmout(milliSec), fServer(serv) {}; 52 ; 53 void SetSlow(Bool_t flag); 54 {; 55 fSlow = flag;; 56 fSlowCnt = 0;; 57 Long_t ms = fNormalTmout;; 58 if (fSlow) {; 59 if (ms < 100); 60 ms = 500;; 61 else if (ms < 500); 62 ms = 3000;; 63 else; 64 ms = 10000;; 65 }; 66 ; 67 SetTime(ms);; 68 }; 69 Bool_t IsSlow() const { return fSlow; }; 70 ; 71 /// timeout handler; 72 /// used to process http requests in main ROOT thread; 73 void Timeout() override; 74 {; 75 Int_t nprocess = fServer.ProcessRequests();; 76 ; 77 if (nprocess > 0) {; 78 fSlowCnt = 0;; 79 if (IsSlow()); 80 SetSlow(kFALSE);; 81 } else if (!IsSlow() && (fSlowCnt++ > 10)) {; 82 SetSlow(kTRUE);; 83 }; 84 }; 85};; 86 ; 87 ; 88/** \class THttpServer; 89\ingroup http; 90 ; 91Online http server for arbitrary ROOT application; 92 ; 93Idea of THttpServer - provide remote http access to running; 94ROOT application and enable HTML/JavaScript user interface.; 95Any registered object can be requested and displayed in the browser.; 96There are many benefits of such approach:; 97 ; 981. standard http interface to ROOT application; 992. no any temporary ROOT files when access data; 1003. user interface running in all browsers; 101 ; 102To start http server simply create instance; 103of the THttpServer class like:; 104 ; 105 serv = new THttpServer(""http:8080"");; 106 ; 107This will starts civetweb-based http server with http port 8080.; 108Than one should be able to open address ""http://localhost:8080""; 109in any modern web browser (Firefox, Chrome, Opera, ...) and browse objects,; 110created in ROOT application. By default, server can access files,; 111canvases and histograms via `gROOT` pointer. All such objects; 112can be display",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:2716,Security,access,access,2716,"g_t ms = fNormalTmout;; 58 if (fSlow) {; 59 if (ms < 100); 60 ms = 500;; 61 else if (ms < 500); 62 ms = 3000;; 63 else; 64 ms = 10000;; 65 }; 66 ; 67 SetTime(ms);; 68 }; 69 Bool_t IsSlow() const { return fSlow; }; 70 ; 71 /// timeout handler; 72 /// used to process http requests in main ROOT thread; 73 void Timeout() override; 74 {; 75 Int_t nprocess = fServer.ProcessRequests();; 76 ; 77 if (nprocess > 0) {; 78 fSlowCnt = 0;; 79 if (IsSlow()); 80 SetSlow(kFALSE);; 81 } else if (!IsSlow() && (fSlowCnt++ > 10)) {; 82 SetSlow(kTRUE);; 83 }; 84 }; 85};; 86 ; 87 ; 88/** \class THttpServer; 89\ingroup http; 90 ; 91Online http server for arbitrary ROOT application; 92 ; 93Idea of THttpServer - provide remote http access to running; 94ROOT application and enable HTML/JavaScript user interface.; 95Any registered object can be requested and displayed in the browser.; 96There are many benefits of such approach:; 97 ; 981. standard http interface to ROOT application; 992. no any temporary ROOT files when access data; 1003. user interface running in all browsers; 101 ; 102To start http server simply create instance; 103of the THttpServer class like:; 104 ; 105 serv = new THttpServer(""http:8080"");; 106 ; 107This will starts civetweb-based http server with http port 8080.; 108Than one should be able to open address ""http://localhost:8080""; 109in any modern web browser (Firefox, Chrome, Opera, ...) and browse objects,; 110created in ROOT application. By default, server can access files,; 111canvases and histograms via `gROOT` pointer. All such objects; 112can be displayed with JSROOT graphics.; 113 ; 114At any time one could register other objects with the command:; 115 ; 116 TGraph* gr = new TGraph(10);; 117 gr->SetName(""gr1"");; 118 serv->Register(""graphs/subfolder"", gr);; 119 ; 120If objects content is changing in the application, one could; 121enable monitoring flag in the browser - than objects view; 122will be regularly updated.; 123 ; 124More information: https://root.cern/ro",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:3190,Security,access,access,3190,"wCnt++ > 10)) {; 82 SetSlow(kTRUE);; 83 }; 84 }; 85};; 86 ; 87 ; 88/** \class THttpServer; 89\ingroup http; 90 ; 91Online http server for arbitrary ROOT application; 92 ; 93Idea of THttpServer - provide remote http access to running; 94ROOT application and enable HTML/JavaScript user interface.; 95Any registered object can be requested and displayed in the browser.; 96There are many benefits of such approach:; 97 ; 981. standard http interface to ROOT application; 992. no any temporary ROOT files when access data; 1003. user interface running in all browsers; 101 ; 102To start http server simply create instance; 103of the THttpServer class like:; 104 ; 105 serv = new THttpServer(""http:8080"");; 106 ; 107This will starts civetweb-based http server with http port 8080.; 108Than one should be able to open address ""http://localhost:8080""; 109in any modern web browser (Firefox, Chrome, Opera, ...) and browse objects,; 110created in ROOT application. By default, server can access files,; 111canvases and histograms via `gROOT` pointer. All such objects; 112can be displayed with JSROOT graphics.; 113 ; 114At any time one could register other objects with the command:; 115 ; 116 TGraph* gr = new TGraph(10);; 117 gr->SetName(""gr1"");; 118 serv->Register(""graphs/subfolder"", gr);; 119 ; 120If objects content is changing in the application, one could; 121enable monitoring flag in the browser - than objects view; 122will be regularly updated.; 123 ; 124More information: https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html; 125*/; 126 ; 127ClassImp(THttpServer);; 128 ; 129////////////////////////////////////////////////////////////////////////////////; 130/// constructor; 131///; 132/// As argument, one specifies engine kind which should be; 133/// created like ""http:8080"". One could specify several engines; 134/// at once, separating them with semicolon ("";""). Following engines are supported:; 135///; 136/// http - TCivetweb, civetweb-based implementation of http protoc",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:10397,Security,access,access,10397,"/// In read-only server is not allowed to change any ROOT object, registered to the server; 294/// Server also cannot execute objects method via exe.json request; 295 ; 296void THttpServer::SetReadOnly(Bool_t readonly); 297{; 298 if (fSniffer); 299 fSniffer->SetReadOnly(readonly);; 300}; 301 ; 302////////////////////////////////////////////////////////////////////////////////; 303/// returns true if only websockets are handled by the server; 304///; 305/// Typically used by WebGui; 306 ; 307Bool_t THttpServer::IsWSOnly() const; 308{; 309 return fWSOnly;; 310}; 311 ; 312////////////////////////////////////////////////////////////////////////////////; 313/// Set websocket-only mode.; 314///; 315/// If true, server will only handle websockets connection; 316/// plus serving file requests to access jsroot/ui5 scripts; 317 ; 318void THttpServer::SetWSOnly(Bool_t on); 319{; 320 fWSOnly = on;; 321}; 322 ; 323////////////////////////////////////////////////////////////////////////////////; 324/// Add files location, which could be used in the server; 325///; 326/// One could map some system folder to the server like; 327///; 328/// serv->AddLocation(""mydir/"", ""/home/user/specials"");; 329///; 330/// Than files from this directory could be addressed via server like `http://localhost:8080/mydir/myfile.root`; 331 ; 332void THttpServer::AddLocation(const char *prefix, const char *path); 333{; 334 if (!prefix || (*prefix == 0)); 335 return;; 336 ; 337 if (!path); 338 fLocations.erase(fLocations.find(prefix));; 339 else; 340 fLocations[prefix] = path;; 341}; 342 ; 343////////////////////////////////////////////////////////////////////////////////; 344/// Set location of JSROOT to use with the server; 345///; 346/// One could specify address like:; 347///; 348/// * https://root.cern/js/7.6.0/; 349/// * https://jsroot.gsi.de/7.6.0/; 350///; 351/// This allows to get new JSROOT features with old server,; 352/// reduce load on THttpServer instance, also startup time can be improved; 35",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:16937,Security,access,access,16937,"equires, that application regularly; 482/// calls gSystem->ProcessEvents(). It happens automatically in ROOT interactive shell.; 483/// If milliSec == 0, no timer will be created.; 484/// In this case application should regularly call ProcessRequests() method.; 485///; 486/// Async timer allows to use THttpServer in applications, which does not have explicit; 487/// gSystem->ProcessEvents() calls. But be aware, that such timer can interrupt any system call; 488/// (like malloc) and can lead to dead locks, especially in multi-threaded applications.; 489 ; 490void THttpServer::SetTimer(Long_t milliSec, Bool_t mode); 491{; 492 if (fTimer) {; 493 fTimer->Stop();; 494 fTimer.reset();; 495 }; 496 if (milliSec > 0) {; 497 if (fOwnThread) {; 498 Error(""SetTimer"", ""Server runs already in special thread, therefore no any timer can be created"");; 499 } else {; 500 fTimer = std::make_unique<THttpTimer>(milliSec, mode, *this);; 501 fTimer->TurnOn();; 502 }; 503 }; 504}; 505 ; 506////////////////////////////////////////////////////////////////////////////////; 507/// Creates special thread to process all requests, directed to http server; 508///; 509/// Should be used with care - only dedicated instance of TRootSniffer is allowed; 510/// By default THttpServer allows to access global lists pointers gROOT or gFile.; 511/// To be on the safe side, all kind of such access performed from the main thread.; 512/// Therefore usage of specialized thread means that no any global pointers will; 513/// be accessible by THttpServer; 514 ; 515void THttpServer::CreateServerThread(); 516{; 517 if (fOwnThread); 518 return;; 519 ; 520 SetTimer(0);; 521 fMainThrdId = 0;; 522 fOwnThread = true;; 523 ; 524 std::thread thrd([this] {; 525 int nempty = 0;; 526 while (fOwnThread && !fTerminated) {; 527 int nprocess = ProcessRequests();; 528 if (nprocess > 0); 529 nempty = 0;; 530 else; 531 nempty++;; 532 if (nempty > 1000) {; 533 nempty = 0;; 534 std::this_thread::sleep_for(std::chrono::milliseconds(1))",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:17031,Security,access,access,17031,"/// gSystem->ProcessEvents() calls. But be aware, that such timer can interrupt any system call; 488/// (like malloc) and can lead to dead locks, especially in multi-threaded applications.; 489 ; 490void THttpServer::SetTimer(Long_t milliSec, Bool_t mode); 491{; 492 if (fTimer) {; 493 fTimer->Stop();; 494 fTimer.reset();; 495 }; 496 if (milliSec > 0) {; 497 if (fOwnThread) {; 498 Error(""SetTimer"", ""Server runs already in special thread, therefore no any timer can be created"");; 499 } else {; 500 fTimer = std::make_unique<THttpTimer>(milliSec, mode, *this);; 501 fTimer->TurnOn();; 502 }; 503 }; 504}; 505 ; 506////////////////////////////////////////////////////////////////////////////////; 507/// Creates special thread to process all requests, directed to http server; 508///; 509/// Should be used with care - only dedicated instance of TRootSniffer is allowed; 510/// By default THttpServer allows to access global lists pointers gROOT or gFile.; 511/// To be on the safe side, all kind of such access performed from the main thread.; 512/// Therefore usage of specialized thread means that no any global pointers will; 513/// be accessible by THttpServer; 514 ; 515void THttpServer::CreateServerThread(); 516{; 517 if (fOwnThread); 518 return;; 519 ; 520 SetTimer(0);; 521 fMainThrdId = 0;; 522 fOwnThread = true;; 523 ; 524 std::thread thrd([this] {; 525 int nempty = 0;; 526 while (fOwnThread && !fTerminated) {; 527 int nprocess = ProcessRequests();; 528 if (nprocess > 0); 529 nempty = 0;; 530 else; 531 nempty++;; 532 if (nempty > 1000) {; 533 nempty = 0;; 534 std::this_thread::sleep_for(std::chrono::milliseconds(1));; 535 }; 536 }; 537 });; 538 ; 539 fThrd = std::move(thrd);; 540}; 541 ; 542////////////////////////////////////////////////////////////////////////////////; 543/// Stop server thread; 544///; 545/// Normally called shortly before http server destructor; 546 ; 547void THttpServer::StopServerThread(); 548{; 549 if (!fOwnThread); 550 return;; 551 ; 552 fOwnThread ",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:17166,Security,access,accessible,17166,"Timer>(milliSec, mode, *this);; 501 fTimer->TurnOn();; 502 }; 503 }; 504}; 505 ; 506////////////////////////////////////////////////////////////////////////////////; 507/// Creates special thread to process all requests, directed to http server; 508///; 509/// Should be used with care - only dedicated instance of TRootSniffer is allowed; 510/// By default THttpServer allows to access global lists pointers gROOT or gFile.; 511/// To be on the safe side, all kind of such access performed from the main thread.; 512/// Therefore usage of specialized thread means that no any global pointers will; 513/// be accessible by THttpServer; 514 ; 515void THttpServer::CreateServerThread(); 516{; 517 if (fOwnThread); 518 return;; 519 ; 520 SetTimer(0);; 521 fMainThrdId = 0;; 522 fOwnThread = true;; 523 ; 524 std::thread thrd([this] {; 525 int nempty = 0;; 526 while (fOwnThread && !fTerminated) {; 527 int nprocess = ProcessRequests();; 528 if (nprocess > 0); 529 nempty = 0;; 530 else; 531 nempty++;; 532 if (nempty > 1000) {; 533 nempty = 0;; 534 std::this_thread::sleep_for(std::chrono::milliseconds(1));; 535 }; 536 }; 537 });; 538 ; 539 fThrd = std::move(thrd);; 540}; 541 ; 542////////////////////////////////////////////////////////////////////////////////; 543/// Stop server thread; 544///; 545/// Normally called shortly before http server destructor; 546 ; 547void THttpServer::StopServerThread(); 548{; 549 if (!fOwnThread); 550 return;; 551 ; 552 fOwnThread = false;; 553 fThrd.join();; 554 fMainThrdId = 0;; 555}; 556 ; 557////////////////////////////////////////////////////////////////////////////////; 558/// Checked that filename does not contains relative path below current directory; 559///; 560/// Used to prevent access to files below current directory; 561 ; 562Bool_t THttpServer::VerifyFilePath(const char *fname); 563{; 564 if (!fname || (*fname == 0)); 565 return kFALSE;; 566 ; 567 Int_t level = 0;; 568 ; 569 while (*fname) {; 570 ; 571 // find next slash or backslash; 572",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:18290,Security,access,access,18290,"25 int nempty = 0;; 526 while (fOwnThread && !fTerminated) {; 527 int nprocess = ProcessRequests();; 528 if (nprocess > 0); 529 nempty = 0;; 530 else; 531 nempty++;; 532 if (nempty > 1000) {; 533 nempty = 0;; 534 std::this_thread::sleep_for(std::chrono::milliseconds(1));; 535 }; 536 }; 537 });; 538 ; 539 fThrd = std::move(thrd);; 540}; 541 ; 542////////////////////////////////////////////////////////////////////////////////; 543/// Stop server thread; 544///; 545/// Normally called shortly before http server destructor; 546 ; 547void THttpServer::StopServerThread(); 548{; 549 if (!fOwnThread); 550 return;; 551 ; 552 fOwnThread = false;; 553 fThrd.join();; 554 fMainThrdId = 0;; 555}; 556 ; 557////////////////////////////////////////////////////////////////////////////////; 558/// Checked that filename does not contains relative path below current directory; 559///; 560/// Used to prevent access to files below current directory; 561 ; 562Bool_t THttpServer::VerifyFilePath(const char *fname); 563{; 564 if (!fname || (*fname == 0)); 565 return kFALSE;; 566 ; 567 Int_t level = 0;; 568 ; 569 while (*fname) {; 570 ; 571 // find next slash or backslash; 572 const char *next = strpbrk(fname, ""/\\"");; 573 if (next == 0); 574 return kTRUE;; 575 ; 576 // most important - change to parent dir; 577 if ((next == fname + 2) && (*fname == '.') && (*(fname + 1) == '.')) {; 578 fname += 3;; 579 level--;; 580 if (level < 0); 581 return kFALSE;; 582 continue;; 583 }; 584 ; 585 // ignore current directory; 586 if ((next == fname + 1) && (*fname == '.')) {; 587 fname += 2;; 588 continue;; 589 }; 590 ; 591 // ignore slash at the front; 592 if (next == fname) {; 593 fname++;; 594 continue;; 595 }; 596 ; 597 fname = next + 1;; 598 level++;; 599 }; 600 ; 601 return kTRUE;; 602}; 603 ; 604////////////////////////////////////////////////////////////////////////////////; 605/// Verifies that request is just file name; 606///; 607/// File names typically contains prefix like ""jsrootsys/""; 608/// I",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:32785,Security,secur,security,32785,"OTSYS + ""/files/online.htm"").Data());; 998 ; 999 } else {; 1000 auto wsptr = FindWS(arg->GetPathName());; 1001 ; 1002 auto handler = wsptr.get();; 1003 ; 1004 if (!handler); 1005 handler = dynamic_cast<THttpWSHandler *>(fSniffer->FindTObjectInHierarchy(arg->fPathName.Data()));; 1006 ; 1007 if (handler) {; 1008 ; 1009 arg->fContent = handler->GetDefaultPageContent().Data();; 1010 ; 1011 if (arg->fContent.find(""file:"") == 0) {; 1012 const char *fname = arg->fContent.c_str() + 5;; 1013 TString resolve;; 1014 if (!IsFileRequested(fname, resolve)) resolve = fname;; 1015 arg->fContent = ReadFileContent(resolve.Data());; 1016 }; 1017 ; 1018 version = handler->GetCodeVersion();; 1019 ; 1020 handler->VerifyDefaultPageContent(arg);; 1021 }; 1022 }; 1023 ; 1024 if (arg->fContent.empty() && arg->fFileName.IsNull() && arg->fPathName.IsNull() && IsWSOnly()) {; 1025 // Creating page with list of available widgets is disabled now for security reasons; 1026 // Later one can provide functionality back only if explicitly desired by the user; 1027 // BuildWSEntryPage();; 1028 ; 1029 arg->SetContent(""refused"");; 1030 arg->Set404();; 1031 }; 1032 ; 1033 if (arg->fContent.empty() && !IsWSOnly()) {; 1034 ; 1035 if (fDefaultPageCont.empty()); 1036 fDefaultPageCont = ReadFileContent(fDefaultPage);; 1037 ; 1038 arg->fContent = fDefaultPageCont;; 1039 }; 1040 ; 1041 if (arg->fContent.empty()) {; 1042 ; 1043 arg->Set404();; 1044 } else if (!arg->Is404()) {; 1045 ; 1046 ReplaceJSROOTLinks(arg, version);; 1047 ; 1048 const char *hjsontag = ""\""$$$h.json$$$\"""";; 1049 ; 1050 // add h.json caching; 1051 if (arg->fContent.find(hjsontag) != std::string::npos) {; 1052 TString h_json;; 1053 TRootSnifferStoreJson store(h_json, kTRUE);; 1054 const char *topname = fTopName.Data();; 1055 if (arg->fTopName.Length() > 0); 1056 topname = arg->fTopName.Data();; 1057 fSniffer->ScanHierarchy(topname, arg->fPathName.Data(), &store);; 1058 ; 1059 arg->ReplaceAllinContent(hjsontag, h_json.Data());; 1060 ; 1061 arg->A",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:44126,Security,access,access,44126," 1346 ; 1347 if (handler->HandleWS(arg)) {; 1348 arg->SetMethod(""WS_READY"");; 1349 ; 1350 if (handler->HandleWS(arg)); 1351 arg->SetTextContent(std::string(israw ? ""txt:"" : """") + std::to_string(arg->GetWSId()));; 1352 } else {; 1353 arg->TakeWSEngine(); // delete handle; 1354 }; 1355 ; 1356 process = arg->IsText();; 1357 } else {; 1358 TUrl url;; 1359 url.SetOptions(arg->fQuery);; 1360 url.ParseOptions();; 1361 const char *connid = url.GetValueFromOptions(""connection"");; 1362 if (connid); 1363 arg->SetWSId(std::stoul(connid));; 1364 if (url.HasOption(""close"")) {; 1365 arg->SetMethod(""WS_CLOSE"");; 1366 arg->SetTextContent(""OK"");; 1367 } else {; 1368 arg->SetMethod(""WS_DATA"");; 1369 }; 1370 ; 1371 process = handler->HandleWS(arg);; 1372 }; 1373 }; 1374 ; 1375 if (!process); 1376 arg->Set404();; 1377 ; 1378 return process;; 1379}; 1380 ; 1381////////////////////////////////////////////////////////////////////////////////; 1382/// Restrict access to specified object; 1383///; 1384/// See TRootSniffer::Restrict() for more details; 1385 ; 1386void THttpServer::Restrict(const char *path, const char *options); 1387{; 1388 fSniffer->Restrict(path, options);; 1389}; 1390 ; 1391////////////////////////////////////////////////////////////////////////////////; 1392/// Register command which can be executed from web interface; 1393///; 1394/// As method one typically specifies string, which is executed with; 1395/// gROOT->ProcessLine() method. For instance:; 1396///; 1397/// serv->RegisterCommand(""Invoke"",""InvokeFunction()"");; 1398///; 1399/// Or one could specify any method of the object which is already registered; 1400/// to the server. For instance:; 1401///; 1402/// serv->Register(""/"", hpx);; 1403/// serv->RegisterCommand(""/ResetHPX"", ""/hpx/->Reset()"");; 1404///; 1405/// Here symbols '/->' separates item name from method to be executed; 1406///; 1407/// One could specify additional arguments in the command with; 1408/// syntax like %arg1%, %arg2% and so on. For example:; 140",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:57644,Security,access,access,57644,"ngine.Definition THttpEngine.h:37; THttpLongPollEngineEmulation of websocket with long poll requests.Definition THttpLongPollEngine.h:23; THttpServerOnline http server for arbitrary ROOT application.Definition THttpServer.h:31; THttpServer::IsReadOnlyBool_t IsReadOnly() constreturns read-only modeDefinition THttpServer.cxx:285; THttpServer::RegisterCommandBool_t RegisterCommand(const char *cmdname, const char *method, const char *icon=nullptr)Register command which can be executed from web interface.Definition THttpServer.cxx:1428; THttpServer::fJSROOTTString fJSROOT! location of external JSROOT filesDefinition THttpServer.h:46; THttpServer::ProcessRequestvirtual void ProcessRequest(std::shared_ptr< THttpCallArg > arg)Process single http request.Definition THttpServer.cxx:978; THttpServer::FindWSstd::shared_ptr< THttpWSHandler > FindWS(const char *name)Find web-socket handler with given name.Definition THttpServer.cxx:1285; THttpServer::fSnifferstd::unique_ptr< TRootSniffer > fSniffer! sniffer provides access to ROOT objects hierarchyDefinition THttpServer.h:36; THttpServer::SetTimervoid SetTimer(Long_t milliSec=100, Bool_t mode=kTRUE)Create timer which will invoke ProcessRequests() function periodically.Definition THttpServer.cxx:490; THttpServer::ProcessBatchHoldervirtual void ProcessBatchHolder(std::shared_ptr< THttpCallArg > &arg)Process special http request for root_batch_holder.js script.Definition THttpServer.cxx:799; THttpServer::fWSHandlersstd::vector< std::shared_ptr< THttpWSHandler > > fWSHandlers! list of WS handlersDefinition THttpServer.h:61; THttpServer::~THttpServervirtual ~THttpServer()destructorDefinition THttpServer.cxx:245; THttpServer::SetTerminatevoid SetTerminate()set termination flag, no any further requests will be processedDefinition THttpServer.cxx:277; THttpServer::MissedRequestvirtual void MissedRequest(THttpCallArg *arg)Method called when THttpServer cannot process request.Definition THttpServer.cxx:788; THttpServer::fOwnThreadBool_t fOw",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:61269,Security,access,accessed,61269,"name of top folder, default - ""ROOT""Definition THttpServer.h:45; THttpServer::SetDrawPagevoid SetDrawPage(const std::string &filename="""")Set drawing HTML page.Definition THttpServer.cxx:387; THttpServer::CreateItemBool_t CreateItem(const char *fullname, const char *title)Create item in sniffer.Definition THttpServer.cxx:1455; THttpServer::ExecuteHttpBool_t ExecuteHttp(std::shared_ptr< THttpCallArg > arg)Execute HTTP request.Definition THttpServer.cxx:642; THttpServer::HideBool_t Hide(const char *fullname, Bool_t hide=kTRUE)Hides folder or element from web gui.Definition THttpServer.cxx:1436; THttpServer::IsCorsCredentialsBool_t IsCorsCredentials() constReturns kTRUE if Access-Control-Allow-Credentials header should be used.Definition THttpServer.h:121; THttpServer::AddLocationvoid AddLocation(const char *prefix, const char *path)Add files location, which could be used in the server.Definition THttpServer.cxx:332; THttpServer::fLocationsstd::map< std::string, std::string > fLocations! list of local directories, which could be accessed via serverDefinition THttpServer.h:48; THttpServer::SubmitHttpBool_t SubmitHttp(std::shared_ptr< THttpCallArg > arg, Bool_t can_run_immediately=kFALSE)Submit HTTP request.Definition THttpServer.cxx:681; THttpServer::fMainThrdIdLong_t fMainThrdId! id of the thread for processing requestsDefinition THttpServer.h:38; THttpServer::fJSROOTSYSTString fJSROOTSYS! location of local JSROOT filesDefinition THttpServer.h:44; THttpServer::fTimerstd::unique_ptr< THttpTimer > fTimer! timer used to access main threadDefinition THttpServer.h:35; THttpServer::fWSOnlyBool_t fWSOnly! when true, handle only websockets / longpoll engineDefinition THttpServer.h:42; THttpServer::RegisterBool_t Register(const char *subfolder, TObject *obj)Register object in subfolder.Definition THttpServer.cxx:1243; THttpServer::fEnginesTList fEngines! engines which runs http serverDefinition THttpServer.h:34; THttpServer::SetCorsvoid SetCors(const std::string &domain=""*"")Enabl",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:61767,Security,access,access,61767,"e=kTRUE)Hides folder or element from web gui.Definition THttpServer.cxx:1436; THttpServer::IsCorsCredentialsBool_t IsCorsCredentials() constReturns kTRUE if Access-Control-Allow-Credentials header should be used.Definition THttpServer.h:121; THttpServer::AddLocationvoid AddLocation(const char *prefix, const char *path)Add files location, which could be used in the server.Definition THttpServer.cxx:332; THttpServer::fLocationsstd::map< std::string, std::string > fLocations! list of local directories, which could be accessed via serverDefinition THttpServer.h:48; THttpServer::SubmitHttpBool_t SubmitHttp(std::shared_ptr< THttpCallArg > arg, Bool_t can_run_immediately=kFALSE)Submit HTTP request.Definition THttpServer.cxx:681; THttpServer::fMainThrdIdLong_t fMainThrdId! id of the thread for processing requestsDefinition THttpServer.h:38; THttpServer::fJSROOTSYSTString fJSROOTSYS! location of local JSROOT filesDefinition THttpServer.h:44; THttpServer::fTimerstd::unique_ptr< THttpTimer > fTimer! timer used to access main threadDefinition THttpServer.h:35; THttpServer::fWSOnlyBool_t fWSOnly! when true, handle only websockets / longpoll engineDefinition THttpServer.h:42; THttpServer::RegisterBool_t Register(const char *subfolder, TObject *obj)Register object in subfolder.Definition THttpServer.cxx:1243; THttpServer::fEnginesTList fEngines! engines which runs http serverDefinition THttpServer.h:34; THttpServer::SetCorsvoid SetCors(const std::string &domain=""*"")Enable CORS header to ProcessRequests() responses Specified location (typically ""*"") add as ""Access-C...Definition THttpServer.h:109; THttpServer::IsCorsBool_t IsCors() constReturns kTRUE if CORS was configured.Definition THttpServer.h:112; THttpServer::GetCorsCredentialsconst char * GetCorsCredentials() constReturns specified CORS credentials value - if any.Definition THttpServer.h:124; THttpServer::fArgsstd::queue< std::shared_ptr< THttpCallArg > > fArgs! submitted argumentsDefinition THttpServer.h:58; THttpServer::Se",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:66016,Security,access,access,66016,"xstd::mutex fMutex! mutex to protect list with argumentsDefinition THttpServer.h:57; THttpServer::fDefaultPagestd::string fDefaultPage! file name for default page nameDefinition THttpServer.h:50; THttpServer::UnregisterWSvoid UnregisterWS(std::shared_ptr< THttpWSHandler > ws)Unregister WS handler.Definition THttpServer.cxx:1272; THttpServer::GetMimeTypestatic const char * GetMimeType(const char *path)Guess mime type base on file extension.Definition THttpServer.cxx:1479; THttpServer::GetSnifferTRootSniffer * GetSniffer() constreturns pointer on objects snifferDefinition THttpServer.h:89; THttpServer::ReplaceJSROOTLinksvoid ReplaceJSROOTLinks(std::shared_ptr< THttpCallArg > &arg, const std::string &version="""")Replaces all references like ""jsrootsys/..."" or other pre-configured pathes.Definition THttpServer.cxx:847; THttpServer::fTerminatedBool_t fTerminated! termination flag, disables all requests processingDefinition THttpServer.h:37; THttpServer::Restrictvoid Restrict(const char *path, const char *options)Restrict access to specified object.Definition THttpServer.cxx:1386; THttpTimerDefinition THttpServer.cxx:42; THttpTimer::fNormalTmoutLong_t fNormalTmoutDefinition THttpServer.cxx:43; THttpTimer::fSlowBool_t fSlowDefinition THttpServer.cxx:44; THttpTimer::fSlowCntInt_t fSlowCntDefinition THttpServer.cxx:45; THttpTimer::Timeoutvoid Timeout() overridetimeout handler used to process http requests in main ROOT threadDefinition THttpServer.cxx:73; THttpTimer::IsSlowBool_t IsSlow() constDefinition THttpServer.cxx:69; THttpTimer::SetSlowvoid SetSlow(Bool_t flag)Definition THttpServer.cxx:53; THttpTimer::fServerTHttpServer & fServerDefinition THttpServer.cxx:48; THttpTimer::THttpTimerTHttpTimer(Long_t milliSec, Bool_t mode, THttpServer &serv)!< server processing requestsDefinition THttpServer.cxx:51; THttpWSHandlerClass for user-side handling of websocket with THttpServer.Definition THttpWSHandler.h:25; THttpWSHandler::GetDefaultPageContentvirtual TString GetDefaultPageCon",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:2805,Usability,simpl,simply,2805,"etTime(ms);; 68 }; 69 Bool_t IsSlow() const { return fSlow; }; 70 ; 71 /// timeout handler; 72 /// used to process http requests in main ROOT thread; 73 void Timeout() override; 74 {; 75 Int_t nprocess = fServer.ProcessRequests();; 76 ; 77 if (nprocess > 0) {; 78 fSlowCnt = 0;; 79 if (IsSlow()); 80 SetSlow(kFALSE);; 81 } else if (!IsSlow() && (fSlowCnt++ > 10)) {; 82 SetSlow(kTRUE);; 83 }; 84 }; 85};; 86 ; 87 ; 88/** \class THttpServer; 89\ingroup http; 90 ; 91Online http server for arbitrary ROOT application; 92 ; 93Idea of THttpServer - provide remote http access to running; 94ROOT application and enable HTML/JavaScript user interface.; 95Any registered object can be requested and displayed in the browser.; 96There are many benefits of such approach:; 97 ; 981. standard http interface to ROOT application; 992. no any temporary ROOT files when access data; 1003. user interface running in all browsers; 101 ; 102To start http server simply create instance; 103of the THttpServer class like:; 104 ; 105 serv = new THttpServer(""http:8080"");; 106 ; 107This will starts civetweb-based http server with http port 8080.; 108Than one should be able to open address ""http://localhost:8080""; 109in any modern web browser (Firefox, Chrome, Opera, ...) and browse objects,; 110created in ROOT application. By default, server can access files,; 111canvases and histograms via `gROOT` pointer. All such objects; 112can be displayed with JSROOT graphics.; 113 ; 114At any time one could register other objects with the command:; 115 ; 116 TGraph* gr = new TGraph(10);; 117 gr->SetName(""gr1"");; 118 serv->Register(""graphs/subfolder"", gr);; 119 ; 120If objects content is changing in the application, one could; 121enable monitoring flag in the browser - than objects view; 122will be regularly updated.; 123 ; 124More information: https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html; 125*/; 126 ; 127ClassImp(THttpServer);; 128 ; 129/////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:3719,Usability,guid,guides,3719,"ata; 1003. user interface running in all browsers; 101 ; 102To start http server simply create instance; 103of the THttpServer class like:; 104 ; 105 serv = new THttpServer(""http:8080"");; 106 ; 107This will starts civetweb-based http server with http port 8080.; 108Than one should be able to open address ""http://localhost:8080""; 109in any modern web browser (Firefox, Chrome, Opera, ...) and browse objects,; 110created in ROOT application. By default, server can access files,; 111canvases and histograms via `gROOT` pointer. All such objects; 112can be displayed with JSROOT graphics.; 113 ; 114At any time one could register other objects with the command:; 115 ; 116 TGraph* gr = new TGraph(10);; 117 gr->SetName(""gr1"");; 118 serv->Register(""graphs/subfolder"", gr);; 119 ; 120If objects content is changing in the application, one could; 121enable monitoring flag in the browser - than objects view; 122will be regularly updated.; 123 ; 124More information: https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html; 125*/; 126 ; 127ClassImp(THttpServer);; 128 ; 129////////////////////////////////////////////////////////////////////////////////; 130/// constructor; 131///; 132/// As argument, one specifies engine kind which should be; 133/// created like ""http:8080"". One could specify several engines; 134/// at once, separating them with semicolon ("";""). Following engines are supported:; 135///; 136/// http - TCivetweb, civetweb-based implementation of http protocol; 137/// fastcgi - TFastCgi, special protocol for communicating with web servers; 138///; 139/// For each created engine one should provide socket port number like ""http:8080"" or ""fastcgi:9000"".; 140/// Additional engine-specific options can be supplied with URL syntax like ""http:8080?thrds=10"".; 141/// Full list of supported options should be checked in engines docu.; 142///; 143/// One also can configure following options, separated by semicolon:; 144///; 145/// readonly, ro - set read-only mode (default); ",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:12447,Usability,clear,clear,12447,"/ When empty string specified (default), local copy of JSROOT is used (distributed with ROOT); 354 ; 355void THttpServer::SetJSROOT(const char *location); 356{; 357 fJSROOT = location ? location : """";; 358}; 359 ; 360////////////////////////////////////////////////////////////////////////////////; 361/// Set default HTML page; 362///; 363/// Sets file name, delivered by the server when http address is opened in the browser.; 364///; 365/// By default, $ROOTSYS/js/files/online.htm page is used; 366/// When empty filename is specified, default page will be used; 367 ; 368void THttpServer::SetDefaultPage(const std::string &filename); 369{; 370 if (!filename.empty()); 371 fDefaultPage = filename;; 372 else; 373 fDefaultPage = fJSROOTSYS + ""/files/online.htm"";; 374 ; 375 // force to read page content next time again; 376 fDefaultPageCont.clear();; 377}; 378 ; 379////////////////////////////////////////////////////////////////////////////////; 380/// Set drawing HTML page; 381///; 382/// Set file name of HTML page, delivered by the server when; 383/// objects drawing page is requested from the browser; 384/// By default, $ROOTSYS/js/files/draw.htm page is used; 385/// When empty filename is specified, default page will be used; 386 ; 387void THttpServer::SetDrawPage(const std::string &filename); 388{; 389 if (!filename.empty()); 390 fDrawPage = filename;; 391 else; 392 fDrawPage = fJSROOTSYS + ""/files/draw.htm"";; 393 ; 394 // force to read page content next time again; 395 fDrawPageCont.clear();; 396}; 397 ; 398////////////////////////////////////////////////////////////////////////////////; 399/// Factory method to create different http engines; 400///; 401/// At the moment two engine kinds are supported:; 402///; 403/// * civetweb or http (default); 404/// * fastcgi; 405///; 406/// Examples:; 407///; 408/// // creates civetweb web server with http port 8080; 409/// serv->CreateEngine(""http:8080"");; 410/// serv->CreateEngine(""civetweb:8080"");; 411/// serv->CreateEngine("":",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:13108,Usability,clear,clear,13108," file name of HTML page, delivered by the server when; 383/// objects drawing page is requested from the browser; 384/// By default, $ROOTSYS/js/files/draw.htm page is used; 385/// When empty filename is specified, default page will be used; 386 ; 387void THttpServer::SetDrawPage(const std::string &filename); 388{; 389 if (!filename.empty()); 390 fDrawPage = filename;; 391 else; 392 fDrawPage = fJSROOTSYS + ""/files/draw.htm"";; 393 ; 394 // force to read page content next time again; 395 fDrawPageCont.clear();; 396}; 397 ; 398////////////////////////////////////////////////////////////////////////////////; 399/// Factory method to create different http engines; 400///; 401/// At the moment two engine kinds are supported:; 402///; 403/// * civetweb or http (default); 404/// * fastcgi; 405///; 406/// Examples:; 407///; 408/// // creates civetweb web server with http port 8080; 409/// serv->CreateEngine(""http:8080"");; 410/// serv->CreateEngine(""civetweb:8080"");; 411/// serv->CreateEngine("":8080"");; 412/// // creates fastcgi server with port 9000; 413/// serv->CreateEngine(""fastcgi:9000"");; 414///; 415/// One could apply additional parameters, using URL syntax:; 416///; 417/// serv->CreateEngine(""http:8080?thrds=10"");; 418 ; 419Bool_t THttpServer::CreateEngine(const char *engine); 420{; 421 if (!engine); 422 return kFALSE;; 423 ; 424 const char *arg = strchr(engine, ':');; 425 if (!arg); 426 return kFALSE;; 427 ; 428 TString clname, sarg;; 429 if (arg != engine); 430 clname.Append(engine, arg - engine);; 431 arg++; // skip first :; 432 ; 433 THttpEngine *eng = nullptr;; 434 ; 435 if ((clname.Length() == 0) || (clname == ""http"") || (clname == ""civetweb"")) {; 436 eng = new TCivetweb(kFALSE);; 437#ifndef R__WIN32; 438 } else if (clname == ""socket"") {; 439 eng = new TCivetweb(kFALSE);; 440 sarg = ""x""; // civetweb require x before socket name; 441 sarg.Append(arg);; 442 arg = sarg.Data();; 443#endif; 444 } else if (clname == ""https"") {; 445 eng = new TCivetweb(kTRUE);; 446 } ",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8cxx_source.html:51731,Usability,clear,clear,51731,"tent(const char *filename, Int_t &len); 1558{; 1559 len = 0;; 1560 ; 1561 std::ifstream is(filename, std::ios::in | std::ios::binary);; 1562 if (!is); 1563 return nullptr;; 1564 ; 1565 is.seekg(0, is.end);; 1566 len = is.tellg();; 1567 is.seekg(0, is.beg);; 1568 ; 1569 char *buf = (char *)malloc(len);; 1570 is.read(buf, len);; 1571 if (!is) {; 1572 free(buf);; 1573 len = 0;; 1574 return nullptr;; 1575 }; 1576 ; 1577 return buf;; 1578}; 1579 ; 1580////////////////////////////////////////////////////////////////////////////////; 1581/// Reads file content, using std::string as container; 1582 ; 1583std::string THttpServer::ReadFileContent(const std::string &filename); 1584{; 1585 std::ifstream is(filename, std::ios::in | std::ios::binary);; 1586 std::string res;; 1587 if (is) {; 1588 is.seekg(0, std::ios::end);; 1589 res.resize(is.tellg());; 1590 is.seekg(0, std::ios::beg);; 1591 is.read((char *)res.data(), res.length());; 1592 if (!is); 1593 res.clear();; 1594 }; 1595 return res;; 1596}; Long_tlong Long_tDefinition RtypesCore.h:54; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TCivetweb.h; TClass.h; TEnv.h; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; TError.h; TFastCgi.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char dept",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
https://root.cern/doc/master/THttpServer_8h_source.html:1583,Energy Efficiency,allocate,allocated,1583,"h""; 18 ; 19#include <mutex>; 20#include <map>; 21#include <string>; 22#include <memory>; 23#include <queue>; 24#include <thread>; 25#include <vector>; 26 ; 27class THttpEngine;; 28class THttpTimer;; 29class TRootSniffer;; 30 ; 31class THttpServer : public TNamed {; 32 ; 33protected:; 34 TList fEngines; ///<! engines which runs http server; 35 std::unique_ptr<THttpTimer> fTimer; ///<! timer used to access main thread; 36 std::unique_ptr<TRootSniffer> fSniffer; ///<! sniffer provides access to ROOT objects hierarchy; 37 Bool_t fTerminated{kFALSE}; ///<! termination flag, disables all requests processing; 38 Long_t fMainThrdId{0}; ///<! id of the thread for processing requests; 39 Long_t fProcessingThrdId{0}; ///<! id of the thread where events are recently processing; 40 Bool_t fOwnThread{kFALSE}; ///<! true when specialized thread allocated for processing requests; 41 std::thread fThrd; ///<! own thread; 42 Bool_t fWSOnly{kFALSE}; ///<! when true, handle only websockets / longpoll engine; 43 ; 44 TString fJSROOTSYS; ///<! location of local JSROOT files; 45 TString fTopName{""ROOT""}; ///<! name of top folder, default - ""ROOT""; 46 TString fJSROOT; ///<! location of external JSROOT files; 47 ; 48 std::map<std::string, std::string> fLocations; //",MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
https://root.cern/doc/master/THttpServer_8h_source.html:12665,Energy Efficiency,allocate,allocated,12665," ROOT objects hierarchyDefinition THttpServer.h:36; THttpServer::SetTimervoid SetTimer(Long_t milliSec=100, Bool_t mode=kTRUE)Create timer which will invoke ProcessRequests() function periodically.Definition THttpServer.cxx:490; THttpServer::ProcessBatchHoldervirtual void ProcessBatchHolder(std::shared_ptr< THttpCallArg > &arg)Process special http request for root_batch_holder.js script.Definition THttpServer.cxx:799; THttpServer::fWSHandlersstd::vector< std::shared_ptr< THttpWSHandler > > fWSHandlers! list of WS handlersDefinition THttpServer.h:61; THttpServer::~THttpServervirtual ~THttpServer()destructorDefinition THttpServer.cxx:245; THttpServer::SetTerminatevoid SetTerminate()set termination flag, no any further requests will be processedDefinition THttpServer.cxx:277; THttpServer::MissedRequestvirtual void MissedRequest(THttpCallArg *arg)Method called when THttpServer cannot process request.Definition THttpServer.cxx:788; THttpServer::fOwnThreadBool_t fOwnThread! true when specialized thread allocated for processing requestsDefinition THttpServer.h:40; THttpServer::SetSniffervoid SetSniffer(TRootSniffer *sniff)Set TRootSniffer to the server.Definition THttpServer.cxx:267; THttpServer::IsFileRequestedBool_t IsFileRequested(const char *uri, TString &res) constCheck if file is requested, thread safe.Definition THttpServer.cxx:612; THttpServer::SetReadOnlyvoid SetReadOnly(Bool_t readonly=kTRUE)Set read-only mode for the server (default on)Definition THttpServer.cxx:296; THttpServer::GetItemFieldconst char * GetItemField(const char *fullname, const char *name)Get item field from sniffer.Definition THttpServer.cxx:1471; THttpServer::GetCorsconst char * GetCors() constReturns specified CORS domain.Definition THttpServer.h:115; THttpServer::fThrdstd::thread fThrd! own threadDefinition THttpServer.h:41; THttpServer::StopServerThreadvoid StopServerThread()Stop server thread.Definition THttpServer.cxx:547; THttpServer::ProcessRequestsInt_t ProcessRequests()Process submitt",MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
https://root.cern/doc/master/THttpServer_8h_source.html:10581,Integrability,protocol,protocol,10581,"nt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t UChar_t lenDefinition TGWin32VirtualXProxy.cxx:249; modeOption_t Option_t TPoint TPoint const char modeDefinition TGWin32VirtualXProxy.cxx:68; namechar name[80]Definition TGX11.cxx:110; THttpCallArg.h; TList.h; TNamed.h; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; THttpCallArgContains arguments for single HTTP call.Definition THttpCallArg.h:27; THttpEngineAbstract class for implementing http protocol for THttpServer.Definition THttpEngine.h:19; THttpServerOnline http server for arbitrary ROOT application.Definition THttpServer.h:31; THttpServer::IsReadOnlyBool_t IsReadOnly() constreturns read-only modeDefinition THttpServer.cxx:285; THttpServer::RegisterCommandBool_t RegisterCommand(const char *cmdname, const char *method, const char *icon=nullptr)Register command which can be executed from web interface.Definition THttpServer.cxx:1428; THttpServer::fJSROOTTString fJSROOT! location of external JSROOT filesDefinition THttpServer.h:46; THttpServer::ProcessRequestvirtual void ProcessRequest(std::shared_ptr< THttpCallArg > arg)Process single http request.Definition THttpServer.cxx:978; THttpServer::GetTopNameconst char * GetTopName() constreturns name of top item in objects hierarchyDefinition THttpServer.h:130; THttpServer::FindWSstd::shared_ptr< THttpWSHandler > FindWS(const char *name)Find web-socket handler with given name.Definition THttpServer.cxx:1285; THt",MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
https://root.cern/doc/master/THttpServer_8h_source.html:10992,Integrability,interface,interface,10992,"ruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t UChar_t lenDefinition TGWin32VirtualXProxy.cxx:249; modeOption_t Option_t TPoint TPoint const char modeDefinition TGWin32VirtualXProxy.cxx:68; namechar name[80]Definition TGX11.cxx:110; THttpCallArg.h; TList.h; TNamed.h; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; THttpCallArgContains arguments for single HTTP call.Definition THttpCallArg.h:27; THttpEngineAbstract class for implementing http protocol for THttpServer.Definition THttpEngine.h:19; THttpServerOnline http server for arbitrary ROOT application.Definition THttpServer.h:31; THttpServer::IsReadOnlyBool_t IsReadOnly() constreturns read-only modeDefinition THttpServer.cxx:285; THttpServer::RegisterCommandBool_t RegisterCommand(const char *cmdname, const char *method, const char *icon=nullptr)Register command which can be executed from web interface.Definition THttpServer.cxx:1428; THttpServer::fJSROOTTString fJSROOT! location of external JSROOT filesDefinition THttpServer.h:46; THttpServer::ProcessRequestvirtual void ProcessRequest(std::shared_ptr< THttpCallArg > arg)Process single http request.Definition THttpServer.cxx:978; THttpServer::GetTopNameconst char * GetTopName() constreturns name of top item in objects hierarchyDefinition THttpServer.h:130; THttpServer::FindWSstd::shared_ptr< THttpWSHandler > FindWS(const char *name)Find web-socket handler with given name.Definition THttpServer.cxx:1285; THttpServer::fSnifferstd::unique_ptr< TRootSniffer > fSniffer! sniffer provides access to ROOT objects hierarchyDefinition THttpServer.h:36; THttpServer::SetTimervoid SetTimer(Long_t milliSec=100, Bool_t mode=kTRUE)Create timer which will invoke ProcessRequests() function periodically.Definition THttpServer.cxx:490; THttpServer::ProcessBatchHol",MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
https://root.cern/doc/master/THttpServer_8h_source.html:4448,Modifiability,config,configured,4448,"ng BuildWSEntryPage();; 72 ; 73 void ReplaceJSROOTLinks(std::shared_ptr<THttpCallArg> &arg, const std::string &version = """");; 74 ; 75 static Bool_t VerifyFilePath(const char *fname);; 76 ; 77 THttpServer(const THttpServer &) = delete;; 78 THttpServer &operator=(const THttpServer &) = delete;; 79 ; 80public:; 81 THttpServer(const char *engine = ""http:8080"");; 82 virtual ~THttpServer();; 83 ; 84 Bool_t CreateEngine(const char *engine);; 85 ; 86 Bool_t IsAnyEngine() const { return fEngines.GetSize() > 0; }; 87 ; 88 /** returns pointer on objects sniffer */; 89 TRootSniffer *GetSniffer() const { return fSniffer.get(); }; 90 ; 91 void SetSniffer(TRootSniffer *sniff);; 92 ; 93 Bool_t IsReadOnly() const;; 94 ; 95 void SetReadOnly(Bool_t readonly = kTRUE);; 96 ; 97 Bool_t IsWSOnly() const;; 98 ; 99 void SetWSOnly(Bool_t on = kTRUE);; 100 ; 101 /** set termination flag, no any further requests will be processed */; 102 void SetTerminate();; 103 ; 104 /** returns kTRUE, if server was terminated */; 105 Bool_t IsTerminated() const { return fTerminated; }; 106 ; 107 /** Enable CORS header to ProcessRequests() responses; 108 * Specified location (typically ""*"") add as ""Access-Control-Allow-Origin"" header */; 109 void SetCors(const std::string &domain = ""*"") { fCors = domain; }; 110 ; 111 /** Returns kTRUE if CORS was configured */; 112 Bool_t IsCors() const { return !fCors.empty(); }; 113 ; 114 /** Returns specified CORS domain */; 115 const char *GetCors() const { return fCors.c_str(); }; 116 ; 117 /** Enable/disable usage Access-Control-Allow-Credentials response header */; 118 void SetCorsCredentials(const std::string &value = ""true"") { fCorsCredentials = value; }; 119 ; 120 /** Returns kTRUE if Access-Control-Allow-Credentials header should be used */; 121 Bool_t IsCorsCredentials() const { return !fCorsCredentials.empty(); }; 122 ; 123 /** Returns specified CORS credentials value - if any */; 124 const char *GetCorsCredentials() const { return fCorsCredentials.c_str(); }; ",MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
https://root.cern/doc/master/THttpServer_8h_source.html:16951,Modifiability,config,configured,16951,"ol-Allow-Origin header for ProcessRequest responsesDefinition THttpServer.h:54; THttpServer::IsTerminatedBool_t IsTerminated() constreturns kTRUE, if server was terminatedDefinition THttpServer.h:105; THttpServer::fJSROOTSYSTString fJSROOTSYS! location of local JSROOT filesDefinition THttpServer.h:44; THttpServer::fTimerstd::unique_ptr< THttpTimer > fTimer! timer used to access main threadDefinition THttpServer.h:35; THttpServer::fWSOnlyBool_t fWSOnly! when true, handle only websockets / longpoll engineDefinition THttpServer.h:42; THttpServer::RegisterBool_t Register(const char *subfolder, TObject *obj)Register object in subfolder.Definition THttpServer.cxx:1243; THttpServer::fEnginesTList fEngines! engines which runs http serverDefinition THttpServer.h:34; THttpServer::SetCorsvoid SetCors(const std::string &domain=""*"")Enable CORS header to ProcessRequests() responses Specified location (typically ""*"") add as ""Access-C...Definition THttpServer.h:109; THttpServer::IsCorsBool_t IsCors() constReturns kTRUE if CORS was configured.Definition THttpServer.h:112; THttpServer::GetCorsCredentialsconst char * GetCorsCredentials() constReturns specified CORS credentials value - if any.Definition THttpServer.h:124; THttpServer::fArgsstd::queue< std::shared_ptr< THttpCallArg > > fArgs! submitted argumentsDefinition THttpServer.h:58; THttpServer::SetDefaultPagevoid SetDefaultPage(const std::string &filename="""")Set default HTML page.Definition THttpServer.cxx:368; THttpServer::THttpServerTHttpServer(const THttpServer &)=delete; THttpServer::ReadFileContentstatic char * ReadFileContent(const char *filename, Int_t &len)Reads content of file from the disk.Definition THttpServer.cxx:1557; THttpServer::CreateServerThreadvoid CreateServerThread()Creates special thread to process all requests, directed to http server.Definition THttpServer.cxx:515; THttpServer::fDrawPageContstd::string fDrawPageCont! content of draw html pageDefinition THttpServer.h:53; THttpServer::UnregisterBool_t Unreg",MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
https://root.cern/doc/master/THttpServer_8h_source.html:20515,Modifiability,config,configured,20515,"ar *value)Set item field in sniffer.Definition THttpServer.cxx:1463; THttpServer::SetJSROOTvoid SetJSROOT(const char *location)Set location of JSROOT to use with the server.Definition THttpServer.cxx:355; THttpServer::fMutexstd::mutex fMutex! mutex to protect list with argumentsDefinition THttpServer.h:57; THttpServer::fDefaultPagestd::string fDefaultPage! file name for default page nameDefinition THttpServer.h:50; THttpServer::UnregisterWSvoid UnregisterWS(std::shared_ptr< THttpWSHandler > ws)Unregister WS handler.Definition THttpServer.cxx:1272; THttpServer::GetMimeTypestatic const char * GetMimeType(const char *path)Guess mime type base on file extension.Definition THttpServer.cxx:1479; THttpServer::GetSnifferTRootSniffer * GetSniffer() constreturns pointer on objects snifferDefinition THttpServer.h:89; THttpServer::ReplaceJSROOTLinksvoid ReplaceJSROOTLinks(std::shared_ptr< THttpCallArg > &arg, const std::string &version="""")Replaces all references like ""jsrootsys/..."" or other pre-configured pathes.Definition THttpServer.cxx:847; THttpServer::fTerminatedBool_t fTerminated! termination flag, disables all requests processingDefinition THttpServer.h:37; THttpServer::SetTopNamevoid SetTopName(const char *top)set name of top item in objects hierarchyDefinition THttpServer.h:127; THttpServer::Restrictvoid Restrict(const char *path, const char *options)Restrict access to specified object.Definition THttpServer.cxx:1386; THttpTimerDefinition THttpServer.cxx:42; TListA doubly linked list.Definition TList.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjectMother of all ROOT objects.Definition TObject.h:41; TRootSnifferSniffer of ROOT objects, data provider for THttpServer.Definition TRootSniffer.h:115; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; bool. nethttpincTHttpServer.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:46 (GVA Tim",MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
https://root.cern/doc/master/THttpServer_8h_source.html:842,Performance,queue,queue,842,"h""; 18 ; 19#include <mutex>; 20#include <map>; 21#include <string>; 22#include <memory>; 23#include <queue>; 24#include <thread>; 25#include <vector>; 26 ; 27class THttpEngine;; 28class THttpTimer;; 29class TRootSniffer;; 30 ; 31class THttpServer : public TNamed {; 32 ; 33protected:; 34 TList fEngines; ///<! engines which runs http server; 35 std::unique_ptr<THttpTimer> fTimer; ///<! timer used to access main thread; 36 std::unique_ptr<TRootSniffer> fSniffer; ///<! sniffer provides access to ROOT objects hierarchy; 37 Bool_t fTerminated{kFALSE}; ///<! termination flag, disables all requests processing; 38 Long_t fMainThrdId{0}; ///<! id of the thread for processing requests; 39 Long_t fProcessingThrdId{0}; ///<! id of the thread where events are recently processing; 40 Bool_t fOwnThread{kFALSE}; ///<! true when specialized thread allocated for processing requests; 41 std::thread fThrd; ///<! own thread; 42 Bool_t fWSOnly{kFALSE}; ///<! when true, handle only websockets / longpoll engine; 43 ; 44 TString fJSROOTSYS; ///<! location of local JSROOT files; 45 TString fTopName{""ROOT""}; ///<! name of top folder, default - ""ROOT""; 46 TString fJSROOT; ///<! location of external JSROOT files; 47 ; 48 std::map<std::string, std::string> fLocations; //",MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
https://root.cern/doc/master/THttpServer_8h_source.html:2634,Performance,queue,queue,2634,"sts; 41 std::thread fThrd; ///<! own thread; 42 Bool_t fWSOnly{kFALSE}; ///<! when true, handle only websockets / longpoll engine; 43 ; 44 TString fJSROOTSYS; ///<! location of local JSROOT files; 45 TString fTopName{""ROOT""}; ///<! name of top folder, default - ""ROOT""; 46 TString fJSROOT; ///<! location of external JSROOT files; 47 ; 48 std::map<std::string, std::string> fLocations; ///<! list of local directories, which could be accessed via server; 49 ; 50 std::string fDefaultPage; ///<! file name for default page name; 51 std::string fDefaultPageCont; ///<! content of default html page; 52 std::string fDrawPage; ///<! file name for drawing of single element; 53 std::string fDrawPageCont; ///<! content of draw html page; 54 std::string fCors; ///<! CORS: sets Access-Control-Allow-Origin header for ProcessRequest responses; 55 std::string fCorsCredentials; ///<! CORS: add Access-Control-Allow-Credentials: true response header; 56 ; 57 std::mutex fMutex; ///<! mutex to protect list with arguments; 58 std::queue<std::shared_ptr<THttpCallArg>> fArgs; ///<! submitted arguments; 59 ; 60 std::mutex fWSMutex; ///<! mutex to protect WS handler lists; 61 std::vector<std::shared_ptr<THttpWSHandler>> fWSHandlers; ///<! list of WS handlers; 62 ; 63 virtual void MissedRequest(THttpCallArg *arg);; 64 ; 65 virtual void ProcessRequest(std::shared_ptr<THttpCallArg> arg);; 66 ; 67 virtual void ProcessBatchHolder(std::shared_ptr<THttpCallArg> &arg);; 68 ; 69 void StopServerThread();; 70 ; 71 std::string BuildWSEntryPage();; 72 ; 73 void ReplaceJSROOTLinks(std::shared_ptr<THttpCallArg> &arg, const std::string &version = """");; 74 ; 75 static Bool_t VerifyFilePath(const char *fname);; 76 ; 77 THttpServer(const THttpServer &) = delete;; 78 THttpServer &operator=(const THttpServer &) = delete;; 79 ; 80public:; 81 THttpServer(const char *engine = ""http:8080"");; 82 virtual ~THttpServer();; 83 ; 84 Bool_t CreateEngine(const char *engine);; 85 ; 86 Bool_t IsAnyEngine() const { return fEngines.",MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
https://root.cern/doc/master/THttpServer_8h_source.html:17165,Performance,queue,queue,17165,"efinition THttpServer.h:44; THttpServer::fTimerstd::unique_ptr< THttpTimer > fTimer! timer used to access main threadDefinition THttpServer.h:35; THttpServer::fWSOnlyBool_t fWSOnly! when true, handle only websockets / longpoll engineDefinition THttpServer.h:42; THttpServer::RegisterBool_t Register(const char *subfolder, TObject *obj)Register object in subfolder.Definition THttpServer.cxx:1243; THttpServer::fEnginesTList fEngines! engines which runs http serverDefinition THttpServer.h:34; THttpServer::SetCorsvoid SetCors(const std::string &domain=""*"")Enable CORS header to ProcessRequests() responses Specified location (typically ""*"") add as ""Access-C...Definition THttpServer.h:109; THttpServer::IsCorsBool_t IsCors() constReturns kTRUE if CORS was configured.Definition THttpServer.h:112; THttpServer::GetCorsCredentialsconst char * GetCorsCredentials() constReturns specified CORS credentials value - if any.Definition THttpServer.h:124; THttpServer::fArgsstd::queue< std::shared_ptr< THttpCallArg > > fArgs! submitted argumentsDefinition THttpServer.h:58; THttpServer::SetDefaultPagevoid SetDefaultPage(const std::string &filename="""")Set default HTML page.Definition THttpServer.cxx:368; THttpServer::THttpServerTHttpServer(const THttpServer &)=delete; THttpServer::ReadFileContentstatic char * ReadFileContent(const char *filename, Int_t &len)Reads content of file from the disk.Definition THttpServer.cxx:1557; THttpServer::CreateServerThreadvoid CreateServerThread()Creates special thread to process all requests, directed to http server.Definition THttpServer.cxx:515; THttpServer::fDrawPageContstd::string fDrawPageCont! content of draw html pageDefinition THttpServer.h:53; THttpServer::UnregisterBool_t Unregister(TObject *obj)Unregister object.Definition THttpServer.cxx:1253; THttpServer::SetWSOnlyvoid SetWSOnly(Bool_t on=kTRUE)Set websocket-only mode.Definition THttpServer.cxx:318; THttpServer::BuildWSEntryPagestd::string BuildWSEntryPage()Create summary page with active WS ha",MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
https://root.cern/doc/master/THttpServer_8h_source.html:5769,Safety,safe,safe,5769,,MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
https://root.cern/doc/master/THttpServer_8h_source.html:12971,Safety,safe,safe,12971,"oldervirtual void ProcessBatchHolder(std::shared_ptr< THttpCallArg > &arg)Process special http request for root_batch_holder.js script.Definition THttpServer.cxx:799; THttpServer::fWSHandlersstd::vector< std::shared_ptr< THttpWSHandler > > fWSHandlers! list of WS handlersDefinition THttpServer.h:61; THttpServer::~THttpServervirtual ~THttpServer()destructorDefinition THttpServer.cxx:245; THttpServer::SetTerminatevoid SetTerminate()set termination flag, no any further requests will be processedDefinition THttpServer.cxx:277; THttpServer::MissedRequestvirtual void MissedRequest(THttpCallArg *arg)Method called when THttpServer cannot process request.Definition THttpServer.cxx:788; THttpServer::fOwnThreadBool_t fOwnThread! true when specialized thread allocated for processing requestsDefinition THttpServer.h:40; THttpServer::SetSniffervoid SetSniffer(TRootSniffer *sniff)Set TRootSniffer to the server.Definition THttpServer.cxx:267; THttpServer::IsFileRequestedBool_t IsFileRequested(const char *uri, TString &res) constCheck if file is requested, thread safe.Definition THttpServer.cxx:612; THttpServer::SetReadOnlyvoid SetReadOnly(Bool_t readonly=kTRUE)Set read-only mode for the server (default on)Definition THttpServer.cxx:296; THttpServer::GetItemFieldconst char * GetItemField(const char *fullname, const char *name)Get item field from sniffer.Definition THttpServer.cxx:1471; THttpServer::GetCorsconst char * GetCors() constReturns specified CORS domain.Definition THttpServer.h:115; THttpServer::fThrdstd::thread fThrd! own threadDefinition THttpServer.h:41; THttpServer::StopServerThreadvoid StopServerThread()Stop server thread.Definition THttpServer.cxx:547; THttpServer::ProcessRequestsInt_t ProcessRequests()Process submitted requests, must be called from appropriate thread.Definition THttpServer.cxx:708; THttpServer::ExecuteWSBool_t ExecuteWS(std::shared_ptr< THttpCallArg > &arg, Bool_t external_thrd=kFALSE, Bool_t wait_process=kFALSE)Execute WS request.Definition THttpSer",MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
https://root.cern/doc/master/THttpServer_8h_source.html:1142,Security,access,access,1142,"h""; 18 ; 19#include <mutex>; 20#include <map>; 21#include <string>; 22#include <memory>; 23#include <queue>; 24#include <thread>; 25#include <vector>; 26 ; 27class THttpEngine;; 28class THttpTimer;; 29class TRootSniffer;; 30 ; 31class THttpServer : public TNamed {; 32 ; 33protected:; 34 TList fEngines; ///<! engines which runs http server; 35 std::unique_ptr<THttpTimer> fTimer; ///<! timer used to access main thread; 36 std::unique_ptr<TRootSniffer> fSniffer; ///<! sniffer provides access to ROOT objects hierarchy; 37 Bool_t fTerminated{kFALSE}; ///<! termination flag, disables all requests processing; 38 Long_t fMainThrdId{0}; ///<! id of the thread for processing requests; 39 Long_t fProcessingThrdId{0}; ///<! id of the thread where events are recently processing; 40 Bool_t fOwnThread{kFALSE}; ///<! true when specialized thread allocated for processing requests; 41 std::thread fThrd; ///<! own thread; 42 Bool_t fWSOnly{kFALSE}; ///<! when true, handle only websockets / longpoll engine; 43 ; 44 TString fJSROOTSYS; ///<! location of local JSROOT files; 45 TString fTopName{""ROOT""}; ///<! name of top folder, default - ""ROOT""; 46 TString fJSROOT; ///<! location of external JSROOT files; 47 ; 48 std::map<std::string, std::string> fLocations; //",MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
https://root.cern/doc/master/THttpServer_8h_source.html:1228,Security,access,access,1228,"h""; 18 ; 19#include <mutex>; 20#include <map>; 21#include <string>; 22#include <memory>; 23#include <queue>; 24#include <thread>; 25#include <vector>; 26 ; 27class THttpEngine;; 28class THttpTimer;; 29class TRootSniffer;; 30 ; 31class THttpServer : public TNamed {; 32 ; 33protected:; 34 TList fEngines; ///<! engines which runs http server; 35 std::unique_ptr<THttpTimer> fTimer; ///<! timer used to access main thread; 36 std::unique_ptr<TRootSniffer> fSniffer; ///<! sniffer provides access to ROOT objects hierarchy; 37 Bool_t fTerminated{kFALSE}; ///<! termination flag, disables all requests processing; 38 Long_t fMainThrdId{0}; ///<! id of the thread for processing requests; 39 Long_t fProcessingThrdId{0}; ///<! id of the thread where events are recently processing; 40 Bool_t fOwnThread{kFALSE}; ///<! true when specialized thread allocated for processing requests; 41 std::thread fThrd; ///<! own thread; 42 Bool_t fWSOnly{kFALSE}; ///<! when true, handle only websockets / longpoll engine; 43 ; 44 TString fJSROOTSYS; ///<! location of local JSROOT files; 45 TString fTopName{""ROOT""}; ///<! name of top folder, default - ""ROOT""; 46 TString fJSROOT; ///<! location of external JSROOT files; 47 ; 48 std::map<std::string, std::string> fLocations; //",MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
https://root.cern/doc/master/THttpServer_8h_source.html:2047,Security,access,accessed,2047,"engines which runs http server; 35 std::unique_ptr<THttpTimer> fTimer; ///<! timer used to access main thread; 36 std::unique_ptr<TRootSniffer> fSniffer; ///<! sniffer provides access to ROOT objects hierarchy; 37 Bool_t fTerminated{kFALSE}; ///<! termination flag, disables all requests processing; 38 Long_t fMainThrdId{0}; ///<! id of the thread for processing requests; 39 Long_t fProcessingThrdId{0}; ///<! id of the thread where events are recently processing; 40 Bool_t fOwnThread{kFALSE}; ///<! true when specialized thread allocated for processing requests; 41 std::thread fThrd; ///<! own thread; 42 Bool_t fWSOnly{kFALSE}; ///<! when true, handle only websockets / longpoll engine; 43 ; 44 TString fJSROOTSYS; ///<! location of local JSROOT files; 45 TString fTopName{""ROOT""}; ///<! name of top folder, default - ""ROOT""; 46 TString fJSROOT; ///<! location of external JSROOT files; 47 ; 48 std::map<std::string, std::string> fLocations; ///<! list of local directories, which could be accessed via server; 49 ; 50 std::string fDefaultPage; ///<! file name for default page name; 51 std::string fDefaultPageCont; ///<! content of default html page; 52 std::string fDrawPage; ///<! file name for drawing of single element; 53 std::string fDrawPageCont; ///<! content of draw html page; 54 std::string fCors; ///<! CORS: sets Access-Control-Allow-Origin header for ProcessRequest responses; 55 std::string fCorsCredentials; ///<! CORS: add Access-Control-Allow-Credentials: true response header; 56 ; 57 std::mutex fMutex; ///<! mutex to protect list with arguments; 58 std::queue<std::shared_ptr<THttpCallArg>> fArgs; ///<! submitted arguments; 59 ; 60 std::mutex fWSMutex; ///<! mutex to protect WS handler lists; 61 std::vector<std::shared_ptr<THttpWSHandler>> fWSHandlers; ///<! list of WS handlers; 62 ; 63 virtual void MissedRequest(THttpCallArg *arg);; 64 ; 65 virtual void ProcessRequest(std::shared_ptr<THttpCallArg> arg);; 66 ; 67 virtual void ProcessBatchHolder(std::shared_ptr<THtt",MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
https://root.cern/doc/master/THttpServer_8h_source.html:6867,Security,access,access,6867," request */; 148 Bool_t ExecuteHttp(std::shared_ptr<THttpCallArg> arg);; 149 ; 150 /** Submit HTTP request */; 151 Bool_t SubmitHttp(std::shared_ptr<THttpCallArg> arg, Bool_t can_run_immediately = kFALSE);; 152 ; 153 /** Process submitted requests, must be called from appropriate thread */; 154 Int_t ProcessRequests();; 155 ; 156 /** Register object in subfolder */; 157 Bool_t Register(const char *subfolder, TObject *obj);; 158 ; 159 /** Unregister object */; 160 Bool_t Unregister(TObject *obj);; 161 ; 162 /** Register WS handler*/; 163 void RegisterWS(std::shared_ptr<THttpWSHandler> ws);; 164 ; 165 /** Unregister WS handler*/; 166 void UnregisterWS(std::shared_ptr<THttpWSHandler> ws);; 167 ; 168 /** Find web-socket handler with given name */; 169 std::shared_ptr<THttpWSHandler> FindWS(const char *name);; 170 ; 171 /** Execute WS request */; 172 Bool_t ExecuteWS(std::shared_ptr<THttpCallArg> &arg, Bool_t external_thrd = kFALSE, Bool_t wait_process = kFALSE);; 173 ; 174 /** Restrict access to specified object */; 175 void Restrict(const char *path, const char *options);; 176 ; 177 Bool_t RegisterCommand(const char *cmdname, const char *method, const char *icon = nullptr);; 178 ; 179 Bool_t Hide(const char *fullname, Bool_t hide = kTRUE);; 180 ; 181 Bool_t SetIcon(const char *fullname, const char *iconname);; 182 ; 183 Bool_t CreateItem(const char *fullname, const char *title);; 184 ; 185 Bool_t SetItemField(const char *fullname, const char *name, const char *value);; 186 ; 187 const char *GetItemField(const char *fullname, const char *name);; 188 ; 189 /** Guess mime type base on file extension */; 190 static const char *GetMimeType(const char *path);; 191 ; 192 /** Reads content of file from the disk */; 193 static char *ReadFileContent(const char *filename, Int_t &len);; 194 ; 195 /** Reads content of file from the disk, use std::string in return value */; 196 static std::string ReadFileContent(const std::string &filename);; 197 ; 198 ClassDefOverride(THttpServer, 0",MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
https://root.cern/doc/master/THttpServer_8h_source.html:11644,Security,access,access,11644,"ne.h:19; THttpServerOnline http server for arbitrary ROOT application.Definition THttpServer.h:31; THttpServer::IsReadOnlyBool_t IsReadOnly() constreturns read-only modeDefinition THttpServer.cxx:285; THttpServer::RegisterCommandBool_t RegisterCommand(const char *cmdname, const char *method, const char *icon=nullptr)Register command which can be executed from web interface.Definition THttpServer.cxx:1428; THttpServer::fJSROOTTString fJSROOT! location of external JSROOT filesDefinition THttpServer.h:46; THttpServer::ProcessRequestvirtual void ProcessRequest(std::shared_ptr< THttpCallArg > arg)Process single http request.Definition THttpServer.cxx:978; THttpServer::GetTopNameconst char * GetTopName() constreturns name of top item in objects hierarchyDefinition THttpServer.h:130; THttpServer::FindWSstd::shared_ptr< THttpWSHandler > FindWS(const char *name)Find web-socket handler with given name.Definition THttpServer.cxx:1285; THttpServer::fSnifferstd::unique_ptr< TRootSniffer > fSniffer! sniffer provides access to ROOT objects hierarchyDefinition THttpServer.h:36; THttpServer::SetTimervoid SetTimer(Long_t milliSec=100, Bool_t mode=kTRUE)Create timer which will invoke ProcessRequests() function periodically.Definition THttpServer.cxx:490; THttpServer::ProcessBatchHoldervirtual void ProcessBatchHolder(std::shared_ptr< THttpCallArg > &arg)Process special http request for root_batch_holder.js script.Definition THttpServer.cxx:799; THttpServer::fWSHandlersstd::vector< std::shared_ptr< THttpWSHandler > > fWSHandlers! list of WS handlersDefinition THttpServer.h:61; THttpServer::~THttpServervirtual ~THttpServer()destructorDefinition THttpServer.cxx:245; THttpServer::SetTerminatevoid SetTerminate()set termination flag, no any further requests will be processedDefinition THttpServer.cxx:277; THttpServer::MissedRequestvirtual void MissedRequest(THttpCallArg *arg)Method called when THttpServer cannot process request.Definition THttpServer.cxx:788; THttpServer::fOwnThreadBool_t fOw",MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
https://root.cern/doc/master/THttpServer_8h_source.html:15535,Security,access,accessed,15535,"tle)Create item in sniffer.Definition THttpServer.cxx:1455; THttpServer::ExecuteHttpBool_t ExecuteHttp(std::shared_ptr< THttpCallArg > arg)Execute HTTP request.Definition THttpServer.cxx:642; THttpServer::HideBool_t Hide(const char *fullname, Bool_t hide=kTRUE)Hides folder or element from web gui.Definition THttpServer.cxx:1436; THttpServer::SetCorsCredentialsvoid SetCorsCredentials(const std::string &value=""true"")Enable/disable usage Access-Control-Allow-Credentials response header.Definition THttpServer.h:118; THttpServer::IsCorsCredentialsBool_t IsCorsCredentials() constReturns kTRUE if Access-Control-Allow-Credentials header should be used.Definition THttpServer.h:121; THttpServer::AddLocationvoid AddLocation(const char *prefix, const char *path)Add files location, which could be used in the server.Definition THttpServer.cxx:332; THttpServer::IsAnyEngineBool_t IsAnyEngine() constDefinition THttpServer.h:86; THttpServer::fLocationsstd::map< std::string, std::string > fLocations! list of local directories, which could be accessed via serverDefinition THttpServer.h:48; THttpServer::SubmitHttpBool_t SubmitHttp(std::shared_ptr< THttpCallArg > arg, Bool_t can_run_immediately=kFALSE)Submit HTTP request.Definition THttpServer.cxx:681; THttpServer::fMainThrdIdLong_t fMainThrdId! id of the thread for processing requestsDefinition THttpServer.h:38; THttpServer::fCorsstd::string fCors! CORS: sets Access-Control-Allow-Origin header for ProcessRequest responsesDefinition THttpServer.h:54; THttpServer::IsTerminatedBool_t IsTerminated() constreturns kTRUE, if server was terminatedDefinition THttpServer.h:105; THttpServer::fJSROOTSYSTString fJSROOTSYS! location of local JSROOT filesDefinition THttpServer.h:44; THttpServer::fTimerstd::unique_ptr< THttpTimer > fTimer! timer used to access main threadDefinition THttpServer.h:35; THttpServer::fWSOnlyBool_t fWSOnly! when true, handle only websockets / longpoll engineDefinition THttpServer.h:42; THttpServer::RegisterBool_t Register(co",MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
https://root.cern/doc/master/THttpServer_8h_source.html:16294,Security,access,access,16294,"which could be used in the server.Definition THttpServer.cxx:332; THttpServer::IsAnyEngineBool_t IsAnyEngine() constDefinition THttpServer.h:86; THttpServer::fLocationsstd::map< std::string, std::string > fLocations! list of local directories, which could be accessed via serverDefinition THttpServer.h:48; THttpServer::SubmitHttpBool_t SubmitHttp(std::shared_ptr< THttpCallArg > arg, Bool_t can_run_immediately=kFALSE)Submit HTTP request.Definition THttpServer.cxx:681; THttpServer::fMainThrdIdLong_t fMainThrdId! id of the thread for processing requestsDefinition THttpServer.h:38; THttpServer::fCorsstd::string fCors! CORS: sets Access-Control-Allow-Origin header for ProcessRequest responsesDefinition THttpServer.h:54; THttpServer::IsTerminatedBool_t IsTerminated() constreturns kTRUE, if server was terminatedDefinition THttpServer.h:105; THttpServer::fJSROOTSYSTString fJSROOTSYS! location of local JSROOT filesDefinition THttpServer.h:44; THttpServer::fTimerstd::unique_ptr< THttpTimer > fTimer! timer used to access main threadDefinition THttpServer.h:35; THttpServer::fWSOnlyBool_t fWSOnly! when true, handle only websockets / longpoll engineDefinition THttpServer.h:42; THttpServer::RegisterBool_t Register(const char *subfolder, TObject *obj)Register object in subfolder.Definition THttpServer.cxx:1243; THttpServer::fEnginesTList fEngines! engines which runs http serverDefinition THttpServer.h:34; THttpServer::SetCorsvoid SetCors(const std::string &domain=""*"")Enable CORS header to ProcessRequests() responses Specified location (typically ""*"") add as ""Access-C...Definition THttpServer.h:109; THttpServer::IsCorsBool_t IsCors() constReturns kTRUE if CORS was configured.Definition THttpServer.h:112; THttpServer::GetCorsCredentialsconst char * GetCorsCredentials() constReturns specified CORS credentials value - if any.Definition THttpServer.h:124; THttpServer::fArgsstd::queue< std::shared_ptr< THttpCallArg > > fArgs! submitted argumentsDefinition THttpServer.h:58; THttpServer::Se",MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
https://root.cern/doc/master/THttpServer_8h_source.html:20896,Security,access,access,20896,"iffer.Definition THttpServer.cxx:1463; THttpServer::SetJSROOTvoid SetJSROOT(const char *location)Set location of JSROOT to use with the server.Definition THttpServer.cxx:355; THttpServer::fMutexstd::mutex fMutex! mutex to protect list with argumentsDefinition THttpServer.h:57; THttpServer::fDefaultPagestd::string fDefaultPage! file name for default page nameDefinition THttpServer.h:50; THttpServer::UnregisterWSvoid UnregisterWS(std::shared_ptr< THttpWSHandler > ws)Unregister WS handler.Definition THttpServer.cxx:1272; THttpServer::GetMimeTypestatic const char * GetMimeType(const char *path)Guess mime type base on file extension.Definition THttpServer.cxx:1479; THttpServer::GetSnifferTRootSniffer * GetSniffer() constreturns pointer on objects snifferDefinition THttpServer.h:89; THttpServer::ReplaceJSROOTLinksvoid ReplaceJSROOTLinks(std::shared_ptr< THttpCallArg > &arg, const std::string &version="""")Replaces all references like ""jsrootsys/..."" or other pre-configured pathes.Definition THttpServer.cxx:847; THttpServer::fTerminatedBool_t fTerminated! termination flag, disables all requests processingDefinition THttpServer.h:37; THttpServer::SetTopNamevoid SetTopName(const char *top)set name of top item in objects hierarchyDefinition THttpServer.h:127; THttpServer::Restrictvoid Restrict(const char *path, const char *options)Restrict access to specified object.Definition THttpServer.cxx:1386; THttpTimerDefinition THttpServer.cxx:42; TListA doubly linked list.Definition TList.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjectMother of all ROOT objects.Definition TObject.h:41; TRootSnifferSniffer of ROOT objects, data provider for THttpServer.Definition TRootSniffer.h:115; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; bool. nethttpincTHttpServer.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:46 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
https://root.cern/doc/master/timeonaxis2_8C.html:702,Testability,test,test,702,". ROOT: tutorials/graphs/timeonaxis2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. timeonaxis2.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Define the time offset as 2003, January 1st. . ; void timeonaxis2() {; auto ct2 = new TCanvas(""ct2"",""ct2"",10,10,700,500);; ; TDatime T0(2003, 1, 1, 0, 0, 0);; int X0 = T0.Convert();; gStyle->SetTimeOffset(X0);; ; // Define the lowest histogram limit as 2002, September 23rd; TDatime T1(2002, 9, 23, 0, 0, 0);; int X1 = T1.Convert()-X0;; ; // Define the highest histogram limit as 2003, March 7th; TDatime T2(2003, 3, 7, 0, 0, 0);; int X2 = T2.Convert(1)-X0;; ; auto h1 = new TH1F(""h1"",""test"",100,X1,X2);; ; TRandom r;; for (Int_t i=0;i<30000;i++) {; Double_t noise = r.Gaus(0.5*(X1+X2),0.1*(X2-X1));; h1->Fill(noise);; }; ; h1->GetXaxis()->SetTimeDisplay(1);; h1->GetXaxis()->SetLabelSize(0.03);; h1->GetXaxis()->SetTimeFormat(""%Y/%m/%d"");; h1->Draw();; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TAttAxis::SetLabelSizevirtual void SetLabelSize(Float_t size=0.04)Set size of axis labels.Definition TAttAxis.cxx:203; TAxis::SetTimeDisplayvirtual void SetTimeDisplay(Int_t value)Definition TAxis.h:171; TAxis::SetTimeFormatvirtual void SetTimeFormat(const char *format="""")Change the format used for time plotting.Definition TAxis.cxx:1157; TCanvasThe Canvas class.Definition TCanvas.h:23; TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::GetXaxis",MatchSource.WIKI,doc/master/timeonaxis2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/timeonaxis2_8C.html
https://root.cern/doc/master/timeonaxis3_8C.html:2234,Security,access,accessor,2234,"extColor(kBlue+2);; ; TLatex tex2;; tex2.SetNDC();; tex2.SetTextFont(102);; tex2.SetTextSize(0.07*f);; tex2.SetTextColor(kOrange+3);; ; time_t offset[] = {0, 0, 1325376000, 1341100800};; time_t t[] = {1331150400, 1336417200, 0, 36000};; ; c->SetTopMargin(0); c->SetBottomMargin(0);; c->SetLeftMargin(0); c->SetRightMargin(0);; c->Divide(2, 4, -1, -1);; TLine l;; l.DrawLine(0.5, 0, 0.5, 1.);; ; for(int i = 0; i < 4; ++i){; for(int gmt = 0; gmt < 2; ++gmt){; const char* opt = (gmt ? ""gmt"" : ""local"");; TVirtualPad* p = c->cd(2*i + gmt + 1);; p->SetTopMargin(0); p->SetBottomMargin(0);; p->SetLeftMargin(0); p->SetRightMargin(0);; p->SetFillStyle(4000);; ; TGaxis* ga = new TGaxis (.4, .25, 5., .25, t[i], t[i] + 1, 1, ""t"");; ga->SetTimeFormat(""TGaxis label: #color[2]{%Y-%m-%d %H:%M:%S}"");; ga->SetLabelFont(102);; ga->SetLabelColor(kBlue+2);; ; ga->SetTimeOffset(offset[i], opt);; ga->SetLabelOffset(0.04*f);; ga->SetLabelSize(0.07*f);; ga->SetLineColor(0);; ga->Draw();; ; // Get offset string of axis time format: there is not accessor; // to time format in TGaxis.; // Assumes TAxis use the same format.; TAxis a(10, 0, 1600000000);; a.SetTimeOffset(offset[i], opt);; const char* offsettimeformat = a.GetTimeFormat();; ; char buf[256];; if (offset[i] < t[i]) {; snprintf(buf, 256, ""#splitline{%s, %s}{offset: %ld, option %s}"",; stime(t+i).Data(), stime(t+i, true).Data(), offset[i], opt);; } else {; int h = t[i] / 3600;; int m = (t[i] - 3600 * h) / 60 ;; int s = (t[i] - h * 3600 - m * 60);; snprintf(buf, 256, ""#splitline{%d h %d m %d s}{offset: %s, option %s}"",; h, m, s, stime(offset + i, gmt).Data(), opt);; }; tex1.DrawLatex(.01, .75, buf);; tex2.DrawLatex(.01, .50, offsettimeformat);; time_t t_ = t[i] + offset[i];; snprintf(buf, 256, ""Expecting: #color[2]{%s}"", stime(&t_, gmt, false).Data());; tex3.DrawLatex(.01, .24, buf);; if(i > 0) l.DrawLine(0, 0.95, 1, 0.95);; }; }; }; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSh",MatchSource.WIKI,doc/master/timeonaxis3_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/timeonaxis3_8C.html
https://root.cern/doc/master/timeonaxis3_8C.html:349,Testability,test,test,349,". ROOT: tutorials/graphs/timeonaxis3.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. timeonaxis3.C File ReferenceTutorials » Graphs tutorials. Detailed Description; This example compares what the system time function gmtime and localtime give with what gives TGaxis. ; It can be used as referenced test to check if TGaxis is working properly. The original code was developed by Philippe Gras (CEA Saclay. IRFU/SEDI). ; #include ""TAxis.h""; #include ""TGaxis.h""; #include ""TCanvas.h""; #include ""TString.h""; #include ""TLine.h""; #include ""TLatex.h""; #include <ctime>; #include <cstdio>; ; TString stime(time_t* t, bool utc = false, bool display_time_zone = true) {; struct tm* tt;; if (utc) tt = gmtime(t);; else tt = localtime(t);; char buf[256];; if (display_time_zone) strftime(buf, sizeof(buf), ""%Y-%m-%d %H:%M:%S %Z"", tt);; else strftime(buf, sizeof(buf), ""%Y-%m-%d %H:%M:%S"", tt);; return TString(buf);; }; ; ; void timeonaxis3() {; double f = 1.8;; ; auto c = new TCanvas;; ; TLatex tex1;; tex1.SetNDC();; tex1.SetTextFont(102);; tex1.SetTextSize(0.055*f);; ; TLatex tex3;; tex3.SetNDC();; tex3.SetTextFont(102);; tex3.SetTextSize(0.07*f);; tex3.SetTextColor(kBlue+2);; ; TLatex tex2;; tex2.SetNDC();; tex2.SetTextFont(102);; tex2.SetTextSize(0.07*f);; tex2.SetTextColor(kOrange+3);; ; time_t offset[] = {0, 0, 1325376000, 1341100800};; time_t t[] = {1331150400, 1336417200, 0, 36000};; ; c->SetTopMargin(0); c->SetBottomMargin(0);; c->SetLeftMargin(0); c->SetRightMargin(0);; c->Divide(2, 4, -1, -1);; TLine l;; l.DrawLine(0.5, 0, 0.5, 1.);; ; for(int i = 0; i < 4; ++i){; for(int gmt = 0; gmt < 2; ++gmt){; const char* opt = (gmt ? ""gmt"" : ""local"");; TVirtualPad* p = c->cd(2*i + gmt + 1);; p->SetTopMargin(0); p->SetBottomMargin(0);; p->SetLeftMargin(0); p->SetRightMargin(0);; p->SetFillStyle(4000);; ; TGaxis* ga = new TGaxis (.4, .25, 5., .25, t[i], t[i] + 1, 1, ""t"");; ga->SetTimeFormat(""TGaxis label: #color[2]{%Y-%m-%d %H:%M:%S}"");; ga->Se",MatchSource.WIKI,doc/master/timeonaxis3_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/timeonaxis3_8C.html
https://root.cern/doc/master/timeonaxis3_8C.html:5796,Usability,simpl,simple,5796,"Class to manage histogram axis.Definition TAxis.h:31; TCanvasThe Canvas class.Definition TCanvas.h:23; TGaxisThe axis painter class.Definition TGaxis.h:24; TGaxis::SetTimeFormatvoid SetTimeFormat(const char *tformat)Change the format used for time plotting.Definition TGaxis.cxx:2969; TGaxis::SetLabelFontvoid SetLabelFont(Int_t labelfont)Definition TGaxis.h:105; TGaxis::SetLabelOffsetvoid SetLabelOffset(Float_t labeloffset)Definition TGaxis.h:106; TGaxis::SetTimeOffsetvoid SetTimeOffset(Double_t toffset, Option_t *option=""local"")Change the time offset. If option = ""gmt"", set display mode to GMT.Definition TGaxis.cxx:2993; TGaxis::SetLabelColorvoid SetLabelColor(Int_t labelcolor)Definition TGaxis.h:104; TGaxis::SetLabelSizevoid SetLabelSize(Float_t labelsize)Definition TGaxis.h:107; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::DrawLatexTLatex * DrawLatex(Double_t x, Double_t y, const char *text)Make a copy of this object with the new parameters And copy object attributes.Definition TLatex.cxx:1943; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::DrawLinevirtual TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:103; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TStringBasic string class.Definition TString.h:139; TText::SetNDCvirtual void SetNDC(Bool_t isNDC=kTRUE)Set NDC mode on if isNDC = kTRUE, off otherwise.Definition TText.cxx:823; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4; ttauto * ttDefinition textangle.C:16; AuthorsPhilippe Gras, Bertrand Bellenot, Olivier Couet ; Definition in file timeonaxis3.C. tutorialsgraphstimeonaxis3.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/timeonaxis3_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/timeonaxis3_8C.html
https://root.cern/doc/master/timeonaxis_8C.html:2014,Usability,simpl,simple,2014,"he time offset is the one that will be used by all graphs.; // If one changes it, it will be changed even on the graphs already defined; gStyle->SetTimeOffset(script_time);; ; auto ct = new TCanvas(""ct"",""Time on axis"",10,10,700,900);; ct->Divide(1,3);; ; int i;; ; //### Build a signal: noisy damped sine; // Time interval: 30 minutes; ; gStyle->SetTitleH(0.08);; float noise;; auto ht = new TH1F(""ht"",""Love at first sight"",3000,0.,2000.);; for (i=1;i<3000;i++) {; noise = gRandom->Gaus(0,120);; if (i>700) {; noise += 1000*sin((i-700)*6.28/30)*exp((double)(700-i)/300);; }; ht->SetBinContent(i,noise);; }; ct->cd(1);; ht->SetLineColor(2);; ht->GetXaxis()->SetLabelSize(0.05);; ht->Draw();; // Sets time on the X axis; // The time used is the one set as time offset added to the value; // of the axis. This is converted into day/month/year hour:min:sec and; // a reasonable tick interval value is chosen.; ht->GetXaxis()->SetTimeDisplay(1);; ; //### Build a simple graph beginning at a different time; // Time interval: 5 seconds; ; float x[100], t[100];; for (i=0;i<100;i++) {; x[i] = sin(i*4*3.1415926/50)*exp(-(double)i/20);; t[i] = 6000+(double)i/20;; }; auto gt = new TGraph(100,t,x);; gt->SetTitle(""Politics"");; ct->cd(2);; gt->SetLineColor(5);; gt->SetLineWidth(2);; gt->Draw(""AL"");; gt->GetXaxis()->SetLabelSize(0.05);; // Sets time on the X axis; gt->GetXaxis()->SetTimeDisplay(1);; gPad->Modified();; ; //### Build a second simple graph for a very long time interval; // Time interval: a few years; ; auto gt2 = new TGraph();; TDatime dateBegin(2000,1,1,0,0,0);; for (i=0;i<10;i++) {; TDatime datePnt(2000 + i,1,1,0,0,0);; gt2->AddPoint(datePnt.Convert() - dateBegin.Convert(), 100 + gRandom->Gaus(500,100)*i);; }; gt2->SetTitle(""Number of monkeys on the moon"");; ct->cd(3);; gt2->SetMarkerColor(4);; gt2->SetMarkerStyle(29);; gt2->SetMarkerSize(1.3);; gt2->Draw(""AP"");; gt2->GetXaxis()->SetLabelSize(0.04);; gt2->GetXaxis()->SetNdivisions(10);; // Sets time on the X axis; gt2->GetXaxis()-",MatchSource.WIKI,doc/master/timeonaxis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/timeonaxis_8C.html
https://root.cern/doc/master/timeonaxis_8C.html:2490,Usability,simpl,simple,2490,",120);; if (i>700) {; noise += 1000*sin((i-700)*6.28/30)*exp((double)(700-i)/300);; }; ht->SetBinContent(i,noise);; }; ct->cd(1);; ht->SetLineColor(2);; ht->GetXaxis()->SetLabelSize(0.05);; ht->Draw();; // Sets time on the X axis; // The time used is the one set as time offset added to the value; // of the axis. This is converted into day/month/year hour:min:sec and; // a reasonable tick interval value is chosen.; ht->GetXaxis()->SetTimeDisplay(1);; ; //### Build a simple graph beginning at a different time; // Time interval: 5 seconds; ; float x[100], t[100];; for (i=0;i<100;i++) {; x[i] = sin(i*4*3.1415926/50)*exp(-(double)i/20);; t[i] = 6000+(double)i/20;; }; auto gt = new TGraph(100,t,x);; gt->SetTitle(""Politics"");; ct->cd(2);; gt->SetLineColor(5);; gt->SetLineWidth(2);; gt->Draw(""AL"");; gt->GetXaxis()->SetLabelSize(0.05);; // Sets time on the X axis; gt->GetXaxis()->SetTimeDisplay(1);; gPad->Modified();; ; //### Build a second simple graph for a very long time interval; // Time interval: a few years; ; auto gt2 = new TGraph();; TDatime dateBegin(2000,1,1,0,0,0);; for (i=0;i<10;i++) {; TDatime datePnt(2000 + i,1,1,0,0,0);; gt2->AddPoint(datePnt.Convert() - dateBegin.Convert(), 100 + gRandom->Gaus(500,100)*i);; }; gt2->SetTitle(""Number of monkeys on the moon"");; ct->cd(3);; gt2->SetMarkerColor(4);; gt2->SetMarkerStyle(29);; gt2->SetMarkerSize(1.3);; gt2->Draw(""AP"");; gt2->GetXaxis()->SetLabelSize(0.04);; gt2->GetXaxis()->SetNdivisions(10);; // Sets time on the X axis; gt2->GetXaxis()->SetTimeDisplay(1);; ; // One can choose a different time format than the one chosen by default; // The time format is the same as the one of the C strftime() function; // It's a string containing the following formats :; //; // for date :; // %a abbreviated weekday name; // %b abbreviated month name; // %d day of the month (01-31); // %m month (01-12); // %y year without century; // %Y year with century; //; // for time :; // %H hour (24-hour clock); // %I hour (12-hour clock); // %p",MatchSource.WIKI,doc/master/timeonaxis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/timeonaxis_8C.html
https://root.cern/doc/master/TInterpreter_8cxx_source.html:3207,Availability,error,error,3207,"//////////////////////////////////////////; 46/// TInterpreter ctor only called by derived classes.; 47 ; 48TInterpreter::TInterpreter(const char *name, const char *title); 49 : TNamed(name, title); 50{; 51 gInterpreterLocal = this;; 52 gCling = this;; 53}; 54 ; 55////////////////////////////////////////////////////////////////////////////////; 56/// returns gInterpreter global; 57 ; 58TInterpreter *TInterpreter::Instance(); 59{; 60 if (gInterpreterLocal == nullptr) {; 61 static TROOT *getROOT = ROOT::GetROOT(); // Make sure gInterpreterLocal is set; 62 if (!getROOT) {; 63 ::Fatal(""TInterpreter::Instance"",""TROOT object is required before accessing a TInterpreter"");; 64 }; 65 }; 66 return gInterpreterLocal;; 67}; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TError.h; namechar name[80]Definition TGX11.cxx:110; TGlobal.h; gInterpreterLocalstatic TInterpreter * gInterpreterLocalDefinition TInterpreter.cxx:25; gClingTInterpreter * gClingDefinition TInterpreter.cxx:24; TInterpreter.h; gClingR__EXTERN TInterpreter * gClingDefinition TInterpreter.h:574; TROOT.h; TGlobalMappedFunction::MakeFunctorstatic void MakeFunctor(const char *name, const char *type, GlobFunc &func)Definition TGlobal.h:73; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::TInterpreterTInterpreter()Definition TInterpreter.h:135; TInterpreter::Instancestatic TInterpreter * Instance()returns gInterpreter globalDefinition TInterpreter.cxx:58; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TROOTROOT top level object description.Definition TROOT.h:94; ROOT::GetROOTTROOT * GetROOT()Definition TROOT.cxx:472. coremetasrcTInterpreter.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TInterpreter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8cxx_source.html
https://root.cern/doc/master/TInterpreter_8cxx_source.html:692,Integrability,interface,interface,692,". ROOT: core/meta/src/TInterpreter.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TInterpreter.cxx. Go to the documentation of this file. 1// @(#)root/meta:$Id$; 2// Author: Fons Rademakers 01/03/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TInterpreter; 13This class defines an abstract interface to a generic command line; 14interpreter.; 15*/; 16 ; 17#include ""TInterpreter.h""; 18 ; 19#include ""TROOT.h""; 20#include ""TError.h""; 21#include ""TGlobal.h""; 22 ; 23 ; 24TInterpreter* gCling = nullptr; // returns pointer to global TCling object; 25static TInterpreter *gInterpreterLocal = nullptr; // The real holder of the pointer.; 26 ; 27 ; 28namespace {; 29static struct AddPseudoGlobals {; 30AddPseudoGlobals() {; 31 ; 32 // use special functor to extract pointer on gInterpreterLocal variable; 33 TGlobalMappedFunction::MakeFunctor(""gInterpreter"", ""TInterpreter*"", TInterpreter::Instance, [] {; 34 TInterpreter::Instance();; 35 return (void *) &gInterpreterLocal;; 36 });; 37 ; 38}; 39} gAddPseudoGlobals;; 40}; 41 ; 42 ; 43ClassImp(TInterpreter);; 44 ; 45////////////////////////////////////////////////////////////////////////////////; 46/// TInterpreter ctor only called by derived classes.; 47 ; 48TInterpreter::TInterpreter(const char *name, const char *title); 49 : TNamed(name, title); 50{; 51 gInterpreterLocal = this;; 52 gCling = this;; 53}; 54 ; 55////////////////////////////////////////////////////////////////////////////////; 56/// returns gInterpreter global; 57 ; 58TInterpreter *TInterpreter::Instance(); 59{; 60 if (gInterpreterLocal == nullptr) {; 61 static TROOT *getROOT =",MatchSource.WIKI,doc/master/TInterpreter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8cxx_source.html
https://root.cern/doc/master/TInterpreter_8cxx_source.html:2759,Integrability,interface,interface,2759,"//////////////////////////////////////////; 46/// TInterpreter ctor only called by derived classes.; 47 ; 48TInterpreter::TInterpreter(const char *name, const char *title); 49 : TNamed(name, title); 50{; 51 gInterpreterLocal = this;; 52 gCling = this;; 53}; 54 ; 55////////////////////////////////////////////////////////////////////////////////; 56/// returns gInterpreter global; 57 ; 58TInterpreter *TInterpreter::Instance(); 59{; 60 if (gInterpreterLocal == nullptr) {; 61 static TROOT *getROOT = ROOT::GetROOT(); // Make sure gInterpreterLocal is set; 62 if (!getROOT) {; 63 ::Fatal(""TInterpreter::Instance"",""TROOT object is required before accessing a TInterpreter"");; 64 }; 65 }; 66 return gInterpreterLocal;; 67}; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TError.h; namechar name[80]Definition TGX11.cxx:110; TGlobal.h; gInterpreterLocalstatic TInterpreter * gInterpreterLocalDefinition TInterpreter.cxx:25; gClingTInterpreter * gClingDefinition TInterpreter.cxx:24; TInterpreter.h; gClingR__EXTERN TInterpreter * gClingDefinition TInterpreter.h:574; TROOT.h; TGlobalMappedFunction::MakeFunctorstatic void MakeFunctor(const char *name, const char *type, GlobFunc &func)Definition TGlobal.h:73; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::TInterpreterTInterpreter()Definition TInterpreter.h:135; TInterpreter::Instancestatic TInterpreter * Instance()returns gInterpreter globalDefinition TInterpreter.cxx:58; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TROOTROOT top level object description.Definition TROOT.h:94; ROOT::GetROOTTROOT * GetROOT()Definition TROOT.cxx:472. coremetasrcTInterpreter.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TInterpreter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8cxx_source.html
https://root.cern/doc/master/TInterpreter_8cxx_source.html:3213,Integrability,message,message,3213,"//////////////////////////////////////////; 46/// TInterpreter ctor only called by derived classes.; 47 ; 48TInterpreter::TInterpreter(const char *name, const char *title); 49 : TNamed(name, title); 50{; 51 gInterpreterLocal = this;; 52 gCling = this;; 53}; 54 ; 55////////////////////////////////////////////////////////////////////////////////; 56/// returns gInterpreter global; 57 ; 58TInterpreter *TInterpreter::Instance(); 59{; 60 if (gInterpreterLocal == nullptr) {; 61 static TROOT *getROOT = ROOT::GetROOT(); // Make sure gInterpreterLocal is set; 62 if (!getROOT) {; 63 ::Fatal(""TInterpreter::Instance"",""TROOT object is required before accessing a TInterpreter"");; 64 }; 65 }; 66 return gInterpreterLocal;; 67}; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TError.h; namechar name[80]Definition TGX11.cxx:110; TGlobal.h; gInterpreterLocalstatic TInterpreter * gInterpreterLocalDefinition TInterpreter.cxx:25; gClingTInterpreter * gClingDefinition TInterpreter.cxx:24; TInterpreter.h; gClingR__EXTERN TInterpreter * gClingDefinition TInterpreter.h:574; TROOT.h; TGlobalMappedFunction::MakeFunctorstatic void MakeFunctor(const char *name, const char *type, GlobFunc &func)Definition TGlobal.h:73; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::TInterpreterTInterpreter()Definition TInterpreter.h:135; TInterpreter::Instancestatic TInterpreter * Instance()returns gInterpreter globalDefinition TInterpreter.cxx:58; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TROOTROOT top level object description.Definition TROOT.h:94; ROOT::GetROOTTROOT * GetROOT()Definition TROOT.cxx:472. coremetasrcTInterpreter.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TInterpreter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8cxx_source.html
https://root.cern/doc/master/TInterpreter_8cxx_source.html:1191,Modifiability,variab,variable,1191,"**************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TInterpreter; 13This class defines an abstract interface to a generic command line; 14interpreter.; 15*/; 16 ; 17#include ""TInterpreter.h""; 18 ; 19#include ""TROOT.h""; 20#include ""TError.h""; 21#include ""TGlobal.h""; 22 ; 23 ; 24TInterpreter* gCling = nullptr; // returns pointer to global TCling object; 25static TInterpreter *gInterpreterLocal = nullptr; // The real holder of the pointer.; 26 ; 27 ; 28namespace {; 29static struct AddPseudoGlobals {; 30AddPseudoGlobals() {; 31 ; 32 // use special functor to extract pointer on gInterpreterLocal variable; 33 TGlobalMappedFunction::MakeFunctor(""gInterpreter"", ""TInterpreter*"", TInterpreter::Instance, [] {; 34 TInterpreter::Instance();; 35 return (void *) &gInterpreterLocal;; 36 });; 37 ; 38}; 39} gAddPseudoGlobals;; 40}; 41 ; 42 ; 43ClassImp(TInterpreter);; 44 ; 45////////////////////////////////////////////////////////////////////////////////; 46/// TInterpreter ctor only called by derived classes.; 47 ; 48TInterpreter::TInterpreter(const char *name, const char *title); 49 : TNamed(name, title); 50{; 51 gInterpreterLocal = this;; 52 gCling = this;; 53}; 54 ; 55////////////////////////////////////////////////////////////////////////////////; 56/// returns gInterpreter global; 57 ; 58TInterpreter *TInterpreter::Instance(); 59{; 60 if (gInterpreterLocal == nullptr) {; 61 static TROOT *getROOT = ROOT::GetROOT(); // Make sure gInterpreterLocal is set; 62 if (!getROOT) {; 63 ::Fatal(""TInterpreter::Instance"",""TROOT object is required before accessing a TInterpreter"");; 64 }; 65 }; 66 return gInterpreterLocal;; 67}; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TError.h; namechar name[80]Definition T",MatchSource.WIKI,doc/master/TInterpreter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8cxx_source.html
https://root.cern/doc/master/TInterpreter_8cxx_source.html:2147,Security,access,accessing,2147,"ing object; 25static TInterpreter *gInterpreterLocal = nullptr; // The real holder of the pointer.; 26 ; 27 ; 28namespace {; 29static struct AddPseudoGlobals {; 30AddPseudoGlobals() {; 31 ; 32 // use special functor to extract pointer on gInterpreterLocal variable; 33 TGlobalMappedFunction::MakeFunctor(""gInterpreter"", ""TInterpreter*"", TInterpreter::Instance, [] {; 34 TInterpreter::Instance();; 35 return (void *) &gInterpreterLocal;; 36 });; 37 ; 38}; 39} gAddPseudoGlobals;; 40}; 41 ; 42 ; 43ClassImp(TInterpreter);; 44 ; 45////////////////////////////////////////////////////////////////////////////////; 46/// TInterpreter ctor only called by derived classes.; 47 ; 48TInterpreter::TInterpreter(const char *name, const char *title); 49 : TNamed(name, title); 50{; 51 gInterpreterLocal = this;; 52 gCling = this;; 53}; 54 ; 55////////////////////////////////////////////////////////////////////////////////; 56/// returns gInterpreter global; 57 ; 58TInterpreter *TInterpreter::Instance(); 59{; 60 if (gInterpreterLocal == nullptr) {; 61 static TROOT *getROOT = ROOT::GetROOT(); // Make sure gInterpreterLocal is set; 62 if (!getROOT) {; 63 ::Fatal(""TInterpreter::Instance"",""TROOT object is required before accessing a TInterpreter"");; 64 }; 65 }; 66 return gInterpreterLocal;; 67}; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TError.h; namechar name[80]Definition TGX11.cxx:110; TGlobal.h; gInterpreterLocalstatic TInterpreter * gInterpreterLocalDefinition TInterpreter.cxx:25; gClingTInterpreter * gClingDefinition TInterpreter.cxx:24; TInterpreter.h; gClingR__EXTERN TInterpreter * gClingDefinition TInterpreter.h:574; TROOT.h; TGlobalMappedFunction::MakeFunctorstatic void MakeFunctor(const char *name, const char *type, GlobFunc &func)Definition TGlobal.h:73; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::TInterpreterTInterpreter()Definition TInterpreter.h:135; TInterpreter::Instancestatic",MatchSource.WIKI,doc/master/TInterpreter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8cxx_source.html
https://root.cern/doc/master/TInterpreter_8h.html:460,Integrability,depend,dependency,460,". ROOT: core/meta/inc/TInterpreter.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Macros |; Typedefs |; Variables ; TInterpreter.h File Reference. #include ""TDataType.h""; #include ""TDictionary.h""; #include ""TInterpreterValue.h""; #include ""TNamed.h""; #include ""TVirtualRWMutex.h""; #include <map>; #include <typeinfo>; #include <vector>; #include <string>; #include <utility>. Include dependency graph for TInterpreter.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  TInterpreter::CallFuncIFacePtr_t;  ; struct  ROOT::Internal::InterpreterMutexRegistrationRAII;  ; class  TInterpreter::SuspendAutoLoadingRAII;  ; class  TInterpreter::SuspendAutoParsing;  ; class  TInterpreter;  This class defines an abstract interface to a generic command line interpreter. More...;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define gInterpreter   (TInterpreter::Instance());  ; #define R__LOCKGUARD_CLING(mutex)   ::ROOT::Internal::InterpreterMutexRegistrationRAII _R__UNIQUE_(R__guard)(mutex); { };  . Typedefs; typedef TInterpreter * CreateInterpreter_t(void *shlibHandle, const char *argv[]);  ; typedef void * DestroyInterpreter_t(TInterpreter *);  . Variables; R__EXTERN TInterpreter * gCling;  ; R__EXTERN TVirtualMutex * gInterpreterMutex;  . Macro Definition Documentation. ◆ gInterpreter. #define gInterpreter   (TInterpreter::Instance()). Definition at line 573 of file TInterpreter.h. ◆ R__LOCKGUARD_CLING. #define R__LOCKGUARD_CLING; (;  ; mutex);    ::ROOT::Internal::InterpreterMutexRegistrationRAII _R__UNIQUE_(R__guard",MatchSource.WIKI,doc/master/TInterpreter_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h.html
https://root.cern/doc/master/TInterpreter_8h.html:1000,Integrability,interface,interface,1000,". ROOT: core/meta/inc/TInterpreter.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Macros |; Typedefs |; Variables ; TInterpreter.h File Reference. #include ""TDataType.h""; #include ""TDictionary.h""; #include ""TInterpreterValue.h""; #include ""TNamed.h""; #include ""TVirtualRWMutex.h""; #include <map>; #include <typeinfo>; #include <vector>; #include <string>; #include <utility>. Include dependency graph for TInterpreter.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  TInterpreter::CallFuncIFacePtr_t;  ; struct  ROOT::Internal::InterpreterMutexRegistrationRAII;  ; class  TInterpreter::SuspendAutoLoadingRAII;  ; class  TInterpreter::SuspendAutoParsing;  ; class  TInterpreter;  This class defines an abstract interface to a generic command line interpreter. More...;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define gInterpreter   (TInterpreter::Instance());  ; #define R__LOCKGUARD_CLING(mutex)   ::ROOT::Internal::InterpreterMutexRegistrationRAII _R__UNIQUE_(R__guard)(mutex); { };  . Typedefs; typedef TInterpreter * CreateInterpreter_t(void *shlibHandle, const char *argv[]);  ; typedef void * DestroyInterpreter_t(TInterpreter *);  . Variables; R__EXTERN TInterpreter * gCling;  ; R__EXTERN TVirtualMutex * gInterpreterMutex;  . Macro Definition Documentation. ◆ gInterpreter. #define gInterpreter   (TInterpreter::Instance()). Definition at line 573 of file TInterpreter.h. ◆ R__LOCKGUARD_CLING. #define R__LOCKGUARD_CLING; (;  ; mutex);    ::ROOT::Internal::InterpreterMutexRegistrationRAII _R__UNIQUE_(R__guard",MatchSource.WIKI,doc/master/TInterpreter_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h.html
https://root.cern/doc/master/TInterpreter_8h_source.html:1955,Availability,error,error,1955,"ndef ROOT_TInterpreter; 14#define ROOT_TInterpreter; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TInterpreter //; 19// //; 20// This class defines an abstract interface to a generic command line //; 21// interpreter. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TDataType.h""; 26#include ""TDictionary.h""; 27#include ""TInterpreterValue.h""; 28#include ""TNamed.h""; 29#include ""TVirtualRWMutex.h""; 30 ; 31#include <map>; 32#include <typeinfo>; 33#include <vector>; 34#include <string>; 35#include <utility>; 36 ; 37class TClass;; 38class TEnv;; 39class TFunction;; 40class TMethod;; 41class TObjArray;; 42class TEnum;; 43class TListOfEnums;; 44class TSeqCollection;; 45 ; 46R__EXTERN TVirtualMutex *gInterpreterMutex;; 47 ; 48# define R__LOCKGUARD_CLING(mutex) ::ROOT::Internal::InterpreterMutexRegistrationRAII _R__UNIQUE_(R__guard)(mutex); { }; 49 ; 50namespace ROOT {; 51namespace Internal {; 52struct InterpreterMutexRegistrationRAII {; 53 TLockGuard fLockGuard;; 54 InterpreterMutexRegistrationRAII(TVirtualMutex* mutex);; 55 ~InterpreterMutexRegistrationRAII();; 56};; 57}; 58}; 59 ; 60class TInterpreter : public TNamed {; 61 ; 62protected:; 63 void Execute(TMethod *method, TObjArray *params, int *error = nullptr) override = 0;; 64 virtual Bool_t SetSuspendAutoParsing(Bool_t value) = 0;; 65 ; 66 friend class SuspendAutoParsing;; 67 ; 68public:; 69 // See as in TSchemaType.h.; 70 typedef class std::map<std::string, std::string> MembersMap_t;; 71 ; 72 enum EErrorCode {; 73 kNoError = 0,; 74 kRecoverable = 1,; 75 kDangerous = 2,; 76 kFatal = 3,; 77 kProcessing = 99; 78 };; 79 ; 80 enum class EReturnType { kLong, kDouble, kString, kOther, kNoReturnType };; 81 ; 82 struct CallFuncIFacePtr_t {; 83 enum EKind {; 84 kUninitialized,; 85 kGeneric,; 86 kCtor,; 87 kDtor; 88 };; 89 ; 90 typedef void (*Generic_t)(void*, int, void**, void*);; 91 typedef void (*Ctor_t)(void**, void*,",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:6408,Availability,error,error,6408,"lected input is incomplete.; 154 virtual Int_t GetMore() const = 0;; 155 virtual TClass *GenerateTClass(const char *classname, Bool_t emulation, Bool_t silent = kFALSE) = 0;; 156 virtual TClass *GenerateTClass(ClassInfo_t *classinfo, Bool_t silent = kFALSE) = 0;; 157 virtual Int_t GenerateDictionary(const char *classes, const char *includes = nullptr, const char *options = nullptr) = 0;; 158 virtual char *GetPrompt() = 0;; 159 virtual const char *GetSharedLibs() = 0;; 160 virtual const char *GetClassSharedLibs(const char *cls, bool skipCore = true) = 0;; 161 virtual const char *GetSharedLibDeps(const char *lib, bool tryDyld = false) = 0;; 162 virtual const char *GetIncludePath() = 0;; 163 virtual const char *GetSTLIncludePath() const { return """"; }; 164 virtual TObjArray *GetRootMapFiles() const = 0;; 165 virtual void Initialize() = 0;; 166 virtual void ShutDown() = 0;; 167 virtual void InspectMembers(TMemberInspector&, const void* obj, const TClass* cl, Bool_t isTransient) = 0;; 168 virtual Bool_t IsLoaded(const char *filename) const = 0;; 169 virtual Bool_t IsLibraryLoaded(const char *libname) const = 0;; 170 virtual Bool_t HasPCMForLibrary(const char *libname) const = 0;; 171 virtual Int_t Load(const char *filenam, Bool_t system = kFALSE) = 0;; 172 virtual void LoadMacro(const char *filename, EErrorCode *error = nullptr) = 0;; 173 virtual Int_t LoadLibraryMap(const char *rootmapfile = nullptr) = 0;; 174 virtual Int_t RescanLibraryMap() = 0;; 175 virtual Int_t ReloadAllSharedLibraryMaps() = 0;; 176 virtual Int_t UnloadAllSharedLibraryMaps() = 0;; 177 virtual Int_t UnloadLibraryMap(const char *library) = 0;; 178 virtual Longptr_t ProcessLine(const char *line, EErrorCode *error = nullptr) = 0;; 179 virtual Longptr_t ProcessLineSynch(const char *line, EErrorCode *error = nullptr) = 0;; 180 virtual void PrintIntro() = 0;; 181 virtual bool RegisterPrebuiltModulePath(const std::string& FullPath,; 182 const std::string& ModuleMapName = ""module.modulemap"") const = 0;; 183",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:6780,Availability,error,error,6780,"lected input is incomplete.; 154 virtual Int_t GetMore() const = 0;; 155 virtual TClass *GenerateTClass(const char *classname, Bool_t emulation, Bool_t silent = kFALSE) = 0;; 156 virtual TClass *GenerateTClass(ClassInfo_t *classinfo, Bool_t silent = kFALSE) = 0;; 157 virtual Int_t GenerateDictionary(const char *classes, const char *includes = nullptr, const char *options = nullptr) = 0;; 158 virtual char *GetPrompt() = 0;; 159 virtual const char *GetSharedLibs() = 0;; 160 virtual const char *GetClassSharedLibs(const char *cls, bool skipCore = true) = 0;; 161 virtual const char *GetSharedLibDeps(const char *lib, bool tryDyld = false) = 0;; 162 virtual const char *GetIncludePath() = 0;; 163 virtual const char *GetSTLIncludePath() const { return """"; }; 164 virtual TObjArray *GetRootMapFiles() const = 0;; 165 virtual void Initialize() = 0;; 166 virtual void ShutDown() = 0;; 167 virtual void InspectMembers(TMemberInspector&, const void* obj, const TClass* cl, Bool_t isTransient) = 0;; 168 virtual Bool_t IsLoaded(const char *filename) const = 0;; 169 virtual Bool_t IsLibraryLoaded(const char *libname) const = 0;; 170 virtual Bool_t HasPCMForLibrary(const char *libname) const = 0;; 171 virtual Int_t Load(const char *filenam, Bool_t system = kFALSE) = 0;; 172 virtual void LoadMacro(const char *filename, EErrorCode *error = nullptr) = 0;; 173 virtual Int_t LoadLibraryMap(const char *rootmapfile = nullptr) = 0;; 174 virtual Int_t RescanLibraryMap() = 0;; 175 virtual Int_t ReloadAllSharedLibraryMaps() = 0;; 176 virtual Int_t UnloadAllSharedLibraryMaps() = 0;; 177 virtual Int_t UnloadLibraryMap(const char *library) = 0;; 178 virtual Longptr_t ProcessLine(const char *line, EErrorCode *error = nullptr) = 0;; 179 virtual Longptr_t ProcessLineSynch(const char *line, EErrorCode *error = nullptr) = 0;; 180 virtual void PrintIntro() = 0;; 181 virtual bool RegisterPrebuiltModulePath(const std::string& FullPath,; 182 const std::string& ModuleMapName = ""module.modulemap"") const = 0;; 183",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:6872,Availability,error,error,6872,"lected input is incomplete.; 154 virtual Int_t GetMore() const = 0;; 155 virtual TClass *GenerateTClass(const char *classname, Bool_t emulation, Bool_t silent = kFALSE) = 0;; 156 virtual TClass *GenerateTClass(ClassInfo_t *classinfo, Bool_t silent = kFALSE) = 0;; 157 virtual Int_t GenerateDictionary(const char *classes, const char *includes = nullptr, const char *options = nullptr) = 0;; 158 virtual char *GetPrompt() = 0;; 159 virtual const char *GetSharedLibs() = 0;; 160 virtual const char *GetClassSharedLibs(const char *cls, bool skipCore = true) = 0;; 161 virtual const char *GetSharedLibDeps(const char *lib, bool tryDyld = false) = 0;; 162 virtual const char *GetIncludePath() = 0;; 163 virtual const char *GetSTLIncludePath() const { return """"; }; 164 virtual TObjArray *GetRootMapFiles() const = 0;; 165 virtual void Initialize() = 0;; 166 virtual void ShutDown() = 0;; 167 virtual void InspectMembers(TMemberInspector&, const void* obj, const TClass* cl, Bool_t isTransient) = 0;; 168 virtual Bool_t IsLoaded(const char *filename) const = 0;; 169 virtual Bool_t IsLibraryLoaded(const char *libname) const = 0;; 170 virtual Bool_t HasPCMForLibrary(const char *libname) const = 0;; 171 virtual Int_t Load(const char *filenam, Bool_t system = kFALSE) = 0;; 172 virtual void LoadMacro(const char *filename, EErrorCode *error = nullptr) = 0;; 173 virtual Int_t LoadLibraryMap(const char *rootmapfile = nullptr) = 0;; 174 virtual Int_t RescanLibraryMap() = 0;; 175 virtual Int_t ReloadAllSharedLibraryMaps() = 0;; 176 virtual Int_t UnloadAllSharedLibraryMaps() = 0;; 177 virtual Int_t UnloadLibraryMap(const char *library) = 0;; 178 virtual Longptr_t ProcessLine(const char *line, EErrorCode *error = nullptr) = 0;; 179 virtual Longptr_t ProcessLineSynch(const char *line, EErrorCode *error = nullptr) = 0;; 180 virtual void PrintIntro() = 0;; 181 virtual bool RegisterPrebuiltModulePath(const std::string& FullPath,; 182 const std::string& ModuleMapName = ""module.modulemap"") const = 0;; 183",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:8898,Availability,error,error,8898,"l void Reset() = 0;; 200 virtual void ResetAll() = 0;; 201 virtual void ResetGlobals() = 0;; 202 virtual void ResetGlobalVar(void *obj) = 0;; 203 virtual void RewindDictionary() = 0;; 204 virtual Int_t DeleteGlobal(void *obj) = 0;; 205 virtual Int_t DeleteVariable(const char* name) = 0;; 206 virtual void SaveContext() = 0;; 207 virtual void SaveGlobalsContext() = 0;; 208 virtual void UpdateListOfGlobals() = 0;; 209 virtual void UpdateListOfGlobalFunctions() = 0;; 210 virtual void UpdateListOfTypes() = 0;; 211 virtual void SetClassInfo(TClass *cl, Bool_t reload = kFALSE, Bool_t silent = kFALSE) = 0;; 212 ; 213 enum ECheckClassInfo {; 214 kUnknown = 0, // backward compatible with false; 215 kKnown = 1,; 216 kWithClassDefInline = 2; 217 };; 218 virtual ECheckClassInfo CheckClassInfo(const char *name, Bool_t autoload, Bool_t isClassOrNamespaceOnly = kFALSE) = 0;; 219 ; 220 virtual Bool_t CheckClassTemplate(const char *name) = 0;; 221 virtual Longptr_t Calc(const char *line, EErrorCode* error = nullptr) = 0;; 222 virtual void CreateListOfBaseClasses(TClass *cl) const = 0;; 223 virtual void CreateListOfDataMembers(TClass *cl) const = 0;; 224 virtual void CreateListOfMethods(TClass *cl) const = 0;; 225 virtual void CreateListOfMethodArgs(TFunction *m) const = 0;; 226 virtual void UpdateListOfMethods(TClass *cl) const = 0;; 227 virtual TString GetMangledName(TClass *cl, const char *method, const char *params, Bool_t objectIsConst = kFALSE) = 0;; 228 virtual TString GetMangledNameWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) = 0;; 229 virtual void GetInterpreterTypeName(const char *name, std::string &output, Bool_t full = kFALSE) = 0;; 230 virtual void *GetInterfaceMethod(TClass *cl, const char *method, const char *params, Bool_t objectIsConst = kFALSE) = 0;; 231 virtual void *GetInterfaceMethodWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:10058,Availability,error,error,10058,"l void CreateListOfMethods(TClass *cl) const = 0;; 225 virtual void CreateListOfMethodArgs(TFunction *m) const = 0;; 226 virtual void UpdateListOfMethods(TClass *cl) const = 0;; 227 virtual TString GetMangledName(TClass *cl, const char *method, const char *params, Bool_t objectIsConst = kFALSE) = 0;; 228 virtual TString GetMangledNameWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) = 0;; 229 virtual void GetInterpreterTypeName(const char *name, std::string &output, Bool_t full = kFALSE) = 0;; 230 virtual void *GetInterfaceMethod(TClass *cl, const char *method, const char *params, Bool_t objectIsConst = kFALSE) = 0;; 231 virtual void *GetInterfaceMethodWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) = 0;; 232 void Execute(const char *function, const char *params, int *error = nullptr) override = 0;; 233 virtual void Execute(TObject *obj, TClass *cl, const char *method, const char *params, int *error = nullptr) = 0;; 234 virtual void Execute(TObject *obj, TClass *cl, TMethod *method, TObjArray *params, int *error = nullptr) = 0;; 235 virtual void ExecuteWithArgsAndReturn(TMethod *method, void* address, const void* args[] = nullptr, int /*nargs*/ = 0, void *ret= nullptr) const = 0;; 236 virtual Longptr_t ExecuteMacro(const char *filename, EErrorCode *error = nullptr) = 0;; 237 virtual Bool_t IsErrorMessagesEnabled() const = 0;; 238 virtual Bool_t SetErrorMessages(Bool_t enable = kTRUE) = 0;; 239 virtual Bool_t IsProcessLineLocked() const = 0;; 240 virtual void SetProcessLineLock(Bool_t lock = kTRUE) = 0;; 241 virtual const char *TypeName(const char *s) = 0;; 242 virtual std::string ToString(const char *type, void *obj) = 0;; 243 ; 244 virtual void SnapshotMutexState(ROOT::TVirtualRWMutex* mtx) = 0;; 245 virtual void ForgetMutexState() = 0;; 246 ; 247 // ",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:10186,Availability,error,error,10186,"; 226 virtual void UpdateListOfMethods(TClass *cl) const = 0;; 227 virtual TString GetMangledName(TClass *cl, const char *method, const char *params, Bool_t objectIsConst = kFALSE) = 0;; 228 virtual TString GetMangledNameWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) = 0;; 229 virtual void GetInterpreterTypeName(const char *name, std::string &output, Bool_t full = kFALSE) = 0;; 230 virtual void *GetInterfaceMethod(TClass *cl, const char *method, const char *params, Bool_t objectIsConst = kFALSE) = 0;; 231 virtual void *GetInterfaceMethodWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) = 0;; 232 void Execute(const char *function, const char *params, int *error = nullptr) override = 0;; 233 virtual void Execute(TObject *obj, TClass *cl, const char *method, const char *params, int *error = nullptr) = 0;; 234 virtual void Execute(TObject *obj, TClass *cl, TMethod *method, TObjArray *params, int *error = nullptr) = 0;; 235 virtual void ExecuteWithArgsAndReturn(TMethod *method, void* address, const void* args[] = nullptr, int /*nargs*/ = 0, void *ret= nullptr) const = 0;; 236 virtual Longptr_t ExecuteMacro(const char *filename, EErrorCode *error = nullptr) = 0;; 237 virtual Bool_t IsErrorMessagesEnabled() const = 0;; 238 virtual Bool_t SetErrorMessages(Bool_t enable = kTRUE) = 0;; 239 virtual Bool_t IsProcessLineLocked() const = 0;; 240 virtual void SetProcessLineLock(Bool_t lock = kTRUE) = 0;; 241 virtual const char *TypeName(const char *s) = 0;; 242 virtual std::string ToString(const char *type, void *obj) = 0;; 243 ; 244 virtual void SnapshotMutexState(ROOT::TVirtualRWMutex* mtx) = 0;; 245 virtual void ForgetMutexState() = 0;; 246 ; 247 // All the functions below must be virtual with a dummy implementation; 248 // These functions are redefined in TCling.",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:10301,Availability,error,error,10301,"; 226 virtual void UpdateListOfMethods(TClass *cl) const = 0;; 227 virtual TString GetMangledName(TClass *cl, const char *method, const char *params, Bool_t objectIsConst = kFALSE) = 0;; 228 virtual TString GetMangledNameWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) = 0;; 229 virtual void GetInterpreterTypeName(const char *name, std::string &output, Bool_t full = kFALSE) = 0;; 230 virtual void *GetInterfaceMethod(TClass *cl, const char *method, const char *params, Bool_t objectIsConst = kFALSE) = 0;; 231 virtual void *GetInterfaceMethodWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) = 0;; 232 void Execute(const char *function, const char *params, int *error = nullptr) override = 0;; 233 virtual void Execute(TObject *obj, TClass *cl, const char *method, const char *params, int *error = nullptr) = 0;; 234 virtual void Execute(TObject *obj, TClass *cl, TMethod *method, TObjArray *params, int *error = nullptr) = 0;; 235 virtual void ExecuteWithArgsAndReturn(TMethod *method, void* address, const void* args[] = nullptr, int /*nargs*/ = 0, void *ret= nullptr) const = 0;; 236 virtual Longptr_t ExecuteMacro(const char *filename, EErrorCode *error = nullptr) = 0;; 237 virtual Bool_t IsErrorMessagesEnabled() const = 0;; 238 virtual Bool_t SetErrorMessages(Bool_t enable = kTRUE) = 0;; 239 virtual Bool_t IsProcessLineLocked() const = 0;; 240 virtual void SetProcessLineLock(Bool_t lock = kTRUE) = 0;; 241 virtual const char *TypeName(const char *s) = 0;; 242 virtual std::string ToString(const char *type, void *obj) = 0;; 243 ; 244 virtual void SnapshotMutexState(ROOT::TVirtualRWMutex* mtx) = 0;; 245 virtual void ForgetMutexState() = 0;; 246 ; 247 // All the functions below must be virtual with a dummy implementation; 248 // These functions are redefined in TCling.",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:10548,Availability,error,error,10548,"; 226 virtual void UpdateListOfMethods(TClass *cl) const = 0;; 227 virtual TString GetMangledName(TClass *cl, const char *method, const char *params, Bool_t objectIsConst = kFALSE) = 0;; 228 virtual TString GetMangledNameWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) = 0;; 229 virtual void GetInterpreterTypeName(const char *name, std::string &output, Bool_t full = kFALSE) = 0;; 230 virtual void *GetInterfaceMethod(TClass *cl, const char *method, const char *params, Bool_t objectIsConst = kFALSE) = 0;; 231 virtual void *GetInterfaceMethodWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) = 0;; 232 void Execute(const char *function, const char *params, int *error = nullptr) override = 0;; 233 virtual void Execute(TObject *obj, TClass *cl, const char *method, const char *params, int *error = nullptr) = 0;; 234 virtual void Execute(TObject *obj, TClass *cl, TMethod *method, TObjArray *params, int *error = nullptr) = 0;; 235 virtual void ExecuteWithArgsAndReturn(TMethod *method, void* address, const void* args[] = nullptr, int /*nargs*/ = 0, void *ret= nullptr) const = 0;; 236 virtual Longptr_t ExecuteMacro(const char *filename, EErrorCode *error = nullptr) = 0;; 237 virtual Bool_t IsErrorMessagesEnabled() const = 0;; 238 virtual Bool_t SetErrorMessages(Bool_t enable = kTRUE) = 0;; 239 virtual Bool_t IsProcessLineLocked() const = 0;; 240 virtual void SetProcessLineLock(Bool_t lock = kTRUE) = 0;; 241 virtual const char *TypeName(const char *s) = 0;; 242 virtual std::string ToString(const char *type, void *obj) = 0;; 243 ; 244 virtual void SnapshotMutexState(ROOT::TVirtualRWMutex* mtx) = 0;; 245 virtual void ForgetMutexState() = 0;; 246 ; 247 // All the functions below must be virtual with a dummy implementation; 248 // These functions are redefined in TCling.",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:11516,Availability,error,error,11516," const char *TypeName(const char *s) = 0;; 242 virtual std::string ToString(const char *type, void *obj) = 0;; 243 ; 244 virtual void SnapshotMutexState(ROOT::TVirtualRWMutex* mtx) = 0;; 245 virtual void ForgetMutexState() = 0;; 246 ; 247 // All the functions below must be virtual with a dummy implementation; 248 // These functions are redefined in TCling.; 249 ; 250 // Misc; 251 virtual int DisplayClass(FILE * /* fout */,const char * /* name */,int /* base */,int /* start */) const {return 0;}; 252 virtual int DisplayIncludePath(FILE * /* fout */) const {return 0;}; 253 virtual void *FindSym(const char * /* entry */) const {return nullptr;}; 254 virtual void GenericError(const char * /* error */) const {}; 255 virtual Long_t GetExecByteCode() const {return 0;}; 256 virtual const char *GetTopLevelMacroName() const {return nullptr;};; 257 virtual const char *GetCurrentMacroName() const {return nullptr;};; 258 virtual int GetSecurityError() const{return 0;}; 259 virtual int LoadFile(const char * /* path */) const {return 0;}; 260 virtual Bool_t LoadText(const char * /* text */) const {return kFALSE;}; 261 virtual const char *MapCppName(const char*) const {return nullptr;}; 262 virtual void SetAlloclockfunc(void (*)()) const {}; 263 virtual void SetAllocunlockfunc(void (*)()) const {}; 264 virtual int SetClassAutoLoading(int) const {return 0;}; 265 int SetClassAutoloading(int a) const { return SetClassAutoLoading(a); } // Deprecated; 266 virtual int SetClassAutoparsing(int) {return 0;};; 267 virtual void SetErrmsgcallback(void * /* p */) const {}; 268 /// \brief Report diagnostics to the ROOT error handler (see TError.h).; 269 virtual void ReportDiagnosticsToErrorHandler(bool /*enable*/ = true) {}; 270 virtual void SetTempLevel(int /* val */) const {}; 271 virtual int UnloadFile(const char * /* path */) const {return 0;}; 272 ; 273 /// The created temporary must be deleted by the caller.; 274 /// Deprecated! Please use MakeInterpreterValue().; 275 TInterpreterValue *Cre",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:12436,Availability,error,error,12436," const char *TypeName(const char *s) = 0;; 242 virtual std::string ToString(const char *type, void *obj) = 0;; 243 ; 244 virtual void SnapshotMutexState(ROOT::TVirtualRWMutex* mtx) = 0;; 245 virtual void ForgetMutexState() = 0;; 246 ; 247 // All the functions below must be virtual with a dummy implementation; 248 // These functions are redefined in TCling.; 249 ; 250 // Misc; 251 virtual int DisplayClass(FILE * /* fout */,const char * /* name */,int /* base */,int /* start */) const {return 0;}; 252 virtual int DisplayIncludePath(FILE * /* fout */) const {return 0;}; 253 virtual void *FindSym(const char * /* entry */) const {return nullptr;}; 254 virtual void GenericError(const char * /* error */) const {}; 255 virtual Long_t GetExecByteCode() const {return 0;}; 256 virtual const char *GetTopLevelMacroName() const {return nullptr;};; 257 virtual const char *GetCurrentMacroName() const {return nullptr;};; 258 virtual int GetSecurityError() const{return 0;}; 259 virtual int LoadFile(const char * /* path */) const {return 0;}; 260 virtual Bool_t LoadText(const char * /* text */) const {return kFALSE;}; 261 virtual const char *MapCppName(const char*) const {return nullptr;}; 262 virtual void SetAlloclockfunc(void (*)()) const {}; 263 virtual void SetAllocunlockfunc(void (*)()) const {}; 264 virtual int SetClassAutoLoading(int) const {return 0;}; 265 int SetClassAutoloading(int a) const { return SetClassAutoLoading(a); } // Deprecated; 266 virtual int SetClassAutoparsing(int) {return 0;};; 267 virtual void SetErrmsgcallback(void * /* p */) const {}; 268 /// \brief Report diagnostics to the ROOT error handler (see TError.h).; 269 virtual void ReportDiagnosticsToErrorHandler(bool /*enable*/ = true) {}; 270 virtual void SetTempLevel(int /* val */) const {}; 271 virtual int UnloadFile(const char * /* path */) const {return 0;}; 272 ; 273 /// The created temporary must be deleted by the caller.; 274 /// Deprecated! Please use MakeInterpreterValue().; 275 TInterpreterValue *Cre",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:46329,Availability,error,error,46329,"Validvirtual Bool_t ClassInfo_IsValid(ClassInfo_t *) constDefinition TInterpreter.h:421; TInterpreter::MethodArgInfo_TypeNormalizedNamevirtual std::string MethodArgInfo_TypeNormalizedName(MethodArgInfo_t *) const =0; TInterpreter::DeleteVariablevirtual Int_t DeleteVariable(const char *name)=0; TInterpreter::GenericErrorvirtual void GenericError(const char *) constDefinition TInterpreter.h:254; TInterpreter::SaveGlobalsContextvirtual void SaveGlobalsContext()=0; TInterpreter::CallFunc_ExecIntvirtual Longptr_t CallFunc_ExecInt(CallFunc_t *, void *) constDefinition TInterpreter.h:319; TInterpreter::ForgetMutexStatevirtual void ForgetMutexState()=0; TInterpreter::TypedefInfo_TrueNamevirtual const char * TypedefInfo_TrueName(TypedefInfo_t *) constDefinition TInterpreter.h:548; TInterpreter::BaseClassInfo_Nextvirtual int BaseClassInfo_Next(BaseClassInfo_t *, int) constDefinition TInterpreter.h:445; TInterpreter::ProcessLinevirtual Longptr_t ProcessLine(const char *line, EErrorCode *error=nullptr)=0; TInterpreter::SetClassAutoloadingint SetClassAutoloading(int a) constDefinition TInterpreter.h:265; TInterpreter::GenerateDictionaryvirtual Int_t GenerateDictionary(const char *classes, const char *includes=nullptr, const char *options=nullptr)=0; TInterpreter::TypedefInfo_Propertyvirtual Long_t TypedefInfo_Property(TypedefInfo_t *) constDefinition TInterpreter.h:546; TInterpreter::CallFunc_SetArgvirtual void CallFunc_SetArg(CallFunc_t *, Double_t) const =0; TInterpreter::HasPCMForLibraryvirtual Bool_t HasPCMForLibrary(const char *libname) const =0; TInterpreter::CallFunc_SetFuncProtovirtual void CallFunc_SetFuncProto(CallFunc_t *func, ClassInfo_t *info, const char *method, const std::vector< TypeInfo_t * > &proto, Longptr_t *Offset, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) const =0; TInterpreter::GetSharedLibDepsvirtual const char * GetSharedLibDeps(const char *lib, bool tryDyld=false)=0; TInterpreter::GetFunctionvirtual DeclId_t GetFunction(ClassInfo_t *cl, const",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:47434,Availability,error,error,47434," TInterpreter::BaseClassInfo_Nextvirtual int BaseClassInfo_Next(BaseClassInfo_t *, int) constDefinition TInterpreter.h:445; TInterpreter::ProcessLinevirtual Longptr_t ProcessLine(const char *line, EErrorCode *error=nullptr)=0; TInterpreter::SetClassAutoloadingint SetClassAutoloading(int a) constDefinition TInterpreter.h:265; TInterpreter::GenerateDictionaryvirtual Int_t GenerateDictionary(const char *classes, const char *includes=nullptr, const char *options=nullptr)=0; TInterpreter::TypedefInfo_Propertyvirtual Long_t TypedefInfo_Property(TypedefInfo_t *) constDefinition TInterpreter.h:546; TInterpreter::CallFunc_SetArgvirtual void CallFunc_SetArg(CallFunc_t *, Double_t) const =0; TInterpreter::HasPCMForLibraryvirtual Bool_t HasPCMForLibrary(const char *libname) const =0; TInterpreter::CallFunc_SetFuncProtovirtual void CallFunc_SetFuncProto(CallFunc_t *func, ClassInfo_t *info, const char *method, const std::vector< TypeInfo_t * > &proto, Longptr_t *Offset, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) const =0; TInterpreter::GetSharedLibDepsvirtual const char * GetSharedLibDeps(const char *lib, bool tryDyld=false)=0; TInterpreter::GetFunctionvirtual DeclId_t GetFunction(ClassInfo_t *cl, const char *funcname)=0; TInterpreter::Executevoid Execute(TMethod *method, TObjArray *params, int *error=nullptr) override=0Execute method on this object with parameters stored in the TObjArray.; TInterpreter::AutoParsevirtual Int_t AutoParse(const char *cls)=0; TInterpreter::GetIncludePathvirtual const char * GetIncludePath()=0; TInterpreter::CodeCompletevirtual void CodeComplete(const std::string &, size_t &, std::vector< std::string > &)Definition TInterpreter.h:279; TInterpreter::TypedefInfo_IsValidvirtual Bool_t TypedefInfo_IsValid(TypedefInfo_t *) constDefinition TInterpreter.h:544; TInterpreter::AutoLoadvirtual Int_t AutoLoad(const std::type_info &typeinfo, Bool_t knowDictNotLoaded=kFALSE)=0; TInterpreter::TypeInfo_Namevirtual const char * TypeInfo_Name(TypeInfo_t *) ",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:48236,Availability,error,error,48236,"false)=0; TInterpreter::GetFunctionvirtual DeclId_t GetFunction(ClassInfo_t *cl, const char *funcname)=0; TInterpreter::Executevoid Execute(TMethod *method, TObjArray *params, int *error=nullptr) override=0Execute method on this object with parameters stored in the TObjArray.; TInterpreter::AutoParsevirtual Int_t AutoParse(const char *cls)=0; TInterpreter::GetIncludePathvirtual const char * GetIncludePath()=0; TInterpreter::CodeCompletevirtual void CodeComplete(const std::string &, size_t &, std::vector< std::string > &)Definition TInterpreter.h:279; TInterpreter::TypedefInfo_IsValidvirtual Bool_t TypedefInfo_IsValid(TypedefInfo_t *) constDefinition TInterpreter.h:544; TInterpreter::AutoLoadvirtual Int_t AutoLoad(const std::type_info &typeinfo, Bool_t knowDictNotLoaded=kFALSE)=0; TInterpreter::TypeInfo_Namevirtual const char * TypeInfo_Name(TypeInfo_t *) constDefinition TInterpreter.h:530; TInterpreter::LoadMacrovirtual void LoadMacro(const char *filename, EErrorCode *error=nullptr)=0; TInterpreter::ClassInfo_Deletevirtual void ClassInfo_Delete(ClassInfo_t *) constDefinition TInterpreter.h:401; TInterpreter::CallFunc_SetArgumentsvoid CallFunc_SetArguments(CallFunc_t *func, const T &... args)Definition TInterpreter.h:380; TInterpreter::CallFunc_ExecWithReturnvirtual void CallFunc_ExecWithReturn(CallFunc_t *, void *, void *) constDefinition TInterpreter.h:317; TInterpreter::GetClassvirtual TClass * GetClass(const std::type_info &typeinfo, Bool_t load) const =0; TInterpreter::CallFunc_SetArgvoid CallFunc_SetArg(CallFunc_t *func, void *arg)Definition TInterpreter.h:351; TInterpreter::RegisterModulevirtual void RegisterModule(const char *, const char **, const char **, const char *, const char *, void(*)(), const FwdDeclArgsToKeepCollection_t &fwdDeclArgsToKeep, const char **classesHeaders, Bool_t lateRegistration=false, Bool_t hasCxxModule=false)=0; TInterpreter::CallFunc_SetArgvoid CallFunc_SetArg(CallFunc_t *func, Char_t param) constDefinition TInterpreter.h:340; TInte",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:60719,Availability,error,error,60719,"Definition TInterpreter.h:465; TInterpreter::IsErrorMessagesEnabledvirtual Bool_t IsErrorMessagesEnabled() const =0; TInterpreter::DataMemberInfo_Nextvirtual int DataMemberInfo_Next(DataMemberInfo_t *) constDefinition TInterpreter.h:462; TInterpreter::BaseClassInfo_Deletevirtual void BaseClassInfo_Delete(BaseClassInfo_t *) constDefinition TInterpreter.h:440; TInterpreter::ClassInfo_Factoryvirtual ClassInfo_t * ClassInfo_Factory(Bool_t=kTRUE) const =0; TInterpreter::SetAutoLoadCallBackvirtual void * SetAutoLoadCallBack(void *)Definition TInterpreter.h:140; TInterpreter::CheckClassTemplatevirtual Bool_t CheckClassTemplate(const char *name)=0; TInterpreter::MethodArgInfo_Propertyvirtual Long_t MethodArgInfo_Property(MethodArgInfo_t *) constDefinition TInterpreter.h:515; TInterpreter::IsSignedIntegerTypevirtual Bool_t IsSignedIntegerType(const void *) constDefinition TInterpreter.h:555; TInterpreter::ExecuteMacrovirtual Longptr_t ExecuteMacro(const char *filename, EErrorCode *error=nullptr)=0; TInterpreter::IsVoidPointerTypevirtual Bool_t IsVoidPointerType(const void *) constDefinition TInterpreter.h:559; TInterpreter::ClassInfo_Containsvirtual Bool_t ClassInfo_Contains(ClassInfo_t *info, DeclId_t decl) const =0; TInterpreter::DataMemberInfo_Factoryvirtual DataMemberInfo_t * DataMemberInfo_Factory(ClassInfo_t *, TDictionary::EMemberSelection) constDefinition TInterpreter.h:457; TInterpreter::IsAutoParsingSuspendedvirtual Bool_t IsAutoParsingSuspended() const =0; TInterpreter::GetEnumvirtual DeclId_t GetEnum(TClass *cl, const char *name) const =0; TInterpreter::MethodArgInfo_Deletevirtual void MethodArgInfo_Delete(MethodArgInfo_t *) constDefinition TInterpreter.h:509; TInterpreter::ClassInfo_FileNamevirtual const char * ClassInfo_FileName(ClassInfo_t *) constDefinition TInterpreter.h:432; TInterpreter::ClassInfo_Newvirtual void * ClassInfo_New(ClassInfo_t *, int, void *) constDefinition TInterpreter.h:427; TInterpreter::TypeInfo_Propertyvirtual Long_t TypeInfo_Property(Ty",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:62766,Availability,error,error,62766,":CallFunc_SetFuncProtovirtual void CallFunc_SetFuncProto(CallFunc_t *, ClassInfo_t *, const char *, const char *, bool, Longptr_t *, ROOT::EFunctionMatchMode=ROOT::kConversionMatch) constDefinition TInterpreter.h:392; TInterpreter::SnapshotMutexStatevirtual void SnapshotMutexState(ROOT::TVirtualRWMutex *mtx)=0; TInterpreter::MethodInfo_Factoryvirtual MethodInfo_t * MethodInfo_Factory(ClassInfo_t *) constDefinition TInterpreter.h:489; TInterpreter::CreateListOfMethodsvirtual void CreateListOfMethods(TClass *cl) const =0; TInterpreter::TypeInfo_Sizevirtual int TypeInfo_Size(TypeInfo_t *) constDefinition TInterpreter.h:533; TInterpreter::MethodInfo_FactoryCopyvirtual MethodInfo_t * MethodInfo_FactoryCopy(MethodInfo_t *) constDefinition TInterpreter.h:491; TInterpreter::Executevirtual void Execute(TObject *obj, TClass *cl, TMethod *method, TObjArray *params, int *error=nullptr)=0; TInterpreter::SetGetlinevirtual void SetGetline(const char *(*getlineFunc)(const char *prompt), void(*histaddFunc)(const char *line))=0; TInterpreter::ClassInfo_IsValidMethodvirtual Bool_t ClassInfo_IsValidMethod(ClassInfo_t *, const char *, const char *, Bool_t, Longptr_t *, ROOT::EFunctionMatchMode=ROOT::kConversionMatch) constDefinition TInterpreter.h:423; TInterpreter::MethodInfo_Namevirtual const char * MethodInfo_Name(MethodInfo_t *) constDefinition TInterpreter.h:503; TInterpreter::ClassInfo_GetMethodNArgvirtual int ClassInfo_GetMethodNArg(ClassInfo_t *, const char *, const char *, Bool_t=false, ROOT::EFunctionMatchMode=ROOT::kConversionMatch) constDefinition TInterpreter.h:411; TInterpreter::UpdateListOfTypesvirtual void UpdateListOfTypes()=0; TInterpreter::DataMemberInfo_Factoryvirtual DataMemberInfo_t * DataMemberInfo_Factory(DeclId_t declid, ClassInfo_t *clinfo) const =0; TInterpreter::GetClassSharedLibsvirtual const char * GetClassSharedLibs(const char *cls, bool skipCore=true)=0; TInterpreter::MethodArgInfo_FactoryCopyvirtual MethodArgInfo_t * MethodArgInfo_FactoryCopy(MethodArgInf",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:69250,Availability,error,error,69250,"nterpreter::MethodInfo_Propertyvirtual Long_t MethodInfo_Property(MethodInfo_t *) const =0; TInterpreter::GetSharedLibsvirtual const char * GetSharedLibs()=0; TInterpreter::MapCppNamevirtual const char * MapCppName(const char *) constDefinition TInterpreter.h:261; TInterpreter::MethodInfo_IsValidvirtual Bool_t MethodInfo_IsValid(MethodInfo_t *) constDefinition TInterpreter.h:493; TInterpreter::DataMemberInfo_Deletevirtual void DataMemberInfo_Delete(DataMemberInfo_t *) constDefinition TInterpreter.h:456; TInterpreter::LoadEnumsvirtual void LoadEnums(TListOfEnums &cl) const =0; TInterpreter::BaseClassInfo_ClassInfovirtual ClassInfo_t * BaseClassInfo_ClassInfo(BaseClassInfo_t *) const =0; TInterpreter::~TInterpretervirtual ~TInterpreter()Definition TInterpreter.h:137; TInterpreter::FindSymvirtual void * FindSym(const char *) constDefinition TInterpreter.h:253; TInterpreter::SaveContextvirtual void SaveContext()=0; TInterpreter::ProcessLineSynchvirtual Longptr_t ProcessLineSynch(const char *line, EErrorCode *error=nullptr)=0; TInterpreter::SetErrmsgcallbackvirtual void SetErrmsgcallback(void *) constDefinition TInterpreter.h:267; TInterpreter::CallFunc_SetArgImplvoid CallFunc_SetArgImpl(CallFunc_t *)Definition TInterpreter.h:362; TInterpreter::CallFunc_SetArgvoid CallFunc_SetArg(CallFunc_t *func, UShort_t param) constDefinition TInterpreter.h:345; TInterpreter::ClassInfo_IsLoadedvirtual Bool_t ClassInfo_IsLoaded(ClassInfo_t *) constDefinition TInterpreter.h:420; TInterpreter::DataMemberInfo_MaxIndexvirtual int DataMemberInfo_MaxIndex(DataMemberInfo_t *, Int_t) constDefinition TInterpreter.h:461; TInterpreter::GetDeclIdvirtual DeclId_t GetDeclId(ClassInfo_t *info) const =0; TInterpreter::CallFunc_FactoryCopyvirtual CallFunc_t * CallFunc_FactoryCopy(CallFunc_t *) constDefinition TInterpreter.h:323; TInterpreter::ClassInfo_IsValidMethodvirtual Bool_t ClassInfo_IsValidMethod(ClassInfo_t *, const char *, const char *, Longptr_t *, ROOT::EFunctionMatchMode=ROOT::kConversionMa",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:71244,Availability,error,error,71244,"ition TInterpreter.h:422; TInterpreter::GetExitCodevirtual Int_t GetExitCode() const =0; TInterpreter::TypedefInfo_Titlevirtual const char * TypedefInfo_Title(TypedefInfo_t *) constDefinition TInterpreter.h:550; TInterpreter::ClassInfo_Initvirtual void ClassInfo_Init(ClassInfo_t *, const char *) constDefinition TInterpreter.h:414; TInterpreter::DataMemberInfo_Titlevirtual const char * DataMemberInfo_Title(DataMemberInfo_t *) constDefinition TInterpreter.h:470; TInterpreter::BaseClassInfo_Nextvirtual int BaseClassInfo_Next(BaseClassInfo_t *) constDefinition TInterpreter.h:444; TInterpreter::LoadLibraryMapvirtual Int_t LoadLibraryMap(const char *rootmapfile=nullptr)=0; TInterpreter::MethodArgInfo_Factoryvirtual MethodArgInfo_t * MethodArgInfo_Factory(MethodInfo_t *) constDefinition TInterpreter.h:511; TInterpreter::SetAlloclockfuncvirtual void SetAlloclockfunc(void(*)()) constDefinition TInterpreter.h:262; TInterpreter::Executevoid Execute(const char *function, const char *params, int *error=nullptr) override=0Execute method on this object with the given parameter string, e.g.; TInterpreter::DeclId_tTDictionary::DeclId_t DeclId_tDefinition TInterpreter.h:288; TInterpreter::CallFunc_Execvirtual void CallFunc_Exec(CallFunc_t *, void *, TInterpreterValue &) constDefinition TInterpreter.h:316; TInterpreter::ClassInfo_Factoryvirtual ClassInfo_t * ClassInfo_Factory(ClassInfo_t *) const =0; TInterpreter::GetMangledNameWithPrototypevirtual TString GetMangledNameWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode=ROOT::kConversionMatch)=0; TInterpreter::GetDeclIdvirtual DeclId_t GetDeclId(CallFunc_t *info) const =0; TInterpreter::ExecuteWithArgsAndReturnvirtual void ExecuteWithArgsAndReturn(TMethod *method, void *address, const void *args[]=nullptr, int=0, void *ret=nullptr) const =0; TInterpreter::MakeInterpreterValuevirtual std::unique_ptr< TInterpreterValue > MakeInterpreterValue() constDefinition TInterpret",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:73932,Availability,error,error,73932,"_t TypeInfo_IsValid(TypeInfo_t *) constDefinition TInterpreter.h:529; TInterpreter::CallFunc_IFacePtrvirtual CallFuncIFacePtr_t CallFunc_IFacePtr(CallFunc_t *) constDefinition TInterpreter.h:328; TInterpreter::BaseClassInfo_Factoryvirtual BaseClassInfo_t * BaseClassInfo_Factory(ClassInfo_t *) constDefinition TInterpreter.h:441; TInterpreter::GetFunctionOverloadsvirtual void GetFunctionOverloads(ClassInfo_t *cl, const char *funcname, std::vector< DeclId_t > &res) const =0; TInterpreter::GetDeclIdvirtual DeclId_t GetDeclId(MethodInfo_t *info) const =0; TInterpreter::RegisterTClassUpdatevirtual void RegisterTClassUpdate(TClass *oldcl, DictFuncPtr_t dict)=0; TInterpreter::ClassInfo_IsScopedEnumvirtual Bool_t ClassInfo_IsScopedEnum(ClassInfo_t *) constDefinition TInterpreter.h:418; TInterpreter::MethodInfo_Nextvirtual int MethodInfo_Next(MethodInfo_t *) constDefinition TInterpreter.h:496; TInterpreter::Calcvirtual Longptr_t Calc(const char *line, EErrorCode *error=nullptr)=0; TInterpreter::CallFunc_FactoryMethodvirtual MethodInfo_t * CallFunc_FactoryMethod(CallFunc_t *) constDefinition TInterpreter.h:324; TInterpreter::ReportDiagnosticsToErrorHandlervirtual void ReportDiagnosticsToErrorHandler(bool=true)Report diagnostics to the ROOT error handler (see TError.h).Definition TInterpreter.h:269; TInterpreter::BaseClassInfo_Offsetvirtual Longptr_t BaseClassInfo_Offset(BaseClassInfo_t *, void *=nullptr, bool=true) constDefinition TInterpreter.h:446; TInterpreter::DataMemberInfo_TypeTrueNamevirtual const char * DataMemberInfo_TypeTrueName(DataMemberInfo_t *) constDefinition TInterpreter.h:468; TInterpreter::CallFunc_SetArgvirtual void CallFunc_SetArg(CallFunc_t *, ULong_t) const =0; TInterpreter::TypeInfo_FactoryCopyvirtual TypeInfo_t * TypeInfo_FactoryCopy(TypeInfo_t *) constDefinition TInterpreter.h:527; TInterpreter::GenerateTClassvirtual TClass * GenerateTClass(ClassInfo_t *classinfo, Bool_t silent=kFALSE)=0; TInterpreter::ClassInfo_ClassPropertyvirtual Long_t ClassInfo_Cla",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:74213,Availability,error,error,74213,"8; TInterpreter::BaseClassInfo_Factoryvirtual BaseClassInfo_t * BaseClassInfo_Factory(ClassInfo_t *) constDefinition TInterpreter.h:441; TInterpreter::GetFunctionOverloadsvirtual void GetFunctionOverloads(ClassInfo_t *cl, const char *funcname, std::vector< DeclId_t > &res) const =0; TInterpreter::GetDeclIdvirtual DeclId_t GetDeclId(MethodInfo_t *info) const =0; TInterpreter::RegisterTClassUpdatevirtual void RegisterTClassUpdate(TClass *oldcl, DictFuncPtr_t dict)=0; TInterpreter::ClassInfo_IsScopedEnumvirtual Bool_t ClassInfo_IsScopedEnum(ClassInfo_t *) constDefinition TInterpreter.h:418; TInterpreter::MethodInfo_Nextvirtual int MethodInfo_Next(MethodInfo_t *) constDefinition TInterpreter.h:496; TInterpreter::Calcvirtual Longptr_t Calc(const char *line, EErrorCode *error=nullptr)=0; TInterpreter::CallFunc_FactoryMethodvirtual MethodInfo_t * CallFunc_FactoryMethod(CallFunc_t *) constDefinition TInterpreter.h:324; TInterpreter::ReportDiagnosticsToErrorHandlervirtual void ReportDiagnosticsToErrorHandler(bool=true)Report diagnostics to the ROOT error handler (see TError.h).Definition TInterpreter.h:269; TInterpreter::BaseClassInfo_Offsetvirtual Longptr_t BaseClassInfo_Offset(BaseClassInfo_t *, void *=nullptr, bool=true) constDefinition TInterpreter.h:446; TInterpreter::DataMemberInfo_TypeTrueNamevirtual const char * DataMemberInfo_TypeTrueName(DataMemberInfo_t *) constDefinition TInterpreter.h:468; TInterpreter::CallFunc_SetArgvirtual void CallFunc_SetArg(CallFunc_t *, ULong_t) const =0; TInterpreter::TypeInfo_FactoryCopyvirtual TypeInfo_t * TypeInfo_FactoryCopy(TypeInfo_t *) constDefinition TInterpreter.h:527; TInterpreter::GenerateTClassvirtual TClass * GenerateTClass(ClassInfo_t *classinfo, Bool_t silent=kFALSE)=0; TInterpreter::ClassInfo_ClassPropertyvirtual Long_t ClassInfo_ClassProperty(ClassInfo_t *) constDefinition TInterpreter.h:400; TInterpreter::GetMorevirtual Int_t GetMore() const =0Returns whether the interpreter is waiting for more input, i.e.; TInterpreter",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:79750,Availability,error,error,79750," *info) const =0; TInterpreter::FuncTempInfo_IsValidvirtual Bool_t FuncTempInfo_IsValid(FuncTempInfo_t *) const =0; TInterpreter::CallFunc_SetArgImplvoid CallFunc_SetArgImpl(CallFunc_t *func, const U &head)Definition TInterpreter.h:367; TInterpreter::BaseClassInfo_Propertyvirtual Long_t BaseClassInfo_Property(BaseClassInfo_t *) constDefinition TInterpreter.h:447; TInterpreter::CallFunc_ExecDoublevirtual Double_t CallFunc_ExecDouble(CallFunc_t *, void *) constDefinition TInterpreter.h:321; TInterpreter::CallFunc_SetArgvirtual void CallFunc_SetArg(CallFunc_t *, Long_t) const =0; TInterpreter::GetInterfaceMethodvirtual void * GetInterfaceMethod(TClass *cl, const char *method, const char *params, Bool_t objectIsConst=kFALSE)=0; TInterpreter::GetCurrentMacroNamevirtual const char * GetCurrentMacroName() constDefinition TInterpreter.h:257; TInterpreter::Executevirtual void Execute(TObject *obj, TClass *cl, const char *method, const char *params, int *error=nullptr)=0; TInterpreter::TypeNamevirtual const char * TypeName(const char *s)=0; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TLockGuardDefinition TVirtualMutex.h:70; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStringBasic string class.Definition TString.h:139; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; double; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOTtbb::task_arena is an alias of tbb::",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:12878,Deployability,release,release,12878,"unc(void (*)()) const {}; 263 virtual void SetAllocunlockfunc(void (*)()) const {}; 264 virtual int SetClassAutoLoading(int) const {return 0;}; 265 int SetClassAutoloading(int a) const { return SetClassAutoLoading(a); } // Deprecated; 266 virtual int SetClassAutoparsing(int) {return 0;};; 267 virtual void SetErrmsgcallback(void * /* p */) const {}; 268 /// \brief Report diagnostics to the ROOT error handler (see TError.h).; 269 virtual void ReportDiagnosticsToErrorHandler(bool /*enable*/ = true) {}; 270 virtual void SetTempLevel(int /* val */) const {}; 271 virtual int UnloadFile(const char * /* path */) const {return 0;}; 272 ; 273 /// The created temporary must be deleted by the caller.; 274 /// Deprecated! Please use MakeInterpreterValue().; 275 TInterpreterValue *CreateTemporary() const {; 276 return MakeInterpreterValue().release();; 277 }; 278 virtual std::unique_ptr<TInterpreterValue> MakeInterpreterValue() const { return nullptr; }; 279 virtual void CodeComplete(const std::string&, size_t&,; 280 std::vector<std::string>&) {}; 281 virtual int Evaluate(const char*, TInterpreterValue&) {return 0;}; 282 ; 283 // core/meta helper functions.; 284 virtual EReturnType MethodCallReturnType(TFunction *func) const = 0;; 285 virtual ULong64_t GetInterpreterStateMarker() const = 0;; 286 virtual bool DiagnoseIfInterpreterException(const std::exception &e) const = 0;; 287 ; 288 typedef TDictionary::DeclId_t DeclId_t;; 289 virtual DeclId_t GetDeclId(CallFunc_t *info) const = 0;; 290 virtual DeclId_t GetDeclId(ClassInfo_t *info) const = 0;; 291 virtual DeclId_t GetDeclId(DataMemberInfo_t *info) const = 0;; 292 virtual DeclId_t GetDeclId(FuncTempInfo_t *info) const = 0;; 293 virtual DeclId_t GetDeclId(MethodInfo_t *info) const = 0;; 294 virtual DeclId_t GetDeclId(TypedefInfo_t *info) const = 0;; 295 ; 296 virtual void SetDeclAttr(DeclId_t, const char* /* attribute */) = 0 ;; 297 ; 298 virtual DeclId_t GetDataMember(ClassInfo_t *cl, const char *name) const = 0;; 299 virtual De",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:850,Integrability,interface,interface,850,". ROOT: core/meta/inc/TInterpreter.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TInterpreter.h. Go to the documentation of this file. 1// @(#)root/meta:$Id$; 2// Author: Fons Rademakers 01/03/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13#ifndef ROOT_TInterpreter; 14#define ROOT_TInterpreter; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TInterpreter //; 19// //; 20// This class defines an abstract interface to a generic command line //; 21// interpreter. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TDataType.h""; 26#include ""TDictionary.h""; 27#include ""TInterpreterValue.h""; 28#include ""TNamed.h""; 29#include ""TVirtualRWMutex.h""; 30 ; 31#include <map>; 32#include <typeinfo>; 33#include <vector>; 34#include <string>; 35#include <utility>; 36 ; 37class TClass;; 38class TEnv;; 39class TFunction;; 40class TMethod;; 41class TObjArray;; 42class TEnum;; 43class TListOfEnums;; 44class TSeqCollection;; 45 ; 46R__EXTERN TVirtualMutex *gInterpreterMutex;; 47 ; 48# define R__LOCKGUARD_CLING(mutex) ::ROOT::Internal::InterpreterMutexRegistrationRAII _R__UNIQUE_(R__guard)(mutex); { }; 49 ; 50namespace ROOT {; 51namespace Internal {; 52struct InterpreterMutexRegistrationRAII {; 53 TLockGuard fLockGuard;; 54 InterpreterMutexRegistrationRAII(TVirtualMutex* mutex);; 55 ~InterpreterMutexRegistrationRAII();; 56};; 57}; 58}; 59 ; 60class TInterpreter : public TNamed {; 61 ; 62protected:; 63 void Execute(TMethod *method, TObjArray *params, int *error = nullptr) override = 0;; 64 virtual Boo",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:15226,Integrability,interface,interface,15226,") const = 0;; 302 virtual TEnum* CreateEnum(void *VD, TClass *cl) const = 0;; 303 virtual void UpdateEnumConstants(TEnum* enumObj, TClass* cl) const = 0;; 304 virtual void LoadEnums(TListOfEnums& cl) const = 0;; 305 virtual DeclId_t GetFunction(ClassInfo_t *cl, const char *funcname) = 0;; 306 virtual DeclId_t GetFunctionWithPrototype(ClassInfo_t *cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) = 0;; 307 virtual DeclId_t GetFunctionWithValues(ClassInfo_t *cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE) = 0;; 308 virtual DeclId_t GetFunctionTemplate(ClassInfo_t *cl, const char *funcname) = 0;; 309 virtual void GetFunctionOverloads(ClassInfo_t *cl, const char *funcname, std::vector<DeclId_t>& res) const = 0;; 310 virtual void LoadFunctionTemplates(TClass* cl) const = 0;; 311 virtual std::vector<std::string> GetUsingNamespaces(ClassInfo_t *cl) const = 0;; 312 ; 313 // CallFunc interface; 314 virtual void CallFunc_Delete(CallFunc_t * /* func */) const {}; 315 virtual void CallFunc_Exec(CallFunc_t * /* func */, void * /* address */) const {}; 316 virtual void CallFunc_Exec(CallFunc_t * /* func */, void * /* address */, TInterpreterValue& /* val */) const {}; 317 virtual void CallFunc_ExecWithReturn(CallFunc_t * /* func */, void * /* address */, void * /* ret */) const {}; 318 virtual void CallFunc_ExecWithArgsAndReturn(CallFunc_t * /* func */, void * /* address */, const void* /* args */ [] = nullptr, int /*nargs*/ = 0, void * /* ret */ = nullptr) const {}; 319 virtual Longptr_t CallFunc_ExecInt(CallFunc_t * /* func */, void * /* address */) const {return 0;}; 320 virtual Long64_t CallFunc_ExecInt64(CallFunc_t * /* func */, void * /* address */) const {return 0;}; 321 virtual Double_t CallFunc_ExecDouble(CallFunc_t * /* func */, void * /* address */) const {return 0;}; 322 virtual CallFunc_t *CallFunc_Factory() const {return nullptr;}; 323 virtual CallFunc_t *CallF",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:20895,Integrability,interface,interface,20895,"o */, const char * /* method */, const char * /* proto */, Longptr_t * /* Offset */, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) const {}; 392 virtual void CallFunc_SetFuncProto(CallFunc_t * /* func */, ClassInfo_t * /* info */, const char * /* method */, const char * /* proto */, bool /* objectIsConst */, Longptr_t * /* Offset */, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) const {}; 393 virtual void CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const std::vector<TypeInfo_t*> &proto, Longptr_t* Offset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const = 0;; 394 virtual void CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const std::vector<TypeInfo_t*> &proto, bool objectIsConst, Longptr_t* Offset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const = 0;; 395 ; 396 virtual std::string CallFunc_GetWrapperCode(CallFunc_t *func) const = 0;; 397 ; 398 // ClassInfo interface; 399 virtual Bool_t ClassInfo_Contains(ClassInfo_t *info, DeclId_t decl) const = 0;; 400 virtual Long_t ClassInfo_ClassProperty(ClassInfo_t * /* info */) const {return 0;}; 401 virtual void ClassInfo_Delete(ClassInfo_t * /* info */) const {}; 402 virtual void ClassInfo_Delete(ClassInfo_t * /* info */, void * /* arena */) const {}; 403 virtual void ClassInfo_DeleteArray(ClassInfo_t * /* info */, void * /* arena */, bool /* dtorOnly */) const {}; 404 virtual void ClassInfo_Destruct(ClassInfo_t * /* info */, void * /* arena */) const {}; 405 virtual ClassInfo_t *ClassInfo_Factory(Bool_t /*all*/ = kTRUE) const = 0;; 406 virtual ClassInfo_t *ClassInfo_Factory(ClassInfo_t * /* cl */) const = 0;; 407 virtual ClassInfo_t *ClassInfo_Factory(const char * /* name */) const = 0;; 408 virtual ClassInfo_t *ClassInfo_Factory(DeclId_t declid) const = 0;; 409 virtual Longptr_t ClassInfo_GetBaseOffset(ClassInfo_t* /* fromDerived */,; 410 ClassInfo_t* /* toBase */, void* /* address */ = nullptr, boo",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:24836,Integrability,interface,interface,24836,"t /* n */) const {return nullptr;}; 427 virtual void *ClassInfo_New(ClassInfo_t * /* info */, int /* n */, void * /* arena */) const {return nullptr;}; 428 virtual void *ClassInfo_New(ClassInfo_t * /* info */, void * /* arena */) const {return nullptr;}; 429 virtual Long_t ClassInfo_Property(ClassInfo_t * /* info */) const {return 0;}; 430 virtual int ClassInfo_Size(ClassInfo_t * /* info */) const {return 0;}; 431 virtual Longptr_t ClassInfo_Tagnum(ClassInfo_t * /* info */) const {return 0;}; 432 virtual const char *ClassInfo_FileName(ClassInfo_t * /* info */) const {return nullptr;}; 433 virtual const char *ClassInfo_FullName(ClassInfo_t * /* info */) const {return nullptr;}; 434 virtual const char *ClassInfo_Name(ClassInfo_t * /* info */) const {return nullptr;}; 435 virtual const char *ClassInfo_Title(ClassInfo_t * /* info */) const {return nullptr;}; 436 virtual const char *ClassInfo_TmpltName(ClassInfo_t * /* info */) const {return nullptr;}; 437 ; 438 ; 439 // BaseClassInfo interface; 440 virtual void BaseClassInfo_Delete(BaseClassInfo_t * /* bcinfo */) const {}; 441 virtual BaseClassInfo_t *BaseClassInfo_Factory(ClassInfo_t * /* info */) const {return nullptr;}; 442 virtual BaseClassInfo_t *BaseClassInfo_Factory(ClassInfo_t* /* derived */,; 443 ClassInfo_t* /* base */) const {return nullptr;}; 444 virtual int BaseClassInfo_Next(BaseClassInfo_t * /* bcinfo */) const {return 0;}; 445 virtual int BaseClassInfo_Next(BaseClassInfo_t * /* bcinfo */, int /* onlyDirect */) const {return 0;}; 446 virtual Longptr_t BaseClassInfo_Offset(BaseClassInfo_t * /* toBaseClassInfo */, void* /* address */ = nullptr /*default for non-virtual*/, bool /*isderived*/ = true /*default for non-virtual*/) const {return 0;}; 447 virtual Long_t BaseClassInfo_Property(BaseClassInfo_t * /* bcinfo */) const {return 0;}; 448 virtual Longptr_t BaseClassInfo_Tagnum(BaseClassInfo_t * /* bcinfo */) const {return 0;}; 449 virtual ClassInfo_t*BaseClassInfo_ClassInfo(BaseClassInfo_t * /* bcinfo */) ",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:26190,Integrability,interface,interface,26190,"xt(BaseClassInfo_t * /* bcinfo */) const {return 0;}; 445 virtual int BaseClassInfo_Next(BaseClassInfo_t * /* bcinfo */, int /* onlyDirect */) const {return 0;}; 446 virtual Longptr_t BaseClassInfo_Offset(BaseClassInfo_t * /* toBaseClassInfo */, void* /* address */ = nullptr /*default for non-virtual*/, bool /*isderived*/ = true /*default for non-virtual*/) const {return 0;}; 447 virtual Long_t BaseClassInfo_Property(BaseClassInfo_t * /* bcinfo */) const {return 0;}; 448 virtual Longptr_t BaseClassInfo_Tagnum(BaseClassInfo_t * /* bcinfo */) const {return 0;}; 449 virtual ClassInfo_t*BaseClassInfo_ClassInfo(BaseClassInfo_t * /* bcinfo */) const = 0;; 450 virtual const char *BaseClassInfo_FullName(BaseClassInfo_t * /* bcinfo */) const {return nullptr;}; 451 virtual const char *BaseClassInfo_Name(BaseClassInfo_t * /* bcinfo */) const {return nullptr;}; 452 virtual const char *BaseClassInfo_TmpltName(BaseClassInfo_t * /* bcinfo */) const {return nullptr;}; 453 ; 454 // DataMemberInfo interface; 455 virtual int DataMemberInfo_ArrayDim(DataMemberInfo_t * /* dminfo */) const {return 0;}; 456 virtual void DataMemberInfo_Delete(DataMemberInfo_t * /* dminfo */) const {}; 457 virtual DataMemberInfo_t *DataMemberInfo_Factory(ClassInfo_t * /* clinfo */, TDictionary::EMemberSelection /*selection*/) const {return nullptr;}; 458 virtual DataMemberInfo_t *DataMemberInfo_Factory(DeclId_t declid, ClassInfo_t* clinfo) const = 0;; 459 virtual DataMemberInfo_t *DataMemberInfo_FactoryCopy(DataMemberInfo_t * /* dminfo */) const {return nullptr;}; 460 virtual Bool_t DataMemberInfo_IsValid(DataMemberInfo_t * /* dminfo */) const {return 0;}; 461 virtual int DataMemberInfo_MaxIndex(DataMemberInfo_t * /* dminfo */, Int_t /* dim */) const {return 0;}; 462 virtual int DataMemberInfo_Next(DataMemberInfo_t * /* dminfo */) const {return 0;}; 463 virtual Longptr_t DataMemberInfo_Offset(DataMemberInfo_t * /* dminfo */) const {return 0;}; 464 virtual Long_t DataMemberInfo_Property(DataMemberInfo_t * /*",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:27982,Integrability,interface,interface,27982,"MemberInfo_t * /* dminfo */) const {return 0;}; 463 virtual Longptr_t DataMemberInfo_Offset(DataMemberInfo_t * /* dminfo */) const {return 0;}; 464 virtual Long_t DataMemberInfo_Property(DataMemberInfo_t * /* dminfo */) const {return 0;}; 465 virtual Long_t DataMemberInfo_TypeProperty(DataMemberInfo_t * /* dminfo */) const {return 0;}; 466 virtual int DataMemberInfo_TypeSize(DataMemberInfo_t * /* dminfo */) const {return 0;}; 467 virtual const char *DataMemberInfo_TypeName(DataMemberInfo_t * /* dminfo */) const {return nullptr;}; 468 virtual const char *DataMemberInfo_TypeTrueName(DataMemberInfo_t * /* dminfo */) const {return nullptr;}; 469 virtual const char *DataMemberInfo_Name(DataMemberInfo_t * /* dminfo */) const {return nullptr;}; 470 virtual const char *DataMemberInfo_Title(DataMemberInfo_t * /* dminfo */) const {return nullptr;}; 471 virtual const char *DataMemberInfo_ValidArrayIndex(DataMemberInfo_t * /* dminfo */) const {return nullptr;}; 472 ; 473 // Function Template interface; 474 virtual void FuncTempInfo_Delete(FuncTempInfo_t * /* ft_info */) const = 0;; 475 virtual FuncTempInfo_t *FuncTempInfo_Factory(DeclId_t declid) const = 0;; 476 virtual FuncTempInfo_t *FuncTempInfo_FactoryCopy(FuncTempInfo_t * /* ft_info */) const = 0;; 477 virtual Bool_t FuncTempInfo_IsValid(FuncTempInfo_t * /* ft_info */) const = 0;; 478 virtual UInt_t FuncTempInfo_TemplateNargs(FuncTempInfo_t * /* ft_info */) const = 0;; 479 virtual UInt_t FuncTempInfo_TemplateMinReqArgs(FuncTempInfo_t * /* ft_info */) const = 0;; 480 virtual Long_t FuncTempInfo_Property(FuncTempInfo_t * /* ft_info */) const = 0;; 481 virtual Long_t FuncTempInfo_ExtraProperty(FuncTempInfo_t * /* ft_info */) const = 0;; 482 virtual void FuncTempInfo_Name(FuncTempInfo_t * /* ft_info */, TString &name) const = 0;; 483 virtual void FuncTempInfo_Title(FuncTempInfo_t * /* ft_info */, TString &title) const = 0;; 484 ; 485 // MethodInfo interface; 486 virtual void MethodInfo_CreateSignature(MethodInfo_t * /* minfo *",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:28907,Integrability,interface,interface,28907,"/* dminfo */) const {return nullptr;}; 472 ; 473 // Function Template interface; 474 virtual void FuncTempInfo_Delete(FuncTempInfo_t * /* ft_info */) const = 0;; 475 virtual FuncTempInfo_t *FuncTempInfo_Factory(DeclId_t declid) const = 0;; 476 virtual FuncTempInfo_t *FuncTempInfo_FactoryCopy(FuncTempInfo_t * /* ft_info */) const = 0;; 477 virtual Bool_t FuncTempInfo_IsValid(FuncTempInfo_t * /* ft_info */) const = 0;; 478 virtual UInt_t FuncTempInfo_TemplateNargs(FuncTempInfo_t * /* ft_info */) const = 0;; 479 virtual UInt_t FuncTempInfo_TemplateMinReqArgs(FuncTempInfo_t * /* ft_info */) const = 0;; 480 virtual Long_t FuncTempInfo_Property(FuncTempInfo_t * /* ft_info */) const = 0;; 481 virtual Long_t FuncTempInfo_ExtraProperty(FuncTempInfo_t * /* ft_info */) const = 0;; 482 virtual void FuncTempInfo_Name(FuncTempInfo_t * /* ft_info */, TString &name) const = 0;; 483 virtual void FuncTempInfo_Title(FuncTempInfo_t * /* ft_info */, TString &title) const = 0;; 484 ; 485 // MethodInfo interface; 486 virtual void MethodInfo_CreateSignature(MethodInfo_t * /* minfo */, TString & /* signature */) const {}; 487 virtual void MethodInfo_Delete(MethodInfo_t * /* minfo */) const {}; 488 virtual MethodInfo_t *MethodInfo_Factory() const {return nullptr;}; 489 virtual MethodInfo_t *MethodInfo_Factory(ClassInfo_t * /*clinfo*/) const {return nullptr;}; 490 virtual MethodInfo_t *MethodInfo_Factory(DeclId_t declid) const = 0;; 491 virtual MethodInfo_t *MethodInfo_FactoryCopy(MethodInfo_t * /* minfo */) const {return nullptr;}; 492 virtual void *MethodInfo_InterfaceMethod(MethodInfo_t * /* minfo */) const {return nullptr;}; 493 virtual Bool_t MethodInfo_IsValid(MethodInfo_t * /* minfo */) const {return 0;}; 494 virtual int MethodInfo_NArg(MethodInfo_t * /* minfo */) const {return 0;}; 495 virtual int MethodInfo_NDefaultArg(MethodInfo_t * /* minfo */) const {return 0;}; 496 virtual int MethodInfo_Next(MethodInfo_t * /* minfo */) const {return 0;}; 497 virtual Long_t MethodInfo_Property(Me",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:30833,Integrability,interface,interface,30833," /* minfo */) const {return 0;}; 497 virtual Long_t MethodInfo_Property(MethodInfo_t * /* minfo */) const = 0;; 498 virtual Long_t MethodInfo_ExtraProperty(MethodInfo_t * /* minfo */) const = 0;; 499 virtual TypeInfo_t *MethodInfo_Type(MethodInfo_t * /* minfo */) const {return nullptr;}; 500 virtual EReturnType MethodInfo_MethodCallReturnType(MethodInfo_t* minfo) const = 0;; 501 virtual const char *MethodInfo_GetMangledName(MethodInfo_t * /* minfo */) const {return nullptr;}; 502 virtual const char *MethodInfo_GetPrototype(MethodInfo_t * /* minfo */) const {return nullptr;}; 503 virtual const char *MethodInfo_Name(MethodInfo_t * /* minfo */) const {return nullptr;}; 504 virtual const char *MethodInfo_TypeName(MethodInfo_t * /* minfo */) const {return nullptr;}; 505 virtual std::string MethodInfo_TypeNormalizedName(MethodInfo_t * /* minfo */) const {return """";}; 506 virtual const char *MethodInfo_Title(MethodInfo_t * /* minfo */) const {return nullptr;}; 507 ; 508 // MethodArgInfo interface; 509 virtual void MethodArgInfo_Delete(MethodArgInfo_t * /* marginfo */) const {}; 510 virtual MethodArgInfo_t *MethodArgInfo_Factory() const {return nullptr;}; 511 virtual MethodArgInfo_t *MethodArgInfo_Factory(MethodInfo_t * /*minfo*/) const {return nullptr;}; 512 virtual MethodArgInfo_t *MethodArgInfo_FactoryCopy(MethodArgInfo_t * /* marginfo */) const {return nullptr;}; 513 virtual Bool_t MethodArgInfo_IsValid(MethodArgInfo_t * /* marginfo */) const {return 0;}; 514 virtual int MethodArgInfo_Next(MethodArgInfo_t * /* marginfo */) const {return 0;}; 515 virtual Long_t MethodArgInfo_Property(MethodArgInfo_t * /* marginfo */) const {return 0;}; 516 virtual const char *MethodArgInfo_DefaultValue(MethodArgInfo_t * /* marginfo */) const {return nullptr;}; 517 virtual const char *MethodArgInfo_Name(MethodArgInfo_t * /* marginfo */) const {return nullptr;}; 518 virtual const char *MethodArgInfo_TypeName(MethodArgInfo_t * /* marginfo */) const {return nullptr;}; 519 virtual std::string",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:32052,Integrability,interface,interface,32052,"thodInfo_t * /*minfo*/) const {return nullptr;}; 512 virtual MethodArgInfo_t *MethodArgInfo_FactoryCopy(MethodArgInfo_t * /* marginfo */) const {return nullptr;}; 513 virtual Bool_t MethodArgInfo_IsValid(MethodArgInfo_t * /* marginfo */) const {return 0;}; 514 virtual int MethodArgInfo_Next(MethodArgInfo_t * /* marginfo */) const {return 0;}; 515 virtual Long_t MethodArgInfo_Property(MethodArgInfo_t * /* marginfo */) const {return 0;}; 516 virtual const char *MethodArgInfo_DefaultValue(MethodArgInfo_t * /* marginfo */) const {return nullptr;}; 517 virtual const char *MethodArgInfo_Name(MethodArgInfo_t * /* marginfo */) const {return nullptr;}; 518 virtual const char *MethodArgInfo_TypeName(MethodArgInfo_t * /* marginfo */) const {return nullptr;}; 519 virtual std::string MethodArgInfo_TypeNormalizedName(MethodArgInfo_t * /* marginfo */) const = 0;; 520 virtual TypeInfo_t *MethodArgInfo_TypeInfo(MethodArgInfo_t * /* marginfo */) const {return nullptr;}; 521 ; 522 ; 523 // TypeInfo interface; 524 virtual void TypeInfo_Delete(TypeInfo_t * /* tinfo */) const {}; 525 virtual TypeInfo_t *TypeInfo_Factory() const {return nullptr;}; 526 virtual TypeInfo_t *TypeInfo_Factory(const char* /* name */) const {return nullptr;}; 527 virtual TypeInfo_t *TypeInfo_FactoryCopy(TypeInfo_t * /* tinfo */) const {return nullptr;}; 528 virtual void TypeInfo_Init(TypeInfo_t * /* tinfo */, const char * /* funcname */) const {}; 529 virtual Bool_t TypeInfo_IsValid(TypeInfo_t * /* tinfo */) const {return 0;}; 530 virtual const char *TypeInfo_Name(TypeInfo_t * /* info */) const {return nullptr;}; 531 virtual Long_t TypeInfo_Property(TypeInfo_t * /* tinfo */) const {return 0;}; 532 virtual int TypeInfo_RefType(TypeInfo_t * /* tinfo */) const {return 0;}; 533 virtual int TypeInfo_Size(TypeInfo_t * /* tinfo */) const {return 0;}; 534 virtual const char *TypeInfo_TrueName(TypeInfo_t * /* tinfo */) const {return nullptr;}; 535 virtual void *TypeInfo_QualTypePtr(TypeInfo_t * /* tinfo */) const {return",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:33100,Integrability,interface,interface,33100,"t * /* tinfo */) const {}; 525 virtual TypeInfo_t *TypeInfo_Factory() const {return nullptr;}; 526 virtual TypeInfo_t *TypeInfo_Factory(const char* /* name */) const {return nullptr;}; 527 virtual TypeInfo_t *TypeInfo_FactoryCopy(TypeInfo_t * /* tinfo */) const {return nullptr;}; 528 virtual void TypeInfo_Init(TypeInfo_t * /* tinfo */, const char * /* funcname */) const {}; 529 virtual Bool_t TypeInfo_IsValid(TypeInfo_t * /* tinfo */) const {return 0;}; 530 virtual const char *TypeInfo_Name(TypeInfo_t * /* info */) const {return nullptr;}; 531 virtual Long_t TypeInfo_Property(TypeInfo_t * /* tinfo */) const {return 0;}; 532 virtual int TypeInfo_RefType(TypeInfo_t * /* tinfo */) const {return 0;}; 533 virtual int TypeInfo_Size(TypeInfo_t * /* tinfo */) const {return 0;}; 534 virtual const char *TypeInfo_TrueName(TypeInfo_t * /* tinfo */) const {return nullptr;}; 535 virtual void *TypeInfo_QualTypePtr(TypeInfo_t * /* tinfo */) const {return nullptr;}; 536 ; 537 ; 538 // TypedefInfo interface; 539 virtual void TypedefInfo_Delete(TypedefInfo_t * /* tinfo */) const {}; 540 virtual TypedefInfo_t *TypedefInfo_Factory() const {return nullptr;}; 541 virtual TypedefInfo_t *TypedefInfo_Factory(const char *) const {return nullptr;}; 542 virtual TypedefInfo_t *TypedefInfo_FactoryCopy(TypedefInfo_t * /* tinfo */) const {return nullptr;}; 543 virtual void TypedefInfo_Init(TypedefInfo_t * /* tinfo */, const char * /* funcname */) const {}; 544 virtual Bool_t TypedefInfo_IsValid(TypedefInfo_t * /* tinfo */) const {return 0;}; 545 virtual int TypedefInfo_Next(TypedefInfo_t* /*tinfo*/) const {return 0;}; 546 virtual Long_t TypedefInfo_Property(TypedefInfo_t * /* tinfo */) const {return 0;}; 547 virtual int TypedefInfo_Size(TypedefInfo_t * /* tinfo */) const {return 0;}; 548 virtual const char *TypedefInfo_TrueName(TypedefInfo_t * /* tinfo */) const {return nullptr;}; 549 virtual const char *TypedefInfo_Name(TypedefInfo_t * /* tinfo */) const {return nullptr;}; 550 virtual const char *",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:34210,Integrability,interface,interface,34210,"pedefInfo_Factory() const {return nullptr;}; 541 virtual TypedefInfo_t *TypedefInfo_Factory(const char *) const {return nullptr;}; 542 virtual TypedefInfo_t *TypedefInfo_FactoryCopy(TypedefInfo_t * /* tinfo */) const {return nullptr;}; 543 virtual void TypedefInfo_Init(TypedefInfo_t * /* tinfo */, const char * /* funcname */) const {}; 544 virtual Bool_t TypedefInfo_IsValid(TypedefInfo_t * /* tinfo */) const {return 0;}; 545 virtual int TypedefInfo_Next(TypedefInfo_t* /*tinfo*/) const {return 0;}; 546 virtual Long_t TypedefInfo_Property(TypedefInfo_t * /* tinfo */) const {return 0;}; 547 virtual int TypedefInfo_Size(TypedefInfo_t * /* tinfo */) const {return 0;}; 548 virtual const char *TypedefInfo_TrueName(TypedefInfo_t * /* tinfo */) const {return nullptr;}; 549 virtual const char *TypedefInfo_Name(TypedefInfo_t * /* tinfo */) const {return nullptr;}; 550 virtual const char *TypedefInfo_Title(TypedefInfo_t * /* tinfo */) const {return nullptr;}; 551 ; 552 // QualType Opaque Ptr interface; 553 virtual Bool_t IsSameType(const void * /* QualTypePtr1 */, const void * /* QualTypePtr2 */) const {return 0;}; 554 virtual Bool_t IsIntegerType(const void * /* QualTypePtr */) const {return 0;}; 555 virtual Bool_t IsSignedIntegerType(const void * /* QualTypePtr */) const {return 0;}; 556 virtual Bool_t IsUnsignedIntegerType(const void * /* QualTypePtr */) const {return 0;}; 557 virtual Bool_t IsFloatingType(const void * /* QualTypePtr */) const {return 0;}; 558 virtual Bool_t IsPointerType(const void * /* QualTypePtr */) const {return 0;}; 559 virtual Bool_t IsVoidPointerType(const void * /* QualTypePtr */) const {return 0;}; 560 ; 561 // FunctionDecl interface; 562 virtual Bool_t FunctionDeclId_IsMethod(DeclId_t /* fdeclid */) const {return 0;}; 563 ; 564 static TInterpreter *Instance();; 565 ; 566 ClassDefOverride(TInterpreter,0) //ABC defining interface to generic interpreter; 567};; 568 ; 569 ; 570typedef TInterpreter *CreateInterpreter_t(void* shlibHandle, const char* ar",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:34885,Integrability,interface,interface,34885,"defInfo_Size(TypedefInfo_t * /* tinfo */) const {return 0;}; 548 virtual const char *TypedefInfo_TrueName(TypedefInfo_t * /* tinfo */) const {return nullptr;}; 549 virtual const char *TypedefInfo_Name(TypedefInfo_t * /* tinfo */) const {return nullptr;}; 550 virtual const char *TypedefInfo_Title(TypedefInfo_t * /* tinfo */) const {return nullptr;}; 551 ; 552 // QualType Opaque Ptr interface; 553 virtual Bool_t IsSameType(const void * /* QualTypePtr1 */, const void * /* QualTypePtr2 */) const {return 0;}; 554 virtual Bool_t IsIntegerType(const void * /* QualTypePtr */) const {return 0;}; 555 virtual Bool_t IsSignedIntegerType(const void * /* QualTypePtr */) const {return 0;}; 556 virtual Bool_t IsUnsignedIntegerType(const void * /* QualTypePtr */) const {return 0;}; 557 virtual Bool_t IsFloatingType(const void * /* QualTypePtr */) const {return 0;}; 558 virtual Bool_t IsPointerType(const void * /* QualTypePtr */) const {return 0;}; 559 virtual Bool_t IsVoidPointerType(const void * /* QualTypePtr */) const {return 0;}; 560 ; 561 // FunctionDecl interface; 562 virtual Bool_t FunctionDeclId_IsMethod(DeclId_t /* fdeclid */) const {return 0;}; 563 ; 564 static TInterpreter *Instance();; 565 ; 566 ClassDefOverride(TInterpreter,0) //ABC defining interface to generic interpreter; 567};; 568 ; 569 ; 570typedef TInterpreter *CreateInterpreter_t(void* shlibHandle, const char* argv[]);; 571typedef void *DestroyInterpreter_t(TInterpreter*);; 572 ; 573#define gInterpreter (TInterpreter::Instance()); 574R__EXTERN TInterpreter* gCling;; 575 ; 576inline ROOT::Internal::InterpreterMutexRegistrationRAII::InterpreterMutexRegistrationRAII(TVirtualMutex* mutex):; 577 fLockGuard(mutex); 578{; 579 if (gCoreMutex); 580 ::gCling->SnapshotMutexState(gCoreMutex);; 581}; 582inline ROOT::Internal::InterpreterMutexRegistrationRAII::~InterpreterMutexRegistrationRAII(); 583{; 584 if (gCoreMutex); 585 ::gCling->ForgetMutexState();; 586}; 587 ; 588#endif; R__EXTERN#define R__EXTERNDefinition DllImport.",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:35084,Integrability,interface,interface,35084,"defInfo_Size(TypedefInfo_t * /* tinfo */) const {return 0;}; 548 virtual const char *TypedefInfo_TrueName(TypedefInfo_t * /* tinfo */) const {return nullptr;}; 549 virtual const char *TypedefInfo_Name(TypedefInfo_t * /* tinfo */) const {return nullptr;}; 550 virtual const char *TypedefInfo_Title(TypedefInfo_t * /* tinfo */) const {return nullptr;}; 551 ; 552 // QualType Opaque Ptr interface; 553 virtual Bool_t IsSameType(const void * /* QualTypePtr1 */, const void * /* QualTypePtr2 */) const {return 0;}; 554 virtual Bool_t IsIntegerType(const void * /* QualTypePtr */) const {return 0;}; 555 virtual Bool_t IsSignedIntegerType(const void * /* QualTypePtr */) const {return 0;}; 556 virtual Bool_t IsUnsignedIntegerType(const void * /* QualTypePtr */) const {return 0;}; 557 virtual Bool_t IsFloatingType(const void * /* QualTypePtr */) const {return 0;}; 558 virtual Bool_t IsPointerType(const void * /* QualTypePtr */) const {return 0;}; 559 virtual Bool_t IsVoidPointerType(const void * /* QualTypePtr */) const {return 0;}; 560 ; 561 // FunctionDecl interface; 562 virtual Bool_t FunctionDeclId_IsMethod(DeclId_t /* fdeclid */) const {return 0;}; 563 ; 564 static TInterpreter *Instance();; 565 ; 566 ClassDefOverride(TInterpreter,0) //ABC defining interface to generic interpreter; 567};; 568 ; 569 ; 570typedef TInterpreter *CreateInterpreter_t(void* shlibHandle, const char* argv[]);; 571typedef void *DestroyInterpreter_t(TInterpreter*);; 572 ; 573#define gInterpreter (TInterpreter::Instance()); 574R__EXTERN TInterpreter* gCling;; 575 ; 576inline ROOT::Internal::InterpreterMutexRegistrationRAII::InterpreterMutexRegistrationRAII(TVirtualMutex* mutex):; 577 fLockGuard(mutex); 578{; 579 if (gCoreMutex); 580 ::gCling->SnapshotMutexState(gCoreMutex);; 581}; 582inline ROOT::Internal::InterpreterMutexRegistrationRAII::~InterpreterMutexRegistrationRAII(); 583{; 584 if (gCoreMutex); 585 ::gCling->ForgetMutexState();; 586}; 587 ; 588#endif; R__EXTERN#define R__EXTERNDefinition DllImport.",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:41023,Integrability,interface,interface,41023,"n TInterpreter.h:120; TInterpreter::SuspendAutoLoadingRAII::~SuspendAutoLoadingRAII~SuspendAutoLoadingRAII()Definition TInterpreter.h:129; TInterpreter::SuspendAutoLoadingRAII::fOldValuebool fOldValueDefinition TInterpreter.h:122; TInterpreter::SuspendAutoLoadingRAII::fInterpTInterpreter * fInterpDefinition TInterpreter.h:121; TInterpreter::SuspendAutoLoadingRAII::SuspendAutoLoadingRAIISuspendAutoLoadingRAII(TInterpreter *interp)Definition TInterpreter.h:125; TInterpreter::SuspendAutoParsingDefinition TInterpreter.h:111; TInterpreter::SuspendAutoParsing::SuspendAutoParsingSuspendAutoParsing(TInterpreter *where, Bool_t value=kTRUE)Definition TInterpreter.h:115; TInterpreter::SuspendAutoParsing::fPreviousBool_t fPreviousDefinition TInterpreter.h:113; TInterpreter::SuspendAutoParsing::fInterpTInterpreter * fInterpDefinition TInterpreter.h:112; TInterpreter::SuspendAutoParsing::~SuspendAutoParsing~SuspendAutoParsing()Definition TInterpreter.h:116; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::TypedefInfo_Factoryvirtual TypedefInfo_t * TypedefInfo_Factory() constDefinition TInterpreter.h:540; TInterpreter::RegisterPrebuiltModulePathvirtual bool RegisterPrebuiltModulePath(const std::string &FullPath, const std::string &ModuleMapName=""module.modulemap"") const =0; TInterpreter::ToStringvirtual std::string ToString(const char *type, void *obj)=0; TInterpreter::MethodInfo_NArgvirtual int MethodInfo_NArg(MethodInfo_t *) constDefinition TInterpreter.h:494; TInterpreter::ClassInfo_HasMethodvirtual Bool_t ClassInfo_HasMethod(ClassInfo_t *, const char *) constDefinition TInterpreter.h:413; TInterpreter::MethodInfo_ExtraPropertyvirtual Long_t MethodInfo_ExtraProperty(MethodInfo_t *) const =0; TInterpreter::DataMemberInfo_FactoryCopyvirtual DataMemberInfo_t * DataMemberInfo_FactoryCopy(DataMemberInfo_t *) constDefinition TInterpreter.h:459; TInterpreter::ClassInfo_Deletevirtual void ClassInfo_De",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:80620,Integrability,interface,interface,80620," constDefinition TInterpreter.h:257; TInterpreter::Executevirtual void Execute(TObject *obj, TClass *cl, const char *method, const char *params, int *error=nullptr)=0; TInterpreter::TypeNamevirtual const char * TypeName(const char *s)=0; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TLockGuardDefinition TVirtualMutex.h:70; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStringBasic string class.Definition TString.h:139; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; double; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::gCoreMutexR__EXTERN TVirtualRWMutex * gCoreMutexDefinition TVirtualRWMutex.h:37; ROOT::EFunctionMatchModeEFunctionMatchModeDefinition TDictionary.h:161; ROOT::kConversionMatch@ kConversionMatchDefinition TDictionary.h:163; ROOT::Internal::InterpreterMutexRegistrationRAIIDefinition TInterpreter.h:52; ROOT::Internal::InterpreterMutexRegistrationRAII::fLockGuardTLockGuard fLockGuardDefinition TInterpreter.h:53; ROOT::Internal::InterpreterMutexRegistrationRAII::InterpreterMutexRegistrationRAIIInterpreterMutexRegistrationRAII(TVirtualMutex *mutex)Definition TInterpreter.h:576; ROOT::Internal::InterpreterMutexRegistrationRAII::~InterpreterMutexRegistrationRAII~InterpreterMutexRegistrationRAII()Def",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:39762,Modifiability,config,config,39762,"xx:110; TInterpreterValue.h; gInterpreterMutexR__EXTERN TVirtualMutex * gInterpreterMutexDefinition TInterpreter.h:46; CreateInterpreter_tTInterpreter * CreateInterpreter_t(void *shlibHandle, const char *argv[])Definition TInterpreter.h:570; gClingR__EXTERN TInterpreter * gClingDefinition TInterpreter.h:574; DestroyInterpreter_tvoid * DestroyInterpreter_t(TInterpreter *)Definition TInterpreter.h:571; TNamed.h; R__LOCKGUARD#define R__LOCKGUARD(mutex)Definition TVirtualMutex.h:95; TVirtualRWMutex.h; protoconst char * protoDefinition civetweb.c:17535; ROOT::TVirtualRWMutexDefinition TVirtualRWMutex.h:39; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TDictionary::EMemberSelectionEMemberSelectionKinds of members to include in lists.Definition TDictionary.h:216; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TEnumThe TEnum class implements the enum type.Definition TEnum.h:33; TEnvThe TEnv class reads config files, by default named .rootrc.Definition TEnv.h:124; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TInterpreterValueDefinition TInterpreterValue.h:32; TInterpreter::SuspendAutoLoadingRAIIDefinition TInterpreter.h:120; TInterpreter::SuspendAutoLoadingRAII::~SuspendAutoLoadingRAII~SuspendAutoLoadingRAII()Definition TInterpreter.h:129; TInterpreter::SuspendAutoLoadingRAII::fOldValuebool fOldValueDefinition TInterpreter.h:122; TInterpreter::SuspendAutoLoadingRAII::fInterpTInterpreter * fInterpDefinition TInterpreter.h:121; TInterpreter::SuspendAutoLoadingRAII::SuspendAutoLoadingRAIISuspendAutoLoadingRAII(TInterpreter *interp)Definition TInterpreter.h:125; TInterpreter::SuspendAutoParsingDefinition TInterpreter.h:111; TInterpreter::SuspendAutoParsing::SuspendAutoParsingSuspendAutoParsing(TInterpreter *where, Bool_t value=kTRUE)Definition TInterpreter.h:115; TInterpreter::SuspendAutoParsing::fPreviousBool_t fPreviousDefinition TI",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:4865,Performance,load,load,4865,"_t fGeneric;; 106 Ctor_t fCtor;; 107 Dtor_t fDtor;; 108 };; 109 };; 110 ; 111 class SuspendAutoParsing {; 112 TInterpreter *fInterp;; 113 Bool_t fPrevious;; 114 public:; 115 SuspendAutoParsing(TInterpreter *where, Bool_t value = kTRUE) : fInterp(where), fPrevious(fInterp->SetSuspendAutoParsing(value)) {}; 116 ~SuspendAutoParsing() { fInterp->SetSuspendAutoParsing(fPrevious); }; 117 };; 118 virtual Bool_t IsAutoParsingSuspended() const = 0;; 119 ; 120 class SuspendAutoLoadingRAII {; 121 TInterpreter *fInterp = nullptr;; 122 bool fOldValue;; 123 ; 124 public:; 125 SuspendAutoLoadingRAII(TInterpreter *interp) : fInterp(interp); 126 {; 127 fOldValue = fInterp->SetClassAutoLoading(false);; 128 }; 129 ~SuspendAutoLoadingRAII() { fInterp->SetClassAutoLoading(fOldValue); }; 130 };; 131 ; 132 typedef int (*AutoLoadCallBack_t)(const char*);; 133 typedef std::vector<std::pair<std::string, int> > FwdDeclArgsToKeepCollection_t;; 134 ; 135 TInterpreter() { } // for Dictionary; 136 TInterpreter(const char *name, const char *title = ""Generic Interpreter"");; 137 virtual ~TInterpreter() { }; 138 ; 139 virtual void AddIncludePath(const char *path) = 0;; 140 virtual void *SetAutoLoadCallBack(void* /*cb*/) { return nullptr; }; 141 virtual void *GetAutoLoadCallBack() const { return nullptr; }; 142 virtual Int_t AutoLoad(const char *classname, Bool_t knowDictNotLoaded = kFALSE) = 0;; 143 virtual Int_t AutoLoad(const std::type_info& typeinfo, Bool_t knowDictNotLoaded = kFALSE) = 0;; 144 virtual Int_t AutoParse(const char* cls) = 0;; 145 virtual void ClearFileBusy() = 0;; 146 virtual void ClearStack() = 0; // Delete existing temporary values; 147 virtual Bool_t Declare(const char* code) = 0;; 148 virtual void EndOfLineAction() = 0;; 149 virtual TClass *GetClass(const std::type_info& typeinfo, Bool_t load) const = 0;; 150 virtual Int_t GetExitCode() const = 0;; 151 virtual TEnv *GetMapfile() const { return nullptr; }; 152 ///\brief Returns whether the interpreter is waiting for more input, i.",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:48721,Performance,load,load,48721,"ing &, size_t &, std::vector< std::string > &)Definition TInterpreter.h:279; TInterpreter::TypedefInfo_IsValidvirtual Bool_t TypedefInfo_IsValid(TypedefInfo_t *) constDefinition TInterpreter.h:544; TInterpreter::AutoLoadvirtual Int_t AutoLoad(const std::type_info &typeinfo, Bool_t knowDictNotLoaded=kFALSE)=0; TInterpreter::TypeInfo_Namevirtual const char * TypeInfo_Name(TypeInfo_t *) constDefinition TInterpreter.h:530; TInterpreter::LoadMacrovirtual void LoadMacro(const char *filename, EErrorCode *error=nullptr)=0; TInterpreter::ClassInfo_Deletevirtual void ClassInfo_Delete(ClassInfo_t *) constDefinition TInterpreter.h:401; TInterpreter::CallFunc_SetArgumentsvoid CallFunc_SetArguments(CallFunc_t *func, const T &... args)Definition TInterpreter.h:380; TInterpreter::CallFunc_ExecWithReturnvirtual void CallFunc_ExecWithReturn(CallFunc_t *, void *, void *) constDefinition TInterpreter.h:317; TInterpreter::GetClassvirtual TClass * GetClass(const std::type_info &typeinfo, Bool_t load) const =0; TInterpreter::CallFunc_SetArgvoid CallFunc_SetArg(CallFunc_t *func, void *arg)Definition TInterpreter.h:351; TInterpreter::RegisterModulevirtual void RegisterModule(const char *, const char **, const char **, const char *, const char *, void(*)(), const FwdDeclArgsToKeepCollection_t &fwdDeclArgsToKeep, const char **classesHeaders, Bool_t lateRegistration=false, Bool_t hasCxxModule=false)=0; TInterpreter::CallFunc_SetArgvoid CallFunc_SetArg(CallFunc_t *func, Char_t param) constDefinition TInterpreter.h:340; TInterpreter::MethodArgInfo_DefaultValuevirtual const char * MethodArgInfo_DefaultValue(MethodArgInfo_t *) constDefinition TInterpreter.h:516; TInterpreter::DiagnoseIfInterpreterExceptionvirtual bool DiagnoseIfInterpreterException(const std::exception &e) const =0; TInterpreter::MethodCallReturnTypevirtual EReturnType MethodCallReturnType(TFunction *func) const =0; TInterpreter::CallFunc_ExecWithArgsAndReturnvirtual void CallFunc_ExecWithArgsAndReturn(CallFunc_t *, void *, const ",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:79898,Security,access,access,79898," *info) const =0; TInterpreter::FuncTempInfo_IsValidvirtual Bool_t FuncTempInfo_IsValid(FuncTempInfo_t *) const =0; TInterpreter::CallFunc_SetArgImplvoid CallFunc_SetArgImpl(CallFunc_t *func, const U &head)Definition TInterpreter.h:367; TInterpreter::BaseClassInfo_Propertyvirtual Long_t BaseClassInfo_Property(BaseClassInfo_t *) constDefinition TInterpreter.h:447; TInterpreter::CallFunc_ExecDoublevirtual Double_t CallFunc_ExecDouble(CallFunc_t *, void *) constDefinition TInterpreter.h:321; TInterpreter::CallFunc_SetArgvirtual void CallFunc_SetArg(CallFunc_t *, Long_t) const =0; TInterpreter::GetInterfaceMethodvirtual void * GetInterfaceMethod(TClass *cl, const char *method, const char *params, Bool_t objectIsConst=kFALSE)=0; TInterpreter::GetCurrentMacroNamevirtual const char * GetCurrentMacroName() constDefinition TInterpreter.h:257; TInterpreter::Executevirtual void Execute(TObject *obj, TClass *cl, const char *method, const char *params, int *error=nullptr)=0; TInterpreter::TypeNamevirtual const char * TypeName(const char *s)=0; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TLockGuardDefinition TVirtualMutex.h:70; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStringBasic string class.Definition TString.h:139; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; double; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOTtbb::task_arena is an alias of tbb::",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TInterpreter_8h_source.html:80065,Security,access,accessing,80065,"rtyvirtual Long_t BaseClassInfo_Property(BaseClassInfo_t *) constDefinition TInterpreter.h:447; TInterpreter::CallFunc_ExecDoublevirtual Double_t CallFunc_ExecDouble(CallFunc_t *, void *) constDefinition TInterpreter.h:321; TInterpreter::CallFunc_SetArgvirtual void CallFunc_SetArg(CallFunc_t *, Long_t) const =0; TInterpreter::GetInterfaceMethodvirtual void * GetInterfaceMethod(TClass *cl, const char *method, const char *params, Bool_t objectIsConst=kFALSE)=0; TInterpreter::GetCurrentMacroNamevirtual const char * GetCurrentMacroName() constDefinition TInterpreter.h:257; TInterpreter::Executevirtual void Execute(TObject *obj, TClass *cl, const char *method, const char *params, int *error=nullptr)=0; TInterpreter::TypeNamevirtual const char * TypeName(const char *s)=0; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TLockGuardDefinition TVirtualMutex.h:70; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStringBasic string class.Definition TString.h:139; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; double; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::gCoreMutexR__EXTERN TVirtualRWMutex * gCoreMutexDefinition TVirtualRWMutex.h:37; ROOT::EFunctionMatchModeEFunctionMatchModeDefinition TDictionary.h:161; ROOT::kC",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
https://root.cern/doc/master/TIOFeatures_8hxx_source.html:3386,Energy Efficiency,efficient,efficient,3386,"features in this enum.; 63};; 64 ; 65 ; 66} // namespace Experimental; 67 ; 68 ; 69class TIOFeatures {; 70friend class ::TTree;; 71friend class ::TBranch;; 72friend class ::TBasket;; 73 ; 74public:; 75 TIOFeatures() {}; 76 ; 77 void Clear(EIOFeatures bits);; 78 void Clear(Experimental::EIOUnsupportedFeatures bits);; 79 void Clear(Experimental::EIOFeatures bits);; 80 bool Set(EIOFeatures bits);; 81 bool Set(Experimental::EIOFeatures bits);; 82 bool Set(const std::string &);; 83 bool Test(EIOFeatures bits) const;; 84 bool Test(Experimental::EIOFeatures bits) const;; 85 bool Test(Experimental::EIOUnsupportedFeatures bits) const;; 86 void Print() const;; 87 ; 88 // The number of known, defined IO features (supported / unsupported / experimental).; 89 static constexpr int kIOFeatureCount = 1;; 90 ; 91private:; 92 // These methods allow access to the raw bitset underlying; 93 // this object, breaking type safety. They are necessary for; 94 // efficient interaction with TTree / TBranch / TBasket, but left; 95 // private to prevent users from interacting with the raw bits.; 96 TIOFeatures(UChar_t IOBits) : fIOBits(IOBits) {}; 97 UChar_t GetFeatures() const;; 98 void Set(UChar_t newBits) {fIOBits = newBits;}; 99 ; 100 UChar_t fIOBits{0};; 101};; 102 ; 103} // namespace ROOT; 104 ; 105#endif // ROOT_TIO_FEATURES; UChar_tunsigned char UChar_tDefinition RtypesCore.h:38; Rtypes.h; BIT#define BIT(n)Definition Rtypes.h:90; ROOT::TIOFeaturesTIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TT...Definition TIOFeatures.hxx:69; ROOT::TIOFeatures::GetFeaturesUChar_t GetFeatures() constDefinition TIOFeatures.cxx:250; ROOT::TIOFeatures::TIOFeaturesTIOFeatures(UChar_t IOBits)Definition TIOFeatures.hxx:96; ROOT::TIOFeatures::Testbool Test(Experimental::EIOUnsupportedFeatures bits) const; ROOT::TIOFeatures::Printvoid Print() constPrint a human-readable representation of the TIOFeatures to stdout.Definition TIOFeatures.cxx:197; ROOT::TIOFeature",MatchSource.WIKI,doc/master/TIOFeatures_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TIOFeatures_8hxx_source.html
https://root.cern/doc/master/TIOFeatures_8hxx_source.html:3348,Safety,safe,safety,3348,"re is never an IO feature that goes into the ROOT:: namespace; 60// but is unsupported.; 61enum class EIOUnsupportedFeatures {; 62 kUnsupported = 0 // Union of all features in this enum.; 63};; 64 ; 65 ; 66} // namespace Experimental; 67 ; 68 ; 69class TIOFeatures {; 70friend class ::TTree;; 71friend class ::TBranch;; 72friend class ::TBasket;; 73 ; 74public:; 75 TIOFeatures() {}; 76 ; 77 void Clear(EIOFeatures bits);; 78 void Clear(Experimental::EIOUnsupportedFeatures bits);; 79 void Clear(Experimental::EIOFeatures bits);; 80 bool Set(EIOFeatures bits);; 81 bool Set(Experimental::EIOFeatures bits);; 82 bool Set(const std::string &);; 83 bool Test(EIOFeatures bits) const;; 84 bool Test(Experimental::EIOFeatures bits) const;; 85 bool Test(Experimental::EIOUnsupportedFeatures bits) const;; 86 void Print() const;; 87 ; 88 // The number of known, defined IO features (supported / unsupported / experimental).; 89 static constexpr int kIOFeatureCount = 1;; 90 ; 91private:; 92 // These methods allow access to the raw bitset underlying; 93 // this object, breaking type safety. They are necessary for; 94 // efficient interaction with TTree / TBranch / TBasket, but left; 95 // private to prevent users from interacting with the raw bits.; 96 TIOFeatures(UChar_t IOBits) : fIOBits(IOBits) {}; 97 UChar_t GetFeatures() const;; 98 void Set(UChar_t newBits) {fIOBits = newBits;}; 99 ; 100 UChar_t fIOBits{0};; 101};; 102 ; 103} // namespace ROOT; 104 ; 105#endif // ROOT_TIO_FEATURES; UChar_tunsigned char UChar_tDefinition RtypesCore.h:38; Rtypes.h; BIT#define BIT(n)Definition Rtypes.h:90; ROOT::TIOFeaturesTIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TT...Definition TIOFeatures.hxx:69; ROOT::TIOFeatures::GetFeaturesUChar_t GetFeatures() constDefinition TIOFeatures.cxx:250; ROOT::TIOFeatures::TIOFeaturesTIOFeatures(UChar_t IOBits)Definition TIOFeatures.hxx:96; ROOT::TIOFeatures::Testbool Test(Experimental::EIOUnsupportedFeatures bits)",MatchSource.WIKI,doc/master/TIOFeatures_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TIOFeatures_8hxx_source.html
https://root.cern/doc/master/TIOFeatures_8hxx_source.html:3278,Security,access,access,3278,"re is never an IO feature that goes into the ROOT:: namespace; 60// but is unsupported.; 61enum class EIOUnsupportedFeatures {; 62 kUnsupported = 0 // Union of all features in this enum.; 63};; 64 ; 65 ; 66} // namespace Experimental; 67 ; 68 ; 69class TIOFeatures {; 70friend class ::TTree;; 71friend class ::TBranch;; 72friend class ::TBasket;; 73 ; 74public:; 75 TIOFeatures() {}; 76 ; 77 void Clear(EIOFeatures bits);; 78 void Clear(Experimental::EIOUnsupportedFeatures bits);; 79 void Clear(Experimental::EIOFeatures bits);; 80 bool Set(EIOFeatures bits);; 81 bool Set(Experimental::EIOFeatures bits);; 82 bool Set(const std::string &);; 83 bool Test(EIOFeatures bits) const;; 84 bool Test(Experimental::EIOFeatures bits) const;; 85 bool Test(Experimental::EIOUnsupportedFeatures bits) const;; 86 void Print() const;; 87 ; 88 // The number of known, defined IO features (supported / unsupported / experimental).; 89 static constexpr int kIOFeatureCount = 1;; 90 ; 91private:; 92 // These methods allow access to the raw bitset underlying; 93 // this object, breaking type safety. They are necessary for; 94 // efficient interaction with TTree / TBranch / TBasket, but left; 95 // private to prevent users from interacting with the raw bits.; 96 TIOFeatures(UChar_t IOBits) : fIOBits(IOBits) {}; 97 UChar_t GetFeatures() const;; 98 void Set(UChar_t newBits) {fIOBits = newBits;}; 99 ; 100 UChar_t fIOBits{0};; 101};; 102 ; 103} // namespace ROOT; 104 ; 105#endif // ROOT_TIO_FEATURES; UChar_tunsigned char UChar_tDefinition RtypesCore.h:38; Rtypes.h; BIT#define BIT(n)Definition Rtypes.h:90; ROOT::TIOFeaturesTIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TT...Definition TIOFeatures.hxx:69; ROOT::TIOFeatures::GetFeaturesUChar_t GetFeatures() constDefinition TIOFeatures.cxx:250; ROOT::TIOFeatures::TIOFeaturesTIOFeatures(UChar_t IOBits)Definition TIOFeatures.hxx:96; ROOT::TIOFeatures::Testbool Test(Experimental::EIOUnsupportedFeatures bits)",MatchSource.WIKI,doc/master/TIOFeatures_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TIOFeatures_8hxx_source.html
https://root.cern/doc/master/TIterator_8h_source.html:863,Integrability,interface,interface,863,". ROOT: core/cont/inc/TIterator.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TIterator.h. Go to the documentation of this file. 1// @(#)root/cont:$Id$; 2// Author: Fons Rademakers 13/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TIterator; 13#define ROOT_TIterator; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TIterator //; 19// //; 20// Iterator abstract base class. This base class provides the interface //; 21// for collection iterators. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""Rtypes.h""; 26 ; 27class TCollection;; 28class TObject;; 29 ; 30class TIterator {; 31 ; 32protected:; 33 TIterator() { }; 34 TIterator(const TIterator &) { }; 35 ; 36public:; 37 virtual TIterator &operator=(const TIterator &) = 0;; 38 virtual ~TIterator() { }; 39 virtual const TCollection *GetCollection() const = 0;; 40 virtual Option_t *GetOption() const { return """"; }; 41 virtual TObject *Next() = 0;; 42 virtual void Reset() = 0;; 43 TObject *operator()() { return Next(); }; 44 virtual Bool_t operator!=(const TIterator &) const;; 45 Bool_t operator==(const TIterator & other) const { return !(*this != other); }; 46 virtual TObject *operator*() const;; 47 ; 48 ClassDef(TIterator,0) //Iterator abstract base class; 49};; 50 ; 51#endif; Bool_tbool Bool_tDefinition RtypesCore.h:63; Option_tconst char Option_tDefinition RtypesCore.h:66; Rtypes.h; ClassDef#define ClassDef(name, id)Definition Rtypes.h:342; TCollectionCollection abstract base class.Definition TCollection.h:65; TI",MatchSource.WIKI,doc/master/TIterator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TIterator_8h_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:1491,Availability,redundant,redundant,1491,"; 10 *************************************************************************/; 11 ; 12/**; 13\class TKey; 14\ingroup IO; 15 ; 16 Book space in a file, create I/O buffers, to fill them, (un)compress them.; 17 ; 18 The TKey class includes functions to book space in a file, to create I/O; 19 buffers, to fill these buffers, to compress/uncompress data buffers.; 20 Before saving (making persistent) an object in a file, a key must; 21 be created. The key structure contains all the information to; 22 uniquely identify a persistent object in a file.; 23 | Data Member | Explanation |; 24 |-------------|-------------|; 25 | fNbytes | Number of bytes for the compressed object and key. |; 26 | fObjlen | Length of uncompressed object. |; 27 | fDatime | Date/Time when the object was written. |; 28 | fKeylen | Number of bytes for the key structure. |; 29 | fCycle | Cycle number of the object. |; 30 | fSeekKey | Address of the object on file (points to fNbytes). This is a redundant information used to cross-check the data base integrity. |; 31 | fSeekPdir | Pointer to the directory supporting this object.|; 32 | fClassName | Object class name. |; 33 | fName | Name of the object. |; 34 | fTitle | Title of the object. |; 35 ; 36 In the 16 highest bits of fSeekPdir is encoded a pid offset. This; 37 offset is to be added to the pid index stored in the TRef object; 38 and the referenced TObject.; 39 ; 40 The TKey class is used by ROOT to:; 41 - Write an object in the current directory; 42 - Write a new ntuple buffer; 43 ; 44 The structure of a file is shown in TFile::TFile.; 45 The structure of a directory is shown in TDirectoryFile::TDirectoryFile.; 46 The TKey class is used by the TBasket class.; 47 See also TTree.; 48*/; 49 ; 50#include <atomic>; 51#include <iostream>; 52 ; 53#include ""TROOT.h""; 54#include ""TClass.h""; 55#include ""TDirectoryFile.h""; 56#include ""TFile.h""; 57#include ""TKey.h""; 58#include ""TBufferFile.h""; 59#include ""TFree.h""; 60#include ""TBrowser.h""; 61#include ""Bytes.",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:49449,Availability,recover,recover,49449,"Offset needs to be increment if the key/basket is copied; 1378 // and need to be zero for new key/basket.; 1379 Long64_t pdir;; 1380 b >> pdir;; 1381 fPidOffset = pdir >> kPidOffsetShift;; 1382 fSeekPdir = pdir & kPidOffsetMask;; 1383 } else {; 1384 UInt_t seekkey, seekdir;; 1385 b >> seekkey; fSeekKey = (Long64_t)seekkey;; 1386 b >> seekdir; fSeekPdir= (Long64_t)seekdir;; 1387 }; 1388 fClassName.Streamer(b);; 1389 //the following test required for forward and backward compatibility; 1390 if (fClassName == ""TDirectory"") {; 1391 fClassName = ""TDirectoryFile"";; 1392 SetBit(kIsDirectoryFile);; 1393 }; 1394 fName.Streamer(b);; 1395 fTitle.Streamer(b);; 1396 if (fKeylen < 0) {; 1397 Error(""Streamer"",""The value of fKeylen is incorrect (%d) ; trying to recover by setting it to zero"",fKeylen);; 1398 MakeZombie();; 1399 fKeylen = 0;; 1400 }; 1401 if (fObjlen < 0) {; 1402 Error(""Streamer"",""The value of fObjlen is incorrect (%d) ; trying to recover by setting it to zero"",fObjlen);; 1403 MakeZombie();; 1404 fObjlen = 0;; 1405 }; 1406 if (fNbytes < 0) {; 1407 Error(""Streamer"",""The value of fNbytes is incorrect (%d) ; trying to recover by setting it to zero"",fNbytes);; 1408 MakeZombie();; 1409 fNbytes = 0;; 1410 }; 1411 ; 1412 } else {; 1413 b << fNbytes;; 1414 version = (Version_t)fVersion;; 1415 b << version;; 1416 b << fObjlen;; 1417 if (fDatime.Get() == 0) fDatime.Set();; 1418 if (TestBit(TKey::kReproducible)); 1419 TDatime((UInt_t) 1).Streamer(b);; 1420 else; 1421 fDatime.Streamer(b);; 1422 b << fKeylen;; 1423 b << fCycle;; 1424 if (fVersion > 1000) {; 1425 b << fSeekKey;; 1426 ; 1427 // We currently store in the 16 highest bit of fSeekPdir the value of; 1428 // fPidOffset. This offset is used when a key (or basket) is transfered from one; 1429 // file to the other. In this case the TRef and TObject might have stored a; 1430 // pid index (to retrieve TProcessIDs) which refered to their order on the original; 1431 // file, the fPidOffset is to be added to those values to corr",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:49637,Availability,recover,recover,49637,"Offset needs to be increment if the key/basket is copied; 1378 // and need to be zero for new key/basket.; 1379 Long64_t pdir;; 1380 b >> pdir;; 1381 fPidOffset = pdir >> kPidOffsetShift;; 1382 fSeekPdir = pdir & kPidOffsetMask;; 1383 } else {; 1384 UInt_t seekkey, seekdir;; 1385 b >> seekkey; fSeekKey = (Long64_t)seekkey;; 1386 b >> seekdir; fSeekPdir= (Long64_t)seekdir;; 1387 }; 1388 fClassName.Streamer(b);; 1389 //the following test required for forward and backward compatibility; 1390 if (fClassName == ""TDirectory"") {; 1391 fClassName = ""TDirectoryFile"";; 1392 SetBit(kIsDirectoryFile);; 1393 }; 1394 fName.Streamer(b);; 1395 fTitle.Streamer(b);; 1396 if (fKeylen < 0) {; 1397 Error(""Streamer"",""The value of fKeylen is incorrect (%d) ; trying to recover by setting it to zero"",fKeylen);; 1398 MakeZombie();; 1399 fKeylen = 0;; 1400 }; 1401 if (fObjlen < 0) {; 1402 Error(""Streamer"",""The value of fObjlen is incorrect (%d) ; trying to recover by setting it to zero"",fObjlen);; 1403 MakeZombie();; 1404 fObjlen = 0;; 1405 }; 1406 if (fNbytes < 0) {; 1407 Error(""Streamer"",""The value of fNbytes is incorrect (%d) ; trying to recover by setting it to zero"",fNbytes);; 1408 MakeZombie();; 1409 fNbytes = 0;; 1410 }; 1411 ; 1412 } else {; 1413 b << fNbytes;; 1414 version = (Version_t)fVersion;; 1415 b << version;; 1416 b << fObjlen;; 1417 if (fDatime.Get() == 0) fDatime.Set();; 1418 if (TestBit(TKey::kReproducible)); 1419 TDatime((UInt_t) 1).Streamer(b);; 1420 else; 1421 fDatime.Streamer(b);; 1422 b << fKeylen;; 1423 b << fCycle;; 1424 if (fVersion > 1000) {; 1425 b << fSeekKey;; 1426 ; 1427 // We currently store in the 16 highest bit of fSeekPdir the value of; 1428 // fPidOffset. This offset is used when a key (or basket) is transfered from one; 1429 // file to the other. In this case the TRef and TObject might have stored a; 1430 // pid index (to retrieve TProcessIDs) which refered to their order on the original; 1431 // file, the fPidOffset is to be added to those values to corr",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:49825,Availability,recover,recover,49825,"Offset needs to be increment if the key/basket is copied; 1378 // and need to be zero for new key/basket.; 1379 Long64_t pdir;; 1380 b >> pdir;; 1381 fPidOffset = pdir >> kPidOffsetShift;; 1382 fSeekPdir = pdir & kPidOffsetMask;; 1383 } else {; 1384 UInt_t seekkey, seekdir;; 1385 b >> seekkey; fSeekKey = (Long64_t)seekkey;; 1386 b >> seekdir; fSeekPdir= (Long64_t)seekdir;; 1387 }; 1388 fClassName.Streamer(b);; 1389 //the following test required for forward and backward compatibility; 1390 if (fClassName == ""TDirectory"") {; 1391 fClassName = ""TDirectoryFile"";; 1392 SetBit(kIsDirectoryFile);; 1393 }; 1394 fName.Streamer(b);; 1395 fTitle.Streamer(b);; 1396 if (fKeylen < 0) {; 1397 Error(""Streamer"",""The value of fKeylen is incorrect (%d) ; trying to recover by setting it to zero"",fKeylen);; 1398 MakeZombie();; 1399 fKeylen = 0;; 1400 }; 1401 if (fObjlen < 0) {; 1402 Error(""Streamer"",""The value of fObjlen is incorrect (%d) ; trying to recover by setting it to zero"",fObjlen);; 1403 MakeZombie();; 1404 fObjlen = 0;; 1405 }; 1406 if (fNbytes < 0) {; 1407 Error(""Streamer"",""The value of fNbytes is incorrect (%d) ; trying to recover by setting it to zero"",fNbytes);; 1408 MakeZombie();; 1409 fNbytes = 0;; 1410 }; 1411 ; 1412 } else {; 1413 b << fNbytes;; 1414 version = (Version_t)fVersion;; 1415 b << version;; 1416 b << fObjlen;; 1417 if (fDatime.Get() == 0) fDatime.Set();; 1418 if (TestBit(TKey::kReproducible)); 1419 TDatime((UInt_t) 1).Streamer(b);; 1420 else; 1421 fDatime.Streamer(b);; 1422 b << fKeylen;; 1423 b << fCycle;; 1424 if (fVersion > 1000) {; 1425 b << fSeekKey;; 1426 ; 1427 // We currently store in the 16 highest bit of fSeekPdir the value of; 1428 // fPidOffset. This offset is used when a key (or basket) is transfered from one; 1429 // file to the other. In this case the TRef and TObject might have stored a; 1430 // pid index (to retrieve TProcessIDs) which refered to their order on the original; 1431 // file, the fPidOffset is to be added to those values to corr",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:51602,Availability,error,error,51602,"original; 1431 // file, the fPidOffset is to be added to those values to correctly find the; 1432 // TProcessID. This fPidOffset needs to be increment if the key/basket is copied; 1433 // and need to be zero for new key/basket.; 1434 Long64_t pdir = (((Long64_t)fPidOffset)<<kPidOffsetShift) | (kPidOffsetMask & fSeekPdir);; 1435 b << pdir;; 1436 } else {; 1437 b << (Int_t)fSeekKey;; 1438 b << (Int_t)fSeekPdir;; 1439 }; 1440 if (TestBit(kIsDirectoryFile)) {; 1441 // We want to record ""TDirectory"" instead of TDirectoryFile so that the file can be read by ancient version of ROOT.; 1442 b.WriteTString(gTDirectoryString);; 1443 } else {; 1444 fClassName.Streamer(b);; 1445 }; 1446 fName.Streamer(b);; 1447 fTitle.Streamer(b);; 1448 }; 1449}; 1450 ; 1451////////////////////////////////////////////////////////////////////////////////; 1452/// Write the encoded object supported by this key.; 1453/// The function returns the number of bytes committed to the file.; 1454/// If a write error occurs, the number of bytes returned is -1.; 1455 ; 1456Int_t TKey::WriteFile(Int_t cycle, TFile* f); 1457{; 1458 if (!f) f = GetFile();; 1459 if (!f) return -1;; 1460 ; 1461 Int_t nsize = fNbytes;; 1462 char *buffer = fBuffer;; 1463 if (cycle) {; 1464 fCycle = cycle;; 1465 FillBuffer(buffer);; 1466 buffer = fBuffer;; 1467 }; 1468 ; 1469 if (fLeft > 0) nsize += sizeof(Int_t);; 1470 f->Seek(fSeekKey);; 1471 Bool_t result = f->WriteBuffer(buffer,nsize);; 1472 //f->Flush(); Flushing takes too much time.; 1473 // Let user flush the file when they want.; 1474 if (gDebug) {; 1475 std::cout <<"" TKey Writing ""<<nsize<< "" bytes at address ""<<fSeekKey; 1476 <<"" for ID= "" <<GetName()<<"" Title= ""<<GetTitle()<<std::endl;; 1477 }; 1478 ; 1479 DeleteBuffer();; 1480 return result==kTRUE ? -1 : nsize;; 1481}; 1482 ; 1483////////////////////////////////////////////////////////////////////////////////; 1484/// Write the encoded object supported by this key.; 1485/// The function returns the number of bytes commi",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:52654,Availability,error,error,52654,"t TKey::WriteFile(Int_t cycle, TFile* f); 1457{; 1458 if (!f) f = GetFile();; 1459 if (!f) return -1;; 1460 ; 1461 Int_t nsize = fNbytes;; 1462 char *buffer = fBuffer;; 1463 if (cycle) {; 1464 fCycle = cycle;; 1465 FillBuffer(buffer);; 1466 buffer = fBuffer;; 1467 }; 1468 ; 1469 if (fLeft > 0) nsize += sizeof(Int_t);; 1470 f->Seek(fSeekKey);; 1471 Bool_t result = f->WriteBuffer(buffer,nsize);; 1472 //f->Flush(); Flushing takes too much time.; 1473 // Let user flush the file when they want.; 1474 if (gDebug) {; 1475 std::cout <<"" TKey Writing ""<<nsize<< "" bytes at address ""<<fSeekKey; 1476 <<"" for ID= "" <<GetName()<<"" Title= ""<<GetTitle()<<std::endl;; 1477 }; 1478 ; 1479 DeleteBuffer();; 1480 return result==kTRUE ? -1 : nsize;; 1481}; 1482 ; 1483////////////////////////////////////////////////////////////////////////////////; 1484/// Write the encoded object supported by this key.; 1485/// The function returns the number of bytes committed to the file.; 1486/// If a write error occurs, the number of bytes returned is -1.; 1487 ; 1488Int_t TKey::WriteFileKeepBuffer(TFile *f); 1489{; 1490 if (!f) f = GetFile();; 1491 if (!f) return -1;; 1492 ; 1493 Int_t nsize = fNbytes;; 1494 char *buffer = fBuffer;; 1495 ; 1496 if (fLeft > 0) nsize += sizeof(Int_t);; 1497 f->Seek(fSeekKey);; 1498 Bool_t result = f->WriteBuffer(buffer,nsize);; 1499 //f->Flush(); Flushing takes too much time.; 1500 // Let user flush the file when they want.; 1501 if (gDebug) {; 1502 std::cout <<"" TKey Writing ""<<nsize<< "" bytes at address ""<<fSeekKey; 1503 <<"" for ID= "" <<GetName()<<"" Title= ""<<GetTitle()<<std::endl;; 1504 }; 1505 ; 1506 return result==kTRUE ? -1 : nsize;; 1507}; 1508 ; 1509////////////////////////////////////////////////////////////////////////////////; 1510/// Title can keep 32x32 xpm thumbnail/icon of the parent object.; 1511 ; 1512const char *TKey::GetIconName() const; 1513{; 1514 return (!fTitle.IsNull() && fTitle.BeginsWith(""/* "") ? fTitle.Data() : 0);; 1515}; 1516 ; 1517////////",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:55231,Availability,error,error,55231,"r *&buf, Bool_t *x)Definition Bytes.h:278; tobufvoid tobuf(char *&buf, Bool_t x)Definition Bytes.h:55; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; UShort_tunsigned short UShort_tDefinition RtypesCore.h:40; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; UChar_tunsigned char UChar_tDefinition RtypesCore.h:38; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Short_tshort Short_tDefinition RtypesCore.h:39; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBrowser.h; TBufferFile.h; TClass.h; TDirectoryFile.h; gDirectory#define gDirectoryDefinition TDirectory.h:384; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; TFile.h; gFile#define gFileDefinition TFile.h:347; TFree.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; offsetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h offsetDefinition TGWin32VirtualXProxy.cxx:245; resultOption_t Option_t TPoint TPoint const cha",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:71239,Availability,error,error,71239,"finition TObject.cxx:894; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::UseCurrentStylevirtual void UseCurrentStyle()Set current style settings in this object This function is called when either TCanvas::UseCurrentStyl...Definition TObject.cxx:807; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Classstatic TClass * Class(); TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Resizevoid Resize(Ssiz_t n)Resize the string. Truncate or add blanks as necessary.Definition TString.cxx:1152; TString::BeginsWithBool_t BeginsWith(c",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:71375,Availability,error,error,71375,"efinition TObject.cxx:213; TObject::UseCurrentStylevirtual void UseCurrentStyle()Set current style settings in this object This function is called when either TCanvas::UseCurrentStyl...Definition TObject.cxx:807; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Classstatic TClass * Class(); TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Resizevoid Resize(Ssiz_t n)Resize the string. Truncate or add blanks as necessary.Definition TString.cxx:1152; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare cmp=kExact) constDefinition TString.h:623; TString::IsNullBool_t IsNull() constDefinition TString.h:414; T",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:19293,Deployability,update,updates,19293,"ze+sizeof(Int_t)];; 513 }; 514 char *buffer = fBuffer+nsize;; 515 Int_t nbytesleft = -fLeft; // set header of remaining record; 516 tobuf(buffer, nbytesleft);; 517 bestfree->SetFirst(fSeekKey+nsize);; 518 }; 519 ; 520 fSeekPdir = externFile ? externFile->GetSeekDir() : fMotherDir->GetSeekDir();; 521}; 522 ; 523////////////////////////////////////////////////////////////////////////////////; 524/// TKey default destructor.; 525 ; 526TKey::~TKey(); 527{; 528 if (fMotherDir && fMotherDir->GetListOfKeys()); 529 fMotherDir->GetListOfKeys()->Remove(this);; 530 TKey::DeleteBuffer();; 531}; 532 ; 533////////////////////////////////////////////////////////////////////////////////; 534/// Delete an object from the file.; 535///; 536/// Note: the key is not deleted. You still have to call ""delete key"".; 537/// This is different from the behaviour of TObject::Delete()!; 538 ; 539void TKey::Delete(Option_t *option); 540{; 541 if (TestBit(kIsDirectoryFile)) {; 542 // TDirectoryFile assumes that its location on file never change (for example updates are partial); 543 // and never checks if the space might have been released and thus over-write any data that might; 544 // have been written there.; 545 if (option && option[0] == 'v'); 546 printf(""Rejected attempt to delete TDirectoryFile key: %s at address %lld, nbytes = %d\n"",; 547 GetName(), fSeekKey, fNbytes);; 548 return;; 549 }; 550 if (option && option[0] == 'v') printf(""Deleting key: %s at address %lld, nbytes = %d\n"",GetName(),fSeekKey,fNbytes);; 551 Long64_t first = fSeekKey;; 552 Long64_t last = fSeekKey + fNbytes -1;; 553 if (GetFile()) GetFile()->MakeFree(first, last); // release space used by this key; 554 fMotherDir->GetListOfKeys()->Remove(this);; 555}; 556 ; 557////////////////////////////////////////////////////////////////////////////////; 558/// Delete key buffer(s).; 559 ; 560void TKey::DeleteBuffer(); 561{; 562 if (fBufferRef) {; 563 delete fBufferRef;; 564 fBufferRef = 0;; 565 } else {; 566 // We only need to de",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:19368,Deployability,release,released,19368,"ze+sizeof(Int_t)];; 513 }; 514 char *buffer = fBuffer+nsize;; 515 Int_t nbytesleft = -fLeft; // set header of remaining record; 516 tobuf(buffer, nbytesleft);; 517 bestfree->SetFirst(fSeekKey+nsize);; 518 }; 519 ; 520 fSeekPdir = externFile ? externFile->GetSeekDir() : fMotherDir->GetSeekDir();; 521}; 522 ; 523////////////////////////////////////////////////////////////////////////////////; 524/// TKey default destructor.; 525 ; 526TKey::~TKey(); 527{; 528 if (fMotherDir && fMotherDir->GetListOfKeys()); 529 fMotherDir->GetListOfKeys()->Remove(this);; 530 TKey::DeleteBuffer();; 531}; 532 ; 533////////////////////////////////////////////////////////////////////////////////; 534/// Delete an object from the file.; 535///; 536/// Note: the key is not deleted. You still have to call ""delete key"".; 537/// This is different from the behaviour of TObject::Delete()!; 538 ; 539void TKey::Delete(Option_t *option); 540{; 541 if (TestBit(kIsDirectoryFile)) {; 542 // TDirectoryFile assumes that its location on file never change (for example updates are partial); 543 // and never checks if the space might have been released and thus over-write any data that might; 544 // have been written there.; 545 if (option && option[0] == 'v'); 546 printf(""Rejected attempt to delete TDirectoryFile key: %s at address %lld, nbytes = %d\n"",; 547 GetName(), fSeekKey, fNbytes);; 548 return;; 549 }; 550 if (option && option[0] == 'v') printf(""Deleting key: %s at address %lld, nbytes = %d\n"",GetName(),fSeekKey,fNbytes);; 551 Long64_t first = fSeekKey;; 552 Long64_t last = fSeekKey + fNbytes -1;; 553 if (GetFile()) GetFile()->MakeFree(first, last); // release space used by this key; 554 fMotherDir->GetListOfKeys()->Remove(this);; 555}; 556 ; 557////////////////////////////////////////////////////////////////////////////////; 558/// Delete key buffer(s).; 559 ; 560void TKey::DeleteBuffer(); 561{; 562 if (fBufferRef) {; 563 delete fBufferRef;; 564 fBufferRef = 0;; 565 } else {; 566 // We only need to de",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:19895,Deployability,release,release,19895,">GetListOfKeys()->Remove(this);; 530 TKey::DeleteBuffer();; 531}; 532 ; 533////////////////////////////////////////////////////////////////////////////////; 534/// Delete an object from the file.; 535///; 536/// Note: the key is not deleted. You still have to call ""delete key"".; 537/// This is different from the behaviour of TObject::Delete()!; 538 ; 539void TKey::Delete(Option_t *option); 540{; 541 if (TestBit(kIsDirectoryFile)) {; 542 // TDirectoryFile assumes that its location on file never change (for example updates are partial); 543 // and never checks if the space might have been released and thus over-write any data that might; 544 // have been written there.; 545 if (option && option[0] == 'v'); 546 printf(""Rejected attempt to delete TDirectoryFile key: %s at address %lld, nbytes = %d\n"",; 547 GetName(), fSeekKey, fNbytes);; 548 return;; 549 }; 550 if (option && option[0] == 'v') printf(""Deleting key: %s at address %lld, nbytes = %d\n"",GetName(),fSeekKey,fNbytes);; 551 Long64_t first = fSeekKey;; 552 Long64_t last = fSeekKey + fNbytes -1;; 553 if (GetFile()) GetFile()->MakeFree(first, last); // release space used by this key; 554 fMotherDir->GetListOfKeys()->Remove(this);; 555}; 556 ; 557////////////////////////////////////////////////////////////////////////////////; 558/// Delete key buffer(s).; 559 ; 560void TKey::DeleteBuffer(); 561{; 562 if (fBufferRef) {; 563 delete fBufferRef;; 564 fBufferRef = 0;; 565 } else {; 566 // We only need to delete fBuffer if fBufferRef is zero because; 567 // if fBufferRef exists, we delegate ownership of fBuffer to fBufferRef.; 568 if (fBuffer) {; 569 delete [] fBuffer;; 570 }; 571 }; 572 fBuffer = 0;; 573}; 574 ; 575////////////////////////////////////////////////////////////////////////////////; 576/// Return cycle number associated to this key.; 577 ; 578Short_t TKey::GetCycle() const; 579{; 580 return ((fCycle >0) ? fCycle : -fCycle);; 581}; 582 ; 583/////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:16489,Energy Efficiency,allocate,allocated,16489,"he key references a; 425/// folder in which case we don't want to re-read the folder object; 426/// since it might contain new objects not yet saved.; 427 ; 428void TKey::Browse(TBrowser *b); 429{; 430 if (fMotherDir==0) return;; 431 ; 432 TClass *objcl = TClass::GetClass(GetClassName());; 433 ; 434 void* obj = fMotherDir->GetList()->FindObject(GetName());; 435 if (obj && objcl->IsTObject()) {; 436 TObject *tobj = (TObject*) objcl->DynamicCast(TObject::Class(), obj);; 437 if (!tobj->IsFolder()) {; 438 if (tobj->InheritsFrom(TCollection::Class())); 439 tobj->Delete(); // delete also collection elements; 440 delete tobj;; 441 obj = 0;; 442 }; 443 }; 444 ; 445 if (!obj); 446 obj = ReadObj();; 447 ; 448 if (b && obj) {; 449 objcl->Browse(obj,b);; 450 b->SetRefreshFlag(kTRUE);; 451 }; 452}; 453 ; 454////////////////////////////////////////////////////////////////////////////////; 455/// Create a TKey object of specified size.; 456///; 457/// If externFile!=0, key will be allocated in specified file, otherwise file; 458/// of mother directory will be used.; 459 ; 460void TKey::Create(Int_t nbytes, TFile* externFile); 461{; 462 keyAbsNumber++; SetUniqueID(keyAbsNumber);; 463 ; 464 TFile *f = externFile;; 465 if (!f) f = GetFile();; 466 if (!f) {; 467 Error(""Create"",""Cannot create key without file"");; 468 return;; 469 }; 470 ; 471 Int_t nsize = nbytes + fKeylen;; 472 TList *lfree = f->GetListOfFree();; 473 TFree *f1 = (TFree*)lfree->First();; 474//*-*-------------------find free segment; 475//*-* =================; 476 TFree *bestfree = f1->GetBestFree(lfree,nsize);; 477 if (bestfree == 0) {; 478 Error(""Create"",""Cannot allocate %d bytes for ID = %s Title = %s"",; 479 nsize,GetName(),GetTitle());; 480 return;; 481 }; 482 ; 483 if (f->TestBit(TFile::kReproducible)); 484 SetBit(TKey::kReproducible);; 485 ; 486 fDatime.Set();; 487 fSeekKey = bestfree->GetFirst();; 488//*-*----------------- Case Add at the end of the file; 489 if (fSeekKey >= f->GetEND()) {; 490 f->SetEND(fSeekKe",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:17147,Energy Efficiency,allocate,allocate,17147,"ect::Class(), obj);; 437 if (!tobj->IsFolder()) {; 438 if (tobj->InheritsFrom(TCollection::Class())); 439 tobj->Delete(); // delete also collection elements; 440 delete tobj;; 441 obj = 0;; 442 }; 443 }; 444 ; 445 if (!obj); 446 obj = ReadObj();; 447 ; 448 if (b && obj) {; 449 objcl->Browse(obj,b);; 450 b->SetRefreshFlag(kTRUE);; 451 }; 452}; 453 ; 454////////////////////////////////////////////////////////////////////////////////; 455/// Create a TKey object of specified size.; 456///; 457/// If externFile!=0, key will be allocated in specified file, otherwise file; 458/// of mother directory will be used.; 459 ; 460void TKey::Create(Int_t nbytes, TFile* externFile); 461{; 462 keyAbsNumber++; SetUniqueID(keyAbsNumber);; 463 ; 464 TFile *f = externFile;; 465 if (!f) f = GetFile();; 466 if (!f) {; 467 Error(""Create"",""Cannot create key without file"");; 468 return;; 469 }; 470 ; 471 Int_t nsize = nbytes + fKeylen;; 472 TList *lfree = f->GetListOfFree();; 473 TFree *f1 = (TFree*)lfree->First();; 474//*-*-------------------find free segment; 475//*-* =================; 476 TFree *bestfree = f1->GetBestFree(lfree,nsize);; 477 if (bestfree == 0) {; 478 Error(""Create"",""Cannot allocate %d bytes for ID = %s Title = %s"",; 479 nsize,GetName(),GetTitle());; 480 return;; 481 }; 482 ; 483 if (f->TestBit(TFile::kReproducible)); 484 SetBit(TKey::kReproducible);; 485 ; 486 fDatime.Set();; 487 fSeekKey = bestfree->GetFirst();; 488//*-*----------------- Case Add at the end of the file; 489 if (fSeekKey >= f->GetEND()) {; 490 f->SetEND(fSeekKey+nsize);; 491 bestfree->SetFirst(fSeekKey+nsize);; 492 if (f->GetEND() > bestfree->GetLast()) {; 493 bestfree->SetLast(bestfree->GetLast() + 1000000000);; 494 }; 495 fLeft = -1;; 496 if (!fBuffer) fBuffer = new char[nsize];; 497 } else {; 498 fLeft = Int_t(bestfree->GetLast() - fSeekKey - nsize + 1);; 499 }; 500//*-*----------------- Case where new object fills exactly a deleted gap; 501 fNbytes = nsize;; 502 if (fLeft == 0) {; 503 if (!fBuffer) {",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:27776,Energy Efficiency,allocate,allocate,27776,"ay with using:; 744/// ~~~{.cpp}; 745/// MyClass *obj = (MyClass*)key->ReadObj();; 746/// ~~~; 747///; 748/// #### Example2: Usual case (recommended unless performance is critical); 749/// ~~~{.cpp}; 750/// MyClass *obj = dynamic_cast<MyClass*>(key->ReadObj());; 751/// ~~~; 752/// which support also the more complex inheritance like:; 753/// ~~~{.cpp}; 754/// class MyClass : public AnotherClass, public TObject; 755/// ~~~; 756///; 757/// Of course, `dynamic_cast<>` can also be used in the example 1.; 758 ; 759TObject *TKey::ReadObj(); 760{; 761 TClass *cl = TClass::GetClass(fClassName.Data());; 762 if (!cl) {; 763 Error(""ReadObj"", ""Unknown class %s"", fClassName.Data());; 764 return 0;; 765 }; 766 if (!cl->IsTObject()) {; 767 // in principle user should call TKey::ReadObjectAny!; 768 return (TObject*)ReadObjectAny(0);; 769 }; 770 ; 771 TBufferFile bufferRef(TBuffer::kRead, fObjlen+fKeylen);; 772 if (!bufferRef.Buffer()) {; 773 Error(""ReadObj"", ""Cannot allocate buffer: fObjlen = %d"", fObjlen);; 774 return 0;; 775 }; 776 if (GetFile()==0) return 0;; 777 bufferRef.SetParent(GetFile());; 778 bufferRef.SetPidOffset(fPidOffset);; 779 ; 780 std::unique_ptr<char []> compressedBuffer;; 781 auto storeBuffer = fBuffer;; 782 if (fObjlen > fNbytes-fKeylen) {; 783 compressedBuffer.reset(new char[fNbytes]);; 784 fBuffer = compressedBuffer.get();; 785 if( !ReadFile() ) //Read object structure from file; 786 {; 787 fBuffer = 0;; 788 return 0;; 789 }; 790 memcpy(bufferRef.Buffer(),fBuffer,fKeylen);; 791 } else {; 792 fBuffer = bufferRef.Buffer();; 793 if( !ReadFile() ) { //Read object structure from file; 794 ; 795 fBuffer = 0;; 796 return 0;; 797 }; 798 }; 799 fBuffer = storeBuffer;; 800 ; 801 // get version of key; 802 bufferRef.SetBufferOffset(sizeof(fNbytes));; 803 Version_t kvers = bufferRef.ReadVersion();; 804 ; 805 bufferRef.SetBufferOffset(fKeylen);; 806 TObject *tobj = 0;; 807 // Create an instance of this class; 808 ; 809 char *pobj = (char*)cl->New();; 810 if (!pobj) {; 811",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:32375,Energy Efficiency,allocate,allocate,32375,"lass. In particular the TClass object can create a new; 884/// object of the class type it describes. This new object now calls its; 885/// Streamer function to rebuilt itself.; 886///; 887/// ### Note; 888/// This function is called only internally by ROOT classes.; 889/// Although being public it is not supposed to be used outside ROOT.; 890/// If used, you must make sure that the bufferRead is large enough to; 891/// accomodate the object being read.; 892 ; 893TObject *TKey::ReadObjWithBuffer(char *bufferRead); 894{; 895 ; 896 TClass *cl = TClass::GetClass(fClassName.Data());; 897 if (!cl) {; 898 Error(""ReadObjWithBuffer"", ""Unknown class %s"", fClassName.Data());; 899 return 0;; 900 }; 901 if (!cl->IsTObject()) {; 902 // in principle user should call TKey::ReadObjectAny!; 903 return (TObject*)ReadObjectAny(0);; 904 }; 905 ; 906 TBufferFile bufferRef(TBuffer::kRead, fObjlen+fKeylen);; 907 if (!bufferRef.Buffer()) {; 908 Error(""ReadObjWithBuffer"", ""Cannot allocate buffer: fObjlen = %d"", fObjlen);; 909 return 0;; 910 }; 911 if (GetFile()==0) return 0;; 912 bufferRef.SetParent(GetFile());; 913 bufferRef.SetPidOffset(fPidOffset);; 914 ; 915 auto storeBuffer = fBuffer;; 916 if (fObjlen > fNbytes-fKeylen) {; 917 fBuffer = bufferRead;; 918 memcpy(bufferRef.Buffer(),fBuffer,fKeylen);; 919 } else {; 920 fBuffer = bufferRef.Buffer();; 921 ReadFile(); //Read object structure from file; 922 }; 923 fBuffer = storeBuffer;; 924 ; 925 // get version of key; 926 bufferRef.SetBufferOffset(sizeof(fNbytes));; 927 Version_t kvers = bufferRef.ReadVersion();; 928 ; 929 bufferRef.SetBufferOffset(fKeylen);; 930 TObject *tobj = 0;; 931 // Create an instance of this class; 932 ; 933 char *pobj = (char*)cl->New();; 934 if (!pobj) {; 935 Error(""ReadObjWithBuffer"", ""Cannot create new object of class %s"", fClassName.Data());; 936 return 0;; 937 }; 938 Int_t baseOffset = cl->GetBaseClassOffset(TObject::Class());; 939 if (baseOffset==-1) {; 940 // cl does not inherit from TObject.; 941 // Since th",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:36849,Energy Efficiency,allocate,allocate,36849,"pp}; 1011/// auto TopClass = TClass::GetClass(""Top"");; 1012/// auto ptr = (Top*) key->ReadObjectAny( TopClass );; 1013/// if (ptr==0) printError(""the object stored in the key is not of the expected type\n"");; 1014/// ~~~; 1015/// The object associated to this key is read from the file into memory.; 1016/// Once the key structure is read (via Streamer) the class identifier; 1017/// of the object is known.; 1018/// Using the class identifier we find the TClass object for this class.; 1019/// A TClass object contains a full description (i.e. dictionary) of the; 1020/// associated class. In particular the TClass object can create a new; 1021/// object of the class type it describes. This new object now calls its; 1022/// Streamer function to rebuilt itself.; 1023 ; 1024void *TKey::ReadObjectAny(const TClass* expectedClass); 1025{; 1026 TBufferFile bufferRef(TBuffer::kRead, fObjlen+fKeylen);; 1027 if (!bufferRef.Buffer()) {; 1028 Error(""ReadObj"", ""Cannot allocate buffer: fObjlen = %d"", fObjlen);; 1029 return 0;; 1030 }; 1031 if (GetFile()==0) return 0;; 1032 bufferRef.SetParent(GetFile());; 1033 bufferRef.SetPidOffset(fPidOffset);; 1034 ; 1035 std::unique_ptr<char []> compressedBuffer;; 1036 auto storeBuffer = fBuffer;; 1037 if (fObjlen > fNbytes-fKeylen) {; 1038 compressedBuffer.reset(new char[fNbytes]);; 1039 fBuffer = compressedBuffer.get();; 1040 ReadFile(); //Read object structure from file; 1041 memcpy(bufferRef.Buffer(),fBuffer,fKeylen);; 1042 } else {; 1043 fBuffer = bufferRef.Buffer();; 1044 ReadFile(); //Read object structure from file; 1045 }; 1046 fBuffer = storeBuffer;; 1047 ; 1048 // get version of key; 1049 bufferRef.SetBufferOffset(sizeof(fNbytes));; 1050 Version_t kvers = bufferRef.ReadVersion();; 1051 ; 1052 bufferRef.SetBufferOffset(fKeylen);; 1053 TClass *cl = TClass::GetClass(fClassName.Data());; 1054 TClass *clOnfile = 0;; 1055 if (!cl) {; 1056 Error(""ReadObjectAny"", ""Unknown class %s"", fClassName.Data());; 1057 return 0;; 1058 }; 1059 Int_t baseOffs",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:59250,Energy Efficiency,allocate,allocated,59250,"er.h:43; TBuffer::SetParentvoid SetParent(TObject *parent)Set parent owning this buffer.Definition TBuffer.cxx:270; TBuffer::kWrite@ kWriteDefinition TBuffer.h:73; TBuffer::kRead@ kReadDefinition TBuffer.h:73; TBuffer::SetBufferOffsetvoid SetBufferOffset(Int_t offset=0)Definition TBuffer.h:93; TBuffer::LengthInt_t Length() constDefinition TBuffer.h:100; TBuffer::MapObjectvirtual void MapObject(const TObject *obj, UInt_t offset=1)=0; TBuffer::Bufferchar * Buffer() constDefinition TBuffer.h:96; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Streamervoid Streamer(void *obj, TBuffer &b, const TClass *onfile_class=nullptr) constDefinition TClass.h:607; TClass::Browsevoid Browse(TBrowser *b) overrideThis method is called by a browser to get the class information.Definition TClass.cxx:2077; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4982; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::kDummyNew@ kDummyNewDefinition TClass.h:107; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:59701,Integrability,wrap,wrapper,59701,"stDefinition TBuffer.h:96; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Streamervoid Streamer(void *obj, TBuffer &b, const TClass *onfile_class=nullptr) constDefinition TClass.h:607; TClass::Browsevoid Browse(TBrowser *b) overrideThis method is called by a browser to get the class information.Definition TClass.cxx:2077; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4982; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::kDummyNew@ kDummyNewDefinition TClass.h:107; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7460; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::GetActualClassTClass * Get",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:70685,Integrability,message,message,70685,"ideReturns name of object.Definition TNamed.h:47; TNamed::fTitleTString fTitleDefinition TNamed.h:33; TNamed::fNameTString fNameDefinition TNamed.h:32; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::IsFoldervirtual Bool_t IsFolder() constReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Definition TObject.cxx:560; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::UseCurrentStylevirtual void UseCurrentStyle()Set current style settings in this object This function is called when either TCanvas::UseCurrentStyl...Definition TObject.cxx:807; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Classstatic TClass * Class(); TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::Infovirtual void",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:71245,Integrability,message,message,71245,"finition TObject.cxx:894; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::UseCurrentStylevirtual void UseCurrentStyle()Set current style settings in this object This function is called when either TCanvas::UseCurrentStyl...Definition TObject.cxx:807; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Classstatic TClass * Class(); TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Resizevoid Resize(Ssiz_t n)Resize the string. Truncate or add blanks as necessary.Definition TString.cxx:1152; TString::BeginsWithBool_t BeginsWith(c",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:71381,Integrability,message,message,71381,"efinition TObject.cxx:213; TObject::UseCurrentStylevirtual void UseCurrentStyle()Set current style settings in this object This function is called when either TCanvas::UseCurrentStyl...Definition TObject.cxx:807; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Classstatic TClass * Class(); TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Resizevoid Resize(Ssiz_t n)Resize the string. Truncate or add blanks as necessary.Definition TString.cxx:1152; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare cmp=kExact) constDefinition TString.h:623; TString::IsNullBool_t IsNull() constDefinition TString.h:414; T",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:71745,Integrability,message,message,71745,"c TClass * Class(); TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Resizevoid Resize(Ssiz_t n)Resize the string. Truncate or add blanks as necessary.Definition TString.cxx:1152; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare cmp=kExact) constDefinition TString.h:623; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::FillBuffervirtual void FillBuffer(char *&buffer) constCopy string into I/O buffer.Definition TString.cxx:1310; TString::Streamervirtual void Streamer(TBuffer &)Stream a string object.Definition TString.cxx:1412; TString::Sizeofvirtual Int_t Sizeof() constReturns size string will occupy on I/O buffer.Definition TString.cxx:1401; TString::ReadBuffervirtual vo",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:26580,Modifiability,inherit,inheritance,26580,"//; 713/// Print key contents.; 714 ; 715void TKey::Print(Option_t *) const; 716{; 717 printf(""TKey Name = %s, Title = %s, Cycle = %d\n"",GetName(),GetTitle(),GetCycle());; 718}; 719 ; 720////////////////////////////////////////////////////////////////////////////////; 721/// To read a TObject* from the file.; 722///; 723/// The object associated to this key is read from the file into memory; 724/// Once the key structure is read (via Streamer) the class identifier; 725/// of the object is known.; 726/// Using the class identifier we find the TClass object for this class.; 727/// A TClass object contains a full description (i.e. dictionary) of the; 728/// associated class. In particular the TClass object can create a new; 729/// object of the class type it describes. This new object now calls its; 730/// Streamer function to rebuilt itself.; 731///; 732/// Use TKey::ReadObjectAny to read any object non-derived from TObject; 733///; 734/// ### Note; 735/// A C style cast can only be used in the case where the final class; 736/// of this object derives from TObject as a first inheritance, otherwise; 737/// one must use a dynamic_cast.; 738///; 739/// #### Example1: simplified case; 740/// ~~~{.cpp}; 741/// class MyClass : public TObject, public AnotherClass; 742/// ~~~; 743/// then on return, one get away with using:; 744/// ~~~{.cpp}; 745/// MyClass *obj = (MyClass*)key->ReadObj();; 746/// ~~~; 747///; 748/// #### Example2: Usual case (recommended unless performance is critical); 749/// ~~~{.cpp}; 750/// MyClass *obj = dynamic_cast<MyClass*>(key->ReadObj());; 751/// ~~~; 752/// which support also the more complex inheritance like:; 753/// ~~~{.cpp}; 754/// class MyClass : public AnotherClass, public TObject; 755/// ~~~; 756///; 757/// Of course, `dynamic_cast<>` can also be used in the example 1.; 758 ; 759TObject *TKey::ReadObj(); 760{; 761 TClass *cl = TClass::GetClass(fClassName.Data());; 762 if (!cl) {; 763 Error(""ReadObj"", ""Unknown class %s"", fClassName.Data());;",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:27129,Modifiability,inherit,inheritance,27129,"ss object contains a full description (i.e. dictionary) of the; 728/// associated class. In particular the TClass object can create a new; 729/// object of the class type it describes. This new object now calls its; 730/// Streamer function to rebuilt itself.; 731///; 732/// Use TKey::ReadObjectAny to read any object non-derived from TObject; 733///; 734/// ### Note; 735/// A C style cast can only be used in the case where the final class; 736/// of this object derives from TObject as a first inheritance, otherwise; 737/// one must use a dynamic_cast.; 738///; 739/// #### Example1: simplified case; 740/// ~~~{.cpp}; 741/// class MyClass : public TObject, public AnotherClass; 742/// ~~~; 743/// then on return, one get away with using:; 744/// ~~~{.cpp}; 745/// MyClass *obj = (MyClass*)key->ReadObj();; 746/// ~~~; 747///; 748/// #### Example2: Usual case (recommended unless performance is critical); 749/// ~~~{.cpp}; 750/// MyClass *obj = dynamic_cast<MyClass*>(key->ReadObj());; 751/// ~~~; 752/// which support also the more complex inheritance like:; 753/// ~~~{.cpp}; 754/// class MyClass : public AnotherClass, public TObject; 755/// ~~~; 756///; 757/// Of course, `dynamic_cast<>` can also be used in the example 1.; 758 ; 759TObject *TKey::ReadObj(); 760{; 761 TClass *cl = TClass::GetClass(fClassName.Data());; 762 if (!cl) {; 763 Error(""ReadObj"", ""Unknown class %s"", fClassName.Data());; 764 return 0;; 765 }; 766 if (!cl->IsTObject()) {; 767 // in principle user should call TKey::ReadObjectAny!; 768 return (TObject*)ReadObjectAny(0);; 769 }; 770 ; 771 TBufferFile bufferRef(TBuffer::kRead, fObjlen+fKeylen);; 772 if (!bufferRef.Buffer()) {; 773 Error(""ReadObj"", ""Cannot allocate buffer: fObjlen = %d"", fObjlen);; 774 return 0;; 775 }; 776 if (GetFile()==0) return 0;; 777 bufferRef.SetParent(GetFile());; 778 bufferRef.SetPidOffset(fPidOffset);; 779 ; 780 std::unique_ptr<char []> compressedBuffer;; 781 auto storeBuffer = fBuffer;; 782 if (fObjlen > fNbytes-fKeylen) {; 783 co",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:29024,Modifiability,inherit,inherit,29024,"std::unique_ptr<char []> compressedBuffer;; 781 auto storeBuffer = fBuffer;; 782 if (fObjlen > fNbytes-fKeylen) {; 783 compressedBuffer.reset(new char[fNbytes]);; 784 fBuffer = compressedBuffer.get();; 785 if( !ReadFile() ) //Read object structure from file; 786 {; 787 fBuffer = 0;; 788 return 0;; 789 }; 790 memcpy(bufferRef.Buffer(),fBuffer,fKeylen);; 791 } else {; 792 fBuffer = bufferRef.Buffer();; 793 if( !ReadFile() ) { //Read object structure from file; 794 ; 795 fBuffer = 0;; 796 return 0;; 797 }; 798 }; 799 fBuffer = storeBuffer;; 800 ; 801 // get version of key; 802 bufferRef.SetBufferOffset(sizeof(fNbytes));; 803 Version_t kvers = bufferRef.ReadVersion();; 804 ; 805 bufferRef.SetBufferOffset(fKeylen);; 806 TObject *tobj = 0;; 807 // Create an instance of this class; 808 ; 809 char *pobj = (char*)cl->New();; 810 if (!pobj) {; 811 Error(""ReadObj"", ""Cannot create new object of class %s"", fClassName.Data());; 812 return 0;; 813 }; 814 Int_t baseOffset = cl->GetBaseClassOffset(TObject::Class());; 815 if (baseOffset==-1) {; 816 // cl does not inherit from TObject.; 817 // Since this is not possible yet, the only reason we could reach this code; 818 // is because something is screw up in the ROOT code.; 819 Fatal(""ReadObj"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 820 fClassName.Data());; 821 }; 822 tobj = (TObject*)(pobj+baseOffset);; 823 if (kvers > 1); 824 bufferRef.MapObject(pobj,cl); //register obj in map to handle self reference; 825 ; 826 if (fObjlen > fNbytes-fKeylen) {; 827 char *objbuf = bufferRef.Buffer() + fKeylen;; 828 UChar_t *bufcur = (UChar_t *)&compressedBuffer[fKeylen];; 829 Int_t nin, nout = 0, nbuf;; 830 Int_t noutot = 0;; 831 while (1) {; 832 Int_t hc = R__unzip_header(&nin, bufcur, &nbuf);; 833 if (hc!=0) break;; 834 R__unzip(&nin, bufcur, &nbuf, (unsigned char*) objbuf, &nout);; 835 if (!nout) break;; 836 noutot += nout;; 837 if (noutot >= fObjlen) break;; 838 bufcur += nin;; 839 objbuf += nout;; 840 }; 841 compr",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:29235,Modifiability,inherit,inheritance,29235,"87 fBuffer = 0;; 788 return 0;; 789 }; 790 memcpy(bufferRef.Buffer(),fBuffer,fKeylen);; 791 } else {; 792 fBuffer = bufferRef.Buffer();; 793 if( !ReadFile() ) { //Read object structure from file; 794 ; 795 fBuffer = 0;; 796 return 0;; 797 }; 798 }; 799 fBuffer = storeBuffer;; 800 ; 801 // get version of key; 802 bufferRef.SetBufferOffset(sizeof(fNbytes));; 803 Version_t kvers = bufferRef.ReadVersion();; 804 ; 805 bufferRef.SetBufferOffset(fKeylen);; 806 TObject *tobj = 0;; 807 // Create an instance of this class; 808 ; 809 char *pobj = (char*)cl->New();; 810 if (!pobj) {; 811 Error(""ReadObj"", ""Cannot create new object of class %s"", fClassName.Data());; 812 return 0;; 813 }; 814 Int_t baseOffset = cl->GetBaseClassOffset(TObject::Class());; 815 if (baseOffset==-1) {; 816 // cl does not inherit from TObject.; 817 // Since this is not possible yet, the only reason we could reach this code; 818 // is because something is screw up in the ROOT code.; 819 Fatal(""ReadObj"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 820 fClassName.Data());; 821 }; 822 tobj = (TObject*)(pobj+baseOffset);; 823 if (kvers > 1); 824 bufferRef.MapObject(pobj,cl); //register obj in map to handle self reference; 825 ; 826 if (fObjlen > fNbytes-fKeylen) {; 827 char *objbuf = bufferRef.Buffer() + fKeylen;; 828 UChar_t *bufcur = (UChar_t *)&compressedBuffer[fKeylen];; 829 Int_t nin, nout = 0, nbuf;; 830 Int_t noutot = 0;; 831 while (1) {; 832 Int_t hc = R__unzip_header(&nin, bufcur, &nbuf);; 833 if (hc!=0) break;; 834 R__unzip(&nin, bufcur, &nbuf, (unsigned char*) objbuf, &nout);; 835 if (!nout) break;; 836 noutot += nout;; 837 if (noutot >= fObjlen) break;; 838 bufcur += nin;; 839 objbuf += nout;; 840 }; 841 compressedBuffer.reset(nullptr);; 842 if (nout) {; 843 tobj->Streamer(bufferRef); //does not work with example 2 above; 844 } else {; 845 // Even-though we have a TObject, if the class is emulated the virtual; 846 // table may not be 'right', so let's go via the TClass.;",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:33367,Modifiability,inherit,inherit,33367,"07 if (!bufferRef.Buffer()) {; 908 Error(""ReadObjWithBuffer"", ""Cannot allocate buffer: fObjlen = %d"", fObjlen);; 909 return 0;; 910 }; 911 if (GetFile()==0) return 0;; 912 bufferRef.SetParent(GetFile());; 913 bufferRef.SetPidOffset(fPidOffset);; 914 ; 915 auto storeBuffer = fBuffer;; 916 if (fObjlen > fNbytes-fKeylen) {; 917 fBuffer = bufferRead;; 918 memcpy(bufferRef.Buffer(),fBuffer,fKeylen);; 919 } else {; 920 fBuffer = bufferRef.Buffer();; 921 ReadFile(); //Read object structure from file; 922 }; 923 fBuffer = storeBuffer;; 924 ; 925 // get version of key; 926 bufferRef.SetBufferOffset(sizeof(fNbytes));; 927 Version_t kvers = bufferRef.ReadVersion();; 928 ; 929 bufferRef.SetBufferOffset(fKeylen);; 930 TObject *tobj = 0;; 931 // Create an instance of this class; 932 ; 933 char *pobj = (char*)cl->New();; 934 if (!pobj) {; 935 Error(""ReadObjWithBuffer"", ""Cannot create new object of class %s"", fClassName.Data());; 936 return 0;; 937 }; 938 Int_t baseOffset = cl->GetBaseClassOffset(TObject::Class());; 939 if (baseOffset==-1) {; 940 // cl does not inherit from TObject.; 941 // Since this is not possible yet, the only reason we could reach this code; 942 // is because something is screw up in the ROOT code.; 943 Fatal(""ReadObjWithBuffer"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 944 fClassName.Data());; 945 }; 946 tobj = (TObject*)(pobj+baseOffset);; 947 ; 948 if (kvers > 1); 949 bufferRef.MapObject(pobj,cl); //register obj in map to handle self reference; 950 ; 951 if (fObjlen > fNbytes-fKeylen) {; 952 char *objbuf = bufferRef.Buffer() + fKeylen;; 953 UChar_t *bufcur = (UChar_t *)&bufferRead[fKeylen];; 954 Int_t nin, nout = 0, nbuf;; 955 Int_t noutot = 0;; 956 while (1) {; 957 Int_t hc = R__unzip_header(&nin, bufcur, &nbuf);; 958 if (hc!=0) break;; 959 R__unzip(&nin, bufcur, &nbuf, (unsigned char*) objbuf, &nout);; 960 if (!nout) break;; 961 noutot += nout;; 962 if (noutot >= fObjlen) break;; 963 bufcur += nin;; 964 objbuf += nout;; 965 };",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:33588,Modifiability,inherit,inheritance,33588," = fBuffer;; 916 if (fObjlen > fNbytes-fKeylen) {; 917 fBuffer = bufferRead;; 918 memcpy(bufferRef.Buffer(),fBuffer,fKeylen);; 919 } else {; 920 fBuffer = bufferRef.Buffer();; 921 ReadFile(); //Read object structure from file; 922 }; 923 fBuffer = storeBuffer;; 924 ; 925 // get version of key; 926 bufferRef.SetBufferOffset(sizeof(fNbytes));; 927 Version_t kvers = bufferRef.ReadVersion();; 928 ; 929 bufferRef.SetBufferOffset(fKeylen);; 930 TObject *tobj = 0;; 931 // Create an instance of this class; 932 ; 933 char *pobj = (char*)cl->New();; 934 if (!pobj) {; 935 Error(""ReadObjWithBuffer"", ""Cannot create new object of class %s"", fClassName.Data());; 936 return 0;; 937 }; 938 Int_t baseOffset = cl->GetBaseClassOffset(TObject::Class());; 939 if (baseOffset==-1) {; 940 // cl does not inherit from TObject.; 941 // Since this is not possible yet, the only reason we could reach this code; 942 // is because something is screw up in the ROOT code.; 943 Fatal(""ReadObjWithBuffer"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 944 fClassName.Data());; 945 }; 946 tobj = (TObject*)(pobj+baseOffset);; 947 ; 948 if (kvers > 1); 949 bufferRef.MapObject(pobj,cl); //register obj in map to handle self reference; 950 ; 951 if (fObjlen > fNbytes-fKeylen) {; 952 char *objbuf = bufferRef.Buffer() + fKeylen;; 953 UChar_t *bufcur = (UChar_t *)&bufferRead[fKeylen];; 954 Int_t nin, nout = 0, nbuf;; 955 Int_t noutot = 0;; 956 while (1) {; 957 Int_t hc = R__unzip_header(&nin, bufcur, &nbuf);; 958 if (hc!=0) break;; 959 R__unzip(&nin, bufcur, &nbuf, (unsigned char*) objbuf, &nout);; 960 if (!nout) break;; 961 noutot += nout;; 962 if (noutot >= fObjlen) break;; 963 bufcur += nin;; 964 objbuf += nout;; 965 }; 966 if (nout) {; 967 tobj->Streamer(bufferRef); //does not work with example 2 above; 968 } else {; 969 // Even-though we have a TObject, if the class is emulated the virtual; 970 // table may not be 'right', so let's go via the TClass.; 971 cl->Destructor(pobj);; 972 r",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:35784,Modifiability,inherit,inherits,35784,"ast<TDirectoryFile*>(tobj);; 982 dir->SetName(GetName());; 983 dir->SetTitle(GetTitle());; 984 dir->SetMother(fMotherDir);; 985 fMotherDir->Append(dir);; 986 }; 987 ; 988 // Append the object to the directory if requested:; 989 {; 990 ROOT::DirAutoAdd_t addfunc = cl->GetDirectoryAutoAdd();; 991 if (addfunc) {; 992 addfunc(pobj, fMotherDir);; 993 }; 994 }; 995 ; 996 return tobj;; 997}; 998 ; 999////////////////////////////////////////////////////////////////////////////////; 1000/// To read an object (non deriving from TObject) from the file.; 1001///; 1002/// If expectedClass is not null, we checked that that actual class of the; 1003/// object stored is suitable to be stored in a pointer pointing to an object; 1004/// of class 'expectedClass'. We also adjust the value of the returned address; 1005/// so that it is suitable to be cast (C-Style); 1006/// a pointer pointing to an object of class 'expectedClass'.; 1007///; 1008/// So for example if the class Bottom inherits from Top and the object; 1009/// stored is of type Bottom you can safely do:; 1010/// ~~~{.cpp}; 1011/// auto TopClass = TClass::GetClass(""Top"");; 1012/// auto ptr = (Top*) key->ReadObjectAny( TopClass );; 1013/// if (ptr==0) printError(""the object stored in the key is not of the expected type\n"");; 1014/// ~~~; 1015/// The object associated to this key is read from the file into memory.; 1016/// Once the key structure is read (via Streamer) the class identifier; 1017/// of the object is known.; 1018/// Using the class identifier we find the TClass object for this class.; 1019/// A TClass object contains a full description (i.e. dictionary) of the; 1020/// associated class. In particular the TClass object can create a new; 1021/// object of the class type it describes. This new object now calls its; 1022/// Streamer function to rebuilt itself.; 1023 ; 1024void *TKey::ReadObjectAny(const TClass* expectedClass); 1025{; 1026 TBufferFile bufferRef(TBuffer::kRead, fObjlen+fKeylen);; 1027 if (!bufferRef.B",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:37967,Modifiability,inherit,inherit,37967,"erRef.SetPidOffset(fPidOffset);; 1034 ; 1035 std::unique_ptr<char []> compressedBuffer;; 1036 auto storeBuffer = fBuffer;; 1037 if (fObjlen > fNbytes-fKeylen) {; 1038 compressedBuffer.reset(new char[fNbytes]);; 1039 fBuffer = compressedBuffer.get();; 1040 ReadFile(); //Read object structure from file; 1041 memcpy(bufferRef.Buffer(),fBuffer,fKeylen);; 1042 } else {; 1043 fBuffer = bufferRef.Buffer();; 1044 ReadFile(); //Read object structure from file; 1045 }; 1046 fBuffer = storeBuffer;; 1047 ; 1048 // get version of key; 1049 bufferRef.SetBufferOffset(sizeof(fNbytes));; 1050 Version_t kvers = bufferRef.ReadVersion();; 1051 ; 1052 bufferRef.SetBufferOffset(fKeylen);; 1053 TClass *cl = TClass::GetClass(fClassName.Data());; 1054 TClass *clOnfile = 0;; 1055 if (!cl) {; 1056 Error(""ReadObjectAny"", ""Unknown class %s"", fClassName.Data());; 1057 return 0;; 1058 }; 1059 Int_t baseOffset = 0;; 1060 if (expectedClass) {; 1061 // baseOffset will be -1 if cl does not inherit from expectedClass; 1062 baseOffset = cl->GetBaseClassOffset(expectedClass);; 1063 if (baseOffset == -1) {; 1064 // The 2 classes are unrelated, maybe there is a converter between the 2.; 1065 ; 1066 if (!expectedClass->GetSchemaRules() ||; 1067 !expectedClass->GetSchemaRules()->HasRuleWithSourceClass(cl->GetName())); 1068 {; 1069 // There is no converter; 1070 return 0;; 1071 }; 1072 baseOffset = 0; // For now we do not support requesting from a class that is the base of one of the class for which there is transformation to ....; 1073 clOnfile = cl;; 1074 cl = const_cast<TClass*>(expectedClass);; 1075 Info(""ReadObjectAny"",""Using Converter StreamerInfo from %s to %s"",clOnfile->GetName(),expectedClass->GetName());; 1076 }; 1077 if (cl->GetState() > TClass::kEmulated && expectedClass->GetState() <= TClass::kEmulated) {; 1078 //we cannot mix a compiled class with an emulated class in the inheritance; 1079 Warning(""ReadObjectAny"",; 1080 ""Trying to read an emulated class (%s) to store in a compiled pointer (%s)""",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:38873,Modifiability,inherit,inheritance,38873,"_t baseOffset = 0;; 1060 if (expectedClass) {; 1061 // baseOffset will be -1 if cl does not inherit from expectedClass; 1062 baseOffset = cl->GetBaseClassOffset(expectedClass);; 1063 if (baseOffset == -1) {; 1064 // The 2 classes are unrelated, maybe there is a converter between the 2.; 1065 ; 1066 if (!expectedClass->GetSchemaRules() ||; 1067 !expectedClass->GetSchemaRules()->HasRuleWithSourceClass(cl->GetName())); 1068 {; 1069 // There is no converter; 1070 return 0;; 1071 }; 1072 baseOffset = 0; // For now we do not support requesting from a class that is the base of one of the class for which there is transformation to ....; 1073 clOnfile = cl;; 1074 cl = const_cast<TClass*>(expectedClass);; 1075 Info(""ReadObjectAny"",""Using Converter StreamerInfo from %s to %s"",clOnfile->GetName(),expectedClass->GetName());; 1076 }; 1077 if (cl->GetState() > TClass::kEmulated && expectedClass->GetState() <= TClass::kEmulated) {; 1078 //we cannot mix a compiled class with an emulated class in the inheritance; 1079 Warning(""ReadObjectAny"",; 1080 ""Trying to read an emulated class (%s) to store in a compiled pointer (%s)"",; 1081 cl->GetName(),expectedClass->GetName());; 1082 }; 1083 }; 1084 // Create an instance of this class; 1085 ; 1086 void *pobj = cl->New();; 1087 if (!pobj) {; 1088 Error(""ReadObjectAny"", ""Cannot create new object of class %s"", fClassName.Data());; 1089 return 0;; 1090 }; 1091 ; 1092 if (kvers > 1); 1093 bufferRef.MapObject(pobj,cl); //register obj in map to handle self reference; 1094 ; 1095 if (fObjlen > fNbytes-fKeylen) {; 1096 char *objbuf = bufferRef.Buffer() + fKeylen;; 1097 UChar_t *bufcur = (UChar_t *)&compressedBuffer[fKeylen];; 1098 Int_t nin, nout = 0, nbuf;; 1099 Int_t noutot = 0;; 1100 while (1) {; 1101 Int_t hc = R__unzip_header(&nin, bufcur, &nbuf);; 1102 if (hc!=0) break;; 1103 R__unzip(&nin, bufcur, &nbuf, (unsigned char*) objbuf, &nout);; 1104 if (!nout) break;; 1105 noutot += nout;; 1106 if (noutot >= fObjlen) break;; 1107 bufcur += nin;; 1108",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:40340,Modifiability,inherit,inheritance,40340,"80 ""Trying to read an emulated class (%s) to store in a compiled pointer (%s)"",; 1081 cl->GetName(),expectedClass->GetName());; 1082 }; 1083 }; 1084 // Create an instance of this class; 1085 ; 1086 void *pobj = cl->New();; 1087 if (!pobj) {; 1088 Error(""ReadObjectAny"", ""Cannot create new object of class %s"", fClassName.Data());; 1089 return 0;; 1090 }; 1091 ; 1092 if (kvers > 1); 1093 bufferRef.MapObject(pobj,cl); //register obj in map to handle self reference; 1094 ; 1095 if (fObjlen > fNbytes-fKeylen) {; 1096 char *objbuf = bufferRef.Buffer() + fKeylen;; 1097 UChar_t *bufcur = (UChar_t *)&compressedBuffer[fKeylen];; 1098 Int_t nin, nout = 0, nbuf;; 1099 Int_t noutot = 0;; 1100 while (1) {; 1101 Int_t hc = R__unzip_header(&nin, bufcur, &nbuf);; 1102 if (hc!=0) break;; 1103 R__unzip(&nin, bufcur, &nbuf, (unsigned char*) objbuf, &nout);; 1104 if (!nout) break;; 1105 noutot += nout;; 1106 if (noutot >= fObjlen) break;; 1107 bufcur += nin;; 1108 objbuf += nout;; 1109 }; 1110 if (nout) {; 1111 cl->Streamer((void*)pobj, bufferRef, clOnfile); //read object; 1112 } else {; 1113 cl->Destructor(pobj);; 1114 return nullptr;; 1115 }; 1116 } else {; 1117 cl->Streamer((void*)pobj, bufferRef, clOnfile); //read object; 1118 }; 1119 ; 1120 if (cl->IsTObject()) {; 1121 auto tobjBaseOffset = cl->GetBaseClassOffset(TObject::Class());; 1122 if (tobjBaseOffset == -1) {; 1123 Fatal(""ReadObj"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 1124 fClassName.Data());; 1125 }; 1126 TObject *tobj = (TObject*)( ((char*)pobj) + tobjBaseOffset);; 1127 ; 1128 // See similar adjustments in ReadObj; 1129 if (gROOT->GetForceStyle()) tobj->UseCurrentStyle();; 1130 ; 1131 if (cl->InheritsFrom(TDirectoryFile::Class())) {; 1132 TDirectory *dir = static_cast<TDirectoryFile*>(tobj);; 1133 dir->SetName(GetName());; 1134 dir->SetTitle(GetTitle());; 1135 dir->SetMother(fMotherDir);; 1136 fMotherDir->Append(dir);; 1137 }; 1138 }; 1139 ; 1140 {; 1141 // Append the object to the directory ",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:46825,Modifiability,variab,variable,46825,"}; 1289 return kTRUE;; 1290}; 1291 ; 1292////////////////////////////////////////////////////////////////////////////////; 1293/// Set parent in key buffer.; 1294 ; 1295void TKey::SetParent(const TObject *parent); 1296{; 1297 if (fBufferRef) fBufferRef->SetParent((TObject*)parent);; 1298}; 1299 ; 1300////////////////////////////////////////////////////////////////////////////////; 1301/// Reset the key as it had not been 'filled' yet.; 1302 ; 1303void TKey::Reset(); 1304{; 1305 fPidOffset = 0;; 1306 fNbytes = 0;; 1307 fBuffer = 0;; 1308 fObjlen = 0;; 1309 fCycle = 0;; 1310 fSeekPdir = 0;; 1311 fSeekKey = 0;; 1312 fLeft = 0;; 1313 fDatime = (UInt_t)0;; 1314 ; 1315 // fBufferRef and fKeylen intentionally not reset/changed; 1316 ; 1317 keyAbsNumber++; SetUniqueID(keyAbsNumber);; 1318}; 1319 ; 1320////////////////////////////////////////////////////////////////////////////////; 1321/// Return the size in bytes of the key header structure.; 1322///; 1323/// An explanation about the nbytes (Int_t nbytes) variable used in the; 1324/// function. The size of fSeekKey and fSeekPdir is 8 instead of 4 if version is; 1325/// greater than 1000.; 1326/// | Component | Sizeof |; 1327/// |-------------------|------------|; 1328/// | fNbytes | 4 |; 1329/// | sizeof(Version_t) | 2 |; 1330/// | fObjlen | 4 |; 1331/// | fDatime | 4 |; 1332/// | fKeylen | 2 |; 1333/// | fCycle | 2 |; 1334/// | fSeekKey | 4 or 8 |; 1335/// | fSeekPdir | 4 or 8 |; 1336/// | **FIXED TOTAL** | 26 or 34 |; 1337/// | fClassName | 1+ bytes |; 1338/// | fName | 1+ bytes |; 1339/// | fTitle | 1+ bytes |; 1340/// | **TOTAL** | 29+ or 37+ |; 1341 ; 1342Int_t TKey::Sizeof() const; 1343{; 1344 Int_t nbytes = 22; if (fVersion > 1000) nbytes += 8;; 1345 nbytes += fDatime.Sizeof();; 1346 if (TestBit(kIsDirectoryFile)) {; 1347 nbytes += 11; // strlen(""TDirectory"")+1; 1348 } else {; 1349 nbytes += fClassName.Sizeof();; 1350 }; 1351 nbytes += fName.Sizeof();; 1352 nbytes += fTitle.Sizeof();; 1353 return nbytes;; 1354}; 1355",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:60047,Modifiability,inherit,inherits,60047,"o get the class information.Definition TClass.cxx:2077; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4982; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::kDummyNew@ kDummyNewDefinition TClass.h:107; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7460; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::GetActualClassTClass * GetActualClass(const void *object) constReturn a pointer to the real class of the object.Definition TClass.cxx:2674; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:60194,Modifiability,inherit,inherits,60194,"NewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4982; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::kDummyNew@ kDummyNewDefinition TClass.h:107; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7460; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::GetActualClassTClass * GetActualClass(const void *object) constReturn a pointer to the real class of the object.Definition TClass.cxx:2674; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass * Class(); TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:71091,Modifiability,inherit,inherits,71091,"ect.cxx:560; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::UseCurrentStylevirtual void UseCurrentStyle()Set current style settings in this object This function is called when either TCanvas::UseCurrentStyl...Definition TObject.cxx:807; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Classstatic TClass * Class(); TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() c",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
