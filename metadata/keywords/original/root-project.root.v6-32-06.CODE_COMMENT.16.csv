id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:1411,Availability,error,error,1411,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:1422,Availability,recover,recovery,1422,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:1515,Availability,failure,failure,1515,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:1061,Integrability,rout,routine,1061,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:1652,Integrability,depend,dependent,1652,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:1696,Modifiability,extend,extend,1696,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:730,Performance,perform,performed,730,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:692,Safety,recover,recovery,692,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:718,Safety,recover,recovery,718,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:1422,Safety,recover,recovery,1422,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:22,Performance,perform,perform,22,// Determine where to perform name lookup,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:49,Security,access,access,49,"// This nested-name-specifier occurs in a member access expression, e.g.,; // x->B::f, and we are looking into the type of the object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:3,Performance,Perform,Perform,3,"// Perform ""qualified"" name lookup into the declaration context we; // computed, which is either the type of the base of a member access; // expression or the declaration context associated with a prior; // nested-name-specifier.; // The declaration context must be complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:130,Security,access,access,130,"// Perform ""qualified"" name lookup into the declaration context we; // computed, which is either the type of the base of a member access; // expression or the declaration context associated with a prior; // nested-name-specifier.; // The declaration context must be complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:3,Deployability,Update,Update,3,// Update the DeclContext to point to the Tag definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:895,Availability,avail,available,895,"// C++ [basic.lookup.classref]p4:; // If the id-expression in a class member access is a qualified-id of; // the form; //; // class-name-or-namespace-name::...; //; // the class-name-or-namespace-name following the . or -> operator is; // looked up both in the context of the entire postfix-expression and in; // the scope of the class of the object expression. If the name is found; // only in the scope of the class of the object expression, the name; // shall refer to a class-name. If the name is found only in the; // context of the entire postfix-expression, the name shall refer to a; // class-name or namespace-name. [...]; //; // Qualified name lookup into a class will not find a namespace-name,; // so we do not need to diagnose that case specifically. However,; // this qualified name lookup may find nothing. In that case, perform; // unqualified name lookup in the given scope (if available) or; // reconstruct the result from when name lookup was performed at template; // definition time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:836,Performance,perform,perform,836,"// C++ [basic.lookup.classref]p4:; // If the id-expression in a class member access is a qualified-id of; // the form; //; // class-name-or-namespace-name::...; //; // the class-name-or-namespace-name following the . or -> operator is; // looked up both in the context of the entire postfix-expression and in; // the scope of the class of the object expression. If the name is found; // only in the scope of the class of the object expression, the name; // shall refer to a class-name. If the name is found only in the; // context of the entire postfix-expression, the name shall refer to a; // class-name or namespace-name. [...]; //; // Qualified name lookup into a class will not find a namespace-name,; // so we do not need to diagnose that case specifically. However,; // this qualified name lookup may find nothing. In that case, perform; // unqualified name lookup in the given scope (if available) or; // reconstruct the result from when name lookup was performed at template; // definition time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:962,Performance,perform,performed,962,"// C++ [basic.lookup.classref]p4:; // If the id-expression in a class member access is a qualified-id of; // the form; //; // class-name-or-namespace-name::...; //; // the class-name-or-namespace-name following the . or -> operator is; // looked up both in the context of the entire postfix-expression and in; // the scope of the class of the object expression. If the name is found; // only in the scope of the class of the object expression, the name; // shall refer to a class-name. If the name is found only in the; // context of the entire postfix-expression, the name shall refer to a; // class-name or namespace-name. [...]; //; // Qualified name lookup into a class will not find a namespace-name,; // so we do not need to diagnose that case specifically. However,; // this qualified name lookup may find nothing. In that case, perform; // unqualified name lookup in the given scope (if available) or; // reconstruct the result from when name lookup was performed at template; // definition time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:77,Security,access,access,77,"// C++ [basic.lookup.classref]p4:; // If the id-expression in a class member access is a qualified-id of; // the form; //; // class-name-or-namespace-name::...; //; // the class-name-or-namespace-name following the . or -> operator is; // looked up both in the context of the entire postfix-expression and in; // the scope of the class of the object expression. If the name is found; // only in the scope of the class of the object expression, the name; // shall refer to a class-name. If the name is found only in the; // context of the entire postfix-expression, the name shall refer to a; // class-name or namespace-name. [...]; //; // Qualified name lookup into a class will not find a namespace-name,; // so we do not need to diagnose that case specifically. However,; // this qualified name lookup may find nothing. In that case, perform; // unqualified name lookup in the given scope (if available) or; // reconstruct the result from when name lookup was performed at template; // definition time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:3,Performance,Perform,Perform,3,// Perform unqualified name lookup in the current scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:33,Integrability,depend,dependent,33,"// If we performed lookup into a dependent context and did not find anything,; // that's fine: just build a dependent nested-name-specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:108,Integrability,depend,dependent,108,"// If we performed lookup into a dependent context and did not find anything,; // that's fine: just build a dependent nested-name-specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:9,Performance,perform,performed,9,"// If we performed lookup into a dependent context and did not find anything,; // that's fine: just build a dependent nested-name-specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:51,Availability,error,error,51,// Don't speculate if we're just trying to improve error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:57,Availability,recover,recovery,57,// Don't speculate if we're just trying to improve error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:57,Safety,recover,recovery,57,// Don't speculate if we're just trying to improve error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:61,Integrability,depend,dependent,61,"// We were not able to compute the declaration context for a dependent; // base object type or prior nested-name-specifier, so this; // nested-name-specifier refers to an unknown specialization. Just build; // a dependent nested-name-specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:212,Integrability,depend,dependent,212,"// We were not able to compute the declaration context for a dependent; // base object type or prior nested-name-specifier, so this; // nested-name-specifier refers to an unknown specialization. Just build; // a dependent nested-name-specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:65,Availability,error,error,65,"// Replacement '::' -> ':' is not allowed, just issue respective error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:44,Availability,recover,recovering,44,"// We haven't found anything, and we're not recovering from a; // different kind of error, so look for typos.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:84,Availability,error,error,84,"// We haven't found anything, and we're not recovering from a; // different kind of error, so look for typos.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:44,Safety,recover,recovering,44,"// We haven't found anything, and we're not recovering from a; // different kind of error, so look for typos.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:485,Availability,redundant,redundant,485,"// C++03 [basic.lookup.classref]p4:; // [...] If the name is found in both contexts, the; // class-name-or-namespace-name shall refer to the same entity.; //; // We already found the name in the scope of the object. Now, look; // into the current scope (the scope of the postfix-expression) to; // see if we can find the same name there. As above, if there is no; // scope, reconstruct the result from the template instantiation itself.; //; // Note that C++11 does *not* perform this redundant lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:472,Performance,perform,perform,472,"// C++03 [basic.lookup.classref]p4:; // [...] If the name is found in both contexts, the; // class-name-or-namespace-name shall refer to the same entity.; //; // We already found the name in the scope of the object. Now, look; // into the current scope (the scope of the postfix-expression) to; // see if we can find the same name there. As above, if there is no; // scope, reconstruct the result from the template instantiation itself.; //; // Note that C++11 does *not* perform this redundant lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:485,Safety,redund,redundant,485,"// C++03 [basic.lookup.classref]p4:; // [...] If the name is found in both contexts, the; // class-name-or-namespace-name shall refer to the same entity.; //; // We already found the name in the scope of the object. Now, look; // into the current scope (the scope of the postfix-expression) to; // see if we can find the same name there. As above, if there is no; // scope, reconstruct the result from the template instantiation itself.; //; // Note that C++11 does *not* perform this redundant lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:44,Availability,error,error-recovery,44,"// If we're just performing this lookup for error-recovery purposes,; // don't extend the nested-name-specifier. Just return now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:79,Modifiability,extend,extend,79,"// If we're just performing this lookup for error-recovery purposes,; // don't extend the nested-name-specifier. Just return now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:17,Performance,perform,performing,17,"// If we're just performing this lookup for error-recovery purposes,; // don't extend the nested-name-specifier. Just return now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:50,Safety,recover,recovery,50,"// If we're just performing this lookup for error-recovery purposes,; // don't extend the nested-name-specifier. Just return now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:25,Availability,error,error,25,"// Otherwise, we have an error case. If we don't want diagnostics, just; // return an error now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:86,Availability,error,error,86,"// Otherwise, we have an error case. If we don't want diagnostics, just; // return an error now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:123,Availability,error,error,123,"// If we didn't find anything during our lookup, try again with; // ordinary name lookup, which can help us produce better error; // messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:133,Integrability,message,messages,133,"// If we didn't find anything during our lookup, try again with; // ordinary name lookup, which can help us produce better error; // messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:324,Integrability,depend,dependent,324,"// In Microsoft mode, if we are within a templated function and we can't; // resolve Identifier, then extend the SS with Identifier. This will have; // the effect of resolving Identifier during template instantiation.; // The goal is to be able to resolve a function call whose; // nested-name-specifier is located inside a dependent base class.; // Example:; //; // class C {; // public:; // static void foo2() { }; // };; // template <class T> class A { public: typedef C D; };; //; // template <class T> class B : public A<T> {; // public:; // void foo() { D::foo2(); }; // };",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:102,Modifiability,extend,extend,102,"// In Microsoft mode, if we are within a templated function and we can't; // resolve Identifier, then extend the SS with Identifier. This will have; // the effect of resolving Identifier during template instantiation.; // The goal is to be able to resolve a function call whose; // nested-name-specifier is located inside a dependent base class.; // Example:; //; // class C {; // public:; // static void foo2() { }; // };; // template <class T> class A { public: typedef C D; };; //; // template <class T> class B : public A<T> {; // public:; // void foo() { D::foo2(); }; // };",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:56,Availability,error,error,56,"/// IsInvalidUnlessNestedName - This method is used for error recovery; /// purposes to determine whether the specified identifier is only valid as; /// a nested name specifier, for example a namespace name. It is; /// conservatively correct to always return false from this method.; ///; /// The arguments are the same as those passed to ActOnCXXNestedNameSpecifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:62,Availability,recover,recovery,62,"/// IsInvalidUnlessNestedName - This method is used for error recovery; /// purposes to determine whether the specified identifier is only valid as; /// a nested name specifier, for example a namespace name. It is; /// conservatively correct to always return false from this method.; ///; /// The arguments are the same as those passed to ActOnCXXNestedNameSpecifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:62,Safety,recover,recovery,62,"/// IsInvalidUnlessNestedName - This method is used for error recovery; /// purposes to determine whether the specified identifier is only valid as; /// a nested name specifier, for example a namespace name. It is; /// conservatively correct to always return false from this method.; ///; /// The arguments are the same as those passed to ActOnCXXNestedNameSpecifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:12,Integrability,depend,dependent,12,// Handle a dependent template specialization for which we cannot resolve; // the template name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:24,Integrability,depend,depend,24,// TODO: Sema shouldn't depend on Lex,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:24,Integrability,depend,depend,24,// TODO: Sema shouldn't depend on Lex,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:6,Integrability,inject,injected-class-name,6,// An injected-class-name of a class template (specialization) is valid; // as a template or as a non-template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:6,Security,inject,injected-class-name,6,// An injected-class-name of a class template (specialization) is valid; // as a template or as a non-template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:74,Usability,simpl,simple-type-specifier,74,// end anonymous namespace; /// Determine whether the token kind starts a simple-type-specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:104,Integrability,depend,dependent,104,"// end anonymous namespace; /// Tries to perform unqualified lookup of the type decls in bases for; /// dependent class.; /// \return \a NotFound if no any decls is found, \a FoundNotType if found not a; /// type decl, \a FoundType if only type decls are found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:41,Performance,perform,perform,41,"// end anonymous namespace; /// Tries to perform unqualified lookup of the type decls in bases for; /// dependent class.; /// \return \a NotFound if no any decls is found, \a FoundNotType if found not a; /// type decl, \a FoundType if only type decls are found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:26,Integrability,depend,dependent,26,// Look for type decls in dependent base classes that have known primary; // templates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:26,Integrability,depend,dependent,26,// Look for type decls in dependent base classes that have known primary; // templates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:50,Availability,Recover,Recover,50,// We found some types in dependent base classes. Recover as if the user; // wrote 'typename MyClass::II' instead of 'II'. We'll fully resolve the; // lookup during template instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:26,Integrability,depend,dependent,26,// We found some types in dependent base classes. Recover as if the user; // wrote 'typename MyClass::II' instead of 'II'. We'll fully resolve the; // lookup during template instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:50,Safety,Recover,Recover,50,// We found some types in dependent base classes. Recover as if the user; // wrote 'typename MyClass::II' instead of 'II'. We'll fully resolve the; // lookup during template instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:29,Usability,simpl,simple-type-specifier,29,/// Build a ParsedType for a simple-type-specifier with a nested-name-specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:120,Integrability,rout,routine,120,"/// If the identifier refers to a type name within this scope,; /// return the declaration of that type.; ///; /// This routine performs ordinary name lookup of the identifier II; /// within the given scope, with optional C++ scope specifier SS, to; /// determine whether the name refers to a type. If so, returns an; /// opaque pointer (actually a QualType) corresponding to that; /// type. Otherwise, returns NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:128,Performance,perform,performs,128,"/// If the identifier refers to a type name within this scope,; /// return the declaration of that type.; ///; /// This routine performs ordinary name lookup of the identifier II; /// within the given scope, with optional C++ scope specifier SS, to; /// determine whether the name refers to a type. If so, returns an; /// opaque pointer (actually a QualType) corresponding to that; /// type. Otherwise, returns NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:27,Performance,perform,perform,27,// Determine where we will perform name lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:105,Integrability,depend,depends,105,"// C++ [temp.res]p3:; // A qualified-id that refers to a type and in which the; // nested-name-specifier depends on a template-parameter (14.6.2); // shall be prefixed by the keyword typename to indicate that the; // qualified-id denotes a type, forming an; // elaborated-type-specifier (7.1.5.3).; //; // We therefore do not perform any name lookup if the result would; // refer to a member of an unknown specialization.; // In C++2a, in several contexts a 'typename' is not required. Also; // allow this as an extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:326,Performance,perform,perform,326,"// C++ [temp.res]p3:; // A qualified-id that refers to a type and in which the; // nested-name-specifier depends on a template-parameter (14.6.2); // shall be prefixed by the keyword typename to indicate that the; // qualified-id denotes a type, forming an; // elaborated-type-specifier (7.1.5.3).; //; // We therefore do not perform any name lookup if the result would; // refer to a member of an unknown specialization.; // In C++2a, in several contexts a 'typename' is not required. Also; // allow this as an extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:76,Integrability,depend,dependent,76,"// We know from the grammar that this name refers to a type,; // so build a dependent node to describe the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Deployability,Update,Update,3,// Update the DeclContext to point to the Tag definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Performance,Perform,Perform,3,"// Perform ""qualified"" name lookup into the declaration context we; // computed, which is either the type of the base of a member access; // expression or the declaration context associated with a prior; // nested-name-specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:130,Security,access,access,130,"// Perform ""qualified"" name lookup into the declaration context we; // computed, which is either the type of the base of a member access; // expression or the declaration context associated with a prior; // nested-name-specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Performance,Perform,Perform,3,// Perform unqualified name lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:74,Integrability,depend,dependent,74,"// For unqualified lookup in a class template in MSVC mode, look into; // dependent base classes where the primary class template is known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Availability,Recover,Recover,3,"// Recover from type-hiding ambiguities by hiding the type. We'll; // do the lookup again when looking for an object, and we can; // diagnose the error then. If we don't do this, then the error; // about hiding the type will be immediately followed by an error; // that only makes sense if the identifier was treated like a type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:146,Availability,error,error,146,"// Recover from type-hiding ambiguities by hiding the type. We'll; // do the lookup again when looking for an object, and we can; // diagnose the error then. If we don't do this, then the error; // about hiding the type will be immediately followed by an error; // that only makes sense if the identifier was treated like a type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:188,Availability,error,error,188,"// Recover from type-hiding ambiguities by hiding the type. We'll; // do the lookup again when looking for an object, and we can; // diagnose the error then. If we don't do this, then the error; // about hiding the type will be immediately followed by an error; // that only makes sense if the identifier was treated like a type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:255,Availability,error,error,255,"// Recover from type-hiding ambiguities by hiding the type. We'll; // do the lookup again when looking for an object, and we can; // diagnose the error then. If we don't do this, then the error; // about hiding the type will be immediately followed by an error; // that only makes sense if the identifier was treated like a type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Recover,Recover,3,"// Recover from type-hiding ambiguities by hiding the type. We'll; // do the lookup again when looking for an object, and we can; // diagnose the error then. If we don't do this, then the error; // about hiding the type will be immediately followed by an error; // that only makes sense if the identifier was treated like a type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:29,Availability,recover,recovery,29,// Make the selection of the recovery decl deterministic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:29,Safety,recover,recovery,29,// Make the selection of the recovery decl deterministic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:197,Performance,perform,perform,197,"// None of the entities we found is a type, so there is no way; // to even assume that the result is a type. In this case, don't; // complain about the ambiguity. The parser will either try to; // perform this lookup again (e.g., as an object name), which; // will produce the ambiguity, or will complain that it expected; // a type name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:195,Performance,perform,perform,195,"// We found a type within the ambiguous lookup; diagnose the; // ambiguity and then return that type. This might be the right; // answer, or it might not be, but it suppresses any attempt to; // perform the name lookup again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:52,Integrability,inject,injected-class-name,52,"// C++ [class.qual]p2: A lookup that would find the injected-class-name; // instead names the constructors of the class, except when naming a class.; // This is ill-formed when we're not actually forming a ctor or dtor name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:52,Security,inject,injected-class-name,52,"// C++ [class.qual]p2: A lookup that would find the injected-class-name; // instead names the constructors of the class, except when naming a class.; // This is ill-formed when we're not actually forming a ctor or dtor name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Availability,Recover,Recover,3,// Recover with 'int',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Recover,Recover,3,// Recover with 'int',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:9,Integrability,wrap,wrap,9,// Don't wrap in a further UsingType.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:31,Integrability,depend,dependent,31,"/// Find the parent class with dependent bases of the innermost enclosing method; /// context. Do not look for enclosing CXXRecordDecls directly, or we will end; /// up allowing unqualified dependent type names at class-level, which MSVC; /// correctly rejects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:190,Integrability,depend,dependent,190,"/// Find the parent class with dependent bases of the innermost enclosing method; /// context. Do not look for enclosing CXXRecordDecls directly, or we will end; /// up allowing unqualified dependent type names at class-level, which MSVC; /// correctly rejects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:309,Availability,error,errors,309,"// If we weren't able to parse a default template argument, delay lookup; // until instantiation time by making a non-dependent DependentTypeName. We; // pretend we saw a NestedNameSpecifier referring to the current scope, and; // lookup is retried.; // FIXME: This hurts our diagnostic quality, since we get errors like ""no; // type named 'Foo' in 'current_namespace'"" when the user didn't write any; // name specifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:118,Integrability,depend,dependent,118,"// If we weren't able to parse a default template argument, delay lookup; // until instantiation time by making a non-dependent DependentTypeName. We; // pretend we saw a NestedNameSpecifier referring to the current scope, and; // lookup is retried.; // FIXME: This hurts our diagnostic quality, since we get errors like ""no; // type named 'Foo' in 'current_namespace'"" when the user didn't write any; // name specifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:128,Integrability,Depend,DependentTypeName,128,"// If we weren't able to parse a default template argument, delay lookup; // until instantiation time by making a non-dependent DependentTypeName. We; // pretend we saw a NestedNameSpecifier referring to the current scope, and; // lookup is retried.; // FIXME: This hurts our diagnostic quality, since we get errors like ""no; // type named 'Foo' in 'current_namespace'"" when the user didn't write any; // name specifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,Integrability,Depend,DependentNameType,11,// Build a DependentNameType that will perform lookup into RD at; // instantiation time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:39,Performance,perform,perform,39,// Build a DependentNameType that will perform lookup into RD at; // instantiation time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:42,Availability,recover,recover,42,// This is not a situation that we should recover from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:42,Safety,recover,recover,42,// This is not a situation that we should recover from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:45,Availability,error,error,45,"/// isTagName() - This method is called *for error recovery purposes only*; /// to determine if the specified name is a valid tag name (""struct foo""). If; /// so, this returns the TST for the tag corresponding to it (TST_enum,; /// TST_union, TST_struct, TST_interface, TST_class). This is used to diagnose; /// cases in C where the user forgot to specify the tag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:51,Availability,recover,recovery,51,"/// isTagName() - This method is called *for error recovery purposes only*; /// to determine if the specified name is a valid tag name (""struct foo""). If; /// so, this returns the TST for the tag corresponding to it (TST_enum,; /// TST_union, TST_struct, TST_interface, TST_class). This is used to diagnose; /// cases in C where the user forgot to specify the tag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:51,Safety,recover,recovery,51,"/// isTagName() - This method is called *for error recovery purposes only*; /// to determine if the specified name is a valid tag name (""struct foo""). If; /// so, this returns the TST for the tag corresponding to it (TST_enum,; /// TST_union, TST_struct, TST_interface, TST_class). This is used to diagnose; /// cases in C where the user forgot to specify the tag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:160,Availability,down,downgrade,160,"/// isMicrosoftMissingTypename - In Microsoft mode, within class scope,; /// if a CXXScopeSpec's type is equal to the type of one of the base classes; /// then downgrade the missing typename error to a warning.; /// This is needed for MSVC compatibility; Example:; /// @code; /// template<class T> class A {; /// public:; /// typedef int TYPE;; /// };; /// template<class T> class B : public A<T> {; /// public:; /// A<T>::TYPE a; // no typename required because A<T> is a base class.; /// };; /// @endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:191,Availability,error,error,191,"/// isMicrosoftMissingTypename - In Microsoft mode, within class scope,; /// if a CXXScopeSpec's type is equal to the type of one of the base classes; /// then downgrade the missing typename error to a warning.; /// This is needed for MSVC compatibility; Example:; /// @code; /// template<class T> class A {; /// public:; /// typedef int TYPE;; /// };; /// template<class T> class B : public A<T> {; /// public:; /// A<T>::TYPE a; // no typename required because A<T> is a base class.; /// };; /// @endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:25,Availability,error,errors,25,// Don't report typename errors for editor placeholders.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:18,Availability,error,error,18,// FIXME: Support error recovery for the template-name case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:24,Availability,recover,recovery,24,// FIXME: Support error recovery for the template-name case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:24,Safety,recover,recovery,24,// FIXME: Support error recovery for the template-name case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:38,Integrability,interface,interface,38,// We found a similarly-named type or interface; suggest that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:49,Availability,recover,recover,49,"// FIXME: Should we move the logic that tries to recover from a missing tag; // (struct, union, enum) from Parser::ParseImplicitInt here, instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:49,Safety,recover,recover,49,"// FIXME: Should we move the logic that tries to recover from a missing tag; // (struct, union, enum) from Parser::ParseImplicitInt here, instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:29,Testability,log,logic,29,"// FIXME: Should we move the logic that tries to recover from a missing tag; // (struct, union, enum) from Parser::ParseImplicitInt here, instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:70,Integrability,inject,injected-class-name,70,"// Per [class.qual]p2, this names the constructors of SS, not the; // injected-class-name. We don't have a classification for that.; // There's not much point caching this result, since the parser; // will reject it later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:70,Security,inject,injected-class-name,70,"// Per [class.qual]p2, this names the constructors of SS, not the; // injected-class-name. We don't have a classification for that.; // There's not much point caching this result, since the parser; // will reject it later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:74,Integrability,depend,dependent,74,"// For unqualified lookup in a class template in MSVC mode, look into; // dependent base classes where the primary class template is known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:43,Modifiability,variab,variables,43,"// Perform lookup for Objective-C instance variables (including automatically; // synthesized instance variables), if we're in an Objective-C method.; // FIXME: This lookup really, really needs to be folded in to the normal; // unqualified lookup mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:103,Modifiability,variab,variables,103,"// Perform lookup for Objective-C instance variables (including automatically; // synthesized instance variables), if we're in an Objective-C method.; // FIXME: This lookup really, really needs to be folded in to the normal; // unqualified lookup mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Performance,Perform,Perform,3,"// Perform lookup for Objective-C instance variables (including automatically; // synthesized instance variables), if we're in an Objective-C method.; // FIXME: This lookup really, really needs to be folded in to the normal; // unqualified lookup mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Performance,Perform,Perform,3,// Perform typo correction to determine if there is another name that is; // close to this name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:34,Testability,Test,Test,34,// FIXME: is this even reachable? Test it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Deployability,Update,Update,3,"// Update the name, so that the caller has the new name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:8,Deployability,update,update,8,// Also update the LookupResult...; // FIXME: This should probably go away at some point,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:39,Modifiability,variab,variable,39,"// If we found an Objective-C instance variable, let; // LookupInObjCMethod build the appropriate expression to; // reference the ivar.; // FIXME: This is a gross hack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:79,Integrability,depend,dependent,79,"// We performed name lookup into the current instantiation, and there were; // dependent bases, so we treat this result the same way as any other; // dependent nested-name-specifier.; // C++ [temp.res]p2:; // A name used in a template declaration or definition and that is; // dependent on a template-parameter is assumed not to name a type; // unless the applicable name lookup finds a type name or the name is; // qualified by the keyword typename.; //; // FIXME: If the next token is '<', we might want to ask the parser to; // perform some heroics to see if we actually have a; // template-argument-list, which would indicate a missing 'template'; // keyword here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:150,Integrability,depend,dependent,150,"// We performed name lookup into the current instantiation, and there were; // dependent bases, so we treat this result the same way as any other; // dependent nested-name-specifier.; // C++ [temp.res]p2:; // A name used in a template declaration or definition and that is; // dependent on a template-parameter is assumed not to name a type; // unless the applicable name lookup finds a type name or the name is; // qualified by the keyword typename.; //; // FIXME: If the next token is '<', we might want to ask the parser to; // perform some heroics to see if we actually have a; // template-argument-list, which would indicate a missing 'template'; // keyword here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:277,Integrability,depend,dependent,277,"// We performed name lookup into the current instantiation, and there were; // dependent bases, so we treat this result the same way as any other; // dependent nested-name-specifier.; // C++ [temp.res]p2:; // A name used in a template declaration or definition and that is; // dependent on a template-parameter is assumed not to name a type; // unless the applicable name lookup finds a type name or the name is; // qualified by the keyword typename.; //; // FIXME: If the next token is '<', we might want to ask the parser to; // perform some heroics to see if we actually have a; // template-argument-list, which would indicate a missing 'template'; // keyword here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:6,Performance,perform,performed,6,"// We performed name lookup into the current instantiation, and there were; // dependent bases, so we treat this result the same way as any other; // dependent nested-name-specifier.; // C++ [temp.res]p2:; // A name used in a template declaration or definition and that is; // dependent on a template-parameter is assumed not to name a type; // unless the applicable name lookup finds a type name or the name is; // qualified by the keyword typename.; //; // FIXME: If the next token is '<', we might want to ask the parser to; // perform some heroics to see if we actually have a; // template-argument-list, which would indicate a missing 'template'; // keyword here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:531,Performance,perform,perform,531,"// We performed name lookup into the current instantiation, and there were; // dependent bases, so we treat this result the same way as any other; // dependent nested-name-specifier.; // C++ [temp.res]p2:; // A name used in a template declaration or definition and that is; // dependent on a template-parameter is assumed not to name a type; // unless the applicable name lookup finds a type name or the name is; // qualified by the keyword typename.; //; // FIXME: If the next token is '<', we might want to ask the parser to; // perform some heroics to see if we actually have a; // template-argument-list, which would indicate a missing 'template'; // keyword here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:50,Integrability,inject,injected-class-name,50,"// C++ [temp.local]p3:; // A lookup that finds an injected-class-name (10.2) can result in an; // ambiguity in certain cases (for example, if it is found in more than; // one base class). If all of the injected-class-names that are found; // refer to specializations of the same class template, and if the name; // is followed by a template-argument-list, the reference refers to the; // class template itself and not a specialization thereof, and is not; // ambiguous.; //; // This filtering can make an ambiguous result into an unambiguous one,; // so try again after filtering out template names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:202,Integrability,inject,injected-class-names,202,"// C++ [temp.local]p3:; // A lookup that finds an injected-class-name (10.2) can result in an; // ambiguity in certain cases (for example, if it is found in more than; // one base class). If all of the injected-class-names that are found; // refer to specializations of the same class template, and if the name; // is followed by a template-argument-list, the reference refers to the; // class template itself and not a specialization thereof, and is not; // ambiguous.; //; // This filtering can make an ambiguous result into an unambiguous one,; // so try again after filtering out template names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:50,Security,inject,injected-class-name,50,"// C++ [temp.local]p3:; // A lookup that finds an injected-class-name (10.2) can result in an; // ambiguity in certain cases (for example, if it is found in more than; // one base class). If all of the injected-class-names that are found; // refer to specializations of the same class template, and if the name; // is followed by a template-argument-list, the reference refers to the; // class template itself and not a specialization thereof, and is not; // ambiguous.; //; // This filtering can make an ambiguous result into an unambiguous one,; // so try again after filtering out template names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:202,Security,inject,injected-class-names,202,"// C++ [temp.local]p3:; // A lookup that finds an injected-class-name (10.2) can result in an; // ambiguity in certain cases (for example, if it is found in more than; // one base class). If all of the injected-class-names that are found; // refer to specializations of the same class template, and if the name; // is followed by a template-argument-list, the reference refers to the; // class template itself and not a specialization thereof, and is not; // ambiguous.; //; // This filtering can make an ambiguous result into an unambiguous one,; // so try again after filtering out template names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:40,Availability,error,error,40,// Diagnose the ambiguity and return an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:86,Performance,perform,perform,86,"// Function templates always go through overload resolution, at which; // point we'll perform the various checks (e.g., accessibility) we need; // to based on which function we selected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:120,Security,access,accessibility,120,"// Function templates always go through overload resolution, at which; // point we'll perform the various checks (e.g., accessibility) we need; // to based on which function we selected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Integrability,Interface,Interface,3,"// Interface. <something> is parsed as a property reference expression.; // Just return ""unknown"" as a fall-through for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:160,Security,access,accesses,160,"// If we already know which single declaration is referenced, just annotate; // that declaration directly. Defer resolving even non-overloaded class; // member accesses, as we need to defer certain access checks until we know; // the context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:198,Security,access,access,198,"// If we already know which single declaration is referenced, just annotate; // that declaration directly. Defer resolving even non-overloaded class; // member accesses, as we need to defer certain access checks until we know; // the context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:32,Security,access,access,32,"// For an implicit class member access, transform the result into a member; // access expression if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:79,Security,access,access,79,"// For an implicit class member access, transform the result into a member; // access expression if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:267,Modifiability,variab,variable,267,"// C++0x [basic.lookup.unqual]p13:; // A name used in the definition of a static data member of class; // X (after the qualified-id of the static member) is looked up as; // if the name was used in a member function of X.; // C++0x [basic.lookup.unqual]p14:; // If a variable member of a namespace is defined outside of the; // scope of its namespace then any name used in the definition of; // the variable member (after the declarator-id) is looked up as; // if the definition of the variable member occurred in its; // namespace.; // Both of these imply that we should push a scope whose context; // is the semantic context of the declaration. We can't use; // PushDeclContext here because that context is not necessarily; // lexically contained in the current context. Fortunately,; // the containing scope should have the appropriate information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:399,Modifiability,variab,variable,399,"// C++0x [basic.lookup.unqual]p13:; // A name used in the definition of a static data member of class; // X (after the qualified-id of the static member) is looked up as; // if the name was used in a member function of X.; // C++0x [basic.lookup.unqual]p14:; // If a variable member of a namespace is defined outside of the; // scope of its namespace then any name used in the definition of; // the variable member (after the declarator-id) is looked up as; // if the definition of the variable member occurred in its; // namespace.; // Both of these imply that we should push a scope whose context; // is the semantic context of the declaration. We can't use; // PushDeclContext here because that context is not necessarily; // lexically contained in the current context. Fortunately,; // the containing scope should have the appropriate information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:486,Modifiability,variab,variable,486,"// C++0x [basic.lookup.unqual]p13:; // A name used in the definition of a static data member of class; // X (after the qualified-id of the static member) is looked up as; // if the name was used in a member function of X.; // C++0x [basic.lookup.unqual]p14:; // If a variable member of a namespace is defined outside of the; // scope of its namespace then any name used in the definition of; // the variable member (after the declarator-id) is looked up as; // if the definition of the variable member occurred in its; // namespace.; // Both of these imply that we should push a scope whose context; // is the semantic context of the declaration. We can't use; // PushDeclContext here because that context is not necessarily; // lexically contained in the current context. Fortunately,; // the containing scope should have the appropriate information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:43,Safety,safe,safety,43,// Switch back to the lexical context. The safety of this is; // enforced by an assert in EnterDeclaratorContext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:80,Testability,assert,assert,80,// Switch back to the lexical context. The safety of this is; // enforced by an assert in EnterDeclaratorContext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:547,Integrability,depend,dependent,547,"// C++20 [temp.local]p7:; // In the definition of a member of a class template that appears outside; // of the class template definition, the name of a member of the class; // template hides the name of a template-parameter of any enclosing class; // templates (but not a template-parameter of the member if the member is a; // class or function template).; // C++20 [temp.local]p9:; // In the definition of a class template or in the definition of a member; // of such a template that appears outside of the template definition, for; // each non-dependent base class (13.8.2.1), if the name of the base class; // or the name of a member of the base class is the same as the name of a; // template-parameter, the base class name or member name hides the; // template-parameter name (6.4.10).; //; // This means that a template parameter scope should be searched immediately; // after searching the DeclContext for which it is a template parameter; // scope. For example, for; // template<typename T> template<typename U> template<typename V>; // void N::A<T>::B<U>::f(...); // we search V then B<U> (and base classes) then U then A<T> (and base; // classes) then T then N then ::.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:145,Integrability,rout,routine,145,"/// Determine whether overloading is allowed for a new function; /// declaration considering prior declarations of the same name.; ///; /// This routine determines whether overloading is possible, not; /// whether a new declaration actually overloads a previous one.; /// It will return true in C++ (where overloads are alway permitted); /// or, as a C extension, when either the new declaration or a; /// previous one is declared with the 'overloadable' attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,Integrability,interface,interface,11,"// [module.interface]p7:; // A declaration is attached to a module as follows:; // - If the declaration is a non-dependent friend declaration that nominates a; // function with a declarator-id that is a qualified-id or template-id or that; // nominates a class other than with an elaborated-type-specifier with neither; // a nested-name-specifier nor a simple-template-id, it is attached to the; // module to which the friend is attached ([basic.link]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:113,Integrability,depend,dependent,113,"// [module.interface]p7:; // A declaration is attached to a module as follows:; // - If the declaration is a non-dependent friend declaration that nominates a; // function with a declarator-id that is a qualified-id or template-id or that; // nominates a class other than with an elaborated-type-specifier with neither; // a nested-name-specifier nor a simple-template-id, it is attached to the; // module to which the friend is attached ([basic.link]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:353,Usability,simpl,simple-template-id,353,"// [module.interface]p7:; // A declaration is attached to a module as follows:; // - If the declaration is a non-dependent friend declaration that nominates a; // function with a declarator-id that is a qualified-id or template-id or that; // nominates a class other than with an elaborated-type-specifier with neither; // a nested-name-specifier nor a simple-template-id, it is attached to the; // module to which the friend is attached ([basic.link]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:91,Integrability,interface,interface,91,// A module implementation unit has visibility of the decls in its; // implicitly imported interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,Integrability,interface,interface,11,// [module.interface]p6:; // A redeclaration of an entity X is implicitly exported if X was introduced by; // an exported declaration; otherwise it shall not be exported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,Integrability,interface,interface,11,// [module.interface]p1:; // An export-declaration shall inhabit a namespace scope.; //; // So it is meaningless to talk about redeclaration which is not at namespace; // scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:5,Integrability,wrap,wrapper,5,// A wrapper function for checking the semantic restrictions of; // a redeclaration within a module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:202,Modifiability,variab,variable,202,"// Check the redefinition in C++20 Modules.; //; // [basic.def.odr]p14:; // For any definable item D with definitions in multiple translation units,; // - if D is a non-inline non-templated function or variable, or; // - if the definitions in different translation units do not satisfy the; // following requirements,; // the program is ill-formed; a diagnostic is required only if the definable; // item is attached to a named module and a prior definition is reachable at; // the point where a later definition occurs.; // - Each such definition shall not be attached to a named module; // ([module.unit]).; // - Each such definition shall consist of the same sequence of tokens, ...; // ...; //; // Return true if the redefinition is not allowed. Return false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:686,Safety,detect,detect,686,"// We only checks for named modules here. The header like modules is skipped.; // FIXME: This is not right if we import the header like modules in the module; // purview.; //; // For example, assuming ""header.h"" provides definition for `D`.; // ```C++; // //--- M.cppm; // export module M;; // import ""header.h""; // or #include ""header.h"" but import it by clang modules; // actually.; //; // //--- Use.cpp; // import M;; // import ""header.h""; // or uses clang modules.; // ```; //; // In this case, `D` has multiple definitions in multiple TU (M.cppm and; // Use.cpp) and `D` is attached to a named module `M`. The compiler should; // reject it. But the current implementation couldn't detect the case since we; // don't record the information about the importee modules.; //; // But this might not be painful in practice. Since the design of C++20 Named; // Modules suggests us to use headers in global module fragment instead of; // module purview.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:35,Security,access,access,35,// FIXME: Should check for private access too but access is set after we get; // the decl here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:50,Security,access,access,50,// FIXME: Should check for private access too but access is set after we get; // the decl here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:27,Modifiability,refactor,refactored,27,// FIXME: This needs to be refactored; some other isInMainFile users want; // these semantics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:25,Modifiability,variab,variables,25,"// Constants and utility variables are defined in headers with internal; // linkage; don't warn. (Unlike functions, there isn't a convenient marker; // like ""inline"".)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:103,Modifiability,variab,variable,103,"// For a decomposition declaration, warn if none of the bindings are; // referenced, instead of if the variable itself is referenced (which; // it is, by the bindings' expressions).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:7,Integrability,depend,dependent,7,"// For dependent types, the diagnostic is deferred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:42,Modifiability,variab,variable,42,// White-list anything that isn't a local variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:24,Modifiability,variab,variables,24,"// Types of valid local variables should be complete, so this should succeed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:22,Modifiability,variab,variables,22,// Warn for reference variables whose initializtion performs lifetime; // extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:52,Performance,perform,performs,52,// Warn for reference variables whose initializtion performs lifetime; // extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:76,Integrability,depend,dependent,76,"// If we failed to complete the type for some reason, or if the type is; // dependent, don't diagnose the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,Modifiability,variab,variable,106,"// If we failed to complete the type for some reason, or if the type is; // dependent, don't diagnose the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:87,Integrability,depend,dependent,87,// Suppress the warning if the constructor is unresolved because; // its arguments are dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:15,Modifiability,variab,variables,15,"// In C++, `_` variables behave as if they were maybe_unused",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:48,Modifiability,variab,variables,48,"// Don't warn about __block Objective-C pointer variables, as they might; // be assigned in the block but not used elsewhere for the purpose of lifetime; // extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:118,Deployability,release,releases,118,"// Don't warn about Objective-C pointer variables with precise lifetime; // semantics; they can be used to ensure ARC releases the object at a known; // time, which may mean assignment but no other references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:40,Modifiability,variab,variables,40,"// Don't warn about Objective-C pointer variables with precise lifetime; // semantics; they can be used to ensure ARC releases the object at a known; // time, which may mean assignment but no other references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:19,Modifiability,variab,variables,19,// Diagnose unused variables in this scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:188,Deployability,update,updated,188,"/// Look for an Objective-C class in the translation unit.; ///; /// \param Id The name of the Objective-C class we're looking for. If; /// typo-correction fixes this name, the Id will be updated; /// to the fixed name.; ///; /// \param IdLoc The location of the name in the translation unit.; ///; /// \param DoTypoCorrection If true, this routine will attempt typo correction; /// if there is no class with the given name.; ///; /// \returns The declaration of the named Objective-C class, or NULL if the; /// class could not be found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:341,Integrability,rout,routine,341,"/// Look for an Objective-C class in the translation unit.; ///; /// \param Id The name of the Objective-C class we're looking for. If; /// typo-correction fixes this name, the Id will be updated; /// to the fixed name.; ///; /// \param IdLoc The location of the name in the translation unit.; ///; /// \param DoTypoCorrection If true, this routine will attempt typo correction; /// if there is no class with the given name.; ///; /// \returns The declaration of the named Objective-C class, or NULL if the; /// class could not be found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Performance,Perform,Perform,3,"// Perform typo correction at the given location, but only if we; // find an Objective-C class name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:8,Integrability,rout,routine,8,"// This routine must always return a class definition, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:122,Integrability,rout,routine,122,"/// getNonFieldDeclScope - Retrieves the innermost scope, starting; /// from S, where a non-field would be declared. This routine copes; /// with the difference between C and C++ scoping rules in structs and; /// unions. For example, the following code is well-formed in C but; /// ill-formed in C++:; /// @code; /// struct S6 {; /// enum { BAR } e;; /// };; ///; /// void test_S6() {; /// struct S6 a;; /// a.e = BAR;; /// }; /// @endcode; /// For the declaration of BAR, this routine will return a different; /// scope. The scope S will be the scope of the unnamed enumeration; /// within S6. In C++, this routine will return the scope associated; /// with S6, because the enumeration's scope is a transparent; /// context but structures can contain non-field names. In C, this; /// routine will return the translation unit scope, since the; /// enumeration's scope is a transparent context and structures cannot; /// contain non-field names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:478,Integrability,rout,routine,478,"/// getNonFieldDeclScope - Retrieves the innermost scope, starting; /// from S, where a non-field would be declared. This routine copes; /// with the difference between C and C++ scoping rules in structs and; /// unions. For example, the following code is well-formed in C but; /// ill-formed in C++:; /// @code; /// struct S6 {; /// enum { BAR } e;; /// };; ///; /// void test_S6() {; /// struct S6 a;; /// a.e = BAR;; /// }; /// @endcode; /// For the declaration of BAR, this routine will return a different; /// scope. The scope S will be the scope of the unnamed enumeration; /// within S6. In C++, this routine will return the scope associated; /// with S6, because the enumeration's scope is a transparent; /// context but structures can contain non-field names. In C, this; /// routine will return the translation unit scope, since the; /// enumeration's scope is a transparent context and structures cannot; /// contain non-field names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:608,Integrability,rout,routine,608,"/// getNonFieldDeclScope - Retrieves the innermost scope, starting; /// from S, where a non-field would be declared. This routine copes; /// with the difference between C and C++ scoping rules in structs and; /// unions. For example, the following code is well-formed in C but; /// ill-formed in C++:; /// @code; /// struct S6 {; /// enum { BAR } e;; /// };; ///; /// void test_S6() {; /// struct S6 a;; /// a.e = BAR;; /// }; /// @endcode; /// For the declaration of BAR, this routine will return a different; /// scope. The scope S will be the scope of the unnamed enumeration; /// within S6. In C++, this routine will return the scope associated; /// with S6, because the enumeration's scope is a transparent; /// context but structures can contain non-field names. In C, this; /// routine will return the translation unit scope, since the; /// enumeration's scope is a transparent context and structures cannot; /// contain non-field names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:785,Integrability,rout,routine,785,"/// getNonFieldDeclScope - Retrieves the innermost scope, starting; /// from S, where a non-field would be declared. This routine copes; /// with the difference between C and C++ scoping rules in structs and; /// unions. For example, the following code is well-formed in C but; /// ill-formed in C++:; /// @code; /// struct S6 {; /// enum { BAR } e;; /// };; ///; /// void test_S6() {; /// struct S6 a;; /// a.e = BAR;; /// }; /// @endcode; /// For the declaration of BAR, this routine will return a different; /// scope. The scope S will be the scope of the unnamed enumeration; /// within S6. In C++, this routine will return the scope associated; /// with S6, because the enumeration's scope is a transparent; /// context but structures can contain non-field names. In C, this; /// routine will return the translation unit scope, since the; /// enumeration's scope is a transparent context and structures cannot; /// contain non-field names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:38,Modifiability,variab,variably-modified,38,// Must not redefine a typedef with a variably-modified type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:252,Availability,error,error,252,"/// MergeTypedefNameDecl - We just parsed a typedef 'New' which has the; /// same name and scope as a previous declaration 'Old'. Figure out; /// how to resolve this situation, merging decls or emitting; /// diagnostics as appropriate. If there was an error, set New to be invalid.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Deployability,Install,Install,3,"// Install the built-in type for 'id', ignoring the current definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Deployability,Install,Install,3,"// Install the built-in type for 'Class', ignoring the current definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Deployability,Install,Install,3,"// Install the built-in type for 'SEL', ignoring the current definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,Availability,error,error,106,"// If we have a redefinition of a typedef in C, emit a warning. This warning; // is normally mapped to an error, but can be controlled with; // -Wtypedef-redefinition. If either the original or the redefinition is; // in a system header, don't emit this for compatibility with GCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:51,Integrability,depend,dependent,51,"// FIXME: We have no way of representing inherited dependent alignments; // in a case like:; // template<int A, int B> struct alignas(A) X;; // template<int A, int B> struct alignas(B) X {};; // For now, we just ignore any alignas attributes which are not on the; // definition in such a case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:41,Modifiability,inherit,inherited,41,"// FIXME: We have no way of representing inherited dependent alignments; // in a case like:; // template<int A, int B> struct alignas(A) X;; // template<int A, int B> struct alignas(B) X {};; // For now, we just ignore any alignas attributes which are not on the; // definition in such a case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:256,Testability,log,logic,256,"// This function copies an attribute Attr from a previous declaration to the; // new declaration D if the new declaration doesn't itself have that attribute; // yet or if that attribute allows duplicates.; // If you're adding a new attribute that requires logic different from; // ""use explicit attribute on decl if present, else use attribute from; // previous decl"", for example if the attribute needs to be consistent; // between redeclarations, you need to call a custom merge function here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:42,Security,validat,validating,42,// regular attr merging will take care of validating this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:60,Modifiability,variab,variables,60,"// Don't warn about applying selectany to implicitly inline variables.; // Older compilers and language modes would require the use of selectany; // to make such variables inline, and it would have no effect if we; // honored it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:162,Modifiability,variab,variables,162,"// Don't warn about applying selectany to implicitly inline variables.; // Older compilers and language modes would require the use of selectany; // to make such variables inline, and it would have no effect if we; // honored it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:45,Availability,error,error,45,"// extern constinit int a;; // int a = 0; // error (missing 'constinit'), accepted as extension",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:45,Availability,error,error,45,// int a = 0;; // constinit extern int a; // error (missing 'constinit'),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:94,Modifiability,variab,variable,94,"// [dcl.constinit]p1:; // If the [constinit] specifier is applied to any declaration of a; // variable, it shall be applied to the initializing declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:53,Modifiability,inherit,inherit,53,"// This is the initializing declaration. If it would inherit 'constinit',; // that's ill-formed. (Note that we do not apply this to the attribute; // form).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:48,Energy Efficiency,allocate,allocated,48,// Ensure that any moving of objects within the allocated map is done before; // we process them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:33,Availability,avail,availability,33,// Ignore deprecated/unavailable/availability attributes if requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:19,Integrability,depend,depend,19,// C++11 [dcl.attr.depend]p2:; // The first declaration of a function shall specify the; // carries_dependency attribute for its declarator-id if any declaration; // of the function specifies the carries_dependency attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:48,Energy Efficiency,allocate,allocated,48,// Ensure that any moving of objects within the allocated map is; // done before we process them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:24,Integrability,depend,dependent,24,// Don't try to compare dependent sized array,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:430,Modifiability,variab,variable,430,"// C++11 [basic.scope.declarative]p4:; // Given a set of declarations in a single declarative region, each of; // which specifies the same unqualified name,; // -- they shall all refer to the same entity, or all refer to functions; // and function templates; or; // -- exactly one declaration shall declare a class name or enumeration; // name that is not a typedef name and the other declarations shall all; // refer to the same variable or enumerator, or all refer to functions; // and function templates; in this case the class name or enumeration; // name is hidden (3.3.10).; // C++11 [namespace.udecl]p14:; // If a function declaration in namespace scope or block scope has the; // same name and the same parameter-type-list as a function introduced; // by a using-declaration, and the declarations do not declare the same; // function, the program is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:34,Deployability,update,update,34,"// The only case where we need to update the DeclContext is when; // redeclaration lookup for a qualified name finds a declaration; // in an inline namespace within the context named by the qualifier:; //; // inline namespace N { int f(); }; // int ::f(); // Sema DC needs adjusting from :: to N::.; //; // For unqualified declarations, the semantic context *can* change; // along the redeclaration chain (for local extern declarations,; // extern ""C"" declarations, and friend declarations in particular).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:512,Availability,error,error,512,"/// MergeFunctionDecl - We just parsed a function 'New' from; /// declarator D which has the same name and scope as a previous; /// declaration 'Old'. Figure out how to resolve this situation,; /// merging decls or emitting diagnostics as appropriate.; ///; /// In C++, New and Old must be declarations that are not; /// overloaded. Use IsOverload to determine whether New and Old are; /// overloaded, and to select the Old declaration that New should be; /// merged with.; ///; /// Returns true if there was an error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:102,Deployability,update,update,102,"// If the old declaration was found in an inline namespace and the new; // declaration was qualified, update the DeclContext to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:343,Testability,test,test,343,"// If a function is first declared with a calling convention, but is later; // declared or defined without one, all following decls assume the calling; // convention of the first.; //; // It's OK if a function is first declared without a calling convention,; // but is later declared or defined with the default calling convention.; //; // To test if either decl has an explicit calling convention, we look for; // AttributedType sugar nodes on the type as written. If they are missing or; // were canonicalized away, we assume the calling convention was implicit.; //; // Note also that we DO NOT return at this point, because we still have; // other tests to run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:652,Testability,test,tests,652,"// If a function is first declared with a calling convention, but is later; // declared or defined without one, all following decls assume the calling; // convention of the first.; //; // It's OK if a function is first declared without a calling convention,; // but is later declared or defined with the default calling convention.; //; // To test if either decl has an explicit calling convention, we look for; // AttributedType sugar nodes on the type as written. If they are missing or; // were canonicalized away, we assume the calling convention was implicit.; //; // Note also that we DO NOT return at this point, because we still have; // other tests to run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Modifiability,Inherit,Inherit,3,// Inherit the CC from the previous declaration if it was specified; // there but not here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:168,Availability,error,error,168,// MSVC allows explicit template specialization at class scope:; // 2 CXXMethodDecls referring to the same function will be injected.; // We don't want a redeclaration error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:124,Integrability,inject,injected,124,// MSVC allows explicit template specialization at class scope:; // 2 CXXMethodDecls referring to the same function will be injected.; // We don't want a redeclaration error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:124,Security,inject,injected,124,// MSVC allows explicit template specialization at class scope:; // 2 CXXMethodDecls referring to the same function will be injected.; // We don't want a redeclaration error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:400,Deployability,update,updates,400,"// C++1z [over.load]p2; // Certain function declarations cannot be overloaded:; // -- Function declarations that differ only in the return type,; // the exception specification, or both cannot be overloaded.; // Check the exception specifications match. This may recompute the type of; // both Old and New if it resolved exception specifications, so grab the; // types again after this. Because this updates the type, we do this before; // any of the other checks below, which may update the ""de facto"" NewQType; // but do not necessarily update the type of New.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:481,Deployability,update,update,481,"// C++1z [over.load]p2; // Certain function declarations cannot be overloaded:; // -- Function declarations that differ only in the return type,; // the exception specification, or both cannot be overloaded.; // Check the exception specifications match. This may recompute the type of; // both Old and New if it resolved exception specifications, so grab the; // types again after this. Because this updates the type, we do this before; // any of the other checks below, which may update the ""de facto"" NewQType; // but do not necessarily update the type of New.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:539,Deployability,update,update,539,"// C++1z [over.load]p2; // Certain function declarations cannot be overloaded:; // -- Function declarations that differ only in the return type,; // the exception specification, or both cannot be overloaded.; // Check the exception specifications match. This may recompute the type of; // both Old and New if it resolved exception specifications, so grab the; // types again after this. Because this updates the type, we do this before; // any of the other checks below, which may update the ""de facto"" NewQType; // but do not necessarily update the type of New.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:15,Performance,load,load,15,"// C++1z [over.load]p2; // Certain function declarations cannot be overloaded:; // -- Function declarations that differ only in the return type,; // the exception specification, or both cannot be overloaded.; // Check the exception specifications match. This may recompute the type of; // both Old and New if it resolved exception specifications, so grab the; // types again after this. Because this updates the type, we do this before; // any of the other checks below, which may update the ""de facto"" NewQType; // but do not necessarily update the type of New.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:19,Integrability,depend,depend,19,// C++11 [dcl.attr.depend]p2:; // The first declaration of a function shall specify the; // carries_dependency attribute for its declarator-id if any declaration; // of the function specifies the carries_dependency attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:169,Modifiability,extend,extended,169,// (C++98 8.3.5p3):; // All declarations for a function shall agree exactly in both the; // return type and the parameter-type-list.; // We also want to respect all the extended bits except noreturn.; // noreturn should now match unless the old type info didn't have it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:38,Integrability,depend,dependent,38,"// If the types are imprecise (due to dependent constructs in friends or; // local extern declarations), it's OK if they differ. We'll check again; // during instantiation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:537,Integrability,depend,depending,537,"// GNU C permits a K&R definition to follow a prototype declaration; // if the declared types of the parameters in the K&R definition; // match the types in the prototype declaration, even when the; // promoted types of the parameters from the K&R definition differ; // from the types in the prototype. GCC then keeps the types from; // the prototype.; //; // If a variadic prototype is followed by a non-variadic K&R definition,; // the K&R definition becomes variadic. This is sort of an edge case, but; // it's legal per the standard depending on how you read C99 6.7.5.3p15 and; // C99 6.9.1p8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,Integrability,rout,routine,106,"/// Completes the merge of two function declarations that are; /// known to be compatible.; ///; /// This routine handles the merging of attributes and other; /// properties of function declarations from the old declaration to; /// the new declaration, once we know that New is in fact a; /// redeclaration of Old.; ///; /// \returns false",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:123,Deployability,update,update,123,"// Merge the function types so the we get the composite types for the return; // and argument types. Per C11 6.2.7/4, only update the type if the old decl; // was visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:36,Modifiability,variab,variable,36,"/// MergeVarDeclTypes - We parsed a variable 'New' which has the same name and; /// scope as a previous declaration 'Old'. Figure out how to merge their types,; /// emitting diagnostics as appropriate.; ///; /// Declarations using the auto type specifier (C++ [decl.spec.auto]) call back; /// to here in AddInitializerToDecl. We can't check them before the initializer; /// is attached.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:20,Modifiability,variab,variable,20,"// We are merging a variable declaration New into Old. If it has an array; // bound, and that bound differs from Old's bound, we should diagnose the; // mismatch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:112,Modifiability,inherit,inherit,112,"// FIXME: Check visibility. New is hidden but has a complete type. If New; // has no array bound, it should not inherit one from Old, if Old is not; // visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:56,Integrability,depend,dependent,56,"// It's OK if we couldn't merge types if either type is dependent, for a; // block-scope variable. In other cases (static data members of class; // templates, variable templates, ...), we require the types to be; // equivalent.; // FIXME: The C++ standard doesn't say anything about this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:89,Modifiability,variab,variable,89,"// It's OK if we couldn't merge types if either type is dependent, for a; // block-scope variable. In other cases (static data members of class; // templates, variable templates, ...), we require the types to be; // equivalent.; // FIXME: The C++ standard doesn't say anything about this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:159,Modifiability,variab,variable,159,"// It's OK if we couldn't merge types if either type is dependent, for a; // block-scope variable. In other cases (static data members of class; // templates, variable templates, ...), we require the types to be; // equivalent.; // FIXME: The C++ standard doesn't say anything about this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:23,Integrability,depend,dependent,23,"// If the old type was dependent, we can't merge with it, so the new type; // becomes dependent for now. We'll reproduce the original type when we; // instantiate the TypeSourceInfo for the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:86,Integrability,depend,dependent,86,"// If the old type was dependent, we can't merge with it, so the new type; // becomes dependent for now. We'll reproduce the original type when we; // instantiate the TypeSourceInfo for the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:190,Modifiability,variab,variable,190,"// If the old type was dependent, we can't merge with it, so the new type; // becomes dependent for now. We'll reproduce the original type when we; // instantiate the TypeSourceInfo for the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:18,Deployability,update,update,18,// Don't actually update the type on the new declaration if the old; // declaration was an extern declaration in a different scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:328,Modifiability,variab,variable,328,"// C11 6.2.7p4:; // For an identifier with internal or external linkage declared; // in a scope in which a prior declaration of that identifier is; // visible, if the prior declaration specifies internal or; // external linkage, the type of the identifier at the later; // declaration becomes the composite type.; //; // If the variable isn't visible, we do not merge with its type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:36,Modifiability,variab,variable,36,"/// MergeVarDecl - We just parsed a variable 'New' which has the same name; /// and scope as a previous declaration 'Old'. Figure out how to resolve this; /// situation, merging decls or emitting diagnostics as appropriate.; ///; /// Tentative definition rules (C99 6.9.2p2) are checked by; /// FinalizeDeclaratorGroup. Unfortunately, we can't analyze tentative; /// definitions here, since the initializer hasn't been attached.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:34,Modifiability,variab,variable,34,// Verify the old decl was also a variable or variable template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:46,Modifiability,variab,variable,46,// Verify the old decl was also a variable or variable template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:102,Deployability,update,update,102,"// If the old declaration was found in an inline namespace and the new; // declaration was qualified, update the DeclContext to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:31,Modifiability,variab,variable,31,// Warn if an already-declared variable is made a weak_import in a subsequent; // declaration,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Modifiability,Variab,Variables,3,// Variables with external linkage are analyzed in FinalizeDeclaratorGroup.; // FIXME: The test for external storage here seems wrong? We still; // need to check for mismatches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:91,Testability,test,test,91,// Variables with external linkage are analyzed in FinalizeDeclaratorGroup.; // FIXME: The test for external storage here seems wrong? We still; // need to check for mismatches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:54,Modifiability,variab,variable,54,"// C++1z [dcl.fcn.spec]p4:; // If the definition of a variable appears in a translation unit before; // its first declaration as inline, the program is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:35,Modifiability,variab,variable,35,"// If this redeclaration makes the variable inline, we may need to add it to; // UndefinedButUsed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:44,Modifiability,variab,variable,44,"// Do not allow redeclaration to change the variable between requiring; // static and dynamic initialization.; // FIXME: GCC allows this, but uses the TLS keyword on the first; // declaration to determine the kind. Do we need to be compatible here?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Modifiability,Inherit,Inherit,3,// Inherit access appropriately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,Security,access,access,11,// Inherit access appropriately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:16,Availability,error,errors,16,"// Redefinition errors with modules are common with non modular mapped; // headers, example: a non-modular header H in module A that also gets; // included directly in a TU. Pointing twice to the same header/definition; // is confusing, try to get better diagnostics when modules is on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:105,Availability,error,error,105,// Is it the same file and same offset? Provide more information on why; // this leads to a redefinition error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:96,Modifiability,variab,variable,96,/// We've just determined that \p Old and \p New both appear to be definitions; /// of the same variable. Either diagnose or fix the problem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:262,Integrability,depend,depending,262,"// The MS ABI changed between VS2013 and VS2015 with regard to numbers used to; // disambiguate entities defined in different scopes.; // While the VS2015 ABI fixes potential miscompiles, it is also breaks; // compatibility.; // We will pick our mangling number depending on which version of MSVC is being; // targeted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:336,Safety,avoid,avoid,336,"// C++ [dcl.typedef]p9: [P1766R1, applied as DR]; // An unnamed class with a typedef name for linkage purposes shall [be; // C-like].; //; // FIXME: Also diagnose if we've already computed the linkage. That ideally; // shouldn't happen, but there are constructs that the language rule doesn't; // disallow for which we can't reasonably avoid computing linkage early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:22,Availability,error,error,22,// We probably had an error,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:111,Modifiability,variab,variables,111,// C++0x [dcl.constexpr]p1: constexpr can only be applied to declarations; // and definitions of functions and variables.; // C++2a [dcl.constexpr]p1: The consteval specifier shall be applied only to; // the declaration of a function or function template,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:34,Availability,error,error,34,// Don't emit warnings after this error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:76,Integrability,rout,routines,76,"// If we're dealing with a decl but not a TagDecl, assume that; // whatever routines created it handled the friendship aspect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:47,Availability,error,error,47,// Skip all the checks below if we have a type error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,Availability,redundant,redundant,106,"// In C, we allow this as a (popular) extension / bug. Don't bother; // producing further diagnostics for redundant qualifiers after this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,Safety,redund,redundant,106,"// In C, we allow this as a (popular) extension / bug. Don't bother; // producing further diagnostics for redundant qualifiers after this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:139,Availability,error,error,139,"// Since mutable is not a viable storage class specifier in C, there is; // no reason to treat it as an extension. Instead, diagnose as an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:21,Integrability,inject,inject,21,/// We are trying to inject an anonymous member into the given scope;; /// check if there's an existing declaration that can't be overloaded.; ///; /// \return true if this is a forbidden redeclaration,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:21,Security,inject,inject,21,/// We are trying to inject an anonymous member into the given scope;; /// check if there's an existing declaration that can't be overloaded.; ///; /// \return true if this is a forbidden redeclaration,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:46,Security,validat,validated,46,// This function can be parsed before we have validated the; // structure as an anonymous struct,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:4,Integrability,Inject,InjectAnonymousStructOrUnionMembers,4,"/// InjectAnonymousStructOrUnionMembers - Inject the members of the; /// anonymous struct or union AnonRecord into the owning context Owner; /// and scope S. This routine will be invoked just after we realize; /// that an unnamed union or struct is actually an anonymous union or; /// struct, e.g.,; ///; /// @code; /// union {; /// int i;; /// float f;; /// }; // InjectAnonymousStructOrUnionMembers called here to inject i and; /// // f into the surrounding scope.x; /// @endcode; ///; /// This routine is recursive, injecting the names of nested anonymous; /// structs/unions into the owning context and scope as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:42,Integrability,Inject,Inject,42,"/// InjectAnonymousStructOrUnionMembers - Inject the members of the; /// anonymous struct or union AnonRecord into the owning context Owner; /// and scope S. This routine will be invoked just after we realize; /// that an unnamed union or struct is actually an anonymous union or; /// struct, e.g.,; ///; /// @code; /// union {; /// int i;; /// float f;; /// }; // InjectAnonymousStructOrUnionMembers called here to inject i and; /// // f into the surrounding scope.x; /// @endcode; ///; /// This routine is recursive, injecting the names of nested anonymous; /// structs/unions into the owning context and scope as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:163,Integrability,rout,routine,163,"/// InjectAnonymousStructOrUnionMembers - Inject the members of the; /// anonymous struct or union AnonRecord into the owning context Owner; /// and scope S. This routine will be invoked just after we realize; /// that an unnamed union or struct is actually an anonymous union or; /// struct, e.g.,; ///; /// @code; /// union {; /// int i;; /// float f;; /// }; // InjectAnonymousStructOrUnionMembers called here to inject i and; /// // f into the surrounding scope.x; /// @endcode; ///; /// This routine is recursive, injecting the names of nested anonymous; /// structs/unions into the owning context and scope as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:365,Integrability,Inject,InjectAnonymousStructOrUnionMembers,365,"/// InjectAnonymousStructOrUnionMembers - Inject the members of the; /// anonymous struct or union AnonRecord into the owning context Owner; /// and scope S. This routine will be invoked just after we realize; /// that an unnamed union or struct is actually an anonymous union or; /// struct, e.g.,; ///; /// @code; /// union {; /// int i;; /// float f;; /// }; // InjectAnonymousStructOrUnionMembers called here to inject i and; /// // f into the surrounding scope.x; /// @endcode; ///; /// This routine is recursive, injecting the names of nested anonymous; /// structs/unions into the owning context and scope as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:416,Integrability,inject,inject,416,"/// InjectAnonymousStructOrUnionMembers - Inject the members of the; /// anonymous struct or union AnonRecord into the owning context Owner; /// and scope S. This routine will be invoked just after we realize; /// that an unnamed union or struct is actually an anonymous union or; /// struct, e.g.,; ///; /// @code; /// union {; /// int i;; /// float f;; /// }; // InjectAnonymousStructOrUnionMembers called here to inject i and; /// // f into the surrounding scope.x; /// @endcode; ///; /// This routine is recursive, injecting the names of nested anonymous; /// structs/unions into the owning context and scope as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:497,Integrability,rout,routine,497,"/// InjectAnonymousStructOrUnionMembers - Inject the members of the; /// anonymous struct or union AnonRecord into the owning context Owner; /// and scope S. This routine will be invoked just after we realize; /// that an unnamed union or struct is actually an anonymous union or; /// struct, e.g.,; ///; /// @code; /// union {; /// int i;; /// float f;; /// }; // InjectAnonymousStructOrUnionMembers called here to inject i and; /// // f into the surrounding scope.x; /// @endcode; ///; /// This routine is recursive, injecting the names of nested anonymous; /// structs/unions into the owning context and scope as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:519,Integrability,inject,injecting,519,"/// InjectAnonymousStructOrUnionMembers - Inject the members of the; /// anonymous struct or union AnonRecord into the owning context Owner; /// and scope S. This routine will be invoked just after we realize; /// that an unnamed union or struct is actually an anonymous union or; /// struct, e.g.,; ///; /// @code; /// union {; /// int i;; /// float f;; /// }; // InjectAnonymousStructOrUnionMembers called here to inject i and; /// // f into the surrounding scope.x; /// @endcode; ///; /// This routine is recursive, injecting the names of nested anonymous; /// structs/unions into the owning context and scope as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:4,Security,Inject,InjectAnonymousStructOrUnionMembers,4,"/// InjectAnonymousStructOrUnionMembers - Inject the members of the; /// anonymous struct or union AnonRecord into the owning context Owner; /// and scope S. This routine will be invoked just after we realize; /// that an unnamed union or struct is actually an anonymous union or; /// struct, e.g.,; ///; /// @code; /// union {; /// int i;; /// float f;; /// }; // InjectAnonymousStructOrUnionMembers called here to inject i and; /// // f into the surrounding scope.x; /// @endcode; ///; /// This routine is recursive, injecting the names of nested anonymous; /// structs/unions into the owning context and scope as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:42,Security,Inject,Inject,42,"/// InjectAnonymousStructOrUnionMembers - Inject the members of the; /// anonymous struct or union AnonRecord into the owning context Owner; /// and scope S. This routine will be invoked just after we realize; /// that an unnamed union or struct is actually an anonymous union or; /// struct, e.g.,; ///; /// @code; /// union {; /// int i;; /// float f;; /// }; // InjectAnonymousStructOrUnionMembers called here to inject i and; /// // f into the surrounding scope.x; /// @endcode; ///; /// This routine is recursive, injecting the names of nested anonymous; /// structs/unions into the owning context and scope as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:365,Security,Inject,InjectAnonymousStructOrUnionMembers,365,"/// InjectAnonymousStructOrUnionMembers - Inject the members of the; /// anonymous struct or union AnonRecord into the owning context Owner; /// and scope S. This routine will be invoked just after we realize; /// that an unnamed union or struct is actually an anonymous union or; /// struct, e.g.,; ///; /// @code; /// union {; /// int i;; /// float f;; /// }; // InjectAnonymousStructOrUnionMembers called here to inject i and; /// // f into the surrounding scope.x; /// @endcode; ///; /// This routine is recursive, injecting the names of nested anonymous; /// structs/unions into the owning context and scope as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:416,Security,inject,inject,416,"/// InjectAnonymousStructOrUnionMembers - Inject the members of the; /// anonymous struct or union AnonRecord into the owning context Owner; /// and scope S. This routine will be invoked just after we realize; /// that an unnamed union or struct is actually an anonymous union or; /// struct, e.g.,; ///; /// @code; /// union {; /// int i;; /// float f;; /// }; // InjectAnonymousStructOrUnionMembers called here to inject i and; /// // f into the surrounding scope.x; /// @endcode; ///; /// This routine is recursive, injecting the names of nested anonymous; /// structs/unions into the owning context and scope as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:519,Security,inject,injecting,519,"/// InjectAnonymousStructOrUnionMembers - Inject the members of the; /// anonymous struct or union AnonRecord into the owning context Owner; /// and scope S. This routine will be invoked just after we realize; /// that an unnamed union or struct is actually an anonymous union or; /// struct, e.g.,; ///; /// @code; /// union {; /// int i;; /// float f;; /// }; // InjectAnonymousStructOrUnionMembers called here to inject i and; /// // f into the surrounding scope.x; /// @endcode; ///; /// This routine is recursive, injecting the names of nested anonymous; /// structs/unions into the owning context and scope as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:44,Security,access,access,44,// That includes picking up the appropriate access specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:102,Availability,error,error,102,/// StorageClassSpecToVarDeclStorageClass - Maps a DeclSpec::SCS to; /// a VarDecl::StorageClass. Any error reporting is up to the caller:; /// illegal input values are mapped to SC_None.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:29,Availability,error,error,29,// Illegal SCSs map to None: error reporting is up to the caller.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Availability,Recover,Recover,3,// Recover by adding 'static'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Recover,Recover,3,// Recover by adding 'static'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Availability,Recover,Recover,3,// Recover by removing the storage specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Recover,Recover,3,// Recover by removing the storage specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:7,Security,access,access,7,// Any access specifier is fine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:379,Availability,error,error,379,"// C++ [dcl.dcl]p3:; // [If there are no declarators], and except for the declaration of an; // unnamed bit-field, the decl-specifier-seq shall introduce one or more; // names into the program; // C++ [class.mem]p2:; // each such member-declaration shall either declare at least one member; // name of the class or declare at least one unnamed bit-field; //; // For C this is an error even for a named struct, and is diagnosed elsewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Testability,Mock,Mock,3,// Mock up a declarator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:78,Availability,error,error,78,"// mutable can only appear on non-static class members, so it's always; // an error here",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:35,Modifiability,variab,variable,35,"// Default-initialize the implicit variable. This initialization will be; // trivial in almost all cases, except if a union member has an in-class; // initializer:; // union { int n = 0; };",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Integrability,Inject,Inject,3,// Inject the members of the anonymous struct/union into the owning; // context and into the identifier resolver chain for name lookup; // purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Security,Inject,Inject,3,// Inject the members of the anonymous struct/union into the owning; // context and into the identifier resolver chain for name lookup; // purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Testability,Mock,Mock,3,// Mock up a declarator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Integrability,Inject,Inject,3,// Inject the members of the anonymous struct into the current; // context and into the identifier resolver chain for name lookup; // purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Security,Inject,Inject,3,// Inject the members of the anonymous struct into the current; // context and into the identifier resolver chain for name lookup; // purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:20,Usability,guid,guide,20,// C++ [temp.deduct.guide]p3:; // The simple-template-id shall name a class template specialization.; // The template-name shall be the same identifier as the template-name; // of the simple-template-id.; // These together intend to imply that the template-name shall name a; // class template.; // FIXME: template<typename T> struct X {};; // template<typename T> using Y = X<T>;; // Y(int) -> Y<int>;; // satisfies these rules but does not name a class template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:38,Usability,simpl,simple-template-id,38,// C++ [temp.deduct.guide]p3:; // The simple-template-id shall name a class template specialization.; // The template-name shall be the same identifier as the template-name; // of the simple-template-id.; // These together intend to imply that the template-name shall name a; // class template.; // FIXME: template<typename T> struct X {};; // template<typename T> using Y = X<T>;; // Y(int) -> Y<int>;; // satisfies these rules but does not name a class template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:184,Usability,simpl,simple-template-id,184,// C++ [temp.deduct.guide]p3:; // The simple-template-id shall name a class template specialization.; // The template-name shall be the same identifier as the template-name; // of the simple-template-id.; // These together intend to imply that the template-name shall name a; // class template.; // FIXME: template<typename T> struct X {};; // template<typename T> using Y = X<T>;; // Y(int) -> Y<int>;; // satisfies these rules but does not name a class template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:120,Integrability,inject,injected,120,"// The types we specifically need to rebuild are:; // - typenames, typeofs, and decltypes; // - types which will become injected class names; // Of course, we also need to rebuild any type referencing such a; // type. It's safest to just say ""dependent"", but we call out a; // few cases here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:243,Integrability,depend,dependent,243,"// The types we specifically need to rebuild are:; // - typenames, typeofs, and decltypes; // - types which will become injected class names; // Of course, we also need to rebuild any type referencing such a; // type. It's safest to just say ""dependent"", but we call out a; // few cases here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:223,Safety,safe,safest,223,"// The types we specifically need to rebuild are:; // - typenames, typeofs, and decltypes; // - types which will become injected class names; // Of course, we also need to rebuild any type referencing such a; // type. It's safest to just say ""dependent"", but we call out a; // few cases here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:120,Security,inject,injected,120,"// The types we specifically need to rebuild are:; // - typenames, typeofs, and decltypes; // - types which will become injected class names; // Of course, we also need to rebuild any type referencing such a; // type. It's safest to just say ""dependent"", but we call out a; // few cases here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:85,Integrability,depend,dependent,85,// Make sure there's a type source info. This isn't really much; // of a waste; most dependent types should have type source info; // attached already.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Avoid,Avoid,3,"// Avoid warning twice on the same identifier, and don't warn on redeclaration; // of system decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:590,Availability,recover,recover,590,"/// Diagnose a declaration whose declarator-id has the given; /// nested-name-specifier.; ///; /// \param SS The nested-name-specifier of the declarator-id.; ///; /// \param DC The declaration context to which the nested-name-specifier; /// resolves.; ///; /// \param Name The name of the entity being declared.; ///; /// \param Loc The location of the name of the entity being declared.; ///; /// \param IsTemplateId Whether the name is a (simple-)template-id, and thus; /// we're declaring an explicit / partial specialization / instantiation.; ///; /// \returns true if we cannot safely recover from this error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:608,Availability,error,error,608,"/// Diagnose a declaration whose declarator-id has the given; /// nested-name-specifier.; ///; /// \param SS The nested-name-specifier of the declarator-id.; ///; /// \param DC The declaration context to which the nested-name-specifier; /// resolves.; ///; /// \param Name The name of the entity being declared.; ///; /// \param Loc The location of the name of the entity being declared.; ///; /// \param IsTemplateId Whether the name is a (simple-)template-id, and thus; /// we're declaring an explicit / partial specialization / instantiation.; ///; /// \returns true if we cannot safely recover from this error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:583,Safety,safe,safely,583,"/// Diagnose a declaration whose declarator-id has the given; /// nested-name-specifier.; ///; /// \param SS The nested-name-specifier of the declarator-id.; ///; /// \param DC The declaration context to which the nested-name-specifier; /// resolves.; ///; /// \param Name The name of the entity being declared.; ///; /// \param Loc The location of the name of the entity being declared.; ///; /// \param IsTemplateId Whether the name is a (simple-)template-id, and thus; /// we're declaring an explicit / partial specialization / instantiation.; ///; /// \returns true if we cannot safely recover from this error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:590,Safety,recover,recover,590,"/// Diagnose a declaration whose declarator-id has the given; /// nested-name-specifier.; ///; /// \param SS The nested-name-specifier of the declarator-id.; ///; /// \param DC The declaration context to which the nested-name-specifier; /// resolves.; ///; /// \param Name The name of the entity being declared.; ///; /// \param Loc The location of the name of the entity being declared.; ///; /// \param IsTemplateId Whether the name is a (simple-)template-id, and thus; /// we're declaring an explicit / partial specialization / instantiation.; ///; /// \returns true if we cannot safely recover from this error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:441,Usability,simpl,simple,441,"/// Diagnose a declaration whose declarator-id has the given; /// nested-name-specifier.; ///; /// \param SS The nested-name-specifier of the declarator-id.; ///; /// \param DC The declaration context to which the nested-name-specifier; /// resolves.; ///; /// \param Name The name of the entity being declared.; ///; /// \param Loc The location of the name of the entity being declared.; ///; /// \param IsTemplateId Whether the name is a (simple-)template-id, and thus; /// we're declaring an explicit / partial specialization / instantiation.; ///; /// \returns true if we cannot safely recover from this error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:240,Availability,redundant,redundant,240,"// If the user provided a superfluous scope specifier that refers back to the; // class in which the entity is already declared, diagnose and ignore it.; //; // class X {; // void X::f();; // };; //; // Note, it was once ill-formed to give redundant qualification in all; // contexts, but that rule was removed by DR482.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:240,Safety,redund,redundant,240,"// If the user provided a superfluous scope specifier that refers back to the; // class in which the entity is already declared, diagnose and ignore it.; //; // class X {; // void X::f();; // };; //; // Note, it was once ill-formed to give redundant qualification in all; // contexts, but that rule was removed by DR482.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:112,Performance,perform,perform,112,"// Check whether the qualifying scope encloses the scope of the original; // declaration. For a template-id, we perform the checks in; // CheckTemplateSpecializationScope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:96,Integrability,depend,dependent,96,"// If we could not compute the declaration context, it's because the; // declaration context is dependent but does not refer to a class,; // class template, or class template partial specialization. Complain; // and return early, to avoid the coming semantic disaster.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:233,Safety,avoid,avoid,233,"// If we could not compute the declaration context, it's because the; // declaration context is dependent but does not refer to a class,; // class template, or class template partial specialization. Complain; // and return early, to avoid the coming semantic disaster.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:38,Modifiability,variab,variable,38,// See if this is a redefinition of a variable in the same scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:47,Integrability,inject,injected-class-name,47,// Forget that the previous declaration is the injected-class-name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:47,Security,inject,injected-class-name,47,// Forget that the previous declaration is the injected-class-name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:212,Modifiability,variab,variables,212,"// In C++, the previous declaration we find might be a tag type; // (class or enum). In this case, the new declaration will hide the; // tag type. Note that this applies to functions, function templates, and; // variables, but not to typedefs (C++ [dcl.typedef]p4) or variable templates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:268,Modifiability,variab,variable,268,"// In C++, the previous declaration we find might be a tag type; // (class or enum). In this case, the new declaration will hide the; // tag type. Note that this applies to functions, function templates, and; // variables, but not to typedefs (C++ [dcl.typedef]p4) or variable templates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:125,Availability,error,errors,125,/// Helper method to turn variable array types into constant array; /// types in certain situations which would otherwise be errors (for; /// GCC compatibility).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:26,Modifiability,variab,variable,26,/// Helper method to turn variable array types into constant array; /// types in certain situations which would otherwise be errors (for; /// GCC compatibility).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:160,Integrability,depend,depends,160,"// This method tries to turn a variable array into a constant; // array even when the size isn't an ICE. This is necessary; // for compatibility with code that depends on gcc's buggy; // constant expression folding, like struct {char x[(int)(char*)2];}",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:31,Modifiability,variab,variable,31,"// This method tries to turn a variable array into a constant; // array even when the size isn't an ICE. This is necessary; // for compatibility with code that depends on gcc's buggy; // constant expression folding, like struct {char x[(int)(char*)2];}",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:125,Availability,error,errors,125,/// Helper method to turn variable array types into constant array; /// types in certain situations which would otherwise be errors (for; /// GCC compatibility).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:26,Modifiability,variab,variable,26,/// Helper method to turn variable array types into constant array; /// types in certain situations which would otherwise be errors (for; /// GCC compatibility).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:22,Modifiability,variab,variable-sized,22,"/// Attempt to fold a variable-sized type to a constant-sized type, returning; /// true if we were successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:68,Safety,avoid,avoid,68,"// FIXME: We should probably indicate the identifier in question to avoid; // confusion for constructs like ""virtual int a(), b;""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:46,Modifiability,variab,variably,46,// C99 6.7.7p2: If a typedef name specifies a variably modified type; // then it shall have block scope.; // Note that variably modified types must be fixed before merging the decl so; // that redeclarations will match.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:119,Modifiability,variab,variably,119,// C99 6.7.7p2: If a typedef name specifies a variably modified type; // then it shall have block scope.; // Note that variably modified types must be fixed before merging the decl so; // that redeclarations will match.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:27,Performance,Perform,Perform,27,"/// ActOnTypedefNameDecl - Perform semantic checking for a declaration which; /// declares a typedef-name, either using the 'typedef' type specifier or via; /// a C++0x [dcl.typedef]p2 alias-declaration: 'using T = A;'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,Integrability,rout,routine,106,"/// Determines whether the given declaration is an out-of-scope; /// previous declaration.; ///; /// This routine should be invoked when name lookup has found a; /// previous declaration (PrevDecl) that is not in the scope where a; /// new declaration by the same name is being introduced. If the new; /// declaration occurs in a local scope, previous declarations with; /// linkage may still be considered previous declarations (C99; /// 6.2.2p4-5, C++ [basic.link]p6).; ///; /// \param PrevDecl the previous declaration found by name; /// lookup; ///; /// \param DC the context in which the new declaration is being; /// declared.; ///; /// \returns true if PrevDecl is an out-of-scope previous declaration; /// for a new delcaration with the same name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:16,Modifiability,variab,variables,16,// Thread-local variables cannot have lifetime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:138,Modifiability,variab,variable,138,"// OpenCL C v3.0 s6.7.8 - For OpenCL C 2.0 or with the; // __opencl_c_program_scope_global_variables feature, the address space; // for a variable at program scope or a static or extern variable inside; // a function are inferred to be __global.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:186,Modifiability,variab,variable,186,"// OpenCL C v3.0 s6.7.8 - For OpenCL C 2.0 or with the; // __opencl_c_program_scope_global_variables feature, the address space; // for a variable at program scope or a static or extern variable inside; // a function are inferred to be __global.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:72,Performance,cache,cache,72,// Ensure that an auto decl is deduced otherwise the checks below might cache; // the wrong linkage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:50,Modifiability,variab,variable,50,// 'selectany' only applies to externally visible variable declarations.; // It does not apply to functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:166,Modifiability,variab,variable,166,"// dll attributes require external linkage. Static locals may have external; // linkage but still cannot be explicitly imported or exported.; // In Microsoft mode, a variable defined in anonymous namespace must have; // external linkage in order to be exported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:22,Modifiability,variab,variable,22,// Don't declare this variable in the second operand of the for-statement;; // GCC miscompiles that by ending its lifetime before evaluating the; // third operand. See gcc.gnu.org/PR86769.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:31,Modifiability,inherit,inheritable,31,// dllimport and dllexport are inheritable attributes so we have to exclude; // inherited attribute instances.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:80,Modifiability,inherit,inherited,80,// dllimport and dllexport are inheritable attributes so we have to exclude; // inherited attribute instances.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:54,Modifiability,variab,variables,54,// Allow with a warning for free functions and global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:30,Modifiability,inherit,inherited,30,// MSVC allows this. Keep the inherited attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:163,Modifiability,inherit,inherits,163,"// A specialization of a class template member function is processed here; // since it's a redeclaration. If the parent class is dllexport, the; // specialization inherits that attribute. This doesn't happen automatically; // since the parent class isn't instantiated until later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:171,Performance,optimiz,optimization,171,"/// Given that we are within the definition of the given function,; /// will that definition behave like C99's 'inline', where the; /// definition is discarded except for optimization purposes?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:10,Safety,avoid,avoid,10,// Try to avoid calling GetGVALinkageForFunction.; // All cases of this require the 'inline' keyword.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:24,Modifiability,variab,variable,24,"/// Determine whether a variable is extern ""C"" prior to attaching; /// an initializer. We can't just call isExternC() here, because that; /// will also compute and cache whether the declaration is externally; /// visible, which might change when we attach the initializer.; ///; /// This can only be used if the declaration is known to not be a; /// redeclaration of an internal linkage declaration.; ///; /// For instance:; ///; /// auto x = []{};; ///; /// Attaching the initializer here makes this declaration not externally; /// visible, because its type has internal linkage.; ///; /// FIXME: This is a hack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:164,Performance,cache,cache,164,"/// Determine whether a variable is extern ""C"" prior to attaching; /// an initializer. We can't just call isExternC() here, because that; /// will also compute and cache whether the declaration is externally; /// visible, which might change when we attach the initializer.; ///; /// This can only be used if the declaration is known to not be a; /// redeclaration of an internal linkage declaration.; ///; /// For instance:; ///; /// auto x = []{};; ///; /// Attaching the initializer here makes this declaration not externally; /// visible, because its type has internal linkage.; ///; /// FIXME: This is a hack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:48,Modifiability,variab,variable,48,/// Adjust the \c DeclContext for a function or variable that might be a; /// function-local external declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:185,Integrability,depend,dependent,185,"// If this is a local extern function or variable declared within a function; // template, don't add it into the enclosing namespace scope until it is; // instantiated; it might have a dependent type right now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:41,Modifiability,variab,variable,41,"// If this is a local extern function or variable declared within a function; // template, don't add it into the enclosing namespace scope until it is; // instantiated; it might have a dependent type right now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:84,Modifiability,variab,variable,84,// OpenCL v1.2 s6.9.r:; // The event type cannot be used to declare a program scope variable.; // OpenCL v2.0 s6.9.q:; // The clk_event_t and reserve_id_t types cannot be declared in program; // scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:42,Modifiability,variab,variables,42,// OpenCL v1.2 s6.1.1.1: reject declaring variables of the half and; // half array type (unless the cl_khr_fp16 extension is enabled).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:141,Modifiability,variab,variable,141,// This function emits warning and a corresponding note based on the; // ReadOnlyPlacementAttr attribute. The warning checks that all global variable; // declarations of an annotated type must be const qualified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:217,Deployability,patch,patch,217,// Ignore local declarations (for now) and those with const qualification.; // TODO: Local variables should not be allowed if their type declaration has; // ReadOnlyPlacementAttr attribute. To be handled in follow-up patch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:91,Modifiability,variab,variables,91,// Ignore local declarations (for now) and those with const qualification.; // TODO: Local variables should not be allowed if their type declaration has; // ReadOnlyPlacementAttr attribute. To be handled in follow-up patch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:78,Availability,error,error,78,"// mutable can only appear on non-static class members, so it's always; // an error here",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,Modifiability,variab,variable,11,"// If this variable has a VLA type and an initializer, try to; // fold to a constant-sized type. This is otherwise invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:87,Modifiability,variab,variables,87,// [dcl.stc] p2: The auto or register specifiers shall be applied only; // to names of variables declared in a block or to function parameters.; // [dcl.stc] p6: The extern specifier cannot be used in the declaration; // of class members,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:48,Modifiability,variab,variable,48,"// There is an extraneous 'template<>' for this variable. Complain; // about it, but allow the declaration of the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:114,Modifiability,variab,variable,114,"// There is an extraneous 'template<>' for this variable. Complain; // about it, but allow the declaration of the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:23,Modifiability,variab,variable,23,// Only C++1y supports variable templates (N3651).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:31,Modifiability,variab,variable,31,"// If this is supposed to be a variable template, create it as such.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:81,Modifiability,variab,variable,81,"// If we have any template parameter lists that don't directly belong to; // the variable (matching the scope specifier), store them.; // An explicit variable template specialization does not own any template; // parameter lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:150,Modifiability,variab,variable,150,"// If we have any template parameter lists that don't directly belong to; // the variable (matching the scope specifier), store them.; // An explicit variable template specialization does not own any template; // parameter lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:42,Modifiability,variab,variable,42,// 'inline' is not allowed on block scope variable declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:60,Modifiability,variab,variable,60,// C++11 [dcl.stc]p4:; // When thread_local is applied to a variable of block scope the; // storage-class-specifier static is implied if it does not appear; // explicitly.; // Core issue: 'static' is not implied if the variable is declared; // 'extern'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:219,Modifiability,variab,variable,219,// C++11 [dcl.stc]p4:; // When thread_local is applied to a variable of block scope the; // storage-class-specifier static is implied if it does not appear; // explicitly.; // Core issue: 'static' is not implied if the variable is declared; // 'extern'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:12,Availability,error,error,12,// Postpone error emission until we've collected attributes required to; // figure out whether it's a host or device variable and whether the; // error should be ignored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:146,Availability,error,error,146,// Postpone error emission until we've collected attributes required to; // figure out whether it's a host or device variable and whether the; // error should be ignored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:117,Modifiability,variab,variable,117,// Postpone error emission until we've collected attributes required to; // figure out whether it's a host or device variable and whether the; // error should be ignored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:29,Modifiability,variab,variable,29,// We still need to mark the variable as TLS so it shows up in AST with; // proper storage class for other tools to use even if we're not going; // to emit any code for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:124,Modifiability,variab,variable,124,// C++1z [dcl.spec.constexpr]p1:; // A static data member declared with the constexpr specifier is; // implicitly an inline variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:331,Modifiability,variab,variable,331,"// C99 6.7.4p3; // An inline definition of a function with external linkage shall; // not contain a definition of a modifiable object with static or; // thread storage duration...; // We only apply this when the function is required to be defined; // elsewhere, i.e. when the function is not 'extern inline'. Note; // that a local variable with thread storage duration still has to; // be marked 'static'. Also note that it's possible to get these; // semantics in C++ using __attribute__((gnu_inline)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:172,Availability,error,error,172,// WebAssembly tables are always in address space 1 (wasm_var). Don't apply; // address space if the table has local storage (semantic checks elsewhere; // will produce an error anyway).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:44,Modifiability,variab,variables,44,"// CUDA B.2.5: ""__shared__ and __constant__ variables have implied static; // storage [duration].""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:18,Deployability,release,release,18,"// In auto-retain/release, infer strong retension for variables of; // retainable type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:54,Modifiability,variab,variables,54,"// In auto-retain/release, infer strong retension for variables of; // retainable type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:2,Modifiability,Variab,Variable,2,/*Variable*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:77,Availability,error,error,77,"// CheckVariableDeclaration will set NewVD as invalid if something is in; // error like WebAssembly tables being declared as arrays with a non-zero; // size, but then parsing continues and emits further errors on that line.; // To avoid that we check here if it happened and return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:203,Availability,error,errors,203,"// CheckVariableDeclaration will set NewVD as invalid if something is in; // error like WebAssembly tables being declared as arrays with a non-zero; // size, but then parsing continues and emits further errors on that line.; // To avoid that we check here if it happened and return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:231,Safety,avoid,avoid,231,"// CheckVariableDeclaration will set NewVD as invalid if something is in; // error like WebAssembly tables being declared as arrays with a non-zero; // size, but then parsing continues and emits further errors on that line.; // To avoid that we check here if it happened and return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:128,Modifiability,variab,variable,128,"// Check the template parameter list of this declaration, possibly; // merging in the template parameter list from the previous variable; // template declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:62,Modifiability,variab,variable,62,"// If we are providing an explicit specialization of a static variable; // template, make a note of that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:21,Modifiability,variab,variables,21,// Diagnose shadowed variables iff this isn't a redeclaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:61,Deployability,update,update,61,"// If this is the first declaration of an extern C variable, update; // the map of such variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:51,Modifiability,variab,variable,51,"// If this is the first declaration of an extern C variable, update; // the map of such variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:88,Modifiability,variab,variables,88,"// If this is the first declaration of an extern C variable, update; // the map of such variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:23,Modifiability,variab,variable,23,// Special handling of variable named 'main'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:58,Modifiability,variab,variable,58,// C++ [basic.start.main]p3; // A program that declares a variable main at global scope is ill-formed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:30,Modifiability,variab,variable,30,"// In C, and external-linkage variable named main results in undefined; // behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:83,Modifiability,variab,variable,83,"/// Return the location of the capture if the given lambda captures the given; /// variable \p VD, or an invalid source location otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:60,Modifiability,variab,variable,60,// Only diagnose if we're shadowing an unambiguous field or variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:49,Modifiability,variab,variable,49,"/// Return the declaration shadowed by the given variable \p D, or null; /// if it doesn't shadow any declaration or shadowing warnings are disabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:49,Modifiability,variab,variable,49,"/// Return the declaration shadowed by the given variable \p D, or null; /// if it doesn't shadow any declaration or shadowing warnings are disabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:13,Modifiability,variab,variable,13,"/// Diagnose variable or built-in function shadowing. Implements; /// -Wshadow.; ///; /// This method is called whenever a VarDecl is added to a ""useful""; /// scope.; ///; /// \param ShadowedDecl the declaration that is shadowed by the given variable; /// \param R the lookup of the name; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:242,Modifiability,variab,variable,242,"/// Diagnose variable or built-in function shadowing. Implements; /// -Wshadow.; ///; /// This method is called whenever a VarDecl is added to a ""useful""; /// scope.; ///; /// \param ShadowedDecl the declaration that is shadowed by the given variable; /// \param R the lookup of the name; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:30,Modifiability,variab,variables,30,// Fields are not shadowed by variables in C++ static methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:101,Integrability,depend,depending,101,// Remember that this was shadowed so we can either warn about its; // modification or its existence depending on warning settings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:10,Safety,avoid,avoid,10,// Try to avoid warnings for lambdas with an explicit capture; // list. Warn only when the lambda captures the shadowed decl; // explicitly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:45,Safety,avoid,avoid,45,// Remember that this was shadowed so we can avoid the warning if; // the shadowed decl isn't captured and the warning settings allow; // it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:139,Availability,avail,available,139,"// If lambda can capture this, then emit default shadowing warning,; // Otherwise it is not really a shadowing case since field is not; // available in lambda's body.; // At this point we don't know that lambda can capture this, so; // remember that this was shadowed and delay until we know.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:5,Modifiability,variab,variable,5,"// A variable can't shadow a local variable in an enclosing scope, if; // they are separated by a non-capturing declaration context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:35,Modifiability,variab,variable,35,"// A variable can't shadow a local variable in an enclosing scope, if; // they are separated by a non-capturing declaration context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:44,Modifiability,variab,variable,44,// Never warn about shadowing a placeholder variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:27,Modifiability,variab,variables,27,/// Diagnose shadowing for variables shadowed in the lambda record \p LambdaRD; /// when these variables are captured by the lambda.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:95,Modifiability,variab,variables,95,/// Diagnose shadowing for variables shadowed in the lambda record \p LambdaRD; /// when these variables are captured by the lambda.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:10,Safety,avoid,avoid,10,// Try to avoid the warning when the shadowed decl isn't captured.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Avoid,Avoid,3,// Avoid issuing multiple warnings about the same decl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:134,Modifiability,variab,variable,134,"// This is a global, non-extern ""C"" declaration, and there is a previous; // non-global extern ""C"" declaration. Diagnose if this is a variable; // declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:19,Performance,perform,performed,19,// We have already performed the lookup into the translation unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:177,Modifiability,variab,variables,177,"// FIXME: If we have any other entity with this name in global scope,; // the declaration is ill-formed, but that is a defect: it breaks the; // 'stat' hack, for instance. Only variables can have mangled name; // clashes with extern ""C"" declarations, so only they deserve a; // diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:224,Modifiability,variab,variable,224,"/// Apply special rules for handling extern ""C"" declarations. Returns \c true; /// if we have found that this is a redeclaration of some prior entity.; ///; /// Per C++ [dcl.link]p6:; /// Two declarations [for a function or variable] with C language linkage; /// with the same name that appear in different scopes refer to the same; /// [entity]. An entity with C language linkage shall not be declared with; /// the same name as an entity in global scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:33,Modifiability,variab,variable,33,"// In C, when declaring a global variable, look for a corresponding 'extern'; // variable declared in function scope. We don't need this in C++, because; // we find local extern decls in the surrounding file-scope DeclContext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:81,Modifiability,variab,variable,81,"// In C, when declaring a global variable, look for a corresponding 'extern'; // variable declared in function scope. We don't need this in C++, because; // we find local extern decls in the surrounding file-scope DeclContext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,Availability,error,error,11,"// Emit an error if an address space was applied to decl with local storage.; // This includes arrays of objects with address space qualifiers, but not; // automatic variables that point to other address spaces.; // ISO/IEC TR 18037 S5.1.2",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:166,Modifiability,variab,variables,166,"// Emit an error if an address space was applied to decl with local storage.; // This includes arrays of objects with address space qualifiers, but not; // automatic variables that point to other address spaces.; // ISO/IEC TR 18037 S5.1.2",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:55,Modifiability,variab,variables,55,// OpenCL v1.1 s6.5.2 and s6.5.3: no local or constant variables; // in functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:53,Modifiability,variab,variables,53,// OpenCL v2.0 s6.5.2 and s6.5.3: local and constant variables must be; // in the outermost scope of a kernel function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:50,Modifiability,variab,variable,50,// Do not allow other address spaces on automatic variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:58,Modifiability,variab,variable,58,// PPC MMA non-pointer types are not allowed as non-local variable types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:60,Availability,avail,available,60,// Check that SVE types are only used in functions with SVE available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:451,Availability,error,error,451,"/// Perform semantic checking on a newly-created variable; /// declaration.; ///; /// This routine performs all of the type-checking required for a; /// variable declaration once it has been built. It is used both to; /// check variables after they have been parsed and their declarators; /// have been translated into a declaration, and to check variables; /// that have been instantiated from a template.; ///; /// Sets NewVD->isInvalidDecl() if an error was encountered.; ///; /// Returns true if the variable declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:91,Integrability,rout,routine,91,"/// Perform semantic checking on a newly-created variable; /// declaration.; ///; /// This routine performs all of the type-checking required for a; /// variable declaration once it has been built. It is used both to; /// check variables after they have been parsed and their declarators; /// have been translated into a declaration, and to check variables; /// that have been instantiated from a template.; ///; /// Sets NewVD->isInvalidDecl() if an error was encountered.; ///; /// Returns true if the variable declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:49,Modifiability,variab,variable,49,"/// Perform semantic checking on a newly-created variable; /// declaration.; ///; /// This routine performs all of the type-checking required for a; /// variable declaration once it has been built. It is used both to; /// check variables after they have been parsed and their declarators; /// have been translated into a declaration, and to check variables; /// that have been instantiated from a template.; ///; /// Sets NewVD->isInvalidDecl() if an error was encountered.; ///; /// Returns true if the variable declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:153,Modifiability,variab,variable,153,"/// Perform semantic checking on a newly-created variable; /// declaration.; ///; /// This routine performs all of the type-checking required for a; /// variable declaration once it has been built. It is used both to; /// check variables after they have been parsed and their declarators; /// have been translated into a declaration, and to check variables; /// that have been instantiated from a template.; ///; /// Sets NewVD->isInvalidDecl() if an error was encountered.; ///; /// Returns true if the variable declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:228,Modifiability,variab,variables,228,"/// Perform semantic checking on a newly-created variable; /// declaration.; ///; /// This routine performs all of the type-checking required for a; /// variable declaration once it has been built. It is used both to; /// check variables after they have been parsed and their declarators; /// have been translated into a declaration, and to check variables; /// that have been instantiated from a template.; ///; /// Sets NewVD->isInvalidDecl() if an error was encountered.; ///; /// Returns true if the variable declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:347,Modifiability,variab,variables,347,"/// Perform semantic checking on a newly-created variable; /// declaration.; ///; /// This routine performs all of the type-checking required for a; /// variable declaration once it has been built. It is used both to; /// check variables after they have been parsed and their declarators; /// have been translated into a declaration, and to check variables; /// that have been instantiated from a template.; ///; /// Sets NewVD->isInvalidDecl() if an error was encountered.; ///; /// Returns true if the variable declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:504,Modifiability,variab,variable,504,"/// Perform semantic checking on a newly-created variable; /// declaration.; ///; /// This routine performs all of the type-checking required for a; /// variable declaration once it has been built. It is used both to; /// check variables after they have been parsed and their declarators; /// have been translated into a declaration, and to check variables; /// that have been instantiated from a template.; ///; /// Sets NewVD->isInvalidDecl() if an error was encountered.; ///; /// Returns true if the variable declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:4,Performance,Perform,Perform,4,"/// Perform semantic checking on a newly-created variable; /// declaration.; ///; /// This routine performs all of the type-checking required for a; /// variable declaration once it has been built. It is used both to; /// check variables after they have been parsed and their declarators; /// have been translated into a declaration, and to check variables; /// that have been instantiated from a template.; ///; /// Sets NewVD->isInvalidDecl() if an error was encountered.; ///; /// Returns true if the variable declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:99,Performance,perform,performs,99,"/// Perform semantic checking on a newly-created variable; /// declaration.; ///; /// This routine performs all of the type-checking required for a; /// variable declaration once it has been built. It is used both to; /// check variables after they have been parsed and their declarators; /// have been translated into a declaration, and to check variables; /// that have been instantiated from a template.; ///; /// Sets NewVD->isInvalidDecl() if an error was encountered.; ///; /// Returns true if the variable declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:453,Availability,error,errors,453,"/// Generate diagnostics for an invalid function redeclaration.; ///; /// This routine handles generating the diagnostic messages for an invalid; /// function redeclaration, including finding possible similar declarations; /// or performing typo correction if there are no previous declarations with; /// the same name.; ///; /// Returns a NamedDecl iff typo correction was performed and substituting in; /// the new declaration name does not cause new errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:79,Integrability,rout,routine,79,"/// Generate diagnostics for an invalid function redeclaration.; ///; /// This routine handles generating the diagnostic messages for an invalid; /// function redeclaration, including finding possible similar declarations; /// or performing typo correction if there are no previous declarations with; /// the same name.; ///; /// Returns a NamedDecl iff typo correction was performed and substituting in; /// the new declaration name does not cause new errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:121,Integrability,message,messages,121,"/// Generate diagnostics for an invalid function redeclaration.; ///; /// This routine handles generating the diagnostic messages for an invalid; /// function redeclaration, including finding possible similar declarations; /// or performing typo correction if there are no previous declarations with; /// the same name.; ///; /// Returns a NamedDecl iff typo correction was performed and substituting in; /// the new declaration name does not cause new errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:230,Performance,perform,performing,230,"/// Generate diagnostics for an invalid function redeclaration.; ///; /// This routine handles generating the diagnostic messages for an invalid; /// function redeclaration, including finding possible similar declarations; /// or performing typo correction if there are no previous declarations with; /// the same name.; ///; /// Returns a NamedDecl iff typo correction was performed and substituting in; /// the new declaration name does not cause new errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:374,Performance,perform,performed,374,"/// Generate diagnostics for an invalid function redeclaration.; ///; /// This routine handles generating the diagnostic messages for an invalid; /// function redeclaration, including finding possible similar declarations; /// or performing typo correction if there are no previous declarations with; /// the same name.; ///; /// Returns a NamedDecl iff typo correction was performed and substituting in; /// the new declaration name does not cause new errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:92,Availability,error,errors,92,"// Retry building the function declaration with the new previous; // declarations, and with errors suppressed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:8,Availability,error,errors,8,// Trap errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:9,Modifiability,Refactor,Refactor,9,// TODO: Refactor ActOnFunctionDeclarator so that we can call only the; // pieces need to verify the typo-corrected C++ declaration and hopefully; // eliminate the need for the parameter pack ExtraArgs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:8,Integrability,depend,dependent,8,"// Size dependent types are just typedefs to normal integer types; // (e.g. unsigned long), so we cannot distinguish them from other typedefs to; // integers other than by their names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:70,Integrability,depend,dependent,70,// Remove typedefs one by one until we reach a typedef; // for a size dependent type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:59,Availability,avail,available,59,// If template type is not ODR-used its definition is only available; // in the template definition not its instantiation.; // FIXME: This logic doesn't work for types that depend on template; // parameter (PR58590).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:173,Integrability,depend,depend,173,// If template type is not ODR-used its definition is only available; // in the template definition not its instantiation.; // FIXME: This logic doesn't work for types that depend on template; // parameter (PR58590).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:139,Testability,log,logic,139,// If template type is not ODR-used its definition is only available; // in the template definition not its instantiation.; // FIXME: This logic doesn't work for types that depend on template; // parameter (PR58590).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Performance,Cache,Cache,3,// Cache the valid types we encounter to avoid rechecking structs that are; // used again,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:41,Safety,avoid,avoid,41,// Cache the valid types we encounter to avoid rechecking structs that are; // used again,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:14,Availability,error,error,14,"// We have an error, now let's go back up through history and show where; // the offending field came from",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:35,Integrability,depend,dependent,35,"// If we're adding a template to a dependent context, we may need to; // rebuilding some of the types used within the template parameter list,; // now that we know what the current instantiation is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:184,Usability,clear,clearly,184,"// If we remove the template<> and the name is not a; // template-id, we're actually silently creating a problem:; // the friend declaration will refer to an untemplated decl,; // and clearly the user wants a template specialization. So; // we need to insert '<>' after the name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Availability,Recover,Recover,3,// Recover by faking up an empty template argument list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Recover,Recover,3,// Recover by faking up an empty template argument list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:130,Integrability,depend,dependent,130,"// If the function template is referenced directly (for instance, as a; // member of the current instantiation), pretend it has a dependent type.; // This is not really justified by the standard, but is the only sane; // thing to do.; // FIXME: For a friend function, we have not marked the function as being; // a friend yet, so 'isDependentContext' on the FD doesn't work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:53,Modifiability,variab,variable,53,"// C++20 [dcl.inline]/7; // If an inline function or variable that is attached to a named module; // is declared in a definition domain, it shall be defined in that; // domain.; // So, if the current declaration does not have a definition, we must; // check at the end of the TU (or when the PMF starts) to see that we; // have a definition at that point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:2,Modifiability,Variab,Variable,2,/*Variable*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:108,Availability,avail,available,108,"// Copy the parameter declarations from the declarator D to the function; // declaration NewFD, if they are available. First scavenge them into Params.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:148,Integrability,inject,injection,148,"// In C, find all the tag declarations from the prototype and move them; // into the function DeclContext. Remove them from the surrounding tag; // injection context of the function, which is typically but not always; // the TU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:148,Security,inject,injection,148,"// In C, find all the tag declarations from the prototype and move them; // into the function DeclContext. Remove them from the surrounding tag; // injection context of the function, which is typically but not always; // the TU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:73,Integrability,inject,injection,73,"// Preserve the lexical DeclContext if it is not the surrounding tag; // injection context of the FD. In this example, the semantic context of; // E will be f and the lexical context will be S, while both the; // semantic and lexical contexts of S will be f:; // void f(struct S { enum E { a } f; } s);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:73,Security,inject,injection,73,"// Preserve the lexical DeclContext if it is not the surrounding tag; // injection context of the FD. In this example, the semantic context of; // E will be f and the lexical context will be S, while both the; // semantic and lexical contexts of S will be f:; // void f(struct S { enum E { a } f; } s);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:60,Deployability,install,install,60,"// Finally, we know we have the right number of parameters, install them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:25,Modifiability,variab,variably,25,// Functions returning a variably modified type violate C99 6.7.5.2p2; // because all functions have linkage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:211,Availability,error,error,211,// Neither OpenCL nor HLSL allow an address space qualifyer on a return; // type.; //; // OpenCL v1.1 s6.5: Using an address space qualifier in a function return; // type declaration will generate a compilation error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Performance,Perform,Perform,3,// Perform semantic checking on the function declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Availability,Recover,Recover,3,// Recover gracefully from an invalid redeclaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Recover,Recover,3,// Recover gracefully from an invalid redeclaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:270,Modifiability,inherit,inherits,270,"// We do not add HD attributes to specializations here because; // they may have different constexpr-ness compared to their; // templates and, after maybeAddCUDAHostDeviceAttrs() is applied,; // may end up with different effective targets. Instead, a; // specialization inherits its target attributes from its template; // in the CheckFunctionTemplateSpecialization() call below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:50,Integrability,depend,dependent,50,"// For friend function specializations, this is a dependent; // specialization if its semantic context is dependent, its; // type is dependent, or if its template-id is dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,Integrability,depend,dependent,106,"// For friend function specializations, this is a dependent; // specialization if its semantic context is dependent, its; // type is dependent, or if its template-id is dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:133,Integrability,depend,dependent,133,"// For friend function specializations, this is a dependent; // specialization if its semantic context is dependent, its; // type is dependent, or if its template-id is dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:169,Integrability,depend,dependent,169,"// For friend function specializations, this is a dependent; // specialization if its semantic context is dependent, its; // type is dependent, or if its template-id is dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:97,Integrability,depend,dependent,97,"// For class-scope explicit specializations of function templates,; // if the lexical context is dependent, then the specialization; // is dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:139,Integrability,depend,dependent,139,"// For class-scope explicit specializations of function templates,; // if the lexical context is dependent, then the specialization; // is dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:13,Integrability,depend,dependent,13,"// If it's a dependent specialization, it may not be possible; // to determine the primary template (for explicit specializations); // or befriended declaration (for friends) until the enclosing; // template is instantiated. In such cases, we store the declarations; // found by name lookup and defer resolution until instantiation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:158,Integrability,depend,dependent,158,// C++ [dcl.stc]p1:; // A storage-class-specifier shall not be specified in an explicit; // specialization (14.7.3); // FIXME: We should be checking this for dependent specializations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Performance,Perform,Perform,3,// Perform semantic checking on the function declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Availability,Recover,Recover,3,// Recover gracefully from an invalid redeclaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Recover,Recover,3,// Recover gracefully from an invalid redeclaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:14,Security,access,access,14,// Fake up an access specifier if it's supposed to be a class member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:497,Availability,error,error,497,"// ...with the major exception of templated-scope or; // dependent-scope friend declarations.; // TODO: we currently also suppress this check in dependent; // contexts because (1) the parameter depth will be off when; // matching friend templates and (2) we might actually be; // selecting a friend based on a dependent factor. But there; // are situations where these conditions don't apply and we; // can actually do this check immediately.; //; // Unless the scope is dependent, it's always an error if qualified; // redeclaration lookup found nothing at all. Diagnose that now;; // nothing will diagnose that error later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:613,Availability,error,error,613,"// ...with the major exception of templated-scope or; // dependent-scope friend declarations.; // TODO: we currently also suppress this check in dependent; // contexts because (1) the parameter depth will be off when; // matching friend templates and (2) we might actually be; // selecting a friend based on a dependent factor. But there; // are situations where these conditions don't apply and we; // can actually do this check immediately.; //; // Unless the scope is dependent, it's always an error if qualified; // redeclaration lookup found nothing at all. Diagnose that now;; // nothing will diagnose that error later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:57,Integrability,depend,dependent-scope,57,"// ...with the major exception of templated-scope or; // dependent-scope friend declarations.; // TODO: we currently also suppress this check in dependent; // contexts because (1) the parameter depth will be off when; // matching friend templates and (2) we might actually be; // selecting a friend based on a dependent factor. But there; // are situations where these conditions don't apply and we; // can actually do this check immediately.; //; // Unless the scope is dependent, it's always an error if qualified; // redeclaration lookup found nothing at all. Diagnose that now;; // nothing will diagnose that error later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:145,Integrability,depend,dependent,145,"// ...with the major exception of templated-scope or; // dependent-scope friend declarations.; // TODO: we currently also suppress this check in dependent; // contexts because (1) the parameter depth will be off when; // matching friend templates and (2) we might actually be; // selecting a friend based on a dependent factor. But there; // are situations where these conditions don't apply and we; // can actually do this check immediately.; //; // Unless the scope is dependent, it's always an error if qualified; // redeclaration lookup found nothing at all. Diagnose that now;; // nothing will diagnose that error later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:310,Integrability,depend,dependent,310,"// ...with the major exception of templated-scope or; // dependent-scope friend declarations.; // TODO: we currently also suppress this check in dependent; // contexts because (1) the parameter depth will be off when; // matching friend templates and (2) we might actually be; // selecting a friend based on a dependent factor. But there; // are situations where these conditions don't apply and we; // can actually do this check immediately.; //; // Unless the scope is dependent, it's always an error if qualified; // redeclaration lookup found nothing at all. Diagnose that now;; // nothing will diagnose that error later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:471,Integrability,depend,dependent,471,"// ...with the major exception of templated-scope or; // dependent-scope friend declarations.; // TODO: we currently also suppress this check in dependent; // contexts because (1) the parameter depth will be off when; // matching friend templates and (2) we might actually be; // selecting a friend based on a dependent factor. But there; // are situations where these conditions don't apply and we; // can actually do this check immediately.; //; // Unless the scope is dependent, it's always an error if qualified; // redeclaration lookup found nothing at all. Diagnose that now;; // nothing will diagnose that error later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Security,Validat,Validate,3,// Validate the type matches unless this builtin is specified as; // matching regardless of its declared type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:61,Deployability,update,update,61,"// If this is the first declaration of an extern C variable, update; // the map of such variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:51,Modifiability,variab,variable,51,"// If this is the first declaration of an extern C variable, update; // the map of such variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:88,Modifiability,variab,variables,88,"// If this is the first declaration of an extern C variable, update; // the map of such variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:86,Integrability,depend,depends,86,"// Precalculate whether this is a friend function template with a constraint; // that depends on an enclosing template, per [temp.friend]p9.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:78,Integrability,depend,depends,78,// C++ [temp.friend]p9:; // A friend function template with a constraint that depends on a; // template parameter from an enclosing template shall be a definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:12,Availability,avail,availability,12,// Diagnose availability attributes. Availability cannot be used on functions; // that are run during load/unload.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:37,Availability,Avail,Availability,37,// Diagnose availability attributes. Availability cannot be used on functions; // that are run during load/unload.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:102,Performance,load,load,102,// Diagnose availability attributes. Availability cannot be used on functions; // that are run during load/unload.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:203,Security,access,access,203,"// Diagnose no_builtin attribute on function declaration that are not a; // definition.; // FIXME: We should really be doing this in; // SemaDeclAttr.cpp::handleNoBuiltinAttr, unfortunately we only have access to; // the FunctionDecl and at this point of the code; // FunctionDecl::isThisDeclarationADefinition() which always returns `false`; // because Sema::ActOnStartOfFunctionDef has not been called yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:672,Availability,avail,available,672,"/// Return a CodeSegAttr from a containing class. The Microsoft docs say; /// when __declspec(code_seg) ""is applied to a class, all member functions of; /// the class and nested classes -- this includes compiler-generated special; /// member functions -- are put in the specified segment.""; /// The actual behavior is a little more complicated. The Microsoft compiler; /// won't check outer classes if there is an active value from #pragma code_seg.; /// The CodeSeg is always applied from the direct parent but only from outer; /// classes when the #pragma code_seg stack is empty. See:; /// https://reviews.llvm.org/D22931, the Microsoft feedback page is no longer; /// available since MS has removed the page.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:640,Usability,feedback,feedback,640,"/// Return a CodeSegAttr from a containing class. The Microsoft docs say; /// when __declspec(code_seg) ""is applied to a class, all member functions of; /// the class and nested classes -- this includes compiler-generated special; /// member functions -- are put in the specified segment.""; /// The actual behavior is a little more complicated. The Microsoft compiler; /// won't check outer classes if there is an active value from #pragma code_seg.; /// The CodeSeg is always applied from the direct parent but only from outer; /// classes when the #pragma code_seg stack is empty. See:; /// https://reviews.llvm.org/D22931, the Microsoft feedback page is no longer; /// available since MS has removed the page.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:25,Performance,perform,perform,25,"/// Determines if we can perform a correct type check for \p D as a; /// redeclaration of \p PrevDecl. If not, we can generally still perform a; /// best-effort check.; ///; /// \param NewD The new declaration.; /// \param OldD The old declaration.; /// \param NewT The portion of the type of the new declaration to check.; /// \param OldT The portion of the type of the old declaration to check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:134,Performance,perform,perform,134,"/// Determines if we can perform a correct type check for \p D as a; /// redeclaration of \p PrevDecl. If not, we can generally still perform a; /// best-effort check.; ///; /// \param NewD The new declaration.; /// \param OldD The old declaration.; /// \param NewT The portion of the type of the new declaration to check.; /// \param OldT The portion of the type of the old declaration to check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:7,Integrability,depend,dependently-typed,7,"// For dependently-typed local extern declarations and friends, we can't; // perform a correct type check in general until instantiation:; //; // int f();; // template<typename T> void g() { T f(); }; //; // (valid if g() is only instantiated with T = int).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:77,Performance,perform,perform,77,"// For dependently-typed local extern declarations and friends, we can't; // perform a correct type check in general until instantiation:; //; // int f();; // template<typename T> void g() { T f(); }; //; // (valid if g() is only instantiated with T = int).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:48,Integrability,depend,dependent,48,"// Similarly, if the previous declaration was a dependent local extern; // declaration, we don't really know its type yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:46,Integrability,depend,dependent,46,/// Checks if the new declaration declared in dependent context must be; /// put in the same redeclaration chain as the specified declaration.; ///; /// \param D Declaration that is checked.; /// \param PrevDecl Previous declaration found with proper lookup method for the; /// same declaration name.; /// \returns True if D must be added to the redeclaration chain which PrevDecl; /// belongs to.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:15,Integrability,depend,dependent,15,"// Don't chain dependent friend function definitions until instantiation, to; // permit cases like; //; // void func();; // template<typename T> class C1 { friend void func() {} };; // template<typename T> class C2 { friend void func() {} };; //; // ... which is valid if only one of C1 and C2 is ever instantiated.; //; // FIXME: This need only apply to function definitions. For now, we proxy; // this by checking for a file-scope function. We do not want this to apply; // to friend declarations nominating member functions, because that gets in; // the way of access checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:564,Security,access,access,564,"// Don't chain dependent friend function definitions until instantiation, to; // permit cases like; //; // void func();; // template<typename T> class C1 { friend void func() {} };; // template<typename T> class C2 { friend void func() {} };; //; // ... which is valid if only one of C1 and C2 is ever instantiated.; //; // FIXME: This need only apply to function definitions. For now, we proxy; // this by checking for a file-scope function. We do not want this to apply; // to friend declarations nominating member functions, because that gets in; // the way of access checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:136,Availability,error,error,136,"/// Check the target or target_version attribute of the function for; /// MultiVersion validity.; ///; /// Returns true if there was an error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:222,Availability,error,error,222,"/// Check the validity of a multiversion function declaration that is the; /// first of its kind. Also sets the multiversion'ness' of the function itself.; ///; /// This sets NewFD->isInvalidDecl() to true if there was an error.; ///; /// Returns true if there was an error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:268,Availability,error,error,268,"/// Check the validity of a multiversion function declaration that is the; /// first of its kind. Also sets the multiversion'ness' of the function itself.; ///; /// This sets NewFD->isInvalidDecl() to true if there was an error.; ///; /// Returns true if there was an error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:95,Usability,simpl,simple,95,"// If the old decl is NOT MultiVersioned yet, and we don't cause that; // to change, this is a simple redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:139,Availability,error,errors,139,"// Handle CPUDispatch/CPUSpecific versions.; // Only 1 CPUDispatch function is allowed, this will make it go through; // the redeclaration errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:47,Availability,error,error,47,"// If the declarations don't match, this is an error condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:17,Usability,simpl,simply,17,"// Else, this is simply a non-redecl case. Checking the 'value' is only; // necessary in the Target case, since The CPUSpecific/Dispatch cases are; // handled in the attribute adding step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:192,Availability,error,error,192,"/// Check the validity of a mulitversion function declaration.; /// Also sets the multiversion'ness' of the function itself.; ///; /// This sets NewFD->isInvalidDecl() to true if there was an error.; ///; /// Returns true if there was an error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:238,Availability,error,error,238,"/// Check the validity of a mulitversion function declaration.; /// Also sets the multiversion'ness' of the function itself.; ///; /// This sets NewFD->isInvalidDecl() to true if there was an error.; ///; /// Returns true if there was an error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:128,Performance,optimiz,optimization,128,"// Main isn't allowed to become a multiversion function, however it IS; // permitted to have 'main' be marked with the 'target' optimization hint,; // for 'target_version' only default is allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:109,Availability,error,error,109,"// If there's no previous declaration, AND this isn't attempting to cause; // multiversioning, this isn't an error condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:759,Availability,error,error,759,"/// Perform semantic checking of a new function declaration.; ///; /// Performs semantic analysis of the new function declaration; /// NewFD. This routine performs all semantic checking that does not; /// require the actual declarator involved in the declaration, and is; /// used both for the declaration of functions as they are parsed; /// (called via ActOnDeclarator) and for the declaration of functions; /// that have been instantiated via C++ template instantiation (called; /// via InstantiateDecl).; ///; /// \param IsMemberSpecialization whether this new function declaration is; /// a member specialization (that replaces any definition provided by the; /// previous declaration).; ///; /// This sets NewFD->isInvalidDecl() to true if there was an error.; ///; /// \returns true if the function declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:147,Integrability,rout,routine,147,"/// Perform semantic checking of a new function declaration.; ///; /// Performs semantic analysis of the new function declaration; /// NewFD. This routine performs all semantic checking that does not; /// require the actual declarator involved in the declaration, and is; /// used both for the declaration of functions as they are parsed; /// (called via ActOnDeclarator) and for the declaration of functions; /// that have been instantiated via C++ template instantiation (called; /// via InstantiateDecl).; ///; /// \param IsMemberSpecialization whether this new function declaration is; /// a member specialization (that replaces any definition provided by the; /// previous declaration).; ///; /// This sets NewFD->isInvalidDecl() to true if there was an error.; ///; /// \returns true if the function declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:4,Performance,Perform,Perform,4,"/// Perform semantic checking of a new function declaration.; ///; /// Performs semantic analysis of the new function declaration; /// NewFD. This routine performs all semantic checking that does not; /// require the actual declarator involved in the declaration, and is; /// used both for the declaration of functions as they are parsed; /// (called via ActOnDeclarator) and for the declaration of functions; /// that have been instantiated via C++ template instantiation (called; /// via InstantiateDecl).; ///; /// \param IsMemberSpecialization whether this new function declaration is; /// a member specialization (that replaces any definition provided by the; /// previous declaration).; ///; /// This sets NewFD->isInvalidDecl() to true if there was an error.; ///; /// \returns true if the function declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:71,Performance,Perform,Performs,71,"/// Perform semantic checking of a new function declaration.; ///; /// Performs semantic analysis of the new function declaration; /// NewFD. This routine performs all semantic checking that does not; /// require the actual declarator involved in the declaration, and is; /// used both for the declaration of functions as they are parsed; /// (called via ActOnDeclarator) and for the declaration of functions; /// that have been instantiated via C++ template instantiation (called; /// via InstantiateDecl).; ///; /// \param IsMemberSpecialization whether this new function declaration is; /// a member specialization (that replaces any definition provided by the; /// previous declaration).; ///; /// This sets NewFD->isInvalidDecl() to true if there was an error.; ///; /// \returns true if the function declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:155,Performance,perform,performs,155,"/// Perform semantic checking of a new function declaration.; ///; /// Performs semantic analysis of the new function declaration; /// NewFD. This routine performs all semantic checking that does not; /// require the actual declarator involved in the declaration, and is; /// used both for the declaration of functions as they are parsed; /// (called via ActOnDeclarator) and for the declaration of functions; /// that have been instantiated via C++ template instantiation (called; /// via InstantiateDecl).; ///; /// \param IsMemberSpecialization whether this new function declaration is; /// a member specialization (that replaces any definition provided by the; /// previous declaration).; ///; /// This sets NewFD->isInvalidDecl() to true if there was an error.; ///; /// \returns true if the function declaration is a redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:39,Performance,perform,performing,39,"// Warn that we did this, if we're not performing template instantiation.; // In that case, we'll have warned already when the template was defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:56,Modifiability,inherit,inherit,56,// Explicit specializations of a member template do not inherit deleted; // status from the parent member template that they are specializing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:15,Testability,assert,assert,15,// FIXME: This assert will not hold in the presence of modules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:21,Deployability,update,update,21,// FIXME: We need an update record for this AST mutation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:102,Integrability,depend,dependent,102,"// We check here for invalid destructor names.; // If we have a friend destructor declaration that is dependent, we can't; // diagnose right away because cases like this are still valid:; // template <class T> struct A { friend T::X::~Y(); };; // struct B { struct Y { ~Y(); }; using X = Y; };; // template struct A<B>;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:15,Usability,guid,guide,15,// A deduction guide is not on the list of entities that can be; // explicitly specialized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:667,Modifiability,variab,variable,667,"// C++20: dcl.decl.general p4:; // The optional requires-clause ([temp.pre]) in an init-declarator or; // member-declarator shall be present only if the declarator declares a; // templated function ([dcl.fct]).; //; // [temp.pre]/8:; // An entity is templated if it is; // - a template,; // - an entity defined ([basic.def]) or created ([class.temporary]) in a; // templated entity,; // - a member of a templated entity,; // - an enumerator for an enumeration that is a templated entity, or; // - the closure type of a lambda-expression ([expr.prim.lambda.closure]); // appearing in the declaration of a templated entity. [Note 6: A local; // class, a local or block variable, or a friend function defined in a; // templated entity is a templated entity.  end note]; //; // A templated function is a function template or a function that is; // templated. A templated class is a class template or a class that is; // templated. A templated variable is a variable template or a variable; // that is templated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:940,Modifiability,variab,variable,940,"// C++20: dcl.decl.general p4:; // The optional requires-clause ([temp.pre]) in an init-declarator or; // member-declarator shall be present only if the declarator declares a; // templated function ([dcl.fct]).; //; // [temp.pre]/8:; // An entity is templated if it is; // - a template,; // - an entity defined ([basic.def]) or created ([class.temporary]) in a; // templated entity,; // - a member of a templated entity,; // - an enumerator for an enumeration that is a templated entity, or; // - the closure type of a lambda-expression ([expr.prim.lambda.closure]); // appearing in the declaration of a templated entity. [Note 6: A local; // class, a local or block variable, or a friend function defined in a; // templated entity is a templated entity.  end note]; //; // A templated function is a function template or a function that is; // templated. A templated class is a class template or a class that is; // templated. A templated variable is a variable template or a variable; // that is templated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:954,Modifiability,variab,variable,954,"// C++20: dcl.decl.general p4:; // The optional requires-clause ([temp.pre]) in an init-declarator or; // member-declarator shall be present only if the declarator declares a; // templated function ([dcl.fct]).; //; // [temp.pre]/8:; // An entity is templated if it is; // - a template,; // - an entity defined ([basic.def]) or created ([class.temporary]) in a; // templated entity,; // - a member of a templated entity,; // - an enumerator for an enumeration that is a templated entity, or; // - the closure type of a lambda-expression ([expr.prim.lambda.closure]); // appearing in the declaration of a templated entity. [Note 6: A local; // class, a local or block variable, or a friend function defined in a; // templated entity is a templated entity.  end note]; //; // A templated function is a function template or a function that is; // templated. A templated class is a class template or a class that is; // templated. A templated variable is a variable template or a variable; // that is templated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:977,Modifiability,variab,variable,977,"// C++20: dcl.decl.general p4:; // The optional requires-clause ([temp.pre]) in an init-declarator or; // member-declarator shall be present only if the declarator declares a; // templated function ([dcl.fct]).; //; // [temp.pre]/8:; // An entity is templated if it is; // - a template,; // - an entity defined ([basic.def]) or created ([class.temporary]) in a; // templated entity,; // - a member of a templated entity,; // - an enumerator for an enumeration that is a templated entity, or; // - the closure type of a lambda-expression ([expr.prim.lambda.closure]); // appearing in the declaration of a templated entity. [Note 6: A local; // class, a local or block variable, or a friend function defined in a; // templated entity is a templated entity.  end note]; //; // A templated function is a function template or a function that is; // templated. A templated class is a class template or a class that is; // templated. A templated variable is a variable template or a variable; // that is templated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:151,Availability,error,error,151,"// If the function violates [temp.friend]p9 because it is missing; // a definition, and adding a definition would make it templated,; // then let that error take precedence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:259,Availability,error,error,259,"// C++11 [basic.start.main]p3:; // A program that [...] declares main to be inline, static or; // constexpr is ill-formed.; // C11 6.7.4p4: In a hosted environment, no function specifier(s) shall; // appear in a declaration of main.; // static main is not an error under C99, but we should warn about it.; // We accept _Noreturn main as an extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:38,Availability,error,error,38,"// Otherwise, this is just a flat-out error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:115,Testability,log,logic,115,"// Darwin passes an undocumented fourth argument of type char**. If; // other platforms start sprouting these, the logic below will start; // getting shifty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:20,Usability,undo,undocumented,20,"// Darwin passes an undocumented fourth argument of type char**. If; // other platforms start sprouting these, the logic below will start; // getting shifty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:174,Safety,safe,safe,174,"// See if a warning is needed by checking the first difference in index; // numbers. If field being used has index less than the field being; // initialized, then the use is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:27,Modifiability,variab,variables,27,// Check for static member variables and don't warn on them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:81,Security,access,accesses,81,"// Warn when a non-static method call is followed by non-static member; // field accesses, which is followed by a DeclRefExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:9,Modifiability,variab,variables,9,// Local variables will be handled by the CFG analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:74,Availability,avail,available,74,// Simple wrapper to add the name of a variable or (if no variable is; // available) a DeclarationName into a diagnostic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:10,Integrability,wrap,wrapper,10,// Simple wrapper to add the name of a variable or (if no variable is; // available) a DeclarationName into a diagnostic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:39,Modifiability,variab,variable,39,// Simple wrapper to add the name of a variable or (if no variable is; // available) a DeclarationName into a diagnostic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:58,Modifiability,variab,variable,58,// Simple wrapper to add the name of a variable or (if no variable is; // available) a DeclarationName into a diagnostic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Usability,Simpl,Simple,3,// Simple wrapper to add the name of a variable or (if no variable is; // available) a DeclarationName into a diagnostic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:56,Safety,safe,safety,56,"// Warn if we deduced 'id'. 'auto' usually implies type-safety, but using; // 'id' instead of a specific object type prevents most of our usual; // checks.; // We only want to warn outside of template instantiations, though:; // inside a template, the 'id' could have come from a parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:41,Modifiability,variab,variable,41,// Check the deduced type is valid for a variable declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:44,Availability,error,error,44,"// If there is no declaration, there was an error parsing it. Just ignore; // the initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:52,Modifiability,variab,variable,52,// WebAssembly tables can't be used to initialise a variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:78,Availability,recover,recovery,78,"// There are unresolved typos in Init, just drop them.; // FIXME: improve the recovery strategy to preserve the Init.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:78,Safety,recover,recovery,78,"// There are unresolved typos in Init, just drop them.; // FIXME: improve the recovery strategy to preserve the Init.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:53,Availability,recover,recovery-expr,53,// Invalidate the decl as we don't know the type for recovery-expr yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:53,Safety,recover,recovery-expr,53,// Invalidate the decl as we don't know the type for recovery-expr yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:31,Modifiability,variab,variable,31,// dllimport cannot be used on variable definitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:7,Modifiability,variab,variable,7,// The variable can not have an abstract class type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:121,Modifiability,variab,variable,121,"// If adding the initializer will turn this declaration into a definition,; // and we already have a definition for this variable, diagnose or otherwise; // handle the situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:501,Performance,perform,performed,501,"// C++ [class.static.data]p4; // If a static data member is of const integral or const; // enumeration type, its declaration in the class definition can; // specify a constant-initializer which shall be an integral; // constant expression (5.19). In that case, the member can appear; // in integral constant expressions. The member shall still be; // defined in a namespace scope if it is used in the program and the; // namespace scope definition shall not contain an initializer.; //; // We already performed a redefinition check above, but for static; // data members we also need to check whether there was an in-class; // declaration with an initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:32,Energy Efficiency,allocate,allocated,32,"// OpenCL 1.1 6.5.2: ""Variables allocated in the __local address space inside; // a kernel function cannot be initialized.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:22,Modifiability,Variab,Variables,22,"// OpenCL 1.1 6.5.2: ""Variables allocated in the __local address space inside; // a kernel function cannot be initialized.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:7,Performance,Load,LoaderUninitialized,7,// The LoaderUninitialized attribute acts as a definition (of undef).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:89,Modifiability,variab,variable,89,// Expressions default to 'id' when we're in a debugger; // and we are assigning it to a variable of Objective-C pointer type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Performance,Perform,Perform,3,// Perform the initialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:2,Availability,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:2,Safety,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:81,Availability,recover,recovery,81,"// If the provided initializer fails to initialize the var decl,; // we attach a recovery expr for better recovery.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,Availability,recover,recovery,106,"// If the provided initializer fails to initialize the var decl,; // we attach a recovery expr for better recovery.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:81,Safety,recover,recovery,81,"// If the provided initializer fails to initialize the var decl,; // we attach a recovery expr for better recovery.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,Safety,recover,recovery,106,"// If the provided initializer fails to initialize the var decl,; // we attach a recovery expr for better recovery.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:19,Availability,error,error,19,"// In general, for error recovery purposes, the initalizer doesn't play; // part in the valid bit of the declaration. There are a few exceptions:; // 1) if the var decl has a deduced auto type, and the type cannot be; // deduced by an invalid initializer;; // 2) if the var decl is decompsition decl with a non-deduced type, and; // the initialization fails (e.g. `int [a] = {1, 2};`);; // Case 1) was already handled elsewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:25,Availability,recover,recovery,25,"// In general, for error recovery purposes, the initalizer doesn't play; // part in the valid bit of the declaration. There are a few exceptions:; // 1) if the var decl has a deduced auto type, and the type cannot be; // deduced by an invalid initializer;; // 2) if the var decl is decompsition decl with a non-deduced type, and; // the initialization fails (e.g. `int [a] = {1, 2};`);; // Case 1) was already handled elsewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:25,Safety,recover,recovery,25,"// In general, for error recovery purposes, the initalizer doesn't play; // part in the valid bit of the declaration. There are a few exceptions:; // 1) if the var decl has a deduced auto type, and the type cannot be; // deduced by an invalid initializer;; // 2) if the var decl is decompsition decl with a non-deduced type, and; // the initialization fails (e.g. `int [a] = {1, 2};`);; // Case 1) was already handled elsewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:36,Modifiability,variab,variable,36,"// Check for self-references within variable initializers.; // Variables declared within a function/method body (except for references); // are handled by a dataflow analysis.; // This is undefined behavior in C++, but valid in C.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:63,Modifiability,Variab,Variables,63,"// Check for self-references within variable initializers.; // Variables declared within a function/method body (except for references); // are handled by a dataflow analysis.; // This is undefined behavior in C++, but valid in C.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:55,Modifiability,variab,variable,55,// It is safe to assign a weak reference into a strong variable.; // Although this code can still have problems:; // id x = self.weakProp;; // id y = self.weakProp;; // we do not warn to warn spuriously when 'x' and 'y' are on separate; // paths through the function. This should be revisited if; // -Wrepeated-use-of-weak is made flow-sensitive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:9,Safety,safe,safe,9,// It is safe to assign a weak reference into a strong variable.; // Although this code can still have problems:; // id x = self.weakProp;; // id y = self.weakProp;; // we do not warn to warn spuriously when 'x' and 'y' are on separate; // paths through the function. This should be revisited if; // -Wrepeated-use-of-weak is made flow-sensitive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:934,Integrability,depend,dependent,934,"// This is an in-class initialization for a static data member, e.g.,; //; // struct S {; // static const int value = 17;; // };; // C++ [class.mem]p4:; // A member-declarator can contain a constant-initializer only; // if it declares a static member (9.4) of const integral or; // const enumeration type, see 9.4.2.; //; // C++11 [class.static.data]p3:; // If a non-volatile non-inline const static data member is of integral; // or enumeration type, its declaration in the class definition can; // specify a brace-or-equal-initializer in which every initializer-clause; // that is an assignment-expression is a constant expression. A static; // data member of literal type can be declared in the class definition; // with the constexpr specifier; if so, its declaration shall specify a; // brace-or-equal-initializer in which every initializer-clause that is; // an assignment-expression is a constant expression.; // Do nothing on dependent types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:127,Modifiability,variab,variable,127,"// Allow any 'static constexpr' members, whether or not they are of literal; // type. We separately check that every constexpr variable is of literal; // type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:84,Modifiability,variab,variables,84,"// In C, extern is typically used to avoid tentative definitions when; // declaring variables in headers, but adding an intializer makes it a; // definition. This is somewhat confusing, so GCC and Clang both warn on it.; // In C++, extern is often used to give implictly static const variables; // external linkage, so don't warn in that case. If selectany is present,; // this might be header code intended for C and C++ inclusion, so apply the; // C++ rules.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:284,Modifiability,variab,variables,284,"// In C, extern is typically used to avoid tentative definitions when; // declaring variables in headers, but adding an intializer makes it a; // definition. This is somewhat confusing, so GCC and Clang both warn on it.; // In C++, extern is often used to give implictly static const variables; // external linkage, so don't warn in that case. If selectany is present,; // this might be header code intended for C and C++ inclusion, so apply the; // C++ rules.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:37,Safety,avoid,avoid,37,"// In C, extern is typically used to avoid tentative definitions when; // declaring variables in headers, but adding an intializer makes it a; // definition. This is somewhat confusing, so GCC and Clang both warn on it.; // In C++, extern is often used to give implictly static const variables; // external linkage, so don't warn in that case. If selectany is present,; // this might be header code intended for C and C++ inclusion, so apply the; // C++ rules.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:34,Modifiability,variab,variable,34,"// In Microsoft C++ mode, a const variable defined in namespace scope has; // external linkage by default if the variable is declared with; // __declspec(dllexport).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:113,Modifiability,variab,variable,113,"// In Microsoft C++ mode, a const variable defined in namespace scope has; // external linkage by default if the variable is declared with; // __declspec(dllexport).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:52,Availability,error,error,52,"/// ActOnInitializerError - Given that there was an error parsing an; /// initializer for the given declaration, try to at least re-establish; /// invariants such as whether a variable's type is either dependent or; /// complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:202,Integrability,depend,dependent,202,"/// ActOnInitializerError - Given that there was an error parsing an; /// initializer for the given declaration, try to at least re-establish; /// invariants such as whether a variable's type is either dependent or; /// complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:176,Modifiability,variab,variable,176,"/// ActOnInitializerError - Given that there was an error parsing an; /// initializer for the given declaration, try to at least re-establish; /// invariants such as whether a variable's type is either dependent or; /// complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:93,Integrability,depend,dependent,93,"// Our main concern here is re-establishing invariants like ""a; // variable's type is either dependent or complete"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:67,Modifiability,variab,variable,67,"// Our main concern here is re-establishing invariants like ""a; // variable's type is either dependent or complete"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:20,Usability,usab,usable,20,// Bindings are not usable if we can't make sense of the initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:44,Availability,error,error,44,"// If there is no declaration, there was an error parsing it. Just ignore it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:276,Modifiability,variab,variable,276,"// C++11 [class.static.data]p3: A static data member can be declared with; // the constexpr specifier; if so, its declaration shall specify; // a brace-or-equal-initializer.; // C++11 [dcl.constexpr]p1: The constexpr specifier shall be applied only to; // the definition of a variable [...] or the declaration of a static data; // member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:23,Modifiability,variab,variables,23,// OpenCL v1.1 s6.5.3: variables declared in the constant address space must; // be initialized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:346,Availability,error,error,346,"// C99 6.9.2p3: If the declaration of an identifier for an object is; // a tentative definition and has internal linkage (C99 6.2.2p3), the; // declared type shall not be an incomplete type.; // NOTE: code such as the following; // static struct s;; // struct s { int a; };; // is accepted by gcc. Hence here we issue a warning instead of; // an error and we do not invalidate the static declaration.; // NOTE: to avoid multiple warnings, only check the first declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:414,Safety,avoid,avoid,414,"// C99 6.9.2p3: If the declaration of an identifier for an object is; // a tentative definition and has internal linkage (C99 6.2.2p3), the; // declared type shall not be an incomplete type.; // NOTE: code such as the following; // static struct s;; // struct s { int a; };; // is accepted by gcc. Hence here we issue a warning instead of; // an error and we do not invalidate the static declaration.; // NOTE: to avoid multiple warnings, only check the first declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:51,Modifiability,variab,variable,51,// Provide a specific diagnostic for uninitialized variable; // definitions with incomplete array type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:51,Modifiability,variab,variable,51,// Provide a specific diagnostic for uninitialized variable; // definitions with reference type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:80,Integrability,depend,dependent,80,// Do not attempt to type-check the default initializer for a; // variable with dependent type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:66,Modifiability,variab,variable,66,// Do not attempt to type-check the default initializer for a; // variable with dependent type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:7,Modifiability,variab,variable,7,// The variable can not have an abstract class type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:94,Modifiability,variab,variable,94,"// Check for jumps past the implicit initializer. C++0x; // clarifies that this applies to a ""variable with automatic; // storage duration"", not a ""local variable"".; // C++11 [stmt.dcl]p3; // A program that jumps from a point where a variable with automatic; // storage duration is not in scope to a point where it is in scope is; // ill-formed unless the variable has scalar type, class type with a; // trivial default constructor and a trivial destructor, a cv-qualified; // version of one of these types, or an array of one of the preceding; // types and is declared without an initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:154,Modifiability,variab,variable,154,"// Check for jumps past the implicit initializer. C++0x; // clarifies that this applies to a ""variable with automatic; // storage duration"", not a ""local variable"".; // C++11 [stmt.dcl]p3; // A program that jumps from a point where a variable with automatic; // storage duration is not in scope to a point where it is in scope is; // ill-formed unless the variable has scalar type, class type with a; // trivial default constructor and a trivial destructor, a cv-qualified; // version of one of these types, or an array of one of the preceding; // types and is declared without an initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:234,Modifiability,variab,variable,234,"// Check for jumps past the implicit initializer. C++0x; // clarifies that this applies to a ""variable with automatic; // storage duration"", not a ""local variable"".; // C++11 [stmt.dcl]p3; // A program that jumps from a point where a variable with automatic; // storage duration is not in scope to a point where it is in scope is; // ill-formed unless the variable has scalar type, class type with a; // trivial default constructor and a trivial destructor, a cv-qualified; // version of one of these types, or an array of one of the preceding; // types and is declared without an initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:356,Modifiability,variab,variable,356,"// Check for jumps past the implicit initializer. C++0x; // clarifies that this applies to a ""variable with automatic; // storage duration"", not a ""local variable"".; // C++11 [stmt.dcl]p3; // A program that jumps from a point where a variable with automatic; // storage duration is not in scope to a point where it is in scope is; // ill-formed unless the variable has scalar type, class type with a; // trivial default constructor and a trivial destructor, a cv-qualified; // version of one of these types, or an array of one of the preceding; // types and is declared without an initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:35,Availability,recover,recovery-expr,35,"// If default-init fails, attach a recovery-expr initializer to track; // that initialization was attempted and failed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:35,Safety,recover,recovery-expr,35,"// If default-init fails, attach a recovery-expr initializer to track; // that initialization was attempted and failed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:44,Availability,error,error,44,"// If there is no declaration, there was an error parsing it. Ignore it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:37,Modifiability,variab,variable,37,// OpenCL v2.0 s6.12.5 - Every block variable declaration must have an; // initialiser,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:95,Modifiability,variab,variable,95,"// In Objective-C, don't allow jumps past the implicit initialization of a; // local retaining variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:33,Modifiability,variab,variables,33,"// Warn about externally-visible variables being defined without a; // prior declaration. We only want to do this for global; // declarations, but we also specifically need to avoid doing it for; // class members because the linkage of an anonymous class can; // change if it's later given a typedef name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:176,Safety,avoid,avoid,176,"// Warn about externally-visible variables being defined without a; // prior declaration. We only want to do this for global; // declarations, but we also specifically need to avoid doing it for; // class members because the linkage of an anonymous class can; // change if it's later given a typedef name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Modifiability,variab,variable,3,/* variable */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Performance,Cache,Cache,3,// Cache the result of checking for constant initialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:197,Integrability,depend,depend,197,"// If this variable might have a constant initializer or might be usable in; // constant expressions, check whether or not it actually is now. We can't; // do this lazily, because the result might depend on things that change; // later, such as which constexpr functions happen to be defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,Modifiability,variab,variable,11,"// If this variable might have a constant initializer or might be usable in; // constant expressions, check whether or not it actually is now. We can't; // do this lazily, because the result might depend on things that change; // later, such as which constexpr functions happen to be defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:66,Usability,usab,usable,66,"// If this variable might have a constant initializer or might be usable in; // constant expressions, check whether or not it actually is now. We can't; // do this lazily, because the result might depend on things that change; // later, such as which constexpr functions happen to be defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:15,Performance,cache,cache,15,"// Compute and cache the constant value, and remember that we have a; // constant initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:50,Modifiability,variab,variables,50,// Apply section attributes and pragmas to global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,Modifiability,variab,variable,11,"// If this variable must be emitted, add it as an initializer for the; // current module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,Modifiability,variab,variable,11,"// If this variable must be emitted, add it as an initializer for the current; // module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:17,Modifiability,inherit,inherit,17,// Static locals inherit dll attributes from their function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:57,Modifiability,variab,variable,57,// Export this function to enforce exporting this static variable even; // if it is not used in this compilation unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:69,Modifiability,variab,variable,69,// Perform TLS alignment check here after attributes attached to the variable; // which may affect the alignment have been processed. Only perform the check; // if the target has a maximum TLS alignment (zero means no constraints).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Performance,Perform,Perform,3,// Perform TLS alignment check here after attributes attached to the variable; // which may affect the alignment have been processed. Only perform the check; // if the target has a maximum TLS alignment (zero means no constraints).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:139,Performance,perform,perform,139,// Perform TLS alignment check here after attributes attached to the variable; // which may affect the alignment have been processed. Only perform the check; // if the target has a maximum TLS alignment (zero means no constraints).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:51,Integrability,depend,dependent,51,// Protect the check so that it's not performed on dependent types and; // dependent alignments (we can't determine the alignment in that case).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:75,Integrability,depend,dependent,75,// Protect the check so that it's not performed on dependent types and; // dependent alignments (we can't determine the alignment in that case).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:38,Performance,perform,performed,38,// Protect the check so that it's not performed on dependent types and; // dependent alignments (we can't determine the alignment in that case).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:71,Performance,perform,perform,71,/// FinalizeDeclaration - called by ParseDeclarationAfterDeclarator to perform; /// any semantic actions necessary after any initializer has been attached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:56,Modifiability,variab,variables,56,"// Perform check for initializers of device-side global variables.; // CUDA allows empty constructors as initializers (see E.2.3.1, CUDA; // 7.5). We must also apply the same checks to all __shared__; // variables whether they are local or not. CUDA also allows; // constant initializers for __constant__ and __device__ variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:204,Modifiability,variab,variables,204,"// Perform check for initializers of device-side global variables.; // CUDA allows empty constructors as initializers (see E.2.3.1, CUDA; // 7.5). We must also apply the same checks to all __shared__; // variables whether they are local or not. CUDA also allows; // constant initializers for __constant__ and __device__ variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:320,Modifiability,variab,variables,320,"// Perform check for initializers of device-side global variables.; // CUDA allows empty constructors as initializers (see E.2.3.1, CUDA; // 7.5). We must also apply the same checks to all __shared__; // variables whether they are local or not. CUDA also allows; // constant initializers for __constant__ and __device__ variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Performance,Perform,Perform,3,"// Perform check for initializers of device-side global variables.; // CUDA allows empty constructors as initializers (see E.2.3.1, CUDA; // 7.5). We must also apply the same checks to all __shared__; // variables whether they are local or not. CUDA also allows; // constant initializers for __constant__ and __device__ variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:23,Modifiability,variab,variables,23,"// dllimport/dllexport variables cannot be thread local, their TLS index; // isn't exported with the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:101,Modifiability,variab,variable,101,"// dllimport/dllexport variables cannot be thread local, their TLS index; // isn't exported with the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:193,Safety,safe,safe,193,"// But if this is a static local in a dlimport/dllexport function, the; // function will never be inlined, which means the var would never be; // imported, so having it marked import/export is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:111,Modifiability,variab,variable,111,"// If there's a #pragma GCC visibility in scope, and this isn't a class; // member, set the visibility of this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:46,Deployability,update,update,46,// Now we have parsed the initializer and can update the table of magic; // tag values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:82,Performance,perform,perform,82,"// For declarators, there are some additional syntactic-ish checks we need; // to perform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:72,Modifiability,variab,variable,72,// A declarator that uses 'auto' in any way other than to declare a; // variable with a deduced type cannot be combined with any other; // declarator in the same group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:89,Performance,perform,performing,89,"/// BuildDeclaratorGroup - convert a list of declarations into a declaration; /// group, performing any necessary semantic checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:82,Usability,simpl,simple,82,// [dcl.meaning]p1: An unqualified-id occurring in a declarator-id shall be a; // simple identifier except [...irrelevant cases...].,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:107,Availability,toler,tolerate,107,"// In C++11, the 'register' storage class specifier is deprecated.; // In C++17, it is not allowed, but we tolerate it as an extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Availability,Recover,Recover,3,// Recover by removing the name,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Recover,Recover,3,// Recover by removing the name,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:29,Modifiability,variab,variables,29,"// Temporarily put parameter variables in the translation unit, not; // the enclosing context. This prevents them from accidentally; // looking like class members in C++.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:18,Modifiability,variab,variable,18,/// Synthesizes a variable for a parameter arising from a; /// typedef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:35,Availability,error,errors,35,// Don't diagnose unused-parameter errors in template instantiations; we; // will already have done so in the template itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:99,Availability,error,error,99,"// Special cases for arrays:; // - if it's const, use __unsafe_unretained; // - otherwise, it's an error",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:99,Availability,error,error,99,"// Special cases for arrays:; // - if it's const, use __unsafe_unretained; // - otherwise, it's an error",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:35,Integrability,interface,interface,35,// Parameter declarators cannot be interface types. All ObjC objects are; // passed by reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:17,Availability,error,error,17,// Don't emit an error when this is redefinition of a typo-corrected; // definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:199,Modifiability,variab,variable,199,"// Each ExpressionEvaluationContextRecord also keeps track of whether the; // context is nested in an immediate function context, so smaller contexts; // that appear inside immediate functions (like variable initializers) are; // considered to be inside an immediate function context even though by; // themselves they are not immediate function contexts. But when a new; // function is entered, we need to reset this tracking, since the entered; // function might be not an immediate function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:118,Performance,perform,performed,118,"// See if this is a redefinition. If 'will have body' (or similar) is already; // set, then these checks were already performed when it was set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:399,Modifiability,variab,variables,399,"// If we are instantiating a generic lambda call operator, push; // a LambdaScopeInfo onto the function stack. But use the information; // that's already been calculated (ActOnLambdaExpr) to prime the current; // LambdaScopeInfo.; // When the template operator is being specialized, the LambdaScopeInfo,; // has to be properly restored so that tryCaptureVariable doesn't try; // and capture any new variables. In addition when calculating potential; // captures during transformation of nested lambdas, it is necessary to; // have the LSI properly restored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:35,Security,access,accessible,35,"// If the decl has a name, make it accessible in the current scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:76,Security,access,accessible,76,"// Similarly, dive into enums and fish their constants out, making them; // accessible in this scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:276,Testability,test,test,276,"// C++ [module.import/6] external definitions are not permitted in header; // units. Deleted and Defaulted functions are implicitly inline (but the; // inline state is not set at this point, so check the BodyKind explicitly).; // FIXME: Consider an alternate location for the test where the inlined(); // state is complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:80,Modifiability,variab,variables,80,"/// Given the set of return statements within a function body,; /// compute the variables that are subject to the named return value; /// optimization.; ///; /// Each of the variables that is subject to the named return value; /// optimization will be marked as NRVO variables in the AST, and any; /// return statement that has a marked NRVO variable as its NRVO candidate can; /// use the named return value optimization.; ///; /// This function applies a very simplistic algorithm for NRVO: if every return; /// statement in the scope of a variable has the same NRVO candidate, that; /// candidate is an NRVO variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:174,Modifiability,variab,variables,174,"/// Given the set of return statements within a function body,; /// compute the variables that are subject to the named return value; /// optimization.; ///; /// Each of the variables that is subject to the named return value; /// optimization will be marked as NRVO variables in the AST, and any; /// return statement that has a marked NRVO variable as its NRVO candidate can; /// use the named return value optimization.; ///; /// This function applies a very simplistic algorithm for NRVO: if every return; /// statement in the scope of a variable has the same NRVO candidate, that; /// candidate is an NRVO variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:267,Modifiability,variab,variables,267,"/// Given the set of return statements within a function body,; /// compute the variables that are subject to the named return value; /// optimization.; ///; /// Each of the variables that is subject to the named return value; /// optimization will be marked as NRVO variables in the AST, and any; /// return statement that has a marked NRVO variable as its NRVO candidate can; /// use the named return value optimization.; ///; /// This function applies a very simplistic algorithm for NRVO: if every return; /// statement in the scope of a variable has the same NRVO candidate, that; /// candidate is an NRVO variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:342,Modifiability,variab,variable,342,"/// Given the set of return statements within a function body,; /// compute the variables that are subject to the named return value; /// optimization.; ///; /// Each of the variables that is subject to the named return value; /// optimization will be marked as NRVO variables in the AST, and any; /// return statement that has a marked NRVO variable as its NRVO candidate can; /// use the named return value optimization.; ///; /// This function applies a very simplistic algorithm for NRVO: if every return; /// statement in the scope of a variable has the same NRVO candidate, that; /// candidate is an NRVO variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:542,Modifiability,variab,variable,542,"/// Given the set of return statements within a function body,; /// compute the variables that are subject to the named return value; /// optimization.; ///; /// Each of the variables that is subject to the named return value; /// optimization will be marked as NRVO variables in the AST, and any; /// return statement that has a marked NRVO variable as its NRVO candidate can; /// use the named return value optimization.; ///; /// This function applies a very simplistic algorithm for NRVO: if every return; /// statement in the scope of a variable has the same NRVO candidate, that; /// candidate is an NRVO variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:611,Modifiability,variab,variable,611,"/// Given the set of return statements within a function body,; /// compute the variables that are subject to the named return value; /// optimization.; ///; /// Each of the variables that is subject to the named return value; /// optimization will be marked as NRVO variables in the AST, and any; /// return statement that has a marked NRVO variable as its NRVO candidate can; /// use the named return value optimization.; ///; /// This function applies a very simplistic algorithm for NRVO: if every return; /// statement in the scope of a variable has the same NRVO candidate, that; /// candidate is an NRVO variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:138,Performance,optimiz,optimization,138,"/// Given the set of return statements within a function body,; /// compute the variables that are subject to the named return value; /// optimization.; ///; /// Each of the variables that is subject to the named return value; /// optimization will be marked as NRVO variables in the AST, and any; /// return statement that has a marked NRVO variable as its NRVO candidate can; /// use the named return value optimization.; ///; /// This function applies a very simplistic algorithm for NRVO: if every return; /// statement in the scope of a variable has the same NRVO candidate, that; /// candidate is an NRVO variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:231,Performance,optimiz,optimization,231,"/// Given the set of return statements within a function body,; /// compute the variables that are subject to the named return value; /// optimization.; ///; /// Each of the variables that is subject to the named return value; /// optimization will be marked as NRVO variables in the AST, and any; /// return statement that has a marked NRVO variable as its NRVO candidate can; /// use the named return value optimization.; ///; /// This function applies a very simplistic algorithm for NRVO: if every return; /// statement in the scope of a variable has the same NRVO candidate, that; /// candidate is an NRVO variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:409,Performance,optimiz,optimization,409,"/// Given the set of return statements within a function body,; /// compute the variables that are subject to the named return value; /// optimization.; ///; /// Each of the variables that is subject to the named return value; /// optimization will be marked as NRVO variables in the AST, and any; /// return statement that has a marked NRVO variable as its NRVO candidate can; /// use the named return value optimization.; ///; /// This function applies a very simplistic algorithm for NRVO: if every return; /// statement in the scope of a variable has the same NRVO candidate, that; /// candidate is an NRVO variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:462,Usability,simpl,simplistic,462,"/// Given the set of return statements within a function body,; /// compute the variables that are subject to the named return value; /// optimization.; ///; /// Each of the variables that is subject to the named return value; /// optimization will be marked as NRVO variables in the AST, and any; /// return statement that has a marked NRVO variable as its NRVO candidate can; /// use the named return value optimization.; ///; /// This function applies a very simplistic algorithm for NRVO: if every return; /// statement in the scope of a variable has the same NRVO candidate, that; /// candidate is an NRVO variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:105,Integrability,depend,dependent,105,"// We can't simply call Type::isUndeducedType here, because inside template; // auto can be deduced to a dependent type, which is not considered; // ""undeduced"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:12,Usability,simpl,simply,12,"// We can't simply call Type::isUndeducedType here, because inside template; // auto can be deduced to a dependent type, which is not considered; // ""undeduced"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Deployability,Update,Update,3,// Update the return type to the deduced type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:39,Performance,optimiz,optimization,39,// Try to apply the named return value optimization. We have to check; // if we can do this here because lambdas keep return statements around; // to deduce an implicit return type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:217,Safety,detect,detect,217,// GNU warning -Wmissing-prototypes:; // Warn if a global function is defined without a previous; // prototype declaration. This warning is issued even if the; // definition itself provides a prototype. The aim is to detect; // global functions that fail to be declared in header files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:725,Integrability,depend,depending,725,"// The function definition has parameters, so this will change behavior; // in C23. If there is a possible prototype, it comes before the; // function definition.; // FIXME: The declaration may have already been diagnosed as being; // deprecated in GetFullTypeForDeclarator() if it had no arguments, but; // there's no way to test for the ""changes behavior"" condition in; // SemaType.cpp when forming the declaration's function type. So, we do; // this awkward dance instead.; //; // If we have a possible prototype and it declares a function with a; // prototype, we don't want to diagnose it; if we have a possible; // prototype and it has no prototype, it may have already been; // diagnosed in SemaType.cpp as deprecated depending on whether; // -Wstrict-prototypes is enabled. If we already warned about it being; // deprecated, add a note that it also changes behavior. If we didn't; // warn about it being deprecated (because the diagnostic is not; // enabled), warn now that it is deprecated and changes behavior.; // This K&R C function definition definitely changes behavior in C23,; // so diagnose it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:326,Testability,test,test,326,"// The function definition has parameters, so this will change behavior; // in C23. If there is a possible prototype, it comes before the; // function definition.; // FIXME: The declaration may have already been diagnosed as being; // deprecated in GetFullTypeForDeclarator() if it had no arguments, but; // there's no way to test for the ""changes behavior"" condition in; // SemaType.cpp when forming the declaration's function type. So, we do; // this awkward dance instead.; //; // If we have a possible prototype and it declares a function with a; // prototype, we don't want to diagnose it; if we have a possible; // prototype and it has no prototype, it may have already been; // diagnosed in SemaType.cpp as deprecated depending on whether; // -Wstrict-prototypes is enabled. If we already warned about it being; // deprecated, add a note that it also changes behavior. If we didn't; // warn about it being deprecated (because the diagnostic is not; // enabled), warn now that it is deprecated and changes behavior.; // This K&R C function definition definitely changes behavior in C23,; // so diagnose it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:105,Testability,test,tested,105,"// If we have a possible prototype for the function which is a user-; // visible declaration, we already tested that it has no prototype.; // This will change behavior in C23. This gets a warning rather than a; // note because it's the same behavior-changing problem as with the; // definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Deployability,Update,Update,3,// Update the key-function state if necessary for this ABI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:10,Availability,error,errors,10,"// If any errors have occurred, clear out any temporaries that may have; // been leftover. This ensures that these temporaries won't be picked up; // for deletion in some later function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:32,Usability,clear,clear,32,"// If any errors have occurred, clear out any temporaries that may have; // been leftover. This ensures that these temporaries won't be picked up; // for deletion in some later function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:24,Modifiability,variab,variables,24,// Allow local register variables without initializer as they don't; // require prologue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:10,Availability,error,errors,10,"// If any errors have occurred, clear out any temporaries that may have; // been leftover. This ensures that these temporaries won't be picked up for; // deletion in some later function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:32,Usability,clear,clear,32,"// If any errors have occurred, clear out any temporaries that may have; // been leftover. This ensures that these temporaries won't be picked up for; // deletion in some later function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:45,Integrability,inject,injected,45,"// Find the scope in which the identifier is injected and the corresponding; // DeclContext.; // FIXME: C89 does not say what happens if there is no enclosing block scope.; // In that case, we inject the declaration into the translation unit scope; // instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:193,Integrability,inject,inject,193,"// Find the scope in which the identifier is injected and the corresponding; // DeclContext.; // FIXME: C89 does not say what happens if there is no enclosing block scope.; // In that case, we inject the declaration into the translation unit scope; // instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:45,Security,inject,injected,45,"// Find the scope in which the identifier is injected and the corresponding; // DeclContext.; // FIXME: C89 does not say what happens if there is no enclosing block scope.; // In that case, we inject the declaration into the translation unit scope; // instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:193,Security,inject,inject,193,"// Find the scope in which the identifier is injected and the corresponding; // DeclContext.; // FIXME: C89 does not say what happens if there is no enclosing block scope.; // In that case, we inject the declaration into the translation unit scope; // instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:176,Safety,avoid,avoids,176,"// Loop until we find a DeclContext that is either a function/method or the; // translation unit, which are the only two valid places to implicitly define; // a function. This avoids accidentally defining the function within a tag; // declaration, for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:160,Modifiability,variab,variable,160,"// Before we produce a declaration for an implicitly defined; // function, see whether there was a locally-scoped declaration of; // this name as a function or variable. If so, use that; // (non-visible) declaration, and complain about it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:20,Integrability,inject,inject,20,// We still need to inject the function into the enclosing block scope so; // that later (non-call) uses can see it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:20,Security,inject,inject,20,// We still need to inject the function into the enclosing block scope so; // that later (non-call) uses can see it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:33,Availability,error,error,33,"// Extension in C99 (defaults to error). Legal in C89, but warn about it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:122,Availability,error,error,122,"// Because typo correction is expensive, only do it if the implicit; // function declaration is going to be treated as an error.; //; // Perform the correction before issuing the main diagnostic, as some; // consumers use typo-correction callbacks to enhance the main diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:251,Modifiability,enhance,enhance,251,"// Because typo correction is expensive, only do it if the implicit; // function declaration is going to be treated as an error.; //; // Perform the correction before issuing the main diagnostic, as some; // consumers use typo-correction callbacks to enhance the main diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:137,Performance,Perform,Perform,137,"// Because typo correction is expensive, only do it if the implicit; // function declaration is going to be treated as an error.; //; // Perform the correction before issuing the main diagnostic, as some; // consumers use typo-correction callbacks to enhance the main diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:2,Availability,Error,ErrorRecovery,2,/*ErrorRecovery*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:132,Availability,failure,failure,132,"// C++2a [basic.stc.dynamic.allocation]p4:; // An allocation function that has a non-throwing exception specification; // indicates failure by returning a null pointer value. Any other allocation; // function never returns a null pointer value and indicates failure only by; // throwing an exception [...]; //; // However, -fcheck-new invalidates this possible assumption, so don't add; // NonNull when that is enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:258,Availability,failure,failure,258,"// C++2a [basic.stc.dynamic.allocation]p4:; // An allocation function that has a non-throwing exception specification; // indicates failure by returning a null pointer value. Any other allocation; // function never returns a null pointer value and indicates failure only by; // throwing an exception [...]; //; // However, -fcheck-new invalidates this possible assumption, so don't add; // NonNull when that is enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:82,Energy Efficiency,allocate,allocate,82,"// C++2a [basic.stc.dynamic.allocation]p2:; // An allocation function attempts to allocate the requested amount of; // storage. [...] If the request succeeds, the value returned by a; // replaceable allocation function is a [...] pointer value p0 different; // from any previously returned value p1 [...]; //; // However, this particular information is being added in codegen,; // because there is an opt-out switch for it (-fno-assume-sane-operator-new); // C++2a [basic.stc.dynamic.allocation]p2:; // An allocation function attempts to allocate the requested amount of; // storage. If it is successful, it returns the address of the start of a; // block of storage whose length in bytes is at least as large as the; // requested size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:538,Energy Efficiency,allocate,allocate,538,"// C++2a [basic.stc.dynamic.allocation]p2:; // An allocation function attempts to allocate the requested amount of; // storage. [...] If the request succeeds, the value returned by a; // replaceable allocation function is a [...] pointer value p0 different; // from any previously returned value p1 [...]; //; // However, this particular information is being added in codegen,; // because there is an opt-out switch for it (-fno-assume-sane-operator-new); // C++2a [basic.stc.dynamic.allocation]p2:; // An allocation function attempts to allocate the requested amount of; // storage. If it is successful, it returns the address of the start of a; // block of storage whose length in bytes is at least as large as the; // requested size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:347,Modifiability,extend,extended,347,"// FIXME:; // C++2a [basic.stc.dynamic.allocation]p3:; // For an allocation function [...], the pointer returned on a successful; // call shall represent the address of storage that is aligned as follows:; // (3.2) Otherwise, if the allocation function is named operator new[],; // the storage is aligned for any object that does not have; // new-extended alignment ([basic.align]) and is no larger than the; // requested size.; // (3.3) Otherwise, the storage is aligned for any object that does not; // have new-extended alignment and is of the requested size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:514,Modifiability,extend,extended,514,"// FIXME:; // C++2a [basic.stc.dynamic.allocation]p3:; // For an allocation function [...], the pointer returned on a successful; // call shall represent the address of storage that is aligned as follows:; // (3.2) Otherwise, if the allocation function is named operator new[],; // the storage is aligned for any object that does not have; // new-extended alignment ([basic.align]) and is no larger than the; // requested size.; // (3.3) Otherwise, the storage is aligned for any object that does not; // have new-extended alignment and is of the requested size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:34,Integrability,depend,depending,34,"// Add the appropriate attribute, depending on the CUDA compilation mode; // and which target the builtin belongs to. For example, during host; // compilation, aux builtins are __device__, while the rest are __host__.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:49,Availability,error,error,49,// This doesn't use 'isIntegralType' despite the error message mentioning; // integral type because isIntegralType would also allow enum types in C.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:55,Integrability,message,message,55,// This doesn't use 'isIntegralType' despite the error message mentioning; // integral type because isIntegralType would also allow enum types in C.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:80,Integrability,message,message,80,/// Get diagnostic %select index for tag kind for; /// redeclaration diagnostic message.; /// WARNING: Indexes apply to particular diagnostics only!; ///; /// \returns diagnostic %select index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:117,Safety,avoid,avoids,117,"// We only need to do this matching if we have template parameters; // or a scope specifier, which also conveniently avoids this work; // for non-C++ cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:115,Safety,detect,detect,115,"// Figure out the underlying type if this a enum declaration. We need to do; // this early, because it's needed to detect if this is an incompatible; // redeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Availability,Recover,Recover,3,// Recover by falling back to int.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Recover,Recover,3,// Recover by falling back to int.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:54,Integrability,depend,dependent,54,"// If this is a friend or a reference to a class in a dependent; // context, don't try to make a decl for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:160,Integrability,depend,dependent,160,"// Name lookup did not find anything. However, if the; // nested-name-specifier refers to the current instantiation,; // and that current instantiation has any dependent base; // classes, we might find something at instantiation time: treat; // this as a dependent elaborated-type-specifier.; // But this only makes any sense for reference-like lookups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:255,Integrability,depend,dependent,255,"// Name lookup did not find anything. However, if the; // nested-name-specifier refers to the current instantiation,; // and that current instantiation has any dependent base; // classes, we might find something at instantiation time: treat; // this as a dependent elaborated-type-specifier.; // But this only makes any sense for reference-like lookups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:42,Availability,recover,recovery,42,// Note: there used to be some attempt at recovery here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:42,Safety,recover,recovery,42,// Note: there used to be some attempt at recovery here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:650,Availability,error,error,650,"// C++ [basic.scope.pdecl]p5:; // -- for an elaborated-type-specifier of the form; //; // class-key identifier; //; // if the elaborated-type-specifier is used in the; // decl-specifier-seq or parameter-declaration-clause of a; // function defined in namespace scope, the identifier is; // declared as a class-name in the namespace that contains; // the declaration; otherwise, except as a friend; // declaration, the identifier is declared in the smallest; // non-class, non-function-prototype scope that contains the; // declaration.; //; // C99 6.7.2.3p8 has a similar (but not identical!) provision for; // C structs and unions.; //; // It is an error in C++ to declare (rather than define) an enum; // type, including via an elaborated type specifier. We'll; // diagnose that later; for now, declare the enum in the same; // scope as we would have picked for any other tag type.; //; // GNU C also supports this behavior as part of its incomplete; // enum types extension, while GNU C++ does not.; //; // Find the context where we'll be declaring the tag.; // FIXME: We would like to maintain the current DeclContext as the; // lexical context,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:220,Availability,error,errors,220,"// In C++, we need to do a redeclaration lookup to properly; // diagnose some problems.; // FIXME: redeclaration lookup is also used (with and without C++) to find a; // hidden declaration so that we don't get ambiguity errors when using a; // type declared by an elaborated-type-specifier. In C that is not correct; // and we should instead merge compatible types found by lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:19,Performance,perform,perform,19,"// FIXME: This can perform qualified lookups into function contexts,; // which are meaningless.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Availability,Recover,Recover,3,// Recover by ignoring the old declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Recover,Recover,3,// Recover by ignoring the old declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Availability,Recover,Recover,3,// Recover by making this an anonymous redefinition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Recover,Recover,3,// Recover by making this an anonymous redefinition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:48,Availability,recover,recovered,48,"// All conflicts with previous declarations are recovered by; // returning the previous declaration, unless this is a definition,; // in which case we want the caller to bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:48,Safety,recover,recovered,48,"// All conflicts with previous declarations are recovered by; // returning the previous declaration, unless this is a definition,; // in which case we want the caller to bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:414,Integrability,inject,injected,414,"// This declaration is a reference to an existing entity, but; // has different visibility from that entity: it either makes; // a friend visible or it makes a type visible in a new module.; // In either case, create a new declaration. We only do this if; // the declaration would have meant the same thing if no prior; // declaration were found, that is, if it was found in the same; // scope where we would have injected a declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:414,Security,inject,injected,414,"// This declaration is a reference to an existing entity, but; // has different visibility from that entity: it either makes; // a friend visible or it makes a type visible in a new module.; // In either case, create a new declaration. We only do this if; // the declaration would have meant the same thing if no prior; // declaration were found, that is, if it was found in the same; // scope where we would have injected a declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:18,Integrability,inject,injected,18,"// This is in the injected scope, create a new declaration in; // that scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:18,Security,inject,injected,18,"// This is in the injected scope, create a new declaration in; // that scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:119,Availability,error,error,119,"// If we're defining a specialization and the previous definition; // is from an implicit instantiation, don't emit an error; // here; we'll catch this in the general case below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:30,Availability,recover,recover,30,"// If this is a redefinition, recover by making this; // struct be anonymous, which will make any later; // references get the previous definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:30,Safety,recover,recover,30,"// If this is a redefinition, recover by making this; // struct be anonymous, which will make any later; // references get the previous definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:181,Security,access,access,181,"// Okay, we're going to make a redeclaration. If this is some kind; // of reference, make sure we build the redeclaration in the same DC; // as the original, and ignore the current access specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:78,Availability,error,error,78,"// The tag name clashes with something else in the target scope,; // issue an error and recover by making this tag be anonymous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:88,Availability,recover,recover,88,"// The tag name clashes with something else in the target scope,; // issue an error and recover by making this tag be anonymous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:88,Safety,recover,recover,88,"// The tag name clashes with something else in the target scope,; // issue an error and recover by making this tag be anonymous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:79,Usability,clear,clear,79,"// The existing declaration isn't relevant to us; we're in a; // new scope, so clear out the previous declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:47,Usability,simpl,simple,47,// FIXME: Look for a way to use RecordDecl for simple structs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:96,Availability,error,error,96,"// __module_private__ does not apply to local classes. However, we only; // diagnose this as an error when the declaration specifiers are; // freestanding. Here, we just ignore the __module_private__.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:174,Integrability,inject,inject,174,"// If we're declaring or defining a tag in function prototype scope in C,; // note that this type can only be used within the function and add it to; // the list of decls to inject into the function definition scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:174,Security,inject,inject,174,"// If we're declaring or defining a tag in function prototype scope in C,; // note that this type can only be used within the function and add it to; // the list of decls to inject into the function definition scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,Security,access,access,11,// Set the access specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:93,Security,access,access,93,"// We might be replacing an existing declaration in the lookup tables;; // if so, borrow its access specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:26,Availability,error,error,26,// can be null along some error paths,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:57,Availability,recover,recover,57,"// In C++, don't return an invalid declaration. We can't recover well from; // the cases where we make the type anonymous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:57,Safety,recover,recover,57,"// In C++, don't return an invalid declaration. We can't recover well from; // the cases where we make the type anonymous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:121,Integrability,inject,injected-class-name,121,"// C++ [class]p2:; // [...] The class-name is also inserted into the scope of the; // class itself; this is known as the injected-class-name. For; // purposes of access checking, the injected-class-name is treated; // as if it were a public member name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:183,Integrability,inject,injected-class-name,183,"// C++ [class]p2:; // [...] The class-name is also inserted into the scope of the; // class itself; this is known as the injected-class-name. For; // purposes of access checking, the injected-class-name is treated; // as if it were a public member name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:121,Security,inject,injected-class-name,121,"// C++ [class]p2:; // [...] The class-name is also inserted into the scope of the; // class itself; this is known as the injected-class-name. For; // purposes of access checking, the injected-class-name is treated; // as if it were a public member name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:162,Security,access,access,162,"// C++ [class]p2:; // [...] The class-name is also inserted into the scope of the; // class itself; this is known as the injected-class-name. For; // purposes of access checking, the injected-class-name is treated; // as if it were a public member name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:183,Security,inject,injected-class-name,183,"// C++ [class]p2:; // [...] The class-name is also inserted into the scope of the; // class itself; this is known as the injected-class-name. For; // purposes of access checking, the injected-class-name is treated; // as if it were a public member name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:27,Integrability,interface,interface,27,// Exit this scope of this interface definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:9,Usability,undo,undoing,9,"// We're undoing ActOnTagStartDefinition here, not; // ActOnStartCXXMemberDeclarations, so we don't have to mess with; // the FieldCollector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:56,Availability,error,error,56,// Handle incomplete and sizeless types with a specific error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:38,Integrability,depend,dependent,38,"// If the bit-width is type- or value-dependent, don't try to check; // it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:30,Availability,error,error,30,// Over-wide bitfields are an error in C or when using the MSVC bitfield; // ABI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:72,Integrability,rout,routine,72,"/// Build a new FieldDecl and check its well-formedness.; ///; /// This routine builds a new FieldDecl given the fields name, type,; /// record, etc. \p PrevDecl should refer to any previous declaration; /// with the same name and in the same scope as the field to be; /// created.; ///; /// \returns a new FieldDecl.; ///; /// \todo The Declarator argument is a hack. It will be removed once",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:32,Availability,recover,recover,32,"// If we receive a broken type, recover by assuming 'int' and; // marking this declaration as invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:32,Safety,recover,recover,32,"// If we receive a broken type, recover by assuming 'int' and; // marking this declaration as invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:86,Modifiability,variab,variably,86,// C99 6.7.2.1p8: A member of a structure or union may have any type other; // than a variably modified type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:18,Deployability,release,release,18,"// In auto-retain/release, infer strong retension for fields of; // retainable type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:31,Availability,error,error,31,"// Objective-C++ ARC: it is an error to have a non-trivial field of; // a union. However, system headers in Objective-C programs; // occasionally have Objective-C lifetime objects within unions,; // and rather than cause the program to fail, we make those; // members unavailable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:99,Integrability,inject,inject,99,"// FIXME: Unnamed fields can be handled in various different ways, for; // example, unnamed unions inject all members into the struct namespace!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:99,Security,inject,inject,99,"// FIXME: Unnamed fields can be handled in various different ways, for; // example, unnamed unions inject all members into the struct namespace!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:23,Security,validat,validate,23,// Not a bitfield.; // validate II.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:86,Modifiability,variab,variably,86,// C99 6.7.2.1p8: A member of a structure or union may have any type other; // than a variably modified type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:23,Security,access,access,23,// Get the visibility (access control) for this ivar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:48,Integrability,interface,interface,48,// Must set ivar's DeclContext to its enclosing interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:15,Integrability,interface,interfaces,15,"// FIXME: When interfaces are DeclContexts, we'll need to add; // these to the interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:79,Integrability,interface,interface,79,"// FIXME: When interfaces are DeclContexts, we'll need to add; // these to the interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:29,Integrability,rout,routine,29,"/// ActOnLastBitfield - This routine handles synthesized bitfields rules for; /// class and class extensions. For every class \@interface and class; /// extension \@interface, if the last ivar is a bitfield of any type,; /// then add an implicit `char :0` ivar to the end of that interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:128,Integrability,interface,interface,128,"/// ActOnLastBitfield - This routine handles synthesized bitfields rules for; /// class and class extensions. For every class \@interface and class; /// extension \@interface, if the last ivar is a bitfield of any type,; /// then add an implicit `char :0` ivar to the end of that interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:165,Integrability,interface,interface,165,"/// ActOnLastBitfield - This routine handles synthesized bitfields rules for; /// class and class extensions. For every class \@interface and class; /// extension \@interface, if the last ivar is a bitfield of any type,; /// then add an implicit `char :0` ivar to the end of that interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:280,Integrability,interface,interface,280,"/// ActOnLastBitfield - This routine handles synthesized bitfields rules for; /// class and class extensions. For every class \@interface and class; /// extension \@interface, if the last ivar is a bitfield of any type,; /// then add an implicit `char :0` ivar to the end of that interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:94,Performance,perform,performed,94,"/// [class.dtor]p4:; /// At the end of the definition of a class, overload resolution is; /// performed among the prospective destructors declared in that class with; /// an empty argument list to select the destructor for the class, also; /// known as the selected destructor.; ///; /// We do the overload resolution here, then mark the selected constructor in the AST.; /// Later CXXRecordDecl::getDestructor() will return the selected constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:51,Availability,error,error,51,// It's a bit hacky: At this point we've raised an error but we want the; // rest of the compiler to continue somehow working. However almost; // everything we'll try to do with the class will depend on there being a; // destructor. So let's pretend the first one is selected and hope for the; // best.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:193,Integrability,depend,depend,193,// It's a bit hacky: At this point we've raised an error but we want the; // rest of the compiler to continue somehow working. However almost; // everything we'll try to do with the class will depend on there being a; // destructor. So let's pretend the first one is selected and hope for the; // best.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:16,Availability,error,error,16,// There was an error with the constraints comparison. Exit the loop; // and don't consider this function eligible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:123,Integrability,interface,interface,123,// If this is an Objective-C @implementation or category and we have; // new fields here we should reset the layout of the interface since; // it will now change.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Modifiability,Flexible,Flexible,3,// Flexible array member.; // Microsoft and g++ is more permissive regarding flexible array.; // It will accept flexible array in union and also; // as the sole element of a struct/class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:77,Modifiability,flexible,flexible,77,// Flexible array member.; // Microsoft and g++ is more permissive regarding flexible array.; // It will accept flexible array in union and also; // as the sole element of a struct/class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:112,Modifiability,flexible,flexible,112,// Flexible array member.; // Microsoft and g++ is more permissive regarding flexible array.; // It will accept flexible array in union and also; // as the sole element of a struct/class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:207,Modifiability,flexible,flexible,207,"// While the layout of types that contain virtual bases is not specified; // by the C++ standard, both the Itanium and Microsoft C++ ABIs place; // virtual bases after the derived members. This would make a flexible; // array member declared at the end of an object not adjacent to the end; // of the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:25,Modifiability,flexible,flexible,25,"// Okay, we have a legal flexible array member at the end of the struct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:27,Modifiability,flexible,flexible,27,// A type which contains a flexible array member is considered to be a; // flexible array member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:75,Modifiability,flexible,flexible,75,// A type which contains a flexible array member is considered to be a; // flexible array member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:101,Modifiability,variab,variable,101,"// If this is a struct/class and this is not the last element, reject; // it. Note that GCC supports variable sized arrays in the middle of; // structures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:14,Modifiability,flexible,flexible,14,// We support flexible arrays at the end of structs in; // other structs as an extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:7,Security,access,access,7,// Set access bits correctly on the directly-declared conversions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:79,Availability,error,errors,79,// case of ivars in class extension; all other cases have been; // reported as errors elsewhere.; // FIXME. Class extension does not have a LocEnd field.; // CDecl->setLocEnd(RBrac);; // Add ivar's to class extension's DeclContext.; // Diagnose redeclaration of private ivars.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:146,Performance,perform,perform,146,"// In Obj-C and Microsoft mode, require the enumeration value to be; // representable in the underlying type of the enumeration. In C++11,; // we perform a non-narrowing conversion as part of converted constant; // expression checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,Integrability,wrap,wrap,106,"// There is no integral type larger enough to represent this; // value. Complain, then allow the value to wrap around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Safety,Avoid,Avoid,3,// Avoid anonymous enums,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:27,Safety,avoid,avoid,27,// Use int64_t as a key to avoid needing special handling for map keys.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Deployability,Update,Update,3,// Update entry to point to the duplicates vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:130,Availability,mask,masks,130,"// A value is in a flag enum if either its bits are a subset of the enum's; // flag bits (the first condition) or we are allowing masks and the same is; // true of its complement (the second condition). When masks are allowed, we; // allow the common idiom of ~(enum1 | enum2) to be a valid enum value.; //; // While it's true that any value could be used as a mask, the assumption is; // that a mask will have all of the insignificant bits set. Anything else is; // likely a logic error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:208,Availability,mask,masks,208,"// A value is in a flag enum if either its bits are a subset of the enum's; // flag bits (the first condition) or we are allowing masks and the same is; // true of its complement (the second condition). When masks are allowed, we; // allow the common idiom of ~(enum1 | enum2) to be a valid enum value.; //; // While it's true that any value could be used as a mask, the assumption is; // that a mask will have all of the insignificant bits set. Anything else is; // likely a logic error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:361,Availability,mask,mask,361,"// A value is in a flag enum if either its bits are a subset of the enum's; // flag bits (the first condition) or we are allowing masks and the same is; // true of its complement (the second condition). When masks are allowed, we; // allow the common idiom of ~(enum1 | enum2) to be a valid enum value.; //; // While it's true that any value could be used as a mask, the assumption is; // that a mask will have all of the insignificant bits set. Anything else is; // likely a logic error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:396,Availability,mask,mask,396,"// A value is in a flag enum if either its bits are a subset of the enum's; // flag bits (the first condition) or we are allowing masks and the same is; // true of its complement (the second condition). When masks are allowed, we; // allow the common idiom of ~(enum1 | enum2) to be a valid enum value.; //; // While it's true that any value could be used as a mask, the assumption is; // that a mask will have all of the insignificant bits set. Anything else is; // likely a logic error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:482,Availability,error,error,482,"// A value is in a flag enum if either its bits are a subset of the enum's; // flag bits (the first condition) or we are allowing masks and the same is; // true of its complement (the second condition). When masks are allowed, we; // allow the common idiom of ~(enum1 | enum2) to be a valid enum value.; //; // While it's true that any value could be used as a mask, the assumption is; // that a mask will have all of the insignificant bits set. Anything else is; // likely a logic error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:476,Testability,log,logic,476,"// A value is in a flag enum if either its bits are a subset of the enum's; // flag bits (the first condition) or we are allowing masks and the same is; // true of its complement (the second condition). When masks are allowed, we; // allow the common idiom of ~(enum1 | enum2) to be a valid enum value.; //; // While it's true that any value could be used as a mask, the assumption is; // that a mask will have all of the insignificant bits set. Anything else is; // likely a logic error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:58,Modifiability,variab,variable,58,"// If a declaration that:; // 1) declares a function or a variable; // 2) has external linkage; // already exists, add a label attribute to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:2,Modifiability,Variab,Variable,2,/*Variable*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:192,Testability,stub,stub,192,"// When compiling for device, host functions are never emitted. Similarly,; // when compiling for host, device and global functions are never emitted.; // (Technically, we do emit a host-side stub for global functions, but this; // doesn't count for our purposes here.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:62,Testability,stub,stub,62,"// Host-side references to a __global__ function refer to the stub, so the; // function itself is never emitted and therefore should not be marked.; // If we have host fn calls kernel fn calls host+device, the HD function; // does not get instantiated on the host. We model this by omitting at the; // call to the kernel from the callgraph. This ensures that, when compiling; // for host, only HD functions actually called from the host get marked as; // known-emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:330,Modifiability,variab,variable,330,// end namespace AttributeLangSupport; //===----------------------------------------------------------------------===//; // Helper functions; //===----------------------------------------------------------------------===//; /// isFunctionOrMethod - Return true if the given decl has function; /// type (function or function-typed variable) or an Objective-C; /// method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:85,Modifiability,variab,variable,85,/// Return true if the given decl has function type (function or; /// function-typed variable) or an Objective-C method or a block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:97,Availability,error,error,97,/// getFunctionOrMethodNumParams - Return number of function or method; /// parameters. It is an error to call this on a K&R function (use; /// hasFunctionProto first).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:108,Availability,failure,failure,108,"/// If Expr is a valid integer constant, get the value of the integer; /// expression and return success or failure. May output an error.; ///; /// Negative argument is implicitly converted to unsigned, unless; /// \p StrictlyUnsigned is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:131,Availability,error,error,131,"/// If Expr is a valid integer constant, get the value of the integer; /// expression and return success or failure. May output an error.; ///; /// Negative argument is implicitly converted to unsigned, unless; /// \p StrictlyUnsigned is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:4,Integrability,Wrap,Wrapper,4,"/// Wrapper around checkUInt32Argument, with an extra check to be sure; /// that the result will fit into a regular (signed) int. All args have the same; /// purpose as they do in checkUInt32Argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:104,Availability,error,error,104,/// Check if IdxExpr is a valid parameter index for a function or; /// instance method D. May output an error.; ///; /// \returns true if IdxExpr is a valid index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:73,Availability,error,error,73,"/// Check if the argument \p E is a ASCII string literal. If not emit an error; /// and return false, otherwise set \p Str to the value of the string literal; /// and return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:94,Availability,error,error,94,/// Check if the argument \p ArgNum of \p Attr is a ASCII string literal.; /// If not emit an error and return false. If the argument is an identifier it; /// will emit an error with a fixit hint and treat it as if it was a string; /// literal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:172,Availability,error,error,172,/// Check if the argument \p ArgNum of \p Attr is a ASCII string literal.; /// If not emit an error and return false. If the argument is an identifier it; /// will emit an error with a fixit hint and treat it as if it was a string; /// literal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:52,Performance,perform,performing,52,/// Applies the given attribute to the Decl without performing any; /// additional semantic checking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:91,Availability,error,error,91,/// Check if passed in Decl is a pointer type.; /// Note that this function may produce an error message.; /// \return true if the Decl is a pointer type; false otherwise,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:97,Integrability,message,message,97,/// Check if passed in Decl is a pointer type.; /// Note that this function may produce an error message.; /// \return true if the Decl is a pointer type; false otherwise,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:130,Safety,avoid,avoid,130,"// If it's an incomplete type, it could be a smart pointer; skip it.; // (We don't want to force template instantiation if we can avoid it,; // since that would alter the order in which templates are instantiated.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:71,Testability,log,logic,71,"// Capability expressions are simple expressions involving the boolean logic; // operators &&, || or !, a simple DeclRefExpr, CastExpr or a ParenExpr. Once; // a DeclRefExpr is found, its type should be checked to determine whether it; // is a capability or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:30,Usability,simpl,simple,30,"// Capability expressions are simple expressions involving the boolean logic; // operators &&, || or !, a simple DeclRefExpr, CastExpr or a ParenExpr. Once; // a DeclRefExpr is found, its type should be checked to determine whether it; // is a capability or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:106,Usability,simpl,simple,106,"// Capability expressions are simple expressions involving the boolean logic; // operators &&, || or !, a simple DeclRefExpr, CastExpr or a ParenExpr. Once; // a DeclRefExpr is found, its type should be checked to determine whether it; // is a capability or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:229,Testability,log,logic,229,"// If the type does not have a capability, see if the components of the; // expression have capabilities. This allows for writing C code where the; // capability may be on the type, and the expression is a capability; // boolean logic expression. Eg) requires_capability(A || B && !C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:73,Modifiability,variab,variables,73,// The IBOutlet/IBOutletCollection attributes only apply to instance; // variables or properties of Objective-C classes. The outlet must also; // have an object reference type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:50,Integrability,message,message,50,// Handle the case where the attribute has a text message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:6,Availability,error,error,6,// No error,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:50,Integrability,message,message,50,// Handle the case where the attribute has a text message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:27,Availability,avail,availability,27,// If there is an existing availability attribute for this platform that; // has a lower priority use the existing one and discard the new; // attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:46,Availability,avail,availability,46,// Allow different 'introduced' / 'obsoleted' availability versions; // on a method that implements an optional protocol requirement. It; // makes less sense to allow this for 'deprecated' as the user can't; // see if the method is 'deprecated' as 'respondsToSelector' will; // still return true when the method is deprecated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:112,Integrability,protocol,protocol,112,// Allow different 'introduced' / 'obsoleted' availability versions; // on a method that implements an optional protocol requirement. It; // makes less sense to allow this for 'deprecated' as the user can't; // see if the method is 'deprecated' as 'respondsToSelector' will; // still return true when the method is deprecated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:22,Availability,avail,availability,22,// Infer Mac Catalyst availability from the macOS availability attribute; // if it has versioned availability. Don't infer 'unavailable'. This; // inferred availability has lower priority than the other availability; // attributes that are inferred from 'ios'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:50,Availability,avail,availability,50,// Infer Mac Catalyst availability from the macOS availability attribute; // if it has versioned availability. Don't infer 'unavailable'. This; // inferred availability has lower priority than the other availability; // attributes that are inferred from 'ios'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:97,Availability,avail,availability,97,// Infer Mac Catalyst availability from the macOS availability attribute; // if it has versioned availability. Don't infer 'unavailable'. This; // inferred availability has lower priority than the other availability; // attributes that are inferred from 'ios'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:156,Availability,avail,availability,156,// Infer Mac Catalyst availability from the macOS availability attribute; // if it has versioned availability. Don't infer 'unavailable'. This; // inferred availability has lower priority than the other availability; // attributes that are inferred from 'ios'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:203,Availability,avail,availability,203,// Infer Mac Catalyst availability from the macOS availability attribute; // if it has versioned availability. Don't infer 'unavailable'. This; // inferred availability has lower priority than the other availability; // attributes that are inferred from 'ios'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:69,Integrability,protocol,protocol,69,// objc_direct cannot be set on methods declared in the context of a protocol,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:201,Availability,error,error,201,"// It is okay to include this attribute on properties, e.g.:; //; // @property (retain, nonatomic) struct Bork *Q __attribute__((NSObject));; //; // In this case it follows tradition and suppresses an error in the above; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:15,Availability,error,error,15,"// FIXME: This error message could be improved, it would be nice; // to say what the bounds actually are.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:21,Integrability,message,message,21,"// FIXME: This error message could be improved, it would be nice; // to say what the bounds actually are.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:47,Modifiability,variab,variable,47,// The standard attribute cannot be applied to variable declarations such; // as a function pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:31,Modifiability,variab,variable,31,// weak_import only applies to variable & function declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:46,Modifiability,inherit,inherit,46,// Explicit or partial specializations do not inherit; // the section attribute from the primary template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:209,Availability,Error,Error,209,"/// Used to implement to perform semantic checking on; /// attribute((section(""foo""))) specifiers.; ///; /// In this case, ""foo"" is passed in to be checked. If the section; /// specifier is invalid, return an Error that indicates the problem.; ///; /// This is a simple quality of implementation feature to catch errors; /// and give good diagnostics in cases when the assembler or code generator; /// would otherwise reject the section specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:313,Availability,error,errors,313,"/// Used to implement to perform semantic checking on; /// attribute((section(""foo""))) specifiers.; ///; /// In this case, ""foo"" is passed in to be checked. If the section; /// specifier is invalid, return an Error that indicates the problem.; ///; /// This is a simple quality of implementation feature to catch errors; /// and give good diagnostics in cases when the assembler or code generator; /// would otherwise reject the section specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:25,Performance,perform,perform,25,"/// Used to implement to perform semantic checking on; /// attribute((section(""foo""))) specifiers.; ///; /// In this case, ""foo"" is passed in to be checked. If the section; /// specifier is invalid, return an Error that indicates the problem.; ///; /// This is a simple quality of implementation feature to catch errors; /// and give good diagnostics in cases when the assembler or code generator; /// would otherwise reject the section specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:263,Usability,simpl,simple,263,"/// Used to implement to perform semantic checking on; /// attribute((section(""foo""))) specifiers.; ///; /// In this case, ""foo"" is passed in to be checked. If the section; /// specifier is invalid, return an Error that indicates the problem.; ///; /// This is a simple quality of implementation feature to catch errors; /// and give good diagnostics in cases when the assembler or code generator; /// would otherwise reject the section specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:22,Security,validat,validate,22,// Let MCSectionMachO validate this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:46,Modifiability,inherit,inherit,46,// Explicit or partial specializations do not inherit; // the code_seg attribute from the primary template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:19,Performance,tune,tune,19,// Diagnose use of tune if target doesn't support it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:23,Usability,simpl,simple,23,"// gcc only allows for simple identifiers. Since we support more than gcc, we; // will warn the user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:8,Performance,perform,perform,8,"// Only perform the priority check if the attribute is outside of a system; // header. Values <= 100 are reserved for the implementation, and libc++; // benefits from being able to specify values in that range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:52,Testability,test,test,52,// FIXME: this isn't fully correct; we also need to test whether the; // members of the union would all have the same calling convention as the; // first member of the union. Checking just the size and alignment isn't; // sufficient (consider structs passed on the stack instead of in registers; // as an example).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:8,Integrability,depend,dependent,8,// Save dependent expressions in the AST to be instantiated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:117,Modifiability,variab,variable,117,"/// Perform checking of type validity; ///; /// C++11 [dcl.align]p1:; /// An alignment-specifier may be applied to a variable or to a class; /// data member, but it shall not be applied to a bit-field, a function; /// parameter, the formal parameter of a catch clause, or a variable; /// declared with the register storage class specifier. An; /// alignment-specifier may also be applied to the declaration of a class; /// or enumeration type.; /// CWG 2354:; /// CWG agreed to remove permission for alignas to be applied to; /// enumerations.; /// C11 6.7.5/2:; /// An alignment attribute shall not be specified in a declaration of; /// a typedef, or a bit-field, or a function, or a parameter, or an; /// object declared with the register storage-class specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:274,Modifiability,variab,variable,274,"/// Perform checking of type validity; ///; /// C++11 [dcl.align]p1:; /// An alignment-specifier may be applied to a variable or to a class; /// data member, but it shall not be applied to a bit-field, a function; /// parameter, the formal parameter of a catch clause, or a variable; /// declared with the register storage class specifier. An; /// alignment-specifier may also be applied to the declaration of a class; /// or enumeration type.; /// CWG 2354:; /// CWG agreed to remove permission for alignas to be applied to; /// enumerations.; /// C11 6.7.5/2:; /// An alignment attribute shall not be specified in a declaration of; /// a typedef, or a bit-field, or a function, or a parameter, or an; /// object declared with the register storage-class specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:4,Performance,Perform,Perform,4,"/// Perform checking of type validity; ///; /// C++11 [dcl.align]p1:; /// An alignment-specifier may be applied to a variable or to a class; /// data member, but it shall not be applied to a bit-field, a function; /// parameter, the formal parameter of a catch clause, or a variable; /// declared with the register storage class specifier. An; /// alignment-specifier may also be applied to the declaration of a class; /// or enumeration type.; /// CWG 2354:; /// CWG agreed to remove permission for alignas to be applied to; /// enumerations.; /// C11 6.7.5/2:; /// An alignment attribute shall not be specified in a declaration of; /// a typedef, or a bit-field, or a function, or a parameter, or an; /// object declared with the register storage-class specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:22,Integrability,depend,dependent,22,"// We can't support a dependent alignment on a non-dependent type,; // because we have no way to model that a type is ""alignment-dependent""; // but not dependent in any other way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:51,Integrability,depend,dependent,51,"// We can't support a dependent alignment on a non-dependent type,; // because we have no way to model that a type is ""alignment-dependent""; // but not dependent in any other way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:129,Integrability,depend,dependent,129,"// We can't support a dependent alignment on a non-dependent type,; // because we have no way to model that a type is ""alignment-dependent""; // but not dependent in any other way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:152,Integrability,depend,dependent,152,"// We can't support a dependent alignment on a non-dependent type,; // because we have no way to model that a type is ""alignment-dependent""; // but not dependent in any other way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:8,Integrability,depend,dependent,8,// Save dependent expressions in the AST to be instantiated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:10,Performance,Cache,Cache,10,// FIXME: Cache the number on the AL object?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:85,Modifiability,variab,variable,85,"// On AIX, an aligned attribute can not decrease the alignment when applied; // to a variable declaration with vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:22,Integrability,depend,dependent,22,"// We can't support a dependent alignment on a non-dependent type,; // because we have no way to model that a type is ""type-dependent""; // but not dependent in any other way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:51,Integrability,depend,dependent,51,"// We can't support a dependent alignment on a non-dependent type,; // because we have no way to model that a type is ""type-dependent""; // but not dependent in any other way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:124,Integrability,depend,dependent,124,"// We can't support a dependent alignment on a non-dependent type,; // because we have no way to model that a type is ""type-dependent""; // but not dependent in any other way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:147,Integrability,depend,dependent,147,"// We can't support a dependent alignment on a non-dependent type,; // because we have no way to model that a type is ""type-dependent""; // but not dependent in any other way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:85,Modifiability,variab,variable,85,"// On AIX, an aligned attribute can not decrease the alignment when applied; // to a variable declaration with vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:123,Testability,log,logical,123,"/// handleModeAttr - This attribute modifies the width of a decl with primitive; /// type.; ///; /// Despite what would be logical, the mode attribute is a decl attribute, not a; /// type attribute: 'int ** __attribute((mode(HI))) *G;' tries to make 'G' be; /// HImode, not an intermediate pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:3,Safety,Avoid,Avoid,3,// Avoid duplicate warning from template instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:3,Deployability,Install,Install,3,// Install the new type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:48,Modifiability,variab,variables,48,// Attribute does not apply to non-static local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:48,Modifiability,variab,variables,48,// Attribute does not apply to non-static local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:13,Modifiability,variab,variable,13,"// constexpr variable may already get an implicit constant attr, which should; // be replaced by the explicit constant attr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:58,Availability,down,down,58,"// Only warn for ""inline"" when compiling for host, to cut down on noise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:272,Safety,avoid,avoid,272,"// In host compilation the kernel is emitted as a stub function, which is; // a helper function for launching the kernel. The instructions in the helper; // function has nothing to do with the source code of the kernel. Do not emit; // debug info for the stub function to avoid confusing the debugger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:50,Testability,stub,stub,50,"// In host compilation the kernel is emitted as a stub function, which is; // a helper function for launching the kernel. The instructions in the helper; // function has nothing to do with the source code of the kernel. Do not emit; // debug info for the stub function to avoid confusing the debugger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:255,Testability,stub,stub,255,"// In host compilation the kernel is emitted as a stub function, which is; // a helper function for launching the kernel. The instructions in the helper; // function has nothing to do with the source code of the kernel. Do not emit; // debug info for the stub function to avoid confusing the debugger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:40,Modifiability,variab,variables,40,// Analyzer suppression applies only to variables and statements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:220,Availability,error,error,220,"// Checks whether an argument of launch_bounds attribute is; // acceptable, performs implicit conversion to Rvalue, and returns; // non-nullptr Expr result on success. Otherwise, it returns nullptr; // and may output an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:76,Performance,perform,performs,76,"// Checks whether an argument of launch_bounds attribute is; // acceptable, performs implicit conversion to Rvalue, and returns; // non-nullptr Expr result on success. Otherwise, it returns nullptr; // and may output an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:45,Integrability,depend,depend,45,// Accept template arguments for now as they depend on something else.; // We'll get to check them when they eventually get instantiated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:18,Performance,perform,perform,18,// We may need to perform implicit conversion of the argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:102,Integrability,depend,dependent,102,"// These attributes are normally just advisory, but in ARC, ns_consumed; // is significant. Allow non-dependent code to contain inappropriate; // attributes even in ARC, but require template instantiations to be; // set up correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:52,Integrability,interface,interfaces,52,// This attribute can only be applied to methods in interfaces or class; // extensions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:88,Security,access,access,88,// When a user wants to use objc_boxable with a union or struct; // but they don't have access to the declaration (legacy/third-party code); // then they can 'enable' this feature with a typedef:; // typedef struct __attribute((objc_boxable)) legacy_struct legacy_struct;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:17,Security,validat,validation,17,// No additional validation required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:303,Modifiability,variab,variable,303,"// For a function, this will validate a compound Swift name, e.g.; // <code>init(foo:bar:baz:)</code> or <code>controllerForName(_:)</code>, and; // the function will output the number of parameter names, and whether this is a; // single-arg initializer.; //; // For a type, enum constant, property, or variable declaration, this will; // validate either a simple identifier, or a qualified; // <code>context.identifier</code> name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:29,Security,validat,validate,29,"// For a function, this will validate a compound Swift name, e.g.; // <code>init(foo:bar:baz:)</code> or <code>controllerForName(_:)</code>, and; // the function will output the number of parameter names, and whether this is a; // single-arg initializer.; //; // For a type, enum constant, property, or variable declaration, this will; // validate either a simple identifier, or a qualified; // <code>context.identifier</code> name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:339,Security,validat,validate,339,"// For a function, this will validate a compound Swift name, e.g.; // <code>init(foo:bar:baz:)</code> or <code>controllerForName(_:)</code>, and; // the function will output the number of parameter names, and whether this is a; // single-arg initializer.; //; // For a type, enum constant, property, or variable declaration, this will; // validate either a simple identifier, or a qualified; // <code>context.identifier</code> name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:357,Usability,simpl,simple,357,"// For a function, this will validate a compound Swift name, e.g.; // <code>init(foo:bar:baz:)</code> or <code>controllerForName(_:)</code>, and; // the function will output the number of parameter names, and whether this is a; // single-arg initializer.; //; // For a type, enum constant, property, or variable declaration, this will; // validate either a simple identifier, or a qualified; // <code>context.identifier</code> name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:15,Security,access,accessor,15,// A subscript accessor must be a getter or setter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:167,Availability,error,error,167,"// ""newValue"" indicates the ""newValue"" argument for a setter.; // There should only be one 'newValue', but it's only significant for; // subscript accessors, so don't error right away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:147,Security,access,accessors,147,"// ""newValue"" indicates the ""newValue"" argument for a setter.; // There should only be one 'newValue', but it's only significant for; // subscript accessors, so don't error right away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:12,Security,access,accessors,12,// Property accessors must have exactly the number of expected params.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:3,Usability,GUID,GUID,3,"// GUID format is ""XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"" or; // ""{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}"", normalize to the former.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:3,Security,Validat,Validate,3,// Validate GUID length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:12,Usability,GUID,GUID,12,// Validate GUID length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:3,Security,Validat,Validate,3,// Validate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:45,Integrability,depend,depend,45,// Accept template arguments for now as they depend on something else.; // We'll get to check them when they eventually get instantiated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:45,Integrability,depend,depend,45,// Accept template arguments for now as they depend on something else.; // We'll get to check them when they eventually get instantiated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:51,Integrability,message,message,51,// Handle the cases where the attribute has a text message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:29,Integrability,message,message,29,// Support a single optional message only for Declspec and [[]] spellings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:553,Testability,assert,assertions,553,"// FIXME: Rather than create a NoSanitizeSpecificAttr, this creates a; // NoSanitizeAttr object; but we need to calculate the correct spelling list; // index rather than incorrectly assume the index for NoSanitizeSpecificAttr; // has the same spellings as the index for NoSanitizeAttr. We don't have a; // general way to ""translate"" between the two, so this hack attempts to work; // around the issue with hard-coded indices. This is critical for calling; // getSpelling() or prettyPrint() on the resulting semantic attribute object; // without failing assertions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:30,Security,access,access,30,// Check if there is only one access qualifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:303,Availability,error,error,303,"// OpenCL v2.0 s6.6 - read_write can be used for image types to specify that; // an image object can be read and written. OpenCL v2.0 s6.13.6 - A kernel; // cannot read from and write to the same pipe object. Using the read_write; // (or __read_write) qualifier with the pipe qualifier is a compilation error.; // OpenCL v3.0 s6.8 - For OpenCL C 2.0, or with the; // __opencl_c_read_write_images feature, image objects specified as arguments; // to a kernel can additionally be declared to be read-write.; // C++ for OpenCL 1.0 inherits rule from OpenCL C v2.0.; // C++ for OpenCL 2021 inherits rule from OpenCL C v3.0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:528,Modifiability,inherit,inherits,528,"// OpenCL v2.0 s6.6 - read_write can be used for image types to specify that; // an image object can be read and written. OpenCL v2.0 s6.13.6 - A kernel; // cannot read from and write to the same pipe object. Using the read_write; // (or __read_write) qualifier with the pipe qualifier is a compilation error.; // OpenCL v3.0 s6.8 - For OpenCL C 2.0, or with the; // __opencl_c_read_write_images feature, image objects specified as arguments; // to a kernel can additionally be declared to be read-write.; // C++ for OpenCL 1.0 inherits rule from OpenCL C v2.0.; // C++ for OpenCL 2021 inherits rule from OpenCL C v3.0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:586,Modifiability,inherit,inherits,586,"// OpenCL v2.0 s6.6 - read_write can be used for image types to specify that; // an image object can be read and written. OpenCL v2.0 s6.13.6 - A kernel; // cannot read from and write to the same pipe object. Using the read_write; // (or __read_write) qualifier with the pipe qualifier is a compilation error.; // OpenCL v3.0 s6.8 - For OpenCL C 2.0, or with the; // __opencl_c_read_write_images feature, image objects specified as arguments; // to a kernel can additionally be declared to be read-write.; // C++ for OpenCL 1.0 inherits rule from OpenCL C v2.0.; // C++ for OpenCL 2021 inherits rule from OpenCL C v3.0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:43,Modifiability,flexible,flexible,43,"// The ""counted_by"" attribute must be on a flexible array member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:45,Modifiability,flexible,flexible,45,"// The ""counted_by"" field can't point to the flexible array member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:175,Testability,test,tests,175,"// FIXME: it would be good to better handle attribute merging rather than; // silently replacing the existing attribute, so long as it does not break; // the expected codegen tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:55,Modifiability,variab,variables,55,// The attributes only really makes sense for __strong variables; ignore any; // attempts to annotate a parameter with any other lifetime qualifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:135,Availability,error,error,135,"// Tampering with the type of a VarDecl here is a bit of a hack, but we need; // to ensure that the variable is 'const' so that we can error on; // modification, which can otherwise over-release.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:187,Deployability,release,release,187,"// Tampering with the type of a VarDecl here is a bit of a hack, but we need; // to ensure that the variable is 'const' so that we can error on; // modification, which can otherwise over-release.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:100,Modifiability,variab,variable,100,"// Tampering with the type of a VarDecl here is a bit of a hack, but we need; // to ensure that the variable is 'const' so that we can error on; // modification, which can otherwise over-release.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:3,Availability,Error,Error,3,"// Error recovery: drop the non-leaf attribute so that to suppress; // all future warnings caused by erroneous attributes. The leaf attribute; // needs to be kept because it can only suppresses warnings, not cause them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:9,Availability,recover,recovery,9,"// Error recovery: drop the non-leaf attribute so that to suppress; // all future warnings caused by erroneous attributes. The leaf attribute; // needs to be kept because it can only suppresses warnings, not cause them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:9,Safety,recover,recovery,9,"// Error recovery: drop the non-leaf attribute so that to suppress; // all future warnings caused by erroneous attributes. The leaf attribute; // needs to be kept because it can only suppresses warnings, not cause them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:8,Availability,error,error,8,// More error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:14,Availability,recover,recovery,14,// More error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:14,Safety,recover,recovery,14,// More error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:43,Integrability,depend,dependent,43,// Last case is if the expression is value dependent then it must delay; // arguments unless the corresponding argument is able to hold the; // expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:3,Safety,Avoid,Avoid,3,// Avoid adding duplicates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:145,Modifiability,portab,portability,145,"// Suggest moving the attribute to the type instead, but only for our; // own vendor attributes; moving other vendors' attributes might hurt; // portability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:298,Testability,log,logic,298,"// `regparm` is a special case: It's a type attribute but we still want; // to treat it as if it had been written on the declaration because that; // way we'll be able to handle it directly in `processTypeAttr()`.; // If we treated `regparm` it as if it had been written on the; // `DeclSpec`, the logic in `distributeFunctionTypeAttrFromDeclSepc()`; // would try to move it to the declarator, but that doesn't work: We; // can't remove the attribute from the list of declaration attributes; // because it might be needed by other declarators in the same; // declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:10,Safety,safe,safety,10,// Thread safety attributes:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:8,Safety,safe,safety,8,// Type safety attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:33,Availability,error,error,33,// FIXME: This emits a different error message than; // diag::err_attribute_wrong_decl_type + ExpectedKernelFunction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:39,Integrability,message,message,39,// FIXME: This emits a different error message than; // diag::err_attribute_wrong_decl_type + ExpectedKernelFunction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:66,Security,access,access,66,// Annotation attributes are the only attributes allowed after an access; // specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:21,Modifiability,variab,variables,21,// Fake up parameter variables; they are declared as if this were; // a typedef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:124,Deployability,integrat,integration,124,"// Silently accept unsupported uses of __weak in both user and system; // declarations when it's been disabled, for ease of integration with; // -fno-objc-arc files. We do have to take some care against attempts; // to define such things; for now, we've only done that for ivars; // and properties.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:124,Integrability,integrat,integration,124,"// Silently accept unsupported uses of __weak in both user and system; // declarations when it's been disabled, for ease of integration with; // -fno-objc-arc files. We do have to take some care against attempts; // to define such things; for now, we've only done that for ivars; // and properties.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:22,Availability,failure,failures,22,"// Currently, all the failures dealt with this way are due to ARC; // restrictions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:81,Integrability,message,messages,81,// FIXME: we may want to suppress diagnostics for all; // kind of forbidden type messages on unavailable functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:20,Security,access,access,20,// Only produce one access control diagnostic for a structured binding; // declaration: we don't need to tell the user that all the fields are; // inaccessible one at a time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:230,Modifiability,variab,variables,230,"/// CheckDefaultArgumentVisitor - C++ [dcl.fct.default] Traverses; /// the default argument of a parameter to determine whether it; /// contains any ill-formed subexpressions. For example, this will; /// diagnose the use of local variables or parameters within the; /// default argument expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:38,Modifiability,variab,variables,38,"// C++ [dcl.fct.default]p7:; // Local variables shall not be used in default argument; // expressions.; //; // C++17 [dcl.fct.default]p7 (by CWG 2082):; // A local variable shall not appear as a potentially-evaluated; // expression in a default argument.; //; // C++20 [dcl.fct.default]p7 (DR as part of P0588R1, see also CWG 2346):; // Note: A local variable cannot be odr-used (6.3) in a default; // argument.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:164,Modifiability,variab,variable,164,"// C++ [dcl.fct.default]p7:; // Local variables shall not be used in default argument; // expressions.; //; // C++17 [dcl.fct.default]p7 (by CWG 2082):; // A local variable shall not appear as a potentially-evaluated; // expression in a default argument.; //; // C++20 [dcl.fct.default]p7 (DR as part of P0588R1, see also CWG 2346):; // Note: A local variable cannot be odr-used (6.3) in a default; // argument.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:351,Modifiability,variab,variable,351,"// C++ [dcl.fct.default]p7:; // Local variables shall not be used in default argument; // expressions.; //; // C++17 [dcl.fct.default]p7 (by CWG 2082):; // A local variable shall not appear as a potentially-evaluated; // expression in a default argument.; //; // C++20 [dcl.fct.default]p7 (DR as part of P0588R1, see also CWG 2346):; // Note: A local variable cannot be odr-used (6.3) in a default; // argument.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:249,Modifiability,variab,variable,249,"// C++ [dcl.fct.default]p5; // A default argument expression is implicitly converted (clause; // 4) to the parameter type. The default argument expression has; // the same semantic constraints as the initializer expression in; // a declaration of a variable of the parameter type, using the; // copy-initialization semantics (8.5).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Availability,Recover,Recover,3,// Recover by discarding the default argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Safety,Recover,Recover,3,// Recover by discarding the default argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:221,Integrability,rout,routine,221,"/// CheckExtraCXXDefaultArguments - Check for any extra default; /// arguments in the declarator, which is not a function declaration; /// or definition and therefore is not permitted to have default; /// arguments. This routine should be invoked for every declarator; /// that is not a function declaration or definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:204,Availability,error,error,204,"/// MergeCXXFunctionDecl - Merge two declarations of the same C++; /// function, once we already know that they have the same; /// type. Subroutine of MergeFunctionDecl. Returns true if there was an; /// error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:275,Testability,test,test,275,"// FIXME: If we knew where the '=' was, we could easily provide a fix-it; // hint here. Alternatively, we could walk the type-source information; // for NewParam to find the last source location in the type... but it; // isn't worth the effort right now. This is the kind of test case that; // is hard to get right:; // int f(int);; // void g(int (*fp)(int) = f);; // void g(int (*fp)(int) = &f);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:183,Modifiability,inherit,inherited,183,// Merge the old default argument into the new parameter unless the new; // function is a friend declaration in a template class. In the latter; // case the default arguments will be inherited when the friend; // declaration will be instantiated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:419,Integrability,depend,dependent,419,// C++ [dcl.fct.default]p6 (DR217):; // Default arguments for a member function of a class template shall; // be specified on the initial declaration of the member function; // within the class template.; //; // Reading the tea leaves a bit in DR217 and its reference to DR205; // leads me to the conclusion that one cannot add default function; // arguments for an out-of-line definition of a member function of a; // dependent type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:22,Usability,guid,guide,22,// C++17 [temp.deduct.guide]p3:; // Two deduction guide declarations in the same translation unit; // for the same class template shall not have equivalent; // parameter-declaration-clauses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:50,Usability,guid,guide,50,// C++17 [temp.deduct.guide]p3:; // Two deduction guide declarations in the same translation unit; // for the same class template shall not have equivalent; // parameter-declaration-clauses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:58,Usability,simpl,simple-declaration,58,"// The syntax only allows a decomposition declarator as a simple-declaration,; // a for-range-declaration, or a condition in Clang, but we parse it in more; // cases than that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:100,Usability,usab,usable,100,"// FIXME: There's no rule against this, but there are also no rules that; // would actually make it usable, so we reject it for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:108,Modifiability,variab,variable,108,// Don't add FixItHints to remove the specifiers; we do still respect; // them when building the underlying variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:12,Availability,recover,recover,12,// We can't recover from it being declared as a typedef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:12,Safety,recover,recover,12,// We can't recover from it being declared as a typedef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:45,Modifiability,variab,variable,45,"// There are no prior lookup results for the variable itself, because it; // is unnamed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:13,Modifiability,variab,variable,13,// Build the variable that holds the non-decomposed object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:120,Usability,usab,usable,120,"// If we get this far, we've committed to the tuple interpretation, but; // we can still fail if there actually isn't a usable ::value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:97,Security,access,access,97,// [dcl.decomp]p3:; // The unqualified-id get is looked up in the scope of E by class member; // access lookup ...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:16,Modifiability,variab,variable,16,"// each vi is a variable of type ""reference to T"" initialized with the; // initializer, where the reference is an lvalue reference if the; // initializer is an lvalue and an rvalue reference otherwise",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:167,Performance,perform,perform,167,"/// Find the base class to decompose in a built-in decomposition of a class type.; /// This base class search is, unfortunately, not quite like any other that we; /// perform anywhere else in C++.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:8,Security,access,accessible,8,"// ... [accessible, implied by other rules] base class of E.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:21,Security,access,accessible,21,// The field must be accessible in the context of the structured binding.; // We already checked that the base class is accessible.; // FIXME: Add 'const' to AccessedEntity's classes so we can remove the; // const_cast here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:120,Security,access,accessible,120,// The field must be accessible in the context of the structured binding.; // We already checked that the base class is accessible.; // FIXME: Add 'const' to AccessedEntity's classes so we can remove the; // const_cast here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:158,Security,Access,AccessedEntity,158,// The field must be accessible in the context of the structured binding.; // We already checked that the base class is accessible.; // FIXME: Add 'const' to AccessedEntity's classes so we can remove the; // const_cast here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:39,Integrability,depend,dependent,39,"// If the type of the decomposition is dependent, then so is the type of; // each binding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:46,Modifiability,variab,variable,46,/// Merge the exception specifications of two variable declarations.; ///; /// This is called when there's a redeclaration of a VarDecl. The function; /// checks if the redeclaration might have an exception specification and; /// validates compatibility and merges the specs if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:230,Security,validat,validates,230,/// Merge the exception specifications of two variable declarations.; ///; /// This is called when there's a redeclaration of a VarDecl. The function; /// checks if the redeclaration might have an exception specification and; /// validates compatibility and merges the specs if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:73,Integrability,message,message,73,/// Get diagnostic %select index for tag kind for; /// record diagnostic message.; /// WARNING: Indexes apply to particular diagnostics only!; ///; /// \returns diagnostic %select index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:15,Modifiability,variab,variably-modified,15,// Don't allow variably-modified types in constexpr functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:73,Modifiability,variab,variable,73,// C++1y [dcl.constexpr]p3 allows anything except:; // a definition of a variable of non-literal type or of static or; // thread storage duration or [before C++2a] for which no; // initialization is performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:199,Performance,perform,performed,199,// C++1y [dcl.constexpr]p3 allows anything except:; // a definition of a variable of non-literal type or of static or; // thread storage duration or [before C++2a] for which no; // initialization is performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:2,Modifiability,variab,variable,2,/*variable of non-literal type*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:475,Availability,error,error,475,"/// Check that the given field is initialized within a constexpr constructor.; ///; /// \param Dcl The constexpr constructor being checked.; /// \param Field The field being checked. This may be a member of an anonymous; /// struct or union nested within the class being checked.; /// \param Inits All declarations, including anonymous struct/union members and; /// indirect members, for which any initialization was provided.; /// \param Diagnosed Whether we've emitted the error message yet. Used to attach; /// multiple notes for different members to the same error.; /// \param Kind Whether we're diagnosing a constructor as written or determining; /// whether the formal requirements are satisfied.; /// \return \c false if we're checking for validity and the constructor does; /// not satisfy the requirements on a constexpr constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:563,Availability,error,error,563,"/// Check that the given field is initialized within a constexpr constructor.; ///; /// \param Dcl The constexpr constructor being checked.; /// \param Field The field being checked. This may be a member of an anonymous; /// struct or union nested within the class being checked.; /// \param Inits All declarations, including anonymous struct/union members and; /// indirect members, for which any initialization was provided.; /// \param Diagnosed Whether we've emitted the error message yet. Used to attach; /// multiple notes for different members to the same error.; /// \param Kind Whether we're diagnosing a constructor as written or determining; /// whether the formal requirements are satisfied.; /// \return \c false if we're checking for validity and the constructor does; /// not satisfy the requirements on a constexpr constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:481,Integrability,message,message,481,"/// Check that the given field is initialized within a constexpr constructor.; ///; /// \param Dcl The constexpr constructor being checked.; /// \param Field The field being checked. This may be a member of an anonymous; /// struct or union nested within the class being checked.; /// \param Inits All declarations, including anonymous struct/union members and; /// indirect members, for which any initialization was provided.; /// \param Diagnosed Whether we've emitted the error message yet. Used to attach; /// multiple notes for different members to the same error.; /// \param Kind Whether we're diagnosing a constructor as written or determining; /// whether the formal requirements are satisfied.; /// \return \c false if we're checking for validity and the constructor does; /// not satisfy the requirements on a constexpr constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:116,Modifiability,variab,variable,116,"// C++1y allows all of these. We don't allow them as extensions in C++11,; // because they don't make sense without variable mutation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:61,Modifiability,variab,variable,61,"// C++1y allows switch-statements, and since they don't need variable; // mutation, we can reasonably allow them in C++11 as an extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:122,Integrability,Depend,Dependent,122,// Check initialization of non-static data members. Base classes are; // always initialized so do not need to be checked. Dependent bases; // might not have initializers in the member initializer list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:118,Deployability,update,update,118,"/// Determine whether the identifier II is a typo for the name of; /// the class type currently being defined. If so, update it to the identifier; /// that should have been used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:100,Integrability,depend,dependent,100,"/// Determine whether the given class is a base class of the given; /// class, including looking at dependent bases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:30,Security,access,access,30,"// In HLSL, unspecified class access is public rather than private.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:49,Availability,error,error,49,// Already emitted a diagnostic when parsing the error type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:63,Integrability,depend,dependent,63,"// Make sure that we don't have circular inheritance among our dependent; // bases. For non-dependent bases, the check for completeness below handles; // this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:92,Integrability,depend,dependent,92,"// Make sure that we don't have circular inheritance among our dependent; // bases. For non-dependent bases, the check for completeness below handles; // this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:41,Modifiability,inherit,inheritance,41,"// Make sure that we don't have circular inheritance among our dependent; // bases. For non-dependent bases, the check for completeness below handles; // this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:271,Availability,error,errory-recovery,271,"// Make sure that we don't make an ill-formed AST where the type of the; // Class is non-dependent and its attached base class specifier is an; // dependent type, which violates invariants in many clang code paths (e.g.; // constexpr evaluator). If this case happens (in errory-recovery mode), we; // explicitly mark the Class decl invalid. The diagnostic was already; // emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:89,Integrability,depend,dependent,89,"// Make sure that we don't make an ill-formed AST where the type of the; // Class is non-dependent and its attached base class specifier is an; // dependent type, which violates invariants in many clang code paths (e.g.; // constexpr evaluator). If this case happens (in errory-recovery mode), we; // explicitly mark the Class decl invalid. The diagnostic was already; // emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:147,Integrability,depend,dependent,147,"// Make sure that we don't make an ill-formed AST where the type of the; // Class is non-dependent and its attached base class specifier is an; // dependent type, which violates invariants in many clang code paths (e.g.; // constexpr evaluator). If this case happens (in errory-recovery mode), we; // explicitly mark the Class decl invalid. The diagnostic was already; // emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:278,Safety,recover,recovery,278,"// Make sure that we don't make an ill-formed AST where the type of the; // Class is non-dependent and its attached base class specifier is an; // dependent type, which violates invariants in many clang code paths (e.g.; // constexpr evaluator). If this case happens (in errory-recovery mode), we; // explicitly mark the Class decl invalid. The diagnostic was already; // emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:24,Modifiability,polymorphi,polymorphic,24,"// If the base class is polymorphic or isn't empty, the new one is/isn't, too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:28,Modifiability,flexible,flexible,28,"// A class which contains a flexible array member is not suitable for use as a; // base class:; // - If the layout determines that a base comes before another base,; // the flexible array member would index into the subsequent base.; // - If the layout determines that base comes before the derived class,; // the flexible array member would index into the derived class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:173,Modifiability,flexible,flexible,173,"// A class which contains a flexible array member is not suitable for use as a; // base class:; // - If the layout determines that a base comes before another base,; // the flexible array member would index into the subsequent base.; // - If the layout determines that base comes before the derived class,; // the flexible array member would index into the derived class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:314,Modifiability,flexible,flexible,314,"// A class which contains a flexible array member is not suitable for use as a; // base class:; // - If the layout determines that a base comes before another base,; // the flexible array member would index into the subsequent base.; // - If the layout determines that base comes before the derived class,; // the flexible array member would index into the derived class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:4,Performance,Perform,Performs,4,/// Performs the actual work of attaching the given base class; /// specifiers to a C++ class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:101,Availability,redundant,redundant,101,"// Used to keep track of which base types we have already seen, so; // that we can properly diagnose redundant direct base types. Note; // that the key is always the unqualified canonical type of the base; // class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:101,Safety,redund,redundant,101,"// Used to keep track of which base types we have already seen, so; // that we can properly diagnose redundant direct base types. Note; // that the key is always the unqualified canonical type of the base; // class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:12,Availability,redundant,redundant,12,// Copy non-redundant base specifiers into permanent storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:12,Safety,redund,redundant,12,// Copy non-redundant base specifiers into permanent storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:96,Integrability,interface,interfaces,96,// The Microsoft extension __interface does not permit bases that; // are not themselves public interfaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:12,Integrability,depend,dependent,12,// Skip all dependent types in templates being used as base specifiers.; // Checks below assume that the base specifier is a CXXRecord.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:104,Modifiability,inherit,inheritance,104,"// FIXME: In a modules build, do we need the entire path to be visible for us; // to be able to use the inheritance relationship?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:419,Availability,error,error,419,"/// CheckDerivedToBaseConversion - Check whether the Derived-to-Base; /// conversion (where Derived and Base are class types) is; /// well-formed, meaning that the conversion is unambiguous (and; /// that all of the base classes are accessible). Returns true; /// and emits a diagnostic if the code is ill-formed, returns false; /// otherwise. Loc is the location where this routine should point to; /// if there is an error, and Range is the source range to highlight; /// if there is an error.; ///; /// If either InaccessibleBaseID or AmbiguousBaseConvID are 0, then the; /// diagnostic for the respective type of error will be suppressed, but the; /// check for ill-formed code will still be performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:489,Availability,error,error,489,"/// CheckDerivedToBaseConversion - Check whether the Derived-to-Base; /// conversion (where Derived and Base are class types) is; /// well-formed, meaning that the conversion is unambiguous (and; /// that all of the base classes are accessible). Returns true; /// and emits a diagnostic if the code is ill-formed, returns false; /// otherwise. Loc is the location where this routine should point to; /// if there is an error, and Range is the source range to highlight; /// if there is an error.; ///; /// If either InaccessibleBaseID or AmbiguousBaseConvID are 0, then the; /// diagnostic for the respective type of error will be suppressed, but the; /// check for ill-formed code will still be performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:617,Availability,error,error,617,"/// CheckDerivedToBaseConversion - Check whether the Derived-to-Base; /// conversion (where Derived and Base are class types) is; /// well-formed, meaning that the conversion is unambiguous (and; /// that all of the base classes are accessible). Returns true; /// and emits a diagnostic if the code is ill-formed, returns false; /// otherwise. Loc is the location where this routine should point to; /// if there is an error, and Range is the source range to highlight; /// if there is an error.; ///; /// If either InaccessibleBaseID or AmbiguousBaseConvID are 0, then the; /// diagnostic for the respective type of error will be suppressed, but the; /// check for ill-formed code will still be performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:375,Integrability,rout,routine,375,"/// CheckDerivedToBaseConversion - Check whether the Derived-to-Base; /// conversion (where Derived and Base are class types) is; /// well-formed, meaning that the conversion is unambiguous (and; /// that all of the base classes are accessible). Returns true; /// and emits a diagnostic if the code is ill-formed, returns false; /// otherwise. Loc is the location where this routine should point to; /// if there is an error, and Range is the source range to highlight; /// if there is an error.; ///; /// If either InaccessibleBaseID or AmbiguousBaseConvID are 0, then the; /// diagnostic for the respective type of error will be suppressed, but the; /// check for ill-formed code will still be performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:696,Performance,perform,performed,696,"/// CheckDerivedToBaseConversion - Check whether the Derived-to-Base; /// conversion (where Derived and Base are class types) is; /// well-formed, meaning that the conversion is unambiguous (and; /// that all of the base classes are accessible). Returns true; /// and emits a diagnostic if the code is ill-formed, returns false; /// otherwise. Loc is the location where this routine should point to; /// if there is an error, and Range is the source range to highlight; /// if there is an error.; ///; /// If either InaccessibleBaseID or AmbiguousBaseConvID are 0, then the; /// diagnostic for the respective type of error will be suppressed, but the; /// check for ill-formed code will still be performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:233,Security,access,accessible,233,"/// CheckDerivedToBaseConversion - Check whether the Derived-to-Base; /// conversion (where Derived and Base are class types) is; /// well-formed, meaning that the conversion is unambiguous (and; /// that all of the base classes are accessible). Returns true; /// and emits a diagnostic if the code is ill-formed, returns false; /// otherwise. Loc is the location where this routine should point to; /// if there is an error, and Range is the source range to highlight; /// if there is an error.; ///; /// If either InaccessibleBaseID or AmbiguousBaseConvID are 0, then the; /// diagnostic for the respective type of error will be suppressed, but the; /// check for ill-formed code will still be performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:53,Modifiability,inherit,inherits,53,"// For MSVC compatibility, check if Derived directly inherits from Base. Clang; // warns about this hierarchy under -Winaccessible-base, but MSVC allows the; // user to access such bases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:169,Security,access,access,169,"// For MSVC compatibility, check if Derived directly inherits from Base. Clang; // warns about this hierarchy under -Winaccessible-base, but MSVC allows the; // user to access such bases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:36,Security,access,accessed,36,// Check that the base class can be accessed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:106,Performance,Perform,Perform,106,"// We know that the derived-to-base conversion is ambiguous, and; // we're going to produce a diagnostic. Perform the derived-to-base; // search just one more time to compute all of the possible paths so; // that we can print them out. This is more expensive than any of; // the previous derived-to-base checks we've done, but at this point; // performance isn't as much of an issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:345,Performance,perform,performance,345,"// We know that the derived-to-base conversion is ambiguous, and; // we're going to produce a diagnostic. Perform the derived-to-base; // search just one more time to compute all of the possible paths so; // that we can print them out. This is more expensive than any of; // the previous derived-to-base checks we've done, but at this point; // performance isn't as much of an issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:197,Availability,error,error,197,/// Builds a string representing ambiguous paths from a; /// specific derived class to different subobjects of the same base; /// class.; ///; /// This function builds a string that can be used in error messages; /// to show the different paths that one can take through the; /// inheritance hierarchy to go from the derived class to different; /// subobjects of a base class. The result looks something like this:; /// @code; /// struct D -> struct B -> struct A; /// struct D -> struct C -> struct A; /// @endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:203,Integrability,message,messages,203,/// Builds a string representing ambiguous paths from a; /// specific derived class to different subobjects of the same base; /// class.; ///; /// This function builds a string that can be used in error messages; /// to show the different paths that one can take through the; /// inheritance hierarchy to go from the derived class to different; /// subobjects of a base class. The result looks something like this:; /// @code; /// struct D -> struct B -> struct A; /// struct D -> struct C -> struct A; /// @endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:280,Modifiability,inherit,inheritance,280,/// Builds a string representing ambiguous paths from a; /// specific derived class to different subobjects of the same base; /// class.; ///; /// This function builds a string that can be used in error messages; /// to show the different paths that one can take through the; /// inheritance hierarchy to go from the derived class to different; /// subobjects of a base class. The result looks something like this:; /// @code; /// struct D -> struct B -> struct A; /// struct D -> struct C -> struct A; /// @endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:231,Security,access,access,231,//===----------------------------------------------------------------------===//; // C++ class member Handling; //===----------------------------------------------------------------------===//; /// ActOnAccessSpecifier - Parsed an access specifier followed by a colon.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:18,Integrability,depend,dependent,18,// We can't check dependent instance methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:110,Security,access,access,110,"/// ActOnCXXMemberDeclarator - This is invoked when a C++ class member; /// declarator is parsed. 'AS' is the access specifier, 'BW' specifies the; /// bitfield width if there is one, 'InitExpr' specifies the initializer if; /// one has been parsed, and 'InitStyle' is set if an in-class initializer is; /// present (but parsing it has been deferred).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:118,Availability,error,errors,118,// FIXME: It would be nicer if the keyword was ignored only for this; // declarator. Otherwise we could get follow-up errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:94,Security,access,access,94,"// If we have declared a member function template or static data member; // template, set the access of the templated declaration as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:124,Security,access,access,124,// C++ [temp.deduct.guide]p3:; // A deduction guide [...] for a member class template [shall be; // declared] with the same access [as the template].,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:20,Usability,guid,guide,20,// C++ [temp.deduct.guide]p3:; // A deduction guide [...] for a member class template [shall be; // declared] with the same access [as the template].,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:46,Usability,guid,guide,46,// C++ [temp.deduct.guide]p3:; // A deduction guide [...] for a member class template [shall be; // declared] with the same access [as the template].,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Security,Access,Access,3,// Access specifiers are only meaningful if both the template and the; // deduction guide are from the same scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:84,Usability,guid,guide,84,// Access specifiers are only meaningful if both the template and the; // deduction guide are from the same scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Deployability,Update,Update,3,// Update the end location of a method that has a virt-specifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:104,Integrability,depend,dependent,104,"// Remember all explicit private FieldDecls that have a name, no side; // effects and are not part of a dependent type declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Modifiability,Variab,Variables,3,"// Variables to hold state when processing an initializer list. When; // InitList is true, special case initialization of FieldDecls matching; // InitListFieldDecl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:28,Safety,detect,detected,28,"// If a field assignment is detected, remove the field from the; // uninitiailized field set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:2,Availability,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:2,Safety,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:33,Modifiability,variab,variable,33,// We did not find a placeholder variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:2,Availability,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:2,Safety,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:104,Availability,error,error,104,"// The user wrote a constructor initializer on a function that is; // not a C++ constructor. Ignore the error for now, because we may; // have more member initializers coming; we'll diagnose it just; // once in ActOnMemInitializers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:17,Security,access,access-control,17,// We don't want access-control diagnostics here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:46,Integrability,depend,dependent,46,// Can't check initialization for a member of dependent type or when; // any of the arguments are type-dependent expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:103,Integrability,depend,dependent,103,// Can't check initialization for a member of dependent type or when; // any of the arguments are type-dependent expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:106,Availability,Recover,RecoveryExpr,106,// Args were sensible expressions but we couldn't initialize the member; // from them. Preserve them in a RecoveryExpr instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:106,Safety,Recover,RecoveryExpr,106,// Args were sensible expressions but we couldn't initialize the member; // from them. Preserve them in a RecoveryExpr instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:18,Integrability,depend,dependent,18,"// If we are in a dependent context, template instantiation will; // perform this type-checking again. Just save the arguments that we; // received in a ParenListExpr.; // FIXME: This isn't quite ideal, since our ASTs don't capture all; // of the information that we have about the base; // initializer. However, deconstructing the ASTs is a dicey process,; // and this approach is far more likely to get the corner cases right.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:69,Performance,perform,perform,69,"// If we are in a dependent context, template instantiation will; // perform this type-checking again. Just save the arguments that we; // received in a ParenListExpr.; // FIXME: This isn't quite ideal, since our ASTs don't capture all; // of the information that we have about the base; // initializer. However, deconstructing the ASTs is a dicey process,; // and this approach is far more likely to get the corner cases right.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:440,Integrability,depend,dependent,440,"// C++ [class.base.init]p2:; // [...] Unless the mem-initializer-id names a nonstatic data; // member of the constructor's class or a direct or virtual base; // of that class, the mem-initializer is ill-formed. A; // mem-initializer-list can initialize a base class using any; // name that denotes that base class type.; // We can store the initializers in ""as-written"" form and delay analysis until; // instantiation if the constructor is dependent. But not for dependent; // (broken) code in a non-template! SetCtorInitializers does not expect this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:463,Integrability,depend,dependent,463,"// C++ [class.base.init]p2:; // [...] Unless the mem-initializer-id names a nonstatic data; // member of the constructor's class or a direct or virtual base; // of that class, the mem-initializer is ill-formed. A; // mem-initializer-list can initialize a base class using any; // name that denotes that base class type.; // We can store the initializers in ""as-written"" form and delay analysis until; // instantiation if the constructor is dependent. But not for dependent; // (broken) code in a non-template! SetCtorInitializers does not expect this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:24,Integrability,depend,dependent,24,"// If the class has any dependent bases, then it's possible that; // one of those types will resolve to the same type as; // BaseType. Therefore, just treat this as a dependent base; // class initialization. FIXME: Should we try to check the; // initialization anyway? It seems odd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:167,Integrability,depend,dependent,167,"// If the class has any dependent bases, then it's possible that; // one of those types will resolve to the same type as; // BaseType. Therefore, just treat this as a dependent base; // class initialization. FIXME: Should we try to check the; // initialization anyway? It seems odd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:139,Modifiability,inherit,inherited,139,"// C++ [base.class.init]p2:; // If a mem-initializer-id is ambiguous because it designates both; // a direct non-virtual base class and an inherited virtual base; // class, the mem-initializer is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:18,Integrability,depend,dependent,18,"// If we are in a dependent context, template instantiation will; // perform this type-checking again. Just save the arguments that we; // received in a ParenListExpr.; // FIXME: This isn't quite ideal, since our ASTs don't capture all; // of the information that we have about the base; // initializer. However, deconstructing the ASTs is a dicey process,; // and this approach is far more likely to get the corner cases right.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:69,Performance,perform,perform,69,"// If we are in a dependent context, template instantiation will; // perform this type-checking again. Just save the arguments that we; // received in a ParenListExpr.; // FIXME: This isn't quite ideal, since our ASTs don't capture all; // of the information that we have about the base; // initializer. However, deconstructing the ASTs is a dicey process,; // and this approach is far more likely to get the corner cases right.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:29,Safety,avoid,avoid,29,// Cast to the base class to avoid ambiguities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:73,Availability,error,errors,73,// Don't try to build an implicit initializer if there were semantic; // errors in any of the initializers (and therefore we might be; // missing some that the user actually wrote).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:50,Availability,error,errors,50,// Let template instantiation know whether we had errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:10,Integrability,depend,dependent,10,"// Ignore dependent contexts. Also ignore unions, since their members never; // have destructors implicitly called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:18,Security,access,access-control,18,"// FIXME: all the access-control diagnostics are positioned on the; // field/base declaration. That's probably good; that said, the; // user might reasonably want to know why the destructor is being; // emitted, and we currently don't say.; // Non-static data members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:185,Safety,avoid,avoid,185,"// If the destructor exists and has already been marked used in the MS ABI,; // then virtual base destructors have already been checked and marked used.; // Skip checking them again to avoid duplicate diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:49,Integrability,depend,dependent,49,// Bases are always records in a well-formed non-dependent class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:69,Modifiability,inherit,inherits,69,// C++ [class.abstract]p4:; // A class is abstract if it contains or inherits at least one; // pure virtual function for which the final overrider is pure; // virtual.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:7,Safety,safe,safety,7,"// For safety's sake, just ignore it if we don't have type source; // information. This should never happen for non-implicit methods,; // but...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:21,Modifiability,variab,variables,21,// Fields and static variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:18,Modifiability,variab,variables,18,// Defined static variables that are members of an exported base; // class must be marked export too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:23,Integrability,depend,dependent,23,"// If the class is non-dependent, mark the default arguments as ODR-used so; // that we can properly codegen the constructor closure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:31,Integrability,rout,routines,31,// Mark any compiler-generated routines with the implicit code_seg attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:8,Modifiability,inherit,inherits,8,// MSVC inherits DLL attributes to partial class template specializations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:243,Safety,avoid,avoid,243,// MSVC allows imported or exported template classes that have UniqueExternal; // linkage. This occurs when the template class has been instantiated with; // a template parameter which itself has internal linkage.; // We drop the attribute to avoid exporting or importing any members.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:9,Modifiability,inherit,inherit,9,// Don't inherit dll attribute until the template is instantiated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:53,Modifiability,inherit,inherit,53,// Force declaration of implicit members so they can inherit the attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:34,Modifiability,inherit,inherit,34,// Only methods and static fields inherit the attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:4,Performance,Perform,Perform,4,/// Perform propagation of DLL attributes from a derived class to a; /// templated base class for MS compatibility.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:14,Availability,error,error,14,"/// Report an error regarding overriding, along with any relevant; /// overridden methods.; ///; /// \param DiagID the primary error to report.; /// \param MD the overriding method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:127,Availability,error,error,127,"/// Report an error regarding overriding, along with any relevant; /// overridden methods.; ///; /// \param DiagID the primary error to report.; /// \param MD the overriding method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:4,Performance,Perform,Perform,4,"/// Perform semantic checks on a class definition that has been; /// completing, introducing implicitly-declared members, checking for; /// abstract types, etc.; ///; /// \param S The scope in which the class was parsed. Null if we didn't just; /// parse a class definition.; /// \param Record The completed class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:116,Integrability,depend,depend,116,"// Explicitly-defaulted secondary comparison functions (!=, <, <=, >, >=).; // We check these last because they can depend on the properties of the; // primary comparison functions (==, <=>).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Performance,Perform,Perform,3,"// Perform checks that can't be done until we know all the properties of a; // member function (whether it's defaulted, deleted, virtual, overriding,; // ...).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:49,Integrability,depend,dependent,49,// Skip the rest of the checks for a member of a dependent class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:37,Integrability,depend,dependent,37,// FIXME: We could do this check for dependent types with non-dependent; // bases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:62,Integrability,depend,dependent,62,// FIXME: We could do this check for dependent types with non-dependent; // bases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:234,Availability,error,error,234,"// ms_struct is a request to use the same ABI rules as MSVC. Check; // whether this class uses any C++ features that are implemented; // completely differently in MSVC, and if so, emit a diagnostic.; // That diagnostic defaults to an error, but we allow projects to; // map it down to a warning (or ignore it). It's a fairly common; // practice among users of the ms_struct pragma to mass-annotate; // headers, sweeping up a bunch of types that the project doesn't; // really rely on MSVC-compatible layout for. We must therefore; // support ""ms_struct except for C++ stuff"" as a secondary ABI.; // Don't emit this diagnostic if the feature was enabled as a; // language option (as opposed to via a pragma or attribute), as; // the option -mms-bitfields otherwise essentially makes it impossible; // to build C++ code, unless this diagnostic is turned off.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:277,Availability,down,down,277,"// ms_struct is a request to use the same ABI rules as MSVC. Check; // whether this class uses any C++ features that are implemented; // completely differently in MSVC, and if so, emit a diagnostic.; // That diagnostic defaults to an error, but we allow projects to; // map it down to a warning (or ignore it). It's a fairly common; // practice among users of the ms_struct pragma to mass-annotate; // headers, sweeping up a bunch of types that the project doesn't; // really rely on MSVC-compatible layout for. We must therefore; // support ""ms_struct except for C++ stuff"" as a secondary ABI.; // Don't emit this diagnostic if the feature was enabled as a; // language option (as opposed to via a pragma or attribute), as; // the option -mms-bitfields otherwise essentially makes it impossible; // to build C++ code, unless this diagnostic is turned off.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:132,Performance,load,loads,132,"// If we want to emit all the vtables, we need to mark it as used. This; // is especially required for cases like vtable assumption loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:75,Modifiability,inherit,inherited,75,/// A mapping from the base classes through which the constructor was; /// inherited to the using shadow declaration in that base class (or a null; /// pointer if the constructor was declared in that base class).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:54,Modifiability,inherit,inherited,54,"// [class.inhctor.init]p2:; // If the constructor was inherited from multiple base class subobjects; // of type B, the program is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:36,Modifiability,inherit,inherited,36,"/// Find the constructor to use for inherited construction of a base class,; /// and whether that base class constructor inherits the constructor from a; /// virtual base class (in which case it won't actually invoke it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:121,Modifiability,inherit,inherits,121,"/// Find the constructor to use for inherited construction of a base class,; /// and whether that base class constructor inherits the constructor from a; /// virtual base class (in which case it won't actually invoke it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:57,Modifiability,inherit,inherited,57,// This is the base class from which the constructor was inherited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:62,Performance,perform,perform,62,/// Is the special member function which would be selected to perform the; /// specified operation on the specified class type a constexpr constructor?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:12,Modifiability,inherit,inheriting,12,"// If we're inheriting a constructor, see if we need to call it for this base; // class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:252,Performance,perform,performance,252,"// Since default constructor lookup is essentially trivial (and cannot; // involve, for instance, template instantiation), we compute whether a; // defaulted default constructor is constexpr directly within CXXRecordDecl.; //; // This is important for performance; we need to know whether the default; // constructor is constexpr to determine whether the type is a literal type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:45,Performance,perform,perform,45,"// For copy or move constructors, we need to perform overload resolution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:24,Performance,perform,perform,24,"// In C++1y, we need to perform overload resolution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Deployability,Update,Update,3,// Update the type of the special member to use it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:47,Integrability,depend,dependent,47,// Defer all checking for special members of a dependent type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:186,Performance,perform,perform,186,"/// Helper class for building and checking a defaulted comparison.; ///; /// Defaulted functions are built in two phases:; ///; /// * First, the set of operations that the function will perform are; /// identified, and some of them are checked. If any of the checked; /// operations is invalid in certain ways, the comparison function is; /// defined as deleted and no body is built.; /// * Then, if the function is not defined as deleted, the body is built.; ///; /// This is accomplished by performing two visitation steps over the eventual; /// body of the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:493,Performance,perform,performing,493,"/// Helper class for building and checking a defaulted comparison.; ///; /// Defaulted functions are built in two phases:; ///; /// * First, the set of operations that the function will perform are; /// identified, and some of them are checked. If any of the checked; /// operations is invalid in certain ways, the comparison function is; /// defined as deleted and no body is built.; /// * Then, if the function is not defined as deleted, the body is built.; ///; /// This is accomplished by performing two visitation steps over the eventual; /// body of the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:94,Safety,avoid,avoid,94,// FIXME: Change CreateOverloadedBinOp to take an ArrayRef instead of an; // UnresolvedSet to avoid this copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:186,Security,access,accessible,186,"// Throughout C++2a [class.compare]: if overload resolution does not; // result in a usable function, the candidate function is defined as; // deleted. This requires that we selected an accessible function.; //; // Note that this only considers the access of the function when named; // within the type of the subobject, and not the access path for any; // derived-to-base conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:249,Security,access,access,249,"// Throughout C++2a [class.compare]: if overload resolution does not; // result in a usable function, the candidate function is defined as; // deleted. This requires that we selected an accessible function.; //; // Note that this only considers the access of the function when named; // within the type of the subobject, and not the access path for any; // derived-to-base conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:333,Security,access,access,333,"// Throughout C++2a [class.compare]: if overload resolution does not; // result in a usable function, the candidate function is defined as; // deleted. This requires that we selected an accessible function.; //; // Note that this only considers the access of the function when named; // within the type of the subobject, and not the access path for any; // derived-to-base conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:85,Usability,usab,usable,85,"// Throughout C++2a [class.compare]: if overload resolution does not; // result in a usable function, the candidate function is defined as; // deleted. This requires that we selected an accessible function.; //; // Note that this only considers the access of the function when named; // within the type of the subobject, and not the access path for any; // derived-to-base conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:141,Performance,perform,performed,141,// C++2a [class.compare.default]p3 [P2002R0]:; // A defaulted comparison function is constexpr-compatible if; // [...] no overlod resolution performed [...] results in a; // non-constexpr function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:94,Availability,failure,failure,94,"// If any callee has an undeduced return type, deduce it now.; // FIXME: It's not clear how a failure here should be handled. For; // now, we produce an eager diagnostic, because that is forward; // compatible with most (all?) other reasonable options.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:82,Usability,clear,clear,82,"// If any callee has an undeduced return type, deduce it now.; // FIXME: It's not clear how a failure here should be handled. For; // now, we produce an eager diagnostic, because that is forward; // compatible with most (all?) other reasonable options.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:29,Availability,error,error,29,// Don't produce a duplicate error when asked to explain why the; // comparison is deleted: we diagnosed that when initially checking; // the defaulted operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:60,Modifiability,rewrite,rewrite,60,"// If there's no usable candidate, we're done unless we can rewrite a; // '<=>' in terms of '==' and '<'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:17,Usability,usab,usable,17,"// If there's no usable candidate, we're done unless we can rewrite a; // '<=>' in terms of '==' and '<'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:62,Usability,usab,usable,62,"// For any kind of comparison category return type, we need a usable; // '==' and a usable '<'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:84,Usability,usab,usable,84,"// For any kind of comparison category return type, we need a usable; // '==' and a usable '<'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:2,Performance,Perform,PerformADL,2,/*PerformADL=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:4,Performance,Perform,Perform,4,/// Perform the unqualified lookups that might be needed to form a defaulted; /// comparison function for the given operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:132,Integrability,depend,dependent,132,"// For 'operator<=>', we also form a 'cmp != 0' expression, and might; // synthesize a three-way comparison from '<' and '=='. In a dependent; // context, we also need to look up '==' in case we implicitly declare a; // defaulted 'operator=='.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Performance,Perform,Perform,3,// Perform any unqualified lookups we're going to need to default this; // function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:31,Availability,recover,recover,31,// Remove the ref qualifier to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:31,Safety,recover,recover,31,// Remove the ref qualifier to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:34,Availability,recover,recover,34,// Add the 'const' to the type to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:34,Safety,recover,recover,34,// Add the 'const' to the type to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:42,Availability,recover,recover,42,// Remove the 'volatile' from the type to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:42,Safety,recover,recover,42,// Remove the 'volatile' from the type to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:33,Integrability,depend,dependent,33,"// For a defaulted function in a dependent class, defer all remaining checks; // until instantiation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:263,Usability,simpl,simple,263,"// C++2a [dcl.fct.def.default]p3 [P2002R0]:; // If a constexpr-compatible function is explicitly defaulted on its first; // declaration, it is implicitly considered to be constexpr.; // FIXME: Only applying this to the first declaration seems problematic, as; // simple reorderings can affect the meaning of the program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Performance,Perform,Perform,3,// Perform any deferred checking of exception specifications for virtual; // destructors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Performance,Perform,Perform,3,// Perform any deferred checking of exception specifications for befriended; // special members.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:92,Modifiability,inherit,inherited,92,/// CRTP base class for visiting operations performed by a special member; /// function (or inherited constructor).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:44,Performance,perform,performed,44,/// CRTP base class for visiting operations performed by a special member; /// function (or inherited constructor).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:109,Modifiability,inherit,inherited,109,/// Look up the constructor for the specified base class to see if it's; /// overridden due to this being an inherited constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:159,Security,access,accessible,159,"// A member of a union must have a trivial corresponding special member.; // As a weird special case, a destructor call from a union's constructor; // must be accessible and non-deleted, but need not be trivial. Such a; // destructor is never actually called, but is semantically checked as; // if it were.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:70,Availability,error,error,70,"// If program is correct, BaseClass cannot be null, but if it is, the error; // must be reported elsewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:17,Modifiability,inherit,inheriting,17,"// If we have an inheriting constructor, check whether we're calling an; // inherited constructor instead of a default constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:76,Modifiability,inherit,inherited,76,"// If we have an inheriting constructor, check whether we're calling an; // inherited constructor instead of a default constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:29,Security,access,access,29,"// Note that we do not check access along this path; other than that,; // this is the same as shouldDeleteForSubobjectCall(Base, BaseCtor, false);; // FIXME: Check that the base has a usable destructor! Sink this into; // shouldDeleteForClassSubobject.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:184,Usability,usab,usable,184,"// Note that we do not check access along this path; other than that,; // this is the same as shouldDeleteForSubobjectCall(Base, BaseCtor, false);; // FIXME: Check that the base has a usable destructor! Sink this into; // shouldDeleteForClassSubobject.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:6,Security,access,access,6,// Do access control from the special member function,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:92,Modifiability,inherit,inherited,92,"// We should delete the special member in CUDA mode if target inference; // failed.; // For inherited constructors (non-null ICI), CSM may be passed so that MD; // is treated as certain special member, which may not reflect what special; // member MD really is. However inferCUDATargetForImplicitSpecialMember; // expects CSM to match MD, therefore recalculate CSM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:4,Performance,Perform,Perform,4,"/// Perform lookup for a special member of the specified kind, and determine; /// whether it is trivial. If the triviality can be determined without the; /// lookup, skip it. This is intended for use when determining whether a; /// special member of a containing object is trivial, and thus does not ever; /// perform overload resolution for default constructors.; ///; /// If \p Selected is not \c NULL, \c *Selected will be filled in with the; /// member that was most likely to be intended to be trivial, if any.; ///; /// If \p ForCall is true, look at CXXRecord::HasTrivialSpecialMembersForCall to; /// determine whether the special member is trivial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:310,Performance,perform,perform,310,"/// Perform lookup for a special member of the specified kind, and determine; /// whether it is trivial. If the triviality can be determined without the; /// lookup, skip it. This is intended for use when determining whether a; /// special member of a containing object is trivial, and thus does not ever; /// perform overload resolution for default constructors.; ///; /// If \p Selected is not \c NULL, \c *Selected will be filled in with the; /// member that was most likely to be intended to be trivial, if any.; ///; /// If \p ForCall is true, look at CXXRecord::HasTrivialSpecialMembersForCall to; /// determine whether the special member is trivial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:174,Performance,perform,performed,174,"// C++11 [class.ctor]p5:; // A default constructor is trivial if:; // - all the [direct subobjects] have trivial default constructors; //; // Note, no overload resolution is performed in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:101,Performance,perform,perform,101,// We must either select the trivial copy constructor or reach an; // ambiguity; no need to actually perform overload resolution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:36,Performance,perform,perform,36,"// In C++98, we are not supposed to perform overload resolution here, but we; // treat that as a language defect, as suggested on cxx-abi-dev, to treat; // cases like B as having a non-trivial copy constructor:; // struct A { template<typename T> A(T&); };; // struct B { mutable A a; };",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:36,Performance,perform,perform,36,"// In C++98, we are not supposed to perform overload resolution here, but we; // treat that as a language defect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:177,Modifiability,inherit,inherited,177,"// If the method we are checking overrides a method from its base; // don't warn about the other overloaded methods. Clang deviates from; // GCC by only diagnosing overloads of inherited virtual functions that; // do not override any other virtual functions in the base. GCC's; // -Woverloaded-virtual diagnoses any derived function hiding a virtual; // function from a base class. These cases may be better served by a; // warning (not specific to virtual functions) on call sites when the; // call would select a different function from the base class, were it; // visible.; // See FIXME in test/SemaCXX/warn-overload-virtual.cpp for an example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:593,Testability,test,test,593,"// If the method we are checking overrides a method from its base; // don't warn about the other overloaded methods. Clang deviates from; // GCC by only diagnosing overloads of inherited virtual functions that; // do not override any other virtual functions in the base. GCC's; // -Woverloaded-virtual diagnoses any derived function hiding a virtual; // function from a base class. These cases may be better served by a; // warning (not specific to virtual functions) on call sites when the; // call would select a different function from the base class, were it; // visible.; // See FIXME in test/SemaCXX/warn-overload-virtual.cpp for an example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:7,Safety,Detect,DetectVirtual,7,/*bool DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:18,Integrability,depend,dependent,18,"// If the type is dependent, then assume it might have; // implicit copy or move ctor because we won't know yet at this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:218,Integrability,rout,routine,218,"/// AddImplicitlyDeclaredMembersToClass - Adds any implicitly-declared; /// special functions, such as the default constructor, copy; /// constructor, or destructor, to the given C++ class (C++; /// [special]p1). This routine can only be executed just before the; /// definition of the class is complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:236,Modifiability,inherit,inherited,236,// For the MS ABI we need to know whether the copy ctor is deleted. A; // prerequisite for deleting the implicit copy ctor is that the class has; // a move ctor or move assignment that is either user-declared or whose; // semantics are inherited from a subobject. FIXME: We should provide a; // more direct way for CodeGen to ask whether the constructor was deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:477,Performance,perform,performed,477,"/// ActOnStartDelayedCXXMethodDeclaration - We have completed; /// parsing a top-level (non-nested) C++ class, and we are now; /// parsing those parts of the given Method declaration that could; /// not be parsed earlier (C++ [class.mem]p2), such as default; /// arguments. This action should enter the scope of the given; /// Method declaration as if we had just parsed the qualified method; /// name. However, it should not bring the parameters into scope;; /// that will be performed by ActOnDelayedCXXMethodParameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:166,Availability,error,errors,166,"/// CheckConstructorDeclarator - Called by ActOnDeclarator to check; /// the well-formedness of the constructor declarator @p D with type @p; /// R. If there are any errors in the declarator, this routine will; /// emit diagnostics and set the invalid bit to true. In any case, the type; /// will be updated to reflect a well-formed type for the constructor and; /// returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:300,Deployability,update,updated,300,"/// CheckConstructorDeclarator - Called by ActOnDeclarator to check; /// the well-formedness of the constructor declarator @p D with type @p; /// R. If there are any errors in the declarator, this routine will; /// emit diagnostics and set the invalid bit to true. In any case, the type; /// will be updated to reflect a well-formed type for the constructor and; /// returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:197,Integrability,rout,routine,197,"/// CheckConstructorDeclarator - Called by ActOnDeclarator to check; /// the well-formedness of the constructor declarator @p D with type @p; /// R. If there are any errors in the declarator, this routine will; /// emit diagnostics and set the invalid bit to true. In any case, the type; /// will be updated to reflect a well-formed type for the constructor and; /// returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:85,Availability,error,errors,85,"// Rebuild the function type ""R"" without any type qualifiers (in; // case any of the errors above fired) and with ""void"" as the; // return type, since constructors don't have return types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:147,Availability,error,error,147,"/// CheckDestructor - Checks a fully-formed destructor definition for; /// well-formedness, issuing any diagnostics required. Returns true; /// on error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:161,Performance,perform,perform,161,"// If the notional 'delete this' expression requires a non-trivial; // conversion from 'this' to the type of a destroying operator delete's; // first parameter, perform that conversion now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:163,Availability,error,errors,163,"/// CheckDestructorDeclarator - Called by ActOnDeclarator to check; /// the well-formednes of the destructor declarator @p D with type @p; /// R. If there are any errors in the declarator, this routine will; /// emit diagnostics and set the declarator to invalid. Even if this happens,; /// will be updated to reflect a well-formed type for the destructor and; /// returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:299,Deployability,update,updated,299,"/// CheckDestructorDeclarator - Called by ActOnDeclarator to check; /// the well-formednes of the destructor declarator @p D with type @p; /// R. If there are any errors in the declarator, this routine will; /// emit diagnostics and set the declarator to invalid. Even if this happens,; /// will be updated to reflect a well-formed type for the destructor and; /// returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:194,Integrability,rout,routine,194,"/// CheckDestructorDeclarator - Called by ActOnDeclarator to check; /// the well-formednes of the destructor declarator @p D with type @p; /// R. If there are any errors in the declarator, this routine will; /// emit diagnostics and set the declarator to invalid. Even if this happens,; /// will be updated to reflect a well-formed type for the destructor and; /// returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:99,Availability,error,errors,99,"// Rebuild the function type ""R"" without any type qualifiers or; // parameters (in case any of the errors above fired) and with; // ""void"" as the return type, since destructors don't have return; // types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:172,Availability,error,errors,172,"/// CheckConversionDeclarator - Called by ActOnDeclarator to check the; /// well-formednes of the conversion function declarator @p D with; /// type @p R. If there are any errors in the declarator, this routine; /// will emit diagnostics and return true. Otherwise, it will return; /// false. Either way, the type @p R will be updated to reflect a; /// well-formed type for the conversion operator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:327,Deployability,update,updated,327,"/// CheckConversionDeclarator - Called by ActOnDeclarator to check the; /// well-formednes of the conversion function declarator @p D with; /// type @p R. If there are any errors in the declarator, this routine; /// will emit diagnostics and return true. Otherwise, it will return; /// false. Either way, the type @p R will be updated to reflect a; /// well-formed type for the conversion operator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:203,Integrability,rout,routine,203,"/// CheckConversionDeclarator - Called by ActOnDeclarator to check the; /// well-formednes of the conversion function declarator @p D with; /// type @p R. If there are any errors in the declarator, this routine; /// will emit diagnostics and return true. Otherwise, it will return; /// false. Either way, the type @p R will be updated to reflect a; /// well-formed type for the conversion operator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Availability,Recover,Recover,3,"// Recover by incorporating the other type chunks into the result type.; // Note, this does *not* change the name of the function. This is compatible; // with the GCC extension:; // struct S { &operator int(); } s;; // int &r = s.operator int(); // ok in GCC; // S::operator int&() {} // error in GCC, function name is 'operator int'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:288,Availability,error,error,288,"// Recover by incorporating the other type chunks into the result type.; // Note, this does *not* change the name of the function. This is compatible; // with the GCC extension:; // struct S { &operator int(); } s;; // int &r = s.operator int(); // ok in GCC; // S::operator int&() {} // error in GCC, function name is 'operator int'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Safety,Recover,Recover,3,"// Recover by incorporating the other type chunks into the result type.; // Note, this does *not* change the name of the function. This is compatible; // with the GCC extension:; // struct S { &operator int(); } s;; // int &r = s.operator int(); // ok in GCC; // S::operator int&() {} // error in GCC, function name is 'operator int'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:80,Availability,error,errors,80,"// Rebuild the function type ""R"" without any parameters (in case any; // of the errors above fired) and with the conversion type as the; // return type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:134,Integrability,rout,routine,134,"/// ActOnConversionDeclarator - Called by ActOnDeclarator to complete; /// the declaration of the given C++ conversion function. This routine; /// is responsible for recording the conversion function in the C++; /// class, if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:70,Usability,guid,guide,70,"/// Check the validity of a declarator that we parsed for a deduction-guide.; /// These aren't actually declarators in the grammar, so we need to check that; /// the user didn't specify any pieces that are not part of the deduction-guide; /// grammar. Return true on invalid deduction-guide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:232,Usability,guid,guide,232,"/// Check the validity of a declarator that we parsed for a deduction-guide.; /// These aren't actually declarators in the grammar, so we need to check that; /// the user didn't specify any pieces that are not part of the deduction-guide; /// grammar. Return true on invalid deduction-guide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:285,Usability,guid,guide,285,"/// Check the validity of a declarator that we parsed for a deduction-guide.; /// These aren't actually declarators in the grammar, so we need to check that; /// the user didn't specify any pieces that are not part of the deduction-guide; /// grammar. Return true on invalid deduction-guide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:20,Usability,guid,guide,20,// C++ [temp.deduct.guide]p3:; // A deduction-gide shall be declared in the same scope as the; // corresponding class template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:27,Usability,simpl,simple,27,// Check the declarator is simple enough.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:108,Usability,guid,guide,108,// Check that the return type is written as a specialization of; // the template specified as the deduction-guide's name.; // The template name may not be qualified. [temp.deduct.guide],MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:179,Usability,guid,guide,179,// Check that the return type is written as a specialization of; // the template specified as the deduction-guide's name.; // The template name may not be qualified. [temp.deduct.guide],MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:41,Usability,guid,guide,41,// we can still create a valid deduction guide here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:162,Safety,avoid,avoid,162,"// 'inline' must appear on the original definition, but not necessarily; // on all extension definitions, so the note should point to the first; // definition to avoid confusion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:14,Modifiability,extend,extended,14,// This is an extended namespace definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:66,Deployability,update,update,66,"// This is the first ""real"" definition of the namespace ""std"", so update; // our cache of the ""std"" namespace to point at this definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:81,Performance,cache,cache,81,"// This is the first ""real"" definition of the namespace ""std"", so update; // our cache of the ""std"" namespace to point at this definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Deployability,Update,Update,3,// Update the Record decl in case we encountered a forward declaration on our; // first pass. FIXME: This is a bit of a hack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Availability,Toler,Tolerate,3,// Tolerate empty base classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:64,Deployability,Update,Update,64,// We've successfully built the required types and expressions. Update; // the cache and return the newly cached value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:79,Performance,cache,cache,79,// We've successfully built the required types and expressions. Update; // the cache and return the newly cached value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:106,Performance,cache,cached,106,// We've successfully built the required types and expressions. Update; // the cache and return the newly cached value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:43,Availability,avail,available,43,"// We want the created NamespaceDecl to be available for redeclaration; // lookups, but not for regular name lookups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:32,Availability,recover,recovery,32,// This can only happen along a recovery path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:32,Safety,recover,recovery,32,// This can only happen along a recovery path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:9,Modifiability,inherit,inheriting,9,// C++11 inheriting constructors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:14,Security,access,access,14,// Warn about access declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:141,Security,access,access,141,"// If the target happens to be one of the previous declarations, we; // don't have a conflict.; //; // FIXME: but we might be increasing its access, in which case we; // should redeclare it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:40,Availability,error,error,40,"// If we're not in a record, this is an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:1265,Integrability,depend,dependent,1265,"/// Hides a using shadow declaration. This is required by the current; /// using-decl implementation when a resolvable using declaration in a; /// class is followed by a declaration which would hide or override; /// one or more of the using decl's targets; for example:; ///; /// struct Base { void foo(int); };; /// struct Derived : Base {; /// using Base::foo;; /// void foo(int);; /// };; ///; /// The governing language is C++03 [namespace.udecl]p12:; ///; /// When a using-declaration brings names from a base class into a; /// derived class scope, member functions in the derived class; /// override and/or hide member functions with the same name and; /// parameter types in a base class (rather than conflicting).; ///; /// There are two ways to implement this:; /// (1) optimistically create shadow decls when they're not hidden; /// by existing declarations, or; /// (2) don't create any shadow decls (or at least don't make them; /// visible) until we've fully parsed/instantiated the class.; /// The problem with (1) is that we might have to retroactively remove; /// a shadow decl, which requires several O(n) operations because the; /// decl structures are (very reasonably) not designed for removal.; /// (2) avoids this but is very fiddly and phase-dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:1224,Safety,avoid,avoids,1224,"/// Hides a using shadow declaration. This is required by the current; /// using-decl implementation when a resolvable using declaration in a; /// class is followed by a declaration which would hide or override; /// one or more of the using decl's targets; for example:; ///; /// struct Base { void foo(int); };; /// struct Derived : Base {; /// using Base::foo;; /// void foo(int);; /// };; ///; /// The governing language is C++03 [namespace.udecl]p12:; ///; /// When a using-declaration brings names from a base class into a; /// derived class scope, member functions in the derived class; /// override and/or hide member functions with the same name and; /// parameter types in a base class (rather than conflicting).; ///; /// There are two ways to implement this:; /// (1) optimistically create shadow decls when they're not hidden; /// by existing declarations, or; /// (2) don't create any shadow decls (or at least don't make them; /// visible) until we've fully parsed/instantiated the class.; /// The problem with (1) is that we might have to retroactively remove; /// a shadow decl, which requires several O(n) operations because the; /// decl structures are (very reasonably) not designed for removal.; /// (2) avoids this but is very fiddly and phase-dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:52,Integrability,inject,injected-class-name,52,"// No-one ever wants a using-declaration to name an injected-class-name; // of a base class, unless they're declaring an inheriting constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:121,Modifiability,inherit,inheriting,121,"// No-one ever wants a using-declaration to name an injected-class-name; // of a base class, unless they're declaring an inheriting constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:52,Security,inject,injected-class-name,52,"// No-one ever wants a using-declaration to name an injected-class-name; // of a base class, unless they're declaring an inheriting constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:18,Integrability,inject,injected-class-name,18,"// Check that the injected-class-name is named as a member of its own; // type; we don't want to suggest 'using Derived::Base;', since that; // means something else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:18,Security,inject,injected-class-name,18,"// Check that the injected-class-name is named as a member of its own; // type; we don't want to suggest 'using Derived::Base;', since that; // means something else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:19,Modifiability,inherit,inheriting,19,// Check that this inheriting constructor declaration actually names a; // direct base class of the current class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:46,Security,access,accessible,46,// FIXME: Check that the base class member is accessible?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:51,Modifiability,inherit,inheriting,51,"// FIXME: We ignore attributes for now.; // For an inheriting constructor declaration, the name of the using; // declaration is the name of a constructor in this class, not in the; // base class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:181,Integrability,depend,dependent,181,"// No redeclaration check is needed here; in non-member contexts we; // diagnosed all possible conflicts with other using-declarations when; // building the template:; //; // For a dependent non-type using declaration, the only valid case is; // if we instantiate to a single enumerator. We check for conflicts; // between shadow declarations we introduce, and we check in the template; // definition for conflicts between a non-type using declaration and any; // other declaration, which together covers all cases.; //; // A dependent typename using declaration will never successfully; // instantiate, since it will always name a class member, so we reject; // that in the template definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:526,Integrability,depend,dependent,526,"// No redeclaration check is needed here; in non-member contexts we; // diagnosed all possible conflicts with other using-declarations when; // building the template:; //; // For a dependent non-type using declaration, the only valid case is; // if we instantiate to a single enumerator. We check for conflicts; // between shadow declarations we introduce, and we check in the template; // definition for conflicts between a non-type using declaration and any; // other declaration, which together covers all cases.; //; // A dependent typename using declaration will never successfully; // instantiate, since it will always name a class member, so we reject; // that in the template definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:46,Modifiability,inherit,inherited,46,// 'using_if_exists' doesn't make sense on an inherited constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Integrability,Depend,Dependent,3,"// Dependent scope, or an unexpanded pack",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:179,Integrability,depend,dependent,179,"// Unlike most lookups, we don't always want to hide tag; // declarations: tag names are visible through the using declaration; // even if hidden by ordinary names, *except* in a dependent context; // where they may be used by two-phase lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Security,Validat,Validate,3,"// Validate the context, now we have a lookup",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:212,Integrability,depend,dependent,212,"// Try to correct typos if possible. If constructor name lookup finds no; // results, that means the named class has no explicit constructors, and we; // suppressed declaring implicit ones (probably because it's dependent or; // invalid).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:58,Safety,detect,detection,58,// HACK 2017-01-08: Work around an issue with libstdc++'s detection of; // ::gets. Sometimes it believes that glibc provides a ::gets in cases where; // it does not. The issue was fixed in libstdc++ 6.3 (2016-12-21) and later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:25,Modifiability,inherit,inheriting,25,"// If we corrected to an inheriting constructor, handle it as one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:21,Integrability,inject,injected,21,// The parent of the injected class name is the class itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:21,Security,inject,injected,21,// The parent of the injected class name is the class itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:55,Availability,error,error,55,"// If we asked for a typename and got a non-type decl, error out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:53,Availability,error,error,53,"// If we asked for a non-typename and we got a type, error out,; // but only if this is an instantiation of an unresolved using; // decl. Otherwise just silently find the type name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:34,Modifiability,inherit,inheriting,34,// Some additional rules apply to inheriting constructors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:101,Modifiability,inherit,inheriting,101,// Suppress access diagnostics; the access check is instead performed at the; // point of use for an inheriting constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:60,Performance,perform,performed,60,// Suppress access diagnostics; the access check is instead performed at the; // point of use for an inheriting constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:12,Security,access,access,12,// Suppress access diagnostics; the access check is instead performed at the; // point of use for an inheriting constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:36,Security,access,access,36,// Suppress access diagnostics; the access check is instead performed at the; // point of use for an inheriting constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:5,Integrability,depend,dependent,5,// A dependent qualifier outside a class can only ever resolve to an; // enumeration type. Therefore it conflicts with any other non-type; // declaration in the same scope.; // FIXME: How should we check for dependent type-type conflicts at block; // scope?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:208,Integrability,depend,dependent,208,// A dependent qualifier outside a class can only ever resolve to an; // enumeration type. Therefore it conflicts with any other non-type; // declaration in the same scope.; // FIXME: How should we check for dependent type-type conflicts at block; // scope?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:83,Integrability,depend,dependent,83,// using decls differ if one says 'typename' and the other doesn't.; // FIXME: non-dependent using decls?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:155,Availability,error,error,155,"/// Checks that the given nested-name qualifier used in a using decl; /// in the current context is appropriately related to the current; /// scope. If an error is found, diagnoses it and returns true.; /// R is nullptr, if the caller has not (yet) done a lookup, otherwise it's the; /// result of that lookup. UD is likewise nullptr, except when we have an; /// already-populated UsingDecl whose shadow decls contain the same information; /// (i.e. we're instantiating a UsingDecl with non-dependent scope).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:491,Integrability,depend,dependent,491,"/// Checks that the given nested-name qualifier used in a using decl; /// in the current context is appropriately related to the current; /// scope. If an error is found, diagnoses it and returns true.; /// R is nullptr, if the caller has not (yet) done a lookup, otherwise it's the; /// result of that lookup. UD is likewise nullptr, except when we have an; /// already-populated UsingDecl whose shadow decls contain the same information; /// (i.e. we're instantiating a UsingDecl with non-dependent scope).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:277,Integrability,depend,dependent,277,"// C++03 [namespace.udecl]p3:; // C++0x [namespace.udecl]p8:; // A using-declaration for a class member shall be a member-declaration.; // C++20 [namespace.udecl]p7; // ... other than an enumerator ...; // If we weren't able to compute a valid scope, it might validly be a; // dependent class or enumeration scope. If we have a 'typename' keyword,; // the scope must resolve to a class type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:15,Modifiability,variab,variable,15,// const[expr] variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:27,Integrability,depend,dependent,27,"// If the named context is dependent, we can't decide much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:475,Performance,cache,cached,475,"// C++03 [namespace.udecl]p4:; // A using-declaration used as a member-declaration shall refer; // to a member of a base class of the class being defined [etc.].; // Salient point: SS doesn't have to name a base class as long as; // lookup only finds members from base classes. Therefore we can; // diagnose here only if we can prove that can't happen,; // i.e. if the class hierarchies provably don't intersect.; // TODO: it would be nice if ""definitely valid"" results were cached; // in the UsingDecl and UsingShadowDecl so that these checks didn't; // need to be repeated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:48,Integrability,depend,dependent,48,// Collect all bases. Return false if we find a dependent base.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:31,Integrability,depend,dependent,31,// Returns true if the base is dependent or is one of the accumulated base; // classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:35,Integrability,depend,dependent,35,// Return false if the class has a dependent base or if it or one; // of its bases is present in the base set of the current context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:38,Usability,clear,clearly,38,"// FIXME: The C++0x standard does not clearly say this is ill-formed,; // but we can't reasonably accept it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:62,Performance,cache,cache,62,"// This almost never happens, but if it does, ensure that our cache; // doesn't contain a stale result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:53,Availability,error,error,53,// Register a note to be produced if we encounter an error while; // declaring the special member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:350,Security,expose,exposes,350,"// FIXME: We don't have a location to use here. Using the class's; // location maintains the fiction that we declare all special members; // with the class, but (1) it's not clear that lying about that helps our; // users understand what's going on, and (2) there may be outer contexts; // on the stack (some of which are relevant) and printing them exposes; // our lies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:174,Usability,clear,clear,174,"// FIXME: We don't have a location to use here. Using the class's; // location maintains the fiction that we declare all special members; // with the class, but (1) it's not clear that lying about that helps our; // users understand what's going on, and (2) there may be outer contexts; // on the stack (some of which are relevant) and printing them exposes; // our lies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:84,Availability,reliab,reliable,84,// During template instantiation of implicit special member functions we need; // a reliable TypeSourceInfo for the function prototype in order to allow; // functions to be substituted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Performance,Perform,Perform,3,// Perform any delayed checks on exception specifications.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:51,Modifiability,inherit,inherited,51,// FIXME: Add a new kind of DeclarationName for an inherited constructor.; // For now we use the name of the base class constructor as a member of the; // derived class to indicate a (fake) inherited constructor name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:190,Modifiability,inherit,inherited,190,// FIXME: Add a new kind of DeclarationName for an inherited constructor.; // For now we use the name of the base class constructor as a member of the; // derived class to indicate a (fake) inherited constructor name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:63,Modifiability,inherit,inherited,63,// Check to see if we already have a fake constructor for this inherited; // constructor call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:13,Modifiability,inherit,inherited,13,// Check the inherited constructor is valid and find the list of base classes; // from which it was inherited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:100,Modifiability,inherit,inherited,100,// Check the inherited constructor is valid and find the list of base classes; // from which it was inherited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:23,Performance,perform,performed,23,"// Initializations are performed ""as if by a defaulted default constructor"",; // so enter the appropriate scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:197,Modifiability,inherit,inherited,197,// [class.inhctor.init]p1:; // initialization proceeds as if a defaulted default constructor is used to; // initialize the D object and each base class subobject from which the; // constructor was inherited,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:87,Modifiability,inherit,inherited,87,// Build explicit initializers for all base classes from which the; // constructor was inherited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:133,Integrability,depend,depends,133,"// We can't check whether an implicit destructor is deleted before we complete; // the definition of the class, because its validity depends on the alignment; // of the class. We'll check this from ActOnFields once the class is complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:4,Performance,Perform,Perform,4,/// Perform any semantic analysis which needs to be delayed until all; /// pending class member declarations have been parsed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:139,Modifiability,extend,extended,139,"// Replace the destructor's type, building off the existing one. Fortunately,; // the only thing of interest in the destructor type is its extended info.; // The return and arguments are fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:153,Safety,avoid,avoid,153,/// An abstract base class for all helper classes used in building the; // copy/move operators. These classes serve as factory functions and help us; // avoid using the same Expr* in the AST twice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:204,Performance,optimiz,optimization,204,"// end anonymous namespace; /// When generating a defaulted copy or move assignment operator, if a field; /// should be copied with __builtin_memcpy rather than via explicit assignments,; /// do so. This optimization only applies for arrays of scalars, and for arrays; /// of class type where the selected copy/move-assignment operator is trivial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:101,Integrability,rout,routine,101,"/// Builds a statement that copies/moves the given entity from \p From to; /// \c To.; ///; /// This routine is used to copy/move the members of a class with an; /// implicitly-declared copy/move assignment operator. When the entities being; /// copied are arrays, this routine builds for loops to copy them.; ///; /// \param S The Sema object used for type-checking.; ///; /// \param Loc The location where the implicit copy/move is being generated.; ///; /// \param T The type of the expressions being copied/moved. Both expressions; /// must have this type.; ///; /// \param To The expression we are copying/moving to.; ///; /// \param From The expression we are copying/moving from.; ///; /// \param CopyingBaseSubobject Whether we're copying/moving a base subobject.; /// Otherwise, it's a non-static member subobject.; ///; /// \param Copying Whether we're copying or moving.; ///; /// \param Depth Internal parameter recording the depth of the recursion.; ///; /// \returns A statement or a loop that copies the expressions, or StmtResult(0); /// if a memcpy should be used instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:270,Integrability,rout,routine,270,"/// Builds a statement that copies/moves the given entity from \p From to; /// \c To.; ///; /// This routine is used to copy/move the members of a class with an; /// implicitly-declared copy/move assignment operator. When the entities being; /// copied are arrays, this routine builds for loops to copy them.; ///; /// \param S The Sema object used for type-checking.; ///; /// \param Loc The location where the implicit copy/move is being generated.; ///; /// \param T The type of the expressions being copied/moved. Both expressions; /// must have this type.; ///; /// \param To The expression we are copying/moving to.; ///; /// \param From The expression we are copying/moving from.; ///; /// \param CopyingBaseSubobject Whether we're copying/moving a base subobject.; /// Otherwise, it's a non-static member subobject.; ///; /// \param Copying Whether we're copying or moving.; ///; /// \param Depth Internal parameter recording the depth of the recursion.; ///; /// \returns A statement or a loop that copies the expressions, or StmtResult(0); /// if a memcpy should be used instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:639,Modifiability,rewrite,rewrite,639,"// Suppress the protected check (C++ [class.protected]) for each of the; // assignment operators we found. This strange dance is required when; // we're assigning via a base classes's copy-assignment operator. To; // ensure that we're getting the right base class subobject (without; // ambiguities), we need to cast ""this"" to that subobject type; to; // ensure that we don't go through the virtual call mechanism, we need; // to qualify the operator= name with the base class (see below). However,; // this means that if the base class has a protected copy assignment; // operator, the protected member access check will fail. So, we; // rewrite ""protected"" access to ""public"" access in this case, since we; // know by construction that we're calling from a derived class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:604,Security,access,access,604,"// Suppress the protected check (C++ [class.protected]) for each of the; // assignment operators we found. This strange dance is required when; // we're assigning via a base classes's copy-assignment operator. To; // ensure that we're getting the right base class subobject (without; // ambiguities), we need to cast ""this"" to that subobject type; to; // ensure that we don't go through the virtual call mechanism, we need; // to qualify the operator= name with the base class (see below). However,; // this means that if the base class has a protected copy assignment; // operator, the protected member access check will fail. So, we; // rewrite ""protected"" access to ""public"" access in this case, since we; // know by construction that we're calling from a derived class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:659,Security,access,access,659,"// Suppress the protected check (C++ [class.protected]) for each of the; // assignment operators we found. This strange dance is required when; // we're assigning via a base classes's copy-assignment operator. To; // ensure that we're getting the right base class subobject (without; // ambiguities), we need to cast ""this"" to that subobject type; to; // ensure that we don't go through the virtual call mechanism, we need; // to qualify the operator= name with the base class (see below). However,; // this means that if the base class has a protected copy assignment; // operator, the protected member access check will fail. So, we; // rewrite ""protected"" access to ""public"" access in this case, since we; // know by construction that we're calling from a derived class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:678,Security,access,access,678,"// Suppress the protected check (C++ [class.protected]) for each of the; // assignment operators we found. This strange dance is required when; // we're assigning via a base classes's copy-assignment operator. To; // ensure that we're getting the right base class subobject (without; // ambiguities), we need to cast ""this"" to that subobject type; to; // ensure that we don't go through the virtual call mechanism, we need; // to qualify the operator= name with the base class (see below). However,; // this means that if the base class has a protected copy assignment; // operator, the protected member access check will fail. So, we; // rewrite ""protected"" access to ""public"" access in this case, since we; // know by construction that we're calling from a derived class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:24,Modifiability,variab,variable,24,// Create the iteration variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:28,Modifiability,variab,variable,28,// Initialize the iteration variable to zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:40,Modifiability,variab,variable,40,// Creates a reference to the iteration variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:48,Modifiability,variab,variable,48,// Create the DeclStmt that holds the iteration variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:64,Modifiability,variab,variable,64,"// Subscript the ""from"" and ""to"" expressions with the iteration variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:45,Modifiability,variab,variable,45,// Create the pre-increment of the iteration variable. We can determine; // whether the increment will overflow based on the value of the array; // bound.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:130,Performance,perform,performs,130,"// C++0x [class.copy]p30:; // The implicitly-defined or explicitly-defaulted copy assignment operator; // for a non-union class X performs memberwise copy assignment of its; // subobjects. The direct base classes of X are assigned first, in the; // order of their declaration in the base-specifier-list, and then the; // immediate non-static data members of X are assigned, in the order in; // which they were declared in the class definition.; // The statements that form the synthesized function body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:109,Performance,perform,performs,109,"// C++0x [class.copy]p28:; // The implicitly-defined or move assignment operator for a non-union class; // X performs memberwise move assignment of its subobjects. The direct base; // classes of X are assigned first, in the order of their declaration in the; // base-specifier-list, and then the immediate non-static data members of X; // are assigned, in the order in which they were declared in the class; // definition.; // Issue a warning if our implicit move assignment operator will move; // from a virtual base more than once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:75,Availability,reliab,reliable,75,// During template instantiation of special member functions we need a; // reliable TypeSourceInfo for the parameter types in order to allow functions; // to be substituted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:113,Deployability,Update,Update,113,// Fill in the __invoke function with a dummy implementation. IR generation; // will fill in the actual details. Update its type in case it contained; // an 'auto'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:100,Availability,down,down,100,"// FIXME: Converting constructors should also be accepted.; // But to fix this, the logic that digs down into a CXXConstructExpr; // to find the source object needs to handle it.; // Right now it assumes the source object is passed directly as the; // first argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:84,Testability,log,logic,84,"// FIXME: Converting constructors should also be accepted.; // But to fix this, the logic that digs down into a CXXConstructExpr; // to find the source object needs to handle it.; // Right now it assumes the source object is passed directly as the; // first argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:23,Modifiability,variab,variable,23,"// If initializing the variable failed, don't also diagnose problems with; // the destructor, they're likely related.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:53,Modifiability,variab,variable,53,"// If the destructor is constexpr, check whether the variable has constant; // destruction now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:223,Availability,error,error,223,"/// Given a constructor and the set of arguments provided for the; /// constructor, convert the arguments and add any required default arguments; /// to form a proper call to this constructor.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:28,Availability,avail,available,28,"// If too few arguments are available, we'll fill in the rest with defaults.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:30,Integrability,depend,dependent,30,// Reject even if the type is dependent; an operator delete function is; // required to have a non-dependent result type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:99,Integrability,depend,dependent,99,// Reject even if the type is dependent; an operator delete function is; // required to have a non-dependent result type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:49,Integrability,depend,dependent,49,"// The first parameter type is not allowed to be dependent. As a tentative; // DR resolution, we allow a dependent parameter type if it is the right; // type anyway, to allow destroying operator delete in class templates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:105,Integrability,depend,dependent,105,"// The first parameter type is not allowed to be dependent. As a tentative; // DR resolution, we allow a dependent parameter type if it is the right; // type anyway, to allow destroying operator delete in class templates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:38,Modifiability,variab,variable,38,"/// Perform semantic analysis for the variable declaration that; /// occurs within a C++ catch clause, returning the newly-created; /// variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:136,Modifiability,variab,variable,136,"/// Perform semantic analysis for the variable declaration that; /// occurs within a C++ catch clause, returning the newly-created; /// variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:4,Performance,Perform,Perform,4,"/// Perform semantic analysis for the variable declaration that; /// occurs within a C++ catch clause, returning the newly-created; /// variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:22,Availability,error,error,22,"// For the purpose of error recovery, we treat rvalue refs like lvalue refs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:28,Availability,recover,recovery,28,"// For the purpose of error recovery, we treat rvalue refs like lvalue refs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:28,Safety,recover,recovery,28,"// For the purpose of error recovery, we treat rvalue refs like lvalue refs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:27,Testability,test,test,27,// FIXME: should this be a test for macosx-fragile specifically?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:33,Modifiability,variab,variables,33,"// In ARC, infer 'retaining' for variables of retainable type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:104,Modifiability,extend,extended,104,"/// Convert character's value, interpreted as a code unit, to a string.; /// The value needs to be zero-extended to 32-bits.; /// FIXME: This assumes Unicode literal encodings",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:13,Energy Efficiency,reduce,reduced,13,"// Bools are reduced to ints during evaluation, but for; // diagnostic purposes we want to print them as; // true or false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:104,Availability,error,error,104,// These have been substituted from template parameters; // and appear as literals in the static assert error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:97,Testability,assert,assert,97,// These have been substituted from template parameters; // and appear as literals in the static assert error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:14,Usability,simpl,simple,14,// -5 is also simple to understand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:126,Testability,test,test,126,"// In C mode, allow folding as an extension for better compatibility with; // C++ in terms of expressions like static_assert(""test"") or; // static_assert(nullptr).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:57,Integrability,message,message,57,"// If the static_assert passes, only verify that; // the message is grammatically valid without evaluating it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:2,Availability,Error,ErrorOnInvalidMessage,2,/*ErrorOnInvalidMessage=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:2,Availability,Error,ErrorOnInvalidMessage,2,/*ErrorOnInvalidMessage=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:9,Availability,down,down,9,// Drill down into concept specialization expressions to see why they; // weren't satisfied.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:4,Performance,Perform,Perform,4,/// Perform semantic analysis of the given friend type declaration.; ///; /// \returns A friend declaration that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:178,Usability,simpl,simple-type-specifier,178,// C++11 [class.friend]p3:; // A friend declaration that does not declare a function shall have one; // of the following forms:; // friend elaborated-type-specifier ;; // friend simple-type-specifier ;; // friend typename-specifier ;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:84,Availability,down,down,84,"// FIXME: don't ignore attributes.; // If it's explicit specializations all the way down, just forget; // about the template header and build an appropriate non-templated; // friend. TODO: for source fidelity, remember the headers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:445,Usability,simpl,simple,445,"/// Handle a friend type declaration. This works in tandem with; /// ActOnTag.; ///; /// Notes on friend class templates:; ///; /// We generally treat friend class declarations as if they were; /// declaring a class. So, for example, the elaborated type specifier; /// in a friend declaration is required to obey the restrictions of a; /// class-head (i.e. no typedefs in the scope chain), template; /// parameters are required to match up with simple template-ids, &c.; /// However, unlike when declaring a template specialization, it's; /// okay to refer to a template specialization without an empty; /// template parameter declaration, e.g.; /// friend class A<T>::B<unsigned>;; /// We permit this as a special case; if there are any template; /// parameters present at all, require proper matching, i.e.; /// template <> template \<class T> friend class A<int>::B;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:176,Usability,simpl,simple-type-specifier,176,"// C++ [class.friend]p3:; // A friend declaration that does not declare a function shall have one of; // the following forms:; // friend elaborated-type-specifier ;; // friend simple-type-specifier ;; // friend typename-specifier ;; //; // Any declaration with a type qualifier does not have that form. (It's; // legal to specify a qualified type as a friend, you just can't write the; // keywords.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:25,Availability,error,error,25,"// This is definitely an error in C++98. It's probably meant to; // be forbidden in C++0x, too, but the specification is just; // poorly written.; //; // The problem is with declarations like the following:; // template <T> friend A<T>::foo;; // where deciding whether a class C is a friend or not now hinges; // on whether there exists an instantiation of A that causes; // 'foo' to equal C. There are restrictions on class-heads; // (which we declare (by fiat) elaborated friend declarations to; // be) that makes this tractable.; //; // FIXME: handle ""template <> friend class A<T>;"", which; // is possibly well-formed? Who even knows?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:165,Integrability,depend,dependent,165,"// C++ [class.friend]p1; // A friend of a class is a function or class....; // Note that this sees through typedefs, which is intended.; // It *doesn't* see through dependent types, which is correct; // according to [temp.arg.type]p3:; // If a declaration acquires a function type through a; // type dependent on a template-parameter and this causes; // a declaration that does not use the syntactic form of a; // function declarator to have a function type, the program; // is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:300,Integrability,depend,dependent,300,"// C++ [class.friend]p1; // A friend of a class is a function or class....; // Note that this sees through typedefs, which is intended.; // It *doesn't* see through dependent types, which is correct; // according to [temp.arg.type]p3:; // If a declaration acquires a function type through a; // type dependent on a template-parameter and this causes; // a declaration that does not use the syntactic form of a; // function declarator to have a function type, the program; // is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:36,Availability,recover,recover,36,// It might be worthwhile to try to recover by creating an; // appropriate declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:36,Safety,recover,recover,36,// It might be worthwhile to try to recover by creating an; // appropriate declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:247,Usability,simpl,simple,247,"// C++ [namespace.memdef]p3; // - If a friend declaration in a non-local class first declares a; // class or function, the friend class or function is a member; // of the innermost enclosing namespace.; // - The name of the friend is not found by simple name lookup; // until a matching declaration is provided in that namespace; // scope (either before or after the class declaration granting; // friendship).; // - If a friend function is called, its name may be found by the; // name lookup that considers functions from namespaces and; // classes associated with the types of the function arguments.; // - When looking for a prior declaration of a class or a function; // declared as a friend, scopes outside the innermost enclosing; // namespace scope are not considered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:177,Availability,recover,recover,177,// There are five cases here.; // - There's no scope specifier and we're in a local class. Only look; // for functions declared in the immediately-enclosing block scope.; // We recover from invalid scope qualifiers as if they just weren't there.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:177,Safety,recover,recover,177,// There are five cases here.; // - There's no scope specifier and we're in a local class. Only look; // for functions declared in the immediately-enclosing block scope.; // We recover from invalid scope qualifiers as if they just weren't there.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:125,Availability,error,error,125,"// This is ill-formed, but provide the context that we would have; // declared the function in, if we were permitted to, for error recovery.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:131,Availability,recover,recovery,131,"// This is ill-formed, but provide the context that we would have; // declared the function in, if we were permitted to, for error recovery.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:131,Safety,recover,recovery,131,"// This is ill-formed, but provide the context that we would have; // declared the function in, if we were permitted to, for error recovery.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:19,Integrability,depend,dependent,19,"// - There's a non-dependent scope specifier, in which case we; // compute it and do a previous lookup there for a function; // or function template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:9,Performance,perform,performed,9,"// If we performed typo correction, we might have added a scope specifier; // and changed the decl context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:201,Deployability,update,update,201,"// Add the function declaration to the appropriate lookup tables,; // adjusting the redeclarations list as necessary. We don't; // want to do this yet if the friending class is dependent.; //; // Also update the scope-based lookup if the target context's; // lookup context is in lexical scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:177,Integrability,depend,dependent,177,"// Add the function declaration to the appropriate lookup tables,; // adjusting the redeclarations list as necessary. We don't; // want to do this yet if the friending class is dependent.; //; // Also update the scope-based lookup if the target context's; // lookup context is in lexical scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:195,Availability,down,down,195,"// We can't look at FD->getPreviousDecl() because it may not have been set; // if we're in a dependent context. If the function is known to be a; // redeclaration, we will have narrowed Previous down to the right decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:93,Integrability,depend,dependent,93,"// We can't look at FD->getPreviousDecl() because it may not have been set; // if we're in a dependent context. If the function is known to be a; // redeclaration, we will have narrowed Previous down to the right decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:12,Availability,recover,recover,12,// We can't recover from this; the declaration might have already; // been used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:12,Safety,recover,recover,12,// We can't recover from this; the declaration might have already; // been used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:5,Integrability,depend,dependent,5,// A dependent function that doesn't locally look defaultable can; // still instantiate to a defaultable function if it's a constructor; // or assignment operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:52,Integrability,depend,dependent,52,// Defer checking functions that are defaulted in a dependent context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:86,Performance,perform,performed,86,"// If this member fn was defaulted on its first declaration, we will have; // already performed the checking in CheckCompletedCXXClass. Such a; // declaration doesn't trigger an implicit definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:120,Availability,error,error,120,"// If the calling conventions mismatch because the new function is static,; // suppress the calling convention mismatch error; the error about static; // function override (err_static_overrides_virtual from; // Sema::CheckFunctionDeclaration) is more clear.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:131,Availability,error,error,131,"// If the calling conventions mismatch because the new function is static,; // suppress the calling convention mismatch error; the error about static; // function override (err_static_overrides_virtual from; // Sema::CheckFunctionDeclaration) is more clear.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:251,Usability,clear,clear,251,"// If the calling conventions mismatch because the new function is static,; // suppress the calling convention mismatch error; the error about static; // function override (err_static_overrides_virtual from; // Sema::CheckFunctionDeclaration) is more clear.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:118,Availability,error,error,118,"// FIXME: this note won't trigger for delayed access control; // diagnostics, and it's impossible to get an undelayed error; // here from access control during the original parse because; // the ParsingDeclSpec/ParsingDeclarator are still in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:46,Security,access,access,46,"// FIXME: this note won't trigger for delayed access control; // diagnostics, and it's impossible to get an undelayed error; // here from access control during the original parse because; // the ParsingDeclSpec/ParsingDeclarator are still in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:138,Security,access,access,138,"// FIXME: this note won't trigger for delayed access control; // diagnostics, and it's impossible to get an undelayed error; // here from access control during the original parse because; // the ParsingDeclSpec/ParsingDeclarator are still in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:56,Modifiability,variab,variable,56,/// Determine whether the given declaration is a global variable or; /// static data member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:44,Availability,error,error,44,"// If there is no declaration, there was an error parsing it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:44,Availability,error,error,44,"// If there is no declaration, there was an error parsing it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:38,Performance,perform,perform,38,"// The Microsoft ABI requires that we perform the destructor body; // checks (i.e. operator delete() lookup) when the vtable is marked used, as; // the deleting destructor is emitted with the vtable, not with the; // destructor definition as in the Itanium ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:31,Integrability,rout,routine,31,/// SetIvarInitializers - This routine builds initialization ASTs for the; /// Objective-C implementation whose ivars need be initialized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:34,Security,access,accessible,34,// Be sure that the destructor is accessible and is marked as referenced.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:65,Integrability,depend,dependent,65,"// Target may not be determinable yet, for instance if this is a dependent; // call in an uninstantiated template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Safety,Avoid,Avoid,3,// Avoid dereferencing a null pointer here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Deployability,Update,Update,3,// Update the exception specification on the function type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:331,Availability,error,error,331,"/// Check whether the given method, which must be in the 'init'; /// family, is a valid member of that family.; ///; /// \param receiverTypeIfCall - if null, check this as if declaring it;; /// if non-null, check this as if making a call to it with the given; /// receiver type; ///; /// \return true to indicate that there was an error and appropriate; /// actions were taken",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:171,Integrability,protocol,protocols,171,// This castAs is safe: methods that don't return an object; // pointer won't be inferred as inits and will reject an explicit; // objc_method_family(init).; // We ignore protocols here. Should we? What about Class?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:18,Safety,safe,safe,18,// This castAs is safe: methods that don't return an object; // pointer won't be inferred as inits and will reject an explicit; // objc_method_family(init).; // We ignore protocols here. Should we? What about Class?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:27,Availability,error,error,27,// fall through: always an error,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:92,Integrability,interface,interface,92,// It's okay for the result type to still be a forward declaration; // if we're checking an interface declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:36,Integrability,protocol,protocol,36,"// If this method was declared in a protocol, we can't check; // anything unless we have a receiver type that's an interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:115,Integrability,interface,interface,115,"// If this method was declared in a protocol, we can't check; // anything unless we have a receiver type that's an interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:22,Availability,error,error,22,"// Otherwise, it's an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:63,Integrability,protocol,protocol,63,/// Produce additional diagnostics if a category conforms to a protocol that; /// defines a method taking a non-escaping parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:2,Integrability,Message,Message,2,/*Message=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:41,Usability,simpl,simply,41,"// If we don't have a valid method decl, simply return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:37,Integrability,rout,routine,37,"/// ActOnStartOfObjCMethodDef - This routine sets up parameters; invisible; /// and user declared, in the method definition's AST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:41,Usability,simpl,simply,41,"// If we don't have a valid method decl, simply return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:41,Deployability,release,release,41,"// In ARC, disallow definition of retain/release/autorelease/retainCount",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:141,Security,validat,validation,141,"// Callback to only accept typo corrections that are Objective-C classes.; // If an ObjCInterfaceDecl* is given to the constructor, then the validation; // function will reject corrections to that class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:12,Availability,avail,availability,12,// Diagnose availability in the context of the ObjC container.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:2,Safety,Avoid,AvoidPartialAvailabilityChecks,2,/*AvoidPartialAvailabilityChecks=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:25,Modifiability,inherit,inherit,25,// Diagnose classes that inherit from deprecated classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:41,Integrability,interface,interface,41,"// This handles the following case:; // @interface NewI @end; // typedef NewI DeprI __attribute__((deprecated(""blah""))); // @interface SI : DeprI /* warn here */ @end",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:125,Integrability,interface,interface,125,"// This handles the following case:; // @interface NewI @end; // typedef NewI DeprI __attribute__((deprecated(""blah""))); // @interface SI : DeprI /* warn here */ @end",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:73,Integrability,interface,interface,73,// This handles the following case:; //; // typedef int SuperClass;; // @interface MyClass : SuperClass {} @end; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:48,Deployability,update,update,48,// Create a new type location builder so we can update the type; // location information we have.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:96,Testability,assert,assert,96,"// If the type bound has qualifiers other than CVR, we need to strip; // them or we'll probably assert later when trying to apply new; // qualifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:67,Availability,error,error,67,"// If there was no explicit type bound (or we removed it due to an error),; // use 'id' instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:163,Modifiability,variab,variable,163,"// Diagnose redeclarations of type parameters.; // We do this now because Objective-C type parameters aren't pushed into; // scope until later (after the instance variable block), but we want the; // diagnostics to occur right after we parse the type parameter list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:145,Integrability,interface,interface,145,"// end anonymous namespace; /// Check consistency between two Objective-C type parameter lists, e.g.,; /// between a category/extension and an \@interface or between an \@class and an; /// \@interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:191,Integrability,interface,interface,191,"// end anonymous namespace; /// Check consistency between two Objective-C type parameter lists, e.g.,; /// between a category/extension and an \@interface or between an \@class and an; /// \@interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:29,Deployability,update,update,29,// Diagnose the conflict and update the second declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:168,Integrability,interface,interfaces,168,"// The new type parameter got the implicit bound of 'id'. That's okay for; // categories and extensions (overwrite it later), but not for forward; // declarations and @interfaces, because those must be standalone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:3,Deployability,Update,Update,3,// Update the new type parameter's bound to match the previous one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:42,Integrability,interface,interface,42,// Create a declaration to describe this @interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:12,Availability,avail,availability,12,// Diagnose availability in the context of the @interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:48,Integrability,interface,interface,48,// Diagnose availability in the context of the @interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:30,Integrability,protocol,protocols,30,// Check then save referenced protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:48,Integrability,protocol,protocol,48,/// ActOnTypedefedProtocols - this action finds protocol list as part of the; /// typedef'ed use for a qualified super class and adds them to the list; /// of the protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:163,Integrability,protocol,protocols,163,/// ActOnTypedefedProtocols - this action finds protocol list as part of the; /// typedef'ed use for a qualified super class and adds them to the list; /// of the protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:105,Integrability,protocol,protocol,105,// FIXME: Consider whether this should be an invalid loc since the loc; // is not actually pointing to a protocol name reference but to the; // typedef reference. Note that the base class name loc is also pointing; // at the typedef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:115,Availability,avail,available,115,"// Create a new protocol that is completely distinct from previous; // declarations, and do not make this protocol available for name lookup.; // That way, we'll end up completely ignoring the duplicate.; // FIXME: Can we turn this into an error?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:240,Availability,error,error,240,"// Create a new protocol that is completely distinct from previous; // declarations, and do not make this protocol available for name lookup.; // That way, we'll end up completely ignoring the duplicate.; // FIXME: Can we turn this into an error?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:16,Integrability,protocol,protocol,16,"// Create a new protocol that is completely distinct from previous; // declarations, and do not make this protocol available for name lookup.; // That way, we'll end up completely ignoring the duplicate.; // FIXME: Can we turn this into an error?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:106,Integrability,protocol,protocol,106,"// Create a new protocol that is completely distinct from previous; // declarations, and do not make this protocol available for name lookup.; // That way, we'll end up completely ignoring the duplicate.; // FIXME: Can we turn this into an error?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:22,Integrability,depend,dependencies,22,// Check for circular dependencies among protocol declarations. This can; // only happen if this protocol was forward-declared.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:41,Integrability,protocol,protocol,41,// Check for circular dependencies among protocol declarations. This can; // only happen if this protocol was forward-declared.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:97,Integrability,protocol,protocol,97,// Check for circular dependencies among protocol declarations. This can; // only happen if this protocol was forward-declared.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:31,Integrability,protocol,protocols,31,/// Check then save referenced protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:81,Availability,error,error,81,/// FindProtocolDeclaration - This routine looks up protocols and; /// issues an error if they are not declared. It returns list of; /// protocol declarations in its 'Protocols' argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:35,Integrability,rout,routine,35,/// FindProtocolDeclaration - This routine looks up protocols and; /// issues an error if they are not declared. It returns list of; /// protocol declarations in its 'Protocols' argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:52,Integrability,protocol,protocols,52,/// FindProtocolDeclaration - This routine looks up protocols and; /// issues an error if they are not declared. It returns list of; /// protocol declarations in its 'Protocols' argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:137,Integrability,protocol,protocol,137,/// FindProtocolDeclaration - This routine looks up protocols and; /// issues an error if they are not declared. It returns list of; /// protocol declarations in its 'Protocols' argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:167,Integrability,Protocol,Protocols,167,/// FindProtocolDeclaration - This routine looks up protocols and; /// issues an error if they are not declared. It returns list of; /// protocol declarations in its 'Protocols' argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:24,Integrability,protocol,protocol,24,"// If this is a forward protocol declaration, get its definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:108,Availability,avail,availability,108,"// For an objc container, delay protocol reference checking until after we; // can set the objc decl as the availability context, otherwise check now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:32,Integrability,protocol,protocol,32,"// For an objc container, delay protocol reference checking until after we; // can set the objc decl as the availability context, otherwise check now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:100,Availability,Recover,Recover,100,"// If this is a forward declaration and we are supposed to warn in this; // case, do it.; // FIXME: Recover nicely in the hidden case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:100,Safety,Recover,Recover,100,"// If this is a forward declaration and we are supposed to warn in this; // case, do it.; // FIXME: Recover nicely in the hidden case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:76,Integrability,protocol,protocols,76,// Callback to only accept typo corrections that are either; // Objective-C protocols or valid Objective-C type arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:28,Integrability,protocol,protocols,28,"// If we're allowed to find protocols and we have a protocol, accept it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:52,Integrability,protocol,protocol,52,"// If we're allowed to find protocols and we have a protocol, accept it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:135,Integrability,protocol,protocol,135,"// If we found a tag declaration outside of C++, skip it. This; // can happy because we look for any name when there is no; // bias to protocol or type names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:23,Deployability,update,updates,23,// Local function that updates the declaration specifiers with; // protocol information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:67,Integrability,protocol,protocol,67,// Local function that updates the declaration specifiers with; // protocol information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:40,Modifiability,parameteriz,parameterized,40,"// Determine whether the base type is a parameterized class, in; // which case we want to warn about typos such as; // ""NSArray<NSObject>"" (that should be NSArray<NSObject *>).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:108,Availability,avail,availability,108,"// For an objc container, delay protocol reference checking until after we; // can set the objc decl as the availability context, otherwise check now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:32,Integrability,protocol,protocol,32,"// For an objc container, delay protocol reference checking until after we; // can set the objc decl as the availability context, otherwise check now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:24,Integrability,protocol,protocol,24,"// If this is a forward protocol declaration, get its definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:100,Availability,Recover,Recover,100,"// If this is a forward declaration and we are supposed to warn in this; // case, do it.; // FIXME: Recover nicely in the hidden case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:100,Safety,Recover,Recover,100,"// If this is a forward declaration and we are supposed to warn in this; // case, do it.; // FIXME: Recover nicely in the hidden case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:14,Integrability,protocol,protocols,14,"// All of the protocols listed also have type names, and at least; // one is an Objective-C class name. Check whether all of the; // protocol conformances are declared by the base class itself, in; // which case we warn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:133,Integrability,protocol,protocol,133,"// All of the protocols listed also have type names, and at least; // one is an Objective-C class name. Check whether all of the; // protocol conformances are declared by the base class itself, in; // which case we warn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:48,Integrability,protocol,protocols,48,// Attempt to resolve all of the identifiers as protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:28,Integrability,protocol,protocols,28,"// If all of the names were protocols, these were protocol qualifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:50,Integrability,protocol,protocol,50,"// If all of the names were protocols, these were protocol qualifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:37,Usability,simpl,simply,37,// Form declaration specifiers. They simply refer to the type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:23,Deployability,update,updates,23,// Local function that updates the declaration specifiers with; // type argument information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:31,Integrability,protocol,protocols,31,// We did not resolve these as protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:3,Availability,Error,Error,3,"// Error recovery: some names weren't found, or we have a mix of; // type and protocol names. Go resolve all of the unresolved names; // and complain if we can't find a consistent answer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:9,Availability,recover,recovery,9,"// Error recovery: some names weren't found, or we have a mix of; // type and protocol names. Go resolve all of the unresolved names; // and complain if we can't find a consistent answer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:78,Integrability,protocol,protocol,78,"// Error recovery: some names weren't found, or we have a mix of; // type and protocol names. Go resolve all of the unresolved names; // and complain if we can't find a consistent answer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:9,Safety,recover,recovery,9,"// Error recovery: some names weren't found, or we have a mix of; // type and protocol names. Go resolve all of the unresolved names; // and complain if we can't find a consistent answer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:24,Integrability,protocol,protocol,24,// If we already have a protocol or type. Check whether it is the; // right thing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:54,Integrability,protocol,protocols,54,"// If we haven't figured out whether we want types or protocols; // yet, try to figure it out from this name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:33,Integrability,protocol,protocol,33,"// If this name refers to both a protocol and a type (e.g., \c; // NSObject), don't conclude anything yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:83,Integrability,protocol,protocols,83,"// Otherwise, let this name decide whether we'll be correcting; // toward types or protocols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:14,Integrability,protocol,protocols,14,"// If we want protocols and we have a protocol, there's nothing; // more to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:38,Integrability,protocol,protocol,38,"// If we want protocols and we have a protocol, there's nothing; // more to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:43,Integrability,protocol,protocols,43,// We have a conflict: some names refer to protocols and others; // refer to types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:3,Performance,Perform,Perform,3,// Perform typo correction on the name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:17,Integrability,protocol,protocol,17,// Did we find a protocol?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:43,Integrability,protocol,protocols,43,"// If all of the names were (corrected to) protocols, these were; // protocol qualifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:69,Integrability,protocol,protocol,69,"// If all of the names were (corrected to) protocols, these were; // protocol qualifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:28,Availability,error,error,28,// Possibly due to previous error,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:47,Integrability,protocol,protocol,47,/// ActOnForwardProtocolDeclaration - Handle \@protocol foo;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:141,Usability,clear,clear,141,// Create an invalid ObjCCategoryDecl to serve as context for; // the enclosing method declarations. We mark the decl invalid; // to make it clear that this isn't a valid AST.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:24,Integrability,interface,interface,24,/// Check for duplicate interface declaration for this category,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:77,Availability,avail,availability,77,// Process the attributes before looking at protocols to ensure that the; // availability attribute is attached to the category to provide availability; // checking for protocol uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:139,Availability,avail,availability,139,// Process the attributes before looking at protocols to ensure that the; // availability attribute is attached to the category to provide availability; // checking for protocol uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:44,Integrability,protocol,protocols,44,// Process the attributes before looking at protocols to ensure that the; // availability attribute is attached to the category to provide availability; // checking for protocol uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:169,Integrability,protocol,protocol,169,// Process the attributes before looking at protocols to ensure that the; // availability attribute is attached to the category to provide availability; // checking for protocol uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:3,Integrability,Protocol,Protocols,3,// Protocols in the class extension belong to the class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:39,Performance,Perform,Perform,39,/// ActOnStartCategoryImplementation - Perform semantic checks on the; /// category implementation declaration and build an ObjCCategoryImplDecl; /// object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:77,Deployability,install,install,77,// Category @implementation with no corresponding @interface.; // Create and install one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:51,Integrability,interface,interface,51,// Category @implementation with no corresponding @interface.; // Create and install one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:10,Integrability,interface,interface,10,"// If the interface has the objc_runtime_visible attribute, we; // cannot implement a category for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:31,Availability,error,error,31,// FIXME: This will produce an error if the definition of the interface has; // been imported from a module but is not visible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:62,Integrability,interface,interface,62,// FIXME: This will produce an error if the definition of the interface has; // been imported from a module but is not visible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:121,Availability,recover,recovery,121,"// Suggest the (potentially) correct interface name. Don't provide a; // code-modification hint or use the typo name for recovery, because; // this is just a warning. The program may actually be correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:37,Integrability,interface,interface,37,"// Suggest the (potentially) correct interface name. Don't provide a; // code-modification hint or use the typo name for recovery, because; // this is just a warning. The program may actually be correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:121,Safety,recover,recovery,121,"// Suggest the (potentially) correct interface name. Don't provide a; // code-modification hint or use the typo name for recovery, because; // this is just a warning. The program may actually be correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:2,Availability,Error,ErrorRecovery,2,/*ErrorRecovery*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:31,Integrability,interface,interface,31,// This implementation and its interface do not have the same; // super class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:87,Deployability,install,install,87,"// Legacy case of @implementation with no corresponding @interface.; // Build, chain & install the interface decl into the identifier.; // FIXME: Do we support attributes on the @implementation? If so we should; // copy them over.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:57,Integrability,interface,interface,57,"// Legacy case of @implementation with no corresponding @interface.; // Build, chain & install the interface decl into the identifier.; // FIXME: Do we support attributes on the @implementation? If so we should; // copy them over.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:99,Integrability,interface,interface,99,"// Legacy case of @implementation with no corresponding @interface.; // Build, chain & install the interface decl into the identifier.; // FIXME: Do we support attributes on the @implementation? If so we should; // copy them over.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:12,Integrability,interface,interface,12,"// Mark the interface as being completed, even if it was just as; // @class ....;; // declaration; the user cannot reopen it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:33,Integrability,interface,interface,33,/// Check case of non-existing \@interface decl.; /// (legacy objective-c \@implementation decl without an \@interface decl).; /// Add implementations's ivar to the synthesize class's ivar list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:109,Integrability,interface,interface,109,/// Check case of non-existing \@interface decl.; /// (legacy objective-c \@implementation decl without an \@interface decl).; /// Add implementations's ivar to the synthesize class's ivar list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:9,Integrability,interface,interface,9,// Check interface's Ivar list against those in the implementation.; // names and types must match.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:270,Integrability,protocol,protocols,270,"// FIXME: For now ignore 'IncompleteImpl'.; // Previously we grouped all unimplemented methods under a single; // warning, but some users strongly voiced that they would prefer; // separate warnings. We will give that approach a try, as that; // matches what we do with protocols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:1982,Availability,down,down-casting,1982," can; /// guarantee that anything that the user will do to an object of type A can; /// also be done to an object of type B. This is trivially true if the two; /// types are the same, or if B is a subclass of A. It becomes more complex; /// in cases where protocols are involved.; ///; /// Object types in Objective-C describe the minimum requirements for an; /// object, rather than providing a complete description of a type. For; /// example, if A is a subclass of B, then B* may refer to an instance of A.; /// The principle of substitutability means that we may use an instance of A; /// anywhere that we may use an instance of B - it will implement all of the; /// ivars of B and all of the methods of B.; ///; /// This substitutability is important when type checking methods, because; /// the implementation may have stricter type definitions than the interface.; /// The interface specifies minimum requirements, but the implementation may; /// have more accurate ones. For example, a method may privately accept; /// instances of B, but only publish that it accepts instances of A. Any; /// object passed to it will be type checked against B, and so will implicitly; /// by a valid A*. Similarly, a method may return a subclass of the class that; /// it is declared as returning.; ///; /// This is most important when considering subclassing. A method in a; /// subclass must accept any object as an argument that its superclass's; /// implementation accepts. It may, however, accept a more general type; /// without breaking substitutability (i.e. you can still use the subclass; /// anywhere that you can use the superclass, but not vice versa). The; /// converse requirement applies to return types: the return type for a; /// subclass method must be a valid object of the kind that the superclass; /// advertises, but it may be specified more accurately. This avoids the need; /// for explicit down-casting by callers.; ///; /// Note: This is a stricter requirement than for assignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:330,Integrability,protocol,protocols,330,"/// Determines if type B can be substituted for type A. Returns true if we can; /// guarantee that anything that the user will do to an object of type A can; /// also be done to an object of type B. This is trivially true if the two; /// types are the same, or if B is a subclass of A. It becomes more complex; /// in cases where protocols are involved.; ///; /// Object types in Objective-C describe the minimum requirements for an; /// object, rather than providing a complete description of a type. For; /// example, if A is a subclass of B, then B* may refer to an instance of A.; /// The principle of substitutability means that we may use an instance of A; /// anywhere that we may use an instance of B - it will implement all of the; /// ivars of B and all of the methods of B.; ///; /// This substitutability is important when type checking methods, because; /// the implementation may have stricter type definitions than the interface.; /// The interface specifies minimum requirements, but the implementation may; /// have more accurate ones. For example, a method may privately accept; /// instances of B, but only publish that it accepts instances of A. Any; /// object passed to it will be type checked against B, and so will implicitly; /// by a valid A*. Similarly, a method may return a subclass of the class that; /// it is declared as returning.; ///; /// This is most important when considering subclassing. A method in a; /// subclass must accept any object as an argument that its superclass's; /// implementation accepts. It may, however, accept a more general type; /// without breaking substitutability (i.e. you can still use the subclass; /// anywhere that you can use the superclass, but not vice versa). The; /// converse requirement applies to return types: the return type for a; /// subclass method must be a valid object of the kind that the superclass; /// advertises, but it may be specified more accurately. This avoids the need; /// for explicit down-casting by cal",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:934,Integrability,interface,interface,934,"/// Determines if type B can be substituted for type A. Returns true if we can; /// guarantee that anything that the user will do to an object of type A can; /// also be done to an object of type B. This is trivially true if the two; /// types are the same, or if B is a subclass of A. It becomes more complex; /// in cases where protocols are involved.; ///; /// Object types in Objective-C describe the minimum requirements for an; /// object, rather than providing a complete description of a type. For; /// example, if A is a subclass of B, then B* may refer to an instance of A.; /// The principle of substitutability means that we may use an instance of A; /// anywhere that we may use an instance of B - it will implement all of the; /// ivars of B and all of the methods of B.; ///; /// This substitutability is important when type checking methods, because; /// the implementation may have stricter type definitions than the interface.; /// The interface specifies minimum requirements, but the implementation may; /// have more accurate ones. For example, a method may privately accept; /// instances of B, but only publish that it accepts instances of A. Any; /// object passed to it will be type checked against B, and so will implicitly; /// by a valid A*. Similarly, a method may return a subclass of the class that; /// it is declared as returning.; ///; /// This is most important when considering subclassing. A method in a; /// subclass must accept any object as an argument that its superclass's; /// implementation accepts. It may, however, accept a more general type; /// without breaking substitutability (i.e. you can still use the subclass; /// anywhere that you can use the superclass, but not vice versa). The; /// converse requirement applies to return types: the return type for a; /// subclass method must be a valid object of the kind that the superclass; /// advertises, but it may be specified more accurately. This avoids the need; /// for explicit down-casting by cal",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:954,Integrability,interface,interface,954,"/// Determines if type B can be substituted for type A. Returns true if we can; /// guarantee that anything that the user will do to an object of type A can; /// also be done to an object of type B. This is trivially true if the two; /// types are the same, or if B is a subclass of A. It becomes more complex; /// in cases where protocols are involved.; ///; /// Object types in Objective-C describe the minimum requirements for an; /// object, rather than providing a complete description of a type. For; /// example, if A is a subclass of B, then B* may refer to an instance of A.; /// The principle of substitutability means that we may use an instance of A; /// anywhere that we may use an instance of B - it will implement all of the; /// ivars of B and all of the methods of B.; ///; /// This substitutability is important when type checking methods, because; /// the implementation may have stricter type definitions than the interface.; /// The interface specifies minimum requirements, but the implementation may; /// have more accurate ones. For example, a method may privately accept; /// instances of B, but only publish that it accepts instances of A. Any; /// object passed to it will be type checked against B, and so will implicitly; /// by a valid A*. Similarly, a method may return a subclass of the class that; /// it is declared as returning.; ///; /// This is most important when considering subclassing. A method in a; /// subclass must accept any object as an argument that its superclass's; /// implementation accepts. It may, however, accept a more general type; /// without breaking substitutability (i.e. you can still use the subclass; /// anywhere that you can use the superclass, but not vice versa). The; /// converse requirement applies to return types: the return type for a; /// subclass method must be a valid object of the kind that the superclass; /// advertises, but it may be specified more accurately. This avoids the need; /// for explicit down-casting by cal",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:1948,Safety,avoid,avoids,1948," can; /// guarantee that anything that the user will do to an object of type A can; /// also be done to an object of type B. This is trivially true if the two; /// types are the same, or if B is a subclass of A. It becomes more complex; /// in cases where protocols are involved.; ///; /// Object types in Objective-C describe the minimum requirements for an; /// object, rather than providing a complete description of a type. For; /// example, if A is a subclass of B, then B* may refer to an instance of A.; /// The principle of substitutability means that we may use an instance of A; /// anywhere that we may use an instance of B - it will implement all of the; /// ivars of B and all of the methods of B.; ///; /// This substitutability is important when type checking methods, because; /// the implementation may have stricter type definitions than the interface.; /// The interface specifies minimum requirements, but the implementation may; /// have more accurate ones. For example, a method may privately accept; /// instances of B, but only publish that it accepts instances of A. Any; /// object passed to it will be type checked against B, and so will implicitly; /// by a valid A*. Similarly, a method may return a subclass of the class that; /// it is declared as returning.; ///; /// This is most important when considering subclassing. A method in a; /// subclass must accept any object as an argument that its superclass's; /// implementation accepts. It may, however, accept a more general type; /// without breaking substitutability (i.e. you can still use the subclass; /// anywhere that you can use the superclass, but not vice versa). The; /// converse requirement applies to return types: the return type for a; /// subclass method must be a valid object of the kind that the superclass; /// advertises, but it may be specified more accurately. This avoids the need; /// for explicit down-casting by callers.; ///; /// Note: This is a stricter requirement than for assignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:12,Integrability,protocol,protocol-unqualified,12,// Reject a protocol-unqualified id.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:99,Integrability,protocol,protocols,99,"// If B is a qualified id, then A must also be a qualified id and it must; // implement all of the protocols in B. It may not be a qualified class.; // For example, MyClass<A> can be assigned to id<A>, but MyClass<A> is a; // stricter definition so it is not substitutable for id<A>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:110,Availability,error,error,110,"/// In ARC, check whether the conventional meanings of the two methods; /// match. If they don't, it's a hard error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:33,Integrability,rout,routine,33,/// WarnExactTypedMethods - This routine issues a warning if method; /// implementation declaration matches exactly that of its declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:28,Integrability,protocol,protocol,28,// don't issue warning when protocol method is optional because primary; // class is not required to implement it and it is safe for protocol; // to implement it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:133,Integrability,protocol,protocol,133,// don't issue warning when protocol method is optional because primary; // class is not required to implement it and it is safe for protocol; // to implement it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:124,Safety,safe,safe,124,// don't issue warning when protocol method is optional because primary; // class is not required to implement it and it is safe for protocol; // to implement it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:173,Integrability,protocol,protocol,173,/// FIXME: Type hierarchies in Objective-C can be deep. We could most likely; /// improve the efficiency of selector lookups and type checking by associating; /// with each protocol / interface / category the flattened instance tables. If; /// we used an immutable set to keep the table then it wouldn't add significant; /// memory cost and it would be handy for lookups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:184,Integrability,interface,interface,184,/// FIXME: Type hierarchies in Objective-C can be deep. We could most likely; /// improve the efficiency of selector lookups and type checking by associating; /// with each protocol / interface / category the flattened instance tables. If; /// we used an immutable set to keep the table then it wouldn't add significant; /// memory cost and it would be handy for lookups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:51,Integrability,protocol,protocols,51,/// Recursively populates a set with all conformed protocols in a class; /// hierarchy that have the 'objc_protocol_requires_explicit_implementation'; /// attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:35,Integrability,rout,routine,35,"/// CheckProtocolMethodDefs - This routine checks unimplemented methods; /// Declared in protocol, and those referenced by it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:89,Integrability,protocol,protocol,89,"/// CheckProtocolMethodDefs - This routine checks unimplemented methods; /// Declared in protocol, and those referenced by it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:11,Integrability,protocol,protocol,11,"// If this protocol is marked 'objc_protocol_requires_explicit_implementation'; // then we should check if any class in the super class hierarchy also; // conforms to this protocol, either directly or via protocol inheritance.; // If so, we can skip checking this protocol completely because we; // know that a parent class already satisfies this protocol.; //; // Note: we could generalize this logic for all protocols, and merely; // add the limit on looking at the super class chain for just; // specially marked protocols. This may be a good optimization. This; // change is restricted to 'objc_protocol_requires_explicit_implementation'; // protocols for now for controlled evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:172,Integrability,protocol,protocol,172,"// If this protocol is marked 'objc_protocol_requires_explicit_implementation'; // then we should check if any class in the super class hierarchy also; // conforms to this protocol, either directly or via protocol inheritance.; // If so, we can skip checking this protocol completely because we; // know that a parent class already satisfies this protocol.; //; // Note: we could generalize this logic for all protocols, and merely; // add the limit on looking at the super class chain for just; // specially marked protocols. This may be a good optimization. This; // change is restricted to 'objc_protocol_requires_explicit_implementation'; // protocols for now for controlled evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:205,Integrability,protocol,protocol,205,"// If this protocol is marked 'objc_protocol_requires_explicit_implementation'; // then we should check if any class in the super class hierarchy also; // conforms to this protocol, either directly or via protocol inheritance.; // If so, we can skip checking this protocol completely because we; // know that a parent class already satisfies this protocol.; //; // Note: we could generalize this logic for all protocols, and merely; // add the limit on looking at the super class chain for just; // specially marked protocols. This may be a good optimization. This; // change is restricted to 'objc_protocol_requires_explicit_implementation'; // protocols for now for controlled evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:264,Integrability,protocol,protocol,264,"// If this protocol is marked 'objc_protocol_requires_explicit_implementation'; // then we should check if any class in the super class hierarchy also; // conforms to this protocol, either directly or via protocol inheritance.; // If so, we can skip checking this protocol completely because we; // know that a parent class already satisfies this protocol.; //; // Note: we could generalize this logic for all protocols, and merely; // add the limit on looking at the super class chain for just; // specially marked protocols. This may be a good optimization. This; // change is restricted to 'objc_protocol_requires_explicit_implementation'; // protocols for now for controlled evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:347,Integrability,protocol,protocol,347,"// If this protocol is marked 'objc_protocol_requires_explicit_implementation'; // then we should check if any class in the super class hierarchy also; // conforms to this protocol, either directly or via protocol inheritance.; // If so, we can skip checking this protocol completely because we; // know that a parent class already satisfies this protocol.; //; // Note: we could generalize this logic for all protocols, and merely; // add the limit on looking at the super class chain for just; // specially marked protocols. This may be a good optimization. This; // change is restricted to 'objc_protocol_requires_explicit_implementation'; // protocols for now for controlled evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:410,Integrability,protocol,protocols,410,"// If this protocol is marked 'objc_protocol_requires_explicit_implementation'; // then we should check if any class in the super class hierarchy also; // conforms to this protocol, either directly or via protocol inheritance.; // If so, we can skip checking this protocol completely because we; // know that a parent class already satisfies this protocol.; //; // Note: we could generalize this logic for all protocols, and merely; // add the limit on looking at the super class chain for just; // specially marked protocols. This may be a good optimization. This; // change is restricted to 'objc_protocol_requires_explicit_implementation'; // protocols for now for controlled evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:516,Integrability,protocol,protocols,516,"// If this protocol is marked 'objc_protocol_requires_explicit_implementation'; // then we should check if any class in the super class hierarchy also; // conforms to this protocol, either directly or via protocol inheritance.; // If so, we can skip checking this protocol completely because we; // know that a parent class already satisfies this protocol.; //; // Note: we could generalize this logic for all protocols, and merely; // add the limit on looking at the super class chain for just; // specially marked protocols. This may be a good optimization. This; // change is restricted to 'objc_protocol_requires_explicit_implementation'; // protocols for now for controlled evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:646,Integrability,protocol,protocols,646,"// If this protocol is marked 'objc_protocol_requires_explicit_implementation'; // then we should check if any class in the super class hierarchy also; // conforms to this protocol, either directly or via protocol inheritance.; // If so, we can skip checking this protocol completely because we; // know that a parent class already satisfies this protocol.; //; // Note: we could generalize this logic for all protocols, and merely; // add the limit on looking at the super class chain for just; // specially marked protocols. This may be a good optimization. This; // change is restricted to 'objc_protocol_requires_explicit_implementation'; // protocols for now for controlled evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:214,Modifiability,inherit,inheritance,214,"// If this protocol is marked 'objc_protocol_requires_explicit_implementation'; // then we should check if any class in the super class hierarchy also; // conforms to this protocol, either directly or via protocol inheritance.; // If so, we can skip checking this protocol completely because we; // know that a parent class already satisfies this protocol.; //; // Note: we could generalize this logic for all protocols, and merely; // add the limit on looking at the super class chain for just; // specially marked protocols. This may be a good optimization. This; // change is restricted to 'objc_protocol_requires_explicit_implementation'; // protocols for now for controlled evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:546,Performance,optimiz,optimization,546,"// If this protocol is marked 'objc_protocol_requires_explicit_implementation'; // then we should check if any class in the super class hierarchy also; // conforms to this protocol, either directly or via protocol inheritance.; // If so, we can skip checking this protocol completely because we; // know that a parent class already satisfies this protocol.; //; // Note: we could generalize this logic for all protocols, and merely; // add the limit on looking at the super class chain for just; // specially marked protocols. This may be a good optimization. This; // change is restricted to 'objc_protocol_requires_explicit_implementation'; // protocols for now for controlled evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:396,Testability,log,logic,396,"// If this protocol is marked 'objc_protocol_requires_explicit_implementation'; // then we should check if any class in the super class hierarchy also; // conforms to this protocol, either directly or via protocol inheritance.; // If so, we can skip checking this protocol completely because we; // know that a parent class already satisfies this protocol.; //; // Note: we could generalize this logic for all protocols, and merely; // add the limit on looking at the super class chain for just; // specially marked protocols. This may be a good optimization. This; // change is restricted to 'objc_protocol_requires_explicit_implementation'; // protocols for now for controlled evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:37,Integrability,protocol,protocol,37,"// If no super class conforms to the protocol, we should not search; // for methods in the super class to implicitly satisfy the protocol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:129,Integrability,protocol,protocol,129,"// If no super class conforms to the protocol, we should not search; // for methods in the super class to implicitly satisfy the protocol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:24,Integrability,protocol,protocol,24,"// If this is a forward protocol declaration, get its definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:136,Integrability,protocol,protocol,136,"// If a method lookup fails locally we still need to look and see if; // the method was implemented by a base class or an inherited; // protocol. This lookup is slow, but occurs rarely in correct code; // and otherwise would terminate in a warning.; // check unimplemented instance methods.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:122,Modifiability,inherit,inherited,122,"// If a method lookup fails locally we still need to look and see if; // the method was implemented by a base class or an inherited; // protocol. This lookup is slow, but occurs rarely in correct code; // and otherwise would terminate in a warning.; // check unimplemented instance methods.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:148,Integrability,protocol,protocols,148,"// If a method is not implemented in the category implementation but; // has been declared in its primary class, superclass,; // or in one of their protocols, no need to issue the warning.; // This is because method will be implemented in the primary class; // or one of its super class implementation.; // Ugly, but necessary. Method declared in protocol might have; // have been synthesized due to a property declared in the class which; // uses the protocol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:347,Integrability,protocol,protocol,347,"// If a method is not implemented in the category implementation but; // has been declared in its primary class, superclass,; // or in one of their protocols, no need to issue the warning.; // This is because method will be implemented in the primary class; // or one of its super class implementation.; // Ugly, but necessary. Method declared in protocol might have; // have been synthesized due to a property declared in the class which; // uses the protocol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:452,Integrability,protocol,protocol,452,"// If a method is not implemented in the category implementation but; // has been declared in its primary class, superclass,; // or in one of their protocols, no need to issue the warning.; // This is because method will be implemented in the primary class; // or one of its super class implementation.; // Ugly, but necessary. Method declared in protocol might have; // have been synthesized due to a property declared in the class which; // uses the protocol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:17,Integrability,protocol,protocols,17,"// Check on this protocols's referenced protocols, recursively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:40,Integrability,protocol,protocols,40,"// Check on this protocols's referenced protocols, recursively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:59,Integrability,interface,interface,59,/// MatchAllMethodDeclarations - Check methods declared in interface; /// or protocol against those declared in their implementations.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:77,Integrability,protocol,protocol,77,/// MatchAllMethodDeclarations - Check methods declared in interface; /// or protocol against those declared in their implementations.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:46,Integrability,interface,interface,46,"// Check and see if instance methods in class interface have been; // implemented in the implementation class. If so, their types match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:17,Security,access,accessor,17,// Skip property accessor function stubs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:35,Testability,stub,stubs,35,// Skip property accessor function stubs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:43,Integrability,interface,interface,43,"// Check and see if class methods in class interface have been; // implemented in the implementation class. If so, their types match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:17,Security,access,accessor,17,// Skip property accessor function stubs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:35,Testability,stub,stubs,35,// Skip property accessor function stubs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:39,Integrability,protocol,protocols,39,"// Also, check for methods declared in protocols inherited by; // this protocol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:71,Integrability,protocol,protocol,71,"// Also, check for methods declared in protocols inherited by; // this protocol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:49,Modifiability,inherit,inherited,49,"// Also, check for methods declared in protocols inherited by; // this protocol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:57,Integrability,protocol,protocol,57,// Check for any implementation of a methods declared in protocol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:46,Integrability,interface,interface,46,// Check and see if instance methods in class interface have been; // implemented in the implementation class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:47,Integrability,interface,interface,47,// Check and see if properties declared in the interface have either 1); // an implementation or 2) there is a @synthesize/@dynamic implementation; // of the property in the @implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:58,Integrability,protocol,protocol,58,// Check for type conflict of methods declared in a class/protocol and; // its implementation; if any.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:13,Integrability,protocol,protocol,13,// Check the protocol list for unimplemented methods in the @implementation; // class.; // Check and see if class methods in class interface have been; // implemented in the implementation class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:131,Integrability,interface,interface,131,// Check the protocol list for unimplemented methods in the @implementation; // class.; // Check and see if class methods in class interface have been; // implemented in the implementation class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:52,Integrability,protocol,protocols,52,"// For extended class, unimplemented methods in its protocols will; // be reported in the primary class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:7,Modifiability,extend,extended,7,"// For extended class, unimplemented methods in its protocols will; // be reported in the primary class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:8,Integrability,interface,interface,8,// The @interface does not have type parameters. Complain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:68,Security,validat,validate,68,"// Otherwise, use this absurdly complicated algorithm to try to; // validate the basic, low-level compatibility of the two types.; // As a minimum, require the sizes and alignments to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:33,Integrability,depend,dependent,33,// Consider all the kinds of non-dependent canonical types:; // - functions and arrays aren't possible as return and parameter types; // - vector types of equal size can be arbitrarily mixed,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:140,Integrability,protocol,protocol,140,"/// MatchTwoMethodDeclarations - Checks that two methods have matching type and; /// returns true, or false, accordingly.; /// TODO: Handle protocol list; such as id<p1,p2> in type comparisons",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:31,Integrability,protocol,protocol,31,"// If this method belongs to a protocol but the method in list does not, or; // vice versa, we say the context is not the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:297,Availability,avail,availability,297,"// Looking for method with a type bound requires the correct context exists.; // We need to insert a method into the list if the context is different.; // If the method's declaration matches the list; // a> the method belongs to a different context: we need to insert it, in; // order to emit the availability message, we need to prioritize over; // availability among the methods with the same declaration.; // b> the method belongs to the same context: there is no need to insert a; // new entry.; // If the method's declaration does not match the list, we insert it to the; // end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:350,Availability,avail,availability,350,"// Looking for method with a type bound requires the correct context exists.; // We need to insert a method into the list if the context is different.; // If the method's declaration matches the list; // a> the method belongs to a different context: we need to insert it, in; // order to emit the availability message, we need to prioritize over; // availability among the methods with the same declaration.; // b> the method belongs to the same context: there is no need to insert a; // new entry.; // If the method's declaration does not match the list, we insert it to the; // end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:310,Integrability,message,message,310,"// Looking for method with a type bound requires the correct context exists.; // We need to insert a method into the list if the context is different.; // If the method's declaration matches the list; // a> the method belongs to a different context: we need to insert it, in; // order to emit the availability message, we need to prioritize over; // availability among the methods with the same declaration.; // b> the method belongs to the same context: there is no need to insert a; // new entry.; // If the method's declaration does not match the list, we insert it to the; // end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:33,Integrability,interface,interface,33,"// Objective-C doesn't allow an @interface for a class after its; // @implementation. So if Method is not defined and there already is; // an entry for this type signature, Method has to be for a different; // class than PrevObjCMethod.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:20,Usability,clear,clear,20,// FIXME: should we clear the other bits in ListWithSameDeclaration?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:204,Availability,error,errors,204,"/// Determines if this is an ""acceptable"" loose mismatch in the global; /// method pool. This exists mostly as a hack to get around certain; /// global mismatches which we can't afford to make warnings / errors.; /// Really, what we want is a way to take a method out of the global; /// method pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:36,Integrability,protocol,protocol,36,"// Check if the Method belongs to a protocol. We should allow any method; // defined in any protocol, because any subclass could adopt the protocol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:92,Integrability,protocol,protocol,92,"// Check if the Method belongs to a protocol. We should allow any method; // defined in any protocol, because any subclass could adopt the protocol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:139,Integrability,protocol,protocol,139,"// Check if the Method belongs to a protocol. We should allow any method; // defined in any protocol, because any subclass could adopt the protocol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:3,Testability,Test,Test,3,// Test for no method in the pool which should not trigger any warning by; // caller.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:174,Availability,error,errors,174,"// If we didn't see any strict differences, we won't see any loose; // differences. In ARC, however, we also need to check for loose; // mismatches, because most of them are errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:29,Modifiability,flexible,flexible,29,/// Diagnose attempts to use flexible array member with retainable object type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:38,Integrability,interface,interface,38,// Check if variable sized ivar is in interface and visible to subclasses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:12,Modifiability,variab,variable,12,// Check if variable sized ivar is in interface and visible to subclasses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:29,Integrability,interface,interface,29,// Subsequent checks require interface decl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:12,Modifiability,variab,variable,12,// Check if variable sized ivar is followed by another ivar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:44,Modifiability,variab,variable,44,// Check if ObjC container adds ivars after variable sized ivar in superclass.; // Perform the check only if OCD is the first container to declare ivars to; // avoid multiple warnings for the same ivar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:83,Performance,Perform,Perform,83,// Check if ObjC container adds ivars after variable sized ivar in superclass.; // Perform the check only if OCD is the first container to declare ivars to; // avoid multiple warnings for the same ivar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:160,Safety,avoid,avoid,160,// Check if ObjC container adds ivars after variable sized ivar in superclass.; // Perform the check only if OCD is the first container to declare ivars to; // avoid multiple warnings for the same ivar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:17,Integrability,protocol,protocols,17,"// Check on this protocols's referenced protocols, recursively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:40,Integrability,protocol,protocols,40,"// Check on this protocols's referenced protocols, recursively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:20,Security,access,accessor,20,// Make synthesized accessor stub functions visible.; // ActOnPropertyImplDecl() creates them as not visible in case; // they are overridden by an explicit method that is encountered; // later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:29,Testability,stub,stub,29,// Make synthesized accessor stub functions visible.; // ActOnPropertyImplDecl() creates them as not visible in case; // they are overridden by an explicit method that is encountered; // later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:41,Integrability,message,messages,41,"/// The following allows us to typecheck messages to ""id"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:26,Modifiability,extend,extend,26,"// Categories are used to extend the class by declaring new methods.; // By the same token, they are also used to add new properties. No; // need to compare the added property to those in the class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:6,Integrability,interface,interface,6,// An interface can subclass another interface with a; // objc_subclassing_restricted attribute when it has that attribute as; // well (because of interfaces imported from Swift). Therefore we have; // to check if we can subclass in the implementation as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:37,Integrability,interface,interface,37,// An interface can subclass another interface with a; // objc_subclassing_restricted attribute when it has that attribute as; // well (because of interfaces imported from Swift). Therefore we have; // to check if we can subclass in the implementation as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:147,Integrability,interface,interfaces,147,// An interface can subclass another interface with a; // objc_subclassing_restricted attribute when it has that attribute as; // well (because of interfaces imported from Swift). Therefore we have; // to check if we can subclass in the implementation as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:17,Integrability,interface,interface,17,// Find category interface decl and then check that all methods declared; // in this interface are implemented in the category @implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:85,Integrability,interface,interface,85,// Find category interface decl and then check that all methods declared; // in this interface are implemented in the category @implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:32,Integrability,rout,routine,32,/// CvtQTToAstBitMask - utility routine to produce an AST bitmask for; /// objective-c's type qualifier from the parser version of the same info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:28,Modifiability,inherit,inherits,28,"// If an Objective-C method inherits its related result type, then its; // declared result type must be compatible with its own class type. The; // declared result type is compatible if:",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:58,Integrability,protocol,protocol,58,// Any Objective-C pointer type might be acceptable for a protocol; // method; we just don't know.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:133,Integrability,interface,interface,133,"// Prevent the search from reaching this container again. This is; // important with categories, which override methods from the; // interface and each other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:17,Integrability,protocol,protocol,17,"// A method in a protocol declaration overrides declarations from; // referenced (""parent"") protocols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:92,Integrability,protocol,protocols,92,"// A method in a protocol declaration overrides declarations from; // referenced (""parent"") protocols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:94,Integrability,protocol,protocols,94,// A method in a category declaration overrides declarations from; // the main class and from protocols the category references.; // The main class is handled in the constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:20,Integrability,protocol,protocols,20,// - any referenced protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:80,Integrability,interface,interface,80,// A method in a class implementation overrides declarations from; // the class interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:55,Availability,down,down,55,// Search for overridden methods and merge information down from them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:86,Integrability,protocol,protocols,86,"// Keep track if the method overrides any method in the class's base classes,; // its protocols, or its categories' protocols; we will keep that info; // in the ObjCMethodDecl.; // For this info, a method in an implementation is not considered as; // overriding the same method in the interface or its categories.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:116,Integrability,protocol,protocols,116,"// Keep track if the method overrides any method in the class's base classes,; // its protocols, or its categories' protocols; we will keep that info; // in the ObjCMethodDecl.; // For this info, a method in an implementation is not considered as; // overriding the same method in the interface or its categories.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:285,Integrability,interface,interface,285,"// Keep track if the method overrides any method in the class's base classes,; // its protocols, or its categories' protocols; we will keep that info; // in the ObjCMethodDecl.; // For this info, a method in an implementation is not considered as; // overriding the same method in the interface or its categories.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:73,Integrability,interface,interface,73,"// OverrideSearch will return as ""overridden"" the same method in the; // interface. For hasOverriddenMethodsInBaseOrProtocol, we need to; // check whether a category of a base class introduced a method with the; // same selector, after the interface method declaration.; // To avoid unnecessary lookups in the majority of cases, we use the; // extra info bits in GlobalMethodPool to check whether there were any; // category methods with this selector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:240,Integrability,interface,interface,240,"// OverrideSearch will return as ""overridden"" the same method in the; // interface. For hasOverriddenMethodsInBaseOrProtocol, we need to; // check whether a category of a base class introduced a method with the; // same selector, after the interface method declaration.; // To avoid unnecessary lookups in the majority of cases, we use the; // extra info bits in GlobalMethodPool to check whether there were any; // category methods with this selector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:277,Safety,avoid,avoid,277,"// OverrideSearch will return as ""overridden"" the same method in the; // interface. For hasOverriddenMethodsInBaseOrProtocol, we need to; // check whether a category of a base class introduced a method with the; // same selector, after the interface method declaration.; // To avoid unnecessary lookups in the majority of cases, we use the; // extra info bits in GlobalMethodPool to check whether there were any; // category methods with this selector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:13,Availability,down,down,13,// Propagate down the 'related result type' bit from overridden methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:30,Safety,detect,detected,30,// Conflicting properties are detected elsewhere.; // Check for overriding methods,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:91,Deployability,update,updated,91,"/// Merge type nullability from for a redeclaration of the same entity,; /// producing the updated type of the redeclared entity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:64,Integrability,interface,interface,64,/// Merge information from the declaration of a method in the \@interface; /// (or a category/extension) into the corresponding method in the; /// @implementation (for a class or category).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:219,Integrability,protocol,protocols,219,"// Look for any other declaration of this method anywhere we can see in this; // compilation unit.; //; // We do not use IDecl->lookupMethod() because we have specific needs:; //; // - we absolutely do not need to walk protocols, because; // diag::err_objc_direct_on_protocol has already been emitted; // during parsing if there's a conflict,; //; // - when we do not find a match in a given @interface container,; // we need to attempt looking it up in the @implementation block if the; // translation unit sees it to find more clashes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:393,Integrability,interface,interface,393,"// Look for any other declaration of this method anywhere we can see in this; // compilation unit.; //; // We do not use IDecl->lookupMethod() because we have specific needs:; //; // - we absolutely do not need to walk protocols, because; // diag::err_objc_direct_on_protocol has already been emitted; // during parsing if there's a conflict,; //; // - when we do not find a match in a given @interface container,; // we need to attempt looking it up in the @implementation block if the; // translation unit sees it to find more clashes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:3,Performance,Perform,Perform,3,"// Perform the default array/function conversions (C99 6.7.5.3p[7,8]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:174,Testability,stub,stub,174,"// If this method overrides a previous @synthesize declaration,; // register it with the property. Linear search through all; // properties here, because the autosynthesized stub hasn't been; // made visible yet, so it can be overridden by a later; // user-specified implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:51,Modifiability,inherit,inherits,51,"// A method is either tagged direct explicitly, or inherits it from its; // canonical declaration.; //; // We have to do the merge upfront and not in mergeInterfaceMethodToImpl(); // because IDecl->lookupMethod() returns more possible matches than just; // the canonical declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:31,Integrability,interface,interface,31,// Merge information from the @interface declaration into the; // @implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:146,Integrability,interface,interface,146,"// The Idecl->lookupMethod() above will find declarations for ObjCMethod; // in one of these places:; //; // (1) the canonical declaration in an @interface container paired; // with the ImplDecl,; // (2) non canonical declarations in @interface not paired with the; // ImplDecl for the same Class,; // (3) any superclass container.; //; // Direct methods only allow for canonical declarations in the matching; // container (case 1).; //; // Direct methods overriding a superclass declaration (case 3) is; // handled during overrides checks in CheckObjCMethodOverrides().; //; // We deal with same-class container mismatches (Case 2) here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:235,Integrability,interface,interface,235,"// The Idecl->lookupMethod() above will find declarations for ObjCMethod; // in one of these places:; //; // (1) the canonical declaration in an @interface container paired; // with the ImplDecl,; // (2) non canonical declarations in @interface not paired with the; // ImplDecl for the same Class,; // (3) any superclass container.; //; // Direct methods only allow for canonical declarations in the matching; // container (case 1).; //; // Direct methods overriding a superclass declaration (case 3) is; // handled during overrides checks in CheckObjCMethodOverrides().; //; // We deal with same-class container mismatches (Case 2) here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:34,Integrability,protocol,protocol,34,// Warn if a method declared in a protocol to which a category or; // extension conforms is non-escaping and the implementation's method is; // escaping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:53,Integrability,interface,interface,53,"// For valid code, we should always know the primary interface; // declaration by now, however for invalid code we'll keep parsing; // but we won't find the primary interface and IDecl will be nil.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:165,Integrability,interface,interface,165,"// For valid code, we should always know the primary interface; // declaration by now, however for invalid code we'll keep parsing; // but we won't find the primary interface and IDecl will be nil.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:29,Availability,avail,availability,29,"// + load method cannot have availability attributes. It get called on; // startup, so it has to have the availability of the deployment target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:106,Availability,avail,availability,106,"// + load method cannot have availability attributes. It get called on; // startup, so it has to have the availability of the deployment target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:126,Deployability,deploy,deployment,126,"// + load method cannot have availability attributes. It get called on; // startup, so it has to have the availability of the deployment target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:5,Performance,load,load,5,"// + load method cannot have availability attributes. It get called on; // startup, so it has to have the availability of the deployment target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:24,Availability,error,error,24,// Following is also an error. But it is caused by a missing @end; // and diagnostic is issued elsewhere.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:140,Availability,error,error,140,"// If we switched context to translation unit while we are still lexically in; // an objc container, it means the parser missed emitting an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:94,Modifiability,variab,variables,94,/// Called whenever \@defs(ClassName) is encountered in the source. Inserts the; /// instance variables of ClassName into Decls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:24,Modifiability,variab,variables,24,// Collect the instance variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:51,Modifiability,variab,variable,51,/// Build a type-check a new Objective-C exception variable declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:78,Availability,Recover,Recover,78,"// An @catch parameter must be an unqualified object pointer type;; // FIXME: Recover from ""NSObject foo"" by inserting the * in ""NSObject *foo""?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:78,Safety,Recover,Recover,78,"// An @catch parameter must be an unqualified object pointer type;; // FIXME: Recover from ""NSObject foo"" by inserting the * in ""NSObject *foo""?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:33,Modifiability,variab,variables,33,"// In ARC, infer 'retaining' for variables of retainable type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:142,Availability,error,error,142,"// We allow the ""register"" storage class on exception variables because; // GCC did, but we drop it completely. Any other storage class is an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:54,Modifiability,variab,variables,54,"// We allow the ""register"" storage class on exception variables because; // GCC did, but we drop it completely. Any other storage class is an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:3,Performance,Load,Load,3,// Load referenced selectors from the external source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:82,Security,access,accessor,82,/// Used by Sema::DiagnoseUnusedBackingIvarInAccessor to check if a property; /// accessor references the backing ivar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:67,Security,access,accessor,67,// Do not issue this warning if backing ivar is used somewhere and accessor; // implementation makes a self call. This is to prevent false positive in; // cases where the ivar is accessed by another method that the accessor; // delegates to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:179,Security,access,accessed,179,// Do not issue this warning if backing ivar is used somewhere and accessor; // implementation makes a self call. This is to prevent false positive in; // cases where the ivar is accessed by another method that the accessor; // delegates to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:215,Security,access,accessor,215,// Do not issue this warning if backing ivar is used somewhere and accessor; // implementation makes a self call. This is to prevent false positive in; // cases where the ivar is accessed by another method that the accessor; // delegates to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:407,Integrability,rout,routines,407,"//===--- SemaExceptionSpec.cpp - C++ Exception Specifications ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides Sema routines for C++ exception specification testing.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:448,Testability,test,testing,448,"//===--- SemaExceptionSpec.cpp - C++ Exception Specifications ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides Sema routines for C++ exception specification testing.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:331,Deployability,release,released,331,/// HACK: 2014-11-14 libstdc++ had a bug where it shadows std::swap with a; /// member swap function then tries to call std::swap unqualified from the; /// exception specification of that function. This function detects whether; /// we're in such a case and turns off delay-parsing of exception; /// specifications. Libstdc++ 6.1 (released 2016-04-27) appears to have; /// resolved it as side-effect of commit ddb63209a8d (2015-06-05).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:212,Safety,detect,detects,212,/// HACK: 2014-11-14 libstdc++ had a bug where it shadows std::swap with a; /// member swap function then tries to call std::swap unqualified from the; /// exception specification of that function. This function detects whether; /// we're in such a case and turns off delay-parsing of exception; /// specifications. Libstdc++ 6.1 (released 2016-04-27) appears to have; /// resolved it as side-effect of commit ddb63209a8d (2015-06-05).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:392,Availability,down,downgrade,392,"// C++11 [except.spec]p2:; // A type denoted in an exception-specification shall not denote an; // incomplete type other than a class currently being defined [...].; // A type denoted in an exception-specification shall not denote a; // pointer or reference to an incomplete type, other than (cv) void* or a; // pointer or reference to a class currently being defined.; // In Microsoft mode, downgrade this to a warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:39,Modifiability,extend,extend,39,"// The MSVC compatibility mode doesn't extend to sizeless types,; // so diagnose them separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:7,Availability,failure,failure,7,"// The failure was something other than an missing exception; // specification; return an error, except in MS mode where this is a warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:90,Availability,error,error,90,"// The failure was something other than an missing exception; // specification; return an error, except in MS mode where this is a warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:7,Integrability,depend,dependent,7,"// For dependent noexcept, we can't just take the expression from the old; // prototype. It likely contains references to the old prototype's parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:3,Deployability,Update,Update,3,// Update the type of the function with the appropriate exception; // specification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:53,Availability,error,error,53,"// FIXME: As usual, we could be more specific in our error messages, but; // that better waits until we've got types with source locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:59,Integrability,message,messages,59,"// FIXME: As usual, we could be more specific in our error messages, but; // that better waits until we've got types with source locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:16,Integrability,depend,dependent,16,"// If there are dependent noexcept specs, assume everything is fine. Unlike; // with the equivalency check, this is safe in this case, because we don't; // want to merge declarations. Checks after instantiation will catch any; // omissions we make here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:116,Safety,safe,safe,116,"// If there are dependent noexcept specs, assume everything is fine. Unlike; // with the equivalency check, this is safe in this case, because we don't; // want to merge declarations. Checks after instantiation will catch any; // omissions we make here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:24,Testability,test,testing,24,// We shouldn't even be testing this unless the arguments are otherwise; // compatible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:18,Availability,error,error,18,"// This is not an error in C++17 onwards, unless the noexceptness doesn't; // match, but in that case we have a full-on type mismatch, not just a; // type sugar mismatch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:300,Integrability,depend,dependent,300,"// Now we've got the correct types on both sides, check their compatibility.; // This means that the source of the conversion can only throw a subset of; // the exceptions of the target, and any exception specs on arguments or; // return types must be equivalent.; //; // FIXME: If there is a nested dependent exception specification, we should; // not be checking it here. This is fine:; // template<typename T> void f() {; // void (*p)(void (*) throw(T));; // void (*q)(void (*) throw(int)) = p;; // }; // ... because it might be instantiated with T=int.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:153,Performance,perform,perform,153,"// If the old exception specification hasn't been parsed yet, or the new; // exception specification can't be computed yet, remember that we need to; // perform this check when we get to the end of the outermost; // lexically-surrounding class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:60,Security,access,access,60,// Could be a call to a pointer-to-member or a plain member access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:39,Modifiability,variab,variably-modified,39,// FIXME: Properly determine whether a variably-modified type can throw.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:99,Modifiability,polymorphi,polymorphic,99,// - a potentially evaluated typeid expression applied to a glvalue; // expression whose type is a polymorphic class type,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:39,Modifiability,variab,variably-modified,39,// FIXME: Properly determine whether a variably-modified type can throw.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:8,Integrability,message,message,8,"// ObjC message sends are like function calls, but never have exception; // specs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:56,Testability,test,test,56,"// Many other things have subexpressions, so we have to test those.; // Some are simple:",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:81,Usability,simpl,simple,81,"// Many other things have subexpressions, so we have to test those.; // Some are simple:",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:39,Modifiability,variab,variably-modified,39,// FIXME: Properly determine whether a variably-modified type can throw.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:17,Integrability,depend,dependent,17,// Some might be dependent for other reasons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:39,Modifiability,variab,variably-modified,39,// FIXME: Properly determine whether a variably-modified type can throw.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:31,Integrability,depend,dependent,31,// Some expressions are always dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:39,Modifiability,variab,variably-modified,39,// FIXME: Properly determine whether a variably-modified type can throw.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:9,Integrability,depend,dependent,9,"// For a dependent 'if constexpr', the result is dependent if it depends on; // the value of the condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:49,Integrability,depend,dependent,49,"// For a dependent 'if constexpr', the result is dependent if it depends on; // the value of the condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:65,Integrability,depend,depends,65,"// For a dependent 'if constexpr', the result is dependent if it depends on; // the value of the condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,Modifiability,variab,variable,32,// See if this is an auto-typed variable whose initializer we are parsing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:483,Availability,error,errors,483,"/// Check whether we're in an extern inline function and referring to a; /// variable or function with internal linkage (C11 6.7.4p3).; ///; /// This is only a warning because we used to silently accept this code, but; /// in many cases it will not behave correctly. This is not enabled in C++ mode; /// because the restriction language is a bit weaker (C++11 [basic.def.odr]p6); /// and so while there may still be user mistakes, most of the time we can't; /// prove that there are errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:77,Modifiability,variab,variable,77,"/// Check whether we're in an extern inline function and referring to a; /// variable or function with internal linkage (C11 6.7.4p3).; ///; /// This is only a warning because we used to silently accept this code, but; /// in many cases it will not behave correctly. This is not enabled in C++ mode; /// because the restriction language is a bit weaker (C++11 [basic.def.odr]p6); /// and so while there may still be user mistakes, most of the time we can't; /// prove that there are errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Availability,Down,Downgrade,3,"// Downgrade from ExtWarn to Extension if; // (1) the supposedly external inline function is in the main file,; // and probably won't be included anywhere else.; // (2) the thing we're referencing is a pure function.; // (3) the thing we're referencing is another inline function.; // This last can give us false negatives, but it's better than warning on; // wrappers for simple C library functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:360,Integrability,wrap,wrappers,360,"// Downgrade from ExtWarn to Extension if; // (1) the supposedly external inline function is in the main file,; // and probably won't be included anywhere else.; // (2) the thing we're referencing is a pure function.; // (3) the thing we're referencing is another inline function.; // This last can give us false negatives, but it's better than warning on; // wrappers for simple C library functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:373,Usability,simpl,simple,373,"// Downgrade from ExtWarn to Extension if; // (1) the supposedly external inline function is in the main file,; // and probably won't be included anywhere else.; // (2) the thing we're referencing is a pure function.; // (3) the thing we're referencing is another inline function.; // This last can give us false negatives, but it's better than warning on; // wrappers for simple C library functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:340,Availability,error,error,340,"/// Determine whether the use of this declaration is valid, and; /// emit any corresponding diagnostics.; ///; /// This routine diagnoses various problems with referencing; /// declarations that can occur when using a declaration. For example,; /// it might warn if a deprecated or unavailable declaration is being; /// used, or produce an error (and return true) if a C++0x deleted; /// function is being used.; ///; /// \returns true if there was an error (this declaration cannot be; /// referenced), false otherwise.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:452,Availability,error,error,452,"/// Determine whether the use of this declaration is valid, and; /// emit any corresponding diagnostics.; ///; /// This routine diagnoses various problems with referencing; /// declarations that can occur when using a declaration. For example,; /// it might warn if a deprecated or unavailable declaration is being; /// used, or produce an error (and return true) if a C++0x deleted; /// function is being used.; ///; /// \returns true if there was an error (this declaration cannot be; /// referenced), false otherwise.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:120,Integrability,rout,routine,120,"/// Determine whether the use of this declaration is valid, and; /// emit any corresponding diagnostics.; ///; /// This routine diagnoses various problems with referencing; /// declarations that can occur when using a declaration. For example,; /// it might warn if a deprecated or unavailable declaration is being; /// used, or produce an error (and return true) if a C++0x deleted; /// function is being used.; ///; /// \returns true if there was an error (this declaration cannot be; /// referenced), false otherwise.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:188,Safety,avoid,avoid,188,"// Clear out the list of suppressed diagnostics, so that we don't emit; // them again for this specialization. However, we don't obsolete this; // entry from the table, because we want to avoid ever emitting these; // diagnostics again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Usability,Clear,Clear,3,"// Clear out the list of suppressed diagnostics, so that we don't emit; // them again for this specialization. However, we don't obsolete this; // entry from the table, because we want to avoid ever emitting these; // diagnostics again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,Modifiability,variab,variable,32,// See if this is an auto-typed variable whose initializer we are parsing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:77,Modifiability,variab,variables,77,"// [OpenMP 4.0], 2.15 declare reduction Directive, Restrictions; // Only the variables omp_in and omp_out are allowed in the combiner.; // Only the variables omp_priv and omp_orig are allowed in the; // initializer-clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:148,Modifiability,variab,variables,148,"// [OpenMP 4.0], 2.15 declare reduction Directive, Restrictions; // Only the variables omp_in and omp_out are allowed in the combiner.; // Only the variables omp_priv and omp_orig are allowed in the; // initializer-clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:149,Modifiability,variab,variable,149,"// [OpenMP 5.0], 2.19.7.3. declare mapper Directive, Restrictions; // List-items in map clauses on this construct may only refer to the declared; // variable var and entities that could be referenced by a procedure defined; // at the same location.; // [OpenMP 5.2] Also allow iterator declared variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:295,Modifiability,variab,variables,295,"// [OpenMP 5.0], 2.19.7.3. declare mapper Directive, Restrictions; // List-items in map clauses on this construct may only refer to the declared; // variable var and entities that could be referenced by a procedure defined; // at the same location.; // [OpenMP 5.2] Also allow iterator declared variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:33,Integrability,rout,routine,33,"/// DiagnoseSentinelCalls - This routine checks whether a call or; /// message-send is to a declaration with the sentinel attribute, and; /// if so, it checks that the requirements of the sentinel are; /// satisfied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:71,Integrability,message,message-send,71,"/// DiagnoseSentinelCalls - This routine checks whether a call or; /// message-send is to a declaration with the sentinel attribute, and; /// if so, it checks that the requirements of the sentinel are; /// satisfied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:138,Performance,optimiz,optimizer,138,"// Check to see if we are dereferencing a null pointer. If so,; // and if not volatile-qualified, this is undefined behavior that the; // optimizer will delete, so warn about it. People sometimes try to use this; // to get a deterministic trap and are surprised by clang's behavior. This; // only handles the pattern ""*null"", which is a very syntactic check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:33,Security,access,accesses,33,// OpenCL usually rejects direct accesses to values of 'half' type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:26,Availability,down,down,26,"// Under the MS ABI, lock down the inheritance model now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:35,Modifiability,inherit,inheritance,35,"// Under the MS ABI, lock down the inheritance model now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Performance,Load,Loading,3,"// Loading a __weak object implicitly retains the value, so we need a cleanup to; // balance that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:74,Performance,perform,performed,74,/// CallExprUnaryConversions - a special case of an unary conversion; /// performed on a function designator of a call expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:342,Integrability,rout,routine,342,"/// UsualUnaryConversions - Performs various conversions that are common to most; /// operators (C99 6.3). The conversions of array and function types are; /// sometimes suppressed. For example, the array->pointer conversion doesn't; /// apply if the array is an argument to the sizeof or address (&) operators.; /// In these instances, this routine should *not* be called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:28,Performance,Perform,Performs,28,"/// UsualUnaryConversions - Performs various conversions that are common to most; /// operators (C99 6.3). The conversions of array and function types are; /// sometimes suppressed. For example, the array->pointer conversion doesn't; /// apply if the array is an argument to the sizeof or address (&) operators.; /// In these instances, this routine should *not* be called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:10,Performance,perform,perform,10,// Try to perform integral promotions if the object has a theoretically; // promotable type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:7,Performance,perform,performs,7,"// C++ performs lvalue-to-rvalue conversion as a default argument; // promotion, even on class types, but note:; // C++11 [conv.lval]p2:; // When an lvalue-to-rvalue conversion occurs in an unevaluated; // operand or a subexpression thereof the value contained in the; // referenced object is not accessed. Otherwise, if the glvalue; // has a class type, the conversion copy-initializes a temporary; // of type T from the glvalue and the result of the conversion; // is a prvalue for the temporary.; // FIXME: add some way to gate this entire thing for correctness in; // potentially potentially evaluated contexts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:297,Security,access,accessed,297,"// C++ performs lvalue-to-rvalue conversion as a default argument; // promotion, even on class types, but note:; // C++11 [conv.lval]p2:; // When an lvalue-to-rvalue conversion occurs in an unevaluated; // operand or a subexpression thereof the value contained in the; // referenced object is not accessed. Otherwise, if the glvalue; // has a class type, the conversion copy-initializes a temporary; // of type T from the glvalue and the result of the conversion; // is a prvalue for the temporary.; // FIXME: add some way to gate this entire thing for correctness in; // potentially potentially evaluated contexts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:122,Performance,perform,performed,122,"/// Determine the degree of POD-ness for an expression.; /// Incomplete types are considered POD, since this check can be performed; /// when we're in an unevaluated context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:214,Performance,perform,performed,214,"// C++11 [expr.call]p7:; // After these conversions, if the argument does not have arithmetic,; // enumeration, pointer, pointer to member, or class type, the program; // is ill-formed.; //; // Since we've already performed array-to-pointer and function-to-pointer; // decay, the only such type in C++ is cv void. This also handles; // initializer lists as variadic arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:42,Integrability,interface,interface,42,// Don't allow one to pass an Objective-C interface to a vararg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:55,Performance,perform,performed,55,/// Check that the usual arithmetic conversions can be performed on this pair of; /// expressions that might be of enumeration type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:273,Availability,error,error,273,"/// UsualArithmeticConversions - Performs various conversions that are common to; /// binary operators (C99 6.3.1.8). If both operands aren't arithmetic, this; /// routine returns the first non-arithmetic type found. The client is; /// responsible for emitting appropriate error diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:164,Integrability,rout,routine,164,"/// UsualArithmeticConversions - Performs various conversions that are common to; /// binary operators (C99 6.3.1.8). If both operands aren't arithmetic, this; /// routine returns the first non-arithmetic type found. The client is; /// responsible for emitting appropriate error diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:33,Performance,Perform,Performs,33,"/// UsualArithmeticConversions - Performs various conversions that are common to; /// binary operators (C99 6.3.1.8). If both operands aren't arithmetic, this; /// routine returns the first non-arithmetic type found. The client is; /// responsible for emitting appropriate error diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:588,Modifiability,variab,variably,588,"// We relax the restriction on use of incomplete types and non-object; // types with the type-based extension of _Generic. Allowing incomplete; // objects means those can be used as ""tags"" for a type-safe way to map; // to a value. Similarly, matching on function types rather than; // function pointer types can be useful. However, the restriction on VM; // types makes sense to retain as there are open questions about how; // the selection can be made at compile time.; //; // C11 6.5.1.1p2 ""The type name in a generic association shall specify a; // complete object type other than a variably modified type.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:200,Safety,safe,safe,200,"// We relax the restriction on use of incomplete types and non-object; // types with the type-based extension of _Generic. Allowing incomplete; // objects means those can be used as ""tags"" for a type-safe way to map; // to a value. Similarly, matching on function types rather than; // function pointer types can be useful. However, the restriction on VM; // types makes sense to retain as there are open questions about how; // the selection can be made at compile time.; //; // C11 6.5.1.1p2 ""The type name in a generic association shall specify a; // complete object type other than a variably modified type.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:417,Testability,log,logic,417,"// Because the controlling expression undergoes lvalue conversion,; // array conversion, and function conversion, an association which is; // of array type, function type, or is qualified can never be; // reached. We will warn about this so users are less surprised by; // the unreachable association. However, we don't have to handle; // function types; that's not an object type, so it's handled above.; //; // The logic is somewhat different for C++ because C++ has different; // lvalue to rvalue conversion rules than C. [conv.lvalue]p1 says,; // If T is a non-class type, the type of the prvalue is the cv-; // unqualified version of T. Otherwise, the type of the prvalue is T.; // The result of these rules is that all qualified types in an; // association in C are unreachable, and in C++, only qualified non-; // class types are unreachable.; //; // NB: this does not apply when the first operand is a type rather; // than an expression, because the type form does not undergo; // conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:57,Integrability,depend,dependent,57,"// If we determined that the generic selection is result-dependent, don't; // try to compute the result expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:48,Modifiability,variab,variable,48,// CUDA/HIP: Check whether a captured reference variable is referencing a; // host variable in a device or host device lambda.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:83,Modifiability,variab,variable,83,// CUDA/HIP: Check whether a captured reference variable is referencing a; // host variable in a device or host device lambda.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:31,Modifiability,variab,variable,31,// Check whether the reference variable is referencing a host variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:62,Modifiability,variab,variable,62,// Check whether the reference variable is referencing a host variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:105,Modifiability,variab,variable,105,// Check whether the current function is a device or host device lambda.; // Check whether the reference variable is a capture by getDeclContext(); // since refersToEnclosingVariableOrCapture() is not ready at this point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:34,Modifiability,variab,variable,34,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless [...] x is a reference that is usable in; // constant expressions.; // CUDA/HIP:; // If a reference variable referencing a host variable is captured in a; // device or host device lambda, the value of the referee must be copied; // to the capture and the reference variable must be treated as odr-use; // since the value of the referee is not known at compile time and must; // be loaded from the captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:232,Modifiability,variab,variable,232,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless [...] x is a reference that is usable in; // constant expressions.; // CUDA/HIP:; // If a reference variable referencing a host variable is captured in a; // device or host device lambda, the value of the referee must be copied; // to the capture and the reference variable must be treated as odr-use; // since the value of the referee is not known at compile time and must; // be loaded from the captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:260,Modifiability,variab,variable,260,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless [...] x is a reference that is usable in; // constant expressions.; // CUDA/HIP:; // If a reference variable referencing a host variable is captured in a; // device or host device lambda, the value of the referee must be copied; // to the capture and the reference variable must be treated as odr-use; // since the value of the referee is not known at compile time and must; // be loaded from the captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:397,Modifiability,variab,variable,397,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless [...] x is a reference that is usable in; // constant expressions.; // CUDA/HIP:; // If a reference variable referencing a host variable is captured in a; // device or host device lambda, the value of the referee must be copied; // to the capture and the reference variable must be treated as odr-use; // since the value of the referee is not known at compile time and must; // be loaded from the captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:513,Performance,load,loaded,513,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless [...] x is a reference that is usable in; // constant expressions.; // CUDA/HIP:; // If a reference variable referencing a host variable is captured in a; // device or host device lambda, the value of the referee must be copied; // to the capture and the reference variable must be treated as odr-use; // since the value of the referee is not known at compile time and must; // be loaded from the captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:163,Usability,usab,usable,163,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless [...] x is a reference that is usable in; // constant expressions.; // CUDA/HIP:; // If a reference variable referencing a host variable is captured in a; // device or host device lambda, the value of the referee must be copied; // to the capture and the reference variable must be treated as odr-use; // since the value of the referee is not known at compile time and must; // be loaded from the captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:21,Modifiability,variab,variable,21,"// All remaining non-variable cases constitute an odr-use. For variables, we; // need to wait and see how the expression is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:63,Modifiability,variab,variables,63,"// All remaining non-variable cases constitute an odr-use. For variables, we; // need to wait and see how the expression is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:369,Availability,error,errors,369,"// C++ [except.spec]p17:; // An exception-specification is considered to be needed when:; // - in an expression, the function is the unique lookup result or; // the selected member of a set of overloaded functions.; //; // We delay doing this until after we've built the function reference and; // marked it as used so that:; // a) if the function is defaulted, we get errors from defining it before /; // instead of errors from computing its exception specification, and; // b) if the function is a defaulted comparison, we can use the body we; // build when defining it as input to the exception specification; // computation rather than computing a new body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:417,Availability,error,errors,417,"// C++ [except.spec]p17:; // An exception-specification is considered to be needed when:; // - in an expression, the function is the unique lookup result or; // the selected member of a set of overloaded functions.; //; // We delay doing this until after we've built the function reference and; // marked it as used so that:; // a) if the function is defaulted, we get errors from defining it before /; // instead of errors from computing its exception specification, and; // b) if the function is a defaulted comparison, we can use the body we; // build when defining it as input to the exception specification; // computation rather than computing a new body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:70,Availability,error,error,70,"/// Diagnose a lookup that found results in an enclosing class during error; /// recovery. This usually indicates that the results were found in a dependent; /// base class that could not be searched as part of a template definition.; /// Always issues a diagnostic (though this may be only a warning in MS; /// compatibility mode).; ///; /// Return \c true if the error is unrecoverable, or \c false if the caller; /// should attempt to recover using these lookup results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:81,Availability,recover,recovery,81,"/// Diagnose a lookup that found results in an enclosing class during error; /// recovery. This usually indicates that the results were found in a dependent; /// base class that could not be searched as part of a template definition.; /// Always issues a diagnostic (though this may be only a warning in MS; /// compatibility mode).; ///; /// Return \c true if the error is unrecoverable, or \c false if the caller; /// should attempt to recover using these lookup results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:365,Availability,error,error,365,"/// Diagnose a lookup that found results in an enclosing class during error; /// recovery. This usually indicates that the results were found in a dependent; /// base class that could not be searched as part of a template definition.; /// Always issues a diagnostic (though this may be only a warning in MS; /// compatibility mode).; ///; /// Return \c true if the error is unrecoverable, or \c false if the caller; /// should attempt to recover using these lookup results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:438,Availability,recover,recover,438,"/// Diagnose a lookup that found results in an enclosing class during error; /// recovery. This usually indicates that the results were found in a dependent; /// base class that could not be searched as part of a template definition.; /// Always issues a diagnostic (though this may be only a warning in MS; /// compatibility mode).; ///; /// Return \c true if the error is unrecoverable, or \c false if the caller; /// should attempt to recover using these lookup results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:147,Integrability,depend,dependent,147,"/// Diagnose a lookup that found results in an enclosing class during error; /// recovery. This usually indicates that the results were found in a dependent; /// base class that could not be searched as part of a template definition.; /// Always issues a diagnostic (though this may be only a warning in MS; /// compatibility mode).; ///; /// Return \c true if the error is unrecoverable, or \c false if the caller; /// should attempt to recover using these lookup results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:81,Safety,recover,recovery,81,"/// Diagnose a lookup that found results in an enclosing class during error; /// recovery. This usually indicates that the results were found in a dependent; /// base class that could not be searched as part of a template definition.; /// Always issues a diagnostic (though this may be only a warning in MS; /// compatibility mode).; ///; /// Return \c true if the error is unrecoverable, or \c false if the caller; /// should attempt to recover using these lookup results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:438,Safety,recover,recover,438,"/// Diagnose a lookup that found results in an enclosing class during error; /// recovery. This usually indicates that the results were found in a dependent; /// base class that could not be searched as part of a template definition.; /// Always issues a diagnostic (though this may be only a warning in MS; /// compatibility mode).; ///; /// Return \c true if the error is unrecoverable, or \c false if the caller; /// should attempt to recover using these lookup results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:170,Integrability,depend,dependent,170,"// There are two ways we can find a class-scope declaration during template; // instantiation that we did not find in the template definition: if it is a; // member of a dependent base class, or if it is declared after the point of; // use in the same class. Distinguish these by comparing the class in which; // the member was found to the naming class of the lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:29,Availability,recover,recover,29,// Tell the callee to try to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:29,Safety,recover,recover,29,// Tell the callee to try to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:195,Integrability,depend,dependent,195,"// If the original lookup was an unqualified lookup, fake an; // unqualified lookup. This is useful when (for example) the; // original lookup would not have found something because it was a; // dependent name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:14,Availability,error,errors,14,// Don't give errors about ambiguities in this lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:149,Availability,recover,recover,149,"// FIXME: If we ended up with a typo for a type name or; // Objective-C class name, we're in trouble because the parser; // is in the wrong place to recover. Suggest the typo; // correction, but don't make it a fix-it since we're not going; // to recover well anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:247,Availability,recover,recover,247,"// FIXME: If we ended up with a typo for a type name or; // Objective-C class name, we're in trouble because the parser; // is in the wrong place to recover. Suggest the typo; // correction, but don't make it a fix-it since we're not going; // to recover well anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:149,Safety,recover,recover,149,"// FIXME: If we ended up with a typo for a type name or; // Objective-C class name, we're in trouble because the parser; // is in the wrong place to recover. Suggest the typo; // correction, but don't make it a fix-it since we're not going; // to recover well anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:247,Safety,recover,recover,247,"// FIXME: If we ended up with a typo for a type name or; // Objective-C class name, we're in trouble because the parser; // is in the wrong place to recover. Suggest the typo; // correction, but don't make it a fix-it since we're not going; // to recover well anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:99,Availability,recover,recover,99,"// FIXME: We found a keyword. Suggest it, but don't provide a fix-it; // because we aren't able to recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:99,Safety,recover,recover,99,"// FIXME: We found a keyword. Suggest it, but don't provide a fix-it; // because we aren't able to recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:37,Availability,recover,recover,37,// Tell the callee whether to try to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:37,Safety,recover,recover,37,// Tell the callee whether to try to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:21,Availability,recover,recover,21,"// Give up, we can't recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:21,Safety,recover,recover,21,"// Give up, we can't recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:245,Availability,recover,recover,245,"/// In Microsoft mode, if we are inside a template class whose parent class has; /// dependent base classes, and we can't resolve an unqualified identifier, then; /// assume the identifier is a member of a dependent base class. We can only; /// recover successfully in static methods, instance methods, and other contexts; /// where 'this' is available. This doesn't precisely match MSVC's; /// instantiation model, but it's close enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:343,Availability,avail,available,343,"/// In Microsoft mode, if we are inside a template class whose parent class has; /// dependent base classes, and we can't resolve an unqualified identifier, then; /// assume the identifier is a member of a dependent base class. We can only; /// recover successfully in static methods, instance methods, and other contexts; /// where 'this' is available. This doesn't precisely match MSVC's; /// instantiation model, but it's close enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:85,Integrability,depend,dependent,85,"/// In Microsoft mode, if we are inside a template class whose parent class has; /// dependent base classes, and we can't resolve an unqualified identifier, then; /// assume the identifier is a member of a dependent base class. We can only; /// recover successfully in static methods, instance methods, and other contexts; /// where 'this' is available. This doesn't precisely match MSVC's; /// instantiation model, but it's close enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:206,Integrability,depend,dependent,206,"/// In Microsoft mode, if we are inside a template class whose parent class has; /// dependent base classes, and we can't resolve an unqualified identifier, then; /// assume the identifier is a member of a dependent base class. We can only; /// recover successfully in static methods, instance methods, and other contexts; /// where 'this' is available. This doesn't precisely match MSVC's; /// instantiation model, but it's close enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:245,Safety,recover,recover,245,"/// In Microsoft mode, if we are inside a template class whose parent class has; /// dependent base classes, and we can't resolve an unqualified identifier, then; /// assume the identifier is a member of a dependent base class. We can only; /// recover successfully in static methods, instance methods, and other contexts; /// where 'this' is available. This doesn't precisely match MSVC's; /// instantiation model, but it's close enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:15,Availability,recover,recover,15,// Only try to recover from lookup into dependent bases in static methods or; // contexts where 'this' is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:106,Availability,avail,available,106,// Only try to recover from lookup into dependent bases in static methods or; // contexts where 'this' is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:40,Integrability,depend,dependent,40,// Only try to recover from lookup into dependent bases in static methods or; // contexts where 'this' is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:15,Safety,recover,recover,15,// Only try to recover from lookup into dependent bases in static methods or; // contexts where 'this' is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:85,Availability,avail,available,85,"// Diagnose this as unqualified lookup into a dependent base class. If 'this'; // is available, suggest inserting 'this->' as a fixit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:46,Integrability,depend,dependent,46,"// Diagnose this as unqualified lookup into a dependent base class. If 'this'; // is available, suggest inserting 'this->' as a fixit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:73,Performance,perform,perform,73,// Synthesize a fake NNS that points to the derived class. This will; // perform name lookup during template instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:55,Integrability,depend,dependent,55,"// C++ [temp.dep.expr]p3:; // An id-expression is type-dependent if it contains:; // -- an identifier that was declared with a dependent type,; // (note: handled after lookup); // -- a template-id that is dependent,; // (note: handled in BuildTemplateIdExpr); // -- a conversion-function-id that specifies a dependent type,; // -- a nested-name-specifier that contains a class-name that; // names a dependent type.; // Determine whether this is a member of an unknown specialization;; // we need to handle these differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:127,Integrability,depend,dependent,127,"// C++ [temp.dep.expr]p3:; // An id-expression is type-dependent if it contains:; // -- an identifier that was declared with a dependent type,; // (note: handled after lookup); // -- a template-id that is dependent,; // (note: handled in BuildTemplateIdExpr); // -- a conversion-function-id that specifies a dependent type,; // -- a nested-name-specifier that contains a class-name that; // names a dependent type.; // Determine whether this is a member of an unknown specialization;; // we need to handle these differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:205,Integrability,depend,dependent,205,"// C++ [temp.dep.expr]p3:; // An id-expression is type-dependent if it contains:; // -- an identifier that was declared with a dependent type,; // (note: handled after lookup); // -- a template-id that is dependent,; // (note: handled in BuildTemplateIdExpr); // -- a conversion-function-id that specifies a dependent type,; // -- a nested-name-specifier that contains a class-name that; // names a dependent type.; // Determine whether this is a member of an unknown specialization;; // we need to handle these differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:308,Integrability,depend,dependent,308,"// C++ [temp.dep.expr]p3:; // An id-expression is type-dependent if it contains:; // -- an identifier that was declared with a dependent type,; // (note: handled after lookup); // -- a template-id that is dependent,; // (note: handled in BuildTemplateIdExpr); // -- a conversion-function-id that specifies a dependent type,; // -- a nested-name-specifier that contains a class-name that; // names a dependent type.; // Determine whether this is a member of an unknown specialization;; // we need to handle these differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:399,Integrability,depend,dependent,399,"// C++ [temp.dep.expr]p3:; // An id-expression is type-dependent if it contains:; // -- an identifier that was declared with a dependent type,; // (note: handled after lookup); // -- a template-id that is dependent,; // (note: handled in BuildTemplateIdExpr); // -- a conversion-function-id that specifies a dependent type,; // -- a nested-name-specifier that contains a class-name that; // names a dependent type.; // Determine whether this is a member of an unknown specialization;; // we need to handle these differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Performance,Perform,Perform,3,// Perform the required lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:239,Performance,perform,performance,239,"// Lookup the template name again to correctly establish the context in; // which it was found. This is really unfortunate as we already did the; // lookup to determine that it was a template name in the first place. If; // this becomes a performance hit, we can work harder to preserve those; // results until we get here but it's likely not worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:31,Integrability,depend,dependent,31,"// If the result might be in a dependent base class, this is a dependent; // id-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:63,Integrability,depend,dependent,63,"// If the result might be in a dependent base class, this is a dependent; // id-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:69,Integrability,depend,dependent,69,// Determine whether this name might be a candidate for; // argument-dependent lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:45,Performance,perform,performed,45,// Signal that a correction to a keyword was performed by returning a; // valid-but-null ExprResult.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:39,Modifiability,variab,variable,39,"// If we found an Objective-C instance variable, let; // LookupInObjCMethod build the appropriate expression to; // reference the ivar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:52,Modifiability,variab,variable,52,"// In a hopelessly buggy code, Objective-C instance variable; // lookup fails and no expression will be built to reference it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:1119,Integrability,depend,dependent,1119,"// Check whether this might be a C++ implicit instance member access.; // C++ [class.mfct.non-static]p3:; // When an id-expression that is not part of a class member access; // syntax and not used to form a pointer to member is used in the; // body of a non-static member function of class X, if name lookup; // resolves the name in the id-expression to a non-static non-type; // member of some class C, the id-expression is transformed into a; // class member access expression using (*this) as the; // postfix-expression to the left of the . operator.; //; // But we don't actually need to do this for '&' operands if R; // resolved to a function or overloaded function set, because the; // expression is ill-formed if it actually works out to be a; // non-static member function:; //; // C++ [expr.ref]p4:; // Otherwise, if E1.E2 refers to a non-static member function. . .; // [t]he expression can be used only as the left-hand operand of a; // member function call.; //; // There are other safeguards against such uses, but it's important; // to get this right here so that we don't end up making a; // spuriously dependent expression if we're inside a dependent; // instance method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:1158,Integrability,depend,dependent,1158,"// Check whether this might be a C++ implicit instance member access.; // C++ [class.mfct.non-static]p3:; // When an id-expression that is not part of a class member access; // syntax and not used to form a pointer to member is used in the; // body of a non-static member function of class X, if name lookup; // resolves the name in the id-expression to a non-static non-type; // member of some class C, the id-expression is transformed into a; // class member access expression using (*this) as the; // postfix-expression to the left of the . operator.; //; // But we don't actually need to do this for '&' operands if R; // resolved to a function or overloaded function set, because the; // expression is ill-formed if it actually works out to be a; // non-static member function:; //; // C++ [expr.ref]p4:; // Otherwise, if E1.E2 refers to a non-static member function. . .; // [t]he expression can be used only as the left-hand operand of a; // member function call.; //; // There are other safeguards against such uses, but it's important; // to get this right here so that we don't end up making a; // spuriously dependent expression if we're inside a dependent; // instance method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:995,Safety,safe,safeguards,995,"// Check whether this might be a C++ implicit instance member access.; // C++ [class.mfct.non-static]p3:; // When an id-expression that is not part of a class member access; // syntax and not used to form a pointer to member is used in the; // body of a non-static member function of class X, if name lookup; // resolves the name in the id-expression to a non-static non-type; // member of some class C, the id-expression is transformed into a; // class member access expression using (*this) as the; // postfix-expression to the left of the . operator.; //; // But we don't actually need to do this for '&' operands if R; // resolved to a function or overloaded function set, because the; // expression is ill-formed if it actually works out to be a; // non-static member function:; //; // C++ [expr.ref]p4:; // Otherwise, if E1.E2 refers to a non-static member function. . .; // [t]he expression can be used only as the left-hand operand of a; // member function call.; //; // There are other safeguards against such uses, but it's important; // to get this right here so that we don't end up making a; // spuriously dependent expression if we're inside a dependent; // instance method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:62,Security,access,access,62,"// Check whether this might be a C++ implicit instance member access.; // C++ [class.mfct.non-static]p3:; // When an id-expression that is not part of a class member access; // syntax and not used to form a pointer to member is used in the; // body of a non-static member function of class X, if name lookup; // resolves the name in the id-expression to a non-static non-type; // member of some class C, the id-expression is transformed into a; // class member access expression using (*this) as the; // postfix-expression to the left of the . operator.; //; // But we don't actually need to do this for '&' operands if R; // resolved to a function or overloaded function set, because the; // expression is ill-formed if it actually works out to be a; // non-static member function:; //; // C++ [expr.ref]p4:; // Otherwise, if E1.E2 refers to a non-static member function. . .; // [t]he expression can be used only as the left-hand operand of a; // member function call.; //; // There are other safeguards against such uses, but it's important; // to get this right here so that we don't end up making a; // spuriously dependent expression if we're inside a dependent; // instance method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:166,Security,access,access,166,"// Check whether this might be a C++ implicit instance member access.; // C++ [class.mfct.non-static]p3:; // When an id-expression that is not part of a class member access; // syntax and not used to form a pointer to member is used in the; // body of a non-static member function of class X, if name lookup; // resolves the name in the id-expression to a non-static non-type; // member of some class C, the id-expression is transformed into a; // class member access expression using (*this) as the; // postfix-expression to the left of the . operator.; //; // But we don't actually need to do this for '&' operands if R; // resolved to a function or overloaded function set, because the; // expression is ill-formed if it actually works out to be a; // non-static member function:; //; // C++ [expr.ref]p4:; // Otherwise, if E1.E2 refers to a non-static member function. . .; // [t]he expression can be used only as the left-hand operand of a; // member function call.; //; // There are other safeguards against such uses, but it's important; // to get this right here so that we don't end up making a; // spuriously dependent expression if we're inside a dependent; // instance method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:461,Security,access,access,461,"// Check whether this might be a C++ implicit instance member access.; // C++ [class.mfct.non-static]p3:; // When an id-expression that is not part of a class member access; // syntax and not used to form a pointer to member is used in the; // body of a non-static member function of class X, if name lookup; // resolves the name in the id-expression to a non-static non-type; // member of some class C, the id-expression is transformed into a; // class member access expression using (*this) as the; // postfix-expression to the left of the . operator.; //; // But we don't actually need to do this for '&' operands if R; // resolved to a function or overloaded function set, because the; // expression is ill-formed if it actually works out to be a; // non-static member function:; //; // C++ [expr.ref]p4:; // Otherwise, if E1.E2 refers to a non-static member function. . .; // [t]he expression can be used only as the left-hand operand of a; // member function call.; //; // There are other safeguards against such uses, but it's important; // to get this right here so that we don't end up making a; // spuriously dependent expression if we're inside a dependent; // instance method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:26,Modifiability,variab,variable,26,"// In C++1y, if this is a variable template id, then check it; // in BuildTemplateIdExpr().; // The single lookup result must be a variable template declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:131,Modifiability,variab,variable,131,"// In C++1y, if this is a variable template id, then check it; // in BuildTemplateIdExpr().; // The single lookup result must be a variable template declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:271,Modifiability,inherit,inherited,271,"// Don't diagnose problems with invalid record decl, the secondary no_member; // diagnostic during template instantiation is likely bogus, e.g. if a class; // is invalid because it's derived from an invalid base class, then missing; // members were likely supposed to be inherited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:110,Availability,recover,recover,110,"// Diagnose a missing typename if this resolved unambiguously to a type in; // a dependent context. If we can recover with a type, downgrade this to; // a warning in Microsoft compatibility mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:131,Availability,down,downgrade,131,"// Diagnose a missing typename if this resolved unambiguously to a type in; // a dependent context. If we can recover with a type, downgrade this to; // a warning in Microsoft compatibility mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:81,Integrability,depend,dependent,81,"// Diagnose a missing typename if this resolved unambiguously to a type in; // a dependent context. If we can recover with a type, downgrade this to; // a warning in Microsoft compatibility mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:110,Safety,recover,recover,110,"// Diagnose a missing typename if this resolved unambiguously to a type in; // a dependent context. If we can recover with a type, downgrade this to; // a warning in Microsoft compatibility mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:9,Availability,recover,recover,9,// Don't recover if the caller isn't expecting us to or if we're in a SFINAE; // context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:9,Safety,recover,recover,9,// Don't recover if the caller isn't expecting us to or if we're in a SFINAE; // context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:45,Availability,recover,recover,45,// Only issue the fixit if we're prepared to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:45,Safety,recover,recover,45,// Only issue the fixit if we're prepared to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Availability,Recover,Recover,3,// Recover by pretending this was an elaborated type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Safety,Recover,Recover,3,// Recover by pretending this was an elaborated type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:55,Security,access,access,55,"// Defend against this resolving to an implicit member access. We usually; // won't get here if this might be a legitimate a class member (we end up in; // BuildMemberReferenceExpr instead), but this can be valid if we're forming; // a pointer-to-member or in an unevaluated context in C++11.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:106,Performance,Perform,Perform,106,"/// The parser has read a name in, and Sema has detected that we're currently; /// inside an ObjC method. Perform some additional checks and determine if we; /// should form a reference to an ivar.; ///; /// Ideally, most of this would be done by lookup, but there's; /// actually quite a lot of extra work involved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:48,Safety,detect,detected,48,"/// The parser has read a name in, and Sema has detected that we're currently; /// inside an ObjC method. Perform some additional checks and determine if we; /// should form a reference to an ivar.; ///; /// Ideally, most of this would be done by lookup, but there's; /// actually quite a lot of extra work involved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:13,Availability,error,error,13,// Check for error condition which is already reported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:521,Availability,error,error,521,"// There are two cases to handle here. 1) scoped lookup could have failed,; // in which case we should look for an ivar. 2) scoped lookup could have; // found a decl, but that decl is outside the current instance method (i.e.; // a global variable). In these two cases, we do a lookup for an ivar with; // this name, if the lookup sucedes, we replace it our current decl.; // If we're in a class method, we don't normally want to look for; // ivars. But if we don't find anything else, and there's an; // ivar, that's an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:239,Modifiability,variab,variable,239,"// There are two cases to handle here. 1) scoped lookup could have failed,; // in which case we should look for an ivar. 2) scoped lookup could have; // found a decl, but that decl is outside the current instance method (i.e.; // a global variable). In these two cases, we do a lookup for an ivar with; // this name, if the lookup sucedes, we replace it our current decl.; // If we're in a class method, we don't normally want to look for; // ivars. But if we don't find anything else, and there's an; // ivar, that's an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:29,Modifiability,variab,variable,29,// We should warn if a local variable hides an ivar.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:65,Availability,error,error,65,"// If accessing a stand-alone ivar in a class method, this is an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:6,Security,access,accessing,6,"// If accessing a stand-alone ivar in a class method, this is an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:23,Availability,error,error,23,"// Didn't encounter an error, didn't find an ivar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:74,Availability,error,error,74,"// If we're referencing an invalid decl, just return this as a silent; // error node. The error diagnostic was already emitted on the decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:90,Availability,error,error,90,"// If we're referencing an invalid decl, just return this as a silent; // error node. The error diagnostic was already emitted on the decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:106,Performance,Perform,Perform,106,"/// The parser has read a name in, and Sema has detected that we're currently; /// inside an ObjC method. Perform some additional checks and determine if we; /// should form a reference to an ivar. If so, build an expression referencing; /// that ivar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:48,Safety,detect,detected,48,"/// The parser has read a name in, and Sema has detected that we're currently; /// inside an ObjC method. Perform some additional checks and determine if we; /// should form a reference to an ivar. If so, build an expression referencing; /// that ivar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:10,Deployability,Integrat,Integrate,10,// FIXME: Integrate this lookup step into LookupParsedName.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:10,Integrability,Integrat,Integrate,10,// FIXME: Integrate this lookup step into LookupParsedName.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:112,Security,access,access,112,"/// Cast a base object to a member's actual type.; ///; /// There are two relevant checks:; ///; /// C++ [class.access.base]p7:; ///; /// If a class member access operator [...] is used to access a non-static; /// data member or non-static member function, the reference is ill-formed if; /// the left operand [...] cannot be implicitly converted to a pointer to the; /// naming class of the right operand.; ///; /// C++ [expr.ref]p7:; ///; /// If E2 is a non-static data member or a non-static member function, the; /// program is ill-formed if the class of which E2 is directly a member is an; /// ambiguous base (11.8) of the naming class (11.9.3) of E2.; ///; /// Note that the latter check does not consider access; the access of the; /// ""real"" base class is checked as appropriate when checking the access of the; /// member name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:156,Security,access,access,156,"/// Cast a base object to a member's actual type.; ///; /// There are two relevant checks:; ///; /// C++ [class.access.base]p7:; ///; /// If a class member access operator [...] is used to access a non-static; /// data member or non-static member function, the reference is ill-formed if; /// the left operand [...] cannot be implicitly converted to a pointer to the; /// naming class of the right operand.; ///; /// C++ [expr.ref]p7:; ///; /// If E2 is a non-static data member or a non-static member function, the; /// program is ill-formed if the class of which E2 is directly a member is an; /// ambiguous base (11.8) of the naming class (11.9.3) of E2.; ///; /// Note that the latter check does not consider access; the access of the; /// ""real"" base class is checked as appropriate when checking the access of the; /// member name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:189,Security,access,access,189,"/// Cast a base object to a member's actual type.; ///; /// There are two relevant checks:; ///; /// C++ [class.access.base]p7:; ///; /// If a class member access operator [...] is used to access a non-static; /// data member or non-static member function, the reference is ill-formed if; /// the left operand [...] cannot be implicitly converted to a pointer to the; /// naming class of the right operand.; ///; /// C++ [expr.ref]p7:; ///; /// If E2 is a non-static data member or a non-static member function, the; /// program is ill-formed if the class of which E2 is directly a member is an; /// ambiguous base (11.8) of the naming class (11.9.3) of E2.; ///; /// Note that the latter check does not consider access; the access of the; /// ""real"" base class is checked as appropriate when checking the access of the; /// member name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:713,Security,access,access,713,"/// Cast a base object to a member's actual type.; ///; /// There are two relevant checks:; ///; /// C++ [class.access.base]p7:; ///; /// If a class member access operator [...] is used to access a non-static; /// data member or non-static member function, the reference is ill-formed if; /// the left operand [...] cannot be implicitly converted to a pointer to the; /// naming class of the right operand.; ///; /// C++ [expr.ref]p7:; ///; /// If E2 is a non-static data member or a non-static member function, the; /// program is ill-formed if the class of which E2 is directly a member is an; /// ambiguous base (11.8) of the naming class (11.9.3) of E2.; ///; /// Note that the latter check does not consider access; the access of the; /// ""real"" base class is checked as appropriate when checking the access of the; /// member name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:725,Security,access,access,725,"/// Cast a base object to a member's actual type.; ///; /// There are two relevant checks:; ///; /// C++ [class.access.base]p7:; ///; /// If a class member access operator [...] is used to access a non-static; /// data member or non-static member function, the reference is ill-formed if; /// the left operand [...] cannot be implicitly converted to a pointer to the; /// naming class of the right operand.; ///; /// C++ [expr.ref]p7:; ///; /// If E2 is a non-static data member or a non-static member function, the; /// program is ill-formed if the class of which E2 is directly a member is an; /// ambiguous base (11.8) of the naming class (11.9.3) of E2.; ///; /// Note that the latter check does not consider access; the access of the; /// ""real"" base class is checked as appropriate when checking the access of the; /// member name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:806,Security,access,access,806,"/// Cast a base object to a member's actual type.; ///; /// There are two relevant checks:; ///; /// C++ [class.access.base]p7:; ///; /// If a class member access operator [...] is used to access a non-static; /// data member or non-static member function, the reference is ill-formed if; /// the left operand [...] cannot be implicitly converted to a pointer to the; /// naming class of the right operand.; ///; /// C++ [expr.ref]p7:; ///; /// If E2 is a non-static data member or a non-static member function, the; /// program is ill-formed if the class of which E2 is directly a member is an; /// ambiguous base (11.8) of the naming class (11.9.3) of E2.; ///; /// Note that the latter check does not consider access; the access of the; /// ""real"" base class is checked as appropriate when checking the access of the; /// member name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:657,Availability,error,error,657,"// C++ [class.member.lookup]p8:; // [...] Ambiguities can often be resolved by qualifying a name with its; // class name.; //; // If the member was a qualified name and the qualified referred to a; // specific base subobject type, we'll cast to that intermediate type; // first and then to the object in which the member is declared. That allows; // one to resolve ambiguities in, e.g., a diamond-shaped hierarchy such as:; //; // class Base { public: int x; };; // class Derived1 : public Base { };; // class Derived2 : public Base { };; // class VeryDerived : public Derived1, public Derived2 { void f(); };; //; // void VeryDerived::f() {; // x = 17; // error: ambiguous base subobjects; // Derived1::x = 17; // okay, pick the Base subobject of Derived1; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:109,Security,hash,hash,109,"// Otherwise, just build an unresolved lookup expression. Suppress; // any lookup-related diagnostics; we'll hash these out later, when; // we've picked a target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Availability,Recover,Recovery,3,"// Recovery from invalid cases (e.g. D is an invalid Decl).; // We use the dependent type for the RecoveryExpr to prevent bogus follow-up; // diagnostics, as invalid decls use int as a fallback type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:98,Availability,Recover,RecoveryExpr,98,"// Recovery from invalid cases (e.g. D is an invalid Decl).; // We use the dependent type for the RecoveryExpr to prevent bogus follow-up; // diagnostics, as invalid decls use int as a fallback type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:75,Integrability,depend,dependent,75,"// Recovery from invalid cases (e.g. D is an invalid Decl).; // We use the dependent type for the RecoveryExpr to prevent bogus follow-up; // diagnostics, as invalid decls use int as a fallback type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Safety,Recover,Recovery,3,"// Recovery from invalid cases (e.g. D is an invalid Decl).; // We use the dependent type for the RecoveryExpr to prevent bogus follow-up; // diagnostics, as invalid decls use int as a fallback type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:98,Safety,Recover,RecoveryExpr,98,"// Recovery from invalid cases (e.g. D is an invalid Decl).; // We use the dependent type for the RecoveryExpr to prevent bogus follow-up; // diagnostics, as invalid decls use int as a fallback type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:121,Integrability,depend,dependent,121,"// Check whether this declaration can be used. Note that we suppress; // this check when we're going to perform argument-dependent lookup; // on this function name, because this might not be the function; // that overload resolution actually selects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:104,Performance,perform,perform,104,"// Check whether this declaration can be used. Note that we suppress; // this check when we're going to perform argument-dependent lookup; // on this function name, because this might not be the function; // that overload resolution actually selects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:102,Usability,simpl,simply,102,"// In 'T ...V;', the type of the declaration 'V' is 'T...', but the type of; // a reference to 'V' is simply (unexpanded) 'T'. The type, like the value,; // is expanded by some outer '...' in the context of the use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:98,Integrability,depend,dependent,98,// Enum constants are always r-values and never references.; // Unresolved using declarations are dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:68,Integrability,depend,depending,68,// Non-type template parameters are either l-values or r-values; // depending on the type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:104,Modifiability,variab,variable,104,"// FIXME: Does the addition of const really only apply in; // potentially-evaluated contexts? Since the variable isn't actually; // captured in an unevaluated context, it seems that the answer is no.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:149,Availability,Recover,RecoveryExpr,149,// Clang AST consumers assume a DeclRefExpr refers to a valid decl. We; // wrap a DeclRefExpr referring to an invalid decl with a dependent-type; // RecoveryExpr to avoid follow-up semantic analysis (thus prevent bogus; // diagnostics).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:75,Integrability,wrap,wrap,75,// Clang AST consumers assume a DeclRefExpr refers to a valid decl. We; // wrap a DeclRefExpr referring to an invalid decl with a dependent-type; // RecoveryExpr to avoid follow-up semantic analysis (thus prevent bogus; // diagnostics).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:130,Integrability,depend,dependent-type,130,// Clang AST consumers assume a DeclRefExpr refers to a valid decl. We; // wrap a DeclRefExpr referring to an invalid decl with a dependent-type; // RecoveryExpr to avoid follow-up semantic analysis (thus prevent bogus; // diagnostics).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:149,Safety,Recover,RecoveryExpr,149,// Clang AST consumers assume a DeclRefExpr refers to a valid decl. We; // wrap a DeclRefExpr referring to an invalid decl with a dependent-type; // RecoveryExpr to avoid follow-up semantic analysis (thus prevent bogus; // diagnostics).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:165,Safety,avoid,avoid,165,// Clang AST consumers assume a DeclRefExpr refers to a valid decl. We; // wrap a DeclRefExpr referring to an invalid decl with a dependent-type; // RecoveryExpr to avoid follow-up semantic analysis (thus prevent bogus; // diagnostics).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:25,Availability,error,error,25,"// Overflow is always an error, but underflow is only an error if; // we underflowed to zero (APFloat reports denormals as underflow).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:57,Availability,error,error,57,"// Overflow is always an error, but underflow is only an error if; // we underflowed to zero (APFloat reports denormals as underflow).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:253,Safety,safe,safe,253,"// NumericLiteralParser wants to overread by one character. Add padding to; // the buffer in case the token is copied to the buffer. If getSpelling(); // returns a StringRef to the memory buffer, it should have a null char at; // the EOF, so it is also safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Performance,Perform,Perform,3,// Perform literal operator lookup to determine if we're building a raw; // literal or a cooked one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:10,Availability,failure,failure,10,"// Lookup failure for imaginary constants isn't fatal, there's still the; // GNU extension producing _Complex types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:166,Usability,clear,clear,166,"// 'wb/uwb' literals are a C23 feature. We support _BitInt as a type in C++,; // but we do not currently support the suffix in C++ mode because it's not; // entirely clear whether WG21 will prefer this suffix to return a library; // type such as std::bit_int instead of returning a _BitInt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:64,Integrability,depend,depends,64,"// Get the value in the widest-possible width. What is ""widest"" depends on; // whether the literal is a bit-precise integer or not. For a bit-precise; // integer type, try to scan the source to determine how many bits are; // needed to represent the value. This may seem a bit expensive, but trying; // to get the integer value from an overly-wide APInt is *extremely*; // expensive, so the naive approach of assuming; // llvm::IntegerType::MAX_INT_BITS is a big performance hit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:463,Performance,perform,performance,463,"// Get the value in the widest-possible width. What is ""widest"" depends on; // whether the literal is a bit-precise integer or not. For a bit-precise; // integer type, try to scan the source to determine how many bits are; // needed to represent the value. This may seem a bit expensive, but trying; // to get the integer value from an overly-wide APInt is *extremely*; // expensive, so the naive approach of assuming; // llvm::IntegerType::MAX_INT_BITS is a big performance hit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:44,Availability,error,error,44,"// If this value didn't fit into uintmax_t, error and force to ull.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:64,Integrability,wrap,wrapper,64,"// If this is an imaginary literal, create the ImaginaryLiteral wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:56,Performance,scalab,scalable,56,// builtin_vectorelements supports both fixed-sized and scalable vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:30,Availability,error,errors,30,// Invalid types must be hard errors for SFINAE in C++.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:91,Availability,error,error,91,"// Allow sizeof(void)/alignof(void) as an extension, unless in OpenCL where; // this is an error (OpenCL v1.1 s6.3.k)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:17,Integrability,interface,interface,17,// Reject sizeof(interface) and sizeof(interface<proto>) if the; // runtime doesn't allow it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:39,Integrability,interface,interface,39,// Reject sizeof(interface) and sizeof(interface<proto>) if the; // runtime doesn't allow it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:140,Security,validat,validates,140,"/// Check the constraints on expression operands to unary type expression; /// and type traits.; ///; /// Completes any types necessary and validates the constraints on the operand; /// expression. The logic mostly mirrors the type-based overload, but may modify; /// the expression as it completes the type for that expression through template; /// instantiation, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:202,Testability,log,logic,202,"/// Check the constraints on expression operands to unary type expression; /// and type traits.; ///; /// Completes any types necessary and validates the constraints on the operand; /// expression. The logic mostly mirrors the type-based overload, but may modify; /// the expression as it completes the type for that expression through template; /// instantiation, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:166,Integrability,depend,dependent,166,"// The operand for sizeof and alignof is in an unevaluated expression context,; // so side effects could result in unintended consequences.; // Exclude instantiation-dependent expressions, because 'sizeof' is sometimes; // used to build SFINAE gadgets.; // FIXME: Should we consider instantiation-dependent operands to 'alignof'?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:297,Integrability,depend,dependent,297,"// The operand for sizeof and alignof is in an unevaluated expression context,; // so side effects could result in unintended consequences.; // Exclude instantiation-dependent expressions, because 'sizeof' is sometimes; // used to build SFINAE gadgets.; // FIXME: Should we consider instantiation-dependent operands to 'alignof'?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:50,Integrability,depend,dependent,50,// Cannot know anything else if the expression is dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:240,Security,access,access,240,"// If it's a field, require the containing struct to have a; // complete definition so that we can compute the layout.; //; // This can happen in C++11 onwards, either by naming the member; // in a way that is not transformed into a member access expression; // (in an unevaluated operand, for instance), or by naming the member; // in a trailing-return-type.; //; // For the record, since __alignof__ on expressions is a GCC; // extension, GCC seems to permit this but always gives the; // nonsensical answer 0.; //; // We don't really need the layout here --- we could instead just; // directly check for all the appropriate alignment-lowing; // attributes --- but that would require duplicating a lot of; // logic that just isn't worth duplicating for such a marginal; // use-case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:711,Testability,log,logic,711,"// If it's a field, require the containing struct to have a; // complete definition so that we can compute the layout.; //; // This can happen in C++11 onwards, either by naming the member; // in a way that is not transformed into a member access expression; // (in an unevaluated operand, for instance), or by naming the member; // in a trailing-return-type.; //; // For the record, since __alignof__ on expressions is a GCC; // extension, GCC seems to permit this but always gives the; // nonsensical answer 0.; //; // We don't really need the layout here --- we could instead just; // directly check for all the appropriate alignment-lowing; // attributes --- but that would require duplicating a lot of; // logic that just isn't worth duplicating for such a marginal; // use-case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:125,Modifiability,flexible,flexible,125,"// Otherwise, if it's a field, and the field doesn't have; // reference type, then it must have a complete type (or be a; // flexible array member, which we explicitly want to; // white-list anyway), which makes the following checks trivial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:50,Integrability,depend,dependent,50,// Cannot know anything else if the expression is dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:23,Availability,down,down,23,// We're going to walk down into the type and look for VLA expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:25,Modifiability,variab,variably-modified,25,// These types are never variably-modified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:262,Integrability,rout,routine,262,"/// Check the constraints on operands to unary expression and type; /// traits.; ///; /// This will complete any types necessary, and validate the various constraints; /// on those operands.; ///; /// The UsualUnaryConversions() function is *not* called by this routine.; /// C99 6.3.2.1p[2-4] all state:; /// Except when it is the operand of the sizeof operator ...; ///; /// C++ [expr.sizeof]p4; /// The lvalue-to-rvalue, array-to-pointer, and function-to-pointer; /// standard conversions are not applied to the operand of sizeof.; ///; /// This policy is followed for all of the unary trait expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:134,Security,validat,validate,134,"/// Check the constraints on operands to unary expression and type; /// traits.; ///; /// This will complete any types necessary, and validate the various constraints; /// on those operands.; ///; /// The UsualUnaryConversions() function is *not* called by this routine.; /// C99 6.3.2.1p[2-4] all state:; /// Except when it is the operand of the sizeof operator ...; ///; /// C++ [expr.sizeof]p4; /// The lvalue-to-rvalue, array-to-pointer, and function-to-pointer; /// standard conversions are not applied to the operand of sizeof.; ///; /// This policy is followed for all of the unary trait expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,Integrability,depend,dependent,32,// Delay type-checking for type-dependent expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:6,Availability,error,error,6,"// If error parsing type, ignore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Testability,Test,Test,3,// Test for placeholders.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:91,Availability,error,error,91,/// Diagnose if arithmetic on the given ObjC pointer is illegal.; ///; /// \return true on error,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:69,Integrability,depend,dependent,69,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:102,Integrability,Depend,DependentTy,102,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:204,Integrability,depend,dependent,204,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:251,Integrability,depend,dependent,251,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:286,Integrability,depend,dependent,286,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:386,Integrability,depend,dependent-sized,386,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:451,Integrability,depend,dependent-typed,451,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:540,Integrability,depend,dependent,540,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:576,Integrability,Depend,DependentTy,576,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:619,Integrability,depend,dependent,619,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:650,Integrability,depend,dependent,650,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:598,Safety,avoid,avoids,598,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:699,Safety,avoid,avoid,699,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:22,Integrability,depend,dependent,22,// Ensure we return a dependent type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:60,Integrability,depend,dependent,60,// Build an unanalyzed expression if either operand is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:375,Testability,log,logic,375,"// Use C++ overloaded-operator rules if either operand has record; // type. The spec says to do this if either type is *overloadable*,; // but enum types can't declare subscript operators or conversion; // operators, so there's nothing interesting for overload resolution; // to do if there aren't any record types involved.; //; // ObjC pointers have their own subscripting logic that is not tied; // to overload resolution and so should not take this path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:65,Integrability,depend,dependent,65,// Build an unanalyzed expression if any of the operands is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:58,Security,access,access,58,// Bail if the element is an array since it is not memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:51,Security,access,access,51,// Check if the base type is a pointer to a member access of a struct; // marked with noderef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:17,Security,access,access,17,// Not a pointer access,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:60,Integrability,depend,dependent,60,// Build an unanalyzed expression if either operand is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Performance,Perform,Perform,3,// Perform default conversions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:59,Availability,error,error,59,// Always try to create iterator declarator to avoid extra error messages; // about unknown declarations use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:65,Integrability,message,messages,65,// Always try to create iterator declarator to avoid extra error messages; // about unknown declarations use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:47,Safety,avoid,avoid,47,// Always try to create iterator declarator to avoid extra error messages; // about unknown declarations use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:24,Modifiability,variab,variable,24,/// Act on the iterator variable declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:51,Availability,error,error,51,// Invalidate all created iterator declarations if error is found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:17,Deployability,update,update,17,// Build counter update.; // Build counter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:17,Deployability,update,update,17,// Build counter update.; // I = Begini + counter * Stepi;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:51,Availability,error,error,51,// Invalidate all created iterator declarations if error is found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Performance,Perform,Perform,3,// Perform default conversions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:14,Testability,log,logic,14,// Use custom logic if this should be the pseudo-object subscript; // expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:20,Usability,clear,cleared,20,"// If we've already cleared out the location for the default argument,; // that means we're parsing it right now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Availability,Recover,Recover,3,"// Recover by marking the field invalid, unless we're in a SFINAE context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Safety,Recover,Recover,3,"// Recover by marking the field invalid, unless we're in a SFINAE context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:278,Integrability,rout,routine,278,"/// ConvertArgumentsForCall - Converts the arguments specified in; /// Args/NumArgs to the parameter types of the function FDecl with; /// function prototype Proto. Call is the call expression itself, and; /// Fn is the function expression. For a C++ member function, this; /// routine does not attempt to convert the object argument. Returns; /// true if the call is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:25,Modifiability,config,config,25,/* kernel function (exec config) */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:28,Availability,avail,available,28,"// If too few arguments are available (and we don't have default; // arguments for the remaining parameters), don't make the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:44,Availability,error,error,44,"// If too many are passed and not variadic, error on the extras and drop; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:43,Security,audit,audited,43,// Remember that parameter belongs to a CF audited API.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:443,Security,access,access,443,"/// CheckStaticArrayArgument - If the given argument corresponds to a static; /// array parameter, check that it is non-null, and that if it is formed by; /// array-to-pointer decay, the underlying array is sufficiently large.; ///; /// C99 6.7.5.3p7: If the keyword static also appears within the [ and ] of the; /// array type derivation, then for each call to the function, the value of the; /// corresponding actual argument shall provide access to the first element of; /// an array with at least as many elements as specified by the size expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:102,Security,expose,exposed,102,"// In practice we'll never use this, since all SVE types are sugared; // via TypedefTypes rather than exposed directly as BuiltinTypes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:88,Availability,failure,failure,88,// Apply this processing to all the arguments at once instead of; // dying at the first failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:371,Modifiability,rewrite,rewrite,371,"/// If a builtin function has a pointer argument with no explicit address; /// space, then it should be able to accept a pointer to any address; /// space as input. In order to do this, we need to replace the; /// standard builtin declaration with one that uses the same address space; /// as the call.; ///; /// \returns nullptr If this builtin is not a candidate for a rewrite i.e.; /// it does not contain any pointer arguments without; /// an address space qualifer. Otherwise the rewritten; /// FunctionDecl is returned.; /// TODO: Handle pointer return types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:41,Usability,simpl,simplify,41,// Convert array arguments to pointer to simplify type lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:216,Security,access,access,216,// If the unresolved member functions were found in a 'naming class' that is; // related (either the same or derived from) to the class that contains the; // member function that itself contained the implicit member access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:36,Integrability,depend,dependent,36,"// If the enclosing function is not dependent, then this lambda is; // capture ready, so if we can capture this, do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:31,Integrability,depend,dependent,31,"// Determine whether this is a dependent call inside a C++ template,; // in which case we won't do any semantic analysis now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:36,Testability,log,logic,36,// We aren't supposed to apply this logic if there's an '&' involved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the function decl for this builtin by replacing parameters; // with no explicit address space with the address space of the arguments; // in ArgExprs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:327,Performance,perform,perform,327,"// If this expression is a call to a builtin function in HIP device; // compilation, allow a pointer-type argument to default address space to be; // passed as a pointer-type parameter to a non-default address space.; // If Arg is declared in the default address space and Param is declared; // in a non-default address space, perform an implicit address space cast to; // the parameter type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:11,Performance,perform,perform,11,// Finally perform an implicit address space cast,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:275,Availability,avail,available,275,"/// BuildResolvedCallExpr - Build a call to a resolved expression,; /// i.e. an expression not of \p OverloadTy. The expression should; /// unary-convert to an expression of function-pointer or; /// block-pointer type.; ///; /// \param NDecl the declaration being called, if available",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:390,Energy Efficiency,efficient,efficient,390,"// Interrupt handlers don't save off the VFP regs automatically on ARM,; // so there's some risk when calling out to non-interrupt handler functions; // that the callee might not preserve them. This is easy to diagnose here,; // but can be very challenging to debug.; // Likewise, X86 interrupt handlers may only call routines with attribute; // no_caller_saved_registers since there is no efficient way to; // save and restore the non-GPR state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:318,Integrability,rout,routines,318,"// Interrupt handlers don't save off the VFP regs automatically on ARM,; // so there's some risk when calling out to non-interrupt handler functions; // that the callee might not preserve them. This is easy to diagnose here,; // but can be very challenging to debug.; // Likewise, X86 interrupt handlers may only call routines with attribute; // no_caller_saved_registers since there is no efficient way to; // save and restore the non-GPR state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:92,Safety,risk,risk,92,"// Interrupt handlers don't save off the VFP regs automatically on ARM,; // so there's some risk when calling out to non-interrupt handler functions; // that the callee might not preserve them. This is easy to diagnose here,; // but can be very challenging to debug.; // Likewise, X86 interrupt handlers may only call routines with attribute; // no_caller_saved_registers since there is no efficient way to; // save and restore the non-GPR state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:79,Energy Efficiency,allocate,allocate,79,"// Get the number of parameters in the function prototype, if any.; // We will allocate space for max(Args.size(), NumParams) arguments; // in the call expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:144,Integrability,depend,dependent,144,"// C cannot always handle TypoExpr nodes in builtin calls and direct; // function calls as their argument checking don't necessarily handle; // dependent types properly, so make sure any TypoExprs have been; // dealt with.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:43,Modifiability,config,configured,43,// CUDA: Calls to global functions must be configured,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:367,Integrability,interface,interface,367,"// If we still haven't found a prototype to use but there are arguments to; // the call, diagnose this as calling a function without a prototype.; // However, if we found a function declaration, check to see if; // -Wdeprecated-non-prototype was disabled where the function was declared.; // If so, we will silence the diagnostic here on the assumption that this; // interface is intentional and the user knows what they're doing. We will; // also silence the diagnostic if there is a function declaration but it; // was implicitly defined (the user already gets diagnostics about the; // creation of the implicit function declaration, so the additional warning; // is not helpful).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:34,Security,secur,security,34,// Warn for unions passing across security boundary (CMSE).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:263,Availability,error,error,263,"// C23 6.7.10p4: An entity of variable length array type shall not be; // initialized except by an empty initializer.; //; // The C extension warnings are issued from ParseBraceInitializer() and; // do not need to be issued here. However, we continue to issue an error; // in the case there are initializers or we are compiling C++. We allow; // use of VLAs in C++, but it's not clear we want to allow {} to zero; // init a VLA in C++ in all cases (such as with non-trivial constructors).; // FIXME: should we allow this construct in C++ when it makes sense to do; // so?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:30,Modifiability,variab,variable,30,"// C23 6.7.10p4: An entity of variable length array type shall not be; // initialized except by an empty initializer.; //; // The C extension warnings are issued from ParseBraceInitializer() and; // do not need to be issued here. However, we continue to issue an error; // in the case there are initializers or we are compiling C++. We allow; // use of VLAs in C++, but it's not clear we want to allow {} to zero; // init a VLA in C++ in all cases (such as with non-trivial constructors).; // FIXME: should we allow this construct in C++ when it makes sense to do; // so?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:379,Usability,clear,clear,379,"// C23 6.7.10p4: An entity of variable length array type shall not be; // initialized except by an empty initializer.; //; // The C extension warnings are issued from ParseBraceInitializer() and; // do not need to be issued here. However, we continue to issue an error; // in the case there are initializers or we are compiling C++. We allow; // use of VLAs in C++, but it's not clear we want to allow {} to zero; // init a VLA in C++ in all cases (such as with non-trivial constructors).; // FIXME: should we allow this construct in C++ when it makes sense to do; // so?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:499,Modifiability,extend,extending,499,"// In C, compound literals are l-values for some reason.; // For GCC compatibility, in C++, file-scope array compound literals with; // constant initializers are also l-values, and compound literals are; // otherwise prvalues.; //; // (GCC also treats C++ list-initialized file-scope array prvalues with; // constant initializers as l-values, but that's non-conforming, so we don't; // follow it there.); //; // FIXME: It would be better to handle the lvalue cases as materializing and; // lifetime-extending a temporary object, but our materialized temporaries; // representation only supports lifetime extension from a variable, not ""out; // of thin air"".; // FIXME: For C++, we might want to instead lifetime-extend only if a pointer; // is bound to the result of applying array-to-pointer decay to the compound; // literal.; // FIXME: GCC supports compound literals of reference type, which should; // obviously have a value kind derived from the kind of reference involved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:621,Modifiability,variab,variable,621,"// In C, compound literals are l-values for some reason.; // For GCC compatibility, in C++, file-scope array compound literals with; // constant initializers are also l-values, and compound literals are; // otherwise prvalues.; //; // (GCC also treats C++ list-initialized file-scope array prvalues with; // constant initializers as l-values, but that's non-conforming, so we don't; // follow it there.); //; // FIXME: It would be better to handle the lvalue cases as materializing and; // lifetime-extending a temporary object, but our materialized temporaries; // representation only supports lifetime extension from a variable, not ""out; // of thin air"".; // FIXME: For C++, we might want to instead lifetime-extend only if a pointer; // is bound to the result of applying array-to-pointer decay to the compound; // literal.; // FIXME: GCC supports compound literals of reference type, which should; // obviously have a value kind derived from the kind of reference involved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:712,Modifiability,extend,extend,712,"// In C, compound literals are l-values for some reason.; // For GCC compatibility, in C++, file-scope array compound literals with; // constant initializers are also l-values, and compound literals are; // otherwise prvalues.; //; // (GCC also treats C++ list-initialized file-scope array prvalues with; // constant initializers as l-values, but that's non-conforming, so we don't; // follow it there.); //; // FIXME: It would be better to handle the lvalue cases as materializing and; // lifetime-extending a temporary object, but our materialized temporaries; // representation only supports lifetime extension from a variable, not ""out; // of thin air"".; // FIXME: For C++, we might want to instead lifetime-extend only if a pointer; // is bound to the result of applying array-to-pointer decay to the compound; // literal.; // FIXME: GCC supports compound literals of reference type, which should; // obviously have a value kind derived from the kind of reference involved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:10,Availability,failure,failures,10,// Ignore failures; dropping the entire initializer list because; // of one failure would be terrible for indexing/etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:76,Availability,failure,failure,76,// Ignore failures; dropping the entire initializer list because; // of one failure would be terrible for indexing/etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:19,Modifiability,extend,extend,19,/// Do an explicit extend of the given block pointer if we're in ARC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,Performance,perform,performing,32,"/// Prepares for a scalar cast, performing all the necessary stages; /// except the final cast and returning the kind required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:15,Usability,simpl,simple,15,// Vectors are simple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:113,Performance,scalab,scalable,113,/// Are the two types RVV-bitcast-compatible types? I.e. is bitcasting from the; /// first RVV type (e.g. an RVV scalable type) to the second type (e.g. an RVV; /// VLS type) allowed?; ///; /// This will also return false if the two given types do not make sense from; /// the perspective of RVV bitcasts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:68,Energy Efficiency,power,power,68,"// ASTContext::getTypeSize will return the size rounded up to a; // power of 2, so instead of using that, we need to use the raw; // element size multiplied by the element count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:144,Integrability,depend,depend,144,"// Disallow lax conversions between scalars and ExtVectors (these; // conversions are allowed for other vector types because common headers; // depend on them). Most scalar OP ExtVector cases are handled by the; // splat path anyway, which does what we want (convert, not bitcast).; // What this rules out for ExtVectors is crazy things like char4*float.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:6,Safety,avoid,avoid,6,"// To avoid having to have a CK_BooleanToSignedFloating cast kind, we cast; // in two steps: boolean to signed integral, then to floating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:21,Testability,assert,assertion,21,// isa<ParenExpr> by assertion at function entrance,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:37,Modifiability,extend,extend,37,"// OpenCL v2.0 specification doesn't extend compatibility of type qualifiers; // (C99 6.7.3) for address spaces. We assume that the check should behave in; // the same manner as it's defined for CVR qualifiers, so for OpenCL two; // qual types are compatible iff; // * corresponded types are compatible; // * CVR qualifiers are equal; // * address spaces are equal; // Thus for conditional operator we merge CVR and address space unqualified; // pointees and if there is a composite type we return a pointer to it with; // merged qualifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:4,Usability,Simpl,Simple,4,"/// Simple conversion between integer and floating point types.; ///; /// Used when handling the OpenCL conditional operator where the; /// condition is a vector while the other operands are scalar.; ///; /// OpenCL v1.1 s6.3.i and s6.11.6 together require that the scalar; /// types are either integer or floating type. Between the two; /// operands, the type with the higher rank is defined as the ""result; /// type"". The other operand needs to be promoted to the same type. No; /// other type promotion is allowed. We cannot use; /// UsualArithmeticConversions() for this purpose, since it always; /// promotes promotable types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:199,Security,access,access,199,"// Handle things like Class and struct objc_class*. Here we case the result; // to the pseudo-builtin, because that will be implicitly cast back to the; // redefinition type if an attempt is made to access its fields.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:24,Integrability,interface,interfaces,24,"// If both operands are interfaces and either operand can be; // assigned to the other, use that type as the composite; // type. This allows; // xxx ? (A*) a : (B*) b; // where B is a subclass of A.; //; // Additionally, as for assignment, if either type is 'id'; // allow silent coercion. Finally, if the types are; // incompatible then make sure to use 'id' as the composite; // type so the result is acceptable for sending messages to.; // FIXME: Consider unifying with 'areComparableObjCPointerTypes'.; // It could return the composite type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:426,Integrability,message,messages,426,"// If both operands are interfaces and either operand can be; // assigned to the other, use that type as the composite; // type. This allows; // xxx ? (A*) a : (B*) b; // where B is a subclass of A.; //; // Additionally, as for assignment, if either type is 'id'; // allow silent coercion. Finally, if the types are; // incompatible then make sure to use 'id' as the composite; // type so the result is acceptable for sending messages to.; // FIXME: Consider unifying with 'areComparableObjCPointerTypes'.; // It could return the composite type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:149,Usability,clear,clear,149,"// Need to handle ""id<xx>"" explicitly.; // GCC allows qualified id and any Objective-C type to devolve to; // id. Currently localizing to here until clear this should be; // part of ObjCQualifiedIdTypesAreCompatible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:60,Integrability,wrap,wraps,60,/// SuggestParentheses - Emit a note with a fixit hint that wraps; /// ParenRange in parentheses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:95,Testability,log,logical,95,"// This only checks for bitwise-or and bitwise-and, but not bitwise-xor and; // not any of the logical operators. Bitwise-xor is commonly used as a; // logical-xor because there is no logical-xor operator. The logical; // operators, including uses of xor, have a high false positive rate for; // precedence warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:152,Testability,log,logical-xor,152,"// This only checks for bitwise-or and bitwise-and, but not bitwise-xor and; // not any of the logical operators. Bitwise-xor is commonly used as a; // logical-xor because there is no logical-xor operator. The logical; // operators, including uses of xor, have a high false positive rate for; // precedence warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:184,Testability,log,logical-xor,184,"// This only checks for bitwise-or and bitwise-and, but not bitwise-xor and; // not any of the logical operators. Bitwise-xor is commonly used as a; // logical-xor because there is no logical-xor operator. The logical; // operators, including uses of xor, have a high false positive rate for; // precedence warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:210,Testability,log,logical,210,"// This only checks for bitwise-or and bitwise-and, but not bitwise-xor and; // not any of the logical operators. Bitwise-xor is commonly used as a; // logical-xor because there is no logical-xor operator. The logical; // operators, including uses of xor, have a high false positive rate for; // precedence warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:54,Safety,safe,safe,54,"// Make sure this is really a binary operator that is safe to pass into; // BinaryOperator::getOverloadedOpcode(), e.g. it's not a subscript op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:94,Testability,log,logical,94,"/// ExprLooksBoolean - Returns true if E looks boolean, i.e. it has boolean type; /// or is a logical expression such as (x==y) which has int type, but is; /// commonly interpreted as boolean.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:81,Integrability,depend,dependent,81,"// C cannot handle TypoExpr nodes in the condition because it; // doesn't handle dependent types properly, so make sure any TypoExprs have; // been dealt with before checking the operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:91,Safety,safe,safely,91,"// If the common expression is a class or array prvalue, materialize it; // so that we can safely refer to it multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Availability,checkPoint,checkPointerTypesForAssignment,3,// checkPointerTypesForAssignment - This is a very tricky routine (despite; // being closely modeled after the C99 spec:-). The odd characteristic of this; // routine is it effectively iqnores the qualifiers on the top level pointee.; // This circumvents the usual type rules specified in 6.2.7p1 & 6.7.5.[1-3].; // FIXME: add a couple examples in this comment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:58,Integrability,rout,routine,58,// checkPointerTypesForAssignment - This is a very tricky routine (despite; // being closely modeled after the C99 spec:-). The odd characteristic of this; // routine is it effectively iqnores the qualifiers on the top level pointee.; // This circumvents the usual type rules specified in 6.2.7p1 & 6.7.5.[1-3].; // FIXME: add a couple examples in this comment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:159,Integrability,rout,routine,159,// checkPointerTypesForAssignment - This is a very tricky routine (despite; // being closely modeled after the C99 spec:-). The odd characteristic of this; // routine is it effectively iqnores the qualifiers on the top level pointee.; // This circumvents the usual type rules specified in 6.2.7p1 & 6.7.5.[1-3].; // FIXME: add a couple examples in this comment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:68,Usability,simpl,simply,68,"// If we are a multi-level pointer, it's possible that our issue is simply; // one of qualification - e.g. char ** -> const char ** is not allowed. If; // the eventual target type is the same and the pointers have the same; // level of indirection, this must be the issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:270,Usability,clear,clear,270,"// Inconsistent address spaces at this point is invalid, even if the; // address spaces would be compatible.; // FIXME: This doesn't catch address space mismatches for pointers of; // different nesting levels, like:; // __local int *** a;; // int ** b = a;; // It's not clear how to actually determine when such pointers are; // invalidly incompatible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:47,Integrability,rout,routine,47,/// checkBlockPointerTypesForAssignment - This routine determines whether two; /// block pointer types are compatible or whether a block and normal pointer; /// are compatible. It is more restrict than comparing two function pointer; // types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:180,Modifiability,variab,variable,180,"// FIXME: OpenCL doesn't define the exact compile time semantics for a block; // assignment.; // The current behavior is similar to C++ lambdas. A block might be; // assigned to a variable iff its return type and parameters are compatible; // (C99 6.2.7) with the corresponding return type and parameters of the LHS of; // an assignment. Presumably it should behave in way that a function pointer; // assignment does in C, so for each parameter and return type:; // * CVR and address space of LHS should be a superset of CVR and address; // space of RHS.; // * unqualified types should be compatible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:51,Integrability,rout,routine,51,"/// CheckAssignmentConstraints (C99 6.5.16) - This routine currently; /// has code to accommodate several GCC extensions when type checking; /// pointers. Here are some objectionable examples that GCC considers warnings:; ///; /// int a, *pint;; /// short *pshort;; /// struct foo *pfoo;; ///; /// pint = pshort; // warning: assignment from incompatible pointer type; /// a = pint; // warning: assignment makes integer from pointer without a cast; /// pint = a; // warning: assignment makes pointer from integer without a cast; /// pint = pfoo; // warning: assignment from incompatible pointer type; ///; /// As a result, the code for dealing with pointers is more complex than the; /// C99 spec dictates.; ///; /// Sets 'Kind' for any result kind except Incompatible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:69,Usability,simpl,simply,69,// Disallow assigning a _Complex to a real type in C++ mode since it simply; // discards the imaginary part.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:174,Deployability,update,updated,174,"// If ConvertRHS is false, we want to leave the caller's RHS untouched. Sadly,; // we can't avoid *all* modifications at the moment, so we need some somewhere; // to put the updated value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:92,Safety,avoid,avoid,92,"// If ConvertRHS is false, we want to leave the caller's RHS untouched. Sadly,; // we can't avoid *all* modifications at the moment, so we need some somewhere; // to put the updated value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:488,Performance,Perform,PerformImplicitConversion,488,"// This check seems unnatural, however it is necessary to ensure the proper; // conversion of functions/arrays. If the conversion were done for all; // DeclExpr's (created by ActOnIdExpression), it would mess up the unary; // expressions that suppress this implicit conversion (&, sizeof). This needs; // to happen before we check for null pointer conversions because C does not; // undergo the same implicit conversions as C++ does above (by the calls to; // TryImplicitConversion() and PerformImplicitConversion()) which insert the; // lvalue to rvalue cast before checking for null pointer constraints. This; // addresses code like: nullptr_t val; int *ptr; ptr = val;; //; // Suppress this for references: C++ 8.5.3p5.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:25,Energy Efficiency,allocate,allocate,25,// FIXME: We potentially allocate here even if ConvertRHS is false.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:33,Availability,error,errors,33,"// Check for various Objective-C errors. If we are not reporting; // diagnostics and just checking for errors, e.g., during overload; // resolution, return Incompatible to indicate the failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:103,Availability,error,errors,103,"// Check for various Objective-C errors. If we are not reporting; // diagnostics and just checking for errors, e.g., during overload; // resolution, return Incompatible to indicate the failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:185,Availability,failure,failure,185,"// Check for various Objective-C errors. If we are not reporting; // diagnostics and just checking for errors, e.g., during overload; // resolution, return Incompatible to indicate the failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:91,Availability,error,errors,91,// Replace the expression with a corrected version and continue so we; // can find further errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:133,Availability,error,error,133,"// Diagnose cases where a scalar was implicitly converted to a vector and; // diagnose the underlying types. Otherwise, diagnose the error; // as invalid vector logical operands for non-C++ cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:161,Testability,log,logical,161,"// Diagnose cases where a scalar was implicitly converted to a vector and; // diagnose the underlying types. Otherwise, diagnose the error; // as invalid vector logical operands for non-C++ cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:367,Availability,error,error,367,"/// Try to convert a value of non-vector type to a vector type by converting; /// the type to the element type of the vector and then performing a splat.; /// If the language is OpenCL, we only use conversions that promote scalar; /// rank; for C, Obj-C, and C++ we allow any real scalar conversion except; /// for float->int.; ///; /// OpenCL V2.0 6.2.6.p2:; /// An error shall occur if any scalar operand type has greater rank; /// than the type of the vector element.; ///; /// \param scalar - if non-null, actually perform the conversions; /// \return true if the operation fails (but without diagnosing the failure)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:612,Availability,failure,failure,612,"/// Try to convert a value of non-vector type to a vector type by converting; /// the type to the element type of the vector and then performing a splat.; /// If the language is OpenCL, we only use conversions that promote scalar; /// rank; for C, Obj-C, and C++ we allow any real scalar conversion except; /// for float->int.; ///; /// OpenCL V2.0 6.2.6.p2:; /// An error shall occur if any scalar operand type has greater rank; /// than the type of the vector element.; ///; /// \param scalar - if non-null, actually perform the conversions; /// \return true if the operation fails (but without diagnosing the failure)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:134,Performance,perform,performing,134,"/// Try to convert a value of non-vector type to a vector type by converting; /// the type to the element type of the vector and then performing a splat.; /// If the language is OpenCL, we only use conversions that promote scalar; /// rank; for C, Obj-C, and C++ we allow any real scalar conversion except; /// for float->int.; ///; /// OpenCL V2.0 6.2.6.p2:; /// An error shall occur if any scalar operand type has greater rank; /// than the type of the vector element.; ///; /// \param scalar - if non-null, actually perform the conversions; /// \return true if the operation fails (but without diagnosing the failure)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:519,Performance,perform,perform,519,"/// Try to convert a value of non-vector type to a vector type by converting; /// the type to the element type of the vector and then performing a splat.; /// If the language is OpenCL, we only use conversions that promote scalar; /// rank; for C, Obj-C, and C++ we allow any real scalar conversion except; /// for float->int.; ///; /// OpenCL V2.0 6.2.6.p2:; /// An error shall occur if any scalar operand type has greater rank; /// than the type of the vector element.; ///; /// \param scalar - if non-null, actually perform the conversions; /// \return true if the operation fails (but without diagnosing the failure)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:4,Testability,Test,Test,4,/// Test if a (constant) integer Int can be casted to another integer type; /// IntTy without losing precision.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:4,Testability,Test,Test,4,/// Test if a (constant) integer Int can be casted to floating point type; /// FloatTy without losing precision.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:215,Safety,avoid,avoided,215,// Reject constants that would be truncated if they were converted to; // the floating point type. Test by simple to/from conversion.; // FIXME: Ideally the conversion to an APFloat and from an APFloat; // could be avoided if there was a convertFromAPInt method; // which could signal back if implicit truncation occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:99,Testability,Test,Test,99,// Reject constants that would be truncated if they were converted to; // the floating point type. Test by simple to/from conversion.; // FIXME: Ideally the conversion to an APFloat and from an APFloat; // could be avoided if there was a convertFromAPInt method; // which could signal back if implicit truncation occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:107,Usability,simpl,simple,107,// Reject constants that would be truncated if they were converted to; // the floating point type. Test by simple to/from conversion.; // FIXME: Ideally the conversion to an APFloat and from an APFloat; // could be avoided if there was a convertFromAPInt method; // which could signal back if implicit truncation occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:257,Performance,perform,perform,257,"// Accept cases where the vector elements are integers and the scalar is; // an integer.; // FIXME: Notionally if the scalar was a floating point value with a precise; // integral representation, we could cast it to an appropriate integer; // type and then perform the rest of the checks here. GCC will perform; // this conversion in some cases as determined by the input language.; // We should accept it on a language independent basis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:303,Performance,perform,perform,303,"// Accept cases where the vector elements are integers and the scalar is; // an integer.; // FIXME: Notionally if the scalar was a floating point value with a precise; // integral representation, we could cast it to an appropriate integer; // type and then perform the rest of the checks here. GCC will perform; // this conversion in some cases as determined by the input language.; // We should accept it on a language independent basis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:83,Integrability,depend,dependent,83,"// Determine whether this is a constant scalar. In the event that the; // value is dependent (and thus cannot be evaluated by the constant; // evaluator), skip the evaluation. This will then diagnose once the; // expression is instantiated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:27,Safety,safe,safely,27,"// If the scalar cannot be safely casted to the vector element type,; // reject it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:29,Performance,perform,performed,29,// This operation may not be performed on boolean vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:107,Availability,down,down,107,"// FIXME: The code below also handles conversion between vectors and; // non-scalars, we should break this down into fine grained specific checks; // and emit proper diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:87,Availability,error,error,87,"// OpenCL V1.1 6.2.6.p1:; // If the operands are of more than one vector type, then an error shall; // occur. Implicit conversions between vector types are not permitted, per; // section 6.2.1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:25,Safety,Detect,Detect,25,// checkArithmeticNull - Detect when a NULL constant is used improperly in an; // expression. These are mainly cases where the null pointer is used as an; // integer instead of a pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Safety,Avoid,Avoid,3,// Avoid analyzing cases where the result will either be invalid (and; // diagnosed as such) or entirely valid and not something to warn about.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:9,Availability,error,error,9,/// Emit error if Operand is incomplete pointer type; ///; /// \returns True if pointer has incomplete type,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:101,Integrability,rout,routine,101,"/// Check the validity of a binary arithmetic operation w.r.t. pointer; /// operands.; ///; /// This routine will diagnose any invalid arithmetic on pointer operands much; /// like \see checkArithmeticOpPointerOperand. However, it has special logic; /// for emitting a single diagnostic even for operations where both LHS and RHS; /// are (potentially problematic) pointers.; ///; /// \returns True when the operand is valid to use (even if as an extension).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:243,Testability,log,logic,243,"/// Check the validity of a binary arithmetic operation w.r.t. pointer; /// operands.; ///; /// This routine will diagnose any invalid arithmetic on pointer operands much; /// like \see checkArithmeticOpPointerOperand. However, it has special logic; /// for emitting a single diagnostic even for operations where both LHS and RHS; /// are (potentially problematic) pointers.; ///; /// \returns True when the operand is valid to use (even if as an extension).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:9,Availability,error,error,9,/// Emit error when two pointers are incompatible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:41,Integrability,interface,interface,41,// Diagnose bad cases where we step over interface counts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:221,Integrability,wrap,wrap,221,"// Don't warn if signed overflow is defined, then all the rest of the; // diagnostics will not be triggered because the behavior is defined.; // Also don't warn in C++20 mode (and newer), as signed left shifts; // always wrap and never overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:47,Integrability,rout,routine,47,// Note that LHS might be a scalar because the routine calls not only in; // OpenCL case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:16,Performance,perform,perform,16,"// Shifts don't perform usual arithmetic conversions, they just do integer; // promotions on each operand. C99 6.5.7p3; // For the LHS, do usual unary conversions, but then reset them away; // if this is a compound assignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:14,Usability,simpl,simpler,14,// The RHS is simpler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:102,Performance,perform,performed,102,// C++ [expr.rel]p2:; // [...] Pointer conversions (4.10) and qualification; // conversions (4.4) are performed on pointer operands (or on; // a pointer operand and a null pointer constant) to bring; // them to their composite pointer type. [...]; //; // C++ [expr.eq]p1 uses the same notion for (in)equality; // comparisons of pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:24,Integrability,interface,interface,24,// Get the LHS object's interface type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:9,Integrability,protocol,protocols,9,// Check protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:170,Availability,error,errors,170,"// For non-floating point types, check for self-comparisons of the form; // x == x, x != x, x < x, etc. These always evaluate to a constant, and; // often indicate logic errors in the program.; //; // NOTE: Don't warn about comparison expressions resulting from macro; // expansion. Also don't warn about comparisons which are only self; // comparisons within a template instantiation. The warnings should catch; // obvious cases in the definition of the template anyways. The idea is to; // warn when the typed comparison operator will always evaluate to the same; // result.; // Used for indexing into %select in warn_comparison_always",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:164,Testability,log,logic,164,"// For non-floating point types, check for self-comparisons of the form; // x == x, x != x, x < x, etc. These always evaluate to a constant, and; // often indicate logic errors in the program.; //; // NOTE: Don't warn about comparison expressions resulting from macro; // expansion. Also don't warn about comparisons which are only self; // comparisons within a template instantiation. The warnings should catch; // obvious cases in the definition of the template anyways. The idea is to; // warn when the typed comparison operator will always evaluate to the same; // result.; // Used for indexing into %select in warn_comparison_always",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:75,Integrability,depend,dependent,75,"// Implicit conversion to a narrower type, but the expression is; // value-dependent so we can't tell whether it's actually narrowing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:153,Safety,avoid,avoid,153,"// We can't use `CK_IntegralCast` when the underlying type is 'bool', so we; // promote the boolean type, and all other promotable integer types, to; // avoid this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:124,Performance,perform,performed,124,"// C++2a [expr.spaceship]p6: If at least one of the operands is of pointer; // type, array-to-pointer, ..., conversions are performed on both operands to; // bring them to their composite type.; // Otherwise, all comparisons expect an rvalue, so convert to rvalue before; // any type-related checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:102,Availability,error,error,102,"// This is a gcc extension compatibility comparison.; // In a SFINAE context, we treat this as a hard error to maintain; // conformance with the C++ standard.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:99,Testability,test,test,99,"// FIXME: If LPtrToVoid, we should presumably convert the LHS rather than; // the RHS, but we have test coverage for this behavior.; // FIXME: Consider using convertPointersToCompositeType in C++.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:276,Safety,avoid,avoid,276,"// Return a signed ext_vector_type that is of identical size and number of; // elements. For floating point vectors, return an integer type of identical; // size and number of elements. In the non ext_vector_type case, search from; // the largest type to the smallest type to avoid cases where long long == long,; // where long gets picked over long long.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:96,Modifiability,extend,extended,96,"/// CheckVectorCompareOperands - vector comparisons are a clang extension that; /// operates on extended vector types. Instead of producing an IntTy result,; /// like a scalar comparison, a vector comparison produces a vector of integer; /// types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:170,Availability,error,errors,170,"// For non-floating point types, check for self-comparisons of the form; // x == x, x != x, x < x, etc. These always evaluate to a constant, and; // often indicate logic errors in the program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:164,Testability,log,logic,164,"// For non-floating point types, check for self-comparisons of the form; // x == x, x != x, x < x, etc. These always evaluate to a constant, and; // often indicate logic errors in the program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:170,Availability,error,errors,170,"// For non-floating point types, check for self-comparisons of the form; // x == x, x != x, x < x, etc. These always evaluate to a constant, and; // often indicate logic errors in the program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:164,Testability,log,logic,164,"// For non-floating point types, check for self-comparisons of the form; // x == x, x != x, x < x, etc. These always evaluate to a constant, and; // often indicate logic errors in the program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:92,Testability,log,logical,92,// FIXME: The check for C++ here is for GCC compatibility. GCC rejects the; // usage of the logical operators && and || with vectors in C. This; // check could be notionally dropped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:41,Testability,log,logical,41,// WebAssembly tables can't be used with logical operators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:41,Testability,log,logical,41,// Diagnose cases where the user write a logical and/or but probably meant a; // bitwise one. We do this when the LHS is a non-bool integer and the RHS; // is a constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:126,Testability,log,logical,126,"// If the RHS can be constant folded, and if it constant folds to something; // that isn't 0 or 1 (which indicate a potential logical operation that; // happened to fold to true/false) then warn.; // Parens on the RHS are ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:25,Testability,log,logical,25,// Suggest replacing the logical operator with the bitwise version,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:27,Testability,log,logical,27,"// OpenCL v1.1 s6.3.g: The logical operators and (&&), or (||) do; // not operate on the built-in scalar and vector float types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:20,Safety,safe,safe,20,// The following is safe because we only use this method for; // non-overloadable operands.; // C++ [expr.log.and]p1; // C++ [expr.log.or]p1; // The operands are both contextually converted to type bool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:106,Testability,log,log,106,// The following is safe because we only use this method for; // non-overloadable operands.; // C++ [expr.log.and]p1; // C++ [expr.log.or]p1; // The operands are both contextually converted to type bool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:131,Testability,log,log,131,// The following is safe because we only use this method for; // non-overloadable operands.; // C++ [expr.log.and]p1; // C++ [expr.log.or]p1; // The operands are both contextually converted to type bool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:13,Testability,log,log,13,// C++ [expr.log.and]p2; // C++ [expr.log.or]p2; // The result is a bool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:38,Testability,log,log,38,// C++ [expr.log.and]p2; // C++ [expr.log.or]p2; // The result is a bool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:74,Modifiability,variab,variable,74,"/// Is the given expression (which must be 'const') a reference to a; /// variable which was originally non-const, but which has become; /// 'const' due to being captured within a block?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:29,Modifiability,variab,variable,29,// The declaration must be a variable which is not declared 'const'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:45,Modifiability,variab,variable,45,"// For init-capture, it is possible that the variable belongs to the; // template pattern of the current context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Deployability,Update,Update,3,// Update err_typecheck_assign_const and note_typecheck_assign_const; // when this enum is changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:49,Availability,error,error,49,"/// Emit the ""read-only variable not assignable"" error and print notes to give; /// more information about why the variable is not assignable, such as pointing; /// to the declaration of a const variable, showing that a method is const, or; /// that the function is returning a const reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:24,Modifiability,variab,variable,24,"/// Emit the ""read-only variable not assignable"" error and print notes to give; /// more information about why the variable is not assignable, such as pointing; /// to the declaration of a const variable, showing that a method is const, or; /// that the function is returning a const reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:115,Modifiability,variab,variable,115,"/// Emit the ""read-only variable not assignable"" error and print notes to give; /// more information about why the variable is not assignable, such as pointing; /// to the declaration of a const variable, showing that a method is const, or; /// that the function is returning a const reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:195,Modifiability,variab,variable,195,"/// Emit the ""read-only variable not assignable"" error and print notes to give; /// more information about why the variable is not assignable, such as pointing; /// to the declaration of a const variable, showing that a method is const, or; /// that the function is returning a const reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:17,Availability,error,error,17,// Only emit one error on the first const found. All other consts will emit; // a note to the error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:94,Availability,error,error,94,// Only emit one error on the first const found. All other consts will emit; // a note to the error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:24,Modifiability,inherit,inherit,24,// Static fields do not inherit constness from parents.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:12,Modifiability,variab,variable,12,// Point to variable declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:67,Availability,error,error,67,"// Can't determine a more specific message, so display the generic error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:35,Integrability,message,message,35,"// Can't determine a more specific message, so display the generic error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:12,Availability,error,error,12,/// Emit an error for the case where a record we are trying to assign to has a; /// const-qualified field somewhere in its hierarchy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:90,Availability,error,error,90,"/// CheckForModifiableLvalue - Verify that E is a modifiable lvalue. If not,; /// emit an error and return true. If so, return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:117,Modifiability,variab,variables,117,"// In ARC, use some specialized diagnostics for occasions where we; // infer 'const'. These are always pseudo-strong variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:22,Modifiability,variab,variables,22,// - fast enumeration variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:72,Usability,simpl,simple,72,"// If none of the special cases above are triggered, then this is a; // simple const assignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:24,Modifiability,variab,variables,24,// Objective-C instance variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:52,Availability,error,error,52,"// Verify that LHS is a modifiable lvalue, and emit error if not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:95,Modifiability,variab,variable,95,"// Warn about retain cycles where a block captures the LHS, but; // not if the LHS is a simple variable into which the block is; // being stored...unless that variable can be captured by reference!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:159,Modifiability,variab,variable,159,"// Warn about retain cycles where a block captures the LHS, but; // not if the LHS is a simple variable into which the block is; // being stored...unless that variable can be captured by reference!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:88,Usability,simpl,simple,88,"// Warn about retain cycles where a block captures the LHS, but; // not if the LHS is a simple variable into which the block is; // being stored...unless that variable can be captured by reference!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:55,Modifiability,variab,variable,55,"// It is safe to assign a weak reference into a strong variable.; // Although this code can still have problems:; // id x = self.weakProp;; // id y = self.weakProp;; // we do not warn to warn spuriously when 'x' and 'y' are on separate; // paths through the function. This should be revisited if; // -Wrepeated-use-of-weak is made flow-sensitive.; // For ObjCWeak only, we do not warn if the assign is to a non-weak; // variable, which will be valid for the current autorelease scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:420,Modifiability,variab,variable,420,"// It is safe to assign a weak reference into a strong variable.; // Although this code can still have problems:; // id x = self.weakProp;; // id y = self.weakProp;; // we do not warn to warn spuriously when 'x' and 'y' are on separate; // paths through the function. This should be revisited if; // -Wrepeated-use-of-weak is made flow-sensitive.; // For ObjCWeak only, we do not warn if the assign is to a non-weak; // variable, which will be valid for the current autorelease scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:9,Safety,safe,safe,9,"// It is safe to assign a weak reference into a strong variable.; // Although this code can still have problems:; // id x = self.weakProp;; // id y = self.weakProp;; // we do not warn to warn spuriously when 'x' and 'y' are on separate; // paths through the function. This should be revisited if; // -Wrepeated-use-of-weak is made flow-sensitive.; // For ObjCWeak only, we do not warn if the assign is to a non-weak; // variable, which will be valid for the current autorelease scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:29,Usability,simpl,simple-assignment,29,// C++2a [expr.ass]p5:; // A simple-assignment whose left operand is of a volatile-qualified; // type is deprecated unless the assignment is either a discarded-value; // expression or an unevaluated operand,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:26,Integrability,depend,dependent,26,// static_cast<void> on a dependent type will not show up as CK_ToVoid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:430,Testability,log,logic,430,"// Scope isn't fine-grained enough to explicitly list the specific cases, so; // instead, skip more than needed, then call back into here with the; // CommaVisitor in SemaStmt.cpp.; // The listed locations are the initialization and increment portions; // of a for loop. The additional checks are on the condition of; // if statements, do/while loops, and for loops.; // Differences in scope flags for C89 mode requires the extra logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:13,Performance,perform,performs,13,"// C's comma performs lvalue conversion (C99 6.3.2.1) on both its; // operands, but not unary promotions.; // C++'s comma does not do any conversions at all (C++ [expr.comma]p1).; // So we treat the LHS as a ignored value, and in C++ we allow the; // containing site to determine what should be done with the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:71,Integrability,rout,routine,71,"/// CheckIncrementDecrementOperand - unlike most ""Check"" methods, this routine; /// doesn't need to call UsualUnaryConversions or UsualArithmeticConversions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Availability,Error,Error,3,// Error on enum increments and decrements in C++ mode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:76,Integrability,rout,routine,76,"/// getPrimaryDecl - Helper function for CheckAddressOfOperand().; /// This routine allows us to typecheck complex/recursive expressions; /// where the declaration is needed for type checking. We only need to; /// handle cases when the expression references a function designator; /// or is an lvalue. Here are some examples:; /// - &(x) => x; /// - &*****f => f for f a function designator.; /// - &s.xx => s; /// - &s.zz[1].yy -> s, if zz is an array; /// - *(x + 1) -> x, if x is an array; /// - &""123""[2] -> 0; /// - & __real__ x -> x; ///; /// FIXME: We don't recurse to the RHS of a comma, nor handle pointers to; /// members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:188,Integrability,depend,depending,188,// In OpenCL captures for blocks called as lambda functions; // are located in the private address space. Blocks used in; // enqueue_kernel can be located in a different address space; // depending on a vendor implementation. Thus preventing; // taking an address of the capture to avoid invalid AS casts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:282,Safety,avoid,avoid,282,// In OpenCL captures for blocks called as lambda functions; // are located in the private address space. Blocks used in; // enqueue_kernel can be located in a different address space; // depending on a vendor implementation. Thus preventing; // taking an address of the capture to avoid invalid AS casts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:26,Availability,down,down,26,"// Under the MS ABI, lock down the inheritance model now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:35,Modifiability,inherit,inheritance,35,"// Under the MS ABI, lock down the inheritance model now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,Performance,load,loads,32,// Use a special diagnostic for loads from property references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:20,Availability,error,error,20,// in C++ it is not error to take address of a register; // variable (c++03 7.1.1P3),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:60,Modifiability,variab,variable,60,// in C++ it is not error to take address of a register; // variable (c++03 7.1.1P3),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:26,Availability,down,down,26,"// Under the MS ABI, lock down the inheritance model now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:35,Modifiability,inherit,inheritance,35,"// Under the MS ABI, lock down the inheritance model now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,Modifiability,variab,variable,32,"// Taking the address of a void variable is technically illegal, but we; // allow it in cases which are otherwise valid.; // Example: ""extern void x; void* y = &x;"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:28,Performance,perform,performed,28,/// Check if a bitwise-& is performed on an Objective-C pointer. This; /// is usually indicative of introspection within the Objective-C pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:54,Energy Efficiency,reduce,reduce,54,"// This warning is deliberately made very specific to reduce false; // positives with logic that uses '&' for hashing. This logic mainly; // looks for code trying to introspect into tagged pointers, which; // code should generally never do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:110,Security,hash,hashing,110,"// This warning is deliberately made very specific to reduce false; // positives with logic that uses '&' for hashing. This logic mainly; // looks for code trying to introspect into tagged pointers, which; // code should generally never do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:86,Testability,log,logic,86,"// This warning is deliberately made very specific to reduce false; // positives with logic that uses '&' for hashing. This logic mainly; // looks for code trying to introspect into tagged pointers, which; // code should generally never do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:124,Testability,log,logic,124,"// This warning is deliberately made very specific to reduce false; // positives with logic that uses '&' for hashing. This logic mainly; // looks for code trying to introspect into tagged pointers, which; // code should generally never do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:51,Performance,perform,performSelectorXXX,51,// Determine if we are introspecting the result of performSelectorXXX.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:16,Integrability,message,messages,16,"// Special case messages to -performSelector and friends, which; // can return non-pointer values boxed in a pointer value.; // Some clients may wish to silence warnings in this subcase.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:29,Performance,perform,performSelector,29,"// Special case messages to -performSelector and friends, which; // can return non-pointer values boxed in a pointer value.; // Some clients may wish to silence warnings in this subcase.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:90,Integrability,depend,dependent,90,"// C cannot handle TypoExpr nodes on either side of a binop because it; // doesn't handle dependent types properly, so make sure any TypoExprs have; // been dealt with before checking the operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:2,Availability,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:2,Safety,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Safety,Avoid,Avoid,3,// Avoid correcting the RHS to the same Expr as the LHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:119,Integrability,rout,routine,119,/// CreateBuiltinBinOp - Creates a new built-in binary operation with; /// operator @p Opc at location @c TokLoc. This routine only supports; /// built-in operations; ActOnBinOp handles overloaded operators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:61,Modifiability,variab,variables,61,// Result type of the binary operator.; // The following two variables are used for compound assignment operators,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:41,Modifiability,variab,variables,41,// OpenCLC v2.0 s6.13.11.1 allows atomic variables to be initialized by; // the ATOMIC_VAR_INIT macro.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:82,Modifiability,variab,variable,82,// Avoid copying a block to the heap if the block is assigned to a local; // auto variable that is declared in the same scope as the block. This; // optimization is unsafe if the local variable is declared in an outer; // scope. For example:; //; // BlockTy b;; // {; // b = ^{...};; // }; // // It is unsafe to invoke the block here if it wasn't copied to the; // // heap.; // b();,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:185,Modifiability,variab,variable,185,// Avoid copying a block to the heap if the block is assigned to a local; // auto variable that is declared in the same scope as the block. This; // optimization is unsafe if the local variable is declared in an outer; // scope. For example:; //; // BlockTy b;; // {; // b = ^{...};; // }; // // It is unsafe to invoke the block here if it wasn't copied to the; // // heap.; // b();,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:149,Performance,optimiz,optimization,149,// Avoid copying a block to the heap if the block is assigned to a local; // auto variable that is declared in the same scope as the block. This; // optimization is unsafe if the local variable is declared in an outer; // scope. For example:; //; // BlockTy b;; // {; // b = ^{...};; // }; // // It is unsafe to invoke the block here if it wasn't copied to the; // // heap.; // b();,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Safety,Avoid,Avoid,3,// Avoid copying a block to the heap if the block is assigned to a local; // auto variable that is declared in the same scope as the block. This; // optimization is unsafe if the local variable is declared in an outer; // scope. For example:; //; // BlockTy b;; // {; // b = ^{...};; // }; // // It is unsafe to invoke the block here if it wasn't copied to the; // // heap.; // b();,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:165,Safety,unsafe,unsafe,165,// Avoid copying a block to the heap if the block is assigned to a local; // auto variable that is declared in the same scope as the block. This; // optimization is unsafe if the local variable is declared in an outer; // scope. For example:; //; // BlockTy b;; // {; // b = ^{...};; // }; // // It is unsafe to invoke the block here if it wasn't copied to the; // // heap.; // b();,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:302,Safety,unsafe,unsafe,302,// Avoid copying a block to the heap if the block is assigned to a local; // auto variable that is declared in the same scope as the block. This; // optimization is unsafe if the local variable is declared in an outer; // scope. For example:; //; // BlockTy b;; // {; // b = ^{...};; // }; // // It is unsafe to invoke the block here if it wasn't copied to the; // // heap.; // b();,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:50,Testability,log,logical,50,// Bitwise operations are sometimes used as eager logical ops.; // Don't diagnose this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:109,Integrability,wrap,wraps,109,/// It accepts a '&&' expr that is inside a '||' one.; /// Emit a diagnostic together with a fixit hint that wraps the '&&' expression; /// in parentheses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:147,Integrability,wrap,wraps,147,/// Look for bitwise op in the left or right hand of a bitwise op with; /// lower precedence and emit a diagnostic together with a fixit hint that wraps; /// the '&' expression in parentheses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:116,Safety,safe,safe,116,"// Warn about arg1 || arg2 && arg3, as GCC 4.3+ does.; // We don't warn for 'assert(a || b && ""bad"")' since this is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:77,Testability,assert,assert,77,"// Warn about arg1 || arg2 && arg3, as GCC 4.3+ does.; // We don't warn for 'assert(a || b && ""bad"")' since this is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:82,Usability,simpl,simple,82,"// In the non-overloaded case, we warn about self-assignment (x = x) for; // both simple assignment and certain compound assignments where algebra; // tells us the operation yields a constant result. When the operator is; // overloaded, we can't do the latter because we don't want to assume that; // those algebraic identities still apply; for example, a path-building; // library might use operator/= to append paths. But it's still reasonable; // to assume that simple assignment is just moving/copying values around; // and so self-assignment is likely a bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:465,Usability,simpl,simple,465,"// In the non-overloaded case, we warn about self-assignment (x = x) for; // both simple assignment and certain compound assignments where algebra; // tells us the operation yields a constant result. When the operator is; // overloaded, we can't do the latter because we don't want to assume that; // those algebraic identities still apply; for example, a path-building; // library might use operator/= to append paths. But it's still reasonable; // to assume that simple assignment is just moving/copying values around; // and so self-assignment is likely a bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:50,Integrability,depend,dependent,50,"// Build the (potentially-overloaded, potentially-dependent); // binary operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:182,Integrability,depend,dependent,182,"// We want to end up calling one of checkPseudoObjectAssignment; // (if the LHS is a pseudo-object), BuildOverloadedBinOp (if; // both expressions are overloadable or either is type-dependent),; // or CreateBuiltinBinOp (in any other case). We also want to get; // any placeholder types out of the way.; // Handle pseudo-objects in the LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:221,Integrability,depend,dependently-typed,221,"// We can't actually test that if we still have a placeholder,; // though. Fortunately, none of the exceptions we see in that; // code below are valid when the LHS is an overload set. Note; // that an overload set can be dependently-typed, but it never; // instantiates to having an overloadable type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:21,Testability,test,test,21,"// We can't actually test that if we still have a placeholder,; // though. Fortunately, none of the exceptions we see in that; // code below are valid when the LHS is an overload set. Note; // that an overload set can be dependently-typed, but it never; // instantiates to having an overloadable type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,Integrability,depend,dependent,32,"// If either expression is type-dependent, always build an; // overloaded op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Testability,log,logical,3,"// logical negation; // Unlike +/-/~, integer promotions aren't done here (C99 6.5.3.3p5).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:26,Testability,log,logical,26,// OpenCL v1.1 6.3.h: The logical operator not (!) does not; // operate on scalar float types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:26,Testability,log,logical,26,// OpenCL v1.1 6.3.h: The logical operator not (!) does not; // operate on vector float types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:10,Testability,log,logical,10,// Vector logical not returns the signed variant of the operand type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:10,Testability,log,logical,10,// Vector logical not returns the signed variant of the operand type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:70,Security,access,access,70,"/// Determine whether the given expression is a qualified member; /// access expression, of a form that could be turned into a pointer to member; /// with the address-of operator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:18,Testability,log,logic,18,// & gets special logic for several kinds of placeholder.; // The builtin code knows what to do.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:62,Modifiability,variab,variable,62,// Type must be complete per C99 7.17p3 because a declaring a variable; // with an incomplete type would be ill-formed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:61,Integrability,depend,dependent,61,"// We have the offset of a field, but we can't look into the dependent; // type. Just record the identifier of the field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:59,Modifiability,variab,variable,59,"// Lookup could be ambiguous when looking up a placeholder variable; // __builtin_offsetof(S, _).; // In that case we would already have emitted a diagnostic",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:119,Availability,error,error,119,"// C99 7.17p3:; // (If the specified member is a bit-field, the behavior is undefined.); //; // We diagnose this as an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:11,Integrability,Depend,DependentTy,11,"// Context.DependentTy is used as a placeholder for a missing block; // return type. TODO: what should we do with declarators like:; // ^ * { ... }; // If the answer is ""apply template argument deduction""....",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:21,Modifiability,variab,variables,21,"// Fake up parameter variables if we have a typedef, like; // ^ fntype { ... }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:21,Modifiability,variab,variables,21,// Put the parameter variables in scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:37,Availability,error,error,37,"/// ActOnBlockError - If there is an error parsing a block, this callback; /// is invoked to pop the information about the block from the action impl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:35,Availability,error,error,35,"// If blocks are disabled, emit an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:39,Performance,optimiz,optimization,39,"// Try to apply the named return value optimization. We have to check again; // if we can do this, though, because blocks keep return statements around; // to deduce an implicit return type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:20,Modifiability,variab,variables,20,// Set the captured variables on the block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:119,Modifiability,variab,variables,119,"// The capture logic needs the destructor, so make sure we mark it.; // Usually this is unnecessary because most local variables have; // their destructors marked at declaration time, but parameters are; // an exception because it's technically only the call site that; // actually requires the destructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:15,Testability,log,logic,15,"// The capture logic needs the destructor, so make sure we mark it.; // Usually this is unnecessary because most local variables have; // their destructors marked at declaration time, but parameters are; // an exception because it's technically only the call site that; // actually requires the destructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:50,Modifiability,variab,variable,50,"// According to the blocks spec, the capture of a variable from; // the stack requires a const copy constructor. This is not true; // of the copy/move done to move a __block variable to the heap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:174,Modifiability,variab,variable,174,"// According to the blocks spec, the capture of a variable from; // the stack requires a const copy constructor. This is not true; // of the copy/move done to move a __block variable to the heap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:111,Availability,Recover,Recover,111,// Build a full-expression copy expression if initialization; // succeeded and used a non-trivial constructor. Recover from; // errors by pretending that the copy isn't necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:128,Availability,error,errors,128,// Build a full-expression copy expression if initialization; // succeeded and used a non-trivial constructor. Recover from; // errors by pretending that the copy isn't necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:111,Safety,Recover,Recover,111,// Build a full-expression copy expression if initialization; // succeeded and used a non-trivial constructor. Recover from; // errors by pretending that the copy isn't necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:39,Availability,alive,alive,39,// Pop the block scope now but keep it alive to the end of this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:68,Modifiability,variab,variables,68,// It also gets a branch-protected scope if any of the captured; // variables needs destruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:1064,Testability,test,test,1064,"// [cstdarg.syn]p1 defers the C++ behavior to what the C standard says,; // and C23 7.16.1.1p2 says, in part:; // If type is not compatible with the type of the actual next argument; // (as promoted according to the default argument promotions), the; // behavior is undefined, except for the following cases:; // - both types are pointers to qualified or unqualified versions of; // compatible types;; // - one type is compatible with a signed integer type, the other; // type is compatible with the corresponding unsigned integer type,; // and the value is representable in both types;; // - one type is pointer to qualified or unqualified void and the; // other is a pointer to a qualified or unqualified character type;; // - or, the type of the next argument is nullptr_t and type is a; // pointer type that has the same representation and alignment; // requirements as a pointer to a character type.; // Given that type compatibility is the primary requirement (ignoring; // qualifications), you would think we could call typesAreCompatible(); // directly to test this. However, in C++, that checks for *same type*,; // which causes false positives when passing an enumeration type to; // va_arg. Instead, get the underlying type of the enumeration and pass; // that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:53,Testability,test,test,53,"// If the types are still not compatible, we need to test whether the; // promoted type and the underlying type are the same except for; // signedness. Ask the AST for the correctly corresponding type and see; // if that's compatible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:43,Integrability,depend,depending,43,"// The type of __null will be int or long, depending on the size of; // pointers on the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Performance,Perform,Perform,3,// Perform array-to-pointer decay if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:162,Availability,error,error,162,"// If the qualifiers lost were because we were applying the; // (deprecated) C++ conversion from a string literal to a char*; // (or wchar_t*), then there was no error (C++ 4.2p2). FIXME:; // Ideally, this check would be performed in; // checkPointerTypesForAssignment. However, that would require a; // bit of refactoring (so that the second argument is an; // expression, rather than a type), which should be done as part; // of a larger effort to fix checkPointerTypesForAssignment for; // C++ semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:238,Availability,checkPoint,checkPointerTypesForAssignment,238,"// If the qualifiers lost were because we were applying the; // (deprecated) C++ conversion from a string literal to a char*; // (or wchar_t*), then there was no error (C++ 4.2p2). FIXME:; // Ideally, this check would be performed in; // checkPointerTypesForAssignment. However, that would require a; // bit of refactoring (so that the second argument is an; // expression, rather than a type), which should be done as part; // of a larger effort to fix checkPointerTypesForAssignment for; // C++ semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:454,Availability,checkPoint,checkPointerTypesForAssignment,454,"// If the qualifiers lost were because we were applying the; // (deprecated) C++ conversion from a string literal to a char*; // (or wchar_t*), then there was no error (C++ 4.2p2). FIXME:; // Ideally, this check would be performed in; // checkPointerTypesForAssignment. However, that would require a; // bit of refactoring (so that the second argument is an; // expression, rather than a type), which should be done as part; // of a larger effort to fix checkPointerTypesForAssignment for; // C++ semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:311,Modifiability,refactor,refactoring,311,"// If the qualifiers lost were because we were applying the; // (deprecated) C++ conversion from a string literal to a char*; // (or wchar_t*), then there was no error (C++ 4.2p2). FIXME:; // Ideally, this check would be performed in; // checkPointerTypesForAssignment. However, that would require a; // bit of refactoring (so that the second argument is an; // expression, rather than a type), which should be done as part; // of a larger effort to fix checkPointerTypesForAssignment for; // C++ semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:221,Performance,perform,performed,221,"// If the qualifiers lost were because we were applying the; // (deprecated) C++ conversion from a string literal to a char*; // (or wchar_t*), then there was no error (C++ 4.2p2). FIXME:; // Ideally, this check would be performed in; // checkPointerTypesForAssignment. However, that would require a; // bit of refactoring (so that the second argument is an; // expression, rather than a type), which should be done as part; // of a larger effort to fix checkPointerTypesForAssignment for; // C++ semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:39,Safety,avoid,avoid,39,// Circumvent ICE checking in C++11 to avoid evaluating the expression twice; // in the non-ICE case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:145,Availability,redundant,redundant,145,"// If our only note is the usual ""invalid subexpression"" note, just point; // the caret at its location rather than producing an essentially; // redundant note.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:145,Safety,redund,redundant,145,"// If our only note is the usual ""invalid subexpression"" note, just point; // the caret at its location rather than producing an essentially; // redundant note.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:309,Availability,Error,Error,309,// We need to special-case DeclRefExprs referring to FieldDecls which; // are not part of a member pointer formation; normal TreeTransforming; // doesn't catch this case because of the way we represent them in the AST.; // FIXME: This is a bit ugly; is it really the best way to handle this; // case?; //; // Error on DeclRefExprs referring to FieldDecls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:103,Usability,simpl,simple-assignment,103,"/// Check whether E, which is either a discarded-value expression or an; /// unevaluated operand, is a simple-assignment to a volatlie-qualified lvalue,; /// and if so, remove it from the list of volatile-qualified assignments that; /// we are going to warn are deprecated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:199,Safety,avoid,avoid,199,"/// Opportunistically remove the callee from ReferencesToConsteval if we can.; /// It's OK if this fails; we'll also remove this in; /// HandleImmediateInvocations, but catching it here allows us to avoid; /// walking the AST looking for it in simple cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:244,Usability,simpl,simple,244,"/// Opportunistically remove the callee from ReferencesToConsteval if we can.; /// It's OK if this fails; we'll also remove this in; /// HandleImmediateInvocations, but catching it here allows us to avoid; /// walking the AST looking for it in simple cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:637,Availability,error,error,637,"// Since an immediate invocation is a full expression itself - it requires; // an additional ExprWithCleanups node, but it can participate to a bigger; // full expression which actually requires cleanups to be run after so; // create ExprWithCleanups without using MaybeCreateExprWithCleanups as it; // may discard cleanups for outer expression too early.; // Note that ExprWithCleanups created here must always have empty cleanup; // objects:; // - compound literals do not create cleanup objects in C++ and immediate; // invocations are C++-only.; // - blocks are not allowed inside constant expressions and compiler will; // issue an error if they appear there.; //; // Hence, in correct code any cleanup objects created inside current; // evaluation context must be outside the immediate invocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:10,Integrability,depend,dependent,10,/// Value-dependent constant expressions should not be immediately; /// evaluated until they are instantiated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:29,Safety,avoid,avoid,29,// Do not rebuild lambdas to avoid creating a new type.; // Lambdas have already been processed inside their eval context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:64,Availability,error,errors,64,// The result may not be usable in case of previous compilation errors.; // In this case evaluation of the expression may result in crash so just; // don't do anything further with the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:25,Usability,usab,usable,25,// The result may not be usable in case of previous compilation errors.; // In this case evaluation of the expression may result in crash so just; // don't do anything further with the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:183,Safety,avoid,avoid,183,"/// When we have more than 1 ImmediateInvocationCandidates or previously; /// failed immediate invocations, we need to check for nested; /// ImmediateInvocationCandidates in order to avoid duplicate diagnostics.; /// Otherwise we only need to remove ReferenceToConsteval in the immediate; /// invocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:59,Availability,error,error,59,"// If the expression is immediate escalating, it is not an error;; // The outer context itself becomes immediate and further errors,; // if any, will be handled by DiagnoseImmediateEscalatingReason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:125,Availability,error,errors,125,"// If the expression is immediate escalating, it is not an error;; // The outer context itself becomes immediate and further errors,; // if any, will be handled by DiagnoseImmediateEscalatingReason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:34,Usability,simpl,simple-assignments,34,// Warn on any volatile-qualified simple-assignments that are not discarded-; // value expressions nor unevaluated operands (those cases get removed from; // this list by CheckUnusedVolatileAssignment).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:50,Usability,clear,clear,50,"// When are coming out of an unevaluated context, clear out any; // temporaries that we may have created as part of the evaluation of; // the expression in that context: they aren't relevant because they; // will never be constructed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:342,Availability,error,error,342,"/// Require that all of the parameter types of function be complete. Normally,; /// parameter types are only required to be complete when a function is called; /// or defined, but to mangle functions with certain calling conventions, the; /// mangler needs to know the size of the parameter list. In this situation,; /// MSVC doesn't emit an error or instantiate templates. Instead, MSVC mangles; /// the function as _foo@0, i.e. zero bytes of parameters, which will usually; /// result in a linker error. Clang doesn't implement this behavior, and instead; /// attempts to error at compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:499,Availability,error,error,499,"/// Require that all of the parameter types of function be complete. Normally,; /// parameter types are only required to be complete when a function is called; /// or defined, but to mangle functions with certain calling conventions, the; /// mangler needs to know the size of the parameter list. In this situation,; /// MSVC doesn't emit an error or instantiate templates. Instead, MSVC mangles; /// the function as _foo@0, i.e. zero bytes of parameters, which will usually; /// result in a linker error. Clang doesn't implement this behavior, and instead; /// attempts to error at compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:574,Availability,error,error,574,"/// Require that all of the parameter types of function be complete. Normally,; /// parameter types are only required to be complete when a function is called; /// or defined, but to mangle functions with certain calling conventions, the; /// mangler needs to know the size of the parameter list. In this situation,; /// MSVC doesn't emit an error or instantiate templates. Instead, MSVC mangles; /// the function as _foo@0, i.e. zero bytes of parameters, which will usually; /// result in a linker error. Clang doesn't implement this behavior, and instead; /// attempts to error at compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:75,Integrability,depend,dependent,75,"/// Declarations in this context are formally odr-used, but this is a; /// dependent context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:81,Modifiability,variab,variables,81,/// Are we within a context in which references to resolved functions or to; /// variables result in odr-use?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:706,Modifiability,variab,variable,706,"// Determine whether we require a function definition to exist, per; // C++11 [temp.inst]p3:; // Unless a function template specialization has been explicitly; // instantiated or explicitly specialized, the function template; // specialization is implicitly instantiated when the specialization is; // referenced in a context that requires a function definition to exist.; // C++20 [temp.inst]p7:; // The existence of a definition of a [...] function is considered to; // affect the semantics of the program if the [...] function is needed for; // constant evaluation by an expression; // C++20 [basic.def.odr]p10:; // Every program shall contain exactly one definition of every non-inline; // function or variable that is odr-used in that program outside of a; // discarded statement; // C++20 [special]p1:; // The implementation will implicitly define [defaulted special members]; // if they are odr-used or needed for constant evaluation.; //; // Note that we skip the implicit instantiation of templates that are only; // used in unused default arguments or by recursive calls to themselves.; // This is formally non-conforming, but seems reasonable in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:58,Safety,avoid,avoid,58,"// Do not defer instantiations of constexpr functions, to avoid the; // expression evaluator needing to call back into Sema if it sees a; // call to such a function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:346,Availability,redundant,redundant,346,"// In the MS C++ ABI, the compiler emits destructor variants where they are; // used. If the destructor is used here but defined elsewhere, mark the; // virtual base destructors referenced. If those virtual base destructors; // are inline, this will ensure they are defined when emitting the complete; // destructor variant. This checking may be redundant if the destructor is; // provided later in this TU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:346,Safety,redund,redundant,346,"// In the MS C++ ABI, the compiler emits destructor variants where they are; // used. If the destructor is used here but defined elsewhere, mark the; // virtual base destructors referenced. If those virtual base destructors; // are inline, this will ensure they are defined when emitting the complete; // destructor variant. This checking may be redundant if the destructor is; // provided later in this TU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:20,Modifiability,variab,variable,20,"/// Directly mark a variable odr-used. Given a choice, prefer to use; /// MarkVariableReferenced since it does additional checks and then; /// calls MarkVarDeclODRUsed.; /// If the variable must be captured:; /// - if FunctionScopeIndexToStopAt is null, capture it in the CurContext; /// - else capture it in the DeclContext that maps to the; /// *FunctionScopeIndexToStopAt on the FunctionScopeInfo stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:181,Modifiability,variab,variable,181,"/// Directly mark a variable odr-used. Given a choice, prefer to use; /// MarkVariableReferenced since it does additional checks and then; /// calls MarkVarDeclODRUsed.; /// If the variable must be captured:; /// - if FunctionScopeIndexToStopAt is null, capture it in the CurContext; /// - else capture it in the DeclContext that maps to the; /// *FunctionScopeIndexToStopAt on the FunctionScopeInfo stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:36,Modifiability,variab,variables,36,// Keep track of used but undefined variables.; // FIXME: We shouldn't suppress this warning for static data members.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:35,Modifiability,variab,variables,35,// Diagnose ODR-use of host global variables in device functions.; // Reference of device global variables in host functions is allowed; // through shadow variables therefore it is not diagnosed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:97,Modifiability,variab,variables,97,// Diagnose ODR-use of host global variables in device functions.; // Reference of device global variables in host functions is allowed; // through shadow variables therefore it is not diagnosed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:155,Modifiability,variab,variables,155,// Diagnose ODR-use of host global variables in device functions.; // Reference of device global variables in host functions is allowed; // through shadow variables therefore it is not diagnosed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:2,Modifiability,variab,variable,2,/*variable*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:33,Modifiability,variab,variable,33,"// Record a CUDA/HIP device side variable if it is ODR-used; // by host code. This is done conservatively, when the variable is; // referenced in any of the following contexts:; // - a non-function context; // - a host function; // - a host device function; // This makes the ODR-use of the device side variable by host code to; // be visible in the device compilation for the compiler to be able to; // emit template variables instantiated by host code only and to; // externalize the static device side variable ODR-used by host code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:116,Modifiability,variab,variable,116,"// Record a CUDA/HIP device side variable if it is ODR-used; // by host code. This is done conservatively, when the variable is; // referenced in any of the following contexts:; // - a non-function context; // - a host function; // - a host device function; // This makes the ODR-use of the device side variable by host code to; // be visible in the device compilation for the compiler to be able to; // emit template variables instantiated by host code only and to; // externalize the static device side variable ODR-used by host code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:303,Modifiability,variab,variable,303,"// Record a CUDA/HIP device side variable if it is ODR-used; // by host code. This is done conservatively, when the variable is; // referenced in any of the following contexts:; // - a non-function context; // - a host function; // - a host device function; // This makes the ODR-use of the device side variable by host code to; // be visible in the device compilation for the compiler to be able to; // emit template variables instantiated by host code only and to; // externalize the static device side variable ODR-used by host code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:418,Modifiability,variab,variables,418,"// Record a CUDA/HIP device side variable if it is ODR-used; // by host code. This is done conservatively, when the variable is; // referenced in any of the following contexts:; // - a non-function context; // - a host function; // - a host device function; // This makes the ODR-use of the device side variable by host code to; // be visible in the device compilation for the compiler to be able to; // emit template variables instantiated by host code only and to; // externalize the static device side variable ODR-used by host code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:505,Modifiability,variab,variable,505,"// Record a CUDA/HIP device side variable if it is ODR-used; // by host code. This is done conservatively, when the variable is; // referenced in any of the following contexts:; // - a non-function context; // - a host function; // - a host device function; // This makes the ODR-use of the device side variable by host code to; // be visible in the device compilation for the compiler to be able to; // emit template variables instantiated by host code only and to; // externalize the static device side variable ODR-used by host code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:359,Modifiability,variab,variable,359,"// For C code, don't diagnose about capture if we're not actually in code; // right now; it's impossible to write a non-constant expression outside of; // function context, so we'll get other (more useful) diagnostics later.; //; // For C++, things get a bit more nasty... it would be nice to suppress this; // diagnostic for certain cases like using a local variable in an array bound; // for a member of a local class, but the correct predicate is not obvious.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:38,Modifiability,variab,variable,38,// Retrieve the capture type for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:57,Modifiability,variab,variable,57,// Compute the type of an expression that refers to this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:101,Modifiability,variab,variables,101,"// Certain capturing entities (lambdas, blocks etc.) are not allowed to capture; // certain types of variables (unnamed, variably modified types etc.); // so check for eligibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:121,Modifiability,variab,variably,121,"// Certain capturing entities (lambdas, blocks etc.) are not allowed to capture; // certain types of variables (unnamed, variably modified types etc.); // so check for eligibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:46,Modifiability,variab,variables,46,"// Lambdas are not allowed to capture unnamed variables; // (e.g. anonymous unions).; // FIXME: The C++11 rule don't actually state this explicitly, but I'm; // assuming that's the intent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:12,Modifiability,variab,variably-modified,12,// Prohibit variably-modified types in blocks; they're difficult to deal with.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:25,Modifiability,flexible,flexible,25,// Prohibit structs with flexible array members too.; // We cannot capture what is in the tail end of the struct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:74,Modifiability,variab,variables,74,// Lambdas and captured statements are not allowed to capture __block; // variables; they don't support the expected semantics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:45,Modifiability,variab,variables,45,// Forbid the block-capture of autoreleasing variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:24,Modifiability,variab,variable,24,// Actually capture the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:22,Modifiability,variab,variable,22,/// Capture the given variable in the captured region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:23,Modifiability,variab,variables,23,"// By default, capture variables by reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:24,Modifiability,variab,variable,24,// Actually capture the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:22,Modifiability,variab,variable,22,/// Capture the given variable in the lambda.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:56,Modifiability,variab,variable,56,// Compute the type of the field that will capture this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:319,Usability,clear,clear,319,"// C++11 [expr.prim.lambda]p15:; // An entity is captured by reference if it is implicitly or; // explicitly captured but not captured by copy. It is; // unspecified whether additional unnamed non-static data; // members are declared in the closure type for entities; // captured by reference.; //; // FIXME: It is not clear whether we want to build an lvalue reference; // to the DeclRefType or to CaptureType.getNonReferenceType(). GCC appears; // to do the former, while EDG does the latter. Core issue 1249 will; // clarify, but for now we follow GCC because it's a more permissive and; // easily defensible position.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:51,Modifiability,variab,variables,51,// Forbid the lambda copy-capture of autoreleasing variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:52,Modifiability,variab,variable,52,// Compute the type of a reference to this captured variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:40,Integrability,depend,dependent,40,// Offer a Copy fix even if the type is dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:284,Modifiability,variab,variable,284,"/// Create up to 4 fix-its for explicit reference and value capture of \p Var or; /// default capture. Fixes may be omitted if they aren't allowed by the; /// standard, for example we can't emit a default copy capture fix-it if we; /// already explicitly copy capture capture another variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:53,Modifiability,variab,variable,53,"// Offer fixes to insert an explicit capture for the variable.; // [] -> [VarName]; // [OtherCapture] -> [OtherCapture, VarName]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:142,Modifiability,variab,variables,142,"// tryCaptureVariable is called every time a DeclRef is formed,; // it can therefore have non-negigible impact on performances.; // For local variables and when there is no capturing scope,; // we can bailout early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:114,Performance,perform,performances,114,"// tryCaptureVariable is called every time a DeclRef is formed,; // it can therefore have non-negigible impact on performances.; // For local variables and when there is no capturing scope,; // we can bailout early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:18,Modifiability,variab,variables,18,// Capture global variables if it is required to use private copy of this; // variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:78,Modifiability,variab,variable,78,// Capture global variables if it is required to use private copy of this; // variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:117,Integrability,depend,depend,117,"// Walk up the stack to determine whether we can capture the variable,; // performing the ""simple"" checks that don't depend on type. We stop when; // we've either hit the declared scope of the variable or find an existing; // capture of that variable. We start from the innermost capturing-entity; // (the DC) and ensure that all intervening capturing-entities; // (blocks/lambdas etc.) between the innermost capturer and the variable`s; // declcontext can either capture the variable or have already captured; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:61,Modifiability,variab,variable,61,"// Walk up the stack to determine whether we can capture the variable,; // performing the ""simple"" checks that don't depend on type. We stop when; // we've either hit the declared scope of the variable or find an existing; // capture of that variable. We start from the innermost capturing-entity; // (the DC) and ensure that all intervening capturing-entities; // (blocks/lambdas etc.) between the innermost capturer and the variable`s; // declcontext can either capture the variable or have already captured; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:193,Modifiability,variab,variable,193,"// Walk up the stack to determine whether we can capture the variable,; // performing the ""simple"" checks that don't depend on type. We stop when; // we've either hit the declared scope of the variable or find an existing; // capture of that variable. We start from the innermost capturing-entity; // (the DC) and ensure that all intervening capturing-entities; // (blocks/lambdas etc.) between the innermost capturer and the variable`s; // declcontext can either capture the variable or have already captured; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:242,Modifiability,variab,variable,242,"// Walk up the stack to determine whether we can capture the variable,; // performing the ""simple"" checks that don't depend on type. We stop when; // we've either hit the declared scope of the variable or find an existing; // capture of that variable. We start from the innermost capturing-entity; // (the DC) and ensure that all intervening capturing-entities; // (blocks/lambdas etc.) between the innermost capturer and the variable`s; // declcontext can either capture the variable or have already captured; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:426,Modifiability,variab,variable,426,"// Walk up the stack to determine whether we can capture the variable,; // performing the ""simple"" checks that don't depend on type. We stop when; // we've either hit the declared scope of the variable or find an existing; // capture of that variable. We start from the innermost capturing-entity; // (the DC) and ensure that all intervening capturing-entities; // (blocks/lambdas etc.) between the innermost capturer and the variable`s; // declcontext can either capture the variable or have already captured; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:476,Modifiability,variab,variable,476,"// Walk up the stack to determine whether we can capture the variable,; // performing the ""simple"" checks that don't depend on type. We stop when; // we've either hit the declared scope of the variable or find an existing; // capture of that variable. We start from the innermost capturing-entity; // (the DC) and ensure that all intervening capturing-entities; // (blocks/lambdas etc.) between the innermost capturer and the variable`s; // declcontext can either capture the variable or have already captured; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:518,Modifiability,variab,variable,518,"// Walk up the stack to determine whether we can capture the variable,; // performing the ""simple"" checks that don't depend on type. We stop when; // we've either hit the declared scope of the variable or find an existing; // capture of that variable. We start from the innermost capturing-entity; // (the DC) and ensure that all intervening capturing-entities; // (blocks/lambdas etc.) between the innermost capturer and the variable`s; // declcontext can either capture the variable or have already captured; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:75,Performance,perform,performing,75,"// Walk up the stack to determine whether we can capture the variable,; // performing the ""simple"" checks that don't depend on type. We stop when; // we've either hit the declared scope of the variable or find an existing; // capture of that variable. We start from the innermost capturing-entity; // (the DC) and ensure that all intervening capturing-entities; // (blocks/lambdas etc.) between the innermost capturer and the variable`s; // declcontext can either capture the variable or have already captured; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:91,Usability,simpl,simple,91,"// Walk up the stack to determine whether we can capture the variable,; // performing the ""simple"" checks that don't depend on type. We stop when; // we've either hit the declared scope of the variable or find an existing; // capture of that variable. We start from the innermost capturing-entity; // (the DC) and ensure that all intervening capturing-entities; // (blocks/lambdas etc.) between the innermost capturer and the variable`s; // declcontext can either capture the variable or have already captured; // the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:10,Modifiability,variab,variable,10,"// If the variable is declared in the current context, there is no need to; // capture it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:95,Modifiability,variab,variable,95,"// We need to check for the parent *first* because, if we *have*; // private-captured a global variable, we need to recursively capture it in; // intermediate blocks, lambdas, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:98,Modifiability,variab,variables,98,"// If we are instantiating a generic lambda call operator body,; // we do not want to capture new variables. What was captured; // during either a lambdas transformation or initial parsing; // should be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:18,Modifiability,variab,variable-length,18,// Try to capture variable-length arrays types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:23,Availability,down,down,23,// We're going to walk down into the type and look for VLA; // expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:18,Modifiability,variab,variables,18,"// OpenMP private variables should not be captured in outer scope, so; // just break here. Similarly, global variables that are captured in a; // target region should not be captured outside the scope of the region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:109,Modifiability,variab,variables,109,"// OpenMP private variables should not be captured in outer scope, so; // just break here. Similarly, global variables that are captured in a; // target region should not be captured outside the scope of the region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:10,Modifiability,variab,variable,10,"// If the variable is private (i.e. not captured) and has variably; // modified type, we still need to capture the type for correct; // codegen in all regions, associated with the construct. Currently,; // it is captured in the innermost captured region only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:58,Modifiability,variab,variably,58,"// If the variable is private (i.e. not captured) and has variably; // modified type, we still need to capture the type for correct; // codegen in all regions, associated with the construct. Currently,; // it is captured in the innermost captured region only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:11,Safety,detect,detect,11,"// When we detect target captures we are looking from inside the; // target region, therefore we need to propagate the capture from the; // enclosing region. Therefore, the capture is not initially nested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:86,Modifiability,variab,variable,86,"// No capture-default, and this is not an explicit capture; // so cannot capture this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:16,Availability,error,error,16,"// FIXME: If we error out because an outer lambda can not implicitly; // capture a variable that an inner lambda explicitly captures, we; // should have the inner lambda do the explicit capture - because; // it makes for cleaner diagnostics later. This would purely be done; // so that the diagnostic does not misleadingly claim that a variable; // can not be captured by a lambda implicitly even though it is captured; // explicitly. Suggestion:; // - create const bool VariableCaptureWasInitiallyExplicit = Explicit; // at the function head; // - cache the StartingDeclContext - this must be a lambda; // - captureInLambda in the innermost lambda the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:83,Modifiability,variab,variable,83,"// FIXME: If we error out because an outer lambda can not implicitly; // capture a variable that an inner lambda explicitly captures, we; // should have the inner lambda do the explicit capture - because; // it makes for cleaner diagnostics later. This would purely be done; // so that the diagnostic does not misleadingly claim that a variable; // can not be captured by a lambda implicitly even though it is captured; // explicitly. Suggestion:; // - create const bool VariableCaptureWasInitiallyExplicit = Explicit; // at the function head; // - cache the StartingDeclContext - this must be a lambda; // - captureInLambda in the innermost lambda the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:336,Modifiability,variab,variable,336,"// FIXME: If we error out because an outer lambda can not implicitly; // capture a variable that an inner lambda explicitly captures, we; // should have the inner lambda do the explicit capture - because; // it makes for cleaner diagnostics later. This would purely be done; // so that the diagnostic does not misleadingly claim that a variable; // can not be captured by a lambda implicitly even though it is captured; // explicitly. Suggestion:; // - create const bool VariableCaptureWasInitiallyExplicit = Explicit; // at the function head; // - cache the StartingDeclContext - this must be a lambda; // - captureInLambda in the innermost lambda the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:471,Modifiability,Variab,VariableCaptureWasInitiallyExplicit,471,"// FIXME: If we error out because an outer lambda can not implicitly; // capture a variable that an inner lambda explicitly captures, we; // should have the inner lambda do the explicit capture - because; // it makes for cleaner diagnostics later. This would purely be done; // so that the diagnostic does not misleadingly claim that a variable; // can not be captured by a lambda implicitly even though it is captured; // explicitly. Suggestion:; // - create const bool VariableCaptureWasInitiallyExplicit = Explicit; // at the function head; // - cache the StartingDeclContext - this must be a lambda; // - captureInLambda in the innermost lambda the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:653,Modifiability,variab,variable,653,"// FIXME: If we error out because an outer lambda can not implicitly; // capture a variable that an inner lambda explicitly captures, we; // should have the inner lambda do the explicit capture - because; // it makes for cleaner diagnostics later. This would purely be done; // so that the diagnostic does not misleadingly claim that a variable; // can not be captured by a lambda implicitly even though it is captured; // explicitly. Suggestion:; // - create const bool VariableCaptureWasInitiallyExplicit = Explicit; // at the function head; // - cache the StartingDeclContext - this must be a lambda; // - captureInLambda in the innermost lambda the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:549,Performance,cache,cache,549,"// FIXME: If we error out because an outer lambda can not implicitly; // capture a variable that an inner lambda explicitly captures, we; // should have the inner lambda do the explicit capture - because; // it makes for cleaner diagnostics later. This would purely be done; // so that the diagnostic does not misleadingly claim that a variable; // can not be captured by a lambda implicitly even though it is captured; // explicitly. Suggestion:; // - create const bool VariableCaptureWasInitiallyExplicit = Explicit; // at the function head; // - cache the StartingDeclContext - this must be a lambda; // - captureInLambda in the innermost lambda the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:13,Availability,down,down,13,"// Walk back down the scope stack, (e.g. from outer lambda to inner lambda); // computing the type of the capture at each step, checking type-specific; // requirements, and adding captures if requested.; // If the variable had already been captured previously, we start capturing; // at the lambda nested within that one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:214,Modifiability,variab,variable,214,"// Walk back down the scope stack, (e.g. from outer lambda to inner lambda); // computing the type of the capture at each step, checking type-specific; // requirements, and adding captures if requested.; // If the variable had already been captured previously, we start capturing; // at the lambda nested within that one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:101,Modifiability,variab,variables,101,"// Certain capturing entities (lambdas, blocks etc.) are not allowed to capture; // certain types of variables (unnamed, variably modified types etc.); // so check for eligibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:121,Modifiability,variab,variably,121,"// Certain capturing entities (lambdas, blocks etc.) are not allowed to capture; // certain types of variables (unnamed, variably modified types etc.); // so check for eligibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:25,Availability,error,error,25,"// After encountering an error, if we're actually supposed to capture, keep; // capturing in nested contexts to suppress any follow-on diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:41,Modifiability,variab,variable,41,// Determine whether we can capture this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:284,Availability,error,error,284,"/// Walk the set of potential results of an expression and mark them all as; /// non-odr-uses if they satisfy the side-conditions of the NonOdrUseReason.; ///; /// \return A new expression if we found any potential results, ExprEmpty() if; /// not, and ExprError() if we diagnosed an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,Modifiability,variab,variable,32,"// Per C++11 [basic.def.odr], a variable is odr-used ""unless it is; // an object that satisfies the requirements for appearing in a; // constant expression (5.19) and the lvalue-to-rvalue conversion (4.1); // is immediately applied."" This function handles the lvalue-to-rvalue; // conversion part.; //; // If we encounter a node that claims to be an odr-use but shouldn't be, we; // transform it into the relevant kind of non-odr-use node and rebuild the; // tree of nodes leading to it.; //; // This is a mini-TreeTransform that only transforms a restricted subset of; // nodes (and only certain operands of them).; // Rebuild a subexpression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:34,Modifiability,variab,variable,34,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evalauted expression; // e is odr-used by e unless; // -- x is a reference that is usable in constant expressions, or; // -- x is a variable of non-reference type that is usable in constant; // expressions and has no mutable subobjects, and e is an element of; // the set of potential results of an expression of; // non-volatile-qualified non-class type to which the lvalue-to-rvalue; // conversion is applied, or; // -- x is a variable of non-reference type, and e is an element of the; // set of potential results of a discarded-value expression to which; // the lvalue-to-rvalue conversion is not applied; //; // We check the first bullet and the ""potentially-evaluated"" condition in; // BuildDeclRefExpr. We check the type requirements in the second bullet; // in CheckLValueToRValueConversionOperand below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:213,Modifiability,variab,variable,213,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evalauted expression; // e is odr-used by e unless; // -- x is a reference that is usable in constant expressions, or; // -- x is a variable of non-reference type that is usable in constant; // expressions and has no mutable subobjects, and e is an element of; // the set of potential results of an expression of; // non-volatile-qualified non-class type to which the lvalue-to-rvalue; // conversion is applied, or; // -- x is a variable of non-reference type, and e is an element of the; // set of potential results of a discarded-value expression to which; // the lvalue-to-rvalue conversion is not applied; //; // We check the first bullet and the ""potentially-evaluated"" condition in; // BuildDeclRefExpr. We check the type requirements in the second bullet; // in CheckLValueToRValueConversionOperand below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:510,Modifiability,variab,variable,510,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evalauted expression; // e is odr-used by e unless; // -- x is a reference that is usable in constant expressions, or; // -- x is a variable of non-reference type that is usable in constant; // expressions and has no mutable subobjects, and e is an element of; // the set of potential results of an expression of; // non-volatile-qualified non-class type to which the lvalue-to-rvalue; // conversion is applied, or; // -- x is a variable of non-reference type, and e is an element of the; // set of potential results of a discarded-value expression to which; // the lvalue-to-rvalue conversion is not applied; //; // We check the first bullet and the ""potentially-evaluated"" condition in; // BuildDeclRefExpr. We check the type requirements in the second bullet; // in CheckLValueToRValueConversionOperand below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:164,Usability,usab,usable,164,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evalauted expression; // e is odr-used by e unless; // -- x is a reference that is usable in constant expressions, or; // -- x is a variable of non-reference type that is usable in constant; // expressions and has no mutable subobjects, and e is an element of; // the set of potential results of an expression of; // non-volatile-qualified non-class type to which the lvalue-to-rvalue; // conversion is applied, or; // -- x is a variable of non-reference type, and e is an element of the; // set of potential results of a discarded-value expression to which; // the lvalue-to-rvalue conversion is not applied; //; // We check the first bullet and the ""potentially-evaluated"" condition in; // BuildDeclRefExpr. We check the type requirements in the second bullet; // in CheckLValueToRValueConversionOperand below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:252,Usability,usab,usable,252,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evalauted expression; // e is odr-used by e unless; // -- x is a reference that is usable in constant expressions, or; // -- x is a variable of non-reference type that is usable in constant; // expressions and has no mutable subobjects, and e is an element of; // the set of potential results of an expression of; // non-volatile-qualified non-class type to which the lvalue-to-rvalue; // conversion is applied, or; // -- x is a variable of non-reference type, and e is an element of the; // set of potential results of a discarded-value expression to which; // the lvalue-to-rvalue conversion is not applied; //; // We check the first bullet and the ""potentially-evaluated"" condition in; // BuildDeclRefExpr. We check the type requirements in the second bullet; // in CheckLValueToRValueConversionOperand below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:29,Security,access,access,29,// -- If e is a class member access expression [...] naming a non-static; // data member...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:29,Security,access,access,29,"// -- If e is a class member access expression naming a static data member,; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:48,Modifiability,variab,variable,48,"// If a constant-expression is a reference to a variable where we delay; // deciding whether it is an odr-use, just assume we will apply the; // lvalue-to-rvalue conversion. In the one case where this doesn't happen; // (a non-type template argument), we have special handling anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:8,Modifiability,variab,variable,8,"// If a variable could potentially be odr-used, defer marking it so; // until we finish analyzing the full expression for any; // lvalue-to-rvalue; // or discarded value conversions that would obviate odr-use.; // Add it to the list of potential captures that will be analyzed; // later (ActOnFinishFullExpr) for eventual capture and odr-use marking; // unless the variable is a reference that was initialized by a constant; // expression (this will never need to be captured or odr-used).; //; // FIXME: We can simplify this a lot after implementing P0588R1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:365,Modifiability,variab,variable,365,"// If a variable could potentially be odr-used, defer marking it so; // until we finish analyzing the full expression for any; // lvalue-to-rvalue; // or discarded value conversions that would obviate odr-use.; // Add it to the list of potential captures that will be analyzed; // later (ActOnFinishFullExpr) for eventual capture and odr-use marking; // unless the variable is a reference that was initialized by a constant; // expression (this will never need to be captured or odr-used).; //; // FIXME: We can simplify this a lot after implementing P0588R1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:512,Usability,simpl,simplify,512,"// If a variable could potentially be odr-used, defer marking it so; // until we finish analyzing the full expression for any; // lvalue-to-rvalue; // or discarded value conversions that would obviate odr-use.; // Add it to the list of potential captures that will be analyzed; // later (ActOnFinishFullExpr) for eventual capture and odr-use marking; // unless the variable is a reference that was initialized by a constant; // expression (this will never need to be captured or odr-used).; //; // FIXME: We can simplify this a lot after implementing P0588R1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,Modifiability,variab,variable,32,// C++20 [expr.const]p12:; // A variable [...] is needed for constant evaluation if it is [...] a; // variable whose name appears as a potentially constant evaluated; // expression that is either a contexpr variable or is of non-volatile; // const-qualified integral type or of reference type,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:102,Modifiability,variab,variable,102,// C++20 [expr.const]p12:; // A variable [...] is needed for constant evaluation if it is [...] a; // variable whose name appears as a potentially constant evaluated; // expression that is either a contexpr variable or is of non-volatile; // const-qualified integral type or of reference type,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:207,Modifiability,variab,variable,207,// C++20 [expr.const]p12:; // A variable [...] is needed for constant evaluation if it is [...] a; // variable whose name appears as a potentially constant evaluated; // expression that is either a contexpr variable or is of non-volatile; // const-qualified integral type or of reference type,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:140,Modifiability,variab,variable,140,"// If this might be a member specialization of a static data member, check; // the specialization is visible. We already did the checks for variable; // template specializations when we created them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:115,Modifiability,variab,variable,115,"// Perform implicit instantiation of static data members, static data member; // templates of class templates, and variable template specializations. Delay; // instantiations of variable templates, except for those that could be used; // in a constant expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:178,Modifiability,variab,variable,178,"// Perform implicit instantiation of static data members, static data member; // templates of class templates, and variable template specializations. Delay; // instantiations of variable templates, except for those that could be used; // in a constant expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Performance,Perform,Perform,3,"// Perform implicit instantiation of static data members, static data member; // templates of class templates, and variable template specializations. Delay; // instantiations of variable templates, except for those that could be used; // in a constant expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:107,Modifiability,variab,variable,107,"// Per C++17 [temp.explicit]p10, we may instantiate despite an explicit; // instantiation declaration if a variable is usable in a constant; // expression (among other cases).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:119,Usability,usab,usable,119,"// Per C++17 [temp.explicit]p10, we may instantiate despite an explicit; // instantiation declaration if a variable is usable in a constant; // expression (among other cases).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:34,Modifiability,variab,variables,34,// Do not defer instantiations of variables that could be used in a; // constant expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:55,Integrability,depend,dependence,55,// Re-set the member to trigger a recomputation of the dependence bits; // for the expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:36,Modifiability,variab,variable,36,"// FIXME: For a specialization of a variable template, we don't; // distinguish between ""declaration and type implicitly instantiated""; // and ""implicit instantiation of definition requested"", so we have; // no direct way to avoid enqueueing the pending instantiation; // multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:225,Safety,avoid,avoid,225,"// FIXME: For a specialization of a variable template, we don't; // distinguish between ""declaration and type implicitly instantiated""; // and ""implicit instantiation of definition requested"", so we have; // no direct way to avoid enqueueing the pending instantiation; // multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:34,Modifiability,variab,variable,34,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless; // -- x is a reference that is usable in constant expressions; // -- x is a variable of non-reference type that is usable in constant; // expressions and has no mutable subobjects [FIXME], and e is an; // element of the set of potential results of an expression of; // non-volatile-qualified non-class type to which the lvalue-to-rvalue; // conversion is applied; // -- x is a variable of non-reference type, and e is an element of the set; // of potential results of a discarded-value expression to which the; // lvalue-to-rvalue conversion is not applied [FIXME]; //; // We check the first part of the second bullet here, and; // Sema::CheckLValueToRValueConversionOperand deals with the second part.; // FIXME: To get the third bullet right, we need to delay this even for; // variables that are not usable in constant expressions.; // If we already know this isn't an odr-use, there's nothing more to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:209,Modifiability,variab,variable,209,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless; // -- x is a reference that is usable in constant expressions; // -- x is a variable of non-reference type that is usable in constant; // expressions and has no mutable subobjects [FIXME], and e is an; // element of the set of potential results of an expression of; // non-volatile-qualified non-class type to which the lvalue-to-rvalue; // conversion is applied; // -- x is a variable of non-reference type, and e is an element of the set; // of potential results of a discarded-value expression to which the; // lvalue-to-rvalue conversion is not applied [FIXME]; //; // We check the first part of the second bullet here, and; // Sema::CheckLValueToRValueConversionOperand deals with the second part.; // FIXME: To get the third bullet right, we need to delay this even for; // variables that are not usable in constant expressions.; // If we already know this isn't an odr-use, there's nothing more to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:510,Modifiability,variab,variable,510,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless; // -- x is a reference that is usable in constant expressions; // -- x is a variable of non-reference type that is usable in constant; // expressions and has no mutable subobjects [FIXME], and e is an; // element of the set of potential results of an expression of; // non-volatile-qualified non-class type to which the lvalue-to-rvalue; // conversion is applied; // -- x is a variable of non-reference type, and e is an element of the set; // of potential results of a discarded-value expression to which the; // lvalue-to-rvalue conversion is not applied [FIXME]; //; // We check the first part of the second bullet here, and; // Sema::CheckLValueToRValueConversionOperand deals with the second part.; // FIXME: To get the third bullet right, we need to delay this even for; // variables that are not usable in constant expressions.; // If we already know this isn't an odr-use, there's nothing more to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:913,Modifiability,variab,variables,913,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless; // -- x is a reference that is usable in constant expressions; // -- x is a variable of non-reference type that is usable in constant; // expressions and has no mutable subobjects [FIXME], and e is an; // element of the set of potential results of an expression of; // non-volatile-qualified non-class type to which the lvalue-to-rvalue; // conversion is applied; // -- x is a variable of non-reference type, and e is an element of the set; // of potential results of a discarded-value expression to which the; // lvalue-to-rvalue conversion is not applied [FIXME]; //; // We check the first part of the second bullet here, and; // Sema::CheckLValueToRValueConversionOperand deals with the second part.; // FIXME: To get the third bullet right, we need to delay this even for; // variables that are not usable in constant expressions.; // If we already know this isn't an odr-use, there's nothing more to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:164,Usability,usab,usable,164,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless; // -- x is a reference that is usable in constant expressions; // -- x is a variable of non-reference type that is usable in constant; // expressions and has no mutable subobjects [FIXME], and e is an; // element of the set of potential results of an expression of; // non-volatile-qualified non-class type to which the lvalue-to-rvalue; // conversion is applied; // -- x is a variable of non-reference type, and e is an element of the set; // of potential results of a discarded-value expression to which the; // lvalue-to-rvalue conversion is not applied [FIXME]; //; // We check the first part of the second bullet here, and; // Sema::CheckLValueToRValueConversionOperand deals with the second part.; // FIXME: To get the third bullet right, we need to delay this even for; // variables that are not usable in constant expressions.; // If we already know this isn't an odr-use, there's nothing more to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:248,Usability,usab,usable,248,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless; // -- x is a reference that is usable in constant expressions; // -- x is a variable of non-reference type that is usable in constant; // expressions and has no mutable subobjects [FIXME], and e is an; // element of the set of potential results of an expression of; // non-volatile-qualified non-class type to which the lvalue-to-rvalue; // conversion is applied; // -- x is a variable of non-reference type, and e is an element of the set; // of potential results of a discarded-value expression to which the; // lvalue-to-rvalue conversion is not applied [FIXME]; //; // We check the first part of the second bullet here, and; // Sema::CheckLValueToRValueConversionOperand deals with the second part.; // FIXME: To get the third bullet right, we need to delay this even for; // variables that are not usable in constant expressions.; // If we already know this isn't an odr-use, there's nothing more to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:936,Usability,usab,usable,936,"// C++2a [basic.def.odr]p4:; // A variable x whose name appears as a potentially-evaluated expression e; // is odr-used by e unless; // -- x is a reference that is usable in constant expressions; // -- x is a variable of non-reference type that is usable in constant; // expressions and has no mutable subobjects [FIXME], and e is an; // element of the set of potential results of an expression of; // non-volatile-qualified non-class type to which the lvalue-to-rvalue; // conversion is applied; // -- x is a variable of non-reference type, and e is an element of the set; // of potential results of a discarded-value expression to which the; // lvalue-to-rvalue conversion is not applied [FIXME]; //; // We check the first part of the second bullet here, and; // Sema::CheckLValueToRValueConversionOperand deals with the second part.; // FIXME: To get the third bullet right, we need to delay this even for; // variables that are not usable in constant expressions.; // If we already know this isn't an odr-use, there's nothing more to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:20,Modifiability,variab,variable,20,"// In some cases, a variable may not have been marked unevaluated, if it; // appears in a defaukt initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:16,Integrability,depend,dependent,16,"// If this is a dependent context, we don't need to mark variables as; // odr-used, but we may still need to track them for lambda capture.; // FIXME: Do we also need to do this inside dependent typeid expressions; // (which are modeled as unevaluated at this point)?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:185,Integrability,depend,dependent,185,"// If this is a dependent context, we don't need to mark variables as; // odr-used, but we may still need to track them for lambda capture.; // FIXME: Do we also need to do this inside dependent typeid expressions; // (which are modeled as unevaluated at this point)?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:57,Modifiability,variab,variables,57,"// If this is a dependent context, we don't need to mark variables as; // odr-used, but we may still need to track them for lambda capture.; // FIXME: Do we also need to do this inside dependent typeid expressions; // (which are modeled as unevaluated at this point)?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:11,Modifiability,variab,variable,11,"/// Mark a variable referenced, and check whether it is odr-used; /// (C++ [basic.def.odr]p2, C99 6.9p3). Note that this should not be; /// used directly for normal expressions referring to VarDecl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:55,Integrability,depend,dependent,55,"// C++ [temp.dep.expr]p3:; // An id-expression is type-dependent if it contains:; // - an identifier associated by name lookup with an entity captured by copy; // in a lambda-expression that has an explicit object parameter whose type; // is dependent ([dcl.fct]),",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:242,Integrability,depend,dependent,242,"// C++ [temp.dep.expr]p3:; // An id-expression is type-dependent if it contains:; // - an identifier associated by name lookup with an entity captured by copy; // in a lambda-expression that has an explicit object parameter whose type; // is dependent ([dcl.fct]),",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:106,Integrability,depend,dependence,106,"/// Perform reference-marking and odr-use handling for a DeclRefExpr.; ///; /// Note, this may change the dependence of the DeclRefExpr, and so needs to be; /// handled with care if the DeclRefExpr is not newly-created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:4,Performance,Perform,Perform,4,"/// Perform reference-marking and odr-use handling for a DeclRefExpr.; ///; /// Note, this may change the dependence of the DeclRefExpr, and so needs to be; /// handled with care if the DeclRefExpr is not newly-created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:9,Deployability,update,update,9,"// TODO: update this with DR# once a defect report is filed.; // C++11 defect. The address of a pure member should not be an ODR use, even; // if it's a qualified reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:4,Performance,Perform,Perform,4,/// Perform reference-marking and odr-use handling for a MemberExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:4,Performance,Perform,Perform,4,/// Perform reference-marking and odr-use handling for a FunctionParmPackExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:160,Modifiability,variab,variables,160,"/// Perform marking for a reference to an arbitrary declaration. It; /// marks the declaration referenced, and performs odr-use checking for; /// functions and variables. This method should not be used when building a; /// normal expression which refers to a variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:259,Modifiability,variab,variable,259,"/// Perform marking for a reference to an arbitrary declaration. It; /// marks the declaration referenced, and performs odr-use checking for; /// functions and variables. This method should not be used when building a; /// normal expression which refers to a variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:4,Performance,Perform,Perform,4,"/// Perform marking for a reference to an arbitrary declaration. It; /// marks the declaration referenced, and performs odr-use checking for; /// functions and variables. This method should not be used when building a; /// normal expression which refers to a variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:111,Performance,perform,performs,111,"/// Perform marking for a reference to an arbitrary declaration. It; /// marks the declaration referenced, and performs odr-use checking for; /// functions and variables. This method should not be used when building a; /// normal expression which refers to a variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:381,Testability,log,logic,381,"// Mark all of the declarations used by a type as referenced.; // FIXME: Not fully implemented yet! We need to have a better understanding; // of when we're entering a context we should not recurse into.; // FIXME: This is and EvaluatedExprMarker are more-or-less equivalent to; // TreeTransforms rebuilding the type in a new context. Rather than; // duplicating the TreeTransform logic, we should consider reusing it here.; // Currently that causes problems when rebuilding LambdaExprs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:39,Modifiability,variab,variables,39,"// If we were asked not to visit local variables, don't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:147,Availability,error,error-dependent,147,"// FIXME: This can trigger the instantiation of the initializer of a; // variable, which can cause the expression to become value-dependent; // or error-dependent. Do we need to propagate the new dependence bits?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:130,Integrability,depend,dependent,130,"// FIXME: This can trigger the instantiation of the initializer of a; // variable, which can cause the expression to become value-dependent; // or error-dependent. Do we need to propagate the new dependence bits?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:153,Integrability,depend,dependent,153,"// FIXME: This can trigger the instantiation of the initializer of a; // variable, which can cause the expression to become value-dependent; // or error-dependent. Do we need to propagate the new dependence bits?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:196,Integrability,depend,dependence,196,"// FIXME: This can trigger the instantiation of the initializer of a; // variable, which can cause the expression to become value-dependent; // or error-dependent. Do we need to propagate the new dependence bits?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:73,Modifiability,variab,variable,73,"// FIXME: This can trigger the instantiation of the initializer of a; // variable, which can cause the expression to become value-dependent; // or error-dependent. Do we need to propagate the new dependence bits?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:203,Modifiability,variab,variables,203,"// namespace; /// Mark any declarations that appear within this expression or any; /// potentially-evaluated subexpressions as ""referenced"".; ///; /// \param SkipLocalVariables If true, don't mark local variables as; /// 'referenced'.; /// \param StopAt Subexpressions that we shouldn't recurse into.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:34,Modifiability,variab,variable,34,"// The initializer of a constexpr variable or of the first declaration of a; // static data member is not syntactically a constant evaluated constant,; // but nonetheless is always required to be a constant expression, so we; // can skip diagnosing.; // FIXME: Using the mangling context here is a hack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,Modifiability,variab,variable,32,"// FIXME: For any other kind of variable, we should build a CFG for its; // initializer and check whether the context in question is reachable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:815,Availability,Failure,Failure,815,"/// Emit a diagnostic that describes an effect on the run-time behavior; /// of the program being compiled.; ///; /// This routine emits the given diagnostic when the code currently being; /// type-checked is ""potentially evaluated"", meaning that there is a; /// possibility that the code will actually be executable. Code in sizeof(); /// expressions, code used only during overload resolution, etc., are not; /// potentially evaluated. This routine will suppress such diagnostics or,; /// in the absolutely nutty case of potentially potentially evaluated; /// expressions (C++ typeid), queue the diagnostic to potentially emit it; /// later.; ///; /// This routine should be used for all diagnostics that describe the run-time; /// behavior of a program, such as passing a non-POD value through an ellipsis.; /// Failure to do so will likely result in spurious diagnostics or failures; /// during overload resolution or within sizeof/alignof/typeof/typeid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:878,Availability,failure,failures,878,"/// Emit a diagnostic that describes an effect on the run-time behavior; /// of the program being compiled.; ///; /// This routine emits the given diagnostic when the code currently being; /// type-checked is ""potentially evaluated"", meaning that there is a; /// possibility that the code will actually be executable. Code in sizeof(); /// expressions, code used only during overload resolution, etc., are not; /// potentially evaluated. This routine will suppress such diagnostics or,; /// in the absolutely nutty case of potentially potentially evaluated; /// expressions (C++ typeid), queue the diagnostic to potentially emit it; /// later.; ///; /// This routine should be used for all diagnostics that describe the run-time; /// behavior of a program, such as passing a non-POD value through an ellipsis.; /// Failure to do so will likely result in spurious diagnostics or failures; /// during overload resolution or within sizeof/alignof/typeof/typeid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:123,Integrability,rout,routine,123,"/// Emit a diagnostic that describes an effect on the run-time behavior; /// of the program being compiled.; ///; /// This routine emits the given diagnostic when the code currently being; /// type-checked is ""potentially evaluated"", meaning that there is a; /// possibility that the code will actually be executable. Code in sizeof(); /// expressions, code used only during overload resolution, etc., are not; /// potentially evaluated. This routine will suppress such diagnostics or,; /// in the absolutely nutty case of potentially potentially evaluated; /// expressions (C++ typeid), queue the diagnostic to potentially emit it; /// later.; ///; /// This routine should be used for all diagnostics that describe the run-time; /// behavior of a program, such as passing a non-POD value through an ellipsis.; /// Failure to do so will likely result in spurious diagnostics or failures; /// during overload resolution or within sizeof/alignof/typeof/typeid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:443,Integrability,rout,routine,443,"/// Emit a diagnostic that describes an effect on the run-time behavior; /// of the program being compiled.; ///; /// This routine emits the given diagnostic when the code currently being; /// type-checked is ""potentially evaluated"", meaning that there is a; /// possibility that the code will actually be executable. Code in sizeof(); /// expressions, code used only during overload resolution, etc., are not; /// potentially evaluated. This routine will suppress such diagnostics or,; /// in the absolutely nutty case of potentially potentially evaluated; /// expressions (C++ typeid), queue the diagnostic to potentially emit it; /// later.; ///; /// This routine should be used for all diagnostics that describe the run-time; /// behavior of a program, such as passing a non-POD value through an ellipsis.; /// Failure to do so will likely result in spurious diagnostics or failures; /// during overload resolution or within sizeof/alignof/typeof/typeid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:659,Integrability,rout,routine,659,"/// Emit a diagnostic that describes an effect on the run-time behavior; /// of the program being compiled.; ///; /// This routine emits the given diagnostic when the code currently being; /// type-checked is ""potentially evaluated"", meaning that there is a; /// possibility that the code will actually be executable. Code in sizeof(); /// expressions, code used only during overload resolution, etc., are not; /// potentially evaluated. This routine will suppress such diagnostics or,; /// in the absolutely nutty case of potentially potentially evaluated; /// expressions (C++ typeid), queue the diagnostic to potentially emit it; /// later.; ///; /// This routine should be used for all diagnostics that describe the run-time; /// behavior of a program, such as passing a non-POD value through an ellipsis.; /// Failure to do so will likely result in spurious diagnostics or failures; /// during overload resolution or within sizeof/alignof/typeof/typeid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:588,Performance,queue,queue,588,"/// Emit a diagnostic that describes an effect on the run-time behavior; /// of the program being compiled.; ///; /// This routine emits the given diagnostic when the code currently being; /// type-checked is ""potentially evaluated"", meaning that there is a; /// possibility that the code will actually be executable. Code in sizeof(); /// expressions, code used only during overload resolution, etc., are not; /// potentially evaluated. This routine will suppress such diagnostics or,; /// in the absolutely nutty case of potentially potentially evaluated; /// expressions (C++ typeid), queue the diagnostic to potentially emit it; /// later.; ///; /// This routine should be used for all diagnostics that describe the run-time; /// behavior of a program, such as passing a non-POD value through an ellipsis.; /// Failure to do so will likely result in spurious diagnostics or failures; /// during overload resolution or within sizeof/alignof/typeof/typeid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:4,Availability,Redundant,Redundant,4,/// Redundant parentheses over an equality comparison can indicate; /// that the user intended an assignment used as condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:4,Safety,Redund,Redundant,4,/// Redundant parentheses over an equality comparison can indicate; /// that the user intended an assignment used as condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:18,Integrability,depend,dependent,18,// Don't warn for dependent expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:52,Integrability,wrap,wraps,52,/// Rebuild an expression which simply semantically wraps another; /// expression which it shares the type and value kind of.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,Usability,simpl,simply,32,/// Rebuild an expression which simply semantically wraps another; /// expression which it shares the type and value kind of.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:52,Integrability,wrap,wraps,52,/// Rebuild an expression which simply semantically wraps another; /// expression which it shares the type and value kind of.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,Usability,simpl,simply,32,/// Rebuild an expression which simply semantically wraps another; /// expression which it shares the type and value kind of.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:377,Modifiability,portab,portably,377,"// __unknown_anytype(...) is a special case used by the debugger when; // it has no idea what a function's signature is.; //; // We want to build this call essentially under the K&R; // unprototyped rules, but making a FunctionNoProtoType in C++; // would foul up all sorts of assumptions. However, we cannot; // simply pass all arguments as variadic arguments, nor can we; // portably just call the function under a non-variadic type; see; // the comment on IR-gen's TargetInfo::isNoProtoCallVariadic.; // However, it turns out that in practice it is generally safe to; // call a function declared as ""A foo(B,C,D);"" under the prototype; // ""A foo(B,C,D,...);"". The only known exception is with the; // Windows ABI, where any variadic function is implicitly cdecl; // regardless of its normal CC. Therefore we change the parameter; // types to match the types of the arguments.; //; // This is a hack, but it is far superior to moving the; // corresponding target-specific code from IR-gen to Sema/AST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:562,Safety,safe,safe,562,"// __unknown_anytype(...) is a special case used by the debugger when; // it has no idea what a function's signature is.; //; // We want to build this call essentially under the K&R; // unprototyped rules, but making a FunctionNoProtoType in C++; // would foul up all sorts of assumptions. However, we cannot; // simply pass all arguments as variadic arguments, nor can we; // portably just call the function under a non-variadic type; see; // the comment on IR-gen's TargetInfo::isNoProtoCallVariadic.; // However, it turns out that in practice it is generally safe to; // call a function declared as ""A foo(B,C,D);"" under the prototype; // ""A foo(B,C,D,...);"". The only known exception is with the; // Windows ABI, where any variadic function is implicitly cdecl; // regardless of its normal CC. Therefore we change the parameter; // types to match the types of the arguments.; //; // This is a hack, but it is far superior to moving the; // corresponding target-specific code from IR-gen to Sema/AST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:313,Usability,simpl,simply,313,"// __unknown_anytype(...) is a special case used by the debugger when; // it has no idea what a function's signature is.; //; // We want to build this call essentially under the K&R; // unprototyped rules, but making a FunctionNoProtoType in C++; // would foul up all sorts of assumptions. However, we cannot; // simply pass all arguments as variadic arguments, nor can we; // portably just call the function under a non-variadic type; see; // the comment on IR-gen's TargetInfo::isNoProtoCallVariadic.; // However, it turns out that in practice it is generally safe to; // call a function declared as ""A foo(B,C,D);"" under the prototype; // ""A foo(B,C,D,...);"". The only known exception is with the; // Windows ABI, where any variadic function is implicitly cdecl; // regardless of its normal CC. Therefore we change the parameter; // types to match the types of the arguments.; //; // This is a hack, but it is far superior to moving the; // corresponding target-specific code from IR-gen to Sema/AST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:37,Availability,avail,available,37,// Rewrite the method result type if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the method result type if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:26,Integrability,message,message,26,// Change the type of the message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:184,Integrability,rout,routine,184,// We must match the FunctionDecl's type to the hack introduced in; // RebuildUnknownAnyExpr::VisitCallExpr to vararg functions of unknown; // type. See the lengthy commentary in that routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:5,Modifiability,variab,variables,5,// - variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the casted expression from scratch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:9,Availability,recover,recoverable,9,// Never recoverable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:9,Safety,recover,recoverable,9,// Never recoverable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:110,Availability,error,error,110,/// Check for operands with placeholder types and complain if found.; /// Returns ExprError() if there was an error and no recovery was possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:123,Availability,recover,recovery,123,/// Check for operands with placeholder types and complain if found.; /// Returns ExprError() if there was an error and no recovery was possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:123,Safety,recover,recovery,123,/// Check for operands with placeholder types and complain if found.; /// Returns ExprError() if there was an error and no recovery was possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:90,Integrability,depend,dependent,90,"// C cannot handle TypoExpr nodes on either side of a binop because it; // doesn't handle dependent types properly, so make sure any TypoExprs have; // been dealt with before checking the operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:103,Availability,failure,failure,103,// No guarantees that ResolveAndFixSingleFunctionTemplateSpecialization; // leaves Result unchanged on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:26,Availability,recover,recover,26,"// If that failed, try to recover with a call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:26,Safety,recover,recover,26,"// If that failed, try to recover with a call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:24,Availability,avail,availability,24,"// Transcribe the ""ios"" availability check to ""maccatalyst"" when compiling; // for ""maccatalyst"" if ""maccatalyst"" is not specified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:16,Availability,avail,available,16,// The use of `@available` in the enclosing context should be analyzed to; // warn when it's used inappropriately (i.e. not if(@available)).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:128,Availability,avail,available,128,// The use of `@available` in the enclosing context should be analyzed to; // warn when it's used inappropriately (i.e. not if(@available)).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:48,Integrability,depend,dependent,48,"// We don't know the concrete type, fallback to dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:58,Modifiability,inherit,inheriting,58,"/// Handle the result of the special case name lookup for inheriting; /// constructor declarations. 'NS::X::X' and 'NS::X<...>::X' are treated as; /// constructor names in member using declarations, even if 'X' is not the; /// name of the corresponding type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:46,Integrability,depend,dependent,46,"// When naming a constructor as a member of a dependent context (eg, in a; // friend declaration or an inherited constructor declaration), form an; // unresolved ""typename"" type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:103,Modifiability,inherit,inherited,103,"// When naming a constructor as a member of a dependent context (eg, in a; // friend declaration or an inherited constructor declaration), form an; // unresolved ""typename"" type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:12,Integrability,inject,injected-class-name,12,"// Find the injected-class-name declaration. Note that we make no attempt to; // diagnose cases where the injected-class-name is shadowed: the only; // declaration that can validly shadow the injected-class-name is a; // non-static data member, and if the class contains both a non-static data; // member and a constructor then it is ill-formed (we check that in; // CheckCompletedCXXClass).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:106,Integrability,inject,injected-class-name,106,"// Find the injected-class-name declaration. Note that we make no attempt to; // diagnose cases where the injected-class-name is shadowed: the only; // declaration that can validly shadow the injected-class-name is a; // non-static data member, and if the class contains both a non-static data; // member and a constructor then it is ill-formed (we check that in; // CheckCompletedCXXClass).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:192,Integrability,inject,injected-class-name,192,"// Find the injected-class-name declaration. Note that we make no attempt to; // diagnose cases where the injected-class-name is shadowed: the only; // declaration that can validly shadow the injected-class-name is a; // non-static data member, and if the class contains both a non-static data; // member and a constructor then it is ill-formed (we check that in; // CheckCompletedCXXClass).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:12,Security,inject,injected-class-name,12,"// Find the injected-class-name declaration. Note that we make no attempt to; // diagnose cases where the injected-class-name is shadowed: the only; // declaration that can validly shadow the injected-class-name is a; // non-static data member, and if the class contains both a non-static data; // member and a constructor then it is ill-formed (we check that in; // CheckCompletedCXXClass).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:106,Security,inject,injected-class-name,106,"// Find the injected-class-name declaration. Note that we make no attempt to; // diagnose cases where the injected-class-name is shadowed: the only; // declaration that can validly shadow the injected-class-name is a; // non-static data member, and if the class contains both a non-static data; // member and a constructor then it is ill-formed (we check that in; // CheckCompletedCXXClass).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:192,Security,inject,injected-class-name,192,"// Find the injected-class-name declaration. Note that we make no attempt to; // diagnose cases where the injected-class-name is shadowed: the only; // declaration that can validly shadow the injected-class-name is a; // non-static data member, and if the class contains both a non-static data; // member and a constructor then it is ill-formed (we check that in; // CheckCompletedCXXClass).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:51,Integrability,depend,dependent,51,// FIXME: RequireCompleteDeclContext doesn't check dependent contexts; // properly. Work around it here for now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:22,Performance,perform,perform,22,"// Determine where to perform name lookup.; // FIXME: This area of the standard is very messy, and the current; // wording is rather unclear about which scopes we search for the; // destructor name; see core issues 399 and 555. Issue 399 in; // particular shows where the current description of destructor name; // lookup is completely out of line with existing practice, e.g.,; // this appears to be ill-formed:; //; // namespace N {; // template <typename T> struct S {; // ~S();; // };; // }; //; // void f(N::S<int>* s) {; // s->N::S<int>::~S();; // }; //; // See also PR6358 and PR6359.; //; // For now, we accept all the cases in which the name given could plausibly; // be interpreted as a correct destructor name, issuing off-by-default; // extension diagnostics on the cases that don't strictly conform to the; // C++20 rules. This basically means we always consider looking in the; // nested-name-specifier prefix, the complete nested-name-specifier, and; // the scope, and accept if we find the expected type in any of the three; // places.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:100,Security,access,access,100,"// If we have an object type, it's because we are in a; // pseudo-destructor-expression or a member access expression, and; // we know what type we're looking for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:42,Availability,failure,failure,42,// Don't list a class twice in the lookup failure diagnostic if it's; // found by both its injected-class-name and by the name in the enclosing; // scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:91,Integrability,inject,injected-class-name,91,// Don't list a class twice in the lookup failure diagnostic if it's; // found by both its injected-class-name and by the name in the enclosing; // scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:91,Security,inject,injected-class-name,91,// Don't list a class twice in the lookup failure diagnostic if it's; // found by both its injected-class-name and by the name in the enclosing; // scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:155,Usability,clear,clear,155,"// As an extension, attempt to ""fix"" an ambiguity by erasing all non-type; // results, and all non-matching results if we have a search type. It's not; // clear what the right behavior is if destructor lookup hits an ambiguity,; // but other compilers do generally accept at least some kinds of; // ambiguity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:1391,Integrability,depend,dependent,1391,"// C++2a [basic.lookup.qual]p6:; // In a qualified-id of the form; //; // nested-name-specifier[opt] type-name :: ~ type-name; //; // the second type-name is looked up in the same scope as the first.; //; // We interpret this as meaning that if you do a dual-scope lookup for the; // first name, you also do a dual-scope lookup for the second name, per; // C++ [basic.lookup.classref]p4:; //; // If the id-expression in a class member access is a qualified-id of the; // form; //; // class-name-or-namespace-name :: ...; //; // the class-name-or-namespace-name following the . or -> is first looked; // up in the class of the object expression and the name, if found, is used.; // Otherwise, it is looked up in the context of the entire; // postfix-expression.; //; // This looks in the same scopes as for an unqualified destructor name:; //; // C++ [basic.lookup.classref]p3:; // If the unqualified-id is ~ type-name, the type-name is looked up; // in the context of the entire postfix-expression. If the type T; // of the object expression is of a class type C, the type-name is; // also looked up in the scope of class C. At least one of the; // lookups shall find a name that refers to cv T.; //; // FIXME: The intent is unclear here. Should type-name::~type-name look in; // the scope anyway if it finds a non-matching name declared in the class?; // If both lookups succeed and find a dependent result, which result should; // we retain? (Same question for p->~type-name().)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:435,Security,access,access,435,"// C++2a [basic.lookup.qual]p6:; // In a qualified-id of the form; //; // nested-name-specifier[opt] type-name :: ~ type-name; //; // the second type-name is looked up in the same scope as the first.; //; // We interpret this as meaning that if you do a dual-scope lookup for the; // first name, you also do a dual-scope lookup for the second name, per; // C++ [basic.lookup.classref]p4:; //; // If the id-expression in a class member access is a qualified-id of the; // form; //; // class-name-or-namespace-name :: ...; //; // the class-name-or-namespace-name following the . or -> is first looked; // up in the class of the object expression and the name, if found, is used.; // Otherwise, it is looked up in the context of the entire; // postfix-expression.; //; // This looks in the same scopes as for an unqualified destructor name:; //; // C++ [basic.lookup.classref]p3:; // If the unqualified-id is ~ type-name, the type-name is looked up; // in the context of the entire postfix-expression. If the type T; // of the object expression is of a class type C, the type-name is; // also looked up in the scope of class C. At least one of the; // lookups shall find a name that refers to cv T.; //; // FIXME: The intent is unclear here. Should type-name::~type-name look in; // the scope anyway if it finds a non-matching name declared in the class?; // If both lookups succeed and find a dependent result, which result should; // we retain? (Same question for p->~type-name().)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:48,Integrability,depend,dependent,48,"// We didn't find our type, but that's OK: it's dependent anyway.; // FIXME: What if we have no nested-name-specifier?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:236,Integrability,depend,dependent,236,"// For compatibility with other compilers and older versions of Clang,; //; // nested-name-specifier type-name :: ~ type-name; //; // also looks for type-name in the scope. Unfortunately, we can't; // reasonably apply this fallback for dependent nested-name-specifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:250,Integrability,depend,dependent,250,"// Per C++11 [over.literal]p2, literal operators can only be declared at; // namespace scope. Therefore, this unqualified-id cannot name anything.; // Reject it early, because we have no AST representation for this in the; // case where the scope is dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:99,Modifiability,polymorphi,polymorphic,99,// C++ [expr.typeid]p3:; // When typeid is applied to an expression other than an glvalue of a; // polymorphic class type [...] [the] expression is an unevaluated; // operand. [...],MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:92,Usability,GUID,GUID,92,"/// Grabs __declspec(uuid()) off a type, or returns 0 if we cannot resolve to; /// a single GUID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:334,Modifiability,extend,extend,334,"// C++0x [class.copymove]p31:; // When certain criteria are met, an implementation is allowed to omit the; // copy/move construction of a class object [...]; //; // - in a throw-expression, when the operand is the name of a; // non-volatile automatic object (other than a function or catch-; // clause parameter) whose scope does not extend beyond the end of the; // innermost enclosing try-block (if there is one), the copy/move; // operation from the operand to the exception object (15.1) can be; // omitted by constructing the automatic object directly into the; // exception object",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:19,Availability,error,error,19,// Don't report an error if 'throw' is used in system headers or in an OpenMP; // target region compiled for a GPU architecture.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:9,Availability,error,error,9,// Delay error emission for the OpenMP device code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:465,Modifiability,extend,extend,465,"// Initialize the exception result. This implicitly weeds out; // abstract types or types with inaccessible copy constructors.; // C++0x [class.copymove]p31:; // When certain criteria are met, an implementation is allowed to omit the; // copy/move construction of a class object [...]; //; // - in a throw-expression, when the operand is the name of a; // non-volatile automatic object (other than a function or; // catch-clause; // parameter) whose scope does not extend beyond the end of the; // innermost enclosing try-block (if there is one), the copy/move; // operation from the operand to the exception object (15.1) can be; // omitted by constructing the automatic object directly into the; // exception object",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:41,Security,access,access,41,// Only add subobjects which have public access throughout the entire chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:27,Security,Validat,Validate,27,/// CheckCXXThrowOperand - Validate the operand of a throw.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:24,Modifiability,polymorphi,polymorphic,24,"// If we are throwing a polymorphic class type or pointer thereof,; // exception handling will make use of the vtable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:213,Performance,perform,perform,213,"// Attempt to lookup the copy constructor. Various pieces of machinery; // will spring into action, like template instantiation, which means this; // cannot be a simple walk of the class's decls. Instead, we must perform; // lookup and overload resolution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:162,Usability,simpl,simple,162,"// Attempt to lookup the copy constructor. Various pieces of machinery; // will spring into action, like template instantiation, which means this; // cannot be a simple walk of the class's decls. Instead, we must perform; // lookup and overload resolution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:213,Performance,perform,performed,213,"// The copy constructor is non-trivial, create a mapping from this class; // type to this constructor.; // N.B. The selection of copy constructor is not sensitive to this; // particular throw-site. Lookup will be performed at the catch-site to; // ensure that the copy constructor is, in fact, accessible (via; // friendship or any other means).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:294,Security,access,accessible,294,"// The copy constructor is non-trivial, create a mapping from this class; // type to this constructor.; // N.B. The selection of copy constructor is not sensitive to this; // particular throw-site. Lookup will be performed at the catch-site to; // ensure that the copy constructor is, in fact, accessible (via; // friendship or any other means).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:65,Energy Efficiency,allocate,allocated,65,"// Under the Itanium C++ ABI, memory for the exception object is allocated by; // the runtime with no ability for the compiler to request additional; // alignment. Warn if the exception type requires alignment beyond the minimum; // guaranteed by the target C++ runtime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:1181,Availability,reliab,reliably,1181,"// Iterate through the stack of lambdas starting from the innermost lambda to; // the outermost lambda, checking if '*this' is ever captured by copy - since; // that could change the cv-qualifiers of the '*this' object.; // The object referred to by '*this' starts out with the cv-qualifiers of its; // member function. We then start with the innermost lambda and iterate; // outward checking to see if any lambda performs a by-copy capture of '*this'; // - and if so, any nested lambda must respect the 'constness' of that; // capturing lamdbda's call operator.; //; // Since the FunctionScopeInfo stack is representative of the lexical; // nesting of the lambda expressions during initial parsing (and is the best; // place for querying information about captures about lambdas that are; // partially processed) and perhaps during instantiation of function templates; // that contain lambda expressions that need to be transformed BUT not; // necessarily during instantiation of a nested generic lambda's function call; // operator (which might even be instantiated at the end of the TU) - at which; // time the DeclContext tree is mature enough to query capture information; // reliably - we use a two pronged approach to walk through all the lexically; // enclosing lambda expressions:; //; // 1) Climb down the FunctionScopeInfo stack as long as each item represents; // a Lambda (i.e. LambdaScopeInfo) AND each LSI's 'closure-type' is lexically; // enclosed by the call-operator of the LSI below it on the stack (while; // tracking the enclosing DC for step 2 if needed). Note the topmost LSI on; // the stack represents the innermost lambda.; //; // 2) If we run out of enclosing LSI's, check if the enclosing DeclContext; // represents a lambda's call operator. If it does, we must be instantiating; // a generic lambda's call operator (represented by the Current LSI, and; // should be the only scenario where an inconsistency between the LSI and the; // DeclContext should occur), so climb o",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:1307,Availability,down,down,1307,"// Iterate through the stack of lambdas starting from the innermost lambda to; // the outermost lambda, checking if '*this' is ever captured by copy - since; // that could change the cv-qualifiers of the '*this' object.; // The object referred to by '*this' starts out with the cv-qualifiers of its; // member function. We then start with the innermost lambda and iterate; // outward checking to see if any lambda performs a by-copy capture of '*this'; // - and if so, any nested lambda must respect the 'constness' of that; // capturing lamdbda's call operator.; //; // Since the FunctionScopeInfo stack is representative of the lexical; // nesting of the lambda expressions during initial parsing (and is the best; // place for querying information about captures about lambdas that are; // partially processed) and perhaps during instantiation of function templates; // that contain lambda expressions that need to be transformed BUT not; // necessarily during instantiation of a nested generic lambda's function call; // operator (which might even be instantiated at the end of the TU) - at which; // time the DeclContext tree is mature enough to query capture information; // reliably - we use a two pronged approach to walk through all the lexically; // enclosing lambda expressions:; //; // 1) Climb down the FunctionScopeInfo stack as long as each item represents; // a Lambda (i.e. LambdaScopeInfo) AND each LSI's 'closure-type' is lexically; // enclosed by the call-operator of the LSI below it on the stack (while; // tracking the enclosing DC for step 2 if needed). Note the topmost LSI on; // the stack represents the innermost lambda.; //; // 2) If we run out of enclosing LSI's, check if the enclosing DeclContext; // represents a lambda's call operator. If it does, we must be instantiating; // a generic lambda's call operator (represented by the Current LSI, and; // should be the only scenario where an inconsistency between the LSI and the; // DeclContext should occur), so climb o",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:2147,Availability,down,down,2147," cv-qualifiers of the '*this' object.; // The object referred to by '*this' starts out with the cv-qualifiers of its; // member function. We then start with the innermost lambda and iterate; // outward checking to see if any lambda performs a by-copy capture of '*this'; // - and if so, any nested lambda must respect the 'constness' of that; // capturing lamdbda's call operator.; //; // Since the FunctionScopeInfo stack is representative of the lexical; // nesting of the lambda expressions during initial parsing (and is the best; // place for querying information about captures about lambdas that are; // partially processed) and perhaps during instantiation of function templates; // that contain lambda expressions that need to be transformed BUT not; // necessarily during instantiation of a nested generic lambda's function call; // operator (which might even be instantiated at the end of the TU) - at which; // time the DeclContext tree is mature enough to query capture information; // reliably - we use a two pronged approach to walk through all the lexically; // enclosing lambda expressions:; //; // 1) Climb down the FunctionScopeInfo stack as long as each item represents; // a Lambda (i.e. LambdaScopeInfo) AND each LSI's 'closure-type' is lexically; // enclosed by the call-operator of the LSI below it on the stack (while; // tracking the enclosing DC for step 2 if needed). Note the topmost LSI on; // the stack represents the innermost lambda.; //; // 2) If we run out of enclosing LSI's, check if the enclosing DeclContext; // represents a lambda's call operator. If it does, we must be instantiating; // a generic lambda's call operator (represented by the Current LSI, and; // should be the only scenario where an inconsistency between the LSI and the; // DeclContext should occur), so climb out the DeclContexts if they; // represent lambdas, while querying the corresponding closure types; // regarding capture information.; // 1) Climb down the function scope info stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:414,Performance,perform,performs,414,"// Iterate through the stack of lambdas starting from the innermost lambda to; // the outermost lambda, checking if '*this' is ever captured by copy - since; // that could change the cv-qualifiers of the '*this' object.; // The object referred to by '*this' starts out with the cv-qualifiers of its; // member function. We then start with the innermost lambda and iterate; // outward checking to see if any lambda performs a by-copy capture of '*this'; // - and if so, any nested lambda must respect the 'constness' of that; // capturing lamdbda's call operator.; //; // Since the FunctionScopeInfo stack is representative of the lexical; // nesting of the lambda expressions during initial parsing (and is the best; // place for querying information about captures about lambdas that are; // partially processed) and perhaps during instantiation of function templates; // that contain lambda expressions that need to be transformed BUT not; // necessarily during instantiation of a nested generic lambda's function call; // operator (which might even be instantiated at the end of the TU) - at which; // time the DeclContext tree is mature enough to query capture information; // reliably - we use a two pronged approach to walk through all the lexically; // enclosing lambda expressions:; //; // 1) Climb down the FunctionScopeInfo stack as long as each item represents; // a Lambda (i.e. LambdaScopeInfo) AND each LSI's 'closure-type' is lexically; // enclosed by the call-operator of the LSI below it on the stack (while; // tracking the enclosing DC for step 2 if needed). Note the topmost LSI on; // the stack represents the innermost lambda.; //; // 2) If we run out of enclosing LSI's, check if the enclosing DeclContext; // represents a lambda's call operator. If it does, we must be instantiating; // a generic lambda's call operator (represented by the Current LSI, and; // should be the only scenario where an inconsistency between the LSI and the; // DeclContext should occur), so climb o",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:144,Availability,recover,recover,144,"// This is a lambda call operator that is being instantiated as a default; // initializer. DC must point to the enclosing class type, so we can recover; // the 'this' type from it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:144,Safety,recover,recover,144,"// This is a lambda call operator that is being instantiated as a default; // initializer. DC must point to the enclosing class type, so we can recover; // the 'this' type from it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:33,Availability,Error,Error,33,"// [=, this] {}; // until C++20: Error: this when = is the default",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:164,Performance,perform,perform,164,"// Regarding (Explicit && idx == MaxFunctionScopesIndex): only the first; // iteration through can be an explicit capture, all enclosing closures,; // if any, must perform implicit captures.; // This closure can capture 'this'; continue looking upwards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:29,Integrability,depend,dependent,29,// Avoid creating a non-type-dependent expression that contains typos.; // Non-type-dependent expressions are liable to be discarded without; // checking for embedded typos.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:84,Integrability,depend,dependent,84,// Avoid creating a non-type-dependent expression that contains typos.; // Non-type-dependent expressions are liable to be discarded without; // checking for embedded typos.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Safety,Avoid,Avoid,3,// Avoid creating a non-type-dependent expression that contains typos.; // Non-type-dependent expressions are liable to be discarded without; // checking for embedded typos.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:92,Performance,perform,perform,92,"// C++17 [expr.type.conv]p1:; // If the type is a placeholder for a deduced class type, [...perform class; // template argument deduction...]; // C++23:; // Otherwise, if the type contains a placeholder type, it is replaced by the; // type determined by placeholder type deduction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:142,Performance,perform,performs,142,"// C++17 [expr.type.conv]p2:; // If the type is cv void and the initializer is (), the expression is a; // prvalue of the specified type that performs no initialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:51,Modifiability,extend,extended,51,"// C++17 [expr.delete]p10:; // If the type has new-extended alignment, a function with a parameter; // of type std::align_val_t is preferred; otherwise a function without; // such a parameter is preferred",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:37,Modifiability,extend,extended,37,"/// Determine whether a type has new-extended alignment. This may be called when; /// the type is incomplete (for a delete-expression with an incomplete pointee; /// type), in which case it will conservatively return false if the alignment is; /// not known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:115,Energy Efficiency,allocate,allocate,115,"// If it's ambiguous, it should be illegal to call operator delete[]; // on this thing, so it doesn't matter if we allocate extra space or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:573,Energy Efficiency,allocate,allocated,573,"/// Parsed a C++ 'new' expression (C++ 5.3.4).; ///; /// E.g.:; /// @code new (memory) int[size][4] @endcode; /// or; /// @code ::new Foo(23, ""hello"") @endcode; ///; /// \param StartLoc The first location of the expression.; /// \param UseGlobal True if 'new' was prefixed with '::'.; /// \param PlacementLParen Opening paren of the placement arguments.; /// \param PlacementArgs Placement new arguments.; /// \param PlacementRParen Closing paren of the placement arguments.; /// \param TypeIdParens If the type is in parens, the source range.; /// \param D The type to be allocated, as well as array dimensions.; /// \param Initializer The initializing expression or initializer-list, or null; /// if there is none.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:110,Performance,perform,performed,110,"// - If the new-initializer is omitted, the object is default-; // initialized (8.5); if no initialization is performed,; // the object has indeterminate value",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:37,Energy Efficiency,allocate,allocated,37,"// In ARC, infer 'retaining' for the allocated",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:321,Performance,perform,performed,321,"// C++98 [expr.new]p7:; // The expression in a direct-new-declarator shall have integral type; // with a non-negative value.; //; // Let's see if this is a constant < 0. If so, we reject it out of hand,; // per CWG1464. Otherwise, if it's not a constant, we must have an; // unparenthesized array type.; // We've already performed any required implicit conversion to integer or; // unscoped enumeration type.; // FIXME: Per CWG1464, we are required to check the value prior to; // converting to size_t. This will never find a negative array size in; // C++14 onwards, because Value is always unsigned here!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:20,Performance,perform,perform,20,"// We would like to perform some checking on the given `operator new` call,; // but the PlacementArgs does not contain the implicit arguments,; // namely allocation size and maybe allocation alignment,; // so we need to conjure them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:32,Energy Efficiency,allocate,allocate,32,// How many bytes do we want to allocate here?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:47,Energy Efficiency,allocate,allocate,47,"// For non-array operator new, we only want to allocate one element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:98,Energy Efficiency,allocate,allocate,98,"// Let's synthesize the alignment argument in case we will need it.; // Since we *really* want to allocate these on stack, this is slightly ugly; // because there might not be a `std::align_val_t` type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:49,Energy Efficiency,allocate,allocated,49,// Warn if the type is over-aligned and is being allocated by (unaligned); // global operator new.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:13,Performance,perform,perform,13,"// If we can perform the initialization, and we've not already done so,; // do it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:42,Energy Efficiency,allocate,allocated,42,/// Checks that a type is suitable as the allocated type; /// in a new-expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:69,Energy Efficiency,allocate,allocated,69,"// C++17 [expr.new]p13:; // If no matching function is found and the allocated object type has; // new-extended alignment, the alignment argument is removed from the; // argument list, and overload resolution is performed again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:103,Modifiability,extend,extended,103,"// C++17 [expr.new]p13:; // If no matching function is found and the allocated object type has; // new-extended alignment, the alignment argument is removed from the; // argument list, and overload resolution is performed again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:212,Performance,perform,performed,212,"// C++17 [expr.new]p13:; // If no matching function is found and the allocated object type has; // new-extended alignment, the alignment argument is removed from the; // argument list, and overload resolution is performed again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:222,Energy Efficiency,allocate,allocated,222,"// --- Choosing an allocation function ---; // C++ 5.3.4p8 - 14 & 18; // 1) If looking in AFS_Global scope for allocation functions, only look in; // the global scope. Else, if AFS_Class, only look in the scope of the; // allocated class. If AFS_Both, look in both.; // 2) If an array size is given, look for operator new[], else look for; // operator new.; // 3) The first argument is always size_t. Append the arguments from the; // placement form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:32,Energy Efficiency,allocate,allocated,32,"// C++ [expr.new]p8:; // If the allocated type is a non-array type, the allocation; // function's name is operator new and the deallocation function's; // name is operator delete. If the allocated type is an array; // type, the allocation function's name is operator new[] and the; // deallocation function's name is operator delete[].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:187,Energy Efficiency,allocate,allocated,187,"// C++ [expr.new]p8:; // If the allocated type is a non-array type, the allocation; // function's name is operator new and the deallocation function's; // name is operator delete. If the allocated type is an array; // type, the allocation function's name is operator new[] and the; // deallocation function's name is operator delete[].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:173,Energy Efficiency,allocate,allocated,173,"// C++1z [expr.new]p9:; // If the new-expression begins with a unary :: operator, the allocation; // function's name is looked up in the global scope. Otherwise, if the; // allocated type is a class type T or array thereof, the allocation; // function's name is looked up in the scope of T.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:52,Energy Efficiency,allocate,allocated,52,"// If this lookup fails to find the name, or if the allocated type is not; // a class type, the allocation function's name is looked up in the; // global scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:24,Security,access,access,24,// We do our own custom access checks below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:178,Energy Efficiency,allocate,allocated,178,"// C++ [expr.new]p19:; //; // If the new-expression begins with a unary :: operator, the; // deallocation function's name is looked up in the global; // scope. Otherwise, if the allocated type is a class type T or an; // array thereof, the deallocation function's name is looked up in; // the scope of T. If this lookup fails to find the name, or if; // the allocated type is not a class type or array thereof, the; // deallocation function's name is looked up in the global scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:358,Energy Efficiency,allocate,allocated,358,"// C++ [expr.new]p19:; //; // If the new-expression begins with a unary :: operator, the; // deallocation function's name is looked up in the global; // scope. Otherwise, if the allocated type is a class type T or an; // array thereof, the deallocation function's name is looked up in; // the scope of T. If this lookup fails to find the name, or if; // the allocated type is not a class type or array thereof, the; // deallocation function's name is looked up in the global scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:307,Performance,perform,perform,307,"// C++ [expr.new]p20:; // A declaration of a placement deallocation function matches the; // declaration of a placement allocation function if it has the; // same number of parameters and, after parameter transformations; // (8.3.5), all parameter types except the first are; // identical. [...]; //; // To perform this comparison, we compute the function type that; // the deallocation function should have, and use that type both; // for template argument deduction and for comparison purposes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Performance,Perform,Perform,3,// Perform template argument deduction to try to match the; // expected function type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:19,Modifiability,variab,variable,19,/// Indicates that variable is initialized with mismatching form of \a new.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:20,Modifiability,variab,variable,20,"/// Returns whether variable is initialized with mismatching form of; /// \c new.; ///; /// If variable is initialized with matching form of \c new or variable is not; /// initialized with a \c new expression, this function will return true.; /// If variable is initialized with mismatching form of \c new, returns false.; /// \param D Variable to analyze.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:95,Modifiability,variab,variable,95,"/// Returns whether variable is initialized with mismatching form of; /// \c new.; ///; /// If variable is initialized with matching form of \c new or variable is not; /// initialized with a \c new expression, this function will return true.; /// If variable is initialized with mismatching form of \c new, returns false.; /// \param D Variable to analyze.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:151,Modifiability,variab,variable,151,"/// Returns whether variable is initialized with mismatching form of; /// \c new.; ///; /// If variable is initialized with matching form of \c new or variable is not; /// initialized with a \c new expression, this function will return true.; /// If variable is initialized with mismatching form of \c new, returns false.; /// \param D Variable to analyze.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:250,Modifiability,variab,variable,250,"/// Returns whether variable is initialized with mismatching form of; /// \c new.; ///; /// If variable is initialized with matching form of \c new or variable is not; /// initialized with a \c new expression, this function will return true.; /// If variable is initialized with mismatching form of \c new, returns false.; /// \param D Variable to analyze.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:336,Modifiability,Variab,Variable,336,"/// Returns whether variable is initialized with mismatching form of; /// \c new.; ///; /// If variable is initialized with matching form of \c new or variable is not; /// initialized with a \c new expression, this function will return true.; /// If variable is initialized with mismatching form of \c new, returns false.; /// \param D Variable to analyze.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Performance,Perform,Perform,3,"// Perform lvalue-to-rvalue cast, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:10,Performance,Perform,PerformContextualImplicitConversion,10,// FIXME: PerformContextualImplicitConversion should return ExprError; // itself in this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:29,Availability,error,errors,29,// FIXME: This can result in errors if the definition was imported from a; // module but is hidden.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:9,Security,access,access,9,// Check access and ambiguity of destructor if we're going to call it.; // Note that this is required even for a virtual delete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:76,Security,access,access,76,// Qualifiers are irrelevant to this conversion; we're only looking; // for access and ambiguity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:24,Security,access,access,24,// We do our own custom access checks below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:31,Modifiability,variab,variable,31,"/// Check the use of the given variable as a C++ condition in an if,; /// while, do-while, or switch statement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:158,Modifiability,variab,variable,158,"// C++11 6.4p4:; // The value of a condition that is an initialized declaration in a statement; // other than a switch statement is the value of the declared variable; // implicitly converted to type bool. If that conversion is ill-formed, the; // program is ill-formed.; // The value of a condition that is an expression is the value of the; // expression, implicitly converted to bool.; //; // C++23 8.5.2p2; // If the if statement is of the form if constexpr, the value of the condition; // is contextually converted to bool and the converted expression shall be; // a constant expression.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:279,Availability,error,error,279,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType using the pre-computed implicit; /// conversion sequence ICS. Returns the converted; /// expression. Action is the kind of conversion we're performing,; /// used in the error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:285,Integrability,message,message,285,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType using the pre-computed implicit; /// conversion sequence ICS. Returns the converted; /// expression. Action is the kind of conversion we're performing,; /// used in the error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:4,Performance,Perform,PerformImplicitConversion,4,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType using the pre-computed implicit; /// conversion sequence ICS. Returns the converted; /// expression. Action is the kind of conversion we're performing,; /// used in the error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:32,Performance,Perform,Perform,32,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType using the pre-computed implicit; /// conversion sequence ICS. Returns the converted; /// expression. Action is the kind of conversion we're performing,; /// used in the error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:250,Performance,perform,performing,250,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType using the pre-computed implicit; /// conversion sequence ICS. Returns the converted; /// expression. Action is the kind of conversion we're performing,; /// used in the error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:286,Availability,error,error,286,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType by following the standard; /// conversion sequence SCS. Returns the converted; /// expression. Flavor is the context in which we're performing this; /// conversion, for use in error messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:292,Integrability,message,messages,292,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType by following the standard; /// conversion sequence SCS. Returns the converted; /// expression. Flavor is the context in which we're performing this; /// conversion, for use in error messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:4,Performance,Perform,PerformImplicitConversion,4,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType by following the standard; /// conversion sequence SCS. Returns the converted; /// expression. Flavor is the context in which we're performing this; /// conversion, for use in error messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:32,Performance,Perform,Perform,32,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType by following the standard; /// conversion sequence SCS. Returns the converted; /// expression. Flavor is the context in which we're performing this; /// conversion, for use in error messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:242,Performance,perform,performing,242,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType by following the standard; /// conversion sequence SCS. Returns the converted; /// expression. Flavor is the context in which we're performing this; /// conversion, for use in error messages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Performance,Perform,Perform,3,// Perform the first implicit conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Performance,Perform,Perform,3,// Perform the second implicit conversion,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:16,Modifiability,extend,extend,16,// Make sure we extend blocks if necessary.; // FIXME: doing this here is really ugly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:135,Modifiability,inherit,inheritance,135,// We may not have been able to figure out what this member pointer resolved; // to up until this exact point. Attempt to lock-in it's inheritance model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Performance,Perform,Perform,3,// Perform half-to-boolean conversion via float.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:71,Performance,perform,perform,71,"// If this conversion sequence involved a scalar -> atomic conversion, perform; // that conversion now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:539,Modifiability,portab,portability,539,"// C++0x [meta.unary.prop]p3:; // For all of the class templates X declared in this Clause, instantiating; // that template with a template argument that is a class template; // specialization may result in the implicit instantiation of the template; // argument if and only if the semantics of X require that the argument; // must be a complete type.; // We apply this rule to all the type trait expressions used to implement; // these class templates. We also try to follow any GCC documented behavior; // in these expressions to ensure portability of standard libraries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:208,Deployability,release,release,208,"// Note: semantic analysis depends on Objective-C lifetime types to be; // considered scalar types. However, such types do not actually behave; // like scalar types at run time (since they may require retain/release; // operations), so we report them as non-scalar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:27,Integrability,depend,depends,27,"// Note: semantic analysis depends on Objective-C lifetime types to be; // considered scalar types. However, such types do not actually behave; // like scalar types at run time (since they may require retain/release; // operations), so we report them as non-scalar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:123,Integrability,interface,interface,123,// __is_interface_class only returns true when CL is invoked in /CLR mode and; // even then only when it is used with the 'interface struct ...' syntax; // Clang doesn't support /CLR which makes this type trait moot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:129,Testability,log,logic,129,// This trait is implemented by MSVC 2012 and needed to parse the; // standard library headers. Specifically this is used as the logic; // behind std::is_trivially_move_constructible (20.9.4.3).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:127,Testability,log,logic,127,// This trait is implemented by MSVC 2012 and needed to parse the; // standard library headers. Specifically it is used as the logic; // behind std::is_trivially_move_assignable (20.9.4.3),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:538,Availability,error,errors,538,"// http://gcc.gnu.org/onlinedocs/gcc/Type-Traits.html:; // If type is const qualified or is a reference type then the; // trait is false. Otherwise if __is_pod (type) is true then the; // trait is true, else if type is a cv class or union type with; // a trivial copy assignment ([class.copy]) then the trait is; // true, else it is false.; // Note: the const and reference restrictions are interesting,; // given that const and reference members don't prevent a class; // from having a trivial copy assignment operator (but do cause; // errors if the copy assignment operator is actually used, q.v.; // [class.copy]p12).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:129,Testability,log,logic,129,// This trait is implemented by MSVC 2012 and needed to parse the; // standard library headers. Specifically this is used as the logic; // behind std::is_nothrow_move_assignable (20.9.4.3).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:119,Safety,avoid,avoid,119,// Evaluate ReferenceBindsToTemporary and ReferenceConstructsFromTemporary; // alongside the IsConstructible traits to avoid duplication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:134,Modifiability,variab,variable,134,"// C++11 [meta.unary.prop]:; // is_trivially_constructible is defined as:; //; // is_constructible<T, Args...>::value is true and the variable; // definition for is_constructible, as defined below, is known to call; // no operation that is not trivial.; //; // The predicate condition for a template specialization; // is_constructible<T, Args...> shall be satisfied if and only if the; // following variable definition would be well-formed for some invented; // variable t:; //; // T t(create<Args>()...);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:400,Modifiability,variab,variable,400,"// C++11 [meta.unary.prop]:; // is_trivially_constructible is defined as:; //; // is_constructible<T, Args...>::value is true and the variable; // definition for is_constructible, as defined below, is known to call; // no operation that is not trivial.; //; // The predicate condition for a template specialization; // is_constructible<T, Args...> shall be satisfied if and only if the; // following variable definition would be well-formed for some invented; // variable t:; //; // T t(create<Args>()...);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:463,Modifiability,variab,variable,463,"// C++11 [meta.unary.prop]:; // is_trivially_constructible is defined as:; //; // is_constructible<T, Args...>::value is true and the variable; // definition for is_constructible, as defined below, is known to call; // no operation that is not trivial.; //; // The predicate condition for a template specialization; // is_constructible<T, Args...> shall be satisfied if and only if the; // following variable definition would be well-formed for some invented; // variable t:; //; // T t(create<Args>()...);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Performance,Perform,Perform,3,// Perform the initialization in an unevaluated context within a SFINAE; // trap at translation unit scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:2,Security,Access,AccessCheckingSFINAE,2,/*AccessCheckingSFINAE=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:501,Performance,perform,performed,501,"// C++0x [meta.rel]p4:; // Given the following function prototype:; //; // template <class T>; // typename add_rvalue_reference<T>::type create();; //; // the predicate condition for a template specialization; // is_convertible<From, To> shall be satisfied if and only if; // the return expression in the following code would be; // well-formed, including any implicit conversions to the return; // type of the function:; //; // To test() {; // return create<From>();; // }; //; // Access checking is performed as if in a context unrelated to To and; // From. Only the validity of the immediate context of the expression; // of the return-statement (including conversions to the return type); // is considered.; //; // We model the initialization as a copy-initialization of a temporary; // of the appropriate type, which for this expression is identical to the; // return statement (since NRVO doesn't apply).; // Functions aren't allowed to return function or array types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:482,Security,Access,Access,482,"// C++0x [meta.rel]p4:; // Given the following function prototype:; //; // template <class T>; // typename add_rvalue_reference<T>::type create();; //; // the predicate condition for a template specialization; // is_convertible<From, To> shall be satisfied if and only if; // the return expression in the following code would be; // well-formed, including any implicit conversions to the return; // type of the function:; //; // To test() {; // return create<From>();; // }; //; // Access checking is performed as if in a context unrelated to To and; // From. Only the validity of the immediate context of the expression; // of the return-statement (including conversions to the return type); // is considered.; //; // We model the initialization as a copy-initialization of a temporary; // of the appropriate type, which for this expression is identical to the; // return statement (since NRVO doesn't apply).; // Functions aren't allowed to return function or array types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:432,Testability,test,test,432,"// C++0x [meta.rel]p4:; // Given the following function prototype:; //; // template <class T>; // typename add_rvalue_reference<T>::type create();; //; // the predicate condition for a template specialization; // is_convertible<From, To> shall be satisfied if and only if; // the return expression in the following code would be; // well-formed, including any implicit conversions to the return; // type of the function:; //; // To test() {; // return create<From>();; // }; //; // Access checking is performed as if in a context unrelated to To and; // From. Only the validity of the immediate context of the expression; // of the return-statement (including conversions to the return type); // is considered.; //; // We model the initialization as a copy-initialization of a temporary; // of the appropriate type, which for this expression is identical to the; // return statement (since NRVO doesn't apply).; // Functions aren't allowed to return function or array types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Performance,Perform,Perform,3,// Perform the initialization in an unevaluated context within a SFINAE; // trap at translation unit scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:2,Security,Access,AccessCheckingSFINAE,2,/*AccessCheckingSFINAE=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:2,Security,Access,AccessCheckingSFINAE,2,/*AccessCheckingSFINAE=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:6,Availability,error,error,6,"// If error parsing the expression, ignore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:32,Integrability,depend,dependent,32,// Delay type-checking for type-dependent expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:456,Security,access,accessible,456,"// Note: C++ [expr.mptr.oper]p2-3 says that the class type into which the; // member pointer points must be completely-defined. However, there is no; // reason for this semantic distinction, and the rule is not enforced by; // other compilers. Therefore, we do not check this property, as it is; // likely to be considered a defect.; // C++ 5.5p2; // [...] to its first operand, which shall be of class T or of a class of; // which T is an unambiguous and accessible base class. [p3: a pointer to; // such a class]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:104,Security,validat,validation,104,"/// Try to convert a type to another according to C++11 5.16p3.; ///; /// This is part of the parameter validation for the ? operator. If either; /// value operand is a class type, the two operands are attempted to be; /// converted to each other. This function does the conversion in one direction.; /// It returns true if the program is ill-formed and has already been diagnosed; /// as such.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:105,Security,validat,validation,105,"/// Try to find a common type for two according to C++0x 5.16p5.; ///; /// This is part of the parameter validation for the ? operator. If either; /// value operand is a class type, overload resolution is used to find a; /// conversion to a common type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:21,Performance,Perform,Perform,21,// We found a match. Perform the conversions on the arguments and move on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:16,Modifiability,extend,extended,16,"/// Perform an ""extended"" implicit conversion as returned by; /// TryClassUnification.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:4,Performance,Perform,Perform,4,"/// Perform an ""extended"" implicit conversion as returned by; /// TryClassUnification.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:65,Integrability,interface,interface,65,"// FIXME: Handle C99's complex types, block pointers and Obj-C++ interface; // pointers.; // Assume r-value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:27,Integrability,depend,dependent,27,// Either of the arguments dependent?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:18,Availability,error,error,18,"// Neither holds, error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:258,Modifiability,extend,extend,258,"// C++11 [expr.cond]p3; // if both are glvalues of the same value category and the same type except; // for cv-qualification, an attempt is made to convert each of those; // operands to the type of the other.; // FIXME:; // Resolving a defect in P0012R1: we extend this to cover all cases where; // one of the operands is reference-compatible with the other, in order; // to support conditionals between functions differing in noexcept. This; // will similarly cover difference in array bounds after P0388R4.; // FIXME: If LTy and RTy have a composite pointer type, should we convert to; // that instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:294,Modifiability,extend,extend,294,"// C++11 [expr.cond]p4; // If the second and third operands are glvalues of the same value; // category and have the same type, the result is of that type and; // value category and it is a bit-field if the second or the third; // operand is a bit-field, or if both are bit-fields.; // We only extend this to bitfields, not to the crazy other kinds of; // l-values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:116,Performance,perform,performed,116,"// C++11 [expr.cond]p6; // Lvalue-to-rvalue, array-to-pointer, and function-to-pointer standard; // conversions are performed on the second and third operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:327,Integrability,depend,depending,327,"// After those conversions, one of the following shall hold:; // -- The second and third operands have the same type; the result; // is of that type. If the operands have class type, the result; // is a prvalue temporary of the result type, which is; // copy-initialized from either the second operand or the third; // operand depending on the value of the first operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:114,Performance,perform,performed,114,"// -- The second and third operands have arithmetic or enumeration type;; // the usual arithmetic conversions are performed to bring them to a; // common type, and the result is of that type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:262,Performance,perform,performed,262,"// -- The second and third operands have pointer type, or one has pointer; // type and the other is a null pointer constant, or both are null; // pointer constants, at least one of which is non-integral; pointer; // conversions and qualification conversions are performed to bring them; // to their composite pointer type. The result is of the composite; // pointer type.; // -- The second and third operands have pointer to member type, or one has; // pointer to member type and the other is a null pointer constant;; // pointer to member conversions and qualification conversions are; // performed to bring them to a common type, whose cv-qualification; // shall match the cv-qualification of either the second or the third; // operand. The result is of the common type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:590,Performance,perform,performed,590,"// -- The second and third operands have pointer type, or one has pointer; // type and the other is a null pointer constant, or both are null; // pointer constants, at least one of which is non-integral; pointer; // conversions and qualification conversions are performed to bring them; // to their composite pointer type. The result is of the composite; // pointer type.; // -- The second and third operands have pointer to member type, or one has; // pointer to member type and the other is a null pointer constant;; // pointer to member conversions and qualification conversions are; // performed to bring them to a common type, whose cv-qualification; // shall match the cv-qualification of either the second or the third; // operand. The result is of the common type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:28,Performance,perform,perform,28,"// At the top level, we can perform a base-to-derived pointer-to-member; // conversion:; //; // - [...] where C1 is reference-related to C2 or C2 is; // reference-related to C1; //; // (Note that the only kinds of reference-relatedness in scope here are; // ""same type or derived from"".) At any other level, the class must; // exactly match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:931,Availability,down,down,931,"// - if T1 or T2 is ""pointer to noexcept function"" and the other type is; // ""pointer to function"", where the function types are otherwise the same,; // ""pointer to function"";; // - if T1 or T2 is ""pointer to member of C1 of type function"", the other; // type is ""pointer to member of C2 of type noexcept function"", and C1; // is reference-related to C2 or C2 is reference-related to C1, where; // the function types are otherwise the same, ""pointer to member of C2 of; // type function"" or ""pointer to member of C1 of type function"",; // respectively;; //; // We also support 'noreturn' here, so as a Clang extension we generalize the; // above to:; //; // - [Clang] If T1 and T2 are both of type ""pointer to function"" or; // ""pointer to member function"" and the pointee types can be unified; // by a function pointer conversion, that conversion is applied; // before checking the following rules.; //; // We've already unwrapped down to the function types, and we want to merge; // rather than just convert, so do this ourselves rather than calling; // IsFunctionConversion.; //; // FIXME: In order to match the standard wording as closely as possible, we; // currently only do this under a single level of pointers. Ideally, we would; // allow this in general, and set NeedConstBefore to the relevant depth on; // the side(s) where we changed anything. If we permit that, we should also; // consider this conversion when determining type similarity and model it as; // a qualification conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:42,Performance,perform,perform,42,// There are some more conversions we can perform under exactly one pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:47,Safety,avoid,avoid,47,// FIXME: Let the caller know if these fail to avoid duplicate diagnostics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:56,Performance,optimiz,optimization,56,// We hit this case with the lambda conversion-to-block optimization;; // we don't want any extra casts here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:7,Integrability,message,message,7,"// For message sends and property references, we try to find an; // actual method. FIXME: we should infer retention by selector in; // cases where we don't have an actual method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:24,Performance,perform,performSelector,24,"// Don't do reclaims on performSelector calls; despite their; // return type, the invoked method doesn't necessarily actually; // return an object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:36,Safety,avoid,avoid,36,"// If destructor is trivial, we can avoid the extra copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:46,Integrability,wrap,wrap,46,"// FIXME: In order to attach the temporaries, wrap the statement into; // a StmtExpr; currently this is only used for asm statements.; // This is hacky, either create a new CXXStmtWithTemporaries statement or; // a new AsmStmtWithTemporaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:21,Performance,perform,perform,21,"// In MS mode, don't perform any extra checking of call return types within a; // decltype expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Performance,Perform,Perform,3,// Perform the semantic checks we delayed until this point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:66,Security,access,accessible,66,"// Now all relevant types are complete, check the destructors are accessible; // and non-deleted, and annotate them on the temporaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:69,Security,access,access,69,/// Note a set of 'operator->' functions that were used for a member access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:20,Modifiability,config,configurable,20,// FIXME: Make this configurable?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:29,Integrability,depend,dependent,29,"// If we have a pointer to a dependent type and are using the -> operator,; // the object type is the type that the pointer points to. We might still; // have enough information about that type to do something useful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:176,Availability,error,error,176,"// When in a template specialization and on the first loop iteration,; // potentially give the default diagnostic (with the fixit in a; // separate note) instead of having the error reported back to here; // and giving a diagnostic with a fixit attached to the error itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:261,Availability,error,error,261,"// When in a template specialization and on the first loop iteration,; // potentially give the default diagnostic (with the fixit in a; // separate note) instead of having the error reported back to here; // and giving a diagnostic with a fixit attached to the error itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:36,Security,access,access,36,"// Objective-C properties allow ""."" access on Objective-C pointer types,; // so adjust the base type to the object type itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:407,Security,access,access,407,"// C++ [basic.lookup.classref]p2:; // [...] If the type of the object expression is of pointer to scalar; // type, the unqualified-id is looked up in the context of the complete; // postfix-expression.; //; // This also indicates that we could be parsing a pseudo-destructor-name.; // Note that Objective-C class and object types can be pseudo-destructor; // expressions or normal member (ivar or property) access expressions, and; // it's legal for the type to be incomplete if this is a pseudo-destructor; // call. We'll do more incomplete-type checks later in the lookup process,; // so just skip this check for ObjC types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:40,Integrability,depend,dependent,40,"// The object type must be complete (or dependent), or; // C++11 [expr.prim.general]p3:; // Unlike the object expression in other contexts, *this is not required to; // be of complete type for purposes of class member access (5.2.5) outside; // the member function body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:218,Security,access,access,218,"// The object type must be complete (or dependent), or; // C++11 [expr.prim.general]p3:; // Unlike the object expression in other contexts, *this is not required to; // be of complete type for purposes of class member access (5.2.5) outside; // the member function body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:77,Security,access,access,77,"// C++ [basic.lookup.classref]p2:; // If the id-expression in a class member access (5.2.5) is an; // unqualified-id, and the type of the object expression is of a class; // type C (or of pointer to a class type C), the unqualified-id is looked; // up in the scope of class C. [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:39,Performance,perform,perform,39,"// The operator requires a prvalue, so perform lvalue conversions.; // Only do this if we might plausibly end with a pointer, as otherwise; // this was likely to be intended to be a '.'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:32,Availability,recover,recover,32,/// Check if it's ok to try and recover dot pseudo destructor calls on; /// pointer objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:32,Safety,recover,recover,32,/// Check if it's ok to try and recover dot pseudo destructor calls on; /// pointer objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Safety,Detect,Detect,3,"// Detect dot pseudo destructor calls on pointer objects, e.g.:; // Foo *foo;; // foo.~Foo();",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Availability,Recover,Recover,3,// Recover by setting the object type to the destructed type and the; // operator to '->'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Safety,Recover,Recover,3,// Recover by setting the object type to the destructed type and the; // operator to '->'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Availability,Recover,Recover,3,// Recover by setting the destructed type to the object type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Safety,Recover,Recover,3,// Recover by setting the destructed type to the object type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Availability,Recover,Recover,3,// Recover by setting the destructed type to the object type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Safety,Recover,Recover,3,// Recover by setting the destructed type to the object type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:98,Integrability,depend,dependent,98,// Compute the object type that we should use for name lookup purposes. Only; // record types and dependent types matter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:45,Integrability,depend,dependent,45,"// The name of the type being destroyed is a dependent name, and we; // couldn't find anything useful in scope. Just store the identifier and; // it's location, and we'll perform (qualified) name lookup again at; // template instantiation time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:171,Performance,perform,perform,171,"// The name of the type being destroyed is a dependent name, and we; // couldn't find anything useful in scope. Just store the identifier and; // it's location, and we'll perform (qualified) name lookup again at; // template instantiation time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Availability,Recover,Recover,3,// Recover by assuming we had the right type all along.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Safety,Recover,Recover,3,// Recover by assuming we had the right type all along.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Availability,Recover,Recover,3,// Recover by assuming we had the right type all along.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Safety,Recover,Recover,3,// Recover by assuming we had the right type all along.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:35,Availability,recover,recovery,35,"// If we've performed some kind of recovery, (re-)build the type source; // information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:12,Performance,perform,performed,12,"// If we've performed some kind of recovery, (re-)build the type source; // information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:35,Safety,recover,recovery,35,"// If we've performed some kind of recovery, (re-)build the type source; // information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Availability,Recover,Recover,3,// Recover by dropping this type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Safety,Recover,Recover,3,// Recover by dropping this type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:52,Modifiability,variab,variable,52,"// Don't decrement RefsMinusAssignments if volatile variable with compound; // assignment (+=, ...) or increment/decrement unary operator to avoid; // potential unused-but-set-variable warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:176,Modifiability,variab,variable,176,"// Don't decrement RefsMinusAssignments if volatile variable with compound; // assignment (+=, ...) or increment/decrement unary operator to avoid; // potential unused-but-set-variable warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:141,Safety,avoid,avoid,141,"// Don't decrement RefsMinusAssignments if volatile variable with compound; // assignment (+=, ...) or increment/decrement unary operator to avoid; // potential unused-but-set-variable warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:4,Performance,Perform,Perform,4,/// Perform the conversions required for an expression used in a; /// context that ignores the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:190,Performance,perform,perform,190,"// The C++11 standard defines the notion of a discarded-value expression;; // normally, we don't need to do anything to handle it, but if it is a; // volatile lvalue with a special form, we perform an lvalue-to-rvalue; // conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:160,Integrability,depend,dependent,160,"// If we can unambiguously determine whether Var can never be used; // in a constant expression, return true.; // - if the variable and its initializer are non-dependent, then; // we can unambiguously check if the variable is a constant expression.; // - if the initializer is not value dependent - we can determine whether; // it can be used to initialize a constant expression. If Init can not; // be used to initialize a constant expression we conclude that Var can; // never be a constant expression.; // - FXIME: if the initializer is dependent, we can still do some analysis and; // identify certain cases unambiguously as non-const by using a Visitor:; // - such as those that involve odr-use of a ParmVarDecl, involve a new; // delete, lambda-expr, dynamic-cast, reinterpret-cast etc...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:287,Integrability,depend,dependent,287,"// If we can unambiguously determine whether Var can never be used; // in a constant expression, return true.; // - if the variable and its initializer are non-dependent, then; // we can unambiguously check if the variable is a constant expression.; // - if the initializer is not value dependent - we can determine whether; // it can be used to initialize a constant expression. If Init can not; // be used to initialize a constant expression we conclude that Var can; // never be a constant expression.; // - FXIME: if the initializer is dependent, we can still do some analysis and; // identify certain cases unambiguously as non-const by using a Visitor:; // - such as those that involve odr-use of a ParmVarDecl, involve a new; // delete, lambda-expr, dynamic-cast, reinterpret-cast etc...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:540,Integrability,depend,dependent,540,"// If we can unambiguously determine whether Var can never be used; // in a constant expression, return true.; // - if the variable and its initializer are non-dependent, then; // we can unambiguously check if the variable is a constant expression.; // - if the initializer is not value dependent - we can determine whether; // it can be used to initialize a constant expression. If Init can not; // be used to initialize a constant expression we conclude that Var can; // never be a constant expression.; // - FXIME: if the initializer is dependent, we can still do some analysis and; // identify certain cases unambiguously as non-const by using a Visitor:; // - such as those that involve odr-use of a ParmVarDecl, involve a new; // delete, lambda-expr, dynamic-cast, reinterpret-cast etc...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:123,Modifiability,variab,variable,123,"// If we can unambiguously determine whether Var can never be used; // in a constant expression, return true.; // - if the variable and its initializer are non-dependent, then; // we can unambiguously check if the variable is a constant expression.; // - if the initializer is not value dependent - we can determine whether; // it can be used to initialize a constant expression. If Init can not; // be used to initialize a constant expression we conclude that Var can; // never be a constant expression.; // - FXIME: if the initializer is dependent, we can still do some analysis and; // identify certain cases unambiguously as non-const by using a Visitor:; // - such as those that involve odr-use of a ParmVarDecl, involve a new; // delete, lambda-expr, dynamic-cast, reinterpret-cast etc...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:214,Modifiability,variab,variable,214,"// If we can unambiguously determine whether Var can never be used; // in a constant expression, return true.; // - if the variable and its initializer are non-dependent, then; // we can unambiguously check if the variable is a constant expression.; // - if the initializer is not value dependent - we can determine whether; // it can be used to initialize a constant expression. If Init can not; // be used to initialize a constant expression we conclude that Var can; // never be a constant expression.; // - FXIME: if the initializer is dependent, we can still do some analysis and; // identify certain cases unambiguously as non-const by using a Visitor:; // - such as those that involve odr-use of a ParmVarDecl, involve a new; // delete, lambda-expr, dynamic-cast, reinterpret-cast etc...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:60,Integrability,depend,dependent,60,"// FIXME: Teach the constant evaluator to deal with the non-dependent parts; // of value-dependent expressions, and use it here to determine whether the; // initializer is a potential constant expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:89,Integrability,depend,dependent,89,"// FIXME: Teach the constant evaluator to deal with the non-dependent parts; // of value-dependent expressions, and use it here to determine whether the; // initializer is a potential constant expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:272,Modifiability,variab,variables,272,"/// Check if the current lambda has any potential captures; /// that must be captured by any of its enclosing lambdas that are ready to; /// capture. If there is a lambda that can capture a nested; /// potential-capture, go ahead and do so. Also, check to see if any; /// variables are uncaptureable or do not involve an odr-use so do not; /// need to be captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:181,Integrability,depend,dependent,181,"// All the potentially captureable variables in the current nested; // lambda (within a generic outer lambda), must be captured by an; // outer lambda that is enclosed within a non-dependent context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:35,Modifiability,variab,variables,35,"// All the potentially captureable variables in the current nested; // lambda (within a generic outer lambda), must be captured by an; // outer lambda that is enclosed within a non-dependent context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:106,Integrability,depend,dependent,106,"// If the variable is clearly identified as non-odr-used and the full; // expression is not instantiation dependent, only then do we not; // need to check enclosing lambda's for speculative captures.; // For e.g.:; // Even though 'x' is not odr-used, it should be captured.; // int test() {; // const int x = 10;; // auto L = [=](auto a) {; // (void) +x + a;; // };; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:10,Modifiability,variab,variable,10,"// If the variable is clearly identified as non-odr-used and the full; // expression is not instantiation dependent, only then do we not; // need to check enclosing lambda's for speculative captures.; // For e.g.:; // Even though 'x' is not odr-used, it should be captured.; // int test() {; // const int x = 10;; // auto L = [=](auto a) {; // (void) +x + a;; // };; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:282,Testability,test,test,282,"// If the variable is clearly identified as non-odr-used and the full; // expression is not instantiation dependent, only then do we not; // need to check enclosing lambda's for speculative captures.; // For e.g.:; // Even though 'x' is not odr-used, it should be captured.; // int test() {; // const int x = 10;; // auto L = [=](auto a) {; // (void) +x + a;; // };; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:22,Usability,clear,clearly,22,"// If the variable is clearly identified as non-odr-used and the full; // expression is not instantiation dependent, only then do we not; // need to check enclosing lambda's for speculative captures.; // For e.g.:; // Even though 'x' is not odr-used, it should be captured.; // int test() {; // const int x = 10;; // auto L = [=](auto a) {; // (void) +x + a;; // };; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:47,Modifiability,variab,variable,47,"// If we have a capture-capable lambda for the variable, go ahead and; // capture the variable in that lambda (and all its enclosing lambdas).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:86,Modifiability,variab,variable,86,"// If we have a capture-capable lambda for the variable, go ahead and; // capture the variable in that lambda (and all its enclosing lambdas).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:283,Availability,error,errors,283,"// This full expression is not instantiation dependent or the variable; // can not be used in a constant expression - which means; // this variable must be odr-used here, so diagnose a; // capture violation early, if the variable is un-captureable.; // This is purely for diagnosing errors early. Otherwise, this; // error would get diagnosed when the lambda becomes capture ready.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:317,Availability,error,error,317,"// This full expression is not instantiation dependent or the variable; // can not be used in a constant expression - which means; // this variable must be odr-used here, so diagnose a; // capture violation early, if the variable is un-captureable.; // This is purely for diagnosing errors early. Otherwise, this; // error would get diagnosed when the lambda becomes capture ready.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:45,Integrability,depend,dependent,45,"// This full expression is not instantiation dependent or the variable; // can not be used in a constant expression - which means; // this variable must be odr-used here, so diagnose a; // capture violation early, if the variable is un-captureable.; // This is purely for diagnosing errors early. Otherwise, this; // error would get diagnosed when the lambda becomes capture ready.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:62,Modifiability,variab,variable,62,"// This full expression is not instantiation dependent or the variable; // can not be used in a constant expression - which means; // this variable must be odr-used here, so diagnose a; // capture violation early, if the variable is un-captureable.; // This is purely for diagnosing errors early. Otherwise, this; // error would get diagnosed when the lambda becomes capture ready.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:139,Modifiability,variab,variable,139,"// This full expression is not instantiation dependent or the variable; // can not be used in a constant expression - which means; // this variable must be odr-used here, so diagnose a; // capture violation early, if the variable is un-captureable.; // This is purely for diagnosing errors early. Otherwise, this; // error would get diagnosed when the lambda becomes capture ready.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:221,Modifiability,variab,variable,221,"// This full expression is not instantiation dependent or the variable; // can not be used in a constant expression - which means; // this variable must be odr-used here, so diagnose a; // capture violation early, if the variable is un-captureable.; // This is purely for diagnosing errors early. Otherwise, this; // error would get diagnosed when the lambda becomes capture ready.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:41,Modifiability,variab,variable,41,"// We will never be able to capture this variable, and we need; // to be able to in any and all instantiations, so diagnose it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Safety,Detect,Detect,3,// Detect and handle the case where the decl might be an implicit; // member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:13,Safety,avoid,avoid,13,// A decl to avoid as a correction because it is in the; // process of being initialized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:163,Usability,clear,clear,163,"// Recursive corrections didn't work, wipe them away and don't add; // them to the TypoExprs set. Remove them from Sema's TypoExpr list; // since we don't want to clear them twice. Note: it's possible the; // TypoExprs were created recursively and thus won't be in our; // Sema's TypoExprs - they were created in our `RecursiveTransformLoop`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:58,Performance,cache,cache,58,// Fetch the next correction by erasing the typo from the cache and calling; // `TryTransform` which will iterate through corrections in; // `TransformTypoExpr`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:80,Usability,clear,clear,80,"// Wipe away any newly created TypoExprs that we don't know about. Since we; // clear any invalid TypoExprs in `CheckForRecursiveTypos`, this is only; // possible if a `TypoExpr` is created during a transformation but then; // fails before we can discover it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:81,Performance,cache,cached,81,"// If the TypoExpr hasn't been seen before, record it. Otherwise, return the; // cached transformation result if there is one and the TypoExpr isn't the; // first one that was encountered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:106,Availability,error,errors,106,"// FIXME: If we would typo-correct to an invalid declaration, it's; // probably best to just suppress all errors from this typo correction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:2,Availability,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:2,Safety,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:25,Integrability,depend,dependent,25,"// If the name itself is dependent, then the result is dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:55,Integrability,depend,dependent,55,"// If the name itself is dependent, then the result is dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:429,Security,access,access,429,"//===--- SemaExprMember.cpp - Semantic Analysis for Expressions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements semantic analysis member access expressions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:55,Security,access,access,55,/// The reference is definitely not an instance member access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:53,Security,access,access,53,/// The reference may be an implicit instance member access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:60,Security,access,access,60,/// The reference is definitely an implicit instance member access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:336,Availability,error,errors,336,"/// The given lookup names class member(s) and is not being used for; /// an address-of-member expression. Classify the type of access; /// according to whether it's possible that this reference names an; /// instance member. This is best-effort in dependent contexts; it is okay to; /// conservatively answer ""yes"", in which case some errors will simply; /// not be caught until template-instantiation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:249,Integrability,depend,dependent,249,"/// The given lookup names class member(s) and is not being used for; /// an address-of-member expression. Classify the type of access; /// according to whether it's possible that this reference names an; /// instance member. This is best-effort in dependent contexts; it is okay to; /// conservatively answer ""yes"", in which case some errors will simply; /// not be caught until template-instantiation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:128,Security,access,access,128,"/// The given lookup names class member(s) and is not being used for; /// an address-of-member expression. Classify the type of access; /// according to whether it's possible that this reference names an; /// instance member. This is best-effort in dependent contexts; it is okay to; /// conservatively answer ""yes"", in which case some errors will simply; /// not be caught until template-instantiation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:348,Usability,simpl,simply,348,"/// The given lookup names class member(s) and is not being used for; /// an address-of-member expression. Classify the type of access; /// according to whether it's possible that this reference names an; /// instance member. This is best-effort in dependent contexts; it is okay to; /// conservatively answer ""yes"", in which case some errors will simply; /// not be caught until template-instantiation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:285,Security,access,access,285,"// [class.mfct.non-static]p3:; // ...is used in the body of a non-static member function of class X,; // if name lookup (3.4.1) resolves the name in the id-expression to a; // non-static non-type member of some class C [...]; // ...if C is not X or a base class of X, the class member access expression; // is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:159,Availability,error,error,159,"// If we can prove that the current context is unrelated to all the; // declaring classes, it can't be an implicit member reference (in; // which case it's an error if any of those members are selected).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:51,Availability,avail,available,51,/// Diagnose a reference to a field with no object available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:34,Security,access,access,34,/// Check an ext-vector component access expression.; ///; /// VK should be set in advance to the value kind of the base; /// expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:16,Testability,log,logic,16,"// FIXME: Share logic with ExtVectorElementExpr::containsDuplicateElements,; // see FIXME there.; //; // FIXME: This logic can be greatly simplified by splitting it along; // halving/not halving and reworking the component checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:117,Testability,log,logic,117,"// FIXME: Share logic with ExtVectorElementExpr::containsDuplicateElements,; // see FIXME there.; //; // FIXME: This logic can be greatly simplified by splitting it along; // halving/not halving and reworking the component checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:138,Usability,simpl,simplified,138,"// FIXME: Share logic with ExtVectorElementExpr::containsDuplicateElements,; // see FIXME there.; //; // FIXME: This logic can be greatly simplified by splitting it along; // halving/not halving and reworking the component checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:14,Security,access,accessor,14,// The vector accessor can't exceed the number of elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:23,Security,access,accessor,23,// Ensure no component accessor exceeds the width of the vector type it; // operates on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:17,Security,access,accessor,17,"// The component accessor looks fine - now we need to compute the actual type.; // The vector type is implied by the component accessor. For example,; // vec4.b is a float, vec4.xy is a vec2, vec4.rgb is a vec3, etc.; // vec4.s0 is a float, vec4.s23 is a vec3, etc.; // vec4.hi, vec4.lo, vec4.e, and vec4.o all return vec2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:127,Security,access,accessor,127,"// The component accessor looks fine - now we need to compute the actual type.; // The vector type is implied by the component accessor. For example,; // vec4.b is a float, vec4.xy is a vec2, vec4.rgb is a vec3, etc.; // vec4.s0 is a float, vec4.s23 is a vec3, etc.; // vec4.hi, vec4.lo, vec4.e, and vec4.o all return vec2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:100,Modifiability,extend,extended,100,"// Now look up the TypeDefDecl from the vector type. Without this,; // diagostics look bad. We want extended vector types to appear built-in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:9,Integrability,protocol,protocols,9,// Check protocols on qualified interfaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:32,Integrability,interface,interfaces,32,// Check protocols on qualified interfaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:17,Integrability,protocol,protocol-qualifier,17,// Search in the protocol-qualifier list of current protocol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:52,Integrability,protocol,protocol,52,// Search in the protocol-qualifier list of current protocol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:320,Availability,error,error,320,"// Even in dependent contexts, try to diagnose base expressions with; // obviously wrong types, e.g.:; //; // T* t;; // t.f;; //; // In Obj-C++, however, the above expression is valid, since it could be; // accessing the 'f' property if T is an Obj-C interface. The extra check; // allows this, while still reporting an error if T is a struct pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:11,Integrability,depend,dependent,11,"// Even in dependent contexts, try to diagnose base expressions with; // obviously wrong types, e.g.:; //; // T* t;; // t.f;; //; // In Obj-C++, however, the above expression is valid, since it could be; // accessing the 'f' property if T is an Obj-C interface. The extra check; // allows this, while still reporting an error if T is a struct pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:251,Integrability,interface,interface,251,"// Even in dependent contexts, try to diagnose base expressions with; // obviously wrong types, e.g.:; //; // T* t;; // t.f;; //; // In Obj-C++, however, the above expression is valid, since it could be; // accessing the 'f' property if T is an Obj-C interface. The extra check; // allows this, while still reporting an error if T is a struct pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:207,Security,access,accessing,207,"// Even in dependent contexts, try to diagnose base expressions with; // obviously wrong types, e.g.:; //; // T* t;; // t.f;; //; // In Obj-C++, however, the above expression is valid, since it could be; // accessing the 'f' property if T is an Obj-C interface. The extra check; // allows this, while still reporting an error if T is a struct pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:22,Security,access,accessed,22,"// Get the type being accessed in BaseType. If this is an arrow, the BaseExpr; // must have pointer type, and the accessed type is the pointee.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:114,Security,access,accessed,114,"// Get the type being accessed in BaseType. If this is an arrow, the BaseExpr; // must have pointer type, and the accessed type is the pointee.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:33,Security,access,access,33,"// If this is an implicit member access, use a different set of; // diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:62,Integrability,depend,dependent,62,// We can't check this yet because the base type is still; // dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:94,Availability,error,error,94,"// If this is an implicit member reference and we find a; // non-instance member, it's not an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:75,Security,validat,validation,75,// Don't add bare keywords to the consumer since they will always fail; // validation by virtue of not being associated with any decls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:75,Modifiability,variab,variables,75,"// Don't accept candidates that cannot be member functions, constants,; // variables, or templates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:19,Security,access,accesses,19,// Implicit member accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:19,Security,access,accesses,19,// Explicit member accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:39,Security,access,access,39,"// In principle we could have a member access expression that; // accesses an anonymous struct/union that's a static member of; // the base object's class. However, under the current standard,; // static data members cannot be anonymous structs or unions.; // Supporting this is as easy as building a MemberExpr here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:66,Security,access,accesses,66,"// In principle we could have a member access expression that; // accesses an anonymous struct/union that's a static member of; // the base object's class. However, under the current standard,; // static data members cannot be anonymous structs or unions.; // Supporting this is as easy as building a MemberExpr here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:26,Security,access,access,26,// Build the first member access in the chain with full information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:29,Usability,simpl,simple,29,// Property names are always simple identifiers and therefore never; // require any interesting additional storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:99,Availability,error,error,99,"// FIXME: diagnose the presence of template arguments now.; // If the decl being referenced had an error, return an error for this; // sub-expr without emitting another error, in order to avoid cascading; // error cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:116,Availability,error,error,116,"// FIXME: diagnose the presence of template arguments now.; // If the decl being referenced had an error, return an error for this; // sub-expr without emitting another error, in order to avoid cascading; // error cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:169,Availability,error,error,169,"// FIXME: diagnose the presence of template arguments now.; // If the decl being referenced had an error, return an error for this; // sub-expr without emitting another error, in order to avoid cascading; // error cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:208,Availability,error,error,208,"// FIXME: diagnose the presence of template arguments now.; // If the decl being referenced had an error, return an error for this; // sub-expr without emitting another error, in order to avoid cascading; // error cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:188,Safety,avoid,avoid,188,"// FIXME: diagnose the presence of template arguments now.; // If the decl being referenced had an error, return an error for this; // sub-expr without emitting another error, in order to avoid cascading; // error cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:30,Security,access,access,30,// Handle the implicit-member-access case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:62,Security,access,access,62,"// If this is not an instance member, convert to a non-member access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:19,Modifiability,variab,variable,19,// We might have a variable template specialization (or maybe one day a; // member concept-id).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:7,Integrability,depend,dependent,7,"// Non-dependent member, but dependent template arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:29,Integrability,depend,dependent,29,"// Non-dependent member, but dependent template arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:29,Security,access,access,29,"/// Given that normal member access failed on the given expression,; /// and given that the expression's type involves builtin-id or; /// builtin-Class, decide whether substituting in the redefinition; /// types would be profitable. The redefinition type is whatever; /// this translation unit tried to typedef to id/Class; we store; /// it to the side and then re-use it in places like this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:4,Performance,Perform,Perform,4,/// Perform conversions on the LHS of a member access expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:47,Security,access,access,47,/// Perform conversions on the LHS of a member access expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:51,Integrability,depend,dependent,51,"/// Look up the given member of the given non-type-dependent; /// expression. This can return in one of two ways:; /// * If it returns a sentinel null-but-valid result, the caller will; /// assume that lookup was performed and the results written into; /// the provided structure. It will take over from there.; /// * Otherwise, the returned expression will be produced in place of; /// an ordinary member expression.; ///; /// The ObjCImpDecl bit is a gross hack that will need to be properly; /// fixed for ObjC++.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:213,Performance,perform,performed,213,"/// Look up the given member of the given non-type-dependent; /// expression. This can return in one of two ways:; /// * If it returns a sentinel null-but-valid result, the caller will; /// assume that lookup was performed and the results written into; /// the provided structure. It will take over from there.; /// * Otherwise, the returned expression will be produced in place of; /// an ordinary member expression.; ///; /// The ObjCImpDecl bit is a gross hack that will need to be properly; /// fixed for ObjC++.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:3,Performance,Perform,Perform,3,// Perform default conversions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:48,Security,access,accesses,48,"// For later type-checking purposes, turn arrow accesses into dot; // accesses. The only access type we support that doesn't follow; // the C equivalence ""a->b === (*a).b"" is ObjC property accesses,; // and those never use arrows, so this is unaffected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:70,Security,access,accesses,70,"// For later type-checking purposes, turn arrow accesses into dot; // accesses. The only access type we support that doesn't follow; // the C equivalence ""a->b === (*a).b"" is ObjC property accesses,; // and those never use arrows, so this is unaffected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:89,Security,access,access,89,"// For later type-checking purposes, turn arrow accesses into dot; // accesses. The only access type we support that doesn't follow; // the C equivalence ""a->b === (*a).b"" is ObjC property accesses,; // and those never use arrows, so this is unaffected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:189,Security,access,accesses,189,"// For later type-checking purposes, turn arrow accesses into dot; // accesses. The only access type we support that doesn't follow; // the C equivalence ""a->b === (*a).b"" is ObjC property accesses,; // and those never use arrows, so this is unaffected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:3,Availability,Recover,Recover,3,"// Recover from arrow accesses to records, e.g.:; // struct MyRecord foo;; // foo->bar; // This is actually well-formed in C++ if MyRecord has an; // overloaded operator->, but that should have been dealt with; // by now--or a diagnostic message already issued if a problem; // was encountered while looking for the overloaded operator->.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:238,Integrability,message,message,238,"// Recover from arrow accesses to records, e.g.:; // struct MyRecord foo;; // foo->bar; // This is actually well-formed in C++ if MyRecord has an; // overloaded operator->, but that should have been dealt with; // by now--or a diagnostic message already issued if a problem; // was encountered while looking for the overloaded operator->.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:3,Safety,Recover,Recover,3,"// Recover from arrow accesses to records, e.g.:; // struct MyRecord foo;; // foo->bar; // This is actually well-formed in C++ if MyRecord has an; // overloaded operator->, but that should have been dealt with; // by now--or a diagnostic message already issued if a problem; // was encountered while looking for the overloaded operator->.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:22,Security,access,accesses,22,"// Recover from arrow accesses to records, e.g.:; // struct MyRecord foo;; // foo->bar; // This is actually well-formed in C++ if MyRecord has an; // overloaded operator->, but that should have been dealt with; // by now--or a diagnostic message already issued if a problem; // was encountered while looking for the overloaded operator->.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:126,Availability,error,error,126,"// If the base type is an atomic type, this access is undefined behavior per; // C11 6.5.2.3p5. Instead of giving a typecheck error, we'll warn the user; // about the UB and recover by converting the atomic lvalue into a non-atomic; // lvalue. Because this is inherently unsafe as an atomic operation, the; // warning defaults to an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:174,Availability,recover,recover,174,"// If the base type is an atomic type, this access is undefined behavior per; // C11 6.5.2.3p5. Instead of giving a typecheck error, we'll warn the user; // about the UB and recover by converting the atomic lvalue into a non-atomic; // lvalue. Because this is inherently unsafe as an atomic operation, the; // warning defaults to an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:333,Availability,error,error,333,"// If the base type is an atomic type, this access is undefined behavior per; // C11 6.5.2.3p5. Instead of giving a typecheck error, we'll warn the user; // about the UB and recover by converting the atomic lvalue into a non-atomic; // lvalue. Because this is inherently unsafe as an atomic operation, the; // warning defaults to an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:174,Safety,recover,recover,174,"// If the base type is an atomic type, this access is undefined behavior per; // C11 6.5.2.3p5. Instead of giving a typecheck error, we'll warn the user; // about the UB and recover by converting the atomic lvalue into a non-atomic; // lvalue. Because this is inherently unsafe as an atomic operation, the; // warning defaults to an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:271,Safety,unsafe,unsafe,271,"// If the base type is an atomic type, this access is undefined behavior per; // C11 6.5.2.3p5. Instead of giving a typecheck error, we'll warn the user; // about the UB and recover by converting the atomic lvalue into a non-atomic; // lvalue. Because this is inherently unsafe as an atomic operation, the; // warning defaults to an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:44,Security,access,access,44,"// If the base type is an atomic type, this access is undefined behavior per; // C11 6.5.2.3p5. Instead of giving a typecheck error, we'll warn the user; // about the UB and recover by converting the atomic lvalue into a non-atomic; // lvalue. Because this is inherently unsafe as an atomic operation, the; // warning defaults to an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:16,Security,access,access,16,// Handle field access to simple records.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:26,Usability,simpl,simple,26,// Handle field access to simple records.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:185,Usability,clear,cleared--that,185,"// Returning valid-but-null is how we indicate to the caller that; // the lookup result was filled in. If typo correction was attempted and; // failed, the lookup result will have been cleared--that combined with the; // valid-but-null ExprResult will trigger the appropriate diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:15,Security,access,access,15,// Handle ivar access to Objective-C objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:144,Integrability,interface,interface,144,// There are three cases for the base type:; // - builtin id (qualified or unqualified); // - builtin Class (qualified or unqualified); // - an interface,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:39,Availability,error,error,39,"// If the decl being referenced had an error, return an error for this; // sub-expr without emitting another error, in order to avoid cascading; // error cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:56,Availability,error,error,56,"// If the decl being referenced had an error, return an error for this; // sub-expr without emitting another error, in order to avoid cascading; // error cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:109,Availability,error,error,109,"// If the decl being referenced had an error, return an error for this; // sub-expr without emitting another error, in order to avoid cascading; // error cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:148,Availability,error,error,148,"// If the decl being referenced had an error, return an error for this; // sub-expr without emitting another error, in order to avoid cascading; // error cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:128,Safety,avoid,avoid,128,"// If the decl being referenced had an error, return an error for this; // sub-expr without emitting another error, in order to avoid cascading; // error cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:181,Availability,avail,available,181,"// Case of a c-function declared inside an objc implementation.; // FIXME: For a c-style function nested inside an objc implementation; // class, there is no implementation context available, so we pass; // down the context as argument to this routine. Ideally, this context; // need be passed down in the AST node and somehow calculated from the; // AST for a function decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:207,Availability,down,down,207,"// Case of a c-function declared inside an objc implementation.; // FIXME: For a c-style function nested inside an objc implementation; // class, there is no implementation context available, so we pass; // down the context as argument to this routine. Ideally, this context; // need be passed down in the AST node and somehow calculated from the; // AST for a function decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:294,Availability,down,down,294,"// Case of a c-function declared inside an objc implementation.; // FIXME: For a c-style function nested inside an objc implementation; // class, there is no implementation context available, so we pass; // down the context as argument to this routine. Ideally, this context; // need be passed down in the AST node and somehow calculated from the; // AST for a function decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:244,Integrability,rout,routine,244,"// Case of a c-function declared inside an objc implementation.; // FIXME: For a c-style function nested inside an objc implementation; // class, there is no implementation context available, so we pass; // down the context as argument to this routine. Ideally, this context; // need be passed down in the AST node and somehow calculated from the; // AST for a function decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:24,Security,access,access,24,// Objective-C property access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:9,Integrability,protocol,protocols,9,// Check protocols on qualified interfaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:32,Integrability,interface,interfaces,32,// Check protocols on qualified interfaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:19,Security,access,access,19,// Normal property access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:23,Security,access,access,23,// We disallow element access for ext_vector_type bool. There is no way to; // materialize a reference to a vector element as a pointer (each element is; // one bit in the vector).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:17,Security,access,access,17,"// Handle 'field access' to vectors, such as 'V.xx'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:3,Availability,Failure,Failure,3,// Failure cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:3,Availability,Recover,Recover,3,"// Recover from dot accesses to pointers, e.g.:; // type *foo;; // foo.bar; // This is actually well-formed in two cases:; // - 'type' is an Objective C type; // - 'bar' is a pseudo-destructor name which happens to refer to; // the appropriate pointer type",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:3,Safety,Recover,Recover,3,"// Recover from dot accesses to pointers, e.g.:; // type *foo;; // foo.bar; // This is actually well-formed in two cases:; // - 'type' is an Objective C type; // - 'bar' is a pseudo-destructor name which happens to refer to; // the appropriate pointer type",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:20,Security,access,accesses,20,"// Recover from dot accesses to pointers, e.g.:; // type *foo;; // foo.bar; // This is actually well-formed in two cases:; // - 'type' is an Objective C type; // - 'bar' is a pseudo-destructor name which happens to refer to; // the appropriate pointer type",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:20,Security,access,access,20,// Recurse as an -> access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:10,Security,access,accesses,10,"// Member accesses have four cases:; // 1: non-array member via ""->"": dereferences; // 2: non-array member via ""."": nothing interesting happens; // 3: array member access via ""->"": nothing interesting happens; // (this returns an array lvalue and does not actually dereference memory); // 4: array member access via ""."": *adds* a layer of indirection",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:164,Security,access,access,164,"// Member accesses have four cases:; // 1: non-array member via ""->"": dereferences; // 2: non-array member via ""."": nothing interesting happens; // 3: array member access via ""->"": nothing interesting happens; // (this returns an array lvalue and does not actually dereference memory); // 4: array member access via ""."": *adds* a layer of indirection",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:305,Security,access,access,305,"// Member accesses have four cases:; // 1: non-array member via ""->"": dereferences; // 2: non-array member via ""."": nothing interesting happens; // 3: array member access via ""->"": nothing interesting happens; // (this returns an array lvalue and does not actually dereference memory); // 4: array member access via ""."": *adds* a layer of indirection",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:30,Security,access,access,30,"/// Builds an implicit member access expression. The current context; /// is known to be an instance method, and the given unqualified lookup; /// set is known to contain only instance members, at least one of which; /// is from an appropriate type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:38,Security,access,access,38,"// If this is known to be an instance access, go ahead and build an; // implicit 'this' expression now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:27,Security,access,access,27,// null signifies implicit access,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:34,Integrability,interface,interface,34,"// Initialize the constant string interface lazily. This assumes; // the NSString interface is seen in this translation unit. Note: We; // don't use NSConstantString, since the runtime team considers this; // interface private (even though it appears in the header files).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:82,Integrability,interface,interface,82,"// Initialize the constant string interface lazily. This assumes; // the NSString interface is seen in this translation unit. Note: We; // don't use NSConstantString, since the runtime team considers this; // interface private (even though it appears in the header files).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:209,Integrability,interface,interface,209,"// Initialize the constant string interface lazily. This assumes; // the NSString interface is seen in this translation unit. Note: We; // don't use NSConstantString, since the runtime team considers this; // interface private (even though it appears in the header files).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:76,Availability,error,error,76,// If there is no NSConstantString interface defined then treat this; // as error and recover from it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:86,Availability,recover,recover,86,// If there is no NSConstantString interface defined then treat this; // as error and recover from it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:35,Integrability,interface,interface,35,// If there is no NSConstantString interface defined then treat this; // as error and recover from it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:86,Safety,recover,recover,86,// If there is no NSConstantString interface defined then treat this; // as error and recover from it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:27,Integrability,interface,interface,27,"// If there is no NSString interface defined, implicitly declare; // a @class NSString; and use that instead. This is to make sure; // type of an NSString literal is represented correctly, instead of; // being an 'id' type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:13,Availability,error,error,13,"/// Emits an error if the given method does not exist, or if the return; /// type is not an Objective-C object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:35,Safety,avoid,avoid,35,// FIXME: Is there a better way to avoid quotes than using getName()?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:32,Availability,avail,availability,32,"/// Validates ObjCInterfaceDecl availability.; /// ObjCInterfaceDecl, used to create ObjC literals, should be defined; /// if clang not in a debugger mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:4,Security,Validat,Validates,4,"/// Validates ObjCInterfaceDecl availability.; /// ObjCInterfaceDecl, used to create ObjC literals, should be defined; /// if clang not in a debugger mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:67,Performance,cache,cached,67,"// Look up the NSNumber class, if we haven't done so already. It's cached; // in the Sema instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:12,Testability,stub,stub,12,// create a stub definition this NSNumber factory method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:29,Integrability,depend,dependent,29,"// If the expression is type-dependent, there's nothing for us to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:3,Performance,Perform,Perform,3,// Perform lvalue-to-rvalue conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:179,Performance,cache,cached,179,"// Support for structure types, that marked as objc_boxable; // struct __attribute__((objc_boxable)) s { ... };; // Look up the NSValue class, if we haven't done so already. It's cached; // in the Sema instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:16,Integrability,depend,dependent,16,// We can't get dependent types here; our callers should have; // filtered them out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:3,Performance,Perform,Perform,3,// Perform lvalue-to-rvalue conversion on the base.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:82,Performance,perform,performing,82,"// Check that each of the elements provided is valid in a collection literal,; // performing conversions as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:89,Performance,perform,performing,89,"// Check that each of the keys and values provided is valid in a collection; // literal, performing conversions as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:63,Deployability,release,release,63,"// In ARC, forbid the user from using @selector for; // retain/release/autorelease/dealloc/retainCount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:35,Availability,error,error,35,"// If we're not in an ObjC method, error out. Note that, unlike the; // C++ case, we don't require an instance method --- class methods; // still have a 'self', and we really do still need to capture it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:35,Integrability,message,message,35,"/// Determine the result type of a message send based on the receiver type,; /// method, and the kind of message send.; ///; /// This is the ""base"" result type, which will still need to be adjusted; /// to account for nullability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:105,Integrability,message,message,105,"/// Determine the result type of a message send based on the receiver type,; /// method, and the kind of message send.; ///; /// This is the ""base"" result type, which will still need to be adjusted; /// to account for nullability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:99,Integrability,message,message,99,"// If a method has a related return type:; // - if the method found is an instance method, but the message send; // was a class message send, T is the declared return type of the method; // found",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:128,Integrability,message,message,128,"// If a method has a related return type:; // - if the method found is an instance method, but the message send; // was a class message send, T is the declared return type of the method; // found",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:22,Integrability,message,message,22,"// If this is a class message, ignore the nullability of the receiver.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:28,Integrability,message,messages,28,"// In a class method, class messages to 'self' that return instancetype can; // be typed as the current class. We can safely do this in ARC because self; // can't be reassigned, and we do it unsafely outside of ARC because in; // practice people never reassign self in class methods and there's some; // virtue in not being aggressively pedantic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:118,Safety,safe,safely,118,"// In a class method, class messages to 'self' that return instancetype can; // be typed as the current class. We can safely do this in ARC because self; // can't be reassigned, and we do it unsafely outside of ARC because in; // practice people never reassign self in class methods and there's some; // virtue in not being aggressively pedantic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:191,Safety,unsafe,unsafely,191,"// In a class method, class messages to 'self' that return instancetype can; // be typed as the current class. We can safely do this in ARC because self; // can't be reassigned, and we do it unsafely outside of ARC because in; // practice people never reassign self in class methods and there's some; // virtue in not being aggressively pedantic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:90,Integrability,interface,interface,90,"// For these purposes, a method in an @implementation overrides a; // declaration in the @interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:47,Integrability,message,message,47,// Find the class to which we are sending this message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:43,Integrability,depend,dependent,43,// We can't do any type-checking on a type-dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:3,Deployability,Update,Update,3,// Update the parameter type in-place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:101,Modifiability,extend,extend,101,"// If we are type-erasing a block to a block-compatible; // Objective-C pointer type, we may need to extend the lifetime; // of the block object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:26,Integrability,interface,interface,26,"// Look it up in the main interface (and categories, etc.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:57,Integrability,protocol,protocol,57,/// LookupMethodInQualifiedType - Lookups up a method in protocol qualifier; /// list of a qualified objective pointer type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:93,Integrability,interface,interface,93,/// HandleExprPropertyRefExpr - Handle foo.bar where foo is a pointer to an; /// objective C interface. This is a property reference expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:9,Integrability,protocol,protocols,9,// Check protocols on qualified interfaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:32,Integrability,interface,interfaces,32,// Check protocols on qualified interfaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:120,Testability,log,logic,120,"// If that failed, look for an ""implicit"" property by seeing if the nullary; // selector is implemented.; // FIXME: The logic for looking up nullary and unary selectors should be; // shared with the code in ActOnInstanceMessage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:70,Security,access,accessor,70,// Special warning if member name used in a property-dot for a setter accessor; // does not use a property with same name; e.g. obj.X = ... for a property with; // name 'x'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:67,Security,access,access,67,"// This is a class property, we should not use the instance to; // access it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:10,Modifiability,refactor,refactor,10,// FIXME: refactor/share with ActOnMemberReference().; // Check if we can reference this property.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:168,Integrability,message,message,168,"// If the identifier is ""super"" and there is no trailing dot, we're; // messaging super. If the identifier is ""super"" and there is a; // trailing dot, it's an instance message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:60,Integrability,message,message,60,// Fall back: let the parser try to parse it as an instance message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:20,Performance,perform,perform,20,// Break out; we'll perform typo correction below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:90,Integrability,message,message,90,"// If the identifier is a class or not, and there is a trailing dot,; // it's an instance message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:64,Integrability,message,message,64,"// We found something. If it's a type, then we have a class; // message. Otherwise, it's an instance message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:101,Integrability,message,message,101,"// We found something. If it's a type, then we have a class; // message. Otherwise, it's an instance message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:19,Integrability,message,message,19,"// We have a class message, and T is the type we're; // messaging. Build source-location information for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:60,Integrability,message,message,60,// Fall back: let the parser try to parse it as an instance message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:63,Integrability,message,message,63,"// Since we are in an instance method, this is an instance; // message to the superclass instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:51,Integrability,message,message,51,"// Since we are in a class method, this is a class message to; // the superclass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:22,Performance,perform,performSelector,22,// Check if this is a performSelector method that uses a selector that returns; // a record or a vector type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:31,Integrability,message,message,31,"/// Build an Objective-C class message expression.; ///; /// This routine takes care of both normal class messages and; /// class messages to the superclass.; ///; /// \param ReceiverTypeInfo Type source information that describes the; /// receiver of this message. This may be NULL, in which case we are; /// sending to the superclass and \p SuperLoc must be a valid source; /// location.; /// \param ReceiverType The type of the object receiving the; /// message. When \p ReceiverTypeInfo is non-NULL, this is the same; /// type as that refers to. For a superclass send, this is the type of; /// the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this class message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:66,Integrability,rout,routine,66,"/// Build an Objective-C class message expression.; ///; /// This routine takes care of both normal class messages and; /// class messages to the superclass.; ///; /// \param ReceiverTypeInfo Type source information that describes the; /// receiver of this message. This may be NULL, in which case we are; /// sending to the superclass and \p SuperLoc must be a valid source; /// location.; /// \param ReceiverType The type of the object receiving the; /// message. When \p ReceiverTypeInfo is non-NULL, this is the same; /// type as that refers to. For a superclass send, this is the type of; /// the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this class message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:106,Integrability,message,messages,106,"/// Build an Objective-C class message expression.; ///; /// This routine takes care of both normal class messages and; /// class messages to the superclass.; ///; /// \param ReceiverTypeInfo Type source information that describes the; /// receiver of this message. This may be NULL, in which case we are; /// sending to the superclass and \p SuperLoc must be a valid source; /// location.; /// \param ReceiverType The type of the object receiving the; /// message. When \p ReceiverTypeInfo is non-NULL, this is the same; /// type as that refers to. For a superclass send, this is the type of; /// the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this class message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:130,Integrability,message,messages,130,"/// Build an Objective-C class message expression.; ///; /// This routine takes care of both normal class messages and; /// class messages to the superclass.; ///; /// \param ReceiverTypeInfo Type source information that describes the; /// receiver of this message. This may be NULL, in which case we are; /// sending to the superclass and \p SuperLoc must be a valid source; /// location.; /// \param ReceiverType The type of the object receiving the; /// message. When \p ReceiverTypeInfo is non-NULL, this is the same; /// type as that refers to. For a superclass send, this is the type of; /// the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this class message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:257,Integrability,message,message,257,"/// Build an Objective-C class message expression.; ///; /// This routine takes care of both normal class messages and; /// class messages to the superclass.; ///; /// \param ReceiverTypeInfo Type source information that describes the; /// receiver of this message. This may be NULL, in which case we are; /// sending to the superclass and \p SuperLoc must be a valid source; /// location.; /// \param ReceiverType The type of the object receiving the; /// message. When \p ReceiverTypeInfo is non-NULL, this is the same; /// type as that refers to. For a superclass send, this is the type of; /// the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this class message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:457,Integrability,message,message,457,"/// Build an Objective-C class message expression.; ///; /// This routine takes care of both normal class messages and; /// class messages to the superclass.; ///; /// \param ReceiverTypeInfo Type source information that describes the; /// receiver of this message. This may be NULL, in which case we are; /// sending to the superclass and \p SuperLoc must be a valid source; /// location.; /// \param ReceiverType The type of the object receiving the; /// message. When \p ReceiverTypeInfo is non-NULL, this is the same; /// type as that refers to. For a superclass send, this is the type of; /// the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this class message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:697,Integrability,message,message,697,"/// Build an Objective-C class message expression.; ///; /// This routine takes care of both normal class messages and; /// class messages to the superclass.; ///; /// \param ReceiverTypeInfo Type source information that describes the; /// receiver of this message. This may be NULL, in which case we are; /// sending to the superclass and \p SuperLoc must be a valid source; /// location.; /// \param ReceiverType The type of the object receiving the; /// message. When \p ReceiverTypeInfo is non-NULL, this is the same; /// type as that refers to. For a superclass send, this is the type of; /// the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this class message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:753,Integrability,message,message,753,"/// Build an Objective-C class message expression.; ///; /// This routine takes care of both normal class messages and; /// class messages to the superclass.; ///; /// \param ReceiverTypeInfo Type source information that describes the; /// receiver of this message. This may be NULL, in which case we are; /// sending to the superclass and \p SuperLoc must be a valid source; /// location.; /// \param ReceiverType The type of the object receiving the; /// message. When \p ReceiverTypeInfo is non-NULL, this is the same; /// type as that refers to. For a superclass send, this is the type of; /// the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this class message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:827,Integrability,message,message,827,"/// Build an Objective-C class message expression.; ///; /// This routine takes care of both normal class messages and; /// class messages to the superclass.; ///; /// \param ReceiverTypeInfo Type source information that describes the; /// receiver of this message. This may be NULL, in which case we are; /// sending to the superclass and \p SuperLoc must be a valid source; /// location.; /// \param ReceiverType The type of the object receiving the; /// message. When \p ReceiverTypeInfo is non-NULL, this is the same; /// type as that refers to. For a superclass send, this is the type of; /// the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this class message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:1047,Integrability,message,message,1047,"/// Build an Objective-C class message expression.; ///; /// This routine takes care of both normal class messages and; /// class messages to the superclass.; ///; /// \param ReceiverTypeInfo Type source information that describes the; /// receiver of this message. This may be NULL, in which case we are; /// sending to the superclass and \p SuperLoc must be a valid source; /// location.; /// \param ReceiverType The type of the object receiving the; /// message. When \p ReceiverTypeInfo is non-NULL, this is the same; /// type as that refers to. For a superclass send, this is the type of; /// the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this class message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:27,Integrability,depend,dependent,27,"// If the receiver type is dependent, we can't type-check anything; // at this point. Build a dependent expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:94,Integrability,depend,dependent,94,"// If the receiver type is dependent, we can't type-check anything; // at this point. Build a dependent expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:47,Integrability,message,message,47,// Find the class to which we are sending this message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:55,Integrability,message,messages,55,"// ActOnClassMessage - used for both unary and keyword messages.; // ArgExprs is optional - if it is present, the number of expressions; // is obtained from Sel.getNumArgs().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:34,Integrability,message,message,34,"/// Build an Objective-C instance message expression.; ///; /// This routine takes care of both normal instance messages and; /// instance messages to the superclass instance.; ///; /// \param Receiver The expression that computes the object that will; /// receive this message. This may be empty, in which case we are; /// sending to the superclass instance and \p SuperLoc must be a valid; /// source location.; ///; /// \param ReceiverType The (static) type of the object receiving the; /// message. When a \p Receiver expression is provided, this is the; /// same type as that expression. For a superclass instance send, this; /// is a pointer to the type of the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass instance message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this instance message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:69,Integrability,rout,routine,69,"/// Build an Objective-C instance message expression.; ///; /// This routine takes care of both normal instance messages and; /// instance messages to the superclass instance.; ///; /// \param Receiver The expression that computes the object that will; /// receive this message. This may be empty, in which case we are; /// sending to the superclass instance and \p SuperLoc must be a valid; /// source location.; ///; /// \param ReceiverType The (static) type of the object receiving the; /// message. When a \p Receiver expression is provided, this is the; /// same type as that expression. For a superclass instance send, this; /// is a pointer to the type of the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass instance message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this instance message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:112,Integrability,message,messages,112,"/// Build an Objective-C instance message expression.; ///; /// This routine takes care of both normal instance messages and; /// instance messages to the superclass instance.; ///; /// \param Receiver The expression that computes the object that will; /// receive this message. This may be empty, in which case we are; /// sending to the superclass instance and \p SuperLoc must be a valid; /// source location.; ///; /// \param ReceiverType The (static) type of the object receiving the; /// message. When a \p Receiver expression is provided, this is the; /// same type as that expression. For a superclass instance send, this; /// is a pointer to the type of the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass instance message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this instance message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:139,Integrability,message,messages,139,"/// Build an Objective-C instance message expression.; ///; /// This routine takes care of both normal instance messages and; /// instance messages to the superclass instance.; ///; /// \param Receiver The expression that computes the object that will; /// receive this message. This may be empty, in which case we are; /// sending to the superclass instance and \p SuperLoc must be a valid; /// source location.; ///; /// \param ReceiverType The (static) type of the object receiving the; /// message. When a \p Receiver expression is provided, this is the; /// same type as that expression. For a superclass instance send, this; /// is a pointer to the type of the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass instance message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this instance message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:270,Integrability,message,message,270,"/// Build an Objective-C instance message expression.; ///; /// This routine takes care of both normal instance messages and; /// instance messages to the superclass instance.; ///; /// \param Receiver The expression that computes the object that will; /// receive this message. This may be empty, in which case we are; /// sending to the superclass instance and \p SuperLoc must be a valid; /// source location.; ///; /// \param ReceiverType The (static) type of the object receiving the; /// message. When a \p Receiver expression is provided, this is the; /// same type as that expression. For a superclass instance send, this; /// is a pointer to the type of the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass instance message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this instance message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:494,Integrability,message,message,494,"/// Build an Objective-C instance message expression.; ///; /// This routine takes care of both normal instance messages and; /// instance messages to the superclass instance.; ///; /// \param Receiver The expression that computes the object that will; /// receive this message. This may be empty, in which case we are; /// sending to the superclass instance and \p SuperLoc must be a valid; /// source location.; ///; /// \param ReceiverType The (static) type of the object receiving the; /// message. When a \p Receiver expression is provided, this is the; /// same type as that expression. For a superclass instance send, this; /// is a pointer to the type of the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass instance message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this instance message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:771,Integrability,message,message,771,"/// Build an Objective-C instance message expression.; ///; /// This routine takes care of both normal instance messages and; /// instance messages to the superclass instance.; ///; /// \param Receiver The expression that computes the object that will; /// receive this message. This may be empty, in which case we are; /// sending to the superclass instance and \p SuperLoc must be a valid; /// source location.; ///; /// \param ReceiverType The (static) type of the object receiving the; /// message. When a \p Receiver expression is provided, this is the; /// same type as that expression. For a superclass instance send, this; /// is a pointer to the type of the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass instance message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this instance message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:827,Integrability,message,message,827,"/// Build an Objective-C instance message expression.; ///; /// This routine takes care of both normal instance messages and; /// instance messages to the superclass instance.; ///; /// \param Receiver The expression that computes the object that will; /// receive this message. This may be empty, in which case we are; /// sending to the superclass instance and \p SuperLoc must be a valid; /// source location.; ///; /// \param ReceiverType The (static) type of the object receiving the; /// message. When a \p Receiver expression is provided, this is the; /// same type as that expression. For a superclass instance send, this; /// is a pointer to the type of the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass instance message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this instance message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:904,Integrability,message,message,904,"/// Build an Objective-C instance message expression.; ///; /// This routine takes care of both normal instance messages and; /// instance messages to the superclass instance.; ///; /// \param Receiver The expression that computes the object that will; /// receive this message. This may be empty, in which case we are; /// sending to the superclass instance and \p SuperLoc must be a valid; /// source location.; ///; /// \param ReceiverType The (static) type of the object receiving the; /// message. When a \p Receiver expression is provided, this is the; /// same type as that expression. For a superclass instance send, this; /// is a pointer to the type of the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass instance message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this instance message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:1124,Integrability,message,message,1124,"/// Build an Objective-C instance message expression.; ///; /// This routine takes care of both normal instance messages and; /// instance messages to the superclass instance.; ///; /// \param Receiver The expression that computes the object that will; /// receive this message. This may be empty, in which case we are; /// sending to the superclass instance and \p SuperLoc must be a valid; /// source location.; ///; /// \param ReceiverType The (static) type of the object receiving the; /// message. When a \p Receiver expression is provided, this is the; /// same type as that expression. For a superclass instance send, this; /// is a pointer to the type of the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass instance message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this instance message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:37,Performance,perform,perform,37,"// If we have a receiver expression, perform appropriate promotions; // and determine receiver type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:27,Integrability,depend,dependent,27,"// If the receiver is type-dependent, we can't type-check anything; // at this point. Build a dependent expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:94,Integrability,depend,dependent,94,"// If the receiver is type-dependent, we can't type-check anything; // at this point. Build a dependent expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:10,Integrability,message,messages,10,// Handle messages to id and __kindof types (where we use the; // global method pool).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:10,Integrability,message,messages,10,"// Handle messages to Class.; // We allow sending a message to a qualified Class (""Class<foo>""), which; // is ok as long as one of the protocols implements the selector (if not,; // warn).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:52,Integrability,message,message,52,"// Handle messages to Class.; // We allow sending a message to a qualified Class (""Class<foo>""), which; // is ok as long as one of the protocols implements the selector (if not,; // warn).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:135,Integrability,protocol,protocols,135,"// Handle messages to Class.; // We allow sending a message to a qualified Class (""Class<foo>""), which; // is ok as long as one of the protocols implements the selector (if not,; // warn).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:10,Integrability,protocol,protocols,10,// Search protocols for class methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:45,Integrability,message,message,45,// warn if instance method found for a Class message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:57,Integrability,interface,interface,57,"// As a guess, try looking for the method in the current interface.; // This very well may not produce the ""right"" method.; // First check the public methods in the class interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:171,Integrability,interface,interface,171,"// As a guess, try looking for the method in the current interface.; // This very well may not produce the ""right"" method.; // First check the public methods in the class interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:22,Integrability,message,message,22,"// We allow sending a message to a qualified ID (""id<foo>""), which is ok as; // long as one of the protocols implements the selector (if not, warn).; // And as long as message is not deprecated/unavailable (warn if it is).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:99,Integrability,protocol,protocols,99,"// We allow sending a message to a qualified ID (""id<foo>""), which is ok as; // long as one of the protocols implements the selector (if not, warn).; // And as long as message is not deprecated/unavailable (warn if it is).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:168,Integrability,message,message,168,"// We allow sending a message to a qualified ID (""id<foo>""), which is ok as; // long as one of the protocols implements the selector (if not, warn).; // And as long as message is not deprecated/unavailable (warn if it is).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:10,Integrability,protocol,protocols,10,// Search protocols for instance methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:22,Integrability,message,message,22,// We allow sending a message to a pointer to an interface (an object).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:49,Integrability,interface,interface,49,// We allow sending a message to a pointer to an interface (an object).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:55,Availability,error,error,55,"// Try to complete the type. Under ARC, this is a hard error from which; // we don't try to recover.; // FIXME: In the non-ARC case, this will still be a hard error if the; // definition is found in a module that's not visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:92,Availability,recover,recover,92,"// Try to complete the type. Under ARC, this is a hard error from which; // we don't try to recover.; // FIXME: In the non-ARC case, this will still be a hard error if the; // definition is found in a module that's not visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:159,Availability,error,error,159,"// Try to complete the type. Under ARC, this is a hard error from which; // we don't try to recover.; // FIXME: In the non-ARC case, this will still be a hard error if the; // definition is found in a module that's not visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:92,Safety,recover,recover,92,"// Try to complete the type. Under ARC, this is a hard error from which; // we don't try to recover.; // FIXME: In the non-ARC case, this will still be a hard error if the; // definition is found in a module that's not visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:10,Integrability,protocol,protocol,10,// Search protocol qualifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:103,Safety,safe,safe,103,"// Under ARC, self can't be assigned, and doing a direct call to `self`; // when it's a Class is hence safe. For other cases, we can't trust `self`; // is what we think it is, so we reject it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:13,Integrability,message,message,13,// Check the message arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:63,Deployability,release,release,63,"// In ARC, forbid the user from sending messages to; // retain/release/autorelease/dealloc/retainCount explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:40,Integrability,message,messages,40,"// In ARC, forbid the user from sending messages to; // retain/release/autorelease/dealloc/retainCount explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:9,Availability,error,error,9,"// Issue error, unless ns_returns_not_retained.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:3,Availability,error,error,3,// error (may leak).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:10,Integrability,message,message,10,"// 'self' message receivers in class methods should be treated as message; // sends to the class object in order for the semantic checks to be; // performed correctly. Messages to 'super' already count as class messages,; // so they don't need to be handled here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:66,Integrability,message,message,66,"// 'self' message receivers in class methods should be treated as message; // sends to the class object in order for the semantic checks to be; // performed correctly. Messages to 'super' already count as class messages,; // so they don't need to be handled here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:168,Integrability,Message,Messages,168,"// 'self' message receivers in class methods should be treated as message; // sends to the class object in order for the semantic checks to be; // performed correctly. Messages to 'super' already count as class messages,; // so they don't need to be handled here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:211,Integrability,message,messages,211,"// 'self' message receivers in class methods should be treated as message; // sends to the class object in order for the semantic checks to be; // performed correctly. Messages to 'super' already count as class messages,; // so they don't need to be handled here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:147,Performance,perform,performed,147,"// 'self' message receivers in class methods should be treated as message; // sends to the class object in order for the semantic checks to be; // performed correctly. Messages to 'super' already count as class messages,; // so they don't need to be handled here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:21,Integrability,message,message,21,"// In ARC, check for message sends which are likely to introduce; // retain cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:58,Integrability,message,messages,58,"// ActOnInstanceMessage - used for both unary and keyword messages.; // ArgExprs is optional - if it is present, the number of expressions; // is obtained from Sel.getNumArgs().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:43,Availability,error,error,43,// A ParenListExpr can show up while doing error recovery with invalid code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:49,Availability,recover,recovery,49,// A ParenListExpr can show up while doing error recovery with invalid code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:49,Safety,recover,recovery,49,// A ParenListExpr can show up while doing error recovery with invalid code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:11,Safety,safe,safely,11,/// Can be safely retained or not retained.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:39,Safety,safe,safely,39,/// Objective-C string literals can be safely casted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:13,Integrability,message,message,13,"// Check for message sends to functions returning CF types. We; // just obey the Cocoa conventions with these, even though the; // return type is CF.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:35,Integrability,bridg,bridge-related,35,// Defer emitting a diagnostic for bridge-related casts; that will be; // handled by CheckObjCBridgeRelatedConversions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:44,Integrability,bridg,bridge,44,// Check whether this could be fixed with a bridge cast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:3,Integrability,Bridg,Bridge,3,// Bridge from an ARC type to a CF type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:3,Integrability,Bridg,Bridge,3,// Bridge from a CF type to an ARC type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:58,Integrability,bridg,bridge,58,// ok to cast to 'id'.; // casting to id<p-list> is ok if bridge type adopts all of; // p-list protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:95,Integrability,protocol,protocols,95,// ok to cast to 'id'.; // casting to id<p-list> is ok if bridge type adopts all of; // p-list protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:63,Integrability,bridg,bridge,63,// warn in presence of __bridge casting to or from a toll free bridge cast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:55,Security,access,accessor,55,// fixit: ObjectExpr.propertyname when it is aproperty accessor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:34,Availability,error,error,34,// Check for viability and report error if casting an rvalue to a; // life-time qualifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:138,Integrability,bridg,bridge,138,"// Issue a diagnostic about a missing @-sign when implicit casting a cstring; // to 'NSString *', instead of falling through to report a ""bridge cast""; // diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:17,Integrability,bridg,bridge,17,"// Do not issue ""bridge cast"" diagnostic when implicit casting; // a retainable object to a CF type parameter belonging to an audited; // CF API function. Let caller issue a normal type mismatched diagnostic; // instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:126,Security,audit,audited,126,"// Do not issue ""bridge cast"" diagnostic when implicit casting; // a retainable object to a CF type parameter belonging to an audited; // CF API function. Let caller issue a normal type mismatched diagnostic; // instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:8,Availability,down,down,8,// Walk down the expression until we hit an implicit cast of kind; // ARCReclaimReturnedObject or an Expr that is neither a Paren nor a Cast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:23,Integrability,depend,dependent,23,// Okay: we'll build a dependent expression type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:4,Deployability,Update,Update,4,"/// Update the type of a string literal, including any surrounding parentheses,; /// to match the type of the object which it is initializing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:150,Safety,Avoid,Avoid,150,"// We have an array of character type with known size. However,; // the size may be smaller or larger than the string we are initializing.; // FIXME: Avoid truncation for 64-bit length strings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:99,Integrability,rout,routines,99,"/// Semantic checking for initializer lists.; ///; /// The InitListChecker class contains a set of routines that each; /// handle the initialization of a certain kind of entity, e.g.,; /// arrays, vectors, struct/union types, scalars, etc. The; /// InitListChecker itself performs a recursive walk of the subobject; /// structure of the type to be initialized, while stepping through; /// the initializer list one element at a time. The IList and Index; /// parameters to each of the Check* routines contain the active; /// (syntactic) initializer list and the index into that initializer; /// list that represents the current initializer. Each routine is; /// responsible for moving that Index forward as it consumes elements.; ///; /// Each Check* routine also has a StructuredList/StructuredIndex; /// arguments, which contains the current ""structured"" (semantic); /// initializer list and the index into that initializer list where we; /// are copying initializers as we map them over to the semantic; /// list. Once we have completed our recursive walk of the subobject; /// structure, we will have constructed a full semantic initializer; /// list.; ///; /// C99 designators cause changes in the initializer list traversal,; /// because they make the initialization ""jump"" into a specific; /// subobject and then continue the initialization from that; /// point. CheckDesignatedInitializer() recursively steps into the; /// designated subobject and manages backing out the recursion to; /// initialize the subobjects after the one designated.; ///; /// If an initializer list contains any designators, we build a placeholder; /// structured list even in 'verify only' mode, so that we can track which; /// elements need 'empty' initializtion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:491,Integrability,rout,routines,491,"/// Semantic checking for initializer lists.; ///; /// The InitListChecker class contains a set of routines that each; /// handle the initialization of a certain kind of entity, e.g.,; /// arrays, vectors, struct/union types, scalars, etc. The; /// InitListChecker itself performs a recursive walk of the subobject; /// structure of the type to be initialized, while stepping through; /// the initializer list one element at a time. The IList and Index; /// parameters to each of the Check* routines contain the active; /// (syntactic) initializer list and the index into that initializer; /// list that represents the current initializer. Each routine is; /// responsible for moving that Index forward as it consumes elements.; ///; /// Each Check* routine also has a StructuredList/StructuredIndex; /// arguments, which contains the current ""structured"" (semantic); /// initializer list and the index into that initializer list where we; /// are copying initializers as we map them over to the semantic; /// list. Once we have completed our recursive walk of the subobject; /// structure, we will have constructed a full semantic initializer; /// list.; ///; /// C99 designators cause changes in the initializer list traversal,; /// because they make the initialization ""jump"" into a specific; /// subobject and then continue the initialization from that; /// point. CheckDesignatedInitializer() recursively steps into the; /// designated subobject and manages backing out the recursion to; /// initialize the subobjects after the one designated.; ///; /// If an initializer list contains any designators, we build a placeholder; /// structured list even in 'verify only' mode, so that we can track which; /// elements need 'empty' initializtion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:645,Integrability,rout,routine,645,"/// Semantic checking for initializer lists.; ///; /// The InitListChecker class contains a set of routines that each; /// handle the initialization of a certain kind of entity, e.g.,; /// arrays, vectors, struct/union types, scalars, etc. The; /// InitListChecker itself performs a recursive walk of the subobject; /// structure of the type to be initialized, while stepping through; /// the initializer list one element at a time. The IList and Index; /// parameters to each of the Check* routines contain the active; /// (syntactic) initializer list and the index into that initializer; /// list that represents the current initializer. Each routine is; /// responsible for moving that Index forward as it consumes elements.; ///; /// Each Check* routine also has a StructuredList/StructuredIndex; /// arguments, which contains the current ""structured"" (semantic); /// initializer list and the index into that initializer list where we; /// are copying initializers as we map them over to the semantic; /// list. Once we have completed our recursive walk of the subobject; /// structure, we will have constructed a full semantic initializer; /// list.; ///; /// C99 designators cause changes in the initializer list traversal,; /// because they make the initialization ""jump"" into a specific; /// subobject and then continue the initialization from that; /// point. CheckDesignatedInitializer() recursively steps into the; /// designated subobject and manages backing out the recursion to; /// initialize the subobjects after the one designated.; ///; /// If an initializer list contains any designators, we build a placeholder; /// structured list even in 'verify only' mode, so that we can track which; /// elements need 'empty' initializtion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:750,Integrability,rout,routine,750,"/// Semantic checking for initializer lists.; ///; /// The InitListChecker class contains a set of routines that each; /// handle the initialization of a certain kind of entity, e.g.,; /// arrays, vectors, struct/union types, scalars, etc. The; /// InitListChecker itself performs a recursive walk of the subobject; /// structure of the type to be initialized, while stepping through; /// the initializer list one element at a time. The IList and Index; /// parameters to each of the Check* routines contain the active; /// (syntactic) initializer list and the index into that initializer; /// list that represents the current initializer. Each routine is; /// responsible for moving that Index forward as it consumes elements.; ///; /// Each Check* routine also has a StructuredList/StructuredIndex; /// arguments, which contains the current ""structured"" (semantic); /// initializer list and the index into that initializer list where we; /// are copying initializers as we map them over to the semantic; /// list. Once we have completed our recursive walk of the subobject; /// structure, we will have constructed a full semantic initializer; /// list.; ///; /// C99 designators cause changes in the initializer list traversal,; /// because they make the initialization ""jump"" into a specific; /// subobject and then continue the initialization from that; /// point. CheckDesignatedInitializer() recursively steps into the; /// designated subobject and manages backing out the recursion to; /// initialize the subobjects after the one designated.; ///; /// If an initializer list contains any designators, we build a placeholder; /// structured list even in 'verify only' mode, so that we can track which; /// elements need 'empty' initializtion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:272,Performance,perform,performs,272,"/// Semantic checking for initializer lists.; ///; /// The InitListChecker class contains a set of routines that each; /// handle the initialization of a certain kind of entity, e.g.,; /// arrays, vectors, struct/union types, scalars, etc. The; /// InitListChecker itself performs a recursive walk of the subobject; /// structure of the type to be initialized, while stepping through; /// the initializer list one element at a time. The IList and Index; /// parameters to each of the Check* routines contain the active; /// (syntactic) initializer list and the index into that initializer; /// list that represents the current initializer. Each routine is; /// responsible for moving that Index forward as it consumes elements.; ///; /// Each Check* routine also has a StructuredList/StructuredIndex; /// arguments, which contains the current ""structured"" (semantic); /// initializer list and the index into that initializer list where we; /// are copying initializers as we map them over to the semantic; /// list. Once we have completed our recursive walk of the subobject; /// structure, we will have constructed a full semantic initializer; /// list.; ///; /// C99 designators cause changes in the initializer list traversal,; /// because they make the initialization ""jump"" into a specific; /// subobject and then continue the initialization from that; /// point. CheckDesignatedInitializer() recursively steps into the; /// designated subobject and manages backing out the recursion to; /// initialize the subobjects after the one designated.; ///; /// If an initializer list contains any designators, we build a placeholder; /// structured list even in 'verify only' mode, so that we can track which; /// elements need 'empty' initializtion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:679,Safety,avoid,avoid,679,"// Explanation on the ""FillWithNoInit"" mode:; //; // Assume we have the following definitions (Case#1):; // struct P { char x[6][6]; } xp = { .x[1] = ""bar"" };; // struct PP { struct P lp; } l = { .lp = xp, .lp.x[1][2] = 'f' };; //; // l.lp.x[1][0..1] should not be filled with implicit initializers because the; // ""base"" initializer ""xp"" will provide values for them; l.lp.x[1] will be ""baf"".; //; // But if we have (Case#2):; // struct PP l = { .lp = xp, .lp.x[1] = { [2] = 'f' } };; //; // l.lp.x[1][0..1] are implicitly initialized and do not use values from the; // ""base"" initializer; l.lp.x[1] will be ""\0\0f\0\0\0"".; //; // To distinguish Case#1 from Case#2, and also to avoid leaving many ""holes""; // in the InitListExpr, the ""holes"" in Case#1 are filled not with empty; // initializers but with special ""NoInitExpr"" place holders, which tells the; // CodeGen not to generate any initializers for these parts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:320,Performance,perform,performs,320,"// C++1y / DR1070:; // shall be initialized [...] from an empty initializer list.; //; // We apply the resolution of this DR to C++11 but not C++98, since C++98; // does not have useful semantics for initialization from an init list.; // We treat this as copy-initialization, because aggregate initialization; // always performs copy-initialization on its elements.; //; // Only do this if we're initializing a class type, to avoid filling in; // the initializer list where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:426,Safety,avoid,avoid,426,"// C++1y / DR1070:; // shall be initialized [...] from an empty initializer list.; //; // We apply the resolution of this DR to C++11 but not C++98, since C++98; // does not have useful semantics for initialization from an init list.; // We treat this as copy-initialization, because aggregate initialization; // always performs copy-initialization on its elements.; //; // Only do this if we're initializing a class type, to avoid filling in; // the initializer list where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:96,Availability,recover,recover,96,"// libstdc++4.6 marks the vector default constructor as explicit in; // _GLIBCXX_DEBUG mode, so recover using the C++03 logic in that case.; // stlport does so too. Look for std::__debug for libstdc++, and for; // std:: for stlport. This is effectively a compiler-side implementation of; // LWG2193.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:96,Safety,recover,recover,96,"// libstdc++4.6 marks the vector default constructor as explicit in; // _GLIBCXX_DEBUG mode, so recover using the C++03 logic in that case.; // stlport does so too. Look for std::__debug for libstdc++, and for; // std:: for stlport. This is effectively a compiler-side implementation of; // LWG2193.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:120,Testability,log,logic,120,"// libstdc++4.6 marks the vector default constructor as explicit in; // _GLIBCXX_DEBUG mode, so recover using the C++03 logic in that case.; // stlport does so too. Look for std::__debug for libstdc++, and for; // std:: for stlport. This is effectively a compiler-side implementation of; // LWG2193.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:60,Modifiability,extend,extend,60,"// Empty initialization requires a constructor call, so; // extend the initializer list to include the constructor; // call and make a note that we'll need to take another pass; // through the initializer list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:98,Performance,perform,perform,98,"/// Recursively replaces NULL values within the given initializer list; /// with expressions that perform value-initialization of the; /// appropriate type, and finish off the InitListExpr formation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:241,Deployability,update,updated,241,"// If this is a nested initializer list, we might have changed its contents; // (and therefore some of its properties, such as instantiation-dependence); // while filling it in. Inform the outer initializer list so that its state; // can be updated to match.; // FIXME: We should fully build the inner initializers before constructing; // the outer InitListExpr instead of mutating AST nodes after they have; // been used as subexpressions of other nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:141,Integrability,depend,dependence,141,"// If this is a nested initializer list, we might have changed its contents; // (and therefore some of its properties, such as instantiation-dependence); // while filling it in. Inform the outer initializer list so that its state; // can be updated to match.; // FIXME: We should fully build the inner initializers before constructing; // the outer InitListExpr instead of mutating AST nodes after they have; // been used as subexpressions of other nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:28,Performance,perform,performing,28,// A transparent ILE is not performing aggregate initialization and should; // not be filled in.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:40,Performance,perform,performing,40,"// In VerifyOnly mode, there's no point performing empty initialization; // more than once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:60,Modifiability,extend,extend,60,"// Empty initialization requires a constructor call, so; // extend the initializer list to include the constructor; // call and make a note that we'll need to take another pass; // through the initializer list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:147,Deployability,Update,Update,147,"/// Check whether the range of the initializer \p ParentIList from element; /// \p Index onwards can be used to initialize an object of type \p T. Update; /// \p Index to indicate how many elements of the list were consumed.; ///; /// This also fills in \p StructuredList, from element \p StructuredIndex; /// onwards, with the fully-braced, desugared form of the initialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Deployability,Update,Update,3,// Update the structured sub-object initializer so that it's ending; // range corresponds with the end of the last initializer it used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:79,Integrability,depend,dependent,79,"// Don't warn during template instantiation. If the initialization was; // non-dependent, we warned during the initial parse; otherwise, the; // type might not be scalar in some uses of the template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:59,Availability,error,error,59,"// Don't complain for incomplete types, since we'll get an error elsewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:115,Integrability,depend,dependent,115,// C++ [over.match.class.deduct]p1.5:; // brace elision is not considered for any aggregate element that has a; // dependent non-array type or an array type with a value-dependent bound,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:170,Integrability,depend,dependent,170,// C++ [over.match.class.deduct]p1.5:; // brace elision is not considered for any aggregate element that has a; // dependent non-array type or an array type with a value-dependent bound,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:115,Integrability,depend,dependent,115,// C++ [over.match.class.deduct]p1.5:; // brace elision is not considered for any aggregate element that has a; // dependent non-array type or an array type with a value-dependent; // bound,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:170,Integrability,depend,dependent,170,// C++ [over.match.class.deduct]p1.5:; // brace elision is not considered for any aggregate element that has a; // dependent non-array type or an array type with a value-dependent; // bound,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:190,Performance,perform,performed,190,"// C++14 [dcl.init.aggr]p13:; // If the assignment-expression can initialize a member, the member is; // initialized. Otherwise [...] brace elision is assumed; //; // Brace elision is never performed if the element is not an; // assignment-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:55,Modifiability,flexible,flexible,55,"// arrayType can be incomplete if we're initializing a flexible; // array member. There's nothing we can do with the completed; // type here, though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:45,Performance,Perform,PerformCopyInitialization,45,"// We cannot initialize this element, so let PerformCopyInitialization; // produce the appropriate diagnostic. We already checked that this; // initialization will fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:26,Deployability,update,update,26,"// The type was promoted, update initializer list.; // FIXME: Why are we updating the syntactic init list?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:136,Availability,down,down,136,"// FIXME: It would be wonderful if we could point at the actual member. In; // general, it would be useful to pass location information down the stack,; // so that we know the location (or decl) of the ""current object"" being; // initialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:120,Availability,failure,failure,120,"// If the initializing element is a vector, try to copy-initialize; // instead of breaking it apart (which is doomed to failure anyway).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:26,Deployability,update,update,26,"// The type was promoted, update initializer list.; // FIXME: Why are we updating the syntactic init list?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:390,Modifiability,portab,portable,390,"// The ability to use vector initializer lists is a GNU vector extension; // and is unrelated to the NEON intrinsics in arm_neon.h. On little; // endian machines it works fine, however on big endian machines it; // exhibits surprising behaviour:; //; // uint32x2_t x = {42, 64};; // return vget_lane_u32(x, 0); // Will return 64.; //; // Because of this, explicitly call out that it is non-portable.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:48,Security,access,accessible,48,"/// Check if the type of a class element has an accessible destructor, and marks; /// it referenced. Returns true if we shouldn't form a reference to the; /// destructor.; ///; /// Aggregate initialization requires a class element's destructor be; /// accessible per 11.6.1 [dcl.init.aggr]:; ///; /// The destructor for each element of class type is potentially invoked; /// (15.4 [class.dtor]) from the context where the aggregate initialization; /// occurs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:252,Security,access,accessible,252,"/// Check if the type of a class element has an accessible destructor, and marks; /// it referenced. Returns true if we shouldn't form a reference to the; /// destructor.; ///; /// Aggregate initialization requires a class element's destructor be; /// accessible per 11.6.1 [dcl.init.aggr]:; ///; /// The destructor for each element of class type is potentially invoked; /// (15.4 [class.dtor]) from the context where the aggregate initialization; /// occurs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:263,Availability,error,error,263,"// C23 6.7.10p4: An entity of variable length array type shall not be; // initialized except by an empty initializer.; //; // The C extension warnings are issued from ParseBraceInitializer() and; // do not need to be issued here. However, we continue to issue an error; // in the case there are initializers or we are compiling C++. We allow; // use of VLAs in C++, but it's not clear we want to allow {} to zero; // init a VLA in C++ in all cases (such as with non-trivial constructors).; // FIXME: should we allow this construct in C++ when it makes sense to do; // so?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:30,Modifiability,variab,variable,30,"// C23 6.7.10p4: An entity of variable length array type shall not be; // initialized except by an empty initializer.; //; // The C extension warnings are issued from ParseBraceInitializer() and; // do not need to be issued here. However, we continue to issue an error; // in the case there are initializers or we are compiling C++. We allow; // use of VLAs in C++, but it's not clear we want to allow {} to zero; // init a VLA in C++ in all cases (such as with non-trivial constructors).; // FIXME: should we allow this construct in C++ when it makes sense to do; // so?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:379,Usability,clear,clear,379,"// C23 6.7.10p4: An entity of variable length array type shall not be; // initialized except by an empty initializer.; //; // The C extension warnings are issued from ParseBraceInitializer() and; // do not need to be issued here. However, we continue to issue an error; // in the case there are initializers or we are compiling C++. We allow; // use of VLAs in C++, but it's not clear we want to allow {} to zero; // init a VLA in C++ in all cases (such as with non-trivial constructors).; // FIXME: should we allow this construct in C++ when it makes sense to do; // so?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:64,Deployability,update,updated,64,// Handle this designated initializer. elementIndex will be; // updated to be the next array element we'll initialize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:179,Performance,perform,performing,179,"// If there are any members of the array that get value-initialized, check; // that is possible. That happens if we know the bound and don't have; // enough elements, or if we're performing an array new with an unknown; // bound.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:14,Modifiability,flexible,flexible,14,// Handle GNU flexible array initializers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:9,Modifiability,flexible,flexible,9,// Empty flexible array init always allowed as an extension,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:12,Modifiability,flexible,flexible,12,// Disallow flexible array init on non-top-level object,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:12,Modifiability,flexible,flexible,12,// Disallow flexible array init on anything which is not a variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:59,Modifiability,variab,variable,59,// Disallow flexible array init on anything which is not a variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:12,Modifiability,flexible,flexible,12,// Disallow flexible array init on local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:41,Modifiability,variab,variables,41,// Disallow flexible array init on local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:66,Safety,avoid,avoid,66,"// If the record is invalid, some of it's members are invalid. To avoid; // confusion, we forgo checking the initializer for the entire record.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:143,Availability,error,error,143,"// If structDecl is a forward declaration, this loop won't do; // anything except look at designated initializers; That's okay,; // because an error should get printed out elsewhere. It might be; // worthwhile to skip over the rest of the initializer, though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:53,Deployability,update,updated,53,// Handle this designated initializer. Field will be updated to; // the next field that we'll be initializing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:20,Modifiability,flexible,flexible,20,"// If we've hit the flexible array member at the end, we're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:53,Security,access,accessible,53,// Check that the types of the remaining fields have accessible destructors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:111,Availability,down,down,111,"// Expand the current designator into the set of replacement; // designators, so we have a full subobject path down to where the; // member of the anonymous struct/union is actually stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:1723,Availability,error,error,1723,"// end anonymous namespace; /// Check the well-formedness of a C99 designated initializer.; ///; /// Determines whether the designated initializer @p DIE, which; /// resides at the given @p Index within the initializer list @p; /// IList, is well-formed for a current object of type @p DeclType; /// (C99 6.7.8). The actual subobject that this designator refers to; /// within the current subobject is returned in either; /// @p NextField or @p NextElementIndex (whichever is appropriate).; ///; /// @param IList The initializer list in which this designated; /// initializer occurs.; ///; /// @param DIE The designated initializer expression.; ///; /// @param DesigIdx The index of the current designator.; ///; /// @param CurrentObjectType The type of the ""current object"" (C99 6.7.8p17),; /// into which the designation in @p DIE should refer.; ///; /// @param NextField If non-NULL and the first designator in @p DIE is; /// a field, this will be set to the field declaration corresponding; /// to the field named by the designator. On input, this is expected to be; /// the next field that would be initialized in the absence of designation,; /// if the complete object being initialized is a struct.; ///; /// @param NextElementIndex If non-NULL and the first designator in @p; /// DIE is an array designator or GNU array-range designator, this; /// will be set to the last index initialized by this designator.; ///; /// @param Index Index into @p IList where the designated initializer; /// @p DIE occurs.; ///; /// @param StructuredList The initializer list expression that; /// describes all of the subobject initializers in the order they'll; /// actually be initialized.; ///; /// @returns true if there was an error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:153,Performance,perform,performing,153,"// C++20 designated initialization can result in direct-list-initialization; // of the designated subobject. This is the only way that we can end up; // performing direct initialization as part of aggregate initialization, so; // it needs special handling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:81,Deployability,update,update,81,"// We don't need to track the structured representation of a; // designated init update of an already-fully-initialized object in; // verify-only mode. The only reason we would need the structure is; // to determine where the uninitialized ""holes"" are, and in this; // case, we know there aren't any and we can't introduce any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:26,Modifiability,variab,variable,26,// We found a placeholder variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:319,Performance,perform,performing,319,"// C++20 [dcl.init.list]p3:; // The ordered identifiers in the designators of the designated-; // initializer-list shall form a subsequence of the ordered identifiers; // in the direct non-static data members of T.; //; // Note that this is not a condition on forming the aggregate; // initialization, only on actually performing initialization,; // so it is not checked in VerifyOnly mode.; //; // FIXME: This is the only reordering diagnostic we produce, and it only; // catches cases where we have a top-level field designator that jumps; // backwards. This is the only such case that is reachable in an; // otherwise-valid C++20 program, so is the only case that's required for; // conformance, but for consistency, we should diagnose all the other; // cases where a designator takes us backwards too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Deployability,Update,Update,3,// Update the designator with the field declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:27,Modifiability,flexible,flexible,27,// This designator names a flexible array member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:43,Modifiability,flexible,flexible,43,// We can't designate an object within the flexible array; // member (because GCC doesn't allow it).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:13,Modifiability,flexible,flexible,13,// Check GNU flexible array initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:309,Availability,error,error,309,"// Codegen can't handle evaluating array range designators that have side; // effects, because we replicate the AST value for each initialized element.; // As such, set the sawArrayRangeDesignator() bit if we initialize multiple; // elements with something that has a side effect, so codegen can emit an; // ""error unsupported"" error instead of miscompiling the app.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:328,Availability,error,error,328,"// Codegen can't handle evaluating array range designators that have side; // effects, because we replicate the AST value for each initialized element.; // As such, set the sawArrayRangeDesignator() bit if we initialize multiple; // elements with something that has a side effect, so codegen can emit an; // ""error unsupported"" error instead of miscompiling the app.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:27,Deployability,update,update,27,// We're just verifying an update to a string literal init. We don't need; // to split the string up into individual characters to do that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:14,Performance,perform,perform,14,"// Repeatedly perform subobject initializations in the range; // [DesignatedStartIndex, DesignatedEndIndex].; // Move to the next designator",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:554,Deployability,update,update,554,"// We are creating an initializer list that initializes the; // subobjects of the current object, but there was already an; // initialization that completely initialized the current; // subobject:; //; // struct X { int a, b; };; // struct X xs[] = { [0] = { 1, 2 }, [0].b = 3 };; //; // Here, xs[0].a == 1 and xs[0].b == 3, since the second,; // designated initializer overwrites the [0].b initializer; // from the prior initialization.; //; // When the existing initializer is an expression rather than an; // initializer list, we cannot decompose and update it in this way.; // For example:; //; // struct X xs[] = { [0] = (struct X) { 1, 2 }, [0].b = 3 };; //; // This case is handled by CheckDesignatedInitializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:7,Energy Efficiency,allocate,allocate,7,// Pre-allocate storage for the structured initializer list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:37,Energy Efficiency,allocate,allocate,37,// Simple heuristic so that we don't allocate a very large; // initializer with many empty entries at the end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Usability,Simpl,Simple,3,// Simple heuristic so that we don't allocate a very large; // initializer with many empty entries at the end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:4,Deployability,Update,Update,4,/// Update the initializer at index @p StructuredIndex within the; /// structured initializer list to the value @p expr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:37,Deployability,update,update,37,// No structured initializer list to update,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:29,Performance,perform,perform,29,/// Determine whether we can perform aggregate initialization for the purposes; /// of overload resolution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:259,Availability,failure,failure,259,"/// Check that the given Index expression is a valid array designator; /// value. This is essentially just a wrapper around; /// VerifyIntegerConstantExpression that also checks for negative values; /// and produces a reasonable diagnostic if there is a; /// failure. Returns the index expression, possibly with an implicit cast; /// added, on success. If everything went okay, Value will receive the; /// value of the constant expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:109,Integrability,wrap,wrapper,109,"/// Check that the given Index expression is a valid array designator; /// value. This is essentially just a wrapper around; /// VerifyIntegerConstantExpression that also checks for negative values; /// and produces a reasonable diagnostic if there is a; /// failure. Returns the index expression, possibly with an implicit cast; /// added, on success. If everything went okay, Value will receive the; /// value of the constant expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Performance,Perform,Perform,3,// Perform overload resolution and return the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:129,Performance,perform,performs,129,"/// Attempt initialization by constructor (C++ [dcl.init]), which; /// enumerates the constructors of the initialized entity and performs overload; /// resolution to select the best.; /// \param DestType The destination class type.; /// \param DestArrayType The destination type, which is either DestType or; /// a (possibly multidimensional) array of DestType.; /// \param IsListInit Is this list-initialization?; /// \param IsInitListCopy Is this non-list-initialization resulting from a; /// list-initialization from {x} where x is the same; /// type as the entity?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:489,Safety,avoid,avoid,489,"// C++17 [dcl.init]p17:; // - If the initializer expression is a prvalue and the cv-unqualified; // version of the source type is the same class as the class of the; // destination, the initializer expression is used to initialize the; // destination object.; // Per DR (no number yet), this does not apply when initializing a base; // class or delegating to another constructor from a mem-initializer.; // ObjC++: Lambda captured by the block in the lambda to block conversion; // should avoid copy elision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:179,Performance,perform,performed,179,"// C++11 [over.match.list]p1, per DR1467:; // When objects of non-aggregate type T are list-initialized, such that; // 8.5.4 [dcl.init.list] specifies that overload resolution is performed; // according to the rules in this section, overload resolution selects; // the constructor in two phases:; //; // - Initially, the candidate functions are the initializer-list; // constructors of the class T and the argument list consists of the; // initializer list as a single argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:115,Performance,perform,performed,115,"// C++11 [over.match.list]p1:; // - If no viable initializer-list constructor is found, overload resolution; // is performed again, where the candidate functions are all the; // constructors of the class T and the argument list consists of the; // elements of the initializer list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:108,Performance,perform,performed,108,"// [class.copy.elision]p3:; // In some copy-initialization contexts, a two-stage overload resolution; // is performed.; // If the first overload resolution selects a deleted function, we also; // need the initialization sequence to decide whether to perform the second; // overload resolution.; // For deleted functions in other contexts, there is no need to get the; // initialization sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:250,Performance,perform,perform,250,"// [class.copy.elision]p3:; // In some copy-initialization contexts, a two-stage overload resolution; // is performed.; // If the first overload resolution selects a deleted function, we also; // need the initialization sequence to decide whether to perform the second; // overload resolution.; // For deleted functions in other contexts, there is no need to get the; // initialization sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Deployability,Update,Update,3,// Update the initializer if we've resolved an overloaded function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Performance,Perform,Perform,3,// Perform address space compatibility check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:60,Performance,perform,perform,60,// Ignore address space of reference type at this point and perform address; // space conversion after the reference binding step.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:167,Performance,perform,performed,167,"// C++20 [dcl.init.list]p3:; // - If the braced-init-list contains a designated-initializer-list, T shall; // be an aggregate class. [...] Aggregate initialization is performed.; //; // We allow arrays here too in order to support array designators.; //; // FIXME: This check should precede the handling of reference initialization.; // We follow other compilers in allowing things like 'Aggr &&a = {.x = 1};'; // as a tentative DR resolution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:530,Performance,perform,performed,530,"// C++11 [dcl.init.list]p3, per DR1467:; // - If T is a class type and the initializer list has a single element of; // type cv U, where U is T or a class derived from T, the object is; // initialized from that element (by copy-initialization for; // copy-list-initialization, or by direct-initialization for; // direct-list-initialization).; // - Otherwise, if T is a character array and the initializer list has a; // single element that is an appropriately-typed string literal; // (8.5.2 [dcl.init.string]), initialization is performed as described; // in that section.; // - Otherwise, if T is an aggregate, [...] (continue below).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:84,Performance,perform,performed,84,"// C++11 [dcl.init.list]p3:; // - If T is an aggregate, aggregate initialization is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:460,Performance,perform,performing,460,"// - Otherwise, if the initializer list has a single element of type E; // [...references are handled above...], the object or reference is; // initialized from that element (by copy-initialization for; // copy-list-initialization, or by direct-initialization for; // direct-list-initialization); if a narrowing conversion is required; // to convert the element to T, the program is ill-formed.; //; // Per core-24034, this is direct-initialization if we were performing; // direct-list-initialization and copy-initialization otherwise.; // We can't use InitListChecker for this, because it always performs; // copy-initialization. This only matters if we might use an 'explicit'; // conversion operator, or for the special case conversion of nullptr_t to; // bool, so we only need to handle those cases.; //; // FIXME: Why not do this in all cases?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:598,Performance,perform,performs,598,"// - Otherwise, if the initializer list has a single element of type E; // [...references are handled above...], the object or reference is; // initialized from that element (by copy-initialization for; // copy-list-initialization, or by direct-initialization for; // direct-list-initialization); if a narrowing conversion is required; // to convert the element to T, the program is ill-formed.; //; // Per core-24034, this is direct-initialization if we were performing; // direct-list-initialization and copy-initialization otherwise.; // We can't use InitListChecker for this, because it always performs; // copy-initialization. This only matters if we might use an 'explicit'; // conversion operator, or for the special case conversion of nullptr_t to; // bool, so we only need to handle those cases.; //; // FIXME: Why not do this in all cases?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Performance,Perform,Perform,3,"// Perform overload resolution. If it fails, return the failed result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:35,Performance,perform,perform,35,// Determine whether we'll need to perform derived-to-base adjustments or; // other conversions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Performance,Perform,Perform,3,// Perform a (possibly multi-level) qualification conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:92,Performance,perform,perform,92,"// The corresponding bullet in C++03 [dcl.init.ref]p5 gives the; // compiler the freedom to perform a copy here or bind to the; // object, while C++0x requires that we bind directly to the; // object. Hence, we always bind to the object without making an; // extra copy. However, in C++03 requires that we check for the; // presence of a suitable copy constructor:; //; // The constructor that would be used to make the copy shall; // be callable whether or not the copy is actually done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:292,Performance,perform,perform,292,"// - Otherwise, a temporary of type ""cv1 T1"" is created and initialized; // from the initializer expression using the rules for a non-reference; // copy-initialization (8.5). The reference is then bound to the; // temporary. [...]; // Ignore address space of reference type at this point and perform address; // space conversion after the reference binding step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:193,Security,access,accessible,193,"// C++98:; // -- if T is a class type (clause 9) with a user-declared constructor; // (12.1), then the default constructor for T is called (and the; // initialization is ill-formed if T has no accessible default; // constructor);; // C++11:; // -- if T is a class type (clause 9) with either no default constructor; // (12.1 [class.ctor]) or a default constructor that is user-provided; // or deleted, then the object is default-initialized;; //; // Note that the C++11 rule is the same as the C++98 rule if there are no; // defaulted or deleted constructors, so we just use it unconditionally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:73,Integrability,wrap,wrap,73,"// FIXME: Instead of creating a CXXConstructExpr of array type here,; // wrap a class-typed CXXConstructExpr in an ArrayInitLoopExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:160,Security,access,accessible,160,"// - if T is a (possibly cv-qualified) class type (Clause 9), the default; // constructor for T is called (and the initialization is ill-formed if; // T has no accessible default constructor);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:37,Performance,perform,performed,37,"// - otherwise, no initialization is performed.; // If a program calls for the default initialization of an object of; // a const-qualified type T, T shall be a class type with a user-provided; // default constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:28,Modifiability,variab,variable,28,"// Braced-initialization of variable array types is not allowed, even if; // the size is greater than or equal to the number of args, so we don't; // allow them to be initialized via parenthesized aggregate initialization; // either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:17,Safety,avoid,avoid,17,// Exit early to avoid confusion when processing members.; // We do the same for braced list initialization in; // `CheckStructUnionTypes`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:35,Modifiability,flexible,flexible,35,"// Incomplete array types indicate flexible array members. Do not allow; // paren list initializations of structs with these members, as GCC; // doesn't either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:125,Performance,perform,performs,125,"/// Attempt a user-defined conversion between two types (C++ [dcl.init]),; /// which enumerates all conversion functions and performs overload resolution; /// to select the best.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:195,Usability,simpl,simply,195,"// The type we're converting from is a class type, enumerate its conversion; // functions.; // We can only enumerate the conversion functions for a complete type; if; // the type isn't complete, simply skip this step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Performance,Perform,Perform,3,"// Perform overload resolution. If it fails, return the failed result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:108,Performance,perform,performed,108,"// [class.copy.elision]p3:; // In some copy-initialization contexts, a two-stage overload resolution; // is performed.; // If the first overload resolution selects a deleted function, we also; // need the initialization sequence to decide whether to perform the second; // overload resolution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:250,Performance,perform,perform,250,"// [class.copy.elision]p3:; // In some copy-initialization contexts, a two-stage overload resolution; // is performed.; // If the first overload resolution selects a deleted function, we also; // need the initialization sequence to decide whether to perform the second; // overload resolution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:343,Performance,perform,performs,343,"// C++14 and before:; // - if the function is a constructor, the call initializes a temporary; // of the cv-unqualified version of the destination type. The [...]; // temporary [...] is then used to direct-initialize, according to the; // rules above, the object that is the destination of the; // copy-initialization.; // Note that this just performs a simple object copy from the temporary.; //; // C++17:; // - if the function is a constructor, the call is a prvalue of the; // cv-unqualified version of the destination type whose return object; // is initialized by the constructor. The call is used to; // direct-initialize, according to the rules above, the object that; // is the destination of the copy-initialization.; // Therefore we need to do nothing further.; //; // FIXME: Mark this copy as extraneous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:354,Usability,simpl,simple,354,"// C++14 and before:; // - if the function is a constructor, the call initializes a temporary; // of the cv-unqualified version of the destination type. The [...]; // temporary [...] is then used to direct-initialize, according to the; // rules above, the object that is the destination of the; // copy-initialization.; // Note that this just performs a simple object copy from the temporary.; //; // C++17:; // - if the function is a constructor, the call is a prvalue of the; // cv-unqualified version of the destination type whose return object; // is initialized by the constructor. The call is used to; // direct-initialize, according to the rules above, the object that; // is the destination of the copy-initialization.; // Therefore we need to do nothing further.; //; // FIXME: Mark this copy as extraneous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:68,Security,hash,hashtable,68,"/// An egregious hack for compatibility with libstdc++-4.2: in <tr1/hashtable>,; /// a function with a pointer return type contains a 'return false;' statement.; /// In C++11, 'false' is not a null pointer, so this breaks the build of any; /// code using that header.; ///; /// Work around this by treating 'return false;' as zero-initializing the result; /// if it's used in a pointer-returning function in a system header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:64,Modifiability,variab,variable,64,"// If we have a declaration reference, it had better be a local variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:72,Performance,load,load,72,"// set isWeakAccess to true, to mean that there will be an implicit; // load which requires a cleanup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:58,Performance,load,load,58,"// If isWeakAccess to true, there will be an implicit; // load which requires a cleanup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:29,Performance,perform,perform,29,/// Determine whether we can perform an elementwise array copy for this kind; /// of entity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:119,Integrability,depend,dependent,119,// Eliminate non-overload placeholder types in the arguments. We; // need to do this before checking whether types are dependent; // because lowering a pseudo-object expression might well give us; // something of dependent type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:213,Integrability,depend,dependent,213,// Eliminate non-overload placeholder types in the arguments. We; // need to do this before checking whether types are dependent; // because lowering a pseudo-object expression might well give us; // something of dependent type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:33,Modifiability,variab,variable,33,"// C++0x [dcl.init.ref]p1:; // A variable declared to be a T& or T&&, that is, ""reference to type T""; // (8.3.2), shall be initialized by an object, or function, of type T or; // by an object that can be converted into a T.; // (Therefore, multiple arguments are not permitted.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:111,Performance,perform,perform,111,"// Some kinds of initialization permit an array to be initialized from; // another array of the same type, and perform elementwise initialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:159,Integrability,wrap,wrapping,159,"// Do not attempt paren list initialization if overload resolution; // resolves to a deleted function .; //; // We may reach this condition if we have a union wrapping a class with; // a non-trivial copy or move constructor and we call one of those two; // constructors. The union is an aggregate, but the matched constructor; // is implicitly deleted, so we need to prevent aggregate initialization; // (otherwise, it'll attempt aggregate initialization by initializing; // the first element with a reference to the union).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:85,Performance,Perform,Perform,85,//===----------------------------------------------------------------------===//; // Perform initialization; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:732,Availability,error,error,732,"/// Make a (potentially elidable) temporary copy of the object; /// provided by the given initializer by calling the appropriate copy; /// constructor.; ///; /// \param S The Sema object used for type-checking.; ///; /// \param T The type of the temporary object, which must either be; /// the type of the initializer expression or a superclass thereof.; ///; /// \param Entity The entity being initialized.; ///; /// \param CurInit The initializer expression.; ///; /// \param IsExtraneousCopy Whether this is an ""extraneous"" copy that; /// is permitted in C++03 (but not C++0x) when binding a reference to; /// an rvalue.; ///; /// \returns An expression that copies the initializer expression into; /// a temporary object, or an error expression if a copy could not be; /// created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Performance,Perform,Perform,3,"// Perform overload resolution using the class's constructors. Per; // C++11 [dcl.init]p16, second bullet for class types, this initialization; // is direct-initialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:234,Availability,down,down,234,"// If this is a totally extraneous copy for C++03 reference; // binding purposes, just return the original initialization; // expression. We don't generate an (elided) copy operation here; // because doing so would require us to pass down a flag to avoid; // infinite recursion, where each step adds another extraneous,; // elidable copy.; // Instantiate the default arguments of any extra parameters in; // the selected copy constructor, as if we were going to create a; // proper call to the copy constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:249,Safety,avoid,avoid,249,"// If this is a totally extraneous copy for C++03 reference; // binding purposes, just return the original initialization; // expression. We don't generate an (elided) copy operation here; // because doing so would require us to pass down a flag to avoid; // infinite recursion, where each step adds another extraneous,; // elidable copy.; // Instantiate the default arguments of any extra parameters in; // the selected copy constructor, as if we were going to create a; // proper call to the copy constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:107,Integrability,rout,routine,107,"// Build the default argument expression; we don't actually care; // if this succeeds or not, because this routine will complain; // if there was a problem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:48,Performance,perform,perform,48,"// Determine the arguments required to actually perform the; // constructor call (we might have derived-to-base conversions, or; // the copy constructor may have default arguments).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:12,Performance,perform,perform,12,// Actually perform the constructor call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Performance,Perform,Perform,3,// Perform overload resolution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:48,Performance,perform,perform,48,// Determine the arguments required to actually perform the constructor; // call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:14,Security,access,access,14,// Only check access if all of that succeeded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:56,Modifiability,extend,extended,56,/// The lifetime of a temporary bound to this entity is extended to the; /// lifeitme of the entity itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:104,Energy Efficiency,allocate,allocated,104,"/// The lifetime of a temporary bound to this entity probably ends too soon,; /// because the entity is allocated in a new-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:43,Modifiability,extend,extend,43,"/// This is a mem-initializer: if it would extend a temporary (other than via; /// a default member initializer), the program is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:113,Modifiability,extend,extending,113,"/// Determine the declaration which an initialized entity ultimately refers to,; /// for the purpose of lifetime-extending a temporary bound to a reference in; /// the initialization of \p Entity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:51,Modifiability,variab,variable,51,"// Per [dcl.decomp]p3, the binding is treated as a variable of reference; // type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:104,Modifiability,extend,extended,104,// -- The lifetime of a temporary bound to the returned value in a; // function return statement is not extended; the temporary is; // destroyed at the end of the full-expression in the return statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:29,Modifiability,extend,extend,29,// FIXME: Should we lifetime-extend through the result of a statement; // expression?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:134,Deployability,patch,patch,134,"// We don't yet know the storage duration of the surrounding temporary.; // Assume it's got full-expression duration for now, it will patch up our; // storage duration if that's not correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:22,Modifiability,extend,extended,22,/// Lifetime would be extended by a reference binding to a temporary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:22,Modifiability,extend,extended,22,/// Lifetime would be extended by a std::initializer_list object binding to; /// its backing array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:25,Modifiability,variab,variable,25,/// A temporary or local variable. This will be one of:; /// * A MaterializeTemporaryExpr.; /// * A DeclRefExpr whose declaration is a local.; /// * An AddrLabelExpr.; /// * A BlockExpr for a block with captures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:22,Modifiability,variab,variable,22,// Don't declare this variable in the second operand of the for-statement;; // GCC miscompiles that by ending its lifetime before evaluating the; // third operand. See gcc.gnu.org/PR86769.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:50,Modifiability,extend,extend,50,// Walk past any constructs which we can lifetime-extend across.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:19,Availability,redundant,redundant,19,"// If this is just redundant braces around an initializer, step over it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:19,Safety,redund,redundant,19,"// If this is just redundant braces around an initializer, step over it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:82,Performance,perform,performing,82,"// Per current approach for DR1376, look through casts to reference type; // when performing lifetime extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:101,Performance,perform,performing,101,"// Per the current approach for DR1299, look through array element access; // on array glvalues when performing lifetime extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:67,Security,access,access,67,"// Per the current approach for DR1299, look through array element access; // on array glvalues when performing lifetime extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:21,Modifiability,extend,extend,21,// We can't lifetime extend through this but we might still find some; // retained temporaries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:82,Modifiability,inherit,inherits,82,// Step into CXXDefaultInitExprs so we can diagnose cases where a; // constructor inherits one as an implicit mem-initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:82,Modifiability,inherit,inherits,82,// Step into CXXDefaultInitExprs so we can diagnose cases where a; // constructor inherits one as an implicit mem-initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:47,Modifiability,extend,extended,47,// Dig out the expression which constructs the extended temporary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:87,Modifiability,extend,extends,87,// C++17 [dcl.init.list]p6:; // initializing an initializer_list object from the array extends the; // lifetime of the array exactly like binding a reference to a temporary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:70,Performance,perform,performing,70,// We already visited the elements of this initializer list while; // performing the initialization. Don't visit them again unless we've; // changed the lifetime of the initialized entity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:18,Modifiability,extend,extend,18,"// If we lifetime-extend a braced initializer which is initializing an; // aggregate, and that aggregate contains reference members which are; // bound to temporaries, those temporaries are also lifetime-extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:204,Modifiability,extend,extended,204,"// If we lifetime-extend a braced initializer which is initializing an; // aggregate, and that aggregate contains reference members which are; // bound to temporaries, those temporaries are also lifetime-extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:165,Modifiability,extend,extend,165,"// This might be either aggregate-initialization of a member or; // initialization of a std::initializer_list object. Regardless,; // we should recursively lifetime-extend that initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:98,Availability,redundant,redundant,98,"// If this is &rvalue, then it's ill-formed and we have already diagnosed; // it. Don't produce a redundant warning about the lifetime of the; // temporary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:98,Safety,redund,redundant,98,"// If this is &rvalue, then it's ill-formed and we have already diagnosed; // it. Don't produce a redundant warning about the lifetime of the; // temporary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:13,Modifiability,extend,extend,13,/// Lifetime-extend along this path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:244,Deployability,update,update,244,"/// We should lifetime-extend, but we don't because (due to technical; /// limitations) we can't. This happens for default member initializers,; /// which we don't clone for every use, so we don't have a unique; /// MaterializeTemporaryExpr to update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:23,Modifiability,extend,extend,23,"/// We should lifetime-extend, but we don't because (due to technical; /// limitations) we can't. This happens for default member initializers,; /// which we don't clone for every use, so we don't have a unique; /// MaterializeTemporaryExpr to update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:20,Modifiability,extend,extend,20,/// Do not lifetime extend along this path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:100,Modifiability,extend,extend,100,/// Determine whether this is an indirect path to a temporary that we are; /// supposed to lifetime-extend along.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:106,Safety,avoid,avoid,106,// We do not want to follow the references when returning a pointer originating; // from a local owner to avoid the following false positive:; // int &p = *localUniquePtr;; // someContainer.add(std::move(localUniquePtr));; // return p;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:192,Modifiability,variab,variable,192,// Skipping a chain of initializing gsl::Pointer annotated objects.; // We are looking only for the final source to find out if it was; // a local or temporary owner or the address of a local variable/param.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:201,Modifiability,variab,variable,201,"// The initialized entity has lifetime beyond the full-expression,; // and the local entity does too, so don't warn.; //; // FIXME: We should consider warning if a static / thread storage; // duration variable retains an automatic storage duration local.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Deployability,Update,Update,3,// Update the storage duration of the materialized temporary.; // FIXME: Rebuild the expression instead of mutating it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:39,Modifiability,extend,extended,39,// Also visit the temporaries lifetime-extended by this initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:30,Modifiability,extend,extend,30,"// We're supposed to lifetime-extend the temporary along this path (per; // the resolution of DR1815), but we don't support that yet.; //; // FIXME: Properly handle this situation. Perhaps the easiest approach; // would be to clone the initializer expression on each use that would; // lifetime extend its temporaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:295,Modifiability,extend,extend,295,"// We're supposed to lifetime-extend the temporary along this path (per; // the resolution of DR1815), but we don't support that yet.; //; // FIXME: Properly handle this situation. Perhaps the easiest approach; // would be to clone the initializer expression on each use that would; // lifetime extend its temporaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:52,Modifiability,variab,variable,52,"// If the path goes through the initialization of a variable or field,; // it can't possibly reach a temporary created in this full-expression.; // We will have already diagnosed any problems with the initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:122,Modifiability,extend,extend,122,"// Under C++ DR1696, if a mem-initializer (or a default member; // initializer used by the absence of one) would lifetime-extend a; // temporary, the program is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:57,Availability,error,error,57,// Paths via a default initializer can only occur during error recovery; // (there's no other way that a default initializer can refer to a; // local). Don't produce a bogus warning on those cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:63,Availability,recover,recovery,63,// Paths via a default initializer can only occur during error recovery; // (there's no other way that a default initializer can refer to a; // local). Don't produce a bogus warning on those cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:63,Safety,recover,recovery,63,// Paths via a default initializer can only occur during error recovery; // (there's no other way that a default initializer can refer to a; // local). Don't produce a bogus warning on those cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:35,Modifiability,variab,variable,35,// We can't determine if the local variable outlives the statement; // expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:90,Availability,error,errors,90,"// We didn't lifetime-extend, so don't go any further; we don't need more; // warnings or errors on inner temporaries within this one's initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:22,Modifiability,extend,extend,22,"// We didn't lifetime-extend, so don't go any further; we don't need more; // warnings or errors on inner temporaries within this one's initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:11,Modifiability,variab,variables,11,// __block variables are not moved implicitly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:11,Testability,test,testing,11,"// Special testing for the argument location. Since the fix-it needs the; // location right before the argument, the argument location can be in a; // macro only if it is at the beginning of the macro.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:113,Security,access,access,113,"// Order an ExprWithCleanups for lifetime marks.; //; // TODO: It'll be good to have a single place to check the access of the; // destructor and generate ExprWithCleanups for various uses. Currently these; // are done in both CreateMaterializeTemporaryExpr and MaybeBindToTemporary,; // but there may be a chance to merge them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:90,Availability,error,error,90,"// The initialization would have succeeded with this fixit. Since the fixit; // is on the error, we need to build a valid AST in this case, so this isn't; // handled in the Failed() branch above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:46,Modifiability,variab,variables,46,// Use a more useful diagnostic for constexpr variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:31,Integrability,depend,dependent,31,"// If the declaration is a non-dependent, incomplete array type; // that has an initializer, then its type will be completed once; // the initializer is instantiated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:306,Integrability,depend,dependently-sized,306,"// FIXME: We don't currently have the ability to accurately; // compute the length of an initializer list without; // performing full type-checking of the initializer list; // (since we have to determine where braces are implicitly; // introduced and such). So, we fall back to making the array; // type a dependently-sized array type with no specified; // bound.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:118,Performance,perform,performing,118,"// FIXME: We don't currently have the ability to accurately; // compute the length of an initializer list without; // performing full type-checking of the initializer list; // (since we have to determine where braces are implicitly; // introduced and such). So, we fall back to making the array; // type a dependently-sized array type with no specified; // bound.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:34,Modifiability,variab,variables,34,// OpenCL v2.0 s6.13.11.1. atomic variables can be initialized in global scope,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:188,Performance,perform,perform,188,// Promote from an unevaluated context to an unevaluated list context in; // C++11 list-initialization; we need to instantiate entities usable in; // constant expressions here in order to perform narrowing checks =(,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:136,Usability,usab,usable,136,// Promote from an unevaluated context to an unevaluated list context in; // C++11 list-initialization; we need to instantiate entities usable in; // constant expressions here in order to perform narrowing checks =(,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:72,Performance,perform,performing,72,"// Walk through the computed steps for the initialization sequence,; // performing the specified conversions along the way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:57,Deployability,update,update,57,// Overload resolution determined which function invoke; update the; // initializer to reflect that choice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:83,Performance,Perform,Perform,83,// We have a derived-to-base cast that produces either an rvalue or an; // lvalue. Perform that cast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:69,Availability,avail,availability,69,"// We don't check for e.g. function pointers here, since address; // availability checks should only occur when the function first decays; // into a pointer or reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:12,Modifiability,extend,extending,12,// If we're extending this temporary to automatic storage duration -- we; // need to register its cleanup during the full-expression's cleanups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:48,Performance,perform,perform,48,// Determine the arguments required to actually perform the constructor; // call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Performance,Perform,Perform,3,// Perform a qualification conversion; these can never go wrong.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:39,Availability,avail,available,39,"// Hack: We must update *ResultType if available in order to set the; // bounds of arrays, e.g. in 'int ar[] = {1, 2, 3};'.; // Worst case: 'const int (&arref)[] = {1, 2, 3};'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:17,Deployability,update,update,17,"// Hack: We must update *ResultType if available in order to set the; // bounds of arrays, e.g. in 'int ar[] = {1, 2, 3};'.; // Worst case: 'const int (&arref)[] = {1, 2, 3};'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:56,Deployability,update,update,56,"// If the destination type is an incomplete array type, update the; // type accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Integrability,Wrap,Wrap,3,// Wrap it in a construction of a std::initializer_list<T>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:106,Modifiability,variab,variable,106,"// Sampler initialization have 5 cases:; // 1. function argument passing; // 1a. argument is a file-scope variable; // 1b. argument is a function-scope variable; // 1c. argument is one of caller function's parameters; // 2. variable initialization; // 2a. initializing a file-scope variable; // 2b. initializing a function-scope variable; //; // For file-scope variables, since they cannot be initialized by function; // call of __translate_sampler_initializer in LLVM IR, their references; // need to be replaced by a cast from their literal initializers to; // sampler type. Since sampler variables can only be used in function; // calls as arguments, we only need to replace them when handling the; // argument passing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:152,Modifiability,variab,variable,152,"// Sampler initialization have 5 cases:; // 1. function argument passing; // 1a. argument is a file-scope variable; // 1b. argument is a function-scope variable; // 1c. argument is one of caller function's parameters; // 2. variable initialization; // 2a. initializing a file-scope variable; // 2b. initializing a function-scope variable; //; // For file-scope variables, since they cannot be initialized by function; // call of __translate_sampler_initializer in LLVM IR, their references; // need to be replaced by a cast from their literal initializers to; // sampler type. Since sampler variables can only be used in function; // calls as arguments, we only need to replace them when handling the; // argument passing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:224,Modifiability,variab,variable,224,"// Sampler initialization have 5 cases:; // 1. function argument passing; // 1a. argument is a file-scope variable; // 1b. argument is a function-scope variable; // 1c. argument is one of caller function's parameters; // 2. variable initialization; // 2a. initializing a file-scope variable; // 2b. initializing a function-scope variable; //; // For file-scope variables, since they cannot be initialized by function; // call of __translate_sampler_initializer in LLVM IR, their references; // need to be replaced by a cast from their literal initializers to; // sampler type. Since sampler variables can only be used in function; // calls as arguments, we only need to replace them when handling the; // argument passing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:282,Modifiability,variab,variable,282,"// Sampler initialization have 5 cases:; // 1. function argument passing; // 1a. argument is a file-scope variable; // 1b. argument is a function-scope variable; // 1c. argument is one of caller function's parameters; // 2. variable initialization; // 2a. initializing a file-scope variable; // 2b. initializing a function-scope variable; //; // For file-scope variables, since they cannot be initialized by function; // call of __translate_sampler_initializer in LLVM IR, their references; // need to be replaced by a cast from their literal initializers to; // sampler type. Since sampler variables can only be used in function; // calls as arguments, we only need to replace them when handling the; // argument passing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:329,Modifiability,variab,variable,329,"// Sampler initialization have 5 cases:; // 1. function argument passing; // 1a. argument is a file-scope variable; // 1b. argument is a function-scope variable; // 1c. argument is one of caller function's parameters; // 2. variable initialization; // 2a. initializing a file-scope variable; // 2b. initializing a function-scope variable; //; // For file-scope variables, since they cannot be initialized by function; // call of __translate_sampler_initializer in LLVM IR, their references; // need to be replaced by a cast from their literal initializers to; // sampler type. Since sampler variables can only be used in function; // calls as arguments, we only need to replace them when handling the; // argument passing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:361,Modifiability,variab,variables,361,"// Sampler initialization have 5 cases:; // 1. function argument passing; // 1a. argument is a file-scope variable; // 1b. argument is a function-scope variable; // 1c. argument is one of caller function's parameters; // 2. variable initialization; // 2a. initializing a file-scope variable; // 2b. initializing a function-scope variable; //; // For file-scope variables, since they cannot be initialized by function; // call of __translate_sampler_initializer in LLVM IR, their references; // need to be replaced by a cast from their literal initializers to; // sampler type. Since sampler variables can only be used in function; // calls as arguments, we only need to replace them when handling the; // argument passing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:591,Modifiability,variab,variables,591,"// Sampler initialization have 5 cases:; // 1. function argument passing; // 1a. argument is a file-scope variable; // 1b. argument is a function-scope variable; // 1c. argument is one of caller function's parameters; // 2. variable initialization; // 2a. initializing a file-scope variable; // 2b. initializing a function-scope variable; //; // For file-scope variables, since they cannot be initialized by function; // call of __translate_sampler_initializer in LLVM IR, their references; // need to be replaced by a cast from their literal initializers to; // sampler type. Since sampler variables can only be used in function; // calls as arguments, we only need to replace them when handling the; // argument passing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:59,Modifiability,variab,variable,59,"// Case 1a; // For function call with a file-scope sampler variable as argument,; // get the integer literal.; // Do not diagnose if the file-scope variable does not have initializer; // since this has already been diagnosed when parsing the variable; // declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:148,Modifiability,variab,variable,148,"// Case 1a; // For function call with a file-scope sampler variable as argument,; // get the integer literal.; // Do not diagnose if the file-scope variable does not have initializer; // since this has already been diagnosed when parsing the variable; // declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:242,Modifiability,variab,variable,242,"// Case 1a; // For function call with a file-scope sampler variable as argument,; // get the integer literal.; // Do not diagnose if the file-scope variable does not have initializer; // since this has already been diagnosed when parsing the variable; // declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:104,Modifiability,variab,variable,104,"// Case 2; // Check initializer is 32 bit integer constant.; // If the initializer is taken from global variable, do not diagnose since; // this has already been done when parsing the variable declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:184,Modifiability,variab,variable,184,"// Case 2; // Check initializer is 32 bit integer constant.; // If the initializer is taken from global variable, do not diagnose since; // this has already been done when parsing the variable declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:117,Modifiability,extend,extend,117,"// Check whether the initializer has a shorter lifetime than the initialized; // entity, and if not, either lifetime-extend or warn as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:109,Availability,failure,failures,109,"//===----------------------------------------------------------------------===//; // Diagnose initialization failures; //===----------------------------------------------------------------------===//; /// Emit notes associated with an initialization that failed due to a; /// ""simple"" conversion failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:296,Availability,failure,failure,296,"//===----------------------------------------------------------------------===//; // Diagnose initialization failures; //===----------------------------------------------------------------------===//; /// Emit notes associated with an initialization that failed due to a; /// ""simple"" conversion failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:277,Usability,simpl,simple,277,"//===----------------------------------------------------------------------===//; // Diagnose initialization failures; //===----------------------------------------------------------------------===//; /// Emit notes associated with an initialization that failed due to a; /// ""simple"" conversion failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:82,Integrability,message,message,82,// Emit a possible note about the conversion failing because the; // operand is a message send with a related result type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:25,Availability,failure,failure,25,// A list-initialization failure for a reference means that we tried to; // create a temporary of the inner type (per [dcl.init.list]p3.6) and the; // inner initialization failed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:15,Availability,error,error,15,// No-op. This error has already been reported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:103,Usability,clear,clear,103,"// If this is a defaulted or implicitly-declared function, then; // it was implicitly deleted. Make it clear that the deletion was; // implicit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:5,Modifiability,variab,variable,5,// A variable's value may have been narrowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:47,Modifiability,variab,variable,47,"// Oops, we didn't find the actual type of the variable. Don't emit a fixit; // with a broken cast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:35,Performance,perform,performing,35,// Prevent infinite recursion when performing parameter copy-initialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:15,Performance,perform,perform,15,// We can only perform deduction for class templates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:21,Integrability,depend,dependent,21,// Can't deduce from dependent arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:10,Performance,Perform,Perform,10,"// FIXME: Perform ""exact type"" matching first, per CWG discussion?; // Or implement this via an implied 'T(T) -> T' deduction guide?; // FIXME: Do we need/want a std::initializer_list<T> special case?; // Look up deduction guides, including those synthesized from constructors.; //; // C++1z [over.match.class.deduct]p1:; // A set of functions and function templates is formed comprising:; // - For each constructor of the class template designated by the; // template-name, a function template [...]; // - For each deduction-guide, a function or function template [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:126,Usability,guid,guide,126,"// FIXME: Perform ""exact type"" matching first, per CWG discussion?; // Or implement this via an implied 'T(T) -> T' deduction guide?; // FIXME: Do we need/want a std::initializer_list<T> special case?; // Look up deduction guides, including those synthesized from constructors.; //; // C++1z [over.match.class.deduct]p1:; // A set of functions and function templates is formed comprising:; // - For each constructor of the class template designated by the; // template-name, a function template [...]; // - For each deduction-guide, a function or function template [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:223,Usability,guid,guides,223,"// FIXME: Perform ""exact type"" matching first, per CWG discussion?; // Or implement this via an implied 'T(T) -> T' deduction guide?; // FIXME: Do we need/want a std::initializer_list<T> special case?; // Look up deduction guides, including those synthesized from constructors.; //; // C++1z [over.match.class.deduct]p1:; // A set of functions and function templates is formed comprising:; // - For each constructor of the class template designated by the; // template-name, a function template [...]; // - For each deduction-guide, a function or function template [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:526,Usability,guid,guide,526,"// FIXME: Perform ""exact type"" matching first, per CWG discussion?; // Or implement this via an implied 'T(T) -> T' deduction guide?; // FIXME: Do we need/want a std::initializer_list<T> special case?; // Look up deduction guides, including those synthesized from constructors.; //; // C++1z [over.match.class.deduct]p1:; // A set of functions and function templates is formed comprising:; // - For each constructor of the class template designated by the; // template-name, a function template [...]; // - For each deduction-guide, a function or function template [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:128,Security,access,access,128,"// FIXME: Do not diagnose inaccessible deduction guides. The standard isn't; // clear on this, but they're not found by name so access does not apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:49,Usability,guid,guides,49,"// FIXME: Do not diagnose inaccessible deduction guides. The standard isn't; // clear on this, but they're not found by name so access does not apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:80,Usability,clear,clear,80,"// FIXME: Do not diagnose inaccessible deduction guides. The standard isn't; // clear on this, but they're not found by name so access does not apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:523,Energy Efficiency,reduce,reduces,523,"// C++1z [over.match.class.deduct]p1:; // Initialization and overload resolution are performed as described in; // [dcl.init] and [over.match.ctor], [over.match.copy], or [over.match.list]; // (as appropriate for the type of initialization performed) for an object; // of a hypothetical class type, where the selected functions and function; // templates are considered to be the constructors of that class type; //; // Since we know we're initializing a class type of a type unrelated to that; // of the initializer, this reduces to something fairly reasonable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:85,Performance,perform,performed,85,"// C++1z [over.match.class.deduct]p1:; // Initialization and overload resolution are performed as described in; // [dcl.init] and [over.match.ctor], [over.match.copy], or [over.match.list]; // (as appropriate for the type of initialization performed) for an object; // of a hypothetical class type, where the selected functions and function; // templates are considered to be the constructors of that class type; //; // Since we know we're initializing a class type of a type unrelated to that; // of the initializer, this reduces to something fairly reasonable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:240,Performance,perform,performed,240,"// C++1z [over.match.class.deduct]p1:; // Initialization and overload resolution are performed as described in; // [dcl.init] and [over.match.ctor], [over.match.copy], or [over.match.list]; // (as appropriate for the type of initialization performed) for an object; // of a hypothetical class type, where the selected functions and function; // templates are considered to be the constructors of that class type; //; // Since we know we're initializing a class type of a type unrelated to that; // of the initializer, this reduces to something fairly reasonable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:52,Usability,guid,guide,52,"// Overload resolution checks whether the deduction guide is declared; // explicit for us.; // When looking for a converting constructor, deduction guides that; // could never be called with one argument are not interesting to; // check or note.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:148,Usability,guid,guides,148,"// Overload resolution checks whether the deduction guide is declared; // explicit for us.; // When looking for a converting constructor, deduction guides that; // could never be called with one argument are not interesting to; // check or note.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:511,Usability,clear,clear,511,"// C++ [over.match.list]p1.2: (second phase list initialization); // the candidate functions are all the constructors of the class T; // C++ [over.match.ctor]p1: (all other cases); // the candidate functions are all the constructors of the class of; // the object being initialized; // C++ [over.best.ics]p4:; // When [...] the constructor [...] is a candidate by; // - [over.match.copy] (in all cases); // FIXME: The ""second phase of [over.match.list] case can also; // theoretically happen here, but it's not clear whether we can; // ever have a parameter of the right type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:180,Integrability,depend,dependent,180,"// C++ [over.match.class.deduct]p1.4:; // if C is defined and its definition satisfies the conditions for an; // aggregate class ([dcl.init.aggr]) with the assumption that any; // dependent base class has no virtual functions and no virtual base; // classes, and the initializer is a non-empty braced-init-list or; // parenthesized expression-list, and there are no deduction-guides for; // C, the set contains an additional function template, called the; // aggregate deduction candidate, defined as follows.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:376,Usability,guid,guides,376,"// C++ [over.match.class.deduct]p1.4:; // if C is defined and its definition satisfies the conditions for an; // aggregate class ([dcl.init.aggr]) with the assumption that any; // dependent base class has no virtual functions and no virtual base; // classes, and the initializer is a non-empty braced-init-list or; // parenthesized expression-list, and there are no deduction-guides for; // C, the set contains an additional function template, called the; // aggregate deduction candidate, defined as follows.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:52,Usability,guid,guide,52,"// Make sure we didn't select an unusable deduction guide, and mark it; // as referenced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:85,Usability,guid,guides,85,// Warn if CTAD was used on a type that does not have any user-defined; // deduction guides.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:358,Availability,down,down,358,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-ready' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-ready lambda's LambdaScopeInfo.; ///; /// Climbs down the stack of lambdas (deepest nested lambda - i.e. current; /// lambda - is on top) to determine the index of the nearest enclosing/outer; /// lambda that is ready to capture the \p VarToCapture being referenced in; /// the current lambda.; /// As we climb down the stack, we want the index of the first such lambda -; /// that is the lambda with the highest index that is 'capture-ready'.; ///; /// A lambda 'L' is capture-ready for 'V' (var or this) if:; /// - its enclosing context is non-dependent; /// - and if the chain of lambdas between L and the lambda in which; /// V is potentially used (i.e. the lambda at the top of the scope info; /// stack), can all capture or have already captured V.; /// If \p VarToCapture is 'null' then we are trying to capture 'this'.; ///; /// Note that a lambda that is deemed 'capture-ready' still needs to be checked; /// for whether it is 'capture-capable' (see; /// getStackIndexOfNearestEnclosingCaptureCapableLambda), before it can truly; /// capture.; ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack and has the highest index.; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-ready. If the return value evaluates to 'false'; /// then no lambda is capture-ready for \p VarToCapture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:620,Availability,down,down,620,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-ready' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-ready lambda's LambdaScopeInfo.; ///; /// Climbs down the stack of lambdas (deepest nested lambda - i.e. current; /// lambda - is on top) to determine the index of the nearest enclosing/outer; /// lambda that is ready to capture the \p VarToCapture being referenced in; /// the current lambda.; /// As we climb down the stack, we want the index of the first such lambda -; /// that is the lambda with the highest index that is 'capture-ready'.; ///; /// A lambda 'L' is capture-ready for 'V' (var or this) if:; /// - its enclosing context is non-dependent; /// - and if the chain of lambdas between L and the lambda in which; /// V is potentially used (i.e. the lambda at the top of the scope info; /// stack), can all capture or have already captured V.; /// If \p VarToCapture is 'null' then we are trying to capture 'this'.; ///; /// Note that a lambda that is deemed 'capture-ready' still needs to be checked; /// for whether it is 'capture-capable' (see; /// getStackIndexOfNearestEnclosingCaptureCapableLambda), before it can truly; /// capture.; ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack and has the highest index.; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-ready. If the return value evaluates to 'false'; /// then no lambda is capture-ready for \p VarToCapture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:855,Integrability,depend,dependent,855,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-ready' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-ready lambda's LambdaScopeInfo.; ///; /// Climbs down the stack of lambdas (deepest nested lambda - i.e. current; /// lambda - is on top) to determine the index of the nearest enclosing/outer; /// lambda that is ready to capture the \p VarToCapture being referenced in; /// the current lambda.; /// As we climb down the stack, we want the index of the first such lambda -; /// that is the lambda with the highest index that is 'capture-ready'.; ///; /// A lambda 'L' is capture-ready for 'V' (var or this) if:; /// - its enclosing context is non-dependent; /// - and if the chain of lambdas between L and the lambda in which; /// V is potentially used (i.e. the lambda at the top of the scope info; /// stack), can all capture or have already captured V.; /// If \p VarToCapture is 'null' then we are trying to capture 'this'.; ///; /// Note that a lambda that is deemed 'capture-ready' still needs to be checked; /// for whether it is 'capture-capable' (see; /// getStackIndexOfNearestEnclosingCaptureCapableLambda), before it can truly; /// capture.; ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack and has the highest index.; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-ready. If the return value evaluates to 'false'; /// then no lambda is capture-ready for \p VarToCapture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:149,Modifiability,variab,variable,149,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-ready' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-ready lambda's LambdaScopeInfo.; ///; /// Climbs down the stack of lambdas (deepest nested lambda - i.e. current; /// lambda - is on top) to determine the index of the nearest enclosing/outer; /// lambda that is ready to capture the \p VarToCapture being referenced in; /// the current lambda.; /// As we climb down the stack, we want the index of the first such lambda -; /// that is the lambda with the highest index that is 'capture-ready'.; ///; /// A lambda 'L' is capture-ready for 'V' (var or this) if:; /// - its enclosing context is non-dependent; /// - and if the chain of lambdas between L and the lambda in which; /// V is potentially used (i.e. the lambda at the top of the scope info; /// stack), can all capture or have already captured V.; /// If \p VarToCapture is 'null' then we are trying to capture 'this'.; ///; /// Note that a lambda that is deemed 'capture-ready' still needs to be checked; /// for whether it is 'capture-capable' (see; /// getStackIndexOfNearestEnclosingCaptureCapableLambda), before it can truly; /// capture.; ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack and has the highest index.; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-ready. If the return value evaluates to 'false'; /// then no lambda is capture-ready for \p VarToCapture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:1468,Modifiability,inherit,inherits,1468,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-ready' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-ready lambda's LambdaScopeInfo.; ///; /// Climbs down the stack of lambdas (deepest nested lambda - i.e. current; /// lambda - is on top) to determine the index of the nearest enclosing/outer; /// lambda that is ready to capture the \p VarToCapture being referenced in; /// the current lambda.; /// As we climb down the stack, we want the index of the first such lambda -; /// that is the lambda with the highest index that is 'capture-ready'.; ///; /// A lambda 'L' is capture-ready for 'V' (var or this) if:; /// - its enclosing context is non-dependent; /// - and if the chain of lambdas between L and the lambda in which; /// V is potentially used (i.e. the lambda at the top of the scope info; /// stack), can all capture or have already captured V.; /// If \p VarToCapture is 'null' then we are trying to capture 'this'.; ///; /// Note that a lambda that is deemed 'capture-ready' still needs to be checked; /// for whether it is 'capture-capable' (see; /// getStackIndexOfNearestEnclosingCaptureCapableLambda), before it can truly; /// capture.; ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack and has the highest index.; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-ready. If the return value evaluates to 'false'; /// then no lambda is capture-ready for \p VarToCapture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:1611,Modifiability,variab,variable,1611,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-ready' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-ready lambda's LambdaScopeInfo.; ///; /// Climbs down the stack of lambdas (deepest nested lambda - i.e. current; /// lambda - is on top) to determine the index of the nearest enclosing/outer; /// lambda that is ready to capture the \p VarToCapture being referenced in; /// the current lambda.; /// As we climb down the stack, we want the index of the first such lambda -; /// that is the lambda with the highest index that is 'capture-ready'.; ///; /// A lambda 'L' is capture-ready for 'V' (var or this) if:; /// - its enclosing context is non-dependent; /// - and if the chain of lambdas between L and the lambda in which; /// V is potentially used (i.e. the lambda at the top of the scope info; /// stack), can all capture or have already captured V.; /// If \p VarToCapture is 'null' then we are trying to capture 'this'.; ///; /// Note that a lambda that is deemed 'capture-ready' still needs to be checked; /// for whether it is 'capture-capable' (see; /// getStackIndexOfNearestEnclosingCaptureCapableLambda), before it can truly; /// capture.; ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack and has the highest index.; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-ready. If the return value evaluates to 'false'; /// then no lambda is capture-ready for \p VarToCapture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:9,Availability,failure,failure,9,// Label failure to capture.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:22,Availability,down,down,22,"// IF we have climbed down to an intervening enclosing lambda that contains; // the variable declaration - it obviously can/must not capture the; // variable.; // Since its enclosing DC is dependent, all the lambdas between it and the; // innermost nested lambda are dependent (otherwise we wouldn't have; // arrived here) - so we don't yet have a lambda that can capture the; // variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:189,Integrability,depend,dependent,189,"// IF we have climbed down to an intervening enclosing lambda that contains; // the variable declaration - it obviously can/must not capture the; // variable.; // Since its enclosing DC is dependent, all the lambdas between it and the; // innermost nested lambda are dependent (otherwise we wouldn't have; // arrived here) - so we don't yet have a lambda that can capture the; // variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:267,Integrability,depend,dependent,267,"// IF we have climbed down to an intervening enclosing lambda that contains; // the variable declaration - it obviously can/must not capture the; // variable.; // Since its enclosing DC is dependent, all the lambdas between it and the; // innermost nested lambda are dependent (otherwise we wouldn't have; // arrived here) - so we don't yet have a lambda that can capture the; // variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:84,Modifiability,variab,variable,84,"// IF we have climbed down to an intervening enclosing lambda that contains; // the variable declaration - it obviously can/must not capture the; // variable.; // Since its enclosing DC is dependent, all the lambdas between it and the; // innermost nested lambda are dependent (otherwise we wouldn't have; // arrived here) - so we don't yet have a lambda that can capture the; // variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:149,Modifiability,variab,variable,149,"// IF we have climbed down to an intervening enclosing lambda that contains; // the variable declaration - it obviously can/must not capture the; // variable.; // Since its enclosing DC is dependent, all the lambdas between it and the; // innermost nested lambda are dependent (otherwise we wouldn't have; // arrived here) - so we don't yet have a lambda that can capture the; // variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:380,Modifiability,variab,variable,380,"// IF we have climbed down to an intervening enclosing lambda that contains; // the variable declaration - it obviously can/must not capture the; // variable.; // Since its enclosing DC is dependent, all the lambdas between it and the; // innermost nested lambda are dependent (otherwise we wouldn't have; // arrived here) - so we don't yet have a lambda that can capture the; // variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:647,Integrability,depend,dependent,647,"// For an enclosing lambda to be capture ready for an entity, all; // intervening lambda's have to be able to capture that entity. If even; // one of the intervening lambda's is not capable of capturing the entity; // then no enclosing lambda can ever capture that entity.; // For e.g.; // const int x = 10;; // [=](auto a) { #1; // [](auto b) { #2 <-- an intervening lambda that can never capture 'x'; // [=](auto c) { #3; // f(x, c); <-- can not lead to x's speculative capture by #1 or #2; // }; }; };; // If they do not have a default implicit capture, check to see; // if the entity has already been explicitly captured.; // If even a single dependent enclosing lambda lacks the capability; // to ever capture this variable, there is no further enclosing; // non-dependent lambda that can capture this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:768,Integrability,depend,dependent,768,"// For an enclosing lambda to be capture ready for an entity, all; // intervening lambda's have to be able to capture that entity. If even; // one of the intervening lambda's is not capable of capturing the entity; // then no enclosing lambda can ever capture that entity.; // For e.g.; // const int x = 10;; // [=](auto a) { #1; // [](auto b) { #2 <-- an intervening lambda that can never capture 'x'; // [=](auto c) { #3; // f(x, c); <-- can not lead to x's speculative capture by #1 or #2; // }; }; };; // If they do not have a default implicit capture, check to see; // if the entity has already been explicitly captured.; // If even a single dependent enclosing lambda lacks the capability; // to ever capture this variable, there is no further enclosing; // non-dependent lambda that can capture this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:720,Modifiability,variab,variable,720,"// For an enclosing lambda to be capture ready for an entity, all; // intervening lambda's have to be able to capture that entity. If even; // one of the intervening lambda's is not capable of capturing the entity; // then no enclosing lambda can ever capture that entity.; // For e.g.; // const int x = 10;; // [=](auto a) { #1; // [](auto b) { #2 <-- an intervening lambda that can never capture 'x'; // [=](auto c) { #3; // f(x, c); <-- can not lead to x's speculative capture by #1 or #2; // }; }; };; // If they do not have a default implicit capture, check to see; // if the entity has already been explicitly captured.; // If even a single dependent enclosing lambda lacks the capability; // to ever capture this variable, there is no further enclosing; // non-dependent lambda that can capture this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:807,Modifiability,variab,variable,807,"// For an enclosing lambda to be capture ready for an entity, all; // intervening lambda's have to be able to capture that entity. If even; // one of the intervening lambda's is not capable of capturing the entity; // then no enclosing lambda can ever capture that entity.; // For e.g.; // const int x = 10;; // [=](auto a) { #1; // [](auto b) { #2 <-- an intervening lambda that can never capture 'x'; // [=](auto c) { #3; // f(x, c); <-- can not lead to x's speculative capture by #1 or #2; // }; }; };; // If they do not have a default implicit capture, check to see; // if the entity has already been explicitly captured.; // If even a single dependent enclosing lambda lacks the capability; // to ever capture this variable, there is no further enclosing; // non-dependent lambda that can capture this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:29,Integrability,depend,dependent,29,"// If the enclosingDC is not dependent, then the immediately nested lambda; // (one index above) is capture-ready.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:716,Availability,down,down,716,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-capable' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-capable lambda's LambdaScopeInfo.; ///; /// Given the current stack of lambdas being processed by Sema and; /// the variable of interest, to identify the nearest enclosing lambda (to the; /// current lambda at the top of the stack) that can truly capture; /// a variable, it has to have the following two properties:; /// a) 'capture-ready' - be the innermost lambda that is 'capture-ready':; /// - climb down the stack (i.e. starting from the innermost and examining; /// each outer lambda step by step) checking if each enclosing; /// lambda can either implicitly or explicitly capture the variable.; /// Record the first such lambda that is enclosed in a non-dependent; /// context. If no such lambda currently exists return failure.; /// b) 'capture-capable' - make sure the 'capture-ready' lambda can truly; /// capture the variable by checking all its enclosing lambdas:; /// - check if all outer lambdas enclosing the 'capture-ready' lambda; /// identified above in 'a' can also capture the variable (this is done; /// via tryCaptureVariable for variables and CheckCXXThisCapture for; /// 'this' by passing in the index of the Lambda identified in step 'a'); ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack.; ///; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-capable. If the return value evaluates to 'false'; /// th",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:1039,Availability,failure,failure,1039,"tionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-capable' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-capable lambda's LambdaScopeInfo.; ///; /// Given the current stack of lambdas being processed by Sema and; /// the variable of interest, to identify the nearest enclosing lambda (to the; /// current lambda at the top of the stack) that can truly capture; /// a variable, it has to have the following two properties:; /// a) 'capture-ready' - be the innermost lambda that is 'capture-ready':; /// - climb down the stack (i.e. starting from the innermost and examining; /// each outer lambda step by step) checking if each enclosing; /// lambda can either implicitly or explicitly capture the variable.; /// Record the first such lambda that is enclosed in a non-dependent; /// context. If no such lambda currently exists return failure.; /// b) 'capture-capable' - make sure the 'capture-ready' lambda can truly; /// capture the variable by checking all its enclosing lambdas:; /// - check if all outer lambdas enclosing the 'capture-ready' lambda; /// identified above in 'a' can also capture the variable (this is done; /// via tryCaptureVariable for variables and CheckCXXThisCapture for; /// 'this' by passing in the index of the Lambda identified in step 'a'); ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack.; ///; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-capable. If the return value evaluates to 'false'; /// then no lambda is captu",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:973,Integrability,depend,dependent,973,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-capable' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-capable lambda's LambdaScopeInfo.; ///; /// Given the current stack of lambdas being processed by Sema and; /// the variable of interest, to identify the nearest enclosing lambda (to the; /// current lambda at the top of the stack) that can truly capture; /// a variable, it has to have the following two properties:; /// a) 'capture-ready' - be the innermost lambda that is 'capture-ready':; /// - climb down the stack (i.e. starting from the innermost and examining; /// each outer lambda step by step) checking if each enclosing; /// lambda can either implicitly or explicitly capture the variable.; /// Record the first such lambda that is enclosed in a non-dependent; /// context. If no such lambda currently exists return failure.; /// b) 'capture-capable' - make sure the 'capture-ready' lambda can truly; /// capture the variable by checking all its enclosing lambdas:; /// - check if all outer lambdas enclosing the 'capture-ready' lambda; /// identified above in 'a' can also capture the variable (this is done; /// via tryCaptureVariable for variables and CheckCXXThisCapture for; /// 'this' by passing in the index of the Lambda identified in step 'a'); ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack.; ///; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-capable. If the return value evaluates to 'false'; /// th",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:151,Modifiability,variab,variable,151,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-capable' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-capable lambda's LambdaScopeInfo.; ///; /// Given the current stack of lambdas being processed by Sema and; /// the variable of interest, to identify the nearest enclosing lambda (to the; /// current lambda at the top of the stack) that can truly capture; /// a variable, it has to have the following two properties:; /// a) 'capture-ready' - be the innermost lambda that is 'capture-ready':; /// - climb down the stack (i.e. starting from the innermost and examining; /// each outer lambda step by step) checking if each enclosing; /// lambda can either implicitly or explicitly capture the variable.; /// Record the first such lambda that is enclosed in a non-dependent; /// context. If no such lambda currently exists return failure.; /// b) 'capture-capable' - make sure the 'capture-ready' lambda can truly; /// capture the variable by checking all its enclosing lambdas:; /// - check if all outer lambdas enclosing the 'capture-ready' lambda; /// identified above in 'a' can also capture the variable (this is done; /// via tryCaptureVariable for variables and CheckCXXThisCapture for; /// 'this' by passing in the index of the Lambda identified in step 'a'); ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack.; ///; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-capable. If the return value evaluates to 'false'; /// th",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:427,Modifiability,variab,variable,427,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-capable' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-capable lambda's LambdaScopeInfo.; ///; /// Given the current stack of lambdas being processed by Sema and; /// the variable of interest, to identify the nearest enclosing lambda (to the; /// current lambda at the top of the stack) that can truly capture; /// a variable, it has to have the following two properties:; /// a) 'capture-ready' - be the innermost lambda that is 'capture-ready':; /// - climb down the stack (i.e. starting from the innermost and examining; /// each outer lambda step by step) checking if each enclosing; /// lambda can either implicitly or explicitly capture the variable.; /// Record the first such lambda that is enclosed in a non-dependent; /// context. If no such lambda currently exists return failure.; /// b) 'capture-capable' - make sure the 'capture-ready' lambda can truly; /// capture the variable by checking all its enclosing lambdas:; /// - check if all outer lambdas enclosing the 'capture-ready' lambda; /// identified above in 'a' can also capture the variable (this is done; /// via tryCaptureVariable for variables and CheckCXXThisCapture for; /// 'this' by passing in the index of the Lambda identified in step 'a'); ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack.; ///; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-capable. If the return value evaluates to 'false'; /// th",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:573,Modifiability,variab,variable,573,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-capable' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-capable lambda's LambdaScopeInfo.; ///; /// Given the current stack of lambdas being processed by Sema and; /// the variable of interest, to identify the nearest enclosing lambda (to the; /// current lambda at the top of the stack) that can truly capture; /// a variable, it has to have the following two properties:; /// a) 'capture-ready' - be the innermost lambda that is 'capture-ready':; /// - climb down the stack (i.e. starting from the innermost and examining; /// each outer lambda step by step) checking if each enclosing; /// lambda can either implicitly or explicitly capture the variable.; /// Record the first such lambda that is enclosed in a non-dependent; /// context. If no such lambda currently exists return failure.; /// b) 'capture-capable' - make sure the 'capture-ready' lambda can truly; /// capture the variable by checking all its enclosing lambdas:; /// - check if all outer lambdas enclosing the 'capture-ready' lambda; /// identified above in 'a' can also capture the variable (this is done; /// via tryCaptureVariable for variables and CheckCXXThisCapture for; /// 'this' by passing in the index of the Lambda identified in step 'a'); ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack.; ///; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-capable. If the return value evaluates to 'false'; /// th",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:903,Modifiability,variab,variable,903,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-capable' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-capable lambda's LambdaScopeInfo.; ///; /// Given the current stack of lambdas being processed by Sema and; /// the variable of interest, to identify the nearest enclosing lambda (to the; /// current lambda at the top of the stack) that can truly capture; /// a variable, it has to have the following two properties:; /// a) 'capture-ready' - be the innermost lambda that is 'capture-ready':; /// - climb down the stack (i.e. starting from the innermost and examining; /// each outer lambda step by step) checking if each enclosing; /// lambda can either implicitly or explicitly capture the variable.; /// Record the first such lambda that is enclosed in a non-dependent; /// context. If no such lambda currently exists return failure.; /// b) 'capture-capable' - make sure the 'capture-ready' lambda can truly; /// capture the variable by checking all its enclosing lambdas:; /// - check if all outer lambdas enclosing the 'capture-ready' lambda; /// identified above in 'a' can also capture the variable (this is done; /// via tryCaptureVariable for variables and CheckCXXThisCapture for; /// 'this' by passing in the index of the Lambda identified in step 'a'); ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack.; ///; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-capable. If the return value evaluates to 'false'; /// th",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:1140,Modifiability,variab,variable,1140," the nearest; /// enclosing lambda (to the current lambda) that is 'capture-capable' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-capable lambda's LambdaScopeInfo.; ///; /// Given the current stack of lambdas being processed by Sema and; /// the variable of interest, to identify the nearest enclosing lambda (to the; /// current lambda at the top of the stack) that can truly capture; /// a variable, it has to have the following two properties:; /// a) 'capture-ready' - be the innermost lambda that is 'capture-ready':; /// - climb down the stack (i.e. starting from the innermost and examining; /// each outer lambda step by step) checking if each enclosing; /// lambda can either implicitly or explicitly capture the variable.; /// Record the first such lambda that is enclosed in a non-dependent; /// context. If no such lambda currently exists return failure.; /// b) 'capture-capable' - make sure the 'capture-ready' lambda can truly; /// capture the variable by checking all its enclosing lambdas:; /// - check if all outer lambdas enclosing the 'capture-ready' lambda; /// identified above in 'a' can also capture the variable (this is done; /// via tryCaptureVariable for variables and CheckCXXThisCapture for; /// 'this' by passing in the index of the Lambda identified in step 'a'); ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack.; ///; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-capable. If the return value evaluates to 'false'; /// then no lambda is capture-capable for \p VarToCapture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:1309,Modifiability,variab,variable,1309," the nearest; /// enclosing lambda (to the current lambda) that is 'capture-capable' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-capable lambda's LambdaScopeInfo.; ///; /// Given the current stack of lambdas being processed by Sema and; /// the variable of interest, to identify the nearest enclosing lambda (to the; /// current lambda at the top of the stack) that can truly capture; /// a variable, it has to have the following two properties:; /// a) 'capture-ready' - be the innermost lambda that is 'capture-ready':; /// - climb down the stack (i.e. starting from the innermost and examining; /// each outer lambda step by step) checking if each enclosing; /// lambda can either implicitly or explicitly capture the variable.; /// Record the first such lambda that is enclosed in a non-dependent; /// context. If no such lambda currently exists return failure.; /// b) 'capture-capable' - make sure the 'capture-ready' lambda can truly; /// capture the variable by checking all its enclosing lambdas:; /// - check if all outer lambdas enclosing the 'capture-ready' lambda; /// identified above in 'a' can also capture the variable (this is done; /// via tryCaptureVariable for variables and CheckCXXThisCapture for; /// 'this' by passing in the index of the Lambda identified in step 'a'); ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack.; ///; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-capable. If the return value evaluates to 'false'; /// then no lambda is capture-capable for \p VarToCapture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:1364,Modifiability,variab,variables,1364," the nearest; /// enclosing lambda (to the current lambda) that is 'capture-capable' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-capable lambda's LambdaScopeInfo.; ///; /// Given the current stack of lambdas being processed by Sema and; /// the variable of interest, to identify the nearest enclosing lambda (to the; /// current lambda at the top of the stack) that can truly capture; /// a variable, it has to have the following two properties:; /// a) 'capture-ready' - be the innermost lambda that is 'capture-ready':; /// - climb down the stack (i.e. starting from the innermost and examining; /// each outer lambda step by step) checking if each enclosing; /// lambda can either implicitly or explicitly capture the variable.; /// Record the first such lambda that is enclosed in a non-dependent; /// context. If no such lambda currently exists return failure.; /// b) 'capture-capable' - make sure the 'capture-ready' lambda can truly; /// capture the variable by checking all its enclosing lambdas:; /// - check if all outer lambdas enclosing the 'capture-ready' lambda; /// identified above in 'a' can also capture the variable (this is done; /// via tryCaptureVariable for variables and CheckCXXThisCapture for; /// 'this' by passing in the index of the Lambda identified in step 'a'); ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack.; ///; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-capable. If the return value evaluates to 'false'; /// then no lambda is capture-capable for \p VarToCapture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:1583,Modifiability,inherit,inherits,1583," the nearest; /// enclosing lambda (to the current lambda) that is 'capture-capable' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-capable lambda's LambdaScopeInfo.; ///; /// Given the current stack of lambdas being processed by Sema and; /// the variable of interest, to identify the nearest enclosing lambda (to the; /// current lambda at the top of the stack) that can truly capture; /// a variable, it has to have the following two properties:; /// a) 'capture-ready' - be the innermost lambda that is 'capture-ready':; /// - climb down the stack (i.e. starting from the innermost and examining; /// each outer lambda step by step) checking if each enclosing; /// lambda can either implicitly or explicitly capture the variable.; /// Record the first such lambda that is enclosed in a non-dependent; /// context. If no such lambda currently exists return failure.; /// b) 'capture-capable' - make sure the 'capture-ready' lambda can truly; /// capture the variable by checking all its enclosing lambdas:; /// - check if all outer lambdas enclosing the 'capture-ready' lambda; /// identified above in 'a' can also capture the variable (this is done; /// via tryCaptureVariable for variables and CheckCXXThisCapture for; /// 'this' by passing in the index of the Lambda identified in step 'a'); ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack.; ///; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-capable. If the return value evaluates to 'false'; /// then no lambda is capture-capable for \p VarToCapture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:1705,Modifiability,variab,variable,1705," the nearest; /// enclosing lambda (to the current lambda) that is 'capture-capable' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-capable lambda's LambdaScopeInfo.; ///; /// Given the current stack of lambdas being processed by Sema and; /// the variable of interest, to identify the nearest enclosing lambda (to the; /// current lambda at the top of the stack) that can truly capture; /// a variable, it has to have the following two properties:; /// a) 'capture-ready' - be the innermost lambda that is 'capture-ready':; /// - climb down the stack (i.e. starting from the innermost and examining; /// each outer lambda step by step) checking if each enclosing; /// lambda can either implicitly or explicitly capture the variable.; /// Record the first such lambda that is enclosed in a non-dependent; /// context. If no such lambda currently exists return failure.; /// b) 'capture-capable' - make sure the 'capture-ready' lambda can truly; /// capture the variable by checking all its enclosing lambdas:; /// - check if all outer lambdas enclosing the 'capture-ready' lambda; /// identified above in 'a' can also capture the variable (this is done; /// via tryCaptureVariable for variables and CheckCXXThisCapture for; /// 'this' by passing in the index of the Lambda identified in step 'a'); ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack.; ///; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-capable. If the return value evaluates to 'false'; /// then no lambda is capture-capable for \p VarToCapture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:59,Modifiability,variab,variable,59,"// Check if the capture-ready lambda can truly capture the variable, by; // checking whether all enclosing lambdas of the capture-ready lambda allow; // the capture - i.e. make sure it is capture-capable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:46,Modifiability,variab,variables,46,// -- the initializers of inline or templated variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:28,Integrability,depend,dependent,28,"// If a lambda appears in a dependent context or is a generic lambda (has; // template parameters) and has an 'auto' return type, deduce it to a; // dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:149,Integrability,depend,dependent,149,"// If a lambda appears in a dependent context or is a generic lambda (has; // template parameters) and has an 'auto' return type, deduce it to a; // dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:396,Integrability,depend,depends,396,"// Force lambda numbering in CUDA/HIP as we need to name lambdas following; // ODR. Both device- and host-compilation need to have a consistent naming; // on kernel functions. As lambdas are potential part of these `__global__`; // function names, they needs numbering following ODR.; // Also force for SYCL, since we need this for the; // __builtin_sycl_unique_stable_name implementation, which depends on lambda; // mangling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:59,Integrability,Depend,DependentTy,59,"// If it was ever a placeholder, it had to been deduced to DependentTy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:28,Usability,simpl,simply,28,"// It's possible there were simply no /valid/ return statements.; // In this case, the first one we found may have at least given us a type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:50,Integrability,depend,dependent,50,// Second case: at least one return statement has dependent type.; // Delay type checking until instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:56,Modifiability,variab,variable,56,// Just ignore the ellipsis for now and form a non-pack variable. We'll; // diagnose this later when we try to capture it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:3,Performance,Perform,Perform,3,// Perform initialization analysis and ensure any implicit conversions; // (such as lvalue-to-rvalue) are enforced.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:18,Modifiability,variab,variable,18,"// Create a dummy variable representing the init-capture. This is not actually; // used as a variable, and only exists as a way to name and refer to the; // init-capture.; // FIXME: Pass in separate source locations for '&' and identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:93,Modifiability,variab,variable,93,"// Create a dummy variable representing the init-capture. This is not actually; // used as a variable, and only exists as a way to name and refer to the; // init-capture.; // FIXME: Pass in separate source locations for '&' and identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:81,Integrability,depend,dependent,81,"// Determine if we're within a context where we know that the lambda will; // be dependent, because there are template parameters in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:234,Availability,redundant,redundant,234,"// C++20 [expr.prim.lambda]p8:; // If a lambda-capture includes a capture-default that is =,; // each simple-capture of that lambda-capture shall be of the form; // ""&identifier"", ""this"", or ""* this"". [ Note: The form [&,this] is; // redundant but accepted for compatibility with ISO C++14. --end note ]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:234,Safety,redund,redundant,234,"// C++20 [expr.prim.lambda]p8:; // If a lambda-capture includes a capture-default that is =,; // each simple-capture of that lambda-capture shall be of the form; // ""&identifier"", ""this"", or ""* this"". [ Note: The form [&,this] is; // redundant but accepted for compatibility with ISO C++14. --end note ]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:102,Usability,simpl,simple-capture,102,"// C++20 [expr.prim.lambda]p8:; // If a lambda-capture includes a capture-default that is =,; // each simple-capture of that lambda-capture shall be of the form; // ""&identifier"", ""this"", or ""* this"". [ Note: The form [&,this] is; // redundant but accepted for compatibility with ISO C++14. --end note ]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:88,Availability,error,error,88,"// If the initializer expression is usable, but the InitCaptureType; // is not, then an error has occurred - so ignore the capture for now.; // for e.g., [n{0}] { }; <-- if no <initializer_list> is included.; // FIXME: we should create the init capture variable and mark it invalid; // in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:253,Modifiability,variab,variable,253,"// If the initializer expression is usable, but the InitCaptureType; // is not, then an error has occurred - so ignore the capture for now.; // for e.g., [n{0}] { }; <-- if no <initializer_list> is included.; // FIXME: we should create the init capture variable and mark it invalid; // in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:36,Usability,usab,usable,36,"// If the initializer expression is usable, but the InitCaptureType; // is not, then an error has occurred - so ignore the capture for now.; // for e.g., [n{0}] { }; <-- if no <initializer_list> is included.; // FIXME: we should create the init capture variable and mark it invalid; // in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:72,Modifiability,variab,variable,72,// C++11 [expr.prim.lambda]p10:; // [...] each such lookup shall find a variable with automatic storage; // duration declared in the reaching scope of the local lambda expression.; // Note that the 'reaching scope' check happens in tryCaptureVariable().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:341,Modifiability,variab,variable,341,"// C++11 [expr.prim.lambda]p9:; // A lambda-expression whose smallest enclosing scope is a block scope is a; // local lambda expression; any other lambda expression shall not have a; // capture-default or simple-capture in its lambda-introducer.; //; // For simple-captures, this is covered by the check below that any named; // entity is a variable that can be captured.; //; // For DR1632, we also allow a capture-default in any context where we can; // odr-use 'this' (in particular, in a default initializer for a non-static; // data member).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:205,Usability,simpl,simple-capture,205,"// C++11 [expr.prim.lambda]p9:; // A lambda-expression whose smallest enclosing scope is a block scope is a; // local lambda expression; any other lambda expression shall not have a; // capture-default or simple-capture in its lambda-introducer.; //; // For simple-captures, this is covered by the check below that any named; // entity is a variable that can be captured.; //; // For DR1632, we also allow a capture-default in any context where we can; // odr-use 'this' (in particular, in a default initializer for a non-static; // data member).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:258,Usability,simpl,simple-captures,258,"// C++11 [expr.prim.lambda]p9:; // A lambda-expression whose smallest enclosing scope is a block scope is a; // local lambda expression; any other lambda expression shall not have a; // capture-default or simple-capture in its lambda-introducer.; //; // For simple-captures, this is covered by the check below that any named; // entity is a variable that can be captured.; //; // For DR1632, we also allow a capture-default in any context where we can; // odr-use 'this' (in particular, in a default initializer for a non-static; // data member).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:145,Integrability,depend,dependent,145,"// After the parameter list, we may parse a noexcept/requires/trailing return; // type which need to know whether the call operator constiture a dependent; // context, so we need to setup the FunctionTemplateDecl of generic lambdas; // now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:451,Modifiability,variab,variable,451,"// [temp.pre]/8:; // An entity is templated if it is; // - a template,; // - an entity defined ([basic.def]) or created ([class.temporary]) in a; // templated entity,; // - a member of a templated entity,; // - an enumerator for an enumeration that is a templated entity, or; // - the closure type of a lambda-expression ([expr.prim.lambda.closure]); // appearing in the declaration of a templated entity. [Note 6: A local; // class, a local or block variable, or a friend function defined in a; // templated entity is a templated entity.  end note]; //; // A templated function is a function template or a function that is; // templated. A templated class is a class template or a class that is; // templated. A templated variable is a variable template or a variable; // that is templated.; // Note: we only have to check if this is defined in a template entity, OR; // if we are a template, since the rest don't apply. The requires clause; // applies to the call operator, which we already know is a member function,; // AND defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:724,Modifiability,variab,variable,724,"// [temp.pre]/8:; // An entity is templated if it is; // - a template,; // - an entity defined ([basic.def]) or created ([class.temporary]) in a; // templated entity,; // - a member of a templated entity,; // - an enumerator for an enumeration that is a templated entity, or; // - the closure type of a lambda-expression ([expr.prim.lambda.closure]); // appearing in the declaration of a templated entity. [Note 6: A local; // class, a local or block variable, or a friend function defined in a; // templated entity is a templated entity.  end note]; //; // A templated function is a function template or a function that is; // templated. A templated class is a class template or a class that is; // templated. A templated variable is a variable template or a variable; // that is templated.; // Note: we only have to check if this is defined in a template entity, OR; // if we are a template, since the rest don't apply. The requires clause; // applies to the call operator, which we already know is a member function,; // AND defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:738,Modifiability,variab,variable,738,"// [temp.pre]/8:; // An entity is templated if it is; // - a template,; // - an entity defined ([basic.def]) or created ([class.temporary]) in a; // templated entity,; // - a member of a templated entity,; // - an enumerator for an enumeration that is a templated entity, or; // - the closure type of a lambda-expression ([expr.prim.lambda.closure]); // appearing in the declaration of a templated entity. [Note 6: A local; // class, a local or block variable, or a friend function defined in a; // templated entity is a templated entity.  end note]; //; // A templated function is a function template or a function that is; // templated. A templated class is a class template or a class that is; // templated. A templated variable is a variable template or a variable; // that is templated.; // Note: we only have to check if this is defined in a template entity, OR; // if we are a template, since the rest don't apply. The requires clause; // applies to the call operator, which we already know is a member function,; // AND defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:761,Modifiability,variab,variable,761,"// [temp.pre]/8:; // An entity is templated if it is; // - a template,; // - an entity defined ([basic.def]) or created ([class.temporary]) in a; // templated entity,; // - a member of a templated entity,; // - an enumerator for an enumeration that is a templated entity, or; // - the closure type of a lambda-expression ([expr.prim.lambda.closure]); // appearing in the declaration of a templated entity. [Note 6: A local; // class, a local or block variable, or a friend function defined in a; // templated entity is a templated entity.  end note]; //; // A templated function is a function template or a function that is; // templated. A templated class is a class template or a class that is; // templated. A templated variable is a variable template or a variable; // that is templated.; // Note: we only have to check if this is defined in a template entity, OR; // if we are a template, since the rest don't apply. The requires clause; // applies to the call operator, which we already know is a member function,; // AND defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:784,Safety,detect,detecting,784,"/// Implement emitting a version of the operator for many of the calling; /// conventions for MSVC, as described here:; /// https://devblogs.microsoft.com/oldnewthing/20150220-00/?p=44623.; /// Experimentally, we determined that cdecl, stdcall, fastcall, and; /// vectorcall are generated by MSVC when it is supported by the target.; /// Additionally, we are ensuring that the default-free/default-member and; /// call-operator calling convention are generated as well.; /// NOTE: We intentionally generate a 'thiscall' on Win32 implicitly from the; /// 'member default', despite MSVC not doing so. We do this in order to ensure; /// that someone who intentionally places 'thiscall' on the lambda call; /// operator will still get that overload, since we don't have the a way of; /// detecting the attribute by the time we get here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:626,Modifiability,variab,variables,626,"// Construct a TypeSourceInfo for the conversion function, and wire; // all the parameters appropriately for the FunctionProtoTypeLoc; // so that everything works during transformation/instantiation of; // generic lambdas.; // The main reason for wiring up the parameters of the conversion; // function with that of the call operator is so that constructs; // like the following work:; // auto L = [](auto b) { <-- 1; // return [](auto a) -> decltype(a) { <-- 2; // return a;; // };; // };; // int (*fp)(int) = L(5);; // Because the trailing return type can contain DeclRefExprs that refer; // to the original call operator's variables, we hijack the call; // operators ParmVarDecls below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:432,Usability,simpl,simply,432,"// Wire up the FunctionProtoTypeLocs with the call operator's parameters.; // These parameter's are essentially used to transform the name and; // the type of the conversion operator. By using the same parameters; // as the call operator's we don't have to fix any back references that; // the trailing return type of the call operator's uses (such as; // decltype(some_type<decltype(a)>::type{} + decltype(a){}) etc.); // - we can simply use the return type of the call operator, and; // everything should work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:374,Safety,avoid,avoid,374,"// FIXME: Instead of passing in the CallOperator->getTypeSourceInfo(); // we should get a prebuilt TrivialTypeSourceInfo from Context; // using FunctionTy & Loc and get its TypeLoc as a FunctionProtoTypeLoc; // then rewire the parameters accordingly, by hoisting up the InvokeParams; // loop below and then use its Params to set Invoke->setParams(...) below.; // This would avoid the 'const' qualifier of the calloperator from; // contaminating the type of the invoker, which is currently adjusted; // in SemaTemplateDeduction.cpp:DeduceTemplateArguments. Fixing the; // trailing return type of the invoker would require a visitor to rebuild; // the trailing return type and adjusting all back DeclRefExpr's to refer; // to the new static invoker parameters - not the call operator's.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:361,Performance,perform,performed,361,"// C++11 [expr.prim.lambda]p21:; // When the lambda-expression is evaluated, the entities that; // are captured by copy are used to direct-initialize each; // corresponding non-static data member of the resulting closure; // object. (For array members, the array elements are; // direct-initialized in increasing subscript order.) These; // initializations are performed in the (unspecified) order in; // which the non-static data members are declared.; // C++ [expr.prim.lambda]p12:; // An entity captured by a lambda-expression is odr-used (3.2) in; // the scope containing the lambda-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:77,Modifiability,variab,variables,77,"// In OpenMP, the capture kind doesn't actually describe how to capture:; // variables are ""mapped"" onto the device in a process that does not formally; // make a copy, even for a ""copy capture"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:81,Integrability,message,message,81,// FIXME: maybe we should warn on these if we can find a sensible diagnostic; // message,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:10,Modifiability,variab,variable,10,"// If the variable being captured has an invalid type, mark the class as; // invalid as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:59,Availability,avail,available,59,// Use source ranges of explicit captures for fixits where available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:103,Integrability,depend,dependent,103,"// If the lambda expression's call operator is not explicitly marked constexpr; // and we are not in a dependent context, analyze the call operator to infer; // its constexpr-ness, suppressing diagnostics while doing so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:40,Modifiability,variab,variable,40,"// Add capture. The capture uses a fake variable, which doesn't correspond; // to any actual memory location. However, the initializer copy-initializes; // the lambda object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:2,Modifiability,variab,variable,2,/*variable=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Safety,Avoid,Avoid,3,"// Avoid picking up a newer decl, just because it was newer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:270,Modifiability,variab,variable,270,"// C++ [basic.scope.declarative]p4:; // Given a set of declarations in a single declarative region [...]; // exactly one declaration shall declare a class name or enumeration name; // that is not a typedef name and the other declarations shall all refer to; // the same variable, non-static data member, or enumerator, or all refer; // to functions and function templates; in this case the class name or; // enumeration name is hidden.; // C++ [basic.scope.hiding]p2:; // A class name or enumeration name can be hidden by the name of a; // variable, data member, function, or enumerator declared in the same; // scope.; // An UnresolvedUsingValueDecl always instantiates to one of these.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:540,Modifiability,variab,variable,540,"// C++ [basic.scope.declarative]p4:; // Given a set of declarations in a single declarative region [...]; // exactly one declaration shall declare a class name or enumeration name; // that is not a typedef name and the other declarations shall all refer to; // the same variable, non-static data member, or enumerator, or all refer; // to functions and function templates; in this case the class name or; // enumeration name is hidden.; // C++ [basic.scope.hiding]p2:; // A class name or enumeration name can be hidden by the name of a; // variable, data member, function, or enumerator declared in the same; // scope.; // An UnresolvedUsingValueDecl always instantiates to one of these.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:48,Availability,avail,available,48,// Bail out if there is an argument that has no available types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:45,Availability,avail,available,45,// Ignore this builtin function if it is not available in the currently; // selected language version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:198,Availability,avail,available,198,"// Ignore this builtin function if it carries an extension macro that is; // not defined. This indicates that the extension is not supported by the; // target, so the builtin function should not be available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:156,Integrability,inject,injecting,156,"// If we didn't find a use of this identifier, and if the identifier; // corresponds to a compiler builtin, create the decl object for the builtin; // now, injecting it into translation unit scope, and return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:156,Security,inject,injecting,156,"// If we didn't find a use of this identifier, and if the identifier; // corresponds to a compiler builtin, create the decl object for the builtin; // now, injecting it into translation unit scope, and return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:127,Availability,error,error,127,"// In C++ and OpenCL (spec v1.2 s6.9.f), we don't have any predefined; // library functions like 'malloc'. Instead, we'll just error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Perform,Perform,3,// Perform lookup into this declaration context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:14,Performance,perform,performing,14,"// When we're performing lookup for the purposes of redeclaration, just; // add the conversion function template. When we deduce template; // arguments for specializations, we'll end up unifying the return; // type of the new declaration with the type of the function template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:330,Performance,perform,perform,330,"// C++ [temp.mem]p6:; // [...] For each such operator, if argument deduction succeeds; // (14.9.2.3), the resulting specialization is used as if found by; // name lookup.; //; // When referencing a conversion function for any purpose other than; // a redeclaration (such that we'll be building an expression with the; // result), perform template argument deduction and place the; // specialization into the result set. We do this to avoid forcing all; // callers to perform special deduction for conversion functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:467,Performance,perform,perform,467,"// C++ [temp.mem]p6:; // [...] For each such operator, if argument deduction succeeds; // (14.9.2.3), the resulting specialization is used as if found by; // name lookup.; //; // When referencing a conversion function for any purpose other than; // a redeclaration (such that we'll be building an expression with the; // result), perform template argument deduction and place the; // specialization into the result set. We do this to avoid forcing all; // callers to perform special deduction for conversion functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:434,Safety,avoid,avoid,434,"// C++ [temp.mem]p6:; // [...] For each such operator, if argument deduction succeeds; // (14.9.2.3), the resulting specialization is used as if found by; // name lookup.; //; // When referencing a conversion function for any purpose other than; // a redeclaration (such that we'll be building an expression with the; // result), perform template argument deduction and place the; // specialization into the result set. We do this to avoid forcing all; // callers to perform special deduction for conversion functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Perform,Perform,3,// Perform template argument deduction against the type that we would; // expect the function to have.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Perform,Performs,3,// Performs C++ unqualified lookup into the given file context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Perform,Perform,3,// Perform direct name lookup into the LookupCtx.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Perform,Perform,3,// Perform direct name lookup into the namespaces nominated by the; // using directives whose common ancestor is this namespace.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:8,Performance,perform,performing,8,"// When performing a scope lookup, we want to find local extern decls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:88,Modifiability,variab,variables,88,"// We do not look directly into function or method contexts,; // since all of the local variables and parameters of the; // function/method are present within the Scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:86,Integrability,interface,interface,86,"// If we have an Objective-C instance method, look for ivars; // in the corresponding interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:41,Performance,perform,perform,41,"// If this is a file context, we need to perform unqualified name; // lookup considering using directives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Perform,Perform,3,"// Perform qualified name lookup into this context.; // FIXME: In some cases, we know that every name that could be found by; // this qualified name lookup will also be on the identifier chain. For; // example, inside a class without any base classes, we never need to; // perform qualified lookup because all of the members are on top of the; // identifier chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:273,Performance,perform,perform,273,"// Perform qualified name lookup into this context.; // FIXME: In some cases, we know that every name that could be found by; // this qualified name lookup will also be on the identifier chain. For; // example, inside a class without any base classes, we never need to; // perform qualified lookup because all of the members are on top of the; // identifier chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:133,Performance,Cache,Cache,133,"// Collect UsingDirectiveDecls in all scopes, and recursively all; // nominated namespaces by those using-directives.; //; // FIXME: Cache this sorted list in Scope structure, and DeclContext, so we; // don't build it for each lookup!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:16,Performance,perform,performing,16,"// If we're not performing redeclaration lookup, do not look for local; // extern declarations outside of a function scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:24,Performance,cache,cached,24,// Return quickly if we cached the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:91,Usability,usab,usable,91,// If M is the global module fragment of the current translation unit. So it; // should be usable.; // [module.global.frag]p1:; // The global module fragment can be used to provide declarations that are; // attached to the global module and usable within the module unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:241,Usability,usab,usable,241,// If M is the global module fragment of the current translation unit. So it; // should be usable.; // [module.global.frag]p1:; // The global module fragment can be used to provide declarations that are; // attached to the global module and usable within the module unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:430,Safety,avoid,avoid,430,"// If M is the module we're parsing, it should be usable. This covers the; // private module fragment. The private module fragment is usable only if; // it is within the current module unit. And it must be the current; // parsing module unit if it is within the current module unit according; // to the grammar of the private module fragment. NOTE: This is covered by; // the following condition. The intention of the check is to avoid string; // comparison as much as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:50,Usability,usab,usable,50,"// If M is the module we're parsing, it should be usable. This covers the; // private module fragment. The private module fragment is usable only if; // it is within the current module unit. And it must be the current; // parsing module unit if it is within the current module unit according; // to the grammar of the private module fragment. NOTE: This is covered by; // the following condition. The intention of the check is to avoid string; // comparison as much as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:134,Usability,usab,usable,134,"// If M is the module we're parsing, it should be usable. This covers the; // private module fragment. The private module fragment is usable only if; // it is within the current module unit. And it must be the current; // parsing module unit if it is within the current module unit according; // to the grammar of the private module fragment. NOTE: This is covered by; // the following condition. The intention of the check is to avoid string; // comparison as much as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:83,Usability,usab,usable,83,// The module unit which is in the same module with the current module; // unit is usable.; //; // FIXME: Here we judge if they are in the same module by comparing the; // string. Is there any better solution?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:81,Integrability,rout,routine,81,"/// Determine whether a declaration is acceptable to name lookup.; ///; /// This routine determines whether the declaration D is acceptable in the; /// current lookup context, taking into account the current template; /// instantiation stack. During template instantiation, a declaration is; /// acceptable if it is acceptable from a module containing any entity on the; /// template instantiation path (by instantiating a template, you allow it to; /// see the declarations that your module can see, including those later on in; /// your module).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Cache,Cache,3,// Cache the fact that this declaration is implicitly visible because; // its parent has a visible definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:52,Integrability,interface,interface,52,// FIXME: Return false directly if we don't have an interface dependency on the; // translation unit containing D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:62,Integrability,depend,dependency,62,// FIXME: Return false directly if we don't have an interface dependency on the; // translation unit containing D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:107,Integrability,interface,interface,107,"// [module.reach]/p1; // A translation unit U is necessarily reachable from a point P if U is a; // module interface unit on which the translation unit containing P has an; // interface dependency, or the translation unit containing P imports U, in; // either case prior to P ([module.import]).; //; // [module.import]/p10; // A translation unit has an interface dependency on a translation unit U if; // it contains a declaration (possibly a module-declaration) that imports U; // or if it has an interface dependency on a translation unit that has an; // interface dependency on U.; //; // So we could conclude the module unit U is necessarily reachable if:; // (1) The module unit U is module interface unit.; // (2) The current unit has an interface dependency on the module unit U.; //; // Here we only check for the first condition. Since we couldn't see; // DeclModule if it isn't (transitively) imported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:176,Integrability,interface,interface,176,"// [module.reach]/p1; // A translation unit U is necessarily reachable from a point P if U is a; // module interface unit on which the translation unit containing P has an; // interface dependency, or the translation unit containing P imports U, in; // either case prior to P ([module.import]).; //; // [module.import]/p10; // A translation unit has an interface dependency on a translation unit U if; // it contains a declaration (possibly a module-declaration) that imports U; // or if it has an interface dependency on a translation unit that has an; // interface dependency on U.; //; // So we could conclude the module unit U is necessarily reachable if:; // (1) The module unit U is module interface unit.; // (2) The current unit has an interface dependency on the module unit U.; //; // Here we only check for the first condition. Since we couldn't see; // DeclModule if it isn't (transitively) imported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:186,Integrability,depend,dependency,186,"// [module.reach]/p1; // A translation unit U is necessarily reachable from a point P if U is a; // module interface unit on which the translation unit containing P has an; // interface dependency, or the translation unit containing P imports U, in; // either case prior to P ([module.import]).; //; // [module.import]/p10; // A translation unit has an interface dependency on a translation unit U if; // it contains a declaration (possibly a module-declaration) that imports U; // or if it has an interface dependency on a translation unit that has an; // interface dependency on U.; //; // So we could conclude the module unit U is necessarily reachable if:; // (1) The module unit U is module interface unit.; // (2) The current unit has an interface dependency on the module unit U.; //; // Here we only check for the first condition. Since we couldn't see; // DeclModule if it isn't (transitively) imported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:353,Integrability,interface,interface,353,"// [module.reach]/p1; // A translation unit U is necessarily reachable from a point P if U is a; // module interface unit on which the translation unit containing P has an; // interface dependency, or the translation unit containing P imports U, in; // either case prior to P ([module.import]).; //; // [module.import]/p10; // A translation unit has an interface dependency on a translation unit U if; // it contains a declaration (possibly a module-declaration) that imports U; // or if it has an interface dependency on a translation unit that has an; // interface dependency on U.; //; // So we could conclude the module unit U is necessarily reachable if:; // (1) The module unit U is module interface unit.; // (2) The current unit has an interface dependency on the module unit U.; //; // Here we only check for the first condition. Since we couldn't see; // DeclModule if it isn't (transitively) imported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:363,Integrability,depend,dependency,363,"// [module.reach]/p1; // A translation unit U is necessarily reachable from a point P if U is a; // module interface unit on which the translation unit containing P has an; // interface dependency, or the translation unit containing P imports U, in; // either case prior to P ([module.import]).; //; // [module.import]/p10; // A translation unit has an interface dependency on a translation unit U if; // it contains a declaration (possibly a module-declaration) that imports U; // or if it has an interface dependency on a translation unit that has an; // interface dependency on U.; //; // So we could conclude the module unit U is necessarily reachable if:; // (1) The module unit U is module interface unit.; // (2) The current unit has an interface dependency on the module unit U.; //; // Here we only check for the first condition. Since we couldn't see; // DeclModule if it isn't (transitively) imported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:498,Integrability,interface,interface,498,"// [module.reach]/p1; // A translation unit U is necessarily reachable from a point P if U is a; // module interface unit on which the translation unit containing P has an; // interface dependency, or the translation unit containing P imports U, in; // either case prior to P ([module.import]).; //; // [module.import]/p10; // A translation unit has an interface dependency on a translation unit U if; // it contains a declaration (possibly a module-declaration) that imports U; // or if it has an interface dependency on a translation unit that has an; // interface dependency on U.; //; // So we could conclude the module unit U is necessarily reachable if:; // (1) The module unit U is module interface unit.; // (2) The current unit has an interface dependency on the module unit U.; //; // Here we only check for the first condition. Since we couldn't see; // DeclModule if it isn't (transitively) imported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:508,Integrability,depend,dependency,508,"// [module.reach]/p1; // A translation unit U is necessarily reachable from a point P if U is a; // module interface unit on which the translation unit containing P has an; // interface dependency, or the translation unit containing P imports U, in; // either case prior to P ([module.import]).; //; // [module.import]/p10; // A translation unit has an interface dependency on a translation unit U if; // it contains a declaration (possibly a module-declaration) that imports U; // or if it has an interface dependency on a translation unit that has an; // interface dependency on U.; //; // So we could conclude the module unit U is necessarily reachable if:; // (1) The module unit U is module interface unit.; // (2) The current unit has an interface dependency on the module unit U.; //; // Here we only check for the first condition. Since we couldn't see; // DeclModule if it isn't (transitively) imported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:557,Integrability,interface,interface,557,"// [module.reach]/p1; // A translation unit U is necessarily reachable from a point P if U is a; // module interface unit on which the translation unit containing P has an; // interface dependency, or the translation unit containing P imports U, in; // either case prior to P ([module.import]).; //; // [module.import]/p10; // A translation unit has an interface dependency on a translation unit U if; // it contains a declaration (possibly a module-declaration) that imports U; // or if it has an interface dependency on a translation unit that has an; // interface dependency on U.; //; // So we could conclude the module unit U is necessarily reachable if:; // (1) The module unit U is module interface unit.; // (2) The current unit has an interface dependency on the module unit U.; //; // Here we only check for the first condition. Since we couldn't see; // DeclModule if it isn't (transitively) imported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:567,Integrability,depend,dependency,567,"// [module.reach]/p1; // A translation unit U is necessarily reachable from a point P if U is a; // module interface unit on which the translation unit containing P has an; // interface dependency, or the translation unit containing P imports U, in; // either case prior to P ([module.import]).; //; // [module.import]/p10; // A translation unit has an interface dependency on a translation unit U if; // it contains a declaration (possibly a module-declaration) that imports U; // or if it has an interface dependency on a translation unit that has an; // interface dependency on U.; //; // So we could conclude the module unit U is necessarily reachable if:; // (1) The module unit U is module interface unit.; // (2) The current unit has an interface dependency on the module unit U.; //; // Here we only check for the first condition. Since we couldn't see; // DeclModule if it isn't (transitively) imported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:696,Integrability,interface,interface,696,"// [module.reach]/p1; // A translation unit U is necessarily reachable from a point P if U is a; // module interface unit on which the translation unit containing P has an; // interface dependency, or the translation unit containing P imports U, in; // either case prior to P ([module.import]).; //; // [module.import]/p10; // A translation unit has an interface dependency on a translation unit U if; // it contains a declaration (possibly a module-declaration) that imports U; // or if it has an interface dependency on a translation unit that has an; // interface dependency on U.; //; // So we could conclude the module unit U is necessarily reachable if:; // (1) The module unit U is module interface unit.; // (2) The current unit has an interface dependency on the module unit U.; //; // Here we only check for the first condition. Since we couldn't see; // DeclModule if it isn't (transitively) imported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:744,Integrability,interface,interface,744,"// [module.reach]/p1; // A translation unit U is necessarily reachable from a point P if U is a; // module interface unit on which the translation unit containing P has an; // interface dependency, or the translation unit containing P imports U, in; // either case prior to P ([module.import]).; //; // [module.import]/p10; // A translation unit has an interface dependency on a translation unit U if; // it contains a declaration (possibly a module-declaration) that imports U; // or if it has an interface dependency on a translation unit that has an; // interface dependency on U.; //; // So we could conclude the module unit U is necessarily reachable if:; // (1) The module unit U is module interface unit.; // (2) The current unit has an interface dependency on the module unit U.; //; // Here we only check for the first condition. Since we couldn't see; // DeclModule if it isn't (transitively) imported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:754,Integrability,depend,dependency,754,"// [module.reach]/p1; // A translation unit U is necessarily reachable from a point P if U is a; // module interface unit on which the translation unit containing P has an; // interface dependency, or the translation unit containing P imports U, in; // either case prior to P ([module.import]).; //; // [module.import]/p10; // A translation unit has an interface dependency on a translation unit U if; // it contains a declaration (possibly a module-declaration) that imports U; // or if it has an interface dependency on a translation unit that has an; // interface dependency on U.; //; // So we could conclude the module unit U is necessarily reachable if:; // (1) The module unit U is module interface unit.; // (2) The current unit has an interface dependency on the module unit U.; //; // Here we only check for the first condition. Since we couldn't see; // DeclModule if it isn't (transitively) imported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:103,Integrability,interface,interface,103,"// [module.reach]/p2; // Additional translation units on; // which the point within the program has an interface dependency may be; // considered reachable, but it is unspecified which are and under what; // circumstances.; //; // The decision here is to treat all additional tranditional units as; // unreachable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:113,Integrability,depend,dependency,113,"// [module.reach]/p2; // Additional translation units on; // which the point within the program has an interface dependency may be; // considered reachable, but it is unspecified which are and under what; // circumstances.; //; // The decision here is to treat all additional tranditional units as; // unreachable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:481,Safety,safe,safe,481,"// This function is called once ""New"" is essentially complete, but before a; // previous declaration is attached. We can't query the linkage of ""New"" in; // general, because attaching the previous declaration can change the; // linkage of New to match the previous declaration.; //; // However, because we've just determined that there is no *visible* prior; // declaration, we can compute the linkage here. There are two possibilities:; //; // * This is not a redeclaration; it's safe to compute the linkage now.; //; // * This is a redeclaration of a prior declaration that is externally; // redeclarable. In that case, the linkage of the declaration is not; // changed by attaching the prior declaration, because both are externally; // declarable (and thus ExternalLinkage or VisibleNoLinkage).; //; // FIXME: This is subtle and fragile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:80,Integrability,rout,routine,80,"/// Retrieve the visible declaration corresponding to D, if any.; ///; /// This routine determines whether the declaration D is visible in the current; /// module, with the current imports. If not, it checks whether any; /// redeclaration of D is visible, and if so, returns that declaration.; ///; /// \returns D, or a visible previous declaration of D, whichever is more recent; /// and visible. If no declaration of D is visible, returns null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:13,Usability,guid,guide,13,"// Deduction guide lives in namespace scope generally, but it is just a; // hint to the compilers. What we actually lookup for is the generated member; // of the corresponding template. So it is sufficient to check the; // reachability of the template decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:474,Availability,down,downside,474,// FIXME: The lookup for allocation function is a standalone process.; // (We can find the logics in Sema::FindAllocationFunctions); //; // Such structure makes it a problem when we instantiate a template; // declaration using placement allocation function if the placement; // allocation function is invisible.; // (See https://github.com/llvm/llvm-project/issues/59601); //; // Here we workaround it by making the placement allocation functions; // always acceptable. The downside is that we can't diagnose the direct; // use of the invisible placement allocation functions. (Although such uses; // should be rare).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:91,Testability,log,logics,91,// FIXME: The lookup for allocation function is a standalone process.; // (We can find the logics in Sema::FindAllocationFunctions); //; // Such structure makes it a problem when we instantiate a template; // declaration using placement allocation function if the placement; // allocation function is invisible.; // (See https://github.com/llvm/llvm-project/issues/59601); //; // Here we workaround it by making the placement allocation functions; // always acceptable. The downside is that we can't diagnose the direct; // use of the invisible placement allocation functions. (Although such uses; // should be rare).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:376,Availability,Error,Error,376,"// [module.interface]p7; // Class and enumeration member names can be found by name lookup in any; // context in which a definition of the type is reachable.; //; // FIXME: The current implementation didn't consider about scope. For example,; // ```; // // m.cppm; // export module m;; // enum E1 { e1 };; // // Use.cpp; // import m;; // void test() {; // auto a = E1::e1; // Error as expected.; // auto b = e1; // Should be error. namespace-scope name e1 is not visible; // }; // ```; // For the above example, the current implementation would emit error for `a`; // correctly. However, the implementation wouldn't diagnose about `b` now.; // Since we only check the reachability for the parent only.; // See clang/test/CXX/module/module.interface/p7.cpp for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:425,Availability,error,error,425,"// [module.interface]p7; // Class and enumeration member names can be found by name lookup in any; // context in which a definition of the type is reachable.; //; // FIXME: The current implementation didn't consider about scope. For example,; // ```; // // m.cppm; // export module m;; // enum E1 { e1 };; // // Use.cpp; // import m;; // void test() {; // auto a = E1::e1; // Error as expected.; // auto b = e1; // Should be error. namespace-scope name e1 is not visible; // }; // ```; // For the above example, the current implementation would emit error for `a`; // correctly. However, the implementation wouldn't diagnose about `b` now.; // Since we only check the reachability for the parent only.; // See clang/test/CXX/module/module.interface/p7.cpp for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:550,Availability,error,error,550,"// [module.interface]p7; // Class and enumeration member names can be found by name lookup in any; // context in which a definition of the type is reachable.; //; // FIXME: The current implementation didn't consider about scope. For example,; // ```; // // m.cppm; // export module m;; // enum E1 { e1 };; // // Use.cpp; // import m;; // void test() {; // auto a = E1::e1; // Error as expected.; // auto b = e1; // Should be error. namespace-scope name e1 is not visible; // }; // ```; // For the above example, the current implementation would emit error for `a`; // correctly. However, the implementation wouldn't diagnose about `b` now.; // Since we only check the reachability for the parent only.; // See clang/test/CXX/module/module.interface/p7.cpp for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:11,Integrability,interface,interface,11,"// [module.interface]p7; // Class and enumeration member names can be found by name lookup in any; // context in which a definition of the type is reachable.; //; // FIXME: The current implementation didn't consider about scope. For example,; // ```; // // m.cppm; // export module m;; // enum E1 { e1 };; // // Use.cpp; // import m;; // void test() {; // auto a = E1::e1; // Error as expected.; // auto b = e1; // Should be error. namespace-scope name e1 is not visible; // }; // ```; // For the above example, the current implementation would emit error for `a`; // correctly. However, the implementation wouldn't diagnose about `b` now.; // Since we only check the reachability for the parent only.; // See clang/test/CXX/module/module.interface/p7.cpp for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:739,Integrability,interface,interface,739,"// [module.interface]p7; // Class and enumeration member names can be found by name lookup in any; // context in which a definition of the type is reachable.; //; // FIXME: The current implementation didn't consider about scope. For example,; // ```; // // m.cppm; // export module m;; // enum E1 { e1 };; // // Use.cpp; // import m;; // void test() {; // auto a = E1::e1; // Error as expected.; // auto b = e1; // Should be error. namespace-scope name e1 is not visible; // }; // ```; // For the above example, the current implementation would emit error for `a`; // correctly. However, the implementation wouldn't diagnose about `b` now.; // Since we only check the reachability for the parent only.; // See clang/test/CXX/module/module.interface/p7.cpp for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:343,Testability,test,test,343,"// [module.interface]p7; // Class and enumeration member names can be found by name lookup in any; // context in which a definition of the type is reachable.; //; // FIXME: The current implementation didn't consider about scope. For example,; // ```; // // m.cppm; // export module m;; // enum E1 { e1 };; // // Use.cpp; // import m;; // void test() {; // auto a = E1::e1; // Error as expected.; // auto b = e1; // Should be error. namespace-scope name e1 is not visible; // }; // ```; // For the above example, the current implementation would emit error for `a`; // correctly. However, the implementation wouldn't diagnose about `b` now.; // Since we only check the reachability for the parent only.; // See clang/test/CXX/module/module.interface/p7.cpp for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:716,Testability,test,test,716,"// [module.interface]p7; // Class and enumeration member names can be found by name lookup in any; // context in which a definition of the type is reachable.; //; // FIXME: The current implementation didn't consider about scope. For example,; // ```; // // m.cppm; // export module m;; // enum E1 { e1 };; // // Use.cpp; // import m;; // void test() {; // auto a = E1::e1; // Error as expected.; // auto b = e1; // Should be error. namespace-scope name e1 is not visible; // }; // ```; // For the above example, the current implementation would emit error for `a`; // correctly. However, the implementation wouldn't diagnose about `b` now.; // Since we only check the reachability for the parent only.; // See clang/test/CXX/module/module.interface/p7.cpp for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:950,Deployability,update,updated,950,"/// Perform unqualified name lookup starting from a given; /// scope.; ///; /// Unqualified name lookup (C++ [basic.lookup.unqual], C99 6.2.1) is; /// used to find names within the current scope. For example, 'x' in; /// @code; /// int x;; /// int f() {; /// return x; // unqualified name look finds 'x' in the global scope; /// }; /// @endcode; ///; /// Different lookup criteria can find different names. For example, a; /// particular scope can have both a struct and a function of the same; /// name, and each can be found by certain lookup criteria. For more; /// information about lookup criteria, see the documentation for the; /// class LookupCriteria.; ///; /// @param S The scope from which unqualified name lookup will; /// begin. If the lookup criteria permits, name lookup may also search; /// in the parent scopes.; ///; /// @param [in,out] R Specifies the lookup to perform (e.g., the name to; /// look up and the lookup kind), and is updated with the results of lookup; /// including zero or more declarations and possibly additional information; /// used to diagnose ambiguities.; ///; /// @returns \c true if lookup succeeded and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:4,Performance,Perform,Perform,4,"/// Perform unqualified name lookup starting from a given; /// scope.; ///; /// Unqualified name lookup (C++ [basic.lookup.unqual], C99 6.2.1) is; /// used to find names within the current scope. For example, 'x' in; /// @code; /// int x;; /// int f() {; /// return x; // unqualified name look finds 'x' in the global scope; /// }; /// @endcode; ///; /// Different lookup criteria can find different names. For example, a; /// particular scope can have both a struct and a function of the same; /// name, and each can be found by certain lookup criteria. For more; /// information about lookup criteria, see the documentation for the; /// class LookupCriteria.; ///; /// @param S The scope from which unqualified name lookup will; /// begin. If the lookup criteria permits, name lookup may also search; /// in the parent scopes.; ///; /// @param [in,out] R Specifies the lookup to perform (e.g., the name to; /// look up and the lookup kind), and is updated with the results of lookup; /// including zero or more declarations and possibly additional information; /// used to diagnose ambiguities.; ///; /// @returns \c true if lookup succeeded and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:881,Performance,perform,perform,881,"/// Perform unqualified name lookup starting from a given; /// scope.; ///; /// Unqualified name lookup (C++ [basic.lookup.unqual], C99 6.2.1) is; /// used to find names within the current scope. For example, 'x' in; /// @code; /// int x;; /// int f() {; /// return x; // unqualified name look finds 'x' in the global scope; /// }; /// @endcode; ///; /// Different lookup criteria can find different names. For example, a; /// particular scope can have both a struct and a function of the same; /// name, and each can be found by certain lookup criteria. For more; /// information about lookup criteria, see the documentation for the; /// class LookupCriteria.; ///; /// @param S The scope from which unqualified name lookup will; /// begin. If the lookup criteria permits, name lookup may also search; /// in the parent scopes.; ///; /// @param [in,out] R Specifies the lookup to perform (e.g., the name to; /// look up and the lookup kind), and is updated with the results of lookup; /// including zero or more declarations and possibly additional information; /// used to diagnose ambiguities.; ///; /// @returns \c true if lookup succeeded and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:8,Performance,perform,performing,8,"// When performing a scope lookup, we want to find local extern decls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:91,Performance,perform,perform,91,"// If the scope containing the declaration is the translation unit,; // then we'll need to perform our checks based on the matching; // DeclContexts rather than matching scopes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Perform,Perform,3,// Perform C++ unqualified name lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:156,Integrability,inject,injecting,156,"// If we didn't find a use of this identifier, and if the identifier; // corresponds to a compiler builtin, create the decl object for the builtin; // now, injecting it into translation unit scope, and return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:156,Security,inject,injecting,156,"// If we didn't find a use of this identifier, and if the identifier; // corresponds to a compiler builtin, create the decl object for the builtin; // now, injecting it into translation unit scope, and return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:129,Availability,failure,failures,129,"// If we didn't find a use of this identifier, the ExternalSource; // may be able to handle the situation.; // Note: some lookup failures are expected!; // See e.g. R.isForRedeclaration().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:4,Performance,Perform,Perform,4,"/// Perform qualified name lookup in the namespaces nominated by; /// using directives by the given context.; ///; /// C++98 [namespace.qual]p2:; /// Given X::m (where X is a user-declared namespace), or given \::m; /// (where X is the global namespace), let S be the set of all; /// declarations of m in X and in the transitive closure of all; /// namespaces nominated by using-directives in X and its used; /// namespaces, except that using-directives are ignored in any; /// namespace, including X, directly containing one or more; /// declarations of m. No namespace is searched more than once in; /// the lookup of a name. If S is the empty set, the program is; /// ill-formed. Otherwise, if S has exactly one member, or if the; /// context of the reference is a using-declaration; /// (namespace.udecl), S is the required set of declarations of; /// m. Otherwise if the use of m is not one that allows a unique; /// declaration to be chosen from S, the program is ill-formed.; ///; /// C++98 [namespace.qual]p5:; /// During the lookup of a qualified namespace member name, if the; /// lookup finds more than one declaration of the member, and if one; /// declaration introduces a class name or enumeration name and the; /// other declarations either introduce the same object, the same; /// enumerator or a set of functions, the non-type name hides the; /// class or enumeration name if and only if the declarations are; /// from the same namespace; otherwise (the declarations are from; /// different namespaces), the program is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:99,Performance,queue,queue,99,"// We have not yet looked into these namespaces, much less added; // their ""using-children"" to the queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:52,Performance,queue,queue,52,// We have at least added all these contexts to the queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:63,Performance,queue,queue,63,// We have already looked into the initial namespace; seed the queue; // with its using-children.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:43,Safety,avoid,avoid,43,// We go through some convolutions here to avoid copying results; // between LookupResults.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:4,Performance,Perform,Perform,4,"/// Perform qualified name lookup into a given context.; ///; /// Qualified name lookup (C++ [basic.lookup.qual]) is used to find; /// names when the context of those names is explicit specified, e.g.,; /// ""std::vector"" or ""x->member"", or as part of unqualified name lookup.; ///; /// Different lookup criteria can find different names. For example, a; /// particular scope can have both a struct and a function of the same; /// name, and each can be found by certain lookup criteria. For more; /// information about lookup criteria, see the documentation for the; /// class LookupCriteria.; ///; /// \param R captures both the lookup criteria and any lookup results found.; ///; /// \param LookupCtx The context in which qualified name lookup will; /// search. If the lookup criteria permits, name lookup may also search; /// in the parent contexts or (for C++ classes) base classes.; ///; /// \param InUnqualifiedLookup true if this is qualified name lookup that; /// occurs as part of unqualified name lookup.; ///; /// \returns true if lookup succeeded, false if it failed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:283,Availability,avail,available,283,"// If we're performing qualified name lookup into a dependent class,; // then we are actually looking into a current instantiation. If we have any; // dependent base classes, then we either have to delay lookup until; // template instantiation time (at which point all bases will be available); // or we have to fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:52,Integrability,depend,dependent,52,"// If we're performing qualified name lookup into a dependent class,; // then we are actually looking into a current instantiation. If we have any; // dependent base classes, then we either have to delay lookup until; // template instantiation time (at which point all bases will be available); // or we have to fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:151,Integrability,depend,dependent,151,"// If we're performing qualified name lookup into a dependent class,; // then we are actually looking into a current instantiation. If we have any; // dependent base classes, then we either have to delay lookup until; // template instantiation time (at which point all bases will be available); // or we have to fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:12,Performance,perform,performing,12,"// If we're performing qualified name lookup into a dependent class,; // then we are actually looking into a current instantiation. If we have any; // dependent base classes, then we either have to delay lookup until; // template instantiation time (at which point all bases will be available); // or we have to fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Perform,Perform,3,// Perform lookup into our base classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:50,Integrability,inject,injected-class-name,50,"// C++ [temp.local]p3:; // A lookup that finds an injected-class-name (10.2) can result in; // an ambiguity in certain cases (for example, if it is found in; // more than one base class). If all of the injected-class-names; // that are found refer to specializations of the same class; // template, and if the name is used as a template-name, the; // reference refers to the class template itself and not a; // specialization thereof, and is not ambiguous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:202,Integrability,inject,injected-class-names,202,"// C++ [temp.local]p3:; // A lookup that finds an injected-class-name (10.2) can result in; // an ambiguity in certain cases (for example, if it is found in; // more than one base class). If all of the injected-class-names; // that are found refer to specializations of the same class; // template, and if the name is used as a template-name, the; // reference refers to the class template itself and not a; // specialization thereof, and is not ambiguous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:50,Security,inject,injected-class-name,50,"// C++ [temp.local]p3:; // A lookup that finds an injected-class-name (10.2) can result in; // an ambiguity in certain cases (for example, if it is found in; // more than one base class). If all of the injected-class-names; // that are found refer to specializations of the same class; // template, and if the name is used as a template-name, the; // reference refers to the class template itself and not a; // specialization thereof, and is not ambiguous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:202,Security,inject,injected-class-names,202,"// C++ [temp.local]p3:; // A lookup that finds an injected-class-name (10.2) can result in; // an ambiguity in certain cases (for example, if it is found in; // more than one base class). If all of the injected-class-names; // that are found refer to specializations of the same class; // template, and if the name is used as a template-name, the; // reference refers to the class template itself and not a; // specialization thereof, and is not ambiguous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:65,Integrability,inject,injected-class-names,65,// C++ [class.member.lookup]p3:; // type declarations (including injected-class-names) are replaced by; // the types they designate,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:65,Security,inject,injected-class-names,65,// C++ [class.member.lookup]p3:; // type declarations (including injected-class-names) are replaced by; // the types they designate,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:128,Energy Efficiency,efficient,efficiently,128,// We'll often find the declarations are in the same order. Handle this; // case (and the special case of only one declaration) efficiently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:64,Security,access,access,64,// Pick the best (i.e. most permissive i.e. numerically lowest) access; // across all paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:144,Security,access,access,144,// FIXME: This language rule no longer exists. Checking for ambiguous base; // subobjects should be done as part of formation of a class member access; // expression (when converting the object parameter to the member's type).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:114,Integrability,rout,routine,114,"/// Performs qualified name lookup or special type of lookup for; /// ""__super::"" scope specifier.; ///; /// This routine is a convenience overload meant to be called from contexts; /// that need to perform a qualified name lookup with an optional C++ scope; /// specifier that might require special kind of lookup.; ///; /// \param R captures both the lookup criteria and any lookup results found.; ///; /// \param LookupCtx The context in which qualified name lookup will; /// search.; ///; /// \param SS An optional C++ scope-specifier.; ///; /// \returns true if lookup succeeded, false if it failed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:4,Performance,Perform,Performs,4,"/// Performs qualified name lookup or special type of lookup for; /// ""__super::"" scope specifier.; ///; /// This routine is a convenience overload meant to be called from contexts; /// that need to perform a qualified name lookup with an optional C++ scope; /// specifier that might require special kind of lookup.; ///; /// \param R captures both the lookup criteria and any lookup results found.; ///; /// \param LookupCtx The context in which qualified name lookup will; /// search.; ///; /// \param SS An optional C++ scope-specifier.; ///; /// \returns true if lookup succeeded, false if it failed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:199,Performance,perform,perform,199,"/// Performs qualified name lookup or special type of lookup for; /// ""__super::"" scope specifier.; ///; /// This routine is a convenience overload meant to be called from contexts; /// that need to perform a qualified name lookup with an optional C++ scope; /// specifier that might require special kind of lookup.; ///; /// \param R captures both the lookup criteria and any lookup results found.; ///; /// \param LookupCtx The context in which qualified name lookup will; /// search.; ///; /// \param SS An optional C++ scope-specifier.; ///; /// \returns true if lookup succeeded, false if it failed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:131,Integrability,rout,routine,131,"/// Performs name lookup for a name that was parsed in the; /// source code, and may contain a C++ scope specifier.; ///; /// This routine is a convenience routine meant to be called from; /// contexts that receive a name and an optional C++ scope specifier; /// (e.g., ""N::M::x""). It will then perform either qualified or; /// unqualified name lookup (with LookupQualifiedName or LookupName,; /// respectively) on the given name and return those results. It will; /// perform a special type of lookup for ""__super::"" scope specifier.; ///; /// @param S The scope from which unqualified name lookup will; /// begin.; ///; /// @param SS An optional C++ scope-specifier, e.g., ""::N::M"".; ///; /// @param EnteringContext Indicates whether we are going to enter the; /// context of the scope-specifier SS (if present).; ///; /// @returns True if any decls were found (but possibly ambiguous)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:156,Integrability,rout,routine,156,"/// Performs name lookup for a name that was parsed in the; /// source code, and may contain a C++ scope specifier.; ///; /// This routine is a convenience routine meant to be called from; /// contexts that receive a name and an optional C++ scope specifier; /// (e.g., ""N::M::x""). It will then perform either qualified or; /// unqualified name lookup (with LookupQualifiedName or LookupName,; /// respectively) on the given name and return those results. It will; /// perform a special type of lookup for ""__super::"" scope specifier.; ///; /// @param S The scope from which unqualified name lookup will; /// begin.; ///; /// @param SS An optional C++ scope-specifier, e.g., ""::N::M"".; ///; /// @param EnteringContext Indicates whether we are going to enter the; /// context of the scope-specifier SS (if present).; ///; /// @returns True if any decls were found (but possibly ambiguous)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:4,Performance,Perform,Performs,4,"/// Performs name lookup for a name that was parsed in the; /// source code, and may contain a C++ scope specifier.; ///; /// This routine is a convenience routine meant to be called from; /// contexts that receive a name and an optional C++ scope specifier; /// (e.g., ""N::M::x""). It will then perform either qualified or; /// unqualified name lookup (with LookupQualifiedName or LookupName,; /// respectively) on the given name and return those results. It will; /// perform a special type of lookup for ""__super::"" scope specifier.; ///; /// @param S The scope from which unqualified name lookup will; /// begin.; ///; /// @param SS An optional C++ scope-specifier, e.g., ""::N::M"".; ///; /// @param EnteringContext Indicates whether we are going to enter the; /// context of the scope-specifier SS (if present).; ///; /// @returns True if any decls were found (but possibly ambiguous)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:295,Performance,perform,perform,295,"/// Performs name lookup for a name that was parsed in the; /// source code, and may contain a C++ scope specifier.; ///; /// This routine is a convenience routine meant to be called from; /// contexts that receive a name and an optional C++ scope specifier; /// (e.g., ""N::M::x""). It will then perform either qualified or; /// unqualified name lookup (with LookupQualifiedName or LookupName,; /// respectively) on the given name and return those results. It will; /// perform a special type of lookup for ""__super::"" scope specifier.; ///; /// @param S The scope from which unqualified name lookup will; /// begin.; ///; /// @param SS An optional C++ scope-specifier, e.g., ""::N::M"".; ///; /// @param EnteringContext Indicates whether we are going to enter the; /// context of the scope-specifier SS (if present).; ///; /// @returns True if any decls were found (but possibly ambiguous)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:469,Performance,perform,perform,469,"/// Performs name lookup for a name that was parsed in the; /// source code, and may contain a C++ scope specifier.; ///; /// This routine is a convenience routine meant to be called from; /// contexts that receive a name and an optional C++ scope specifier; /// (e.g., ""N::M::x""). It will then perform either qualified or; /// unqualified name lookup (with LookupQualifiedName or LookupName,; /// respectively) on the given name and return those results. It will; /// perform a special type of lookup for ""__super::"" scope specifier.; ///; /// @param S The scope from which unqualified name lookup will; /// begin.; ///; /// @param SS An optional C++ scope-specifier, e.g., ""::N::M"".; ///; /// @param EnteringContext Indicates whether we are going to enter the; /// context of the scope-specifier SS (if present).; ///; /// @returns True if any decls were found (but possibly ambiguous)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:89,Performance,perform,perform,89,"// We have resolved the scope specifier to a particular declaration; // contex, and will perform name lookup in that context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Perform,Perform,3,// Perform unqualified name lookup starting in the given scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:4,Performance,Perform,Perform,4,/// Perform qualified name lookup into all base classes of the given; /// class.; ///; /// \param R captures both the lookup criteria and any lookup results found.; ///; /// \param Class The context in which qualified name lookup will; /// search. Name lookup will search in all base classes merging the results.; ///; /// @returns True if any decls were found (but possibly ambiguous),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:7,Security,access,access-control,7,"// The access-control rules we use here are essentially the rules for; // doing a lookup in Class that just magically skipped the direct; // members of Class itself. That is, the naming class is Class, and the; // access includes the access of the base.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:214,Security,access,access,214,"// The access-control rules we use here are essentially the rules for; // doing a lookup in Class that just magically skipped the direct; // members of Class itself. That is, the naming class is Class, and the; // access includes the access of the base.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:234,Security,access,access,234,"// The access-control rules we use here are essentially the rules for; // doing a lookup in Class that just magically skipped the direct; // members of Class itself. That is, the naming class is Class, and the; // access includes the access of the base.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:63,Security,access,access,63,"// Copy the lookup results into the target, merging the base's access into; // the path access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:88,Security,access,access,88,"// Copy the lookup results into the target, merging the base's access into; // the path access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:7,Availability,recover,recovery,7,"// For recovery purposes, go ahead and implement the hiding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:7,Safety,recover,recovery,7,"// For recovery purposes, go ahead and implement the hiding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:58,Integrability,depend,dependent,58,// Add the associated classes and namespaces for argument-dependent; // lookup that involves a template argument (C++ [basic.lookup.argdep]p2).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:58,Integrability,depend,dependent,58,// Add the associated classes and namespaces for argument-dependent lookup; // with an argument of class type (C++ [basic.lookup.argdep]p2).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:6,Integrability,depend,dependent,6,"// In dependent contexts, we do ADL twice, and the first time around,; // the base type might be a dependent TemplateSpecializationType, or a; // TemplateTypeParmType. If that happens, simply ignore it.; // FIXME: If we want to support export, we probably need to add the; // namespace of the template in a TemplateSpecializationType, or even; // the classes and namespaces of known non-dependent arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:99,Integrability,depend,dependent,99,"// In dependent contexts, we do ADL twice, and the first time around,; // the base type might be a dependent TemplateSpecializationType, or a; // TemplateTypeParmType. If that happens, simply ignore it.; // FIXME: If we want to support export, we probably need to add the; // namespace of the template in a TemplateSpecializationType, or even; // the classes and namespaces of known non-dependent arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:387,Integrability,depend,dependent,387,"// In dependent contexts, we do ADL twice, and the first time around,; // the base type might be a dependent TemplateSpecializationType, or a; // TemplateTypeParmType. If that happens, simply ignore it.; // FIXME: If we want to support export, we probably need to add the; // namespace of the template in a TemplateSpecializationType, or even; // the classes and namespaces of known non-dependent arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:185,Usability,simpl,simply,185,"// In dependent contexts, we do ADL twice, and the first time around,; // the base type might be a dependent TemplateSpecializationType, or a; // TemplateTypeParmType. If that happens, simply ignore it.; // FIXME: If we want to support export, we probably need to add the; // namespace of the template in a TemplateSpecializationType, or even; // the classes and namespaces of known non-dependent arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:62,Integrability,depend,dependent,62,// Add the associated classes and namespaces for; // argument-dependent lookup with an argument of type T; // (C++ [basic.lookup.koenig]p2).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:38,Integrability,depend,dependent,38,"// T is canonical. We can also ignore dependent types because; // we don't need to do ADL at the definition point, but if we; // wanted to implement template export (or if we find some other; // use for associated classes and namespaces...) this would be; // wrong.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Queue,Queue,3,// Queue up the class type into which this points.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:44,Availability,error,error,44,// Non-deduced auto types only get here for error cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:36,Integrability,interface,interface,36,"// If T is an Objective-C object or interface type, or a pointer to an; // object or interface type, the associated namespace is the global; // namespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:85,Integrability,interface,interface,85,"// If T is an Objective-C object or interface type, or a pointer to an; // object or interface type, the associated namespace is the global; // namespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:25,Integrability,wrap,wrappers,25,// Atomic types are just wrappers; use the associations of the; // contained type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:65,Integrability,depend,dependent,65,/// Find the associated classes and namespaces for; /// argument-dependent lookup for a call with the given set of; /// arguments.; ///; /// This routine computes the sets of associated classes and associated; /// namespaces searched by argument-dependent lookup; /// (C++ [basic.lookup.argdep]) for a given set of arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:146,Integrability,rout,routine,146,/// Find the associated classes and namespaces for; /// argument-dependent lookup for a call with the given set of; /// arguments.; ///; /// This routine computes the sets of associated classes and associated; /// namespaces searched by argument-dependent lookup; /// (C++ [basic.lookup.argdep]) for a given set of arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:246,Integrability,depend,dependent,246,/// Find the associated classes and namespaces for; /// argument-dependent lookup for a call with the given set of; /// arguments.; ///; /// This routine computes the sets of associated classes and associated; /// namespaces searched by argument-dependent lookup; /// (C++ [basic.lookup.argdep]) for a given set of arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:374,Integrability,depend,dependent,374,"// [...] In addition, if the argument is the name or address of a; // set of overloaded functions and/or function templates, its; // associated classes and namespaces are the union of those; // associated with each of the members of the set: the namespace; // in which the function or function template is defined and the; // classes and namespaces associated with its (non-dependent); // parameter types and return type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:13,Integrability,protocol,protocol,13,"/// Find the protocol with the given name, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:20,Performance,cache,cached,20,// This was already cached,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:10,Performance,perform,perform,10,// Now we perform lookup on the name we computed earlier and do overload; // resolution. Lookup is only performed directly into the class since there; // will always be a (possibly implicit) declaration to shadow any others.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:104,Performance,perform,performed,104,// Now we perform lookup on the name we computed earlier and do overload; // resolution. Lookup is only performed directly into the class since there; // will always be a (possibly implicit) declaration to shadow any others.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:53,Performance,load,load,53,// Copy the candidates as our processing of them may load new declarations; // from an external source and invalidate lookup_result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:89,Integrability,rout,routine,89,"/// Look for the destructor of the given class.; ///; /// During semantic analysis, this routine should be used in lieu of; /// CXXRecordDecl::getDestructor().; ///; /// \returns The destructor for this class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:152,Integrability,depend,dependent,152,"// C++ [basic.lookup.argdep]p3:; // Let X be the lookup set produced by unqualified lookup (3.4.1); // and let Y be the lookup set produced by argument dependent; // lookup (defined as follows). If X contains [...] then Y is; // empty. Otherwise Y is the set of declarations found in the; // namespaces associated with the argument types as described; // below. The set of declarations found by the lookup of the name; // is the union of X and Y.; //; // Here, we compute Y and add its members to the overloaded; // candidate set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:86,Performance,perform,performed,86,"// When considering an associated namespace, the lookup is the; // same as the lookup performed when the associated namespace is; // used as a qualifier (3.4.3.2) except that:; //; // -- Any using-directives in the associated namespace are; // ignored.; //; // -- Any namespace-scope friend functions declared in; // associated classes are visible within their respective; // namespaces even if they are not visible during an ordinary; // lookup (11.4).; //; // C++20 [basic.lookup.argdep] p4.3; // -- are exported, are attached to a named module M, do not appear; // in the translation unit containing the point of the lookup, and; // have the same innermost enclosing non-inline namespace scope as; // a declaration of an associated entity attached to M.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:42,Integrability,depend,dependent,42,// The declaration is visible to argument-dependent lookup if either; // it's ordinarily visible or declared as a friend in an associated; // class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:29,Performance,cache,cached,29,// TODO: maybe this could be cached when generating the; // associated namespaces / entities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:41,Integrability,depend,dependent,41,"// [basic.lookup.argdep]p4:; // Argument-dependent lookup finds all declarations of functions and; // function templates that; // - ...; // - are declared as a friend ([class.friend]) of any class with a; // reachable definition in the set of associated entities,; //; // FIXME: If there's a merged definition of D that is reachable, then; // the friend declaration should be considered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:41,Performance,optimiz,optimized,41,"/// An entry in the shadow map, which is optimized to store a; /// single declaration (the common case) but can also store a list; /// of declarations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Integrability,Protocol,Protocols,3,// Protocols are in distinct namespaces from everything else.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:41,Availability,avail,available,41,// Determine the set of using directives available during; // unqualified name lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:21,Performance,load,loading,21,// We sometimes skip loading namespace-level results (they tend to be huge).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:28,Modifiability,inherit,inherited,28,// Traverse the contexts of inherited C++ classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:19,Integrability,depend,dependent,19,"// Don't look into dependent bases, because name lookup can't look; // there anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:263,Security,access,accessing,263,"// FIXME: It would be nice to be able to determine whether referencing; // a particular member would be ambiguous. For example, given; //; // struct A { int member; };; // struct B { int member; };; // struct C : A, B { };; //; // void f(C *c) { c->### }; //; // accessing 'member' would result in an ambiguity. However, we; // could be smart enough to qualify the member with the base; // class, e.g.,; //; // c->B::member; //; // or; //; // c->A::member; // Find results in this base class (and its bases).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:12,Integrability,protocol,protocols,12,// Traverse protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:66,Testability,test,tests,66,// No clients run in this mode and it's not supported. Please add tests and; // remove the assertion if you start relying on it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:91,Testability,assert,assertion,91,// No clients run in this mode and it's not supported. Please add tests and; // remove the assertion if you start relying on it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:56,Integrability,interface,interface,56,"// For instance methods, look for ivars in the method's interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:17,Performance,perform,performed,17,// We've already performed all of the name lookup that we need; // to for Objective-C methods; the next context will be the; // outer scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:175,Performance,load,loaded,175,"// Look into the translation unit scope. We walk through the translation; // unit's declaration context, because the Scope itself won't have all of; // the declarations if we loaded a precompiled header.; // FIXME: We would like the translation unit's Scope object to point to; // the translation unit, so we don't need this special ""if"" branch.; // However, doing so would force the normal C++ name-lookup code to look; // into the translation unit decl when the IdentifierInfo chains would; // suffice. Once we fix that problem (which is part of a more general; // ""don't look in DeclContexts unless we have to"" optimization), we can; // eliminate this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:614,Performance,optimiz,optimization,614,"// Look into the translation unit scope. We walk through the translation; // unit's declaration context, because the Scope itself won't have all of; // the declarations if we loaded a precompiled header.; // FIXME: We would like the translation unit's Scope object to point to; // the translation unit, so we don't need this special ""if"" branch.; // However, doing so would force the normal C++ name-lookup code to look; // into the translation unit decl when the IdentifierInfo chains would; // suffice. Once we fix that problem (which is part of a more general; // ""don't look in DeclContexts unless we have to"" optimization), we can; // eliminate this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:9,Usability,simpl,simple,9,"// Use a simple length-based heuristic to determine the minimum possible; // edit distance. If the minimum isn't good enough, bail out early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:194,Performance,perform,performing,194,"// Reset the callback distance; // If the current correction candidate and namespace combination are; // too far away from the original typo based on the normalized edit; // distance, then skip performing a qualified name lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:39,Security,validat,validated,39,// Any corrections added below will be validated in subsequent; // iterations of the main while() loop over the Consumer's contents.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:4,Performance,Perform,Perform,4,/// Perform name lookup for a possible result for typo correction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:86,Integrability,depend,dependent,86,"// In Microsoft mode, don't perform typo correction in a template member; // function dependent context because it interferes with the ""lookup into; // dependent bases of class templates"" feature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:152,Integrability,depend,dependent,152,"// In Microsoft mode, don't perform typo correction in a template member; // function dependent context because it interferes with the ""lookup into; // dependent bases of class templates"" feature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:28,Performance,perform,perform,28,"// In Microsoft mode, don't perform typo correction in a template member; // function dependent context because it interferes with the ""lookup into; // dependent bases of class templates"" feature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Safety,Abort,Abort,3,// Abort if typo correction already failed for this specific typo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:117,Performance,perform,performance,117,"// Provide a stop gap for files that are just seriously broken. Trying; // to correct all typos can turn into a HUGE performance penalty, causing; // some files to take minutes to get rejected by the parser.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:38,Availability,error,error,38,"// If we're handling a missing symbol error, using modules, and the; // special search all modules option is used, look for a missing import.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:40,Performance,load,loading,40,// The following has the side effect of loading the missing module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:233,Energy Efficiency,allocate,allocated,233,// Extend the lifetime of the callback. We delayed this until here; // to avoid allocations in the hot path (which is where no typo correction; // occurs). Note that CorrectionCandidateCallback is polymorphic and; // initially stack-allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Modifiability,Extend,Extend,3,// Extend the lifetime of the callback. We delayed this until here; // to avoid allocations in the hot path (which is where no typo correction; // occurs). Note that CorrectionCandidateCallback is polymorphic and; // initially stack-allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:197,Modifiability,polymorphi,polymorphic,197,// Extend the lifetime of the callback. We delayed this until here; // to avoid allocations in the hot path (which is where no typo correction; // occurs). Note that CorrectionCandidateCallback is polymorphic and; // initially stack-allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:74,Safety,avoid,avoid,74,// Extend the lifetime of the callback. We delayed this until here; // to avoid allocations in the hot path (which is where no typo correction; // occurs). Note that CorrectionCandidateCallback is polymorphic and; // initially stack-allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Perform,Perform,3,"// Perform name lookup to find visible, similarly-named entities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:21,Integrability,interface,interfaces,21,// Look in qualified interfaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Load,Load,3,// Load any externally-known namespaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:1083,Integrability,protocol,protocols,1083,"/// Try to ""correct"" a typo in the source code by finding; /// visible declarations whose names are similar to the name that was; /// present in the source code.; ///; /// \param TypoName the \c DeclarationNameInfo structure that contains; /// the name that was present in the source code along with its location.; ///; /// \param LookupKind the name-lookup criteria used to search for the name.; ///; /// \param S the scope in which name lookup occurs.; ///; /// \param SS the nested-name-specifier that precedes the name we're; /// looking for, if present.; ///; /// \param CCC A CorrectionCandidateCallback object that provides further; /// validation of typo correction candidates. It also provides flags for; /// determining the set of keywords permitted.; ///; /// \param MemberContext if non-NULL, the context in which to look for; /// a member access expression.; ///; /// \param EnteringContext whether we're entering the context described by; /// the nested-name-specifier SS.; ///; /// \param OPT when non-NULL, the search for visible declarations will; /// also walk the protocols in the qualified interfaces of \p OPT.; ///; /// \returns a \c TypoCorrection containing the corrected name if the typo; /// along with information such as the \c NamedDecl where the corrected name; /// was declared, and any additional \c NestedNameSpecifier needed to access; /// it (C++ only). The \c TypoCorrection is empty if there is no correction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:1110,Integrability,interface,interfaces,1110,"/// Try to ""correct"" a typo in the source code by finding; /// visible declarations whose names are similar to the name that was; /// present in the source code.; ///; /// \param TypoName the \c DeclarationNameInfo structure that contains; /// the name that was present in the source code along with its location.; ///; /// \param LookupKind the name-lookup criteria used to search for the name.; ///; /// \param S the scope in which name lookup occurs.; ///; /// \param SS the nested-name-specifier that precedes the name we're; /// looking for, if present.; ///; /// \param CCC A CorrectionCandidateCallback object that provides further; /// validation of typo correction candidates. It also provides flags for; /// determining the set of keywords permitted.; ///; /// \param MemberContext if non-NULL, the context in which to look for; /// a member access expression.; ///; /// \param EnteringContext whether we're entering the context described by; /// the nested-name-specifier SS.; ///; /// \param OPT when non-NULL, the search for visible declarations will; /// also walk the protocols in the qualified interfaces of \p OPT.; ///; /// \returns a \c TypoCorrection containing the corrected name if the typo; /// along with information such as the \c NamedDecl where the corrected name; /// was declared, and any additional \c NestedNameSpecifier needed to access; /// it (C++ only). The \c TypoCorrection is empty if there is no correction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:644,Security,validat,validation,644,"/// Try to ""correct"" a typo in the source code by finding; /// visible declarations whose names are similar to the name that was; /// present in the source code.; ///; /// \param TypoName the \c DeclarationNameInfo structure that contains; /// the name that was present in the source code along with its location.; ///; /// \param LookupKind the name-lookup criteria used to search for the name.; ///; /// \param S the scope in which name lookup occurs.; ///; /// \param SS the nested-name-specifier that precedes the name we're; /// looking for, if present.; ///; /// \param CCC A CorrectionCandidateCallback object that provides further; /// validation of typo correction candidates. It also provides flags for; /// determining the set of keywords permitted.; ///; /// \param MemberContext if non-NULL, the context in which to look for; /// a member access expression.; ///; /// \param EnteringContext whether we're entering the context described by; /// the nested-name-specifier SS.; ///; /// \param OPT when non-NULL, the search for visible declarations will; /// also walk the protocols in the qualified interfaces of \p OPT.; ///; /// \returns a \c TypoCorrection containing the corrected name if the typo; /// along with information such as the \c NamedDecl where the corrected name; /// was declared, and any additional \c NestedNameSpecifier needed to access; /// it (C++ only). The \c TypoCorrection is empty if there is no correction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:852,Security,access,access,852,"/// Try to ""correct"" a typo in the source code by finding; /// visible declarations whose names are similar to the name that was; /// present in the source code.; ///; /// \param TypoName the \c DeclarationNameInfo structure that contains; /// the name that was present in the source code along with its location.; ///; /// \param LookupKind the name-lookup criteria used to search for the name.; ///; /// \param S the scope in which name lookup occurs.; ///; /// \param SS the nested-name-specifier that precedes the name we're; /// looking for, if present.; ///; /// \param CCC A CorrectionCandidateCallback object that provides further; /// validation of typo correction candidates. It also provides flags for; /// determining the set of keywords permitted.; ///; /// \param MemberContext if non-NULL, the context in which to look for; /// a member access expression.; ///; /// \param EnteringContext whether we're entering the context described by; /// the nested-name-specifier SS.; ///; /// \param OPT when non-NULL, the search for visible declarations will; /// also walk the protocols in the qualified interfaces of \p OPT.; ///; /// \returns a \c TypoCorrection containing the corrected name if the typo; /// along with information such as the \c NamedDecl where the corrected name; /// was declared, and any additional \c NestedNameSpecifier needed to access; /// it (C++ only). The \c TypoCorrection is empty if there is no correction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:1362,Security,access,access,1362,"/// Try to ""correct"" a typo in the source code by finding; /// visible declarations whose names are similar to the name that was; /// present in the source code.; ///; /// \param TypoName the \c DeclarationNameInfo structure that contains; /// the name that was present in the source code along with its location.; ///; /// \param LookupKind the name-lookup criteria used to search for the name.; ///; /// \param S the scope in which name lookup occurs.; ///; /// \param SS the nested-name-specifier that precedes the name we're; /// looking for, if present.; ///; /// \param CCC A CorrectionCandidateCallback object that provides further; /// validation of typo correction candidates. It also provides flags for; /// determining the set of keywords permitted.; ///; /// \param MemberContext if non-NULL, the context in which to look for; /// a member access expression.; ///; /// \param EnteringContext whether we're entering the context described by; /// the nested-name-specifier SS.; ///; /// \param OPT when non-NULL, the search for visible declarations will; /// also walk the protocols in the qualified interfaces of \p OPT.; ///; /// \returns a \c TypoCorrection containing the corrected name if the typo; /// along with information such as the \c NamedDecl where the corrected name; /// was declared, and any additional \c NestedNameSpecifier needed to access; /// it (C++ only). The \c TypoCorrection is empty if there is no correction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:45,Integrability,message,message-receiver,45,// Prefer 'super' when we're completing in a message-receiver; // context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:14,Availability,failure,failure,14,"// Record the failure's location if needed and return an empty correction. If; // this was an unqualified lookup and we believe the callback object did not; // filter out possible corrections, also cache the failure for the typo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:208,Availability,failure,failure,208,"// Record the failure's location if needed and return an empty correction. If; // this was an unqualified lookup and we believe the callback object did not; // filter out possible corrections, also cache the failure for the typo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:198,Performance,cache,cache,198,"// Record the failure's location if needed and return an empty correction. If; // this was an unqualified lookup and we believe the callback object did not; // filter out possible corrections, also cache the failure for the typo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:1354,Integrability,protocol,protocols,1354,"/// Try to ""correct"" a typo in the source code by finding; /// visible declarations whose names are similar to the name that was; /// present in the source code.; ///; /// \param TypoName the \c DeclarationNameInfo structure that contains; /// the name that was present in the source code along with its location.; ///; /// \param LookupKind the name-lookup criteria used to search for the name.; ///; /// \param S the scope in which name lookup occurs.; ///; /// \param SS the nested-name-specifier that precedes the name we're; /// looking for, if present.; ///; /// \param CCC A CorrectionCandidateCallback object that provides further; /// validation of typo correction candidates. It also provides flags for; /// determining the set of keywords permitted.; ///; /// \param TDG A TypoDiagnosticGenerator functor that will be used to print; /// diagnostics when the actual typo correction is attempted.; ///; /// \param TRC A TypoRecoveryCallback functor that will be used to build an; /// Expr from a typo correction candidate.; ///; /// \param MemberContext if non-NULL, the context in which to look for; /// a member access expression.; ///; /// \param EnteringContext whether we're entering the context described by; /// the nested-name-specifier SS.; ///; /// \param OPT when non-NULL, the search for visible declarations will; /// also walk the protocols in the qualified interfaces of \p OPT.; ///; /// \returns a new \c TypoExpr that will later be replaced in the AST with an; /// Expr representing the result of performing typo correction, or nullptr if; /// typo correction is not possible. If nullptr is returned, no diagnostics will; /// be emitted and it is the responsibility of the caller to emit any that are; /// needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:1381,Integrability,interface,interfaces,1381,"/// Try to ""correct"" a typo in the source code by finding; /// visible declarations whose names are similar to the name that was; /// present in the source code.; ///; /// \param TypoName the \c DeclarationNameInfo structure that contains; /// the name that was present in the source code along with its location.; ///; /// \param LookupKind the name-lookup criteria used to search for the name.; ///; /// \param S the scope in which name lookup occurs.; ///; /// \param SS the nested-name-specifier that precedes the name we're; /// looking for, if present.; ///; /// \param CCC A CorrectionCandidateCallback object that provides further; /// validation of typo correction candidates. It also provides flags for; /// determining the set of keywords permitted.; ///; /// \param TDG A TypoDiagnosticGenerator functor that will be used to print; /// diagnostics when the actual typo correction is attempted.; ///; /// \param TRC A TypoRecoveryCallback functor that will be used to build an; /// Expr from a typo correction candidate.; ///; /// \param MemberContext if non-NULL, the context in which to look for; /// a member access expression.; ///; /// \param EnteringContext whether we're entering the context described by; /// the nested-name-specifier SS.; ///; /// \param OPT when non-NULL, the search for visible declarations will; /// also walk the protocols in the qualified interfaces of \p OPT.; ///; /// \returns a new \c TypoExpr that will later be replaced in the AST with an; /// Expr representing the result of performing typo correction, or nullptr if; /// typo correction is not possible. If nullptr is returned, no diagnostics will; /// be emitted and it is the responsibility of the caller to emit any that are; /// needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:1524,Performance,perform,performing,1524,"/// Try to ""correct"" a typo in the source code by finding; /// visible declarations whose names are similar to the name that was; /// present in the source code.; ///; /// \param TypoName the \c DeclarationNameInfo structure that contains; /// the name that was present in the source code along with its location.; ///; /// \param LookupKind the name-lookup criteria used to search for the name.; ///; /// \param S the scope in which name lookup occurs.; ///; /// \param SS the nested-name-specifier that precedes the name we're; /// looking for, if present.; ///; /// \param CCC A CorrectionCandidateCallback object that provides further; /// validation of typo correction candidates. It also provides flags for; /// determining the set of keywords permitted.; ///; /// \param TDG A TypoDiagnosticGenerator functor that will be used to print; /// diagnostics when the actual typo correction is attempted.; ///; /// \param TRC A TypoRecoveryCallback functor that will be used to build an; /// Expr from a typo correction candidate.; ///; /// \param MemberContext if non-NULL, the context in which to look for; /// a member access expression.; ///; /// \param EnteringContext whether we're entering the context described by; /// the nested-name-specifier SS.; ///; /// \param OPT when non-NULL, the search for visible declarations will; /// also walk the protocols in the qualified interfaces of \p OPT.; ///; /// \returns a new \c TypoExpr that will later be replaced in the AST with an; /// Expr representing the result of performing typo correction, or nullptr if; /// typo correction is not possible. If nullptr is returned, no diagnostics will; /// be emitted and it is the responsibility of the caller to emit any that are; /// needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:644,Security,validat,validation,644,"/// Try to ""correct"" a typo in the source code by finding; /// visible declarations whose names are similar to the name that was; /// present in the source code.; ///; /// \param TypoName the \c DeclarationNameInfo structure that contains; /// the name that was present in the source code along with its location.; ///; /// \param LookupKind the name-lookup criteria used to search for the name.; ///; /// \param S the scope in which name lookup occurs.; ///; /// \param SS the nested-name-specifier that precedes the name we're; /// looking for, if present.; ///; /// \param CCC A CorrectionCandidateCallback object that provides further; /// validation of typo correction candidates. It also provides flags for; /// determining the set of keywords permitted.; ///; /// \param TDG A TypoDiagnosticGenerator functor that will be used to print; /// diagnostics when the actual typo correction is attempted.; ///; /// \param TRC A TypoRecoveryCallback functor that will be used to build an; /// Expr from a typo correction candidate.; ///; /// \param MemberContext if non-NULL, the context in which to look for; /// a member access expression.; ///; /// \param EnteringContext whether we're entering the context described by; /// the nested-name-specifier SS.; ///; /// \param OPT when non-NULL, the search for visible declarations will; /// also walk the protocols in the qualified interfaces of \p OPT.; ///; /// \returns a new \c TypoExpr that will later be replaced in the AST with an; /// Expr representing the result of performing typo correction, or nullptr if; /// typo correction is not possible. If nullptr is returned, no diagnostics will; /// be emitted and it is the responsibility of the caller to emit any that are; /// needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:1123,Security,access,access,1123,"/// Try to ""correct"" a typo in the source code by finding; /// visible declarations whose names are similar to the name that was; /// present in the source code.; ///; /// \param TypoName the \c DeclarationNameInfo structure that contains; /// the name that was present in the source code along with its location.; ///; /// \param LookupKind the name-lookup criteria used to search for the name.; ///; /// \param S the scope in which name lookup occurs.; ///; /// \param SS the nested-name-specifier that precedes the name we're; /// looking for, if present.; ///; /// \param CCC A CorrectionCandidateCallback object that provides further; /// validation of typo correction candidates. It also provides flags for; /// determining the set of keywords permitted.; ///; /// \param TDG A TypoDiagnosticGenerator functor that will be used to print; /// diagnostics when the actual typo correction is attempted.; ///; /// \param TRC A TypoRecoveryCallback functor that will be used to build an; /// Expr from a typo correction candidate.; ///; /// \param MemberContext if non-NULL, the context in which to look for; /// a member access expression.; ///; /// \param EnteringContext whether we're entering the context described by; /// the nested-name-specifier SS.; ///; /// \param OPT when non-NULL, the search for visible declarations will; /// also walk the protocols in the qualified interfaces of \p OPT.; ///; /// \returns a new \c TypoExpr that will later be replaced in the AST with an; /// Expr representing the result of performing typo correction, or nullptr if; /// typo correction is not possible. If nullptr is returned, no diagnostics will; /// be emitted and it is the responsibility of the caller to emit any that are; /// needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:10,Availability,recover,recover,10,// Try to recover by implicitly importing this module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:10,Safety,recover,recover,10,// Try to recover by implicitly importing this module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:502,Availability,Error,ErrorRecovery,502,"/// Diagnose a successfully-corrected typo. Separated from the correction; /// itself to allow external validation of the result, etc.; ///; /// \param Correction The result of performing typo correction.; /// \param TypoDiag The diagnostic to produce. This will have the corrected; /// string added to it (and usually also a fixit).; /// \param PrevNote A note to use when indicating the location of the entity to; /// which we are correcting. Will have the correction string added to it.; /// \param ErrorRecovery If \c true (the default), the caller is going to; /// recover from the typo as if the corrected string had been typed.; /// In this case, \c PDiag must be an error, and we will attach a fixit; /// to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:570,Availability,recover,recover,570,"/// Diagnose a successfully-corrected typo. Separated from the correction; /// itself to allow external validation of the result, etc.; ///; /// \param Correction The result of performing typo correction.; /// \param TypoDiag The diagnostic to produce. This will have the corrected; /// string added to it (and usually also a fixit).; /// \param PrevNote A note to use when indicating the location of the entity to; /// which we are correcting. Will have the correction string added to it.; /// \param ErrorRecovery If \c true (the default), the caller is going to; /// recover from the typo as if the corrected string had been typed.; /// In this case, \c PDiag must be an error, and we will attach a fixit; /// to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:674,Availability,error,error,674,"/// Diagnose a successfully-corrected typo. Separated from the correction; /// itself to allow external validation of the result, etc.; ///; /// \param Correction The result of performing typo correction.; /// \param TypoDiag The diagnostic to produce. This will have the corrected; /// string added to it (and usually also a fixit).; /// \param PrevNote A note to use when indicating the location of the entity to; /// which we are correcting. Will have the correction string added to it.; /// \param ErrorRecovery If \c true (the default), the caller is going to; /// recover from the typo as if the corrected string had been typed.; /// In this case, \c PDiag must be an error, and we will attach a fixit; /// to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:177,Performance,perform,performing,177,"/// Diagnose a successfully-corrected typo. Separated from the correction; /// itself to allow external validation of the result, etc.; ///; /// \param Correction The result of performing typo correction.; /// \param TypoDiag The diagnostic to produce. This will have the corrected; /// string added to it (and usually also a fixit).; /// \param PrevNote A note to use when indicating the location of the entity to; /// which we are correcting. Will have the correction string added to it.; /// \param ErrorRecovery If \c true (the default), the caller is going to; /// recover from the typo as if the corrected string had been typed.; /// In this case, \c PDiag must be an error, and we will attach a fixit; /// to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:570,Safety,recover,recover,570,"/// Diagnose a successfully-corrected typo. Separated from the correction; /// itself to allow external validation of the result, etc.; ///; /// \param Correction The result of performing typo correction.; /// \param TypoDiag The diagnostic to produce. This will have the corrected; /// string added to it (and usually also a fixit).; /// \param PrevNote A note to use when indicating the location of the entity to; /// which we are correcting. Will have the correction string added to it.; /// \param ErrorRecovery If \c true (the default), the caller is going to; /// recover from the typo as if the corrected string had been typed.; /// In this case, \c PDiag must be an error, and we will attach a fixit; /// to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:104,Security,validat,validation,104,"/// Diagnose a successfully-corrected typo. Separated from the correction; /// itself to allow external validation of the result, etc.; ///; /// \param Correction The result of performing typo correction.; /// \param TypoDiag The diagnostic to produce. This will have the corrected; /// string added to it (and usually also a fixit).; /// \param PrevNote A note to use when indicating the location of the entity to; /// which we are correcting. Will have the correction string added to it.; /// \param ErrorRecovery If \c true (the default), the caller is going to; /// recover from the typo as if the corrected string had been typed.; /// In this case, \c PDiag must be an error, and we will attach a fixit; /// to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:102,Security,access,access,102,"// We represent the primary and partition names as 'Paths' which are sections; // of the hierarchical access path for a clang module. However for C++20; // the periods in a name are just another character, and we will need to; // flatten them into a string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:241,Usability,usab,usable,241,// [module.global.frag]p2; // A global-module-fragment specifies the contents of the global module; // fragment for a module unit. The global module fragment can be used to; // provide declarations that are attached to the global module and usable; // within the module unit.; //; // So the declations in the global module shouldn't be visible by default.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:19,Availability,error,error,19,"// For the sake of error recovery (if someone has moved the original header; // after creating the pre-processed output) fall back to obtaining the file; // ref for the input file, which must be present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:25,Availability,recover,recovery,25,"// For the sake of error recovery (if someone has moved the original header; // after creating the pre-processed output) fall back to obtaining the file; // ref for the input file, which must be present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:25,Safety,recover,recovery,25,"// For the sake of error recovery (if someone has moved the original header; // after creating the pre-processed output) fall back to obtaining the file; // ref for the input file, which must be present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:4,Testability,Test,Tests,4,/// Tests whether the given identifier is reserved as a module name and; /// diagnoses if it is. Returns true if a diagnostic is emitted and false; /// otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:149,Integrability,interface,interface,149,"// A (non-partition) module implementation unit requires that we are not; // compiling a module of any kind. A partition implementation emits an; // interface (and the AST for the implementation), which will subsequently; // be consumed to emit a binary.; // A module interface unit requires that we are not compiling a module map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:268,Integrability,interface,interface,268,"// A (non-partition) module implementation unit requires that we are not; // compiling a module of any kind. A partition implementation emits an; // interface (and the AST for the implementation), which will subsequently; // be consumed to emit a binary.; // A module interface unit requires that we are not compiling a module map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:31,Integrability,interface,interface,31,// It's OK to compile a module interface as a normal translation unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:37,Integrability,interface,interface,37,// We were asked to compile a module interface unit but this is a module; // implementation unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:402,Testability,Test,Test,402,// C++23 [module.unit]p1: ... The identifiers module and import shall not; // appear as identifiers in a module-name or module-partition. All; // module-names either beginning with an identifier consisting of std; // followed by zero or more digits or containing a reserved identifier; // ([lex.name]) are reserved and shall not be specified in a; // module-declaration; no diagnostic is required.; // Test the first part of the path to see if it's std[0-9]+ but allow the; // name in a system header.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:8,Testability,test,test,8,// Then test all of the components in the path to see if any of them are; // using another kind of reserved or invalid identifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:7,Integrability,interface,interface,7,// The interface for an implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:140,Integrability,interface,interface,140,// C++20 A module-declaration that contains neither an export-; // keyword nor a module-partition implicitly imports the primary; // module interface unit of the module as if by a module-import-; // declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:14,Performance,load,loader,14,// The module loader will assume we're trying to import the module that; // we're building if `LangOpts.CurrentModule` equals to 'ModuleName'.; // Change the value for `LangOpts.CurrentModule` temporarily to make the; // module loader work properly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:228,Performance,load,loader,228,// The module loader will assume we're trying to import the module that; // we're building if `LangOpts.CurrentModule` equals to 'ModuleName'.; // Change the value for `LangOpts.CurrentModule` temporarily to make the; // module loader work properly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:45,Availability,error,error,45,// Create an empty module interface unit for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:51,Availability,recover,recovery,51,// Create an empty module interface unit for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:26,Integrability,interface,interface,26,// Create an empty module interface unit for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:51,Safety,recover,recovery,51,// Create an empty module interface unit for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:13,Integrability,interface,interface,13,"// Create an interface, but note that it is an implementation; // unit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:113,Integrability,interface,interface,113,// We already potentially made an implicit import (in the case of a module; // implementation unit importing its interface). Make this module visible; // and return the import decl to be added to the current TU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:32,Integrability,interface,interface,32,// Make the import decl for the interface in the impl module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:87,Integrability,interface,interface,87,// As if we imported it.; // Also save this as a shortcut to checking for decls in the interface,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:47,Integrability,interface,interface,47,"// If we made an implicit import of the module interface, then return the; // imported module decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:97,Integrability,interface,interface,97,// C++20 [basic.link]/2:; // A private-module-fragment shall appear only in a primary module; // interface unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:156,Integrability,interface,interface,156,// All declarations created from now on are scoped to the private module; // fragment (and are neither visible nor reachable in importers of the module; // interface).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:253,Integrability,interface,interface,253,"// Diagnose self-import before attempting a load.; // [module.import]/9; // A module implementation unit of a module M that is not a module partition; // shall not contain a module-import-declaration nominating M.; // (for an implementation, the module interface is imported implicitly,; // but that's handled in the module decl code).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:44,Performance,load,load,44,"// Diagnose self-import before attempting a load.; // [module.import]/9; // A module implementation unit of a module M that is not a module partition; // shall not contain a module-import-declaration nominating M.; // (for an implementation, the module interface is imported implicitly,; // but that's handled in the module decl code).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:201,Availability,error,error,201,"//checkModuleImportContext(*this, Mod, ImportLoc, CurContext);; // FIXME: we should support importing a submodule within a different submodule; // of the same top-level module. Until we do, make it an error rather than; // silently ignoring the import.; // FIXME: Should we warn on a redundant import of the current module?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:284,Availability,redundant,redundant,284,"//checkModuleImportContext(*this, Mod, ImportLoc, CurContext);; // FIXME: we should support importing a submodule within a different submodule; // of the same top-level module. Until we do, make it an error rather than; // silently ignoring the import.; // FIXME: Should we warn on a redundant import of the current module?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:284,Safety,redund,redundant,284,"//checkModuleImportContext(*this, Mod, ImportLoc, CurContext);; // FIXME: we should support importing a submodule within a different submodule; // of the same top-level module. Until we do, make it an error rather than; // silently ignoring the import.; // FIXME: Should we warn on a redundant import of the current module?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:11,Integrability,interface,interface,11,// [module.interface]p1:; // An export-declaration shall inhabit a namespace scope and appear in the; // purview of a module interface unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:125,Integrability,interface,interface,125,// [module.interface]p1:; // An export-declaration shall inhabit a namespace scope and appear in the; // purview of a module interface unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:68,Performance,cache,cache,68,"// Leaving a module hides namespace names, so our visible namespace cache; // is now out of date.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:17,Integrability,interface,interface,17,// C++2a [module.interface]p1:; // An export-declaration shall appear only [...] in the purview of a module; // interface unit. An export-declaration shall not appear directly or; // indirectly within [...] a private-module-fragment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:112,Integrability,interface,interface,112,// C++2a [module.interface]p1:; // An export-declaration shall appear only [...] in the purview of a module; // interface unit. An export-declaration shall not appear directly or; // indirectly within [...] a private-module-fragment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:189,Safety,avoid,avoid,189,"// A declaration is exported if it is [...] a namespace-definition; // that contains an exported declaration.; //; // Defer exporting the namespace until after we leave it, in order to; // avoid marking all subsequent declarations in the namespace as exported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:17,Integrability,interface,interface,17,// C++20 [module.interface]p3:; // [...] it shall not declare a name with internal linkage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:17,Integrability,interface,interface,17,// C++2a [module.interface]p5:; // all entities to which all of the using-declarators ultimately refer; // shall have been introduced with a name having external linkage,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:47,Modifiability,variab,variable,47,"// [dcl.inline]/7; // If an inline function or variable that is attached to a named module; // is declared in a definition domain, it shall be defined in that; // domain.; // So, if the current declaration does not have a definition, we must; // check at the end of the TU (or when the PMF starts) to see that we; // have a definition at that point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:82,Integrability,protocol,protocol,82,/// Check this Objective-C property against a property declared in the; /// given protocol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:21,Integrability,protocol,protocol,21,// Have we seen this protocol before?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:35,Integrability,protocol,protocols,35,// Check this property against any protocols we inherit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:48,Modifiability,inherit,inherit,48,// Check this property against any protocols we inherit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:3,Security,Validat,Validate,3,// Validate the attributes on the @property.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:55,Integrability,protocol,protocols,55,// Also compare the property against a property in our protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:28,Integrability,protocol,protocols,28,// Slower path: look in all protocols we referenced.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:10,Performance,load,load,10,// Try to load the file buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:27,Integrability,interface,interface,27,// We need to look in the @interface to see if the @property was; // already declared.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:28,Modifiability,extend,extended,28,// Find the property in the extended class's primary class or; // extensions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:148,Availability,error,error,148,// A readonly property declared in the primary class can be refined; // by adding a readwrite property within an extension.; // Anything else is an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:155,Availability,error,error,155,// Tailor the diagnostics for the common case where a readwrite; // property is declared both in the @interface and the continuation.; // This is a common error where the user often intended the original; // declaration to be readonly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:102,Integrability,interface,interface,102,// Tailor the diagnostics for the common case where a readwrite; // property is declared both in the @interface and the continuation.; // This is a common error where the user often intended the original; // declaration to be readonly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:250,Safety,safe,safe,250,// Relax the strict type matching for property type in continuation class.; // Allow property object type of continuation class to be different as long; // as it narrows the object type in its primary class property. Note that; // this conversion is safe only because the wider type is for a 'readonly'; // property in primary class and 'narrowed' type for a 'readwrite' property; // in continuation class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:113,Integrability,protocol,protocol,113,"// Issue a warning if property is 'assign' as default and its; // object, which is gc'able conforms to NSCopying protocol",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:63,Integrability,rout,routine,63,"/// setImpliedPropertyAttributeForReadOnlyProperty -; /// This routine evaludates life-time attributes for a 'readonly'; /// property with no known lifetime of its own, using backing; /// 'ivar's attribute, if any. If no backing 'ivar', property's; /// life-time is assumed 'strong'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:155,Integrability,protocol,protocols,155,"/// SelectPropertyForSynthesisFromProtocols - Finds the most appropriate; /// property declaration that should be synthesised in all of the inherited; /// protocols. It also diagnoses properties declared in inherited protocols with; /// mismatched types or attributes, since any of them can be candidate for; /// synthesis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:217,Integrability,protocol,protocols,217,"/// SelectPropertyForSynthesisFromProtocols - Finds the most appropriate; /// property declaration that should be synthesised in all of the inherited; /// protocols. It also diagnoses properties declared in inherited protocols with; /// mismatched types or attributes, since any of them can be candidate for; /// synthesis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:140,Modifiability,inherit,inherited,140,"/// SelectPropertyForSynthesisFromProtocols - Finds the most appropriate; /// property declaration that should be synthesised in all of the inherited; /// protocols. It also diagnoses properties declared in inherited protocols with; /// mismatched types or attributes, since any of them can be candidate for; /// synthesis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:207,Modifiability,inherit,inherited,207,"/// SelectPropertyForSynthesisFromProtocols - Finds the most appropriate; /// property declaration that should be synthesised in all of the inherited; /// protocols. It also diagnoses properties declared in inherited protocols with; /// mismatched types or attributes, since any of them can be candidate for; /// synthesis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:38,Integrability,protocol,protocol,38,// Represents a property from another protocol that conflicts with the; // selected declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:29,Availability,error,error,29,// Promote the warning to an error if there are incompatible attributes or; // incompatible types together with readwrite/readonly incompatibility.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:27,Integrability,protocol,protocols,27,// Look through all of the protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:34,Security,access,accessor,34,/// Create a synthesized property accessor stub inside the \@implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:43,Testability,stub,stub,43,/// Create a synthesized property accessor stub inside the \@implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:33,Integrability,rout,routine,33,/// ActOnPropertyImplDecl - This routine performs semantic checks and; /// builds the AST node for a property implementation declaration; declared; /// as \@synthesize or \@dynamic.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:41,Performance,perform,performs,41,/// ActOnPropertyImplDecl - This routine performs semantic checks and; /// builds the AST node for a property implementation declaration; declared; /// as \@synthesize or \@dynamic.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:27,Integrability,interface,interface,27,"// We always synthesize an interface for an implementation; // without an interface decl. So, IDecl is always non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:74,Integrability,interface,interface,74,"// We always synthesize an interface for an implementation; // without an interface decl. So, IDecl is always non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:64,Integrability,interface,interface,64,// Look for this property declaration in the @implementation's @interface,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:59,Availability,error,error,59,"// If category for this implementation not found, it is an error which; // has already been reported eralier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:62,Integrability,interface,interface,62,// Check that this is a previously declared 'ivar' in 'IDecl' interface,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:11,Availability,error,error,11,// It's an error if we have to do this and the user didn't; // explicitly write an ownership attribute on the property.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:96,Safety,avoid,avoid,96,"// Note! I deliberately want it to fall thru so, we have a; // a property implementation and to avoid future warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:53,Availability,error,errors,53,// Note! I deliberately want it to fall thru so more errors are caught.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:96,Safety,avoid,avoid,96,"// Note! I deliberately want it to fall thru so, we have a; // a property implementation and to avoid future warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:96,Integrability,rout,routine,96,// FIXME! Rules for properties are somewhat different that those; // for assignments. Use a new routine to consolidate all cases;; // specifically for property redeclarations as well as for ivars.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:28,Integrability,protocol,protocols,28,"// Readonly properties from protocols can be implemented as ""readwrite""; // with a custom setter name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:38,Integrability,rout,routine,38,/// CollectImmediateProperties - This routine collects all properties in; /// the class and its conforming protocols; but not those in its super class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:107,Integrability,protocol,protocols,107,/// CollectImmediateProperties - This routine collects all properties in; /// the class and its conforming protocols; but not those in its super class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:24,Integrability,protocol,protocols,24,// Scan through class's protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:24,Integrability,protocol,protocols,24,// Scan through class's protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:24,Integrability,protocol,protocols,24,"// Exclude property for protocols which conform to class's super-class,; // as super-class has to implement the property.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:16,Integrability,protocol,protocol,16,// Scan through protocol's protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:27,Integrability,protocol,protocols,27,// Scan through protocol's protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:52,Integrability,rout,routine,52,/// CollectSuperClassPropertyImplementations - This routine collects list of; /// properties to be implemented in super class(s) and also coming from their; /// conforming protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:172,Integrability,protocol,protocols,172,/// CollectSuperClassPropertyImplementations - This routine collects list of; /// properties to be implemented in super class(s) and also coming from their; /// conforming protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:42,Integrability,rout,routine,42,/// IvarBacksCurrentMethodAccessor - This routine returns 'true' if 'IV' is; /// an ivar synthesized for 'Method' and 'Method' is a property accessor; /// declared in class 'IFace'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:141,Security,access,accessor,141,/// IvarBacksCurrentMethodAccessor - This routine returns 'true' if 'IV' is; /// an ivar synthesized for 'Method' and 'Method' is a property accessor; /// declared in class 'IFace'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:51,Security,access,accessors,51,// look up a property declaration whose one of its accessors is implemented; // by this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:77,Security,access,accessors,77,// Also look up property declaration in class extension whose one of its; // accessors is implemented by this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:51,Integrability,protocol,protocols,51,"// We won't auto-synthesize properties declared in protocols.; // Suppress the warning if class's superclass implements property's; // getter and implements property's setter (if readwrite property).; // Or, if property is going to be implemented in its super class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:153,Integrability,protocol,protocol,153,"// When reporting on missing property setter/getter implementation in; // categories, do not report when they are declared in primary class,; // class's protocol, or one of it super classes. This is because,; // the class is going to implement them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:13,Integrability,interface,interface,13,"// Scan the @interface to see if any of the protocols it adopts; // require an explicit implementation, via attribute; // 'objc_protocol_requires_explicit_implementation'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:44,Integrability,protocol,protocols,44,"// Scan the @interface to see if any of the protocols it adopts; // require an explicit implementation, via attribute; // 'objc_protocol_requires_explicit_implementation'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:56,Integrability,interface,interface,56,"// Lazily construct a set of all the properties in the @interface; // of the class, without looking at the superclass. We cannot; // use the call to CollectImmediateProperties() above as that; // utilizes information from the super class's properties as well; // as scans the adopted protocols. This work only triggers for protocols; // with the attribute, which is very rare, and only occurs when; // analyzing the @implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:284,Integrability,protocol,protocols,284,"// Lazily construct a set of all the properties in the @interface; // of the class, without looking at the superclass. We cannot; // use the call to CollectImmediateProperties() above as that; // utilizes information from the super class's properties as well; // as scans the adopted protocols. This work only triggers for protocols; // with the attribute, which is very rare, and only occurs when; // analyzing the @implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:323,Integrability,protocol,protocols,323,"// Lazily construct a set of all the properties in the @interface; // of the class, without looking at the superclass. We cannot; // use the call to CollectImmediateProperties() above as that; // utilizes information from the super class's properties as well; // as scans the adopted protocols. This work only triggers for protocols; // with the attribute, which is very rare, and only occurs when; // analyzing the @implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:20,Security,access,accessors,20,// Collect property accessors implemented in current implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:208,Deployability,update,update,208,/// ProcessPropertyDecl - Make sure that any user-defined setter/getter methods; /// have the property type and issue diagnostics if they don't.; /// Also synthesize a getter/setter method if none exist (and update the; /// appropriate lookup tables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:16,Security,access,accessors,16,// synthesizing accessors must not result in a direct method that is not; // monomorphic,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:156,Integrability,interface,interface,156,"// Add any synthesized methods to the global pool. This allows us to; // handle the following, which is supported by GCC (and part of the design).; //; // @interface Foo; // @property double bar;; // @end; //; // void thisIsUnfortunate() {; // id foo;; // double bar = [foo bar];; // }; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:85,Modifiability,inherit,inherited,85,// Don't issue warning on property with no life time in class; // extension as it is inherited from property in primary class.; // Skip this warning in gc-only mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:28,Integrability,depend,dependent,28,// FIXME: Implement warning dependent on NSCopying being; // implemented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:122,Modifiability,variab,variables,122,//===----------------------------------------------------------------------===//; // Stack of data-sharing attributes for variables; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:75,Modifiability,variab,variable,75,/// Pointer to a reference expression and a flag which shows that the; /// variable is marked as lastprivate(true) or not (false).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:61,Modifiability,variab,variable,61,"/// true if the attribute is applied to the pointee, not the variable; /// itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:12,Integrability,depend,depend,12,/// Set of 'depend' clauses with 'sink|source' dependence kind. Required to; /// get the data (loop counters etc.) about enclosing loop-based construct.; /// This data is required during codegen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:47,Integrability,depend,dependence,47,/// Set of 'depend' clauses with 'sink|source' dependence kind. Required to; /// get the data (loop counters etc.) about enclosing loop-based construct.; /// This data is required during codegen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:12,Modifiability,variab,variable,12,/// Capture variable decl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:20,Modifiability,variab,variables,20,/// true if all the variables in the target executable directives must be; /// captured by reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:18,Modifiability,variab,variable,18,/// Checks if the variable is a local for OpenMP region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:83,Testability,log,logically,83,/// RAII object to temporarily leave the scope of a directive when we want to; /// logically operate in its parent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:27,Modifiability,variab,variables,27,/// Start capturing of the variables in the loop context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:13,Modifiability,variab,variables,13,"/// true, if variables are captured, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:14,Usability,clear,clears,14,/// Marks (or clears) declaration as possibly loop counter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:39,Modifiability,variab,variable,39,"/// If 'aligned' declaration for given variable \a D was not seen yet,; /// add it and return NULL; otherwise return previous occurrence's expression; /// for diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:43,Modifiability,variab,variable,43,"/// If 'nontemporal' declaration for given variable \a D was not seen yet,; /// add it and return NULL; otherwise return previous occurrence's expression; /// for diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:23,Modifiability,variab,variable,23,/// Register specified variable as loop control variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:48,Modifiability,variab,variable,48,/// Register specified variable as loop control variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:27,Modifiability,variab,variable,27,/// Check if the specified variable is a loop control variable for; /// current region.; /// \return The index of the loop control variable in the list of associated; /// for-loops (from outer to inner).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:54,Modifiability,variab,variable,54,/// Check if the specified variable is a loop control variable for; /// current region.; /// \return The index of the loop control variable in the list of associated; /// for-loops (from outer to inner).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:131,Modifiability,variab,variable,131,/// Check if the specified variable is a loop control variable for; /// current region.; /// \return The index of the loop control variable in the list of associated; /// for-loops (from outer to inner).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:27,Modifiability,variab,variable,27,/// Check if the specified variable is a loop control variable for; /// parent region.; /// \return The index of the loop control variable in the list of associated; /// for-loops (from outer to inner).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:54,Modifiability,variab,variable,54,/// Check if the specified variable is a loop control variable for; /// parent region.; /// \return The index of the loop control variable in the list of associated; /// for-loops (from outer to inner).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:130,Modifiability,variab,variable,130,/// Check if the specified variable is a loop control variable for; /// parent region.; /// \return The index of the loop control variable in the list of associated; /// for-loops (from outer to inner).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:27,Modifiability,variab,variable,27,/// Check if the specified variable is a loop control variable for; /// current region.; /// \return The index of the loop control variable in the list of associated; /// for-loops (from outer to inner).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:54,Modifiability,variab,variable,54,/// Check if the specified variable is a loop control variable for; /// current region.; /// \return The index of the loop control variable in the list of associated; /// for-loops (from outer to inner).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:131,Modifiability,variab,variable,131,/// Check if the specified variable is a loop control variable for; /// current region.; /// \return The index of the loop control variable in the list of associated; /// for-loops (from outer to inner).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:25,Modifiability,variab,variable,25,/// Get the loop control variable for the I-th loop (or nullptr) in; /// parent directive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:92,Modifiability,variab,variable,92,/// Checks if the given \p VD declaration is actually a taskgroup reduction; /// descriptor variable at the \p Level of OpenMP regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:28,Modifiability,variab,variables,28,/// Checks if the specified variables has data-sharing attributes which; /// match specified \a CPred predicate in any directive which matches \a DPred; /// predicate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:28,Modifiability,variab,variables,28,/// Checks if the specified variables has data-sharing attributes which; /// match specified \a CPred predicate in any innermost directive which; /// matches \a DPred predicate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:28,Modifiability,variab,variables,28,/// Checks if the specified variables has explicit data-sharing; /// attributes which match specified \a CPred predicate at the specified; /// OpenMP region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:28,Modifiability,variab,variable,28,/// Checks if the specified variable is a threadprivate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:23,Modifiability,variab,variable,23,/// Add a new iterator variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:13,Modifiability,variab,variable,13,/// Check if variable declaration is an iterator VarDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:177,Integrability,rout,routines,177,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a region but not in construct]; // File-scope or namespace-scope variables referenced in called routines; // in the region are shared unless they appear in a threadprivate; // directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,Variab,Variables,53,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a region but not in construct]; // File-scope or namespace-scope variables referenced in called routines; // in the region are shared unless they appear in a threadprivate; // directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:146,Modifiability,variab,variables,146,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a region but not in construct]; // File-scope or namespace-scope variables referenced in called routines; // in the region are shared unless they appear in a threadprivate; // directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:187,Integrability,rout,routines,187,"// OpenMP [2.9.1.2, Data-sharing Attribute Rules for Variables Referenced; // in a region but not in construct]; // Variables with static storage duration that are declared in called; // routines in the region are shared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,Variab,Variables,53,"// OpenMP [2.9.1.2, Data-sharing Attribute Rules for Variables Referenced; // in a region but not in construct]; // Variables with static storage duration that are declared in called; // routines in the region are shared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:116,Modifiability,Variab,Variables,116,"// OpenMP [2.9.1.2, Data-sharing Attribute Rules for Variables Referenced; // in a region but not in construct]; // Variables with static storage duration that are declared in called; // routines in the region are shared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,Variab,Variables,53,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, C/C++, predetermined, p.1]; // Variables with automatic storage duration that are declared in a scope; // inside the construct are private.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:125,Modifiability,Variab,Variables,125,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, C/C++, predetermined, p.1]; // Variables with automatic storage duration that are declared in a scope; // inside the construct are private.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:45,Modifiability,variab,variables,45,// Explicitly specified attributes and local variables with predetermined; // attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,Variab,Variables,53,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, C/C++, implicitly determined, p.1]; // In a parallel or task construct, the data-sharing attributes of these; // variables are determined by the default clause, if present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:207,Modifiability,variab,variables,207,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, C/C++, implicitly determined, p.1]; // In a parallel or task construct, the data-sharing attributes of these; // variables are determined by the default clause, if present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:8,Modifiability,variab,variable,8,"// each variable with static storage duration that is declared; // in a namespace or global scope and referenced in the construct,; // and that does not have a predetermined data-sharing attribute",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,Variab,Variables,53,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, implicitly determined, p.2]; // In a parallel construct, if no default clause is present, these; // variables are shared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:194,Modifiability,variab,variables,194,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, implicitly determined, p.2]; // In a parallel construct, if no default clause is present, these; // variables are shared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,Variab,Variables,53,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, implicitly determined, p.4]; // In a task construct, if no default clause is present, a variable that in; // the enclosing context is determined to be shared by all implicit tasks; // bound to the current team is shared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:182,Modifiability,variab,variable,182,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, implicitly determined, p.4]; // In a task construct, if no default clause is present, a variable that in; // the enclosing context is determined to be shared by all implicit tasks; // bound to the current team is shared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,Variab,Variables,53,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables; // Referenced in a Construct, implicitly determined, p.6]; // In a task construct, if no default clause is present, a variable; // whose data-sharing attribute is not determined by the rules above is; // firstprivate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:182,Modifiability,variab,variable,182,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables; // Referenced in a Construct, implicitly determined, p.6]; // In a task construct, if no default clause is present, a variable; // whose data-sharing attribute is not determined by the rules above is; // firstprivate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
