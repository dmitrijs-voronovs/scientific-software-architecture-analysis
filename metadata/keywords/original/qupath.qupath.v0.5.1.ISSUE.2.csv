id,quality_attribute,keyword,matched_word,match_idx,sentence,source,author,repo,version,wiki,url
https://github.com/qupath/qupath/issues/1262:559,Modifiability,Config,Configure,559,"## Bug report. **Describe the bug**; fail to build qupath with openjdk on ArchLinux. **To Reproduce**; Steps to reproduce the behavior:; ```bash; cd qupath-0.4.3; gradle clean jpackage -Porg.gradle.java.home=/usr/lib/jvm/default; ```. **Expected behavior**; success to build qupath 0.4.3. **Screenshots**; If applicable, add screenshots to help explain your problem. **Desktop (please complete the following information):**; - OS: ArchLinux; - QuPath Version: 0.4.3; - java: jdk-openjdk 20.0.1.u9-3; - gradle: 8.1.1. **Additional context**; logs:; ```text; > Configure project :qupath-app; Unable to determine Java version from toolchain: No matching toolchains found for requested specification: {languageVersion=17, vendor=any, implementation=vendor-specific}.; Unable to determine Java version from toolchain: No matching toolchains found for requested specification: {languageVersion=17, vendor=any, implementation=vendor-specific}. FAILURE: Build failed with an exception. * Where:; Build file '/build/qupath/src/qupath-0.4.3/qupath-app/build.gradle' line: 540. * What went wrong:; A problem occurred configuring project ':qupath-app'.; > Failed to calculate the value of task ':qupath-app:compileJava' property 'javaCompiler'.; > No matching toolchains found for requested specification: {languageVersion=17, vendor=any, implementation=vendor-specific}.; > No locally installed toolchains match (see https://docs.gradle.org/8.1.1/userguide/toolchains.html#sec:auto_detection) and toolchain download repositories have not been configured (see https://docs.gradle.org/8.1.1/userguide/toolchains.html#sub:download_repositories).; ```; It seems related to how we specify the toolchain, https://github.com/qupath/qupath/blob/1368912885c1a191beaea32c28d85a3707f657f8/qupath-app/build.gradle#L535-L548; Maybe, we could follow this: https://github.com/Project-MONAI/MONAILabel/blob/0332f42643015046055a3410b770d1e8a0e1bd57/plugins/qupath/build.gradle#L39-L51; Just add a project property `toolchain` wit",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1262
https://github.com/qupath/qupath/issues/1262:1106,Modifiability,config,configuring,1106,"Steps to reproduce the behavior:; ```bash; cd qupath-0.4.3; gradle clean jpackage -Porg.gradle.java.home=/usr/lib/jvm/default; ```. **Expected behavior**; success to build qupath 0.4.3. **Screenshots**; If applicable, add screenshots to help explain your problem. **Desktop (please complete the following information):**; - OS: ArchLinux; - QuPath Version: 0.4.3; - java: jdk-openjdk 20.0.1.u9-3; - gradle: 8.1.1. **Additional context**; logs:; ```text; > Configure project :qupath-app; Unable to determine Java version from toolchain: No matching toolchains found for requested specification: {languageVersion=17, vendor=any, implementation=vendor-specific}.; Unable to determine Java version from toolchain: No matching toolchains found for requested specification: {languageVersion=17, vendor=any, implementation=vendor-specific}. FAILURE: Build failed with an exception. * Where:; Build file '/build/qupath/src/qupath-0.4.3/qupath-app/build.gradle' line: 540. * What went wrong:; A problem occurred configuring project ':qupath-app'.; > Failed to calculate the value of task ':qupath-app:compileJava' property 'javaCompiler'.; > No matching toolchains found for requested specification: {languageVersion=17, vendor=any, implementation=vendor-specific}.; > No locally installed toolchains match (see https://docs.gradle.org/8.1.1/userguide/toolchains.html#sec:auto_detection) and toolchain download repositories have not been configured (see https://docs.gradle.org/8.1.1/userguide/toolchains.html#sub:download_repositories).; ```; It seems related to how we specify the toolchain, https://github.com/qupath/qupath/blob/1368912885c1a191beaea32c28d85a3707f657f8/qupath-app/build.gradle#L535-L548; Maybe, we could follow this: https://github.com/Project-MONAI/MONAILabel/blob/0332f42643015046055a3410b770d1e8a0e1bd57/plugins/qupath/build.gradle#L39-L51; Just add a project property `toolchain` with a default value, so user could specify it with `-Ptoolchain=20` or simply use the default one (eg. 1",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1262
https://github.com/qupath/qupath/issues/1262:1532,Modifiability,config,configured,1532,"ps to reproduce the behavior:; ```bash; cd qupath-0.4.3; gradle clean jpackage -Porg.gradle.java.home=/usr/lib/jvm/default; ```. **Expected behavior**; success to build qupath 0.4.3. **Screenshots**; If applicable, add screenshots to help explain your problem. **Desktop (please complete the following information):**; - OS: ArchLinux; - QuPath Version: 0.4.3; - java: jdk-openjdk 20.0.1.u9-3; - gradle: 8.1.1. **Additional context**; logs:; ```text; > Configure project :qupath-app; Unable to determine Java version from toolchain: No matching toolchains found for requested specification: {languageVersion=17, vendor=any, implementation=vendor-specific}.; Unable to determine Java version from toolchain: No matching toolchains found for requested specification: {languageVersion=17, vendor=any, implementation=vendor-specific}. FAILURE: Build failed with an exception. * Where:; Build file '/build/qupath/src/qupath-0.4.3/qupath-app/build.gradle' line: 540. * What went wrong:; A problem occurred configuring project ':qupath-app'.; > Failed to calculate the value of task ':qupath-app:compileJava' property 'javaCompiler'.; > No matching toolchains found for requested specification: {languageVersion=17, vendor=any, implementation=vendor-specific}.; > No locally installed toolchains match (see https://docs.gradle.org/8.1.1/userguide/toolchains.html#sec:auto_detection) and toolchain download repositories have not been configured (see https://docs.gradle.org/8.1.1/userguide/toolchains.html#sub:download_repositories).; ```; It seems related to how we specify the toolchain, https://github.com/qupath/qupath/blob/1368912885c1a191beaea32c28d85a3707f657f8/qupath-app/build.gradle#L535-L548; Maybe, we could follow this: https://github.com/Project-MONAI/MONAILabel/blob/0332f42643015046055a3410b770d1e8a0e1bd57/plugins/qupath/build.gradle#L39-L51; Just add a project property `toolchain` with a default value, so user could specify it with `-Ptoolchain=20` or simply use the default one (eg. 17).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1262
https://github.com/qupath/qupath/issues/1262:1921,Modifiability,plugin,plugins,1921,"ps to reproduce the behavior:; ```bash; cd qupath-0.4.3; gradle clean jpackage -Porg.gradle.java.home=/usr/lib/jvm/default; ```. **Expected behavior**; success to build qupath 0.4.3. **Screenshots**; If applicable, add screenshots to help explain your problem. **Desktop (please complete the following information):**; - OS: ArchLinux; - QuPath Version: 0.4.3; - java: jdk-openjdk 20.0.1.u9-3; - gradle: 8.1.1. **Additional context**; logs:; ```text; > Configure project :qupath-app; Unable to determine Java version from toolchain: No matching toolchains found for requested specification: {languageVersion=17, vendor=any, implementation=vendor-specific}.; Unable to determine Java version from toolchain: No matching toolchains found for requested specification: {languageVersion=17, vendor=any, implementation=vendor-specific}. FAILURE: Build failed with an exception. * Where:; Build file '/build/qupath/src/qupath-0.4.3/qupath-app/build.gradle' line: 540. * What went wrong:; A problem occurred configuring project ':qupath-app'.; > Failed to calculate the value of task ':qupath-app:compileJava' property 'javaCompiler'.; > No matching toolchains found for requested specification: {languageVersion=17, vendor=any, implementation=vendor-specific}.; > No locally installed toolchains match (see https://docs.gradle.org/8.1.1/userguide/toolchains.html#sec:auto_detection) and toolchain download repositories have not been configured (see https://docs.gradle.org/8.1.1/userguide/toolchains.html#sub:download_repositories).; ```; It seems related to how we specify the toolchain, https://github.com/qupath/qupath/blob/1368912885c1a191beaea32c28d85a3707f657f8/qupath-app/build.gradle#L535-L548; Maybe, we could follow this: https://github.com/Project-MONAI/MONAILabel/blob/0332f42643015046055a3410b770d1e8a0e1bd57/plugins/qupath/build.gradle#L39-L51; Just add a project property `toolchain` with a default value, so user could specify it with `-Ptoolchain=20` or simply use the default one (eg. 17).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1262
https://github.com/qupath/qupath/issues/1262:541,Testability,log,logs,541,"## Bug report. **Describe the bug**; fail to build qupath with openjdk on ArchLinux. **To Reproduce**; Steps to reproduce the behavior:; ```bash; cd qupath-0.4.3; gradle clean jpackage -Porg.gradle.java.home=/usr/lib/jvm/default; ```. **Expected behavior**; success to build qupath 0.4.3. **Screenshots**; If applicable, add screenshots to help explain your problem. **Desktop (please complete the following information):**; - OS: ArchLinux; - QuPath Version: 0.4.3; - java: jdk-openjdk 20.0.1.u9-3; - gradle: 8.1.1. **Additional context**; logs:; ```text; > Configure project :qupath-app; Unable to determine Java version from toolchain: No matching toolchains found for requested specification: {languageVersion=17, vendor=any, implementation=vendor-specific}.; Unable to determine Java version from toolchain: No matching toolchains found for requested specification: {languageVersion=17, vendor=any, implementation=vendor-specific}. FAILURE: Build failed with an exception. * Where:; Build file '/build/qupath/src/qupath-0.4.3/qupath-app/build.gradle' line: 540. * What went wrong:; A problem occurred configuring project ':qupath-app'.; > Failed to calculate the value of task ':qupath-app:compileJava' property 'javaCompiler'.; > No matching toolchains found for requested specification: {languageVersion=17, vendor=any, implementation=vendor-specific}.; > No locally installed toolchains match (see https://docs.gradle.org/8.1.1/userguide/toolchains.html#sec:auto_detection) and toolchain download repositories have not been configured (see https://docs.gradle.org/8.1.1/userguide/toolchains.html#sub:download_repositories).; ```; It seems related to how we specify the toolchain, https://github.com/qupath/qupath/blob/1368912885c1a191beaea32c28d85a3707f657f8/qupath-app/build.gradle#L535-L548; Maybe, we could follow this: https://github.com/Project-MONAI/MONAILabel/blob/0332f42643015046055a3410b770d1e8a0e1bd57/plugins/qupath/build.gradle#L39-L51; Just add a project property `toolchain` wit",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1262
https://github.com/qupath/qupath/issues/1262:2070,Usability,simpl,simply,2070,"ps to reproduce the behavior:; ```bash; cd qupath-0.4.3; gradle clean jpackage -Porg.gradle.java.home=/usr/lib/jvm/default; ```. **Expected behavior**; success to build qupath 0.4.3. **Screenshots**; If applicable, add screenshots to help explain your problem. **Desktop (please complete the following information):**; - OS: ArchLinux; - QuPath Version: 0.4.3; - java: jdk-openjdk 20.0.1.u9-3; - gradle: 8.1.1. **Additional context**; logs:; ```text; > Configure project :qupath-app; Unable to determine Java version from toolchain: No matching toolchains found for requested specification: {languageVersion=17, vendor=any, implementation=vendor-specific}.; Unable to determine Java version from toolchain: No matching toolchains found for requested specification: {languageVersion=17, vendor=any, implementation=vendor-specific}. FAILURE: Build failed with an exception. * Where:; Build file '/build/qupath/src/qupath-0.4.3/qupath-app/build.gradle' line: 540. * What went wrong:; A problem occurred configuring project ':qupath-app'.; > Failed to calculate the value of task ':qupath-app:compileJava' property 'javaCompiler'.; > No matching toolchains found for requested specification: {languageVersion=17, vendor=any, implementation=vendor-specific}.; > No locally installed toolchains match (see https://docs.gradle.org/8.1.1/userguide/toolchains.html#sec:auto_detection) and toolchain download repositories have not been configured (see https://docs.gradle.org/8.1.1/userguide/toolchains.html#sub:download_repositories).; ```; It seems related to how we specify the toolchain, https://github.com/qupath/qupath/blob/1368912885c1a191beaea32c28d85a3707f657f8/qupath-app/build.gradle#L535-L548; Maybe, we could follow this: https://github.com/Project-MONAI/MONAILabel/blob/0332f42643015046055a3410b770d1e8a0e1bd57/plugins/qupath/build.gradle#L39-L51; Just add a project property `toolchain` with a default value, so user could specify it with `-Ptoolchain=20` or simply use the default one (eg. 17).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1262
https://github.com/qupath/qupath/issues/1263:588,Testability,Test,Tested,588,"## Bug report. **Describe the bug**; As discussed [here](https://forum.image.sc/t/inconvenient-behavior-with-some-czi-preview-images/80343), when opening czi images via the image tab -> ""series 1 (label image)"" with v3.5 or later axioscan software the boundaries of the label image are not contained resulting in a very large label image out with the size of the screen. . **To Reproduce**; See above. **Expected behavior**; The label image displays but at a window size smaller than the size of the screen. **Screenshots**; N/A. **Desktop (please complete the following information):**; Tested on Windows, tbc if on mac/linux. **Additional context**",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1263
https://github.com/qupath/qupath/issues/1264:37,Availability,Error,Error,37,"## Bug report. **Describe the bug**; Error produced when groovy script is converted to JSON. **To Reproduce**; Steps to reproduce the behavior:; 1. Open specific groovy script in qupath; 2. Change the script to JSON via Language dropdown; 3. Will produce an error. . **Expected behavior**; No error, script changes to JSON . **Screenshots**. **Desktop (please complete the following information):**; Confirmed on Windows and Mac, both v0.4.3 QuPath . **Additional context**; See txt for error output. Original groovy script being kept private. ; [groovy to json script error.txt](https://github.com/qupath/qupath/files/11381297/groovy.to.json.script.error.txt)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1264
https://github.com/qupath/qupath/issues/1264:258,Availability,error,error,258,"## Bug report. **Describe the bug**; Error produced when groovy script is converted to JSON. **To Reproduce**; Steps to reproduce the behavior:; 1. Open specific groovy script in qupath; 2. Change the script to JSON via Language dropdown; 3. Will produce an error. . **Expected behavior**; No error, script changes to JSON . **Screenshots**. **Desktop (please complete the following information):**; Confirmed on Windows and Mac, both v0.4.3 QuPath . **Additional context**; See txt for error output. Original groovy script being kept private. ; [groovy to json script error.txt](https://github.com/qupath/qupath/files/11381297/groovy.to.json.script.error.txt)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1264
https://github.com/qupath/qupath/issues/1264:293,Availability,error,error,293,"## Bug report. **Describe the bug**; Error produced when groovy script is converted to JSON. **To Reproduce**; Steps to reproduce the behavior:; 1. Open specific groovy script in qupath; 2. Change the script to JSON via Language dropdown; 3. Will produce an error. . **Expected behavior**; No error, script changes to JSON . **Screenshots**. **Desktop (please complete the following information):**; Confirmed on Windows and Mac, both v0.4.3 QuPath . **Additional context**; See txt for error output. Original groovy script being kept private. ; [groovy to json script error.txt](https://github.com/qupath/qupath/files/11381297/groovy.to.json.script.error.txt)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1264
https://github.com/qupath/qupath/issues/1264:487,Availability,error,error,487,"## Bug report. **Describe the bug**; Error produced when groovy script is converted to JSON. **To Reproduce**; Steps to reproduce the behavior:; 1. Open specific groovy script in qupath; 2. Change the script to JSON via Language dropdown; 3. Will produce an error. . **Expected behavior**; No error, script changes to JSON . **Screenshots**. **Desktop (please complete the following information):**; Confirmed on Windows and Mac, both v0.4.3 QuPath . **Additional context**; See txt for error output. Original groovy script being kept private. ; [groovy to json script error.txt](https://github.com/qupath/qupath/files/11381297/groovy.to.json.script.error.txt)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1264
https://github.com/qupath/qupath/issues/1264:569,Availability,error,error,569,"## Bug report. **Describe the bug**; Error produced when groovy script is converted to JSON. **To Reproduce**; Steps to reproduce the behavior:; 1. Open specific groovy script in qupath; 2. Change the script to JSON via Language dropdown; 3. Will produce an error. . **Expected behavior**; No error, script changes to JSON . **Screenshots**. **Desktop (please complete the following information):**; Confirmed on Windows and Mac, both v0.4.3 QuPath . **Additional context**; See txt for error output. Original groovy script being kept private. ; [groovy to json script error.txt](https://github.com/qupath/qupath/files/11381297/groovy.to.json.script.error.txt)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1264
https://github.com/qupath/qupath/issues/1264:650,Availability,error,error,650,"## Bug report. **Describe the bug**; Error produced when groovy script is converted to JSON. **To Reproduce**; Steps to reproduce the behavior:; 1. Open specific groovy script in qupath; 2. Change the script to JSON via Language dropdown; 3. Will produce an error. . **Expected behavior**; No error, script changes to JSON . **Screenshots**. **Desktop (please complete the following information):**; Confirmed on Windows and Mac, both v0.4.3 QuPath . **Additional context**; See txt for error output. Original groovy script being kept private. ; [groovy to json script error.txt](https://github.com/qupath/qupath/files/11381297/groovy.to.json.script.error.txt)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1264
https://github.com/qupath/qupath/issues/1265:311,Availability,error,error-with-large-images,311,"## Bug report. **Describe the bug**; Sometimes processing using a Bio-Formats image fails with; ```java; Reader is null - was the image already closed?; ```; Alas, the image is not closed - or at least shouldn't be. **To Reproduce**; So far I can't... but see https://forum.image.sc/t/qupath-stardist-extension-error-with-large-images/80221. **Expected behavior**; Not this. But depends upon the underlying problem - which might still be a corrupt file. **Desktop (please complete the following information):**; - OS: Windows (probably all); - QuPath Version: v0.4.3; ; **Additional context**; This line is probably at least partially responsible:. https://github.com/qupath/qupath/blob/v0.4.3/qupath-extension-bioformats/src/main/java/qupath/lib/images/servers/bioformats/BioFormatsImageServer.java#L1280. I suspect when I wrote it I believe an `InterruptedException` would be thrown after 60 seconds, but really it just returns null. So we should resort to the logic from the `catch` in that case. Nevertheless, 60 seconds without any reader becoming available is still an unexpectedly long time - which suggests perhaps something somewhere has got stuck.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1265
https://github.com/qupath/qupath/issues/1265:1053,Availability,avail,available,1053,"## Bug report. **Describe the bug**; Sometimes processing using a Bio-Formats image fails with; ```java; Reader is null - was the image already closed?; ```; Alas, the image is not closed - or at least shouldn't be. **To Reproduce**; So far I can't... but see https://forum.image.sc/t/qupath-stardist-extension-error-with-large-images/80221. **Expected behavior**; Not this. But depends upon the underlying problem - which might still be a corrupt file. **Desktop (please complete the following information):**; - OS: Windows (probably all); - QuPath Version: v0.4.3; ; **Additional context**; This line is probably at least partially responsible:. https://github.com/qupath/qupath/blob/v0.4.3/qupath-extension-bioformats/src/main/java/qupath/lib/images/servers/bioformats/BioFormatsImageServer.java#L1280. I suspect when I wrote it I believe an `InterruptedException` would be thrown after 60 seconds, but really it just returns null. So we should resort to the logic from the `catch` in that case. Nevertheless, 60 seconds without any reader becoming available is still an unexpectedly long time - which suggests perhaps something somewhere has got stuck.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1265
https://github.com/qupath/qupath/issues/1265:379,Integrability,depend,depends,379,"## Bug report. **Describe the bug**; Sometimes processing using a Bio-Formats image fails with; ```java; Reader is null - was the image already closed?; ```; Alas, the image is not closed - or at least shouldn't be. **To Reproduce**; So far I can't... but see https://forum.image.sc/t/qupath-stardist-extension-error-with-large-images/80221. **Expected behavior**; Not this. But depends upon the underlying problem - which might still be a corrupt file. **Desktop (please complete the following information):**; - OS: Windows (probably all); - QuPath Version: v0.4.3; ; **Additional context**; This line is probably at least partially responsible:. https://github.com/qupath/qupath/blob/v0.4.3/qupath-extension-bioformats/src/main/java/qupath/lib/images/servers/bioformats/BioFormatsImageServer.java#L1280. I suspect when I wrote it I believe an `InterruptedException` would be thrown after 60 seconds, but really it just returns null. So we should resort to the logic from the `catch` in that case. Nevertheless, 60 seconds without any reader becoming available is still an unexpectedly long time - which suggests perhaps something somewhere has got stuck.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1265
https://github.com/qupath/qupath/issues/1265:963,Testability,log,logic,963,"## Bug report. **Describe the bug**; Sometimes processing using a Bio-Formats image fails with; ```java; Reader is null - was the image already closed?; ```; Alas, the image is not closed - or at least shouldn't be. **To Reproduce**; So far I can't... but see https://forum.image.sc/t/qupath-stardist-extension-error-with-large-images/80221. **Expected behavior**; Not this. But depends upon the underlying problem - which might still be a corrupt file. **Desktop (please complete the following information):**; - OS: Windows (probably all); - QuPath Version: v0.4.3; ; **Additional context**; This line is probably at least partially responsible:. https://github.com/qupath/qupath/blob/v0.4.3/qupath-extension-bioformats/src/main/java/qupath/lib/images/servers/bioformats/BioFormatsImageServer.java#L1280. I suspect when I wrote it I believe an `InterruptedException` would be thrown after 60 seconds, but really it just returns null. So we should resort to the logic from the `catch` in that case. Nevertheless, 60 seconds without any reader becoming available is still an unexpectedly long time - which suggests perhaps something somewhere has got stuck.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1265
https://github.com/qupath/qupath/pull/1266:77,Integrability,depend,depend,77,"Refactoring to extra some recent code into a `qupath-fx` module that doesn't depend upon the rest of QuPath. The end goal is to extract or rewrite generally-useful parts of the (recent) codebase into one or more separate modules for improved maintainability and reuse. Ultimately, as long as these don't rely on external or pre-2017 code, then they could potentially be more permissively licensed. The new module should follow the JPMS - although currently that breaks the attempt to generate merged javadocs. Consequently, it should either end up in its own repo, or the rest of QuPath's code should be modularized (or probably both).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1266
https://github.com/qupath/qupath/pull/1266:0,Modifiability,Refactor,Refactoring,0,"Refactoring to extra some recent code into a `qupath-fx` module that doesn't depend upon the rest of QuPath. The end goal is to extract or rewrite generally-useful parts of the (recent) codebase into one or more separate modules for improved maintainability and reuse. Ultimately, as long as these don't rely on external or pre-2017 code, then they could potentially be more permissively licensed. The new module should follow the JPMS - although currently that breaks the attempt to generate merged javadocs. Consequently, it should either end up in its own repo, or the rest of QuPath's code should be modularized (or probably both).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1266
https://github.com/qupath/qupath/pull/1266:139,Modifiability,rewrite,rewrite,139,"Refactoring to extra some recent code into a `qupath-fx` module that doesn't depend upon the rest of QuPath. The end goal is to extract or rewrite generally-useful parts of the (recent) codebase into one or more separate modules for improved maintainability and reuse. Ultimately, as long as these don't rely on external or pre-2017 code, then they could potentially be more permissively licensed. The new module should follow the JPMS - although currently that breaks the attempt to generate merged javadocs. Consequently, it should either end up in its own repo, or the rest of QuPath's code should be modularized (or probably both).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1266
https://github.com/qupath/qupath/pull/1266:242,Modifiability,maintainab,maintainability,242,"Refactoring to extra some recent code into a `qupath-fx` module that doesn't depend upon the rest of QuPath. The end goal is to extract or rewrite generally-useful parts of the (recent) codebase into one or more separate modules for improved maintainability and reuse. Ultimately, as long as these don't rely on external or pre-2017 code, then they could potentially be more permissively licensed. The new module should follow the JPMS - although currently that breaks the attempt to generate merged javadocs. Consequently, it should either end up in its own repo, or the rest of QuPath's code should be modularized (or probably both).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1266
https://github.com/qupath/qupath/issues/1267:592,Availability,down,downsample,592,"## Bug report. **Describe the bug**; Exporting annotations across multiple z-slices can fail, in that annotations are drawn on more slices than they should. **To Reproduce**; Steps to reproduce the behavior:; 1. Create a QuPath project containing the ImageJ sample image 'Confocal Series' (accessed via *File &rarr; Open Samples*; 2. Import the attached .geojson file (rename .txt to .geojson) - can import via drag & drop; * [confocal-series-small.txt](https://github.com/qupath/qupath/files/11531594/confocal-series-small.txt) ; 4. Attempt export using the script below:. ```groovy; double downsample = 1.0. def imageData = getCurrentImageData(). def labelServer = new LabeledImageServer.Builder(imageData); .downsample(downsample) // Choose server resolution; this should match the resolution at which tiles are exported; .useInstanceLabels(); .useAnnotations(); .multichannelOutput(false) // If true, each label refers to the channel of a multichannel binary image (required for multiclass probability); .build(). def path = buildFilePath(PROJECT_BASE_DIR, ""labels.tif""); writeImage(labelServer, path); ```. **Expected behavior**; A TIFF stack is written that contains 3 annotations on different z-slices. **Screenshots**; All 3 annotations are included on slices where only one should appear. <img width=""410"" alt=""Screenshot 2023-05-22 at 14 39 46"" src=""https://github.com/qupath/qupath/assets/4690904/e5a8bd59-e49f-4af2-9202-3bf704df6e1a"">. **Desktop (please complete the following information):**; - OS: macOS (probably all); - QuPath Version: 0.4.3. **Additional context**; Problem first noticed when replying to https://forum.image.sc/t/exporting-annotations-for-all-z-stack/81393/3",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1267
https://github.com/qupath/qupath/issues/1267:711,Availability,down,downsample,711,"## Bug report. **Describe the bug**; Exporting annotations across multiple z-slices can fail, in that annotations are drawn on more slices than they should. **To Reproduce**; Steps to reproduce the behavior:; 1. Create a QuPath project containing the ImageJ sample image 'Confocal Series' (accessed via *File &rarr; Open Samples*; 2. Import the attached .geojson file (rename .txt to .geojson) - can import via drag & drop; * [confocal-series-small.txt](https://github.com/qupath/qupath/files/11531594/confocal-series-small.txt) ; 4. Attempt export using the script below:. ```groovy; double downsample = 1.0. def imageData = getCurrentImageData(). def labelServer = new LabeledImageServer.Builder(imageData); .downsample(downsample) // Choose server resolution; this should match the resolution at which tiles are exported; .useInstanceLabels(); .useAnnotations(); .multichannelOutput(false) // If true, each label refers to the channel of a multichannel binary image (required for multiclass probability); .build(). def path = buildFilePath(PROJECT_BASE_DIR, ""labels.tif""); writeImage(labelServer, path); ```. **Expected behavior**; A TIFF stack is written that contains 3 annotations on different z-slices. **Screenshots**; All 3 annotations are included on slices where only one should appear. <img width=""410"" alt=""Screenshot 2023-05-22 at 14 39 46"" src=""https://github.com/qupath/qupath/assets/4690904/e5a8bd59-e49f-4af2-9202-3bf704df6e1a"">. **Desktop (please complete the following information):**; - OS: macOS (probably all); - QuPath Version: 0.4.3. **Additional context**; Problem first noticed when replying to https://forum.image.sc/t/exporting-annotations-for-all-z-stack/81393/3",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1267
https://github.com/qupath/qupath/issues/1267:722,Availability,down,downsample,722,"## Bug report. **Describe the bug**; Exporting annotations across multiple z-slices can fail, in that annotations are drawn on more slices than they should. **To Reproduce**; Steps to reproduce the behavior:; 1. Create a QuPath project containing the ImageJ sample image 'Confocal Series' (accessed via *File &rarr; Open Samples*; 2. Import the attached .geojson file (rename .txt to .geojson) - can import via drag & drop; * [confocal-series-small.txt](https://github.com/qupath/qupath/files/11531594/confocal-series-small.txt) ; 4. Attempt export using the script below:. ```groovy; double downsample = 1.0. def imageData = getCurrentImageData(). def labelServer = new LabeledImageServer.Builder(imageData); .downsample(downsample) // Choose server resolution; this should match the resolution at which tiles are exported; .useInstanceLabels(); .useAnnotations(); .multichannelOutput(false) // If true, each label refers to the channel of a multichannel binary image (required for multiclass probability); .build(). def path = buildFilePath(PROJECT_BASE_DIR, ""labels.tif""); writeImage(labelServer, path); ```. **Expected behavior**; A TIFF stack is written that contains 3 annotations on different z-slices. **Screenshots**; All 3 annotations are included on slices where only one should appear. <img width=""410"" alt=""Screenshot 2023-05-22 at 14 39 46"" src=""https://github.com/qupath/qupath/assets/4690904/e5a8bd59-e49f-4af2-9202-3bf704df6e1a"">. **Desktop (please complete the following information):**; - OS: macOS (probably all); - QuPath Version: 0.4.3. **Additional context**; Problem first noticed when replying to https://forum.image.sc/t/exporting-annotations-for-all-z-stack/81393/3",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1267
https://github.com/qupath/qupath/issues/1267:290,Security,access,accessed,290,"## Bug report. **Describe the bug**; Exporting annotations across multiple z-slices can fail, in that annotations are drawn on more slices than they should. **To Reproduce**; Steps to reproduce the behavior:; 1. Create a QuPath project containing the ImageJ sample image 'Confocal Series' (accessed via *File &rarr; Open Samples*; 2. Import the attached .geojson file (rename .txt to .geojson) - can import via drag & drop; * [confocal-series-small.txt](https://github.com/qupath/qupath/files/11531594/confocal-series-small.txt) ; 4. Attempt export using the script below:. ```groovy; double downsample = 1.0. def imageData = getCurrentImageData(). def labelServer = new LabeledImageServer.Builder(imageData); .downsample(downsample) // Choose server resolution; this should match the resolution at which tiles are exported; .useInstanceLabels(); .useAnnotations(); .multichannelOutput(false) // If true, each label refers to the channel of a multichannel binary image (required for multiclass probability); .build(). def path = buildFilePath(PROJECT_BASE_DIR, ""labels.tif""); writeImage(labelServer, path); ```. **Expected behavior**; A TIFF stack is written that contains 3 annotations on different z-slices. **Screenshots**; All 3 annotations are included on slices where only one should appear. <img width=""410"" alt=""Screenshot 2023-05-22 at 14 39 46"" src=""https://github.com/qupath/qupath/assets/4690904/e5a8bd59-e49f-4af2-9202-3bf704df6e1a"">. **Desktop (please complete the following information):**; - OS: macOS (probably all); - QuPath Version: 0.4.3. **Additional context**; Problem first noticed when replying to https://forum.image.sc/t/exporting-annotations-for-all-z-stack/81393/3",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1267
https://github.com/qupath/qupath/issues/1268:225,Availability,error,error,225,"I am unable to open a project file that was last opened two days ago (5/23/2023). The file is not visible in the folder it has been saved to, but the backup is still there. I tried opening it via recent programs but I get an error message (see below). I also tried copying the backup and changing the name to make it a regular project file, but it only has the blank LIF files and not the annotations and classifications that I have applied for analysis. Is there any way I would be able to retrieve the original file? I haven't had any issues with it until now and redoing the analysis would be a huge inconvenience.; ![Screenshot (1)](https://github.com/qupath/qupath/assets/134634667/d6facfc3-79c7-4d43-9eff-f331d11b4631). Thank you in advance.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1268
https://github.com/qupath/qupath/issues/1268:231,Integrability,message,message,231,"I am unable to open a project file that was last opened two days ago (5/23/2023). The file is not visible in the folder it has been saved to, but the backup is still there. I tried opening it via recent programs but I get an error message (see below). I also tried copying the backup and changing the name to make it a regular project file, but it only has the blank LIF files and not the annotations and classifications that I have applied for analysis. Is there any way I would be able to retrieve the original file? I haven't had any issues with it until now and redoing the analysis would be a huge inconvenience.; ![Screenshot (1)](https://github.com/qupath/qupath/assets/134634667/d6facfc3-79c7-4d43-9eff-f331d11b4631). Thank you in advance.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1268
https://github.com/qupath/qupath/issues/1269:119,Safety,detect,detection,119,"Dear qupath author,; i met a problem in qp v0.4 software as below:; In youtube web ur vedio shows the function ""create detection classifier"", ; <img width=""579"" alt=""9489b4d45da04b74f3c20854bf2d9d4"" src=""https://github.com/qupath/qupath/assets/70978097/eb076397-4e1c-4581-9fec-3bbaf99cb945"">; but i CANNOT find it in my qu-path V0.4.; ![35e753143f4f4812de29d22fa32c218](https://github.com/qupath/qupath/assets/70978097/4f749806-deb0-4f68-a75b-9b0ee0325905); How can i fix it?",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1269
https://github.com/qupath/qupath/pull/1270:675,Deployability,update,updated,675,"Summary of changes in this PR (and recent ones):; * Add checkbox to the top of the 'Show' column to show/hide all; * Replace color rectangles with minimal color pickers (that look the same, but respond to clicks); * Automatically bring text field into focus when double-clicking to set a channel name; * Rename columns; * Reorder the lower controls; * Support regular expressions in the channel name filter for advanced filtering (optional). Before (left) and after (right). <img width=""200"" alt=""Brightness:Contrast before changes"" src=""https://github.com/qupath/qupath/assets/4690904/dd6ead11-38f0-44fa-97e3-2c6dd96bdef2"">. <img width=""200"" alt=""Brightness:Contrast dialog updated"" src=""https://github.com/qupath/qupath/assets/4690904/fe8ac8b8-4ec3-46cc-a708-4d7a11c2d864"">",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1270
https://github.com/qupath/qupath/issues/1272:1099,Availability,down,downsample,1099,"## Feature request. **Is your feature request related to a problem? Please describe.**; At the moment, SVG exports [1] behave differently from their bitmap counterparts [2], in the sense that the bitmap exports include whichever overlays are currently displayed, but the SVG exports only include the original image. [1] File -> Export images -> Rendered SVG and File -> Export snapshot -> Current viewer content (SVG); [2] File -> Export images -> Rendered RGB (with overlays), File -> Export snapshot -> Main window content and File -> Export snapshot -> Current viewer content. **Describe the solution you'd like**; I would *both* types of exports to include overlays if the user so wishes. See the discussion on https://forum.image.sc/t/export-snapshot-current-view-content-svg-does-not-include-the-density-map/82740. **Describe alternatives you've considered**; I have a two-step workaround in the meantime:; 1. Export images -> Rendered SVG (Linked raster); 2. Hide the annotations and detections, then Export images -> Rendered RGB to overwrite the linked raster image, using PNG and the same downsample as used in step 1. **Additional context**; SVG is a great format. The files can be edited in [Inkscape](https://inkscape.org/) and also be used as-is in (recent versions of) Microsoft Office Word and Powerpoint. And they look great when printed, which is why I think it's important for QuPath to have the best possible SVG export functions.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272
https://github.com/qupath/qupath/issues/1272:1310,Energy Efficiency,Power,Powerpoint,1310,"## Feature request. **Is your feature request related to a problem? Please describe.**; At the moment, SVG exports [1] behave differently from their bitmap counterparts [2], in the sense that the bitmap exports include whichever overlays are currently displayed, but the SVG exports only include the original image. [1] File -> Export images -> Rendered SVG and File -> Export snapshot -> Current viewer content (SVG); [2] File -> Export images -> Rendered RGB (with overlays), File -> Export snapshot -> Main window content and File -> Export snapshot -> Current viewer content. **Describe the solution you'd like**; I would *both* types of exports to include overlays if the user so wishes. See the discussion on https://forum.image.sc/t/export-snapshot-current-view-content-svg-does-not-include-the-density-map/82740. **Describe alternatives you've considered**; I have a two-step workaround in the meantime:; 1. Export images -> Rendered SVG (Linked raster); 2. Hide the annotations and detections, then Export images -> Rendered RGB to overwrite the linked raster image, using PNG and the same downsample as used in step 1. **Additional context**; SVG is a great format. The files can be edited in [Inkscape](https://inkscape.org/) and also be used as-is in (recent versions of) Microsoft Office Word and Powerpoint. And they look great when printed, which is why I think it's important for QuPath to have the best possible SVG export functions.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272
https://github.com/qupath/qupath/issues/1272:991,Safety,detect,detections,991,"## Feature request. **Is your feature request related to a problem? Please describe.**; At the moment, SVG exports [1] behave differently from their bitmap counterparts [2], in the sense that the bitmap exports include whichever overlays are currently displayed, but the SVG exports only include the original image. [1] File -> Export images -> Rendered SVG and File -> Export snapshot -> Current viewer content (SVG); [2] File -> Export images -> Rendered RGB (with overlays), File -> Export snapshot -> Main window content and File -> Export snapshot -> Current viewer content. **Describe the solution you'd like**; I would *both* types of exports to include overlays if the user so wishes. See the discussion on https://forum.image.sc/t/export-snapshot-current-view-content-svg-does-not-include-the-density-map/82740. **Describe alternatives you've considered**; I have a two-step workaround in the meantime:; 1. Export images -> Rendered SVG (Linked raster); 2. Hide the annotations and detections, then Export images -> Rendered RGB to overwrite the linked raster image, using PNG and the same downsample as used in step 1. **Additional context**; SVG is a great format. The files can be edited in [Inkscape](https://inkscape.org/) and also be used as-is in (recent versions of) Microsoft Office Word and Powerpoint. And they look great when printed, which is why I think it's important for QuPath to have the best possible SVG export functions.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272
https://github.com/qupath/qupath/pull/1274:84,Deployability,release,release,84,"Merging recent changes into `main`, as the first step towards v0.5.0 being the next release. Currently should be considered *very* unstable. Some of the main changes:; * Major refactoring (still ongoing); * Main aim is to shorten & simplify code (e.g. `QuPathGUI` now half the size); * Extract JavaFX controls that don't depend upon QuPath to a separate module; * Externalize many strings (for localization); * Improve Brightness/Contrast dialog; * Improve SVG export; * Support `-Dnoextensions` system property; * Require Java 17 as minimum version; * Many dependency updates",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1274
https://github.com/qupath/qupath/pull/1274:569,Deployability,update,updates,569,"Merging recent changes into `main`, as the first step towards v0.5.0 being the next release. Currently should be considered *very* unstable. Some of the main changes:; * Major refactoring (still ongoing); * Main aim is to shorten & simplify code (e.g. `QuPathGUI` now half the size); * Extract JavaFX controls that don't depend upon QuPath to a separate module; * Externalize many strings (for localization); * Improve Brightness/Contrast dialog; * Improve SVG export; * Support `-Dnoextensions` system property; * Require Java 17 as minimum version; * Many dependency updates",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1274
https://github.com/qupath/qupath/pull/1274:321,Integrability,depend,depend,321,"Merging recent changes into `main`, as the first step towards v0.5.0 being the next release. Currently should be considered *very* unstable. Some of the main changes:; * Major refactoring (still ongoing); * Main aim is to shorten & simplify code (e.g. `QuPathGUI` now half the size); * Extract JavaFX controls that don't depend upon QuPath to a separate module; * Externalize many strings (for localization); * Improve Brightness/Contrast dialog; * Improve SVG export; * Support `-Dnoextensions` system property; * Require Java 17 as minimum version; * Many dependency updates",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1274
https://github.com/qupath/qupath/pull/1274:558,Integrability,depend,dependency,558,"Merging recent changes into `main`, as the first step towards v0.5.0 being the next release. Currently should be considered *very* unstable. Some of the main changes:; * Major refactoring (still ongoing); * Main aim is to shorten & simplify code (e.g. `QuPathGUI` now half the size); * Extract JavaFX controls that don't depend upon QuPath to a separate module; * Externalize many strings (for localization); * Improve Brightness/Contrast dialog; * Improve SVG export; * Support `-Dnoextensions` system property; * Require Java 17 as minimum version; * Many dependency updates",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1274
https://github.com/qupath/qupath/pull/1274:176,Modifiability,refactor,refactoring,176,"Merging recent changes into `main`, as the first step towards v0.5.0 being the next release. Currently should be considered *very* unstable. Some of the main changes:; * Major refactoring (still ongoing); * Main aim is to shorten & simplify code (e.g. `QuPathGUI` now half the size); * Extract JavaFX controls that don't depend upon QuPath to a separate module; * Externalize many strings (for localization); * Improve Brightness/Contrast dialog; * Improve SVG export; * Support `-Dnoextensions` system property; * Require Java 17 as minimum version; * Many dependency updates",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1274
https://github.com/qupath/qupath/pull/1274:232,Usability,simpl,simplify,232,"Merging recent changes into `main`, as the first step towards v0.5.0 being the next release. Currently should be considered *very* unstable. Some of the main changes:; * Major refactoring (still ongoing); * Main aim is to shorten & simplify code (e.g. `QuPathGUI` now half the size); * Extract JavaFX controls that don't depend upon QuPath to a separate module; * Externalize many strings (for localization); * Improve Brightness/Contrast dialog; * Improve SVG export; * Support `-Dnoextensions` system property; * Require Java 17 as minimum version; * Many dependency updates",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1274
https://github.com/qupath/qupath/pull/1275:390,Testability,test,test,390,"`GeneralTools.getNameWithoutExtension(String)` returns the whole string without the extension for absolute path, while; `GeneralTools.getNameWithoutExtension(File)` returns only the file name part without the extension. eg: `/home/demo/myfile.tif`, the former method returns `/home/demo/myfile` while the latter one returns `myfile`. This commit make them return `myfile` for consistent. A test is also added.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1275
https://github.com/qupath/qupath/issues/1278:1037,Availability,failure,failure,1037,"## Feature request. **Is your feature request related to a problem? Please describe.**; OpenSlide supports `bounds` which are [used to crop the image](https://forum.image.sc/t/roi-annotation-to-openslide-coordinates/44475/3). Annotation exports (and possibly other exports) then have basically invalid coordinates to the image data, unless one's using OpenSlide's bounds. . **Describe the solution you'd like**; Exports should be wrt. the original image dimensions, so that other SW can work with the data without OpenSlide dependency.; Export should by default use absolute coordinates, and offer relative ones only as an option. Or, the offset information should be exported along with annotations. **Describe alternatives you've considered**; Manual management of metadata for each slide. Clumsy, chaotic and inflexible. **Additional context**; IMHO this is more a bug report than a feature request. We are dependent on some software (or worse, its version) to be able to work with the data. Any change to the OpenSlide, the library, failure to derive these coordinates etc. breaks everything.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278
https://github.com/qupath/qupath/issues/1278:524,Integrability,depend,dependency,524,"## Feature request. **Is your feature request related to a problem? Please describe.**; OpenSlide supports `bounds` which are [used to crop the image](https://forum.image.sc/t/roi-annotation-to-openslide-coordinates/44475/3). Annotation exports (and possibly other exports) then have basically invalid coordinates to the image data, unless one's using OpenSlide's bounds. . **Describe the solution you'd like**; Exports should be wrt. the original image dimensions, so that other SW can work with the data without OpenSlide dependency.; Export should by default use absolute coordinates, and offer relative ones only as an option. Or, the offset information should be exported along with annotations. **Describe alternatives you've considered**; Manual management of metadata for each slide. Clumsy, chaotic and inflexible. **Additional context**; IMHO this is more a bug report than a feature request. We are dependent on some software (or worse, its version) to be able to work with the data. Any change to the OpenSlide, the library, failure to derive these coordinates etc. breaks everything.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278
https://github.com/qupath/qupath/issues/1278:910,Integrability,depend,dependent,910,"## Feature request. **Is your feature request related to a problem? Please describe.**; OpenSlide supports `bounds` which are [used to crop the image](https://forum.image.sc/t/roi-annotation-to-openslide-coordinates/44475/3). Annotation exports (and possibly other exports) then have basically invalid coordinates to the image data, unless one's using OpenSlide's bounds. . **Describe the solution you'd like**; Exports should be wrt. the original image dimensions, so that other SW can work with the data without OpenSlide dependency.; Export should by default use absolute coordinates, and offer relative ones only as an option. Or, the offset information should be exported along with annotations. **Describe alternatives you've considered**; Manual management of metadata for each slide. Clumsy, chaotic and inflexible. **Additional context**; IMHO this is more a bug report than a feature request. We are dependent on some software (or worse, its version) to be able to work with the data. Any change to the OpenSlide, the library, failure to derive these coordinates etc. breaks everything.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278
https://github.com/qupath/qupath/issues/1281:220,Availability,down,downloading,220,"I recently updated to MacOS 13.5 (Ventura), on my desktop mini (M1 processor).; Now my QuPath program doesn't work at all.; I get a message saying ""This file is corrupted and should be moved to the trash""; I've tried re-downloading QuPath, as well as re-downloading the OS to no avail.; Any advice?",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1281
https://github.com/qupath/qupath/issues/1281:254,Availability,down,downloading,254,"I recently updated to MacOS 13.5 (Ventura), on my desktop mini (M1 processor).; Now my QuPath program doesn't work at all.; I get a message saying ""This file is corrupted and should be moved to the trash""; I've tried re-downloading QuPath, as well as re-downloading the OS to no avail.; Any advice?",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1281
https://github.com/qupath/qupath/issues/1281:279,Availability,avail,avail,279,"I recently updated to MacOS 13.5 (Ventura), on my desktop mini (M1 processor).; Now my QuPath program doesn't work at all.; I get a message saying ""This file is corrupted and should be moved to the trash""; I've tried re-downloading QuPath, as well as re-downloading the OS to no avail.; Any advice?",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1281
https://github.com/qupath/qupath/issues/1281:11,Deployability,update,updated,11,"I recently updated to MacOS 13.5 (Ventura), on my desktop mini (M1 processor).; Now my QuPath program doesn't work at all.; I get a message saying ""This file is corrupted and should be moved to the trash""; I've tried re-downloading QuPath, as well as re-downloading the OS to no avail.; Any advice?",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1281
https://github.com/qupath/qupath/issues/1281:132,Integrability,message,message,132,"I recently updated to MacOS 13.5 (Ventura), on my desktop mini (M1 processor).; Now my QuPath program doesn't work at all.; I get a message saying ""This file is corrupted and should be moved to the trash""; I've tried re-downloading QuPath, as well as re-downloading the OS to no avail.; Any advice?",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1281
https://github.com/qupath/qupath/issues/1283:127,Availability,Down,Download,127,"## Bug report. **Describe the bug**; Incorrect name and tooltip is displayed for setting the maximum memory. **To Reproduce**; Download and build the most recent code from the GitHub repository, open the preference pane. Under ""General"" you will find incorrect name for setting the maximum memory for Java.; ![Capture-1](https://github.com/qupath/qupath/assets/10900214/bf3f4742-1a9b-4c6b-ac89-d90da3eaf088). **Expected behavior**; The correct name should be ""Set max memory""; ![Capture-2](https://github.com/qupath/qupath/assets/10900214/55b3cbc9-9ccc-4a7a-b40f-7a297fa29e09). **Desktop (please complete the following information):**; - OS: Windows 10; - QuPath Version: 0.5.0-SNAPSHOT",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1283
https://github.com/qupath/qupath/pull/1286:120,Usability,simpl,simple,120,"When opening a project with derived classes in QuPath 0.4.0+, it currently wrongly adds them to `existingClasses`. This simple PR aims to fix this",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1286
https://github.com/qupath/qupath/pull/1287:974,Energy Efficiency,adapt,adapt,974,"Initial refactoring of the bio-format image server to extract code that could be reused in the OMERO extension.; Basically, the bio-format image server uses a pool of readers to retrieve pixel values in parallel. This pull request extracted this behavior from the bio-format image server. 4 classes were created:; * `ReaderPool`: abstract class that can read pixel values of an image using several readers in parallel. A class extending this class must define how to fetch pixel values, but the rest is handled by `ReaderPool`.; * `BioFormatReaderPool`: implementation of `ReaderPool` with specific code to open bio-format images.; * `ReaderWrapper`: interface which is a wrapper around an image reader. It is suited for readers that return arrays of bytes when reading pixel values.; * `BioFormatReaderWrapper`: implementation of `ReaderWrapper` with specific code to open bio-format images. The `BioFormatImageServer` and `BioFormatServerBuilder` were slightly changed to adapt to the new classes. The unit tests passed with these changes. This pull request should not be merged now because I still have to address a few things:; * Where should we place the `ReaderPool` and `ReaderWrapper` classes? Currently there are in the `servers.bioformats` package, but they are not specific to bio-format.; * Should I refactor the BioFormatImageServer to use the best practises we have been discussing? I see this file has a few warnings and the constructor takes 500 lines.; * I will now try to use `ReaderPool` and `ReaderWrapper` in the OMERO extension, so I may have to change a few things if I realize that theses classes are not completely generic. I also have a question:; * When does the `getAssociatedImage(String)` function of `qupath.lib.images.servers.ImageServer` is used? I don't think I was able to test it",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287
https://github.com/qupath/qupath/pull/1287:651,Integrability,interface,interface,651,"Initial refactoring of the bio-format image server to extract code that could be reused in the OMERO extension.; Basically, the bio-format image server uses a pool of readers to retrieve pixel values in parallel. This pull request extracted this behavior from the bio-format image server. 4 classes were created:; * `ReaderPool`: abstract class that can read pixel values of an image using several readers in parallel. A class extending this class must define how to fetch pixel values, but the rest is handled by `ReaderPool`.; * `BioFormatReaderPool`: implementation of `ReaderPool` with specific code to open bio-format images.; * `ReaderWrapper`: interface which is a wrapper around an image reader. It is suited for readers that return arrays of bytes when reading pixel values.; * `BioFormatReaderWrapper`: implementation of `ReaderWrapper` with specific code to open bio-format images. The `BioFormatImageServer` and `BioFormatServerBuilder` were slightly changed to adapt to the new classes. The unit tests passed with these changes. This pull request should not be merged now because I still have to address a few things:; * Where should we place the `ReaderPool` and `ReaderWrapper` classes? Currently there are in the `servers.bioformats` package, but they are not specific to bio-format.; * Should I refactor the BioFormatImageServer to use the best practises we have been discussing? I see this file has a few warnings and the constructor takes 500 lines.; * I will now try to use `ReaderPool` and `ReaderWrapper` in the OMERO extension, so I may have to change a few things if I realize that theses classes are not completely generic. I also have a question:; * When does the `getAssociatedImage(String)` function of `qupath.lib.images.servers.ImageServer` is used? I don't think I was able to test it",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287
https://github.com/qupath/qupath/pull/1287:672,Integrability,wrap,wrapper,672,"Initial refactoring of the bio-format image server to extract code that could be reused in the OMERO extension.; Basically, the bio-format image server uses a pool of readers to retrieve pixel values in parallel. This pull request extracted this behavior from the bio-format image server. 4 classes were created:; * `ReaderPool`: abstract class that can read pixel values of an image using several readers in parallel. A class extending this class must define how to fetch pixel values, but the rest is handled by `ReaderPool`.; * `BioFormatReaderPool`: implementation of `ReaderPool` with specific code to open bio-format images.; * `ReaderWrapper`: interface which is a wrapper around an image reader. It is suited for readers that return arrays of bytes when reading pixel values.; * `BioFormatReaderWrapper`: implementation of `ReaderWrapper` with specific code to open bio-format images. The `BioFormatImageServer` and `BioFormatServerBuilder` were slightly changed to adapt to the new classes. The unit tests passed with these changes. This pull request should not be merged now because I still have to address a few things:; * Where should we place the `ReaderPool` and `ReaderWrapper` classes? Currently there are in the `servers.bioformats` package, but they are not specific to bio-format.; * Should I refactor the BioFormatImageServer to use the best practises we have been discussing? I see this file has a few warnings and the constructor takes 500 lines.; * I will now try to use `ReaderPool` and `ReaderWrapper` in the OMERO extension, so I may have to change a few things if I realize that theses classes are not completely generic. I also have a question:; * When does the `getAssociatedImage(String)` function of `qupath.lib.images.servers.ImageServer` is used? I don't think I was able to test it",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287
https://github.com/qupath/qupath/pull/1287:8,Modifiability,refactor,refactoring,8,"Initial refactoring of the bio-format image server to extract code that could be reused in the OMERO extension.; Basically, the bio-format image server uses a pool of readers to retrieve pixel values in parallel. This pull request extracted this behavior from the bio-format image server. 4 classes were created:; * `ReaderPool`: abstract class that can read pixel values of an image using several readers in parallel. A class extending this class must define how to fetch pixel values, but the rest is handled by `ReaderPool`.; * `BioFormatReaderPool`: implementation of `ReaderPool` with specific code to open bio-format images.; * `ReaderWrapper`: interface which is a wrapper around an image reader. It is suited for readers that return arrays of bytes when reading pixel values.; * `BioFormatReaderWrapper`: implementation of `ReaderWrapper` with specific code to open bio-format images. The `BioFormatImageServer` and `BioFormatServerBuilder` were slightly changed to adapt to the new classes. The unit tests passed with these changes. This pull request should not be merged now because I still have to address a few things:; * Where should we place the `ReaderPool` and `ReaderWrapper` classes? Currently there are in the `servers.bioformats` package, but they are not specific to bio-format.; * Should I refactor the BioFormatImageServer to use the best practises we have been discussing? I see this file has a few warnings and the constructor takes 500 lines.; * I will now try to use `ReaderPool` and `ReaderWrapper` in the OMERO extension, so I may have to change a few things if I realize that theses classes are not completely generic. I also have a question:; * When does the `getAssociatedImage(String)` function of `qupath.lib.images.servers.ImageServer` is used? I don't think I was able to test it",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287
https://github.com/qupath/qupath/pull/1287:427,Modifiability,extend,extending,427,"Initial refactoring of the bio-format image server to extract code that could be reused in the OMERO extension.; Basically, the bio-format image server uses a pool of readers to retrieve pixel values in parallel. This pull request extracted this behavior from the bio-format image server. 4 classes were created:; * `ReaderPool`: abstract class that can read pixel values of an image using several readers in parallel. A class extending this class must define how to fetch pixel values, but the rest is handled by `ReaderPool`.; * `BioFormatReaderPool`: implementation of `ReaderPool` with specific code to open bio-format images.; * `ReaderWrapper`: interface which is a wrapper around an image reader. It is suited for readers that return arrays of bytes when reading pixel values.; * `BioFormatReaderWrapper`: implementation of `ReaderWrapper` with specific code to open bio-format images. The `BioFormatImageServer` and `BioFormatServerBuilder` were slightly changed to adapt to the new classes. The unit tests passed with these changes. This pull request should not be merged now because I still have to address a few things:; * Where should we place the `ReaderPool` and `ReaderWrapper` classes? Currently there are in the `servers.bioformats` package, but they are not specific to bio-format.; * Should I refactor the BioFormatImageServer to use the best practises we have been discussing? I see this file has a few warnings and the constructor takes 500 lines.; * I will now try to use `ReaderPool` and `ReaderWrapper` in the OMERO extension, so I may have to change a few things if I realize that theses classes are not completely generic. I also have a question:; * When does the `getAssociatedImage(String)` function of `qupath.lib.images.servers.ImageServer` is used? I don't think I was able to test it",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287
https://github.com/qupath/qupath/pull/1287:974,Modifiability,adapt,adapt,974,"Initial refactoring of the bio-format image server to extract code that could be reused in the OMERO extension.; Basically, the bio-format image server uses a pool of readers to retrieve pixel values in parallel. This pull request extracted this behavior from the bio-format image server. 4 classes were created:; * `ReaderPool`: abstract class that can read pixel values of an image using several readers in parallel. A class extending this class must define how to fetch pixel values, but the rest is handled by `ReaderPool`.; * `BioFormatReaderPool`: implementation of `ReaderPool` with specific code to open bio-format images.; * `ReaderWrapper`: interface which is a wrapper around an image reader. It is suited for readers that return arrays of bytes when reading pixel values.; * `BioFormatReaderWrapper`: implementation of `ReaderWrapper` with specific code to open bio-format images. The `BioFormatImageServer` and `BioFormatServerBuilder` were slightly changed to adapt to the new classes. The unit tests passed with these changes. This pull request should not be merged now because I still have to address a few things:; * Where should we place the `ReaderPool` and `ReaderWrapper` classes? Currently there are in the `servers.bioformats` package, but they are not specific to bio-format.; * Should I refactor the BioFormatImageServer to use the best practises we have been discussing? I see this file has a few warnings and the constructor takes 500 lines.; * I will now try to use `ReaderPool` and `ReaderWrapper` in the OMERO extension, so I may have to change a few things if I realize that theses classes are not completely generic. I also have a question:; * When does the `getAssociatedImage(String)` function of `qupath.lib.images.servers.ImageServer` is used? I don't think I was able to test it",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287
https://github.com/qupath/qupath/pull/1287:1312,Modifiability,refactor,refactor,1312,"Initial refactoring of the bio-format image server to extract code that could be reused in the OMERO extension.; Basically, the bio-format image server uses a pool of readers to retrieve pixel values in parallel. This pull request extracted this behavior from the bio-format image server. 4 classes were created:; * `ReaderPool`: abstract class that can read pixel values of an image using several readers in parallel. A class extending this class must define how to fetch pixel values, but the rest is handled by `ReaderPool`.; * `BioFormatReaderPool`: implementation of `ReaderPool` with specific code to open bio-format images.; * `ReaderWrapper`: interface which is a wrapper around an image reader. It is suited for readers that return arrays of bytes when reading pixel values.; * `BioFormatReaderWrapper`: implementation of `ReaderWrapper` with specific code to open bio-format images. The `BioFormatImageServer` and `BioFormatServerBuilder` were slightly changed to adapt to the new classes. The unit tests passed with these changes. This pull request should not be merged now because I still have to address a few things:; * Where should we place the `ReaderPool` and `ReaderWrapper` classes? Currently there are in the `servers.bioformats` package, but they are not specific to bio-format.; * Should I refactor the BioFormatImageServer to use the best practises we have been discussing? I see this file has a few warnings and the constructor takes 500 lines.; * I will now try to use `ReaderPool` and `ReaderWrapper` in the OMERO extension, so I may have to change a few things if I realize that theses classes are not completely generic. I also have a question:; * When does the `getAssociatedImage(String)` function of `qupath.lib.images.servers.ImageServer` is used? I don't think I was able to test it",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287
https://github.com/qupath/qupath/pull/1287:1009,Testability,test,tests,1009,"Initial refactoring of the bio-format image server to extract code that could be reused in the OMERO extension.; Basically, the bio-format image server uses a pool of readers to retrieve pixel values in parallel. This pull request extracted this behavior from the bio-format image server. 4 classes were created:; * `ReaderPool`: abstract class that can read pixel values of an image using several readers in parallel. A class extending this class must define how to fetch pixel values, but the rest is handled by `ReaderPool`.; * `BioFormatReaderPool`: implementation of `ReaderPool` with specific code to open bio-format images.; * `ReaderWrapper`: interface which is a wrapper around an image reader. It is suited for readers that return arrays of bytes when reading pixel values.; * `BioFormatReaderWrapper`: implementation of `ReaderWrapper` with specific code to open bio-format images. The `BioFormatImageServer` and `BioFormatServerBuilder` were slightly changed to adapt to the new classes. The unit tests passed with these changes. This pull request should not be merged now because I still have to address a few things:; * Where should we place the `ReaderPool` and `ReaderWrapper` classes? Currently there are in the `servers.bioformats` package, but they are not specific to bio-format.; * Should I refactor the BioFormatImageServer to use the best practises we have been discussing? I see this file has a few warnings and the constructor takes 500 lines.; * I will now try to use `ReaderPool` and `ReaderWrapper` in the OMERO extension, so I may have to change a few things if I realize that theses classes are not completely generic. I also have a question:; * When does the `getAssociatedImage(String)` function of `qupath.lib.images.servers.ImageServer` is used? I don't think I was able to test it",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287
https://github.com/qupath/qupath/pull/1287:1808,Testability,test,test,1808,"Initial refactoring of the bio-format image server to extract code that could be reused in the OMERO extension.; Basically, the bio-format image server uses a pool of readers to retrieve pixel values in parallel. This pull request extracted this behavior from the bio-format image server. 4 classes were created:; * `ReaderPool`: abstract class that can read pixel values of an image using several readers in parallel. A class extending this class must define how to fetch pixel values, but the rest is handled by `ReaderPool`.; * `BioFormatReaderPool`: implementation of `ReaderPool` with specific code to open bio-format images.; * `ReaderWrapper`: interface which is a wrapper around an image reader. It is suited for readers that return arrays of bytes when reading pixel values.; * `BioFormatReaderWrapper`: implementation of `ReaderWrapper` with specific code to open bio-format images. The `BioFormatImageServer` and `BioFormatServerBuilder` were slightly changed to adapt to the new classes. The unit tests passed with these changes. This pull request should not be merged now because I still have to address a few things:; * Where should we place the `ReaderPool` and `ReaderWrapper` classes? Currently there are in the `servers.bioformats` package, but they are not specific to bio-format.; * Should I refactor the BioFormatImageServer to use the best practises we have been discussing? I see this file has a few warnings and the constructor takes 500 lines.; * I will now try to use `ReaderPool` and `ReaderWrapper` in the OMERO extension, so I may have to change a few things if I realize that theses classes are not completely generic. I also have a question:; * When does the `getAssociatedImage(String)` function of `qupath.lib.images.servers.ImageServer` is used? I don't think I was able to test it",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287
https://github.com/qupath/qupath/issues/1290:720,Availability,error,error,720,"## Bug report - 'Add intensity features' not working. I am trying to calculate the intensity feature for my image. I selected a ROI and divided it into tiles, trimming the tiles to ROI. then I select the detections (tiles) and I try to run Analyze->Calculate features->Add intensity features. I select the channel of interest and all the features (Mean, Std dev, min max and median), then I run the analysis for the selected objects (tiles). Now, quite often, it is not possible to get the measurement for all my tiles, but only for few initial tiles and then the calculation stops (which I can assess in the 'show detection measurements' table. . I am running QuPath on a macOS. . Do you know what I can do to fix this error? . ![Screenshot 2023-08-15 at 09 44 06](https://github.com/qupath/qupath/assets/142295421/d334a749-9599-4d52-bc49-6728835240a6)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1290
https://github.com/qupath/qupath/issues/1290:204,Safety,detect,detections,204,"## Bug report - 'Add intensity features' not working. I am trying to calculate the intensity feature for my image. I selected a ROI and divided it into tiles, trimming the tiles to ROI. then I select the detections (tiles) and I try to run Analyze->Calculate features->Add intensity features. I select the channel of interest and all the features (Mean, Std dev, min max and median), then I run the analysis for the selected objects (tiles). Now, quite often, it is not possible to get the measurement for all my tiles, but only for few initial tiles and then the calculation stops (which I can assess in the 'show detection measurements' table. . I am running QuPath on a macOS. . Do you know what I can do to fix this error? . ![Screenshot 2023-08-15 at 09 44 06](https://github.com/qupath/qupath/assets/142295421/d334a749-9599-4d52-bc49-6728835240a6)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1290
https://github.com/qupath/qupath/issues/1290:615,Safety,detect,detection,615,"## Bug report - 'Add intensity features' not working. I am trying to calculate the intensity feature for my image. I selected a ROI and divided it into tiles, trimming the tiles to ROI. then I select the detections (tiles) and I try to run Analyze->Calculate features->Add intensity features. I select the channel of interest and all the features (Mean, Std dev, min max and median), then I run the analysis for the selected objects (tiles). Now, quite often, it is not possible to get the measurement for all my tiles, but only for few initial tiles and then the calculation stops (which I can assess in the 'show detection measurements' table. . I am running QuPath on a macOS. . Do you know what I can do to fix this error? . ![Screenshot 2023-08-15 at 09 44 06](https://github.com/qupath/qupath/assets/142295421/d334a749-9599-4d52-bc49-6728835240a6)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1290
https://github.com/qupath/qupath/issues/1291:89,Availability,error,error,89,Full bug report at https://forum.image.sc/t/removing-images-from-qupath-project-leads-to-error/85053,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1291
https://github.com/qupath/qupath/issues/1293:215,Availability,error,error,215,"## Bug report. **Describe the bug**; QuPath can (attempt to) export GeoJSON containing NaNs, but can't then read the GeoJSON it has written itself. See https://forum.image.sc/t/qupath-object-import-via-geojson-file-error/85384 for the initial bug report. **To Reproduce**; Run the following script:. ```groovy; def json = """"""; {; ""type"": ""Feature"",; ""id"": ""d0852662-6941-4506-bc90-cbda1c2fa7b0"",; ""geometry"": {; ""type"": ""Polygon"",; ""coordinates"": [; [; [44196, 21480],; [44420, 21480],; [44420, 21687],; [44196, 21687],; [44196, 21480]; ]; ]; },; ""properties"": {; ""objectType"": ""annotation"",; ""measurements"": {; ""Anything"": NaN,; ""Anything else"": 2.0; }; }; }; """""". def po = GsonTools.getInstance().fromJson(json, PathObject); ```. The result is an exception; ```; class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader 'bootstrap') in QuPathScript at line number 27. ERROR: qupath.lib.measurements.MeasurementList.putAll(MeasurementList.java:234); qupath.lib.io.QuPathTypeAdapters$MeasurementListTypeAdapter.read(QuPathTypeAdapters.java:679); qupath.lib.io.QuPathTypeAdapters$MeasurementListTypeAdapter.read(QuPathTypeAdapters.java:634); com.google.gson.TypeAdapter.fromJsonTree(TypeAdapter.java:296); qupath.lib.io.QuPathTypeAdapters$PathObjectTypeAdapter.parseObject(QuPathTypeAdapters.java:535); qupath.lib.io.QuPathTypeAdapters$PathObjectTypeAdapter.read(QuPathTypeAdapters.java:464); qupath.lib.io.QuPathTypeAdapters$PathObjectTypeAdapter.read(QuPathTypeAdapters.java:280); com.google.gson.Gson.fromJson(Gson.java:1214); ```. **Expected behavior**; NaNs import properly... and export is also handled properly (whatever way that is). **Desktop (please complete the following information):**; - OS: All; - QuPath Version: 0.4.3 (but likely before)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1293
https://github.com/qupath/qupath/issues/1293:950,Availability,ERROR,ERROR,950,"## Bug report. **Describe the bug**; QuPath can (attempt to) export GeoJSON containing NaNs, but can't then read the GeoJSON it has written itself. See https://forum.image.sc/t/qupath-object-import-via-geojson-file-error/85384 for the initial bug report. **To Reproduce**; Run the following script:. ```groovy; def json = """"""; {; ""type"": ""Feature"",; ""id"": ""d0852662-6941-4506-bc90-cbda1c2fa7b0"",; ""geometry"": {; ""type"": ""Polygon"",; ""coordinates"": [; [; [44196, 21480],; [44420, 21480],; [44420, 21687],; [44196, 21687],; [44196, 21480]; ]; ]; },; ""properties"": {; ""objectType"": ""annotation"",; ""measurements"": {; ""Anything"": NaN,; ""Anything else"": 2.0; }; }; }; """""". def po = GsonTools.getInstance().fromJson(json, PathObject); ```. The result is an exception; ```; class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader 'bootstrap') in QuPathScript at line number 27. ERROR: qupath.lib.measurements.MeasurementList.putAll(MeasurementList.java:234); qupath.lib.io.QuPathTypeAdapters$MeasurementListTypeAdapter.read(QuPathTypeAdapters.java:679); qupath.lib.io.QuPathTypeAdapters$MeasurementListTypeAdapter.read(QuPathTypeAdapters.java:634); com.google.gson.TypeAdapter.fromJsonTree(TypeAdapter.java:296); qupath.lib.io.QuPathTypeAdapters$PathObjectTypeAdapter.parseObject(QuPathTypeAdapters.java:535); qupath.lib.io.QuPathTypeAdapters$PathObjectTypeAdapter.read(QuPathTypeAdapters.java:464); qupath.lib.io.QuPathTypeAdapters$PathObjectTypeAdapter.read(QuPathTypeAdapters.java:280); com.google.gson.Gson.fromJson(Gson.java:1214); ```. **Expected behavior**; NaNs import properly... and export is also handled properly (whatever way that is). **Desktop (please complete the following information):**; - OS: All; - QuPath Version: 0.4.3 (but likely before)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1293
https://github.com/qupath/qupath/issues/1293:895,Performance,load,loader,895,"## Bug report. **Describe the bug**; QuPath can (attempt to) export GeoJSON containing NaNs, but can't then read the GeoJSON it has written itself. See https://forum.image.sc/t/qupath-object-import-via-geojson-file-error/85384 for the initial bug report. **To Reproduce**; Run the following script:. ```groovy; def json = """"""; {; ""type"": ""Feature"",; ""id"": ""d0852662-6941-4506-bc90-cbda1c2fa7b0"",; ""geometry"": {; ""type"": ""Polygon"",; ""coordinates"": [; [; [44196, 21480],; [44420, 21480],; [44420, 21687],; [44196, 21687],; [44196, 21480]; ]; ]; },; ""properties"": {; ""objectType"": ""annotation"",; ""measurements"": {; ""Anything"": NaN,; ""Anything else"": 2.0; }; }; }; """""". def po = GsonTools.getInstance().fromJson(json, PathObject); ```. The result is an exception; ```; class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader 'bootstrap') in QuPathScript at line number 27. ERROR: qupath.lib.measurements.MeasurementList.putAll(MeasurementList.java:234); qupath.lib.io.QuPathTypeAdapters$MeasurementListTypeAdapter.read(QuPathTypeAdapters.java:679); qupath.lib.io.QuPathTypeAdapters$MeasurementListTypeAdapter.read(QuPathTypeAdapters.java:634); com.google.gson.TypeAdapter.fromJsonTree(TypeAdapter.java:296); qupath.lib.io.QuPathTypeAdapters$PathObjectTypeAdapter.parseObject(QuPathTypeAdapters.java:535); qupath.lib.io.QuPathTypeAdapters$PathObjectTypeAdapter.read(QuPathTypeAdapters.java:464); qupath.lib.io.QuPathTypeAdapters$PathObjectTypeAdapter.read(QuPathTypeAdapters.java:280); com.google.gson.Gson.fromJson(Gson.java:1214); ```. **Expected behavior**; NaNs import properly... and export is also handled properly (whatever way that is). **Desktop (please complete the following information):**; - OS: All; - QuPath Version: 0.4.3 (but likely before)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1293
https://github.com/qupath/qupath/pull/1298:382,Performance,perform,performance,382,"I did this with `egrep -rl ""Files\.exists\(\w+\)"" | xargs sed -E -i 's/Files\.exists\((\w+)\)/\1.toFile().exists()/g'` so there's a non-zero chance I missed some usages (anything with a method or field access in the something of `Files.exists(something)` will be missed) and a small chance I broke something, but I didn't want the regex to get too complex. Based on apparently slow performance, see; https://rules.sonarsource.com/java/RSPEC-3725/. https://github.com/qupath/qupath-extension-wsinfer/pull/30; https://github.com/qupath/qupath/issues/1154#issuecomment-1327044045",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1298
https://github.com/qupath/qupath/pull/1298:202,Security,access,access,202,"I did this with `egrep -rl ""Files\.exists\(\w+\)"" | xargs sed -E -i 's/Files\.exists\((\w+)\)/\1.toFile().exists()/g'` so there's a non-zero chance I missed some usages (anything with a method or field access in the something of `Files.exists(something)` will be missed) and a small chance I broke something, but I didn't want the regex to get too complex. Based on apparently slow performance, see; https://rules.sonarsource.com/java/RSPEC-3725/. https://github.com/qupath/qupath-extension-wsinfer/pull/30; https://github.com/qupath/qupath/issues/1154#issuecomment-1327044045",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1298
https://github.com/qupath/qupath/pull/1302:640,Availability,down,down,640,"Fixes https://github.com/qupath/qupath/issues/1220 - to an extent. This uses a very simple approach by calculating changes to the z and t position in the main viewer, and then adding these changes to the z and t values for the viewers to be synchronized - and then clipping to the actual range of z and t values supported by the image in viewer being synchronized. That should work nicely when synchronizing across stacks with identical dimensions, using the same z and t indices. But where dimensions or indices don't match, then out-of-range clipping can cause the relative difference between the main and synchronizing viewer to squeeze down to zero. I'm not at all convinced that's the ideal behavior, but it should be better than ignoring z and t entirely (as is currently the case).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1302
https://github.com/qupath/qupath/pull/1302:241,Integrability,synchroniz,synchronized,241,"Fixes https://github.com/qupath/qupath/issues/1220 - to an extent. This uses a very simple approach by calculating changes to the z and t position in the main viewer, and then adding these changes to the z and t values for the viewers to be synchronized - and then clipping to the actual range of z and t values supported by the image in viewer being synchronized. That should work nicely when synchronizing across stacks with identical dimensions, using the same z and t indices. But where dimensions or indices don't match, then out-of-range clipping can cause the relative difference between the main and synchronizing viewer to squeeze down to zero. I'm not at all convinced that's the ideal behavior, but it should be better than ignoring z and t entirely (as is currently the case).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1302
https://github.com/qupath/qupath/pull/1302:351,Integrability,synchroniz,synchronized,351,"Fixes https://github.com/qupath/qupath/issues/1220 - to an extent. This uses a very simple approach by calculating changes to the z and t position in the main viewer, and then adding these changes to the z and t values for the viewers to be synchronized - and then clipping to the actual range of z and t values supported by the image in viewer being synchronized. That should work nicely when synchronizing across stacks with identical dimensions, using the same z and t indices. But where dimensions or indices don't match, then out-of-range clipping can cause the relative difference between the main and synchronizing viewer to squeeze down to zero. I'm not at all convinced that's the ideal behavior, but it should be better than ignoring z and t entirely (as is currently the case).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1302
https://github.com/qupath/qupath/pull/1302:394,Integrability,synchroniz,synchronizing,394,"Fixes https://github.com/qupath/qupath/issues/1220 - to an extent. This uses a very simple approach by calculating changes to the z and t position in the main viewer, and then adding these changes to the z and t values for the viewers to be synchronized - and then clipping to the actual range of z and t values supported by the image in viewer being synchronized. That should work nicely when synchronizing across stacks with identical dimensions, using the same z and t indices. But where dimensions or indices don't match, then out-of-range clipping can cause the relative difference between the main and synchronizing viewer to squeeze down to zero. I'm not at all convinced that's the ideal behavior, but it should be better than ignoring z and t entirely (as is currently the case).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1302
https://github.com/qupath/qupath/pull/1302:608,Integrability,synchroniz,synchronizing,608,"Fixes https://github.com/qupath/qupath/issues/1220 - to an extent. This uses a very simple approach by calculating changes to the z and t position in the main viewer, and then adding these changes to the z and t values for the viewers to be synchronized - and then clipping to the actual range of z and t values supported by the image in viewer being synchronized. That should work nicely when synchronizing across stacks with identical dimensions, using the same z and t indices. But where dimensions or indices don't match, then out-of-range clipping can cause the relative difference between the main and synchronizing viewer to squeeze down to zero. I'm not at all convinced that's the ideal behavior, but it should be better than ignoring z and t entirely (as is currently the case).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1302
https://github.com/qupath/qupath/pull/1302:84,Usability,simpl,simple,84,"Fixes https://github.com/qupath/qupath/issues/1220 - to an extent. This uses a very simple approach by calculating changes to the z and t position in the main viewer, and then adding these changes to the z and t values for the viewers to be synchronized - and then clipping to the actual range of z and t values supported by the image in viewer being synchronized. That should work nicely when synchronizing across stacks with identical dimensions, using the same z and t indices. But where dimensions or indices don't match, then out-of-range clipping can cause the relative difference between the main and synchronizing viewer to squeeze down to zero. I'm not at all convinced that's the ideal behavior, but it should be better than ignoring z and t entirely (as is currently the case).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1302
https://github.com/qupath/qupath/pull/1304:273,Integrability,depend,dependencies,273,"This isolates some general-purpose JavaFX-related classes which were added to QuPath in recent years (or completely rewritten so that none should derive from prior, GPL-only code), and extracts them to a separate, more permissively-licensed module without any other QuPath dependencies.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1304
https://github.com/qupath/qupath/pull/1305:31,Testability,log,log-viewer,31,Adds https://github.com/qupath/log-viewer from @Rylern as the main log viewer.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1305
https://github.com/qupath/qupath/pull/1305:67,Testability,log,log,67,Adds https://github.com/qupath/log-viewer from @Rylern as the main log viewer.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1305
https://github.com/qupath/qupath/issues/1306:511,Deployability,release,release,511,"## Bug report. > **TLDR:** There's a bug in how QuPath v0.4.0 - v0.4.3 saved/reloads (derived) classifications that *could* impact analysis results based upon counting classified objects.; > ; > In most cases, it shouldn't matter and won't affect results; in fact, at the time of writing I'm not aware of any real-world examples where it has negatively impacted QuPath's analysis. But because it *could* matter, particularly for complicated / non-standard workflows, we plan to include a fix in the next QuPath release.; > ; > In the spirit of openness, the following (somewhat technical) description attempts to explain the issue as clearly as possible. **Describe the bug**; There is a subtle bug in QuPath v0.4.0 - v0.4.3 that strikes when reading ['derived' `PathClass` objects](https://qupath.readthedocs.io/en/0.4/docs/concepts/classifications.html#classifications-derived-classifications) from data files or (some) JSON representations. Earlier QuPath versions are not affected. Derived classifications include examples such as `Tumor: Positive` and `Tumor: Negative` - where both come from a base `Tumor` classification (represented by a `PathClass` object). QuPath aims to ensure that every classification and derived classification is a singleton, i.e. it exists only once. This means that requesting the parent class for `Tumor: Positive` and `Tumor: Negative` should always return the exact same classification object, and that should be identical to what is returned by `QP.getPathClass('Tumor')`. The issue is that whenever a derived classification is *reloaded* in QuPath v0.4.x, a necessary check is missed and this makes it possible for the parent classification of `Tumor: Positive` and `Tumor: Negative` to *not* be identical to the result of `QP.getPathClass('Tumor')`. This could potentially cause confusion when attempting to count objects that share the same classification. **To Reproduce**; The bug is hard to reproduce, and I don't know of any way to reproduce it within a si",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1306
https://github.com/qupath/qupath/issues/1306:5751,Deployability,release,release,5751,"t.getPathClass().getBaseClass() == getPathClass('Tumor')}; ```; This is because `==` really calls the `PathClass.compareTo(pathClass)` method, and this identifies the classes as the same. It is only the 'same object comparison' with `===` that fails. However if the same code was written in Java, `==` would fail because this is the Java version of the same object comparison. Knowing all this, it is possible to construct workflows where the results shown in QuPath are *not* correct. Taking the example above, if I then artificially select half my cells and assign the classification `Tumor` (with nothing else derived from it) then the count for the `Tumor (base)` measurement is wrong - it is too low (24006). This is because it only counts cells classified as `Tumor: Positive` and `Tumor: Negative` - but not `Tumor` only. <img width=""1192"" alt=""Tumor-v0 4 3 wrong"" src=""https://github.com/qupath/qupath/assets/4690904/fd610dcf-18a6-4ed8-bf54-443eddb8e91c"">. This can be seen by comparing the results with the same data opened in v0.3.2, where the `Tumor (base)` value is 102603. <img width=""1074"" alt=""Tumor-v0 3 2 correct"" src=""https://github.com/qupath/qupath/assets/4690904/97e9d2da-72bc-43a0-868c-cabe790bee9d"">. The good news is that all the other results still agree. Therefore it seems that; * Most analysis is unlikely to be affected - it required some effort here to devise a workflow that fails; * Even when the bug *does* strike, it doesn't necessarily affect the measurements that are relevant outputs of the analysis (which here would be the Positive %). **Next steps**; We plan to fix the bug in the next QuPath release, and include new tests to help prevent it ever reoccurring. In the meantime, if you are concerned that it might affect your work, reopening your data files in QuPath v0.3.2 can help to confirm whether the same results are produced. If not, the best place to discuss workarounds and fixes for specific cases is on the forum at https://forum.image.sc/tag/qupath",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1306
https://github.com/qupath/qupath/issues/1306:2061,Performance,load,loaded,2061,"umor: Negative` - where both come from a base `Tumor` classification (represented by a `PathClass` object). QuPath aims to ensure that every classification and derived classification is a singleton, i.e. it exists only once. This means that requesting the parent class for `Tumor: Positive` and `Tumor: Negative` should always return the exact same classification object, and that should be identical to what is returned by `QP.getPathClass('Tumor')`. The issue is that whenever a derived classification is *reloaded* in QuPath v0.4.x, a necessary check is missed and this makes it possible for the parent classification of `Tumor: Positive` and `Tumor: Negative` to *not* be identical to the result of `QP.getPathClass('Tumor')`. This could potentially cause confusion when attempting to count objects that share the same classification. **To Reproduce**; The bug is hard to reproduce, and I don't know of any way to reproduce it within a single QuPath session. It requires data to be saved, and then loaded into a new QuPath session (i.e. after closing QuPath and reopening it, or running QuPath on a different computer). Steps to reproduce the behavior:; 1. Perform a workflow that creates derived classifications, e.g. [positive tumor cell classification](https://qupath.readthedocs.io/en/0.4/docs/tutorials/cell_classification.html); 2. Save the data, restart QuPath, reload the data; 3. Run a script such as the following to count the objects with a specified base classification; ```groovy; println getCellObjects().count {; it.getPathClass().getBaseClass() === getPathClass('Tumor')}; ```; 4. Check that the printed count is 0, even if objects can be found with the specified base classification in the image. **Expected behavior**; Classifications should always be singletons. Given a derived classification, requesting the parent classification should always give the same result as if the parent was created separately. **Screenshots**; The screenshot below shows the issue. According to t",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1306
https://github.com/qupath/qupath/issues/1306:2220,Performance,Perform,Perform,2220,"ngleton, i.e. it exists only once. This means that requesting the parent class for `Tumor: Positive` and `Tumor: Negative` should always return the exact same classification object, and that should be identical to what is returned by `QP.getPathClass('Tumor')`. The issue is that whenever a derived classification is *reloaded* in QuPath v0.4.x, a necessary check is missed and this makes it possible for the parent classification of `Tumor: Positive` and `Tumor: Negative` to *not* be identical to the result of `QP.getPathClass('Tumor')`. This could potentially cause confusion when attempting to count objects that share the same classification. **To Reproduce**; The bug is hard to reproduce, and I don't know of any way to reproduce it within a single QuPath session. It requires data to be saved, and then loaded into a new QuPath session (i.e. after closing QuPath and reopening it, or running QuPath on a different computer). Steps to reproduce the behavior:; 1. Perform a workflow that creates derived classifications, e.g. [positive tumor cell classification](https://qupath.readthedocs.io/en/0.4/docs/tutorials/cell_classification.html); 2. Save the data, restart QuPath, reload the data; 3. Run a script such as the following to count the objects with a specified base classification; ```groovy; println getCellObjects().count {; it.getPathClass().getBaseClass() === getPathClass('Tumor')}; ```; 4. Check that the printed count is 0, even if objects can be found with the specified base classification in the image. **Expected behavior**; Classifications should always be singletons. Given a derived classification, requesting the parent classification should always give the same result as if the parent was created separately. **Screenshots**; The screenshot below shows the issue. According to the measurement table, there should be 54700 cells with the base classification `Tumor` - but the script prints 0. <img width=""914"" alt=""Screenshot 2023-08-30 at 10 11 46"" src=""https://github",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1306
https://github.com/qupath/qupath/issues/1306:5776,Testability,test,tests,5776,"t.getPathClass().getBaseClass() == getPathClass('Tumor')}; ```; This is because `==` really calls the `PathClass.compareTo(pathClass)` method, and this identifies the classes as the same. It is only the 'same object comparison' with `===` that fails. However if the same code was written in Java, `==` would fail because this is the Java version of the same object comparison. Knowing all this, it is possible to construct workflows where the results shown in QuPath are *not* correct. Taking the example above, if I then artificially select half my cells and assign the classification `Tumor` (with nothing else derived from it) then the count for the `Tumor (base)` measurement is wrong - it is too low (24006). This is because it only counts cells classified as `Tumor: Positive` and `Tumor: Negative` - but not `Tumor` only. <img width=""1192"" alt=""Tumor-v0 4 3 wrong"" src=""https://github.com/qupath/qupath/assets/4690904/fd610dcf-18a6-4ed8-bf54-443eddb8e91c"">. This can be seen by comparing the results with the same data opened in v0.3.2, where the `Tumor (base)` value is 102603. <img width=""1074"" alt=""Tumor-v0 3 2 correct"" src=""https://github.com/qupath/qupath/assets/4690904/97e9d2da-72bc-43a0-868c-cabe790bee9d"">. The good news is that all the other results still agree. Therefore it seems that; * Most analysis is unlikely to be affected - it required some effort here to devise a workflow that fails; * Even when the bug *does* strike, it doesn't necessarily affect the measurements that are relevant outputs of the analysis (which here would be the Positive %). **Next steps**; We plan to fix the bug in the next QuPath release, and include new tests to help prevent it ever reoccurring. In the meantime, if you are concerned that it might affect your work, reopening your data files in QuPath v0.3.2 can help to confirm whether the same results are produced. If not, the best place to discuss workarounds and fixes for specific cases is on the forum at https://forum.image.sc/tag/qupath",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1306
https://github.com/qupath/qupath/issues/1306:634,Usability,clear,clearly,634,"## Bug report. > **TLDR:** There's a bug in how QuPath v0.4.0 - v0.4.3 saved/reloads (derived) classifications that *could* impact analysis results based upon counting classified objects.; > ; > In most cases, it shouldn't matter and won't affect results; in fact, at the time of writing I'm not aware of any real-world examples where it has negatively impacted QuPath's analysis. But because it *could* matter, particularly for complicated / non-standard workflows, we plan to include a fix in the next QuPath release.; > ; > In the spirit of openness, the following (somewhat technical) description attempts to explain the issue as clearly as possible. **Describe the bug**; There is a subtle bug in QuPath v0.4.0 - v0.4.3 that strikes when reading ['derived' `PathClass` objects](https://qupath.readthedocs.io/en/0.4/docs/concepts/classifications.html#classifications-derived-classifications) from data files or (some) JSON representations. Earlier QuPath versions are not affected. Derived classifications include examples such as `Tumor: Positive` and `Tumor: Negative` - where both come from a base `Tumor` classification (represented by a `PathClass` object). QuPath aims to ensure that every classification and derived classification is a singleton, i.e. it exists only once. This means that requesting the parent class for `Tumor: Positive` and `Tumor: Negative` should always return the exact same classification object, and that should be identical to what is returned by `QP.getPathClass('Tumor')`. The issue is that whenever a derived classification is *reloaded* in QuPath v0.4.x, a necessary check is missed and this makes it possible for the parent classification of `Tumor: Positive` and `Tumor: Negative` to *not* be identical to the result of `QP.getPathClass('Tumor')`. This could potentially cause confusion when attempting to count objects that share the same classification. **To Reproduce**; The bug is hard to reproduce, and I don't know of any way to reproduce it within a si",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1306
https://github.com/qupath/qupath/pull/1308:17,Testability,log,logic,17,"Move most of the logic into [qupath-fxtras](https://github.com/qupath/qupath-fxtras), so that `PreferencePane` can be greatly simplified. Not expected to built until/unless https://github.com/qupath/qupath-fxtras/pull/4 is merged.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1308
https://github.com/qupath/qupath/pull/1308:126,Usability,simpl,simplified,126,"Move most of the logic into [qupath-fxtras](https://github.com/qupath/qupath-fxtras), so that `PreferencePane` can be greatly simplified. Not expected to built until/unless https://github.com/qupath/qupath-fxtras/pull/4 is merged.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1308
https://github.com/qupath/qupath/issues/1309:711,Usability,clear,clearly,711,"## Bug report. **Describe the bug**; Screenshots make using QuPath v0.4.x have unexpected colors - at least on macOS. This affects; * *Edit &rarr; Copy to clipboard... &rarr; Main window screenshot*; * *Edit &rarr; Copy to clipboard... &rarr; Full screenshot*; * *File &rarr; Export snapshot... &rarr; Main window screenshot*. Snapshots of *specific components* (e.g. the viewer) seem to be fine - suggesting the problem relates to the use of the JavaFX `Robot` class for screen capture, and not color management with JavaFX more generally. **To Reproduce**; Using one of the above commands can show the issue, but the color shift can be subtle enough to miss. I've written a script that reveals the issue more clearly, by comparing screenshots made from JavaFX with those made using (the older) Java AWT:; https://gist.github.com/petebankhead/6d8ea33e0137705d33abc1800fd52072. The colors generated using Java AWT's `Robot` class seem correct, whereas those generated with JavaFX's `Robot` class are unexpectedly 'vivid'. **Expected behavior**; Screenshots generated with QuPath should have colors that faithfully match what is seen on screen, and which would be generated using the operating system's screen capture. **Screenshots**; Screenshots from running the above script:. ### With JavaFX; ![jfx](https://github.com/qupath/qupath/assets/4690904/2662a20d-138c-41ec-896d-3d0dd283b2df). ### With AWT; ![awt](https://github.com/qupath/qupath/assets/4690904/0756554e-c120-4074-8970-6469de5fdde6). ### Difference; ![diff](https://github.com/qupath/qupath/assets/4690904/1df88b3c-03ae-4620-a0ba-fe2907ac11ec). **Desktop (please complete the following information):**; - OS: macOS - with Apple Studio Display; - QuPath Version: v0.4.x. **Additional context**; I have only seen this on macOS with an Apple Studio Display - we need to check if affects other platforms as well. (Additionally, based on the current code I'd expect there are issues with multi-screen scenarios... but I usually only have one)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1309
https://github.com/qupath/qupath/pull/1312:205,Availability,down,down,205,"* Support exporting snapshot as PNG, JPEG and TIFF (not just PNG); * Improve wording for language preference; * Make it possible to use `mavenLocal()` via a gradle property (handle e.g. if a maven repo is down)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1312
https://github.com/qupath/qupath/issues/1313:1012,Availability,down,downloading,1012,"s, each one a TMA. I analyzed all of them about 6 months ago, exported the data I needed to excel, and analyzed it there. However, I wanted to add another variable to analyze the data by, and opened the QuPath project to add a variable to the TMA data grid.;  ; After doing this with the first five images, I saved one and clicked to open the next one, and went to the bathroom while it loaded. When I returned, it was telling me to select an image type, and I realized it had deleted all the annotations and detections. Upon further inspection, it had deleted all the detections and annotations on all of the images except the one I had just been editing, and showed the rest as new and unopened images. ;  ; I closed without saving and reopened, and then two had the detections and annotations restored. I've continued closing and reopening the project, and a different number of images have annotations each time. I have tried downloading the newest version of QuPath, after which there were 5 images with annotations and detections restored and one with only annotations restored. Since updating, the same data is the same every time I reopen it. I have also tried updating and restarting my computer. I have no idea how or why this happened or how to get my data back. This is many hours of work, and I'm scared to start my new project, if this is a possible outcome.;  ; **To Reproduce**; I'm sorry, but I have no idea.;  ; **Expected behavior**; Normally, when I go from one image to another, I save one and then the next one opens the old annotations and detections.;  ; **Screenshots**; <img width=""1264"" alt=""Screenshot 2023-09-04 at 6 43 43 PM"" src=""https://github.com/qupath/qupath/assets/79068467/16ab2d72-a5ad-4910-b1eb-c1fc0a9c8842"">; This is a list of images, you can see that it shows five on this view as opened and the rest as new. ;  ; **Desktop (please complete the following information):**;  - OS:  macOS Ventura Version 13.5.1 (22G90);  - QuPath Version: currently Version: 0.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1313
https://github.com/qupath/qupath/issues/1313:2548,Availability,down,downloaded,2548," annotations restored. I've continued closing and reopening the project, and a different number of images have annotations each time. I have tried downloading the newest version of QuPath, after which there were 5 images with annotations and detections restored and one with only annotations restored. Since updating, the same data is the same every time I reopen it. I have also tried updating and restarting my computer. I have no idea how or why this happened or how to get my data back. This is many hours of work, and I'm scared to start my new project, if this is a possible outcome.;  ; **To Reproduce**; I'm sorry, but I have no idea.;  ; **Expected behavior**; Normally, when I go from one image to another, I save one and then the next one opens the old annotations and detections.;  ; **Screenshots**; <img width=""1264"" alt=""Screenshot 2023-09-04 at 6 43 43 PM"" src=""https://github.com/qupath/qupath/assets/79068467/16ab2d72-a5ad-4910-b1eb-c1fc0a9c8842"">; This is a list of images, you can see that it shows five on this view as opened and the rest as new. ;  ; **Desktop (please complete the following information):**;  - OS:  macOS Ventura Version 13.5.1 (22G90);  - QuPath Version: currently Version: 0.4.4, unfortunately, I didn't check the old version before updating;  ; **Additional context**; The only thing I think *could* be a contributing factor is that the image files are large, and my Mac automatically offloads them to the cloud if I haven't opened them for a few days. When I want to work on the project, I redownload the images from the cloud, and have never had an issue viewing my old annotations on those images before. All of the images are currently downloaded, and there is no consistency between the ones that got offloaded to the cloud and the ones that lost annotations. There are six that were never offloaded to the cloud, and three of them lost annotations/detections. There are also three that were offloaded to the cloud that retained annotations/detections.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1313
https://github.com/qupath/qupath/issues/1313:237,Modifiability,variab,variable,237,"## Bug report;  ; **Describe the bug**; I have a project containing about 20 images, each one a TMA. I analyzed all of them about 6 months ago, exported the data I needed to excel, and analyzed it there. However, I wanted to add another variable to analyze the data by, and opened the QuPath project to add a variable to the TMA data grid.;  ; After doing this with the first five images, I saved one and clicked to open the next one, and went to the bathroom while it loaded. When I returned, it was telling me to select an image type, and I realized it had deleted all the annotations and detections. Upon further inspection, it had deleted all the detections and annotations on all of the images except the one I had just been editing, and showed the rest as new and unopened images. ;  ; I closed without saving and reopened, and then two had the detections and annotations restored. I've continued closing and reopening the project, and a different number of images have annotations each time. I have tried downloading the newest version of QuPath, after which there were 5 images with annotations and detections restored and one with only annotations restored. Since updating, the same data is the same every time I reopen it. I have also tried updating and restarting my computer. I have no idea how or why this happened or how to get my data back. This is many hours of work, and I'm scared to start my new project, if this is a possible outcome.;  ; **To Reproduce**; I'm sorry, but I have no idea.;  ; **Expected behavior**; Normally, when I go from one image to another, I save one and then the next one opens the old annotations and detections.;  ; **Screenshots**; <img width=""1264"" alt=""Screenshot 2023-09-04 at 6 43 43 PM"" src=""https://github.com/qupath/qupath/assets/79068467/16ab2d72-a5ad-4910-b1eb-c1fc0a9c8842"">; This is a list of images, you can see that it shows five on this view as opened and the rest as new. ;  ; **Desktop (please complete the following information):**;  - OS",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1313
https://github.com/qupath/qupath/issues/1313:309,Modifiability,variab,variable,309,"## Bug report;  ; **Describe the bug**; I have a project containing about 20 images, each one a TMA. I analyzed all of them about 6 months ago, exported the data I needed to excel, and analyzed it there. However, I wanted to add another variable to analyze the data by, and opened the QuPath project to add a variable to the TMA data grid.;  ; After doing this with the first five images, I saved one and clicked to open the next one, and went to the bathroom while it loaded. When I returned, it was telling me to select an image type, and I realized it had deleted all the annotations and detections. Upon further inspection, it had deleted all the detections and annotations on all of the images except the one I had just been editing, and showed the rest as new and unopened images. ;  ; I closed without saving and reopened, and then two had the detections and annotations restored. I've continued closing and reopening the project, and a different number of images have annotations each time. I have tried downloading the newest version of QuPath, after which there were 5 images with annotations and detections restored and one with only annotations restored. Since updating, the same data is the same every time I reopen it. I have also tried updating and restarting my computer. I have no idea how or why this happened or how to get my data back. This is many hours of work, and I'm scared to start my new project, if this is a possible outcome.;  ; **To Reproduce**; I'm sorry, but I have no idea.;  ; **Expected behavior**; Normally, when I go from one image to another, I save one and then the next one opens the old annotations and detections.;  ; **Screenshots**; <img width=""1264"" alt=""Screenshot 2023-09-04 at 6 43 43 PM"" src=""https://github.com/qupath/qupath/assets/79068467/16ab2d72-a5ad-4910-b1eb-c1fc0a9c8842"">; This is a list of images, you can see that it shows five on this view as opened and the rest as new. ;  ; **Desktop (please complete the following information):**;  - OS",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1313
https://github.com/qupath/qupath/issues/1313:469,Performance,load,loaded,469,"## Bug report;  ; **Describe the bug**; I have a project containing about 20 images, each one a TMA. I analyzed all of them about 6 months ago, exported the data I needed to excel, and analyzed it there. However, I wanted to add another variable to analyze the data by, and opened the QuPath project to add a variable to the TMA data grid.;  ; After doing this with the first five images, I saved one and clicked to open the next one, and went to the bathroom while it loaded. When I returned, it was telling me to select an image type, and I realized it had deleted all the annotations and detections. Upon further inspection, it had deleted all the detections and annotations on all of the images except the one I had just been editing, and showed the rest as new and unopened images. ;  ; I closed without saving and reopened, and then two had the detections and annotations restored. I've continued closing and reopening the project, and a different number of images have annotations each time. I have tried downloading the newest version of QuPath, after which there were 5 images with annotations and detections restored and one with only annotations restored. Since updating, the same data is the same every time I reopen it. I have also tried updating and restarting my computer. I have no idea how or why this happened or how to get my data back. This is many hours of work, and I'm scared to start my new project, if this is a possible outcome.;  ; **To Reproduce**; I'm sorry, but I have no idea.;  ; **Expected behavior**; Normally, when I go from one image to another, I save one and then the next one opens the old annotations and detections.;  ; **Screenshots**; <img width=""1264"" alt=""Screenshot 2023-09-04 at 6 43 43 PM"" src=""https://github.com/qupath/qupath/assets/79068467/16ab2d72-a5ad-4910-b1eb-c1fc0a9c8842"">; This is a list of images, you can see that it shows five on this view as opened and the rest as new. ;  ; **Desktop (please complete the following information):**;  - OS",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1313
https://github.com/qupath/qupath/issues/1313:591,Safety,detect,detections,591,"## Bug report;  ; **Describe the bug**; I have a project containing about 20 images, each one a TMA. I analyzed all of them about 6 months ago, exported the data I needed to excel, and analyzed it there. However, I wanted to add another variable to analyze the data by, and opened the QuPath project to add a variable to the TMA data grid.;  ; After doing this with the first five images, I saved one and clicked to open the next one, and went to the bathroom while it loaded. When I returned, it was telling me to select an image type, and I realized it had deleted all the annotations and detections. Upon further inspection, it had deleted all the detections and annotations on all of the images except the one I had just been editing, and showed the rest as new and unopened images. ;  ; I closed without saving and reopened, and then two had the detections and annotations restored. I've continued closing and reopening the project, and a different number of images have annotations each time. I have tried downloading the newest version of QuPath, after which there were 5 images with annotations and detections restored and one with only annotations restored. Since updating, the same data is the same every time I reopen it. I have also tried updating and restarting my computer. I have no idea how or why this happened or how to get my data back. This is many hours of work, and I'm scared to start my new project, if this is a possible outcome.;  ; **To Reproduce**; I'm sorry, but I have no idea.;  ; **Expected behavior**; Normally, when I go from one image to another, I save one and then the next one opens the old annotations and detections.;  ; **Screenshots**; <img width=""1264"" alt=""Screenshot 2023-09-04 at 6 43 43 PM"" src=""https://github.com/qupath/qupath/assets/79068467/16ab2d72-a5ad-4910-b1eb-c1fc0a9c8842"">; This is a list of images, you can see that it shows five on this view as opened and the rest as new. ;  ; **Desktop (please complete the following information):**;  - OS",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1313
https://github.com/qupath/qupath/issues/1313:651,Safety,detect,detections,651,"## Bug report;  ; **Describe the bug**; I have a project containing about 20 images, each one a TMA. I analyzed all of them about 6 months ago, exported the data I needed to excel, and analyzed it there. However, I wanted to add another variable to analyze the data by, and opened the QuPath project to add a variable to the TMA data grid.;  ; After doing this with the first five images, I saved one and clicked to open the next one, and went to the bathroom while it loaded. When I returned, it was telling me to select an image type, and I realized it had deleted all the annotations and detections. Upon further inspection, it had deleted all the detections and annotations on all of the images except the one I had just been editing, and showed the rest as new and unopened images. ;  ; I closed without saving and reopened, and then two had the detections and annotations restored. I've continued closing and reopening the project, and a different number of images have annotations each time. I have tried downloading the newest version of QuPath, after which there were 5 images with annotations and detections restored and one with only annotations restored. Since updating, the same data is the same every time I reopen it. I have also tried updating and restarting my computer. I have no idea how or why this happened or how to get my data back. This is many hours of work, and I'm scared to start my new project, if this is a possible outcome.;  ; **To Reproduce**; I'm sorry, but I have no idea.;  ; **Expected behavior**; Normally, when I go from one image to another, I save one and then the next one opens the old annotations and detections.;  ; **Screenshots**; <img width=""1264"" alt=""Screenshot 2023-09-04 at 6 43 43 PM"" src=""https://github.com/qupath/qupath/assets/79068467/16ab2d72-a5ad-4910-b1eb-c1fc0a9c8842"">; This is a list of images, you can see that it shows five on this view as opened and the rest as new. ;  ; **Desktop (please complete the following information):**;  - OS",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1313
https://github.com/qupath/qupath/issues/1313:851,Safety,detect,detections,851,"## Bug report;  ; **Describe the bug**; I have a project containing about 20 images, each one a TMA. I analyzed all of them about 6 months ago, exported the data I needed to excel, and analyzed it there. However, I wanted to add another variable to analyze the data by, and opened the QuPath project to add a variable to the TMA data grid.;  ; After doing this with the first five images, I saved one and clicked to open the next one, and went to the bathroom while it loaded. When I returned, it was telling me to select an image type, and I realized it had deleted all the annotations and detections. Upon further inspection, it had deleted all the detections and annotations on all of the images except the one I had just been editing, and showed the rest as new and unopened images. ;  ; I closed without saving and reopened, and then two had the detections and annotations restored. I've continued closing and reopening the project, and a different number of images have annotations each time. I have tried downloading the newest version of QuPath, after which there were 5 images with annotations and detections restored and one with only annotations restored. Since updating, the same data is the same every time I reopen it. I have also tried updating and restarting my computer. I have no idea how or why this happened or how to get my data back. This is many hours of work, and I'm scared to start my new project, if this is a possible outcome.;  ; **To Reproduce**; I'm sorry, but I have no idea.;  ; **Expected behavior**; Normally, when I go from one image to another, I save one and then the next one opens the old annotations and detections.;  ; **Screenshots**; <img width=""1264"" alt=""Screenshot 2023-09-04 at 6 43 43 PM"" src=""https://github.com/qupath/qupath/assets/79068467/16ab2d72-a5ad-4910-b1eb-c1fc0a9c8842"">; This is a list of images, you can see that it shows five on this view as opened and the rest as new. ;  ; **Desktop (please complete the following information):**;  - OS",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1313
https://github.com/qupath/qupath/issues/1313:1107,Safety,detect,detections,1107,"s, each one a TMA. I analyzed all of them about 6 months ago, exported the data I needed to excel, and analyzed it there. However, I wanted to add another variable to analyze the data by, and opened the QuPath project to add a variable to the TMA data grid.;  ; After doing this with the first five images, I saved one and clicked to open the next one, and went to the bathroom while it loaded. When I returned, it was telling me to select an image type, and I realized it had deleted all the annotations and detections. Upon further inspection, it had deleted all the detections and annotations on all of the images except the one I had just been editing, and showed the rest as new and unopened images. ;  ; I closed without saving and reopened, and then two had the detections and annotations restored. I've continued closing and reopening the project, and a different number of images have annotations each time. I have tried downloading the newest version of QuPath, after which there were 5 images with annotations and detections restored and one with only annotations restored. Since updating, the same data is the same every time I reopen it. I have also tried updating and restarting my computer. I have no idea how or why this happened or how to get my data back. This is many hours of work, and I'm scared to start my new project, if this is a possible outcome.;  ; **To Reproduce**; I'm sorry, but I have no idea.;  ; **Expected behavior**; Normally, when I go from one image to another, I save one and then the next one opens the old annotations and detections.;  ; **Screenshots**; <img width=""1264"" alt=""Screenshot 2023-09-04 at 6 43 43 PM"" src=""https://github.com/qupath/qupath/assets/79068467/16ab2d72-a5ad-4910-b1eb-c1fc0a9c8842"">; This is a list of images, you can see that it shows five on this view as opened and the rest as new. ;  ; **Desktop (please complete the following information):**;  - OS:  macOS Ventura Version 13.5.1 (22G90);  - QuPath Version: currently Version: 0.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1313
https://github.com/qupath/qupath/issues/1313:1645,Safety,detect,detections,1645,"tions and detections. Upon further inspection, it had deleted all the detections and annotations on all of the images except the one I had just been editing, and showed the rest as new and unopened images. ;  ; I closed without saving and reopened, and then two had the detections and annotations restored. I've continued closing and reopening the project, and a different number of images have annotations each time. I have tried downloading the newest version of QuPath, after which there were 5 images with annotations and detections restored and one with only annotations restored. Since updating, the same data is the same every time I reopen it. I have also tried updating and restarting my computer. I have no idea how or why this happened or how to get my data back. This is many hours of work, and I'm scared to start my new project, if this is a possible outcome.;  ; **To Reproduce**; I'm sorry, but I have no idea.;  ; **Expected behavior**; Normally, when I go from one image to another, I save one and then the next one opens the old annotations and detections.;  ; **Screenshots**; <img width=""1264"" alt=""Screenshot 2023-09-04 at 6 43 43 PM"" src=""https://github.com/qupath/qupath/assets/79068467/16ab2d72-a5ad-4910-b1eb-c1fc0a9c8842"">; This is a list of images, you can see that it shows five on this view as opened and the rest as new. ;  ; **Desktop (please complete the following information):**;  - OS:  macOS Ventura Version 13.5.1 (22G90);  - QuPath Version: currently Version: 0.4.4, unfortunately, I didn't check the old version before updating;  ; **Additional context**; The only thing I think *could* be a contributing factor is that the image files are large, and my Mac automatically offloads them to the cloud if I haven't opened them for a few days. When I want to work on the project, I redownload the images from the cloud, and have never had an issue viewing my old annotations on those images before. All of the images are currently downloaded, and there is no consis",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1313
https://github.com/qupath/qupath/issues/1313:2762,Safety,detect,detections,2762," annotations restored. I've continued closing and reopening the project, and a different number of images have annotations each time. I have tried downloading the newest version of QuPath, after which there were 5 images with annotations and detections restored and one with only annotations restored. Since updating, the same data is the same every time I reopen it. I have also tried updating and restarting my computer. I have no idea how or why this happened or how to get my data back. This is many hours of work, and I'm scared to start my new project, if this is a possible outcome.;  ; **To Reproduce**; I'm sorry, but I have no idea.;  ; **Expected behavior**; Normally, when I go from one image to another, I save one and then the next one opens the old annotations and detections.;  ; **Screenshots**; <img width=""1264"" alt=""Screenshot 2023-09-04 at 6 43 43 PM"" src=""https://github.com/qupath/qupath/assets/79068467/16ab2d72-a5ad-4910-b1eb-c1fc0a9c8842"">; This is a list of images, you can see that it shows five on this view as opened and the rest as new. ;  ; **Desktop (please complete the following information):**;  - OS:  macOS Ventura Version 13.5.1 (22G90);  - QuPath Version: currently Version: 0.4.4, unfortunately, I didn't check the old version before updating;  ; **Additional context**; The only thing I think *could* be a contributing factor is that the image files are large, and my Mac automatically offloads them to the cloud if I haven't opened them for a few days. When I want to work on the project, I redownload the images from the cloud, and have never had an issue viewing my old annotations on those images before. All of the images are currently downloaded, and there is no consistency between the ones that got offloaded to the cloud and the ones that lost annotations. There are six that were never offloaded to the cloud, and three of them lost annotations/detections. There are also three that were offloaded to the cloud that retained annotations/detections.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1313
https://github.com/qupath/qupath/issues/1313:2854,Safety,detect,detections,2854," annotations restored. I've continued closing and reopening the project, and a different number of images have annotations each time. I have tried downloading the newest version of QuPath, after which there were 5 images with annotations and detections restored and one with only annotations restored. Since updating, the same data is the same every time I reopen it. I have also tried updating and restarting my computer. I have no idea how or why this happened or how to get my data back. This is many hours of work, and I'm scared to start my new project, if this is a possible outcome.;  ; **To Reproduce**; I'm sorry, but I have no idea.;  ; **Expected behavior**; Normally, when I go from one image to another, I save one and then the next one opens the old annotations and detections.;  ; **Screenshots**; <img width=""1264"" alt=""Screenshot 2023-09-04 at 6 43 43 PM"" src=""https://github.com/qupath/qupath/assets/79068467/16ab2d72-a5ad-4910-b1eb-c1fc0a9c8842"">; This is a list of images, you can see that it shows five on this view as opened and the rest as new. ;  ; **Desktop (please complete the following information):**;  - OS:  macOS Ventura Version 13.5.1 (22G90);  - QuPath Version: currently Version: 0.4.4, unfortunately, I didn't check the old version before updating;  ; **Additional context**; The only thing I think *could* be a contributing factor is that the image files are large, and my Mac automatically offloads them to the cloud if I haven't opened them for a few days. When I want to work on the project, I redownload the images from the cloud, and have never had an issue viewing my old annotations on those images before. All of the images are currently downloaded, and there is no consistency between the ones that got offloaded to the cloud and the ones that lost annotations. There are six that were never offloaded to the cloud, and three of them lost annotations/detections. There are also three that were offloaded to the cloud that retained annotations/detections.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1313
https://github.com/qupath/qupath/pull/1315:114,Deployability,update,update,114,"* Added icons & toolbar buttons for script editor and log viewer; * Fixed bug that meant menuitem graphics didn't update their color when the style changed; * Created new preference to control if the system menubar is used for all windows, the main window only, or no windows",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1315
https://github.com/qupath/qupath/pull/1315:54,Testability,log,log,54,"* Added icons & toolbar buttons for script editor and log viewer; * Fixed bug that meant menuitem graphics didn't update their color when the style changed; * Created new preference to control if the system menubar is used for all windows, the main window only, or no windows",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1315
https://github.com/qupath/qupath/pull/1316:60,Modifiability,refactor,refactoring,60,Fix exception when trying to open view tracking twice. More refactoring should be done in the future to avoid the use of the static dialog.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1316
https://github.com/qupath/qupath/pull/1316:104,Safety,avoid,avoid,104,Fix exception when trying to open view tracking twice. More refactoring should be done in the future to avoid the use of the static dialog.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1316
https://github.com/qupath/qupath/issues/1317:430,Energy Efficiency,monitor,monitors,430,"## Feature request. ### Is your feature request related to a problem? Please describe.; QuPath was designed to have one main window. If there are to be multiple viewers, these are embedded in a grid. The original thinking was that we couldn't handle too many images simultaneously, since they tend to be big. But QuPath is now used for lots of different things, including with images of different sizes... and often with multiple monitors. The 'single window' could become very limiting. . ### Describe the solution you'd like; Not so much the 'solution I'd like' as the one I'm proposing: adding support for detaching viewers. Here's a **very rough** example of it in action, hacked together with minimal code changes:. <img width=""1188"" alt=""Detachable viewer demo"" src=""https://github.com/qupath/qupath/assets/4690904/933e5528-4bf9-461b-855d-04eeb6fe8ad2"">. ### Additional context; This isn't so much a feature request as an invitation for feedback. My feeling is that it's worth exploring, but I'm not sure if it helps or just creates confusion. My main questions are:; * Is this a feature anyone really wants?; * Is it likely to be more helpful or confusing for new users?; * If implemented, should it work by; * Detaching one viewer (and leaving the rest of the 'viewer grid' intact), or; * Breaking up the UI entirely, so that there is no longer a grid and instead we have separate windows (including for the toolbar and analysis pane, more like ImageJ); * Is there a need to have the *same* image open in multiple viewers?; * Note that this wouldn't permit having different objects or display modes (e.g. different kinds of overlays), but rather it would just allow different image regions to be visualized at the same time. That is already kind of possible with *View &rarr; Show mini viewer* - except the mini viewer doesn't support all the kinds of interaction that are possible with a full viewer.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1317
https://github.com/qupath/qupath/issues/1317:943,Usability,feedback,feedback,943,"## Feature request. ### Is your feature request related to a problem? Please describe.; QuPath was designed to have one main window. If there are to be multiple viewers, these are embedded in a grid. The original thinking was that we couldn't handle too many images simultaneously, since they tend to be big. But QuPath is now used for lots of different things, including with images of different sizes... and often with multiple monitors. The 'single window' could become very limiting. . ### Describe the solution you'd like; Not so much the 'solution I'd like' as the one I'm proposing: adding support for detaching viewers. Here's a **very rough** example of it in action, hacked together with minimal code changes:. <img width=""1188"" alt=""Detachable viewer demo"" src=""https://github.com/qupath/qupath/assets/4690904/933e5528-4bf9-461b-855d-04eeb6fe8ad2"">. ### Additional context; This isn't so much a feature request as an invitation for feedback. My feeling is that it's worth exploring, but I'm not sure if it helps or just creates confusion. My main questions are:; * Is this a feature anyone really wants?; * Is it likely to be more helpful or confusing for new users?; * If implemented, should it work by; * Detaching one viewer (and leaving the rest of the 'viewer grid' intact), or; * Breaking up the UI entirely, so that there is no longer a grid and instead we have separate windows (including for the toolbar and analysis pane, more like ImageJ); * Is there a need to have the *same* image open in multiple viewers?; * Note that this wouldn't permit having different objects or display modes (e.g. different kinds of overlays), but rather it would just allow different image regions to be visualized at the same time. That is already kind of possible with *View &rarr; Show mini viewer* - except the mini viewer doesn't support all the kinds of interaction that are possible with a full viewer.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1317
https://github.com/qupath/qupath/pull/1318:2337,Availability,robust,robust,2337,"ed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, ImageData<T> imageData, String arg)`; ```; so that there's no need to request the `ImageData` from the plugin runner - and it's possible to ensure this remains unchanged while all the work of the plugin is completex, no matter what might go on in the UI. Early indications are that the code is just simpler and more robust. However, it's still a core change that *could* potentially have broken lots of things, so most analysis-related commands ought to be checked (e.g. cell detection, or anything else involving `PathPlugin`). ## ImageJ, macOS & menubars. The ImageJ macro runner was an implementation of `PathPlugin`. When exploring how this was affected, I dug into a longstanding bug since QuPath's beginning: basically, ImageJ and QuPath's menus don't play together nicely on macOS: https://github.com/qupath/qupath/issues/6. Shortcuts/accelerators are particularly badly affected: the QuPath ones either don't work, or would trigger both the accelerator within QuPath *and* within ImageJ. This PR attempts to finally fix this, by; 1. overriding any system menubar request from QuPath while ImageJ is running, so that QuPath's menu becomes 'demoted' to within the app; 2. blocking ImageJ's last menubar whenever it no longer has any focussed stage (i.e. whenever a JavaFX window is a",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:1373,Deployability,update,updates,1373,"opup menu (accessed by right-click on a viewer) now contain commands to set a fixed grid size of viewers: 1x1, 1x2, 2x1, 2x2, 3x3.; * This makes it much easier to create a viewer grid for common sizes, without needing multiple steps to add rows/columns.; * Text and icons show the expected grid shapes so they should be easy to interpret; * New commands are added to *Detach viewer from the grid* and subsequently to *Attach viewer to the grid*, so that viewers can be moved to their own floating windows and back again. ## PathPlugin & PluginRunner. When making the above changes, it became clear that a major refactoring & simplification of `PathPlugin` and `PluginRunner` was needed. The original problem was that `PluginRunnerFX` proved to be buggy with detached windows, because the `ImageData` being handled was accessed via `PluginRunner.getImageData()`. In most cases that's fine, but `PluginRunnerFX` was always returning the *current* `ImageData` from QuPath, and if this *changed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, ImageData<T> imageData, String arg)`; ```; so that there's no need to request the `ImageData` from the plugin runner - and it's possible to ensure this remains unchanged while all the work of the plugin is completex, no matter what might go on in the UI. Early indications are that the code is just si",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:1952,Deployability,update,updated,1952,"ctoring & simplification of `PathPlugin` and `PluginRunner` was needed. The original problem was that `PluginRunnerFX` proved to be buggy with detached windows, because the `ImageData` being handled was accessed via `PluginRunner.getImageData()`. In most cases that's fine, but `PluginRunnerFX` was always returning the *current* `ImageData` from QuPath, and if this *changed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, ImageData<T> imageData, String arg)`; ```; so that there's no need to request the `ImageData` from the plugin runner - and it's possible to ensure this remains unchanged while all the work of the plugin is completex, no matter what might go on in the UI. Early indications are that the code is just simpler and more robust. However, it's still a core change that *could* potentially have broken lots of things, so most analysis-related commands ought to be checked (e.g. cell detection, or anything else involving `PathPlugin`). ## ImageJ, macOS & menubars. The ImageJ macro runner was an implementation of `PathPlugin`. When exploring how this was affected, I dug into a longstanding bug since QuPath's beginning: basically, ImageJ and QuPath's menus don't play together nicely on macOS: https://github.com/qupath/qupath/issues/6. Shortcuts/accelerators are particularly badly affected: the QuPath ones either don'",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:858,Modifiability,Plugin,PluginRunner,858,"See discussion at https://github.com/qupath/qupath/issues/1317. This PR has become much more extensive and cover a few (unexpectedly) interrelated issues. ## Viewer grids & detached viewers. The PR aims to improve the use of multiple viewers more generally:. * The *View &rarr; Multi-view...* main menu and *Multi-view* popup menu (accessed by right-click on a viewer) now contain commands to set a fixed grid size of viewers: 1x1, 1x2, 2x1, 2x2, 3x3.; * This makes it much easier to create a viewer grid for common sizes, without needing multiple steps to add rows/columns.; * Text and icons show the expected grid shapes so they should be easy to interpret; * New commands are added to *Detach viewer from the grid* and subsequently to *Attach viewer to the grid*, so that viewers can be moved to their own floating windows and back again. ## PathPlugin & PluginRunner. When making the above changes, it became clear that a major refactoring & simplification of `PathPlugin` and `PluginRunner` was needed. The original problem was that `PluginRunnerFX` proved to be buggy with detached windows, because the `ImageData` being handled was accessed via `PluginRunner.getImageData()`. In most cases that's fine, but `PluginRunnerFX` was always returning the *current* `ImageData` from QuPath, and if this *changed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginR",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:932,Modifiability,refactor,refactoring,932,"See discussion at https://github.com/qupath/qupath/issues/1317. This PR has become much more extensive and cover a few (unexpectedly) interrelated issues. ## Viewer grids & detached viewers. The PR aims to improve the use of multiple viewers more generally:. * The *View &rarr; Multi-view...* main menu and *Multi-view* popup menu (accessed by right-click on a viewer) now contain commands to set a fixed grid size of viewers: 1x1, 1x2, 2x1, 2x2, 3x3.; * This makes it much easier to create a viewer grid for common sizes, without needing multiple steps to add rows/columns.; * Text and icons show the expected grid shapes so they should be easy to interpret; * New commands are added to *Detach viewer from the grid* and subsequently to *Attach viewer to the grid*, so that viewers can be moved to their own floating windows and back again. ## PathPlugin & PluginRunner. When making the above changes, it became clear that a major refactoring & simplification of `PathPlugin` and `PluginRunner` was needed. The original problem was that `PluginRunnerFX` proved to be buggy with detached windows, because the `ImageData` being handled was accessed via `PluginRunner.getImageData()`. In most cases that's fine, but `PluginRunnerFX` was always returning the *current* `ImageData` from QuPath, and if this *changed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginR",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:982,Modifiability,Plugin,PluginRunner,982,"See discussion at https://github.com/qupath/qupath/issues/1317. This PR has become much more extensive and cover a few (unexpectedly) interrelated issues. ## Viewer grids & detached viewers. The PR aims to improve the use of multiple viewers more generally:. * The *View &rarr; Multi-view...* main menu and *Multi-view* popup menu (accessed by right-click on a viewer) now contain commands to set a fixed grid size of viewers: 1x1, 1x2, 2x1, 2x2, 3x3.; * This makes it much easier to create a viewer grid for common sizes, without needing multiple steps to add rows/columns.; * Text and icons show the expected grid shapes so they should be easy to interpret; * New commands are added to *Detach viewer from the grid* and subsequently to *Attach viewer to the grid*, so that viewers can be moved to their own floating windows and back again. ## PathPlugin & PluginRunner. When making the above changes, it became clear that a major refactoring & simplification of `PathPlugin` and `PluginRunner` was needed. The original problem was that `PluginRunnerFX` proved to be buggy with detached windows, because the `ImageData` being handled was accessed via `PluginRunner.getImageData()`. In most cases that's fine, but `PluginRunnerFX` was always returning the *current* `ImageData` from QuPath, and if this *changed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginR",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:1039,Modifiability,Plugin,PluginRunnerFX,1039,"h more extensive and cover a few (unexpectedly) interrelated issues. ## Viewer grids & detached viewers. The PR aims to improve the use of multiple viewers more generally:. * The *View &rarr; Multi-view...* main menu and *Multi-view* popup menu (accessed by right-click on a viewer) now contain commands to set a fixed grid size of viewers: 1x1, 1x2, 2x1, 2x2, 3x3.; * This makes it much easier to create a viewer grid for common sizes, without needing multiple steps to add rows/columns.; * Text and icons show the expected grid shapes so they should be easy to interpret; * New commands are added to *Detach viewer from the grid* and subsequently to *Attach viewer to the grid*, so that viewers can be moved to their own floating windows and back again. ## PathPlugin & PluginRunner. When making the above changes, it became clear that a major refactoring & simplification of `PathPlugin` and `PluginRunner` was needed. The original problem was that `PluginRunnerFX` proved to be buggy with detached windows, because the `ImageData` being handled was accessed via `PluginRunner.getImageData()`. In most cases that's fine, but `PluginRunnerFX` was always returning the *current* `ImageData` from QuPath, and if this *changed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, ImageData<T> imageData, String arg)`; ```; so that there's no need",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:1153,Modifiability,Plugin,PluginRunner,1153,"h more extensive and cover a few (unexpectedly) interrelated issues. ## Viewer grids & detached viewers. The PR aims to improve the use of multiple viewers more generally:. * The *View &rarr; Multi-view...* main menu and *Multi-view* popup menu (accessed by right-click on a viewer) now contain commands to set a fixed grid size of viewers: 1x1, 1x2, 2x1, 2x2, 3x3.; * This makes it much easier to create a viewer grid for common sizes, without needing multiple steps to add rows/columns.; * Text and icons show the expected grid shapes so they should be easy to interpret; * New commands are added to *Detach viewer from the grid* and subsequently to *Attach viewer to the grid*, so that viewers can be moved to their own floating windows and back again. ## PathPlugin & PluginRunner. When making the above changes, it became clear that a major refactoring & simplification of `PathPlugin` and `PluginRunner` was needed. The original problem was that `PluginRunnerFX` proved to be buggy with detached windows, because the `ImageData` being handled was accessed via `PluginRunner.getImageData()`. In most cases that's fine, but `PluginRunnerFX` was always returning the *current* `ImageData` from QuPath, and if this *changed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, ImageData<T> imageData, String arg)`; ```; so that there's no need",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:1215,Modifiability,Plugin,PluginRunnerFX,1215,"opup menu (accessed by right-click on a viewer) now contain commands to set a fixed grid size of viewers: 1x1, 1x2, 2x1, 2x2, 3x3.; * This makes it much easier to create a viewer grid for common sizes, without needing multiple steps to add rows/columns.; * Text and icons show the expected grid shapes so they should be easy to interpret; * New commands are added to *Detach viewer from the grid* and subsequently to *Attach viewer to the grid*, so that viewers can be moved to their own floating windows and back again. ## PathPlugin & PluginRunner. When making the above changes, it became clear that a major refactoring & simplification of `PathPlugin` and `PluginRunner` was needed. The original problem was that `PluginRunnerFX` proved to be buggy with detached windows, because the `ImageData` being handled was accessed via `PluginRunner.getImageData()`. In most cases that's fine, but `PluginRunnerFX` was always returning the *current* `ImageData` from QuPath, and if this *changed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, ImageData<T> imageData, String arg)`; ```; so that there's no need to request the `ImageData` from the plugin runner - and it's possible to ensure this remains unchanged while all the work of the plugin is completex, no matter what might go on in the UI. Early indications are that the code is just si",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:1324,Modifiability,plugin,plugin,1324,"opup menu (accessed by right-click on a viewer) now contain commands to set a fixed grid size of viewers: 1x1, 1x2, 2x1, 2x2, 3x3.; * This makes it much easier to create a viewer grid for common sizes, without needing multiple steps to add rows/columns.; * Text and icons show the expected grid shapes so they should be easy to interpret; * New commands are added to *Detach viewer from the grid* and subsequently to *Attach viewer to the grid*, so that viewers can be moved to their own floating windows and back again. ## PathPlugin & PluginRunner. When making the above changes, it became clear that a major refactoring & simplification of `PathPlugin` and `PluginRunner` was needed. The original problem was that `PluginRunnerFX` proved to be buggy with detached windows, because the `ImageData` being handled was accessed via `PluginRunner.getImageData()`. In most cases that's fine, but `PluginRunnerFX` was always returning the *current* `ImageData` from QuPath, and if this *changed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, ImageData<T> imageData, String arg)`; ```; so that there's no need to request the `ImageData` from the plugin runner - and it's possible to ensure this remains unchanged while all the work of the plugin is completex, no matter what might go on in the UI. Early indications are that the code is just si",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:1615,Modifiability,plugin,plugins,1615,"rows/columns.; * Text and icons show the expected grid shapes so they should be easy to interpret; * New commands are added to *Detach viewer from the grid* and subsequently to *Attach viewer to the grid*, so that viewers can be moved to their own floating windows and back again. ## PathPlugin & PluginRunner. When making the above changes, it became clear that a major refactoring & simplification of `PathPlugin` and `PluginRunner` was needed. The original problem was that `PluginRunnerFX` proved to be buggy with detached windows, because the `ImageData` being handled was accessed via `PluginRunner.getImageData()`. In most cases that's fine, but `PluginRunnerFX` was always returning the *current* `ImageData` from QuPath, and if this *changed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, ImageData<T> imageData, String arg)`; ```; so that there's no need to request the `ImageData` from the plugin runner - and it's possible to ensure this remains unchanged while all the work of the plugin is completex, no matter what might go on in the UI. Early indications are that the code is just simpler and more robust. However, it's still a core change that *could* potentially have broken lots of things, so most analysis-related commands ought to be checked (e.g. cell detection, or anything else involving `PathPlugin`). ## ImageJ, ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:1720,Modifiability,Plugin,PluginRunner,1720," the grid*, so that viewers can be moved to their own floating windows and back again. ## PathPlugin & PluginRunner. When making the above changes, it became clear that a major refactoring & simplification of `PathPlugin` and `PluginRunner` was needed. The original problem was that `PluginRunnerFX` proved to be buggy with detached windows, because the `ImageData` being handled was accessed via `PluginRunner.getImageData()`. In most cases that's fine, but `PluginRunnerFX` was always returning the *current* `ImageData` from QuPath, and if this *changed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, ImageData<T> imageData, String arg)`; ```; so that there's no need to request the `ImageData` from the plugin runner - and it's possible to ensure this remains unchanged while all the work of the plugin is completex, no matter what might go on in the UI. Early indications are that the code is just simpler and more robust. However, it's still a core change that *could* potentially have broken lots of things, so most analysis-related commands ought to be checked (e.g. cell detection, or anything else involving `PathPlugin`). ## ImageJ, macOS & menubars. The ImageJ macro runner was an implementation of `PathPlugin`. When exploring how this was affected, I dug into a longstanding bug since QuPath's beginning: basically, ImageJ an",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:1898,Modifiability,Plugin,PluginRunner,1898,"ctoring & simplification of `PathPlugin` and `PluginRunner` was needed. The original problem was that `PluginRunnerFX` proved to be buggy with detached windows, because the `ImageData` being handled was accessed via `PluginRunner.getImageData()`. In most cases that's fine, but `PluginRunnerFX` was always returning the *current* `ImageData` from QuPath, and if this *changed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, ImageData<T> imageData, String arg)`; ```; so that there's no need to request the `ImageData` from the plugin runner - and it's possible to ensure this remains unchanged while all the work of the plugin is completex, no matter what might go on in the UI. Early indications are that the code is just simpler and more robust. However, it's still a core change that *could* potentially have broken lots of things, so most analysis-related commands ought to be checked (e.g. cell detection, or anything else involving `PathPlugin`). ## ImageJ, macOS & menubars. The ImageJ macro runner was an implementation of `PathPlugin`. When exploring how this was affected, I dug into a longstanding bug since QuPath's beginning: basically, ImageJ and QuPath's menus don't play together nicely on macOS: https://github.com/qupath/qupath/issues/6. Shortcuts/accelerators are particularly badly affected: the QuPath ones either don'",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:1911,Modifiability,plugin,pluginRunner,1911,"ctoring & simplification of `PathPlugin` and `PluginRunner` was needed. The original problem was that `PluginRunnerFX` proved to be buggy with detached windows, because the `ImageData` being handled was accessed via `PluginRunner.getImageData()`. In most cases that's fine, but `PluginRunnerFX` was always returning the *current* `ImageData` from QuPath, and if this *changed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, ImageData<T> imageData, String arg)`; ```; so that there's no need to request the `ImageData` from the plugin runner - and it's possible to ensure this remains unchanged while all the work of the plugin is completex, no matter what might go on in the UI. Early indications are that the code is just simpler and more robust. However, it's still a core change that *could* potentially have broken lots of things, so most analysis-related commands ought to be checked (e.g. cell detection, or anything else involving `PathPlugin`). ## ImageJ, macOS & menubars. The ImageJ macro runner was an implementation of `PathPlugin`. When exploring how this was affected, I dug into a longstanding bug since QuPath's beginning: basically, ImageJ and QuPath's menus don't play together nicely on macOS: https://github.com/qupath/qupath/issues/6. Shortcuts/accelerators are particularly badly affected: the QuPath ones either don'",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:1994,Modifiability,Plugin,PluginRunner,1994,"ndled was accessed via `PluginRunner.getImageData()`. In most cases that's fine, but `PluginRunnerFX` was always returning the *current* `ImageData` from QuPath, and if this *changed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, ImageData<T> imageData, String arg)`; ```; so that there's no need to request the `ImageData` from the plugin runner - and it's possible to ensure this remains unchanged while all the work of the plugin is completex, no matter what might go on in the UI. Early indications are that the code is just simpler and more robust. However, it's still a core change that *could* potentially have broken lots of things, so most analysis-related commands ought to be checked (e.g. cell detection, or anything else involving `PathPlugin`). ## ImageJ, macOS & menubars. The ImageJ macro runner was an implementation of `PathPlugin`. When exploring how this was affected, I dug into a longstanding bug since QuPath's beginning: basically, ImageJ and QuPath's menus don't play together nicely on macOS: https://github.com/qupath/qupath/issues/6. Shortcuts/accelerators are particularly badly affected: the QuPath ones either don't work, or would trigger both the accelerator within QuPath *and* within ImageJ. This PR attempts to finally fix this, by; 1. overriding any system menubar request from QuPath while ImageJ is ru",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:2007,Modifiability,plugin,pluginRunner,2007,"ndled was accessed via `PluginRunner.getImageData()`. In most cases that's fine, but `PluginRunnerFX` was always returning the *current* `ImageData` from QuPath, and if this *changed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, ImageData<T> imageData, String arg)`; ```; so that there's no need to request the `ImageData` from the plugin runner - and it's possible to ensure this remains unchanged while all the work of the plugin is completex, no matter what might go on in the UI. Early indications are that the code is just simpler and more robust. However, it's still a core change that *could* potentially have broken lots of things, so most analysis-related commands ought to be checked (e.g. cell detection, or anything else involving `PathPlugin`). ## ImageJ, macOS & menubars. The ImageJ macro runner was an implementation of `PathPlugin`. When exploring how this was affected, I dug into a longstanding bug since QuPath's beginning: basically, ImageJ and QuPath's menus don't play together nicely on macOS: https://github.com/qupath/qupath/issues/6. Shortcuts/accelerators are particularly badly affected: the QuPath ones either don't work, or would trigger both the accelerator within QuPath *and* within ImageJ. This PR attempts to finally fix this, by; 1. overriding any system menubar request from QuPath while ImageJ is ru",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:2124,Modifiability,plugin,plugin,2124,"ndled was accessed via `PluginRunner.getImageData()`. In most cases that's fine, but `PluginRunnerFX` was always returning the *current* `ImageData` from QuPath, and if this *changed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, ImageData<T> imageData, String arg)`; ```; so that there's no need to request the `ImageData` from the plugin runner - and it's possible to ensure this remains unchanged while all the work of the plugin is completex, no matter what might go on in the UI. Early indications are that the code is just simpler and more robust. However, it's still a core change that *could* potentially have broken lots of things, so most analysis-related commands ought to be checked (e.g. cell detection, or anything else involving `PathPlugin`). ## ImageJ, macOS & menubars. The ImageJ macro runner was an implementation of `PathPlugin`. When exploring how this was affected, I dug into a longstanding bug since QuPath's beginning: basically, ImageJ and QuPath's menus don't play together nicely on macOS: https://github.com/qupath/qupath/issues/6. Shortcuts/accelerators are particularly badly affected: the QuPath ones either don't work, or would trigger both the accelerator within QuPath *and* within ImageJ. This PR attempts to finally fix this, by; 1. overriding any system menubar request from QuPath while ImageJ is ru",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:2217,Modifiability,plugin,plugin,2217,"ndled was accessed via `PluginRunner.getImageData()`. In most cases that's fine, but `PluginRunnerFX` was always returning the *current* `ImageData` from QuPath, and if this *changed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, ImageData<T> imageData, String arg)`; ```; so that there's no need to request the `ImageData` from the plugin runner - and it's possible to ensure this remains unchanged while all the work of the plugin is completex, no matter what might go on in the UI. Early indications are that the code is just simpler and more robust. However, it's still a core change that *could* potentially have broken lots of things, so most analysis-related commands ought to be checked (e.g. cell detection, or anything else involving `PathPlugin`). ## ImageJ, macOS & menubars. The ImageJ macro runner was an implementation of `PathPlugin`. When exploring how this was affected, I dug into a longstanding bug since QuPath's beginning: basically, ImageJ and QuPath's menus don't play together nicely on macOS: https://github.com/qupath/qupath/issues/6. Shortcuts/accelerators are particularly badly affected: the QuPath ones either don't work, or would trigger both the accelerator within QuPath *and* within ImageJ. This PR attempts to finally fix this, by; 1. overriding any system menubar request from QuPath while ImageJ is ru",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:2497,Safety,detect,detection,2497,"ultiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, ImageData<T> imageData, String arg)`; ```; so that there's no need to request the `ImageData` from the plugin runner - and it's possible to ensure this remains unchanged while all the work of the plugin is completex, no matter what might go on in the UI. Early indications are that the code is just simpler and more robust. However, it's still a core change that *could* potentially have broken lots of things, so most analysis-related commands ought to be checked (e.g. cell detection, or anything else involving `PathPlugin`). ## ImageJ, macOS & menubars. The ImageJ macro runner was an implementation of `PathPlugin`. When exploring how this was affected, I dug into a longstanding bug since QuPath's beginning: basically, ImageJ and QuPath's menus don't play together nicely on macOS: https://github.com/qupath/qupath/issues/6. Shortcuts/accelerators are particularly badly affected: the QuPath ones either don't work, or would trigger both the accelerator within QuPath *and* within ImageJ. This PR attempts to finally fix this, by; 1. overriding any system menubar request from QuPath while ImageJ is running, so that QuPath's menu becomes 'demoted' to within the app; 2. blocking ImageJ's last menubar whenever it no longer has any focussed stage (i.e. whenever a JavaFX window is activated). This seems to work on macOS, but the menubar thing failed badly on Windows - so now is *only* applied with Mac. @alanocallaghan @Rylern it would be good if you could check what happens on Linux if yo",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:332,Security,access,accessed,332,"See discussion at https://github.com/qupath/qupath/issues/1317. This PR has become much more extensive and cover a few (unexpectedly) interrelated issues. ## Viewer grids & detached viewers. The PR aims to improve the use of multiple viewers more generally:. * The *View &rarr; Multi-view...* main menu and *Multi-view* popup menu (accessed by right-click on a viewer) now contain commands to set a fixed grid size of viewers: 1x1, 1x2, 2x1, 2x2, 3x3.; * This makes it much easier to create a viewer grid for common sizes, without needing multiple steps to add rows/columns.; * Text and icons show the expected grid shapes so they should be easy to interpret; * New commands are added to *Detach viewer from the grid* and subsequently to *Attach viewer to the grid*, so that viewers can be moved to their own floating windows and back again. ## PathPlugin & PluginRunner. When making the above changes, it became clear that a major refactoring & simplification of `PathPlugin` and `PluginRunner` was needed. The original problem was that `PluginRunnerFX` proved to be buggy with detached windows, because the `ImageData` being handled was accessed via `PluginRunner.getImageData()`. In most cases that's fine, but `PluginRunnerFX` was always returning the *current* `ImageData` from QuPath, and if this *changed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginR",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:1139,Security,access,accessed,1139,"h more extensive and cover a few (unexpectedly) interrelated issues. ## Viewer grids & detached viewers. The PR aims to improve the use of multiple viewers more generally:. * The *View &rarr; Multi-view...* main menu and *Multi-view* popup menu (accessed by right-click on a viewer) now contain commands to set a fixed grid size of viewers: 1x1, 1x2, 2x1, 2x2, 3x3.; * This makes it much easier to create a viewer grid for common sizes, without needing multiple steps to add rows/columns.; * Text and icons show the expected grid shapes so they should be easy to interpret; * New commands are added to *Detach viewer from the grid* and subsequently to *Attach viewer to the grid*, so that viewers can be moved to their own floating windows and back again. ## PathPlugin & PluginRunner. When making the above changes, it became clear that a major refactoring & simplification of `PathPlugin` and `PluginRunner` was needed. The original problem was that `PluginRunnerFX` proved to be buggy with detached windows, because the `ImageData` being handled was accessed via `PluginRunner.getImageData()`. In most cases that's fine, but `PluginRunnerFX` was always returning the *current* `ImageData` from QuPath, and if this *changed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, ImageData<T> imageData, String arg)`; ```; so that there's no need",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:1383,Testability,log,logged,1383,"opup menu (accessed by right-click on a viewer) now contain commands to set a fixed grid size of viewers: 1x1, 1x2, 2x1, 2x2, 3x3.; * This makes it much easier to create a viewer grid for common sizes, without needing multiple steps to add rows/columns.; * Text and icons show the expected grid shapes so they should be easy to interpret; * New commands are added to *Detach viewer from the grid* and subsequently to *Attach viewer to the grid*, so that viewers can be moved to their own floating windows and back again. ## PathPlugin & PluginRunner. When making the above changes, it became clear that a major refactoring & simplification of `PathPlugin` and `PluginRunner` was needed. The original problem was that `PluginRunnerFX` proved to be buggy with detached windows, because the `ImageData` being handled was accessed via `PluginRunner.getImageData()`. In most cases that's fine, but `PluginRunnerFX` was always returning the *current* `ImageData` from QuPath, and if this *changed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, ImageData<T> imageData, String arg)`; ```; so that there's no need to request the `ImageData` from the plugin runner - and it's possible to ensure this remains unchanged while all the work of the plugin is completex, no matter what might go on in the UI. Early indications are that the code is just si",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:1813,Testability,log,logic,1813," the grid*, so that viewers can be moved to their own floating windows and back again. ## PathPlugin & PluginRunner. When making the above changes, it became clear that a major refactoring & simplification of `PathPlugin` and `PluginRunner` was needed. The original problem was that `PluginRunnerFX` proved to be buggy with detached windows, because the `ImageData` being handled was accessed via `PluginRunner.getImageData()`. In most cases that's fine, but `PluginRunnerFX` was always returning the *current* `ImageData` from QuPath, and if this *changed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, ImageData<T> imageData, String arg)`; ```; so that there's no need to request the `ImageData` from the plugin runner - and it's possible to ensure this remains unchanged while all the work of the plugin is completex, no matter what might go on in the UI. Early indications are that the code is just simpler and more robust. However, it's still a core change that *could* potentially have broken lots of things, so most analysis-related commands ought to be checked (e.g. cell detection, or anything else involving `PathPlugin`). ## ImageJ, macOS & menubars. The ImageJ macro runner was an implementation of `PathPlugin`. When exploring how this was affected, I dug into a longstanding bug since QuPath's beginning: basically, ImageJ an",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:913,Usability,clear,clear,913,"See discussion at https://github.com/qupath/qupath/issues/1317. This PR has become much more extensive and cover a few (unexpectedly) interrelated issues. ## Viewer grids & detached viewers. The PR aims to improve the use of multiple viewers more generally:. * The *View &rarr; Multi-view...* main menu and *Multi-view* popup menu (accessed by right-click on a viewer) now contain commands to set a fixed grid size of viewers: 1x1, 1x2, 2x1, 2x2, 3x3.; * This makes it much easier to create a viewer grid for common sizes, without needing multiple steps to add rows/columns.; * Text and icons show the expected grid shapes so they should be easy to interpret; * New commands are added to *Detach viewer from the grid* and subsequently to *Attach viewer to the grid*, so that viewers can be moved to their own floating windows and back again. ## PathPlugin & PluginRunner. When making the above changes, it became clear that a major refactoring & simplification of `PathPlugin` and `PluginRunner` was needed. The original problem was that `PluginRunnerFX` proved to be buggy with detached windows, because the `ImageData` being handled was accessed via `PluginRunner.getImageData()`. In most cases that's fine, but `PluginRunnerFX` was always returning the *current* `ImageData` from QuPath, and if this *changed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginR",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:946,Usability,simpl,simplification,946,"See discussion at https://github.com/qupath/qupath/issues/1317. This PR has become much more extensive and cover a few (unexpectedly) interrelated issues. ## Viewer grids & detached viewers. The PR aims to improve the use of multiple viewers more generally:. * The *View &rarr; Multi-view...* main menu and *Multi-view* popup menu (accessed by right-click on a viewer) now contain commands to set a fixed grid size of viewers: 1x1, 1x2, 2x1, 2x2, 3x3.; * This makes it much easier to create a viewer grid for common sizes, without needing multiple steps to add rows/columns.; * Text and icons show the expected grid shapes so they should be easy to interpret; * New commands are added to *Detach viewer from the grid* and subsequently to *Attach viewer to the grid*, so that viewers can be moved to their own floating windows and back again. ## PathPlugin & PluginRunner. When making the above changes, it became clear that a major refactoring & simplification of `PathPlugin` and `PluginRunner` was needed. The original problem was that `PluginRunnerFX` proved to be buggy with detached windows, because the `ImageData` being handled was accessed via `PluginRunner.getImageData()`. In most cases that's fine, but `PluginRunnerFX` was always returning the *current* `ImageData` from QuPath, and if this *changed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginR",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:1708,Usability,simpl,simplifies,1708," the grid*, so that viewers can be moved to their own floating windows and back again. ## PathPlugin & PluginRunner. When making the above changes, it became clear that a major refactoring & simplification of `PathPlugin` and `PluginRunner` was needed. The original problem was that `PluginRunnerFX` proved to be buggy with detached windows, because the `ImageData` being handled was accessed via `PluginRunner.getImageData()`. In most cases that's fine, but `PluginRunnerFX` was always returning the *current* `ImageData` from QuPath, and if this *changed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, ImageData<T> imageData, String arg)`; ```; so that there's no need to request the `ImageData` from the plugin runner - and it's possible to ensure this remains unchanged while all the work of the plugin is completex, no matter what might go on in the UI. Early indications are that the code is just simpler and more robust. However, it's still a core change that *could* potentially have broken lots of things, so most analysis-related commands ought to be checked (e.g. cell detection, or anything else involving `PathPlugin`). ## ImageJ, macOS & menubars. The ImageJ macro runner was an implementation of `PathPlugin`. When exploring how this was affected, I dug into a longstanding bug since QuPath's beginning: basically, ImageJ an",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:1737,Usability,simpl,simple,1737," the grid*, so that viewers can be moved to their own floating windows and back again. ## PathPlugin & PluginRunner. When making the above changes, it became clear that a major refactoring & simplification of `PathPlugin` and `PluginRunner` was needed. The original problem was that `PluginRunnerFX` proved to be buggy with detached windows, because the `ImageData` being handled was accessed via `PluginRunner.getImageData()`. In most cases that's fine, but `PluginRunnerFX` was always returning the *current* `ImageData` from QuPath, and if this *changed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, ImageData<T> imageData, String arg)`; ```; so that there's no need to request the `ImageData` from the plugin runner - and it's possible to ensure this remains unchanged while all the work of the plugin is completex, no matter what might go on in the UI. Early indications are that the code is just simpler and more robust. However, it's still a core change that *could* potentially have broken lots of things, so most analysis-related commands ought to be checked (e.g. cell detection, or anything else involving `PathPlugin`). ## ImageJ, macOS & menubars. The ImageJ macro runner was an implementation of `PathPlugin`. When exploring how this was affected, I dug into a longstanding bug since QuPath's beginning: basically, ImageJ an",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:2320,Usability,simpl,simpler,2320,"ed* before the plugin was complete (and had fired any hierarchy updates / logged any workflow steps) then exceptions or unexpected behavior could occur. It might conceivably have happened previously when using multiple viewers, but I don't know of any cases where it did - because QuPath locks the UI when plugins run, and this seemed to be working ok. So this PR also includes a new design greatly simplifies `PluginRunner` to simple run tasks in parallel with progress notification - with some special logic for `PathTask` implementations. Alongside that,; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, String arg); ```; has been updated to; ```java; PathPlugin.runPlugin(PluginRunner pluginRunner, ImageData<T> imageData, String arg)`; ```; so that there's no need to request the `ImageData` from the plugin runner - and it's possible to ensure this remains unchanged while all the work of the plugin is completex, no matter what might go on in the UI. Early indications are that the code is just simpler and more robust. However, it's still a core change that *could* potentially have broken lots of things, so most analysis-related commands ought to be checked (e.g. cell detection, or anything else involving `PathPlugin`). ## ImageJ, macOS & menubars. The ImageJ macro runner was an implementation of `PathPlugin`. When exploring how this was affected, I dug into a longstanding bug since QuPath's beginning: basically, ImageJ and QuPath's menus don't play together nicely on macOS: https://github.com/qupath/qupath/issues/6. Shortcuts/accelerators are particularly badly affected: the QuPath ones either don't work, or would trigger both the accelerator within QuPath *and* within ImageJ. This PR attempts to finally fix this, by; 1. overriding any system menubar request from QuPath while ImageJ is running, so that QuPath's menu becomes 'demoted' to within the app; 2. blocking ImageJ's last menubar whenever it no longer has any focussed stage (i.e. whenever a JavaFX window is a",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1318:4488,Usability,undo,undo,4488,". overriding any system menubar request from QuPath while ImageJ is running, so that QuPath's menu becomes 'demoted' to within the app; 2. blocking ImageJ's last menubar whenever it no longer has any focussed stage (i.e. whenever a JavaFX window is activated). This seems to work on macOS, but the menubar thing failed badly on Windows - so now is *only* applied with Mac. @alanocallaghan @Rylern it would be good if you could check what happens on Linux if you:; * Run *Extensions &rarr; ImageJ &rarr; Send snapshot to ImageJ*; * Try to interact and use accelerators with both ImageJ and QuPath windows in focus. For example, pressing `shortcut+L` *should*; * launch the ImageJ command finder if an ImageJ window is in focus; * launch the QuPath command list if a QuPath window is in focus; * *not* launch either the wrong window, or both at once; @finglis if you could also check this on Windows and the older MacBook that's be good, in case I've missed something. ## ImageJ extension toolbar button. The ImageJ extension now appears on the toolbar as a `MenuButton` rather than a `Button`. What it *does* (reveal a popup menu) remains unchanged. The bad thing is that it takes more space. The good thing is that the menu now appears properly even if the toolbar is truncated, and which happens when the window size is small (like on my 13"" Windows laptop screen). ## Revert new system menubar option. Along the way, I had to undo one of the improvements in https://github.com/qupath/qupath/pull/1315 - specifically. * Created new preference to control if the system menubar is used for all windows, the main window only, or no windows. It looked promising, but sadly using the system menubar for the main window and local menubars for other windows failed on macOS, inasmuch as accelerators run on a local menubar would then also be passed to the system menubar... meaning that `shortcut+r` in a script editor would not only run the script, but also offer to reload the data in the current viewer.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318
https://github.com/qupath/qupath/pull/1319:156,Availability,mask,mask,156,"New method (+ corresponding test) to extract pixels from a ROI using OpenCV.; ; It extracts pixels from the input with non-zero values in the corresponding mask, limited to the requested (zero-based) channel index. The mask doesn't have to be multichannel; it could be, but also could be just a single channel that should be applied to all channels.; ; The corresponding unit test generates a binary image of a circle, and then duplicate it to use as the main input image. It checks if the mean value is 1 with the mask, and less than 1 without it.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1319
https://github.com/qupath/qupath/pull/1319:219,Availability,mask,mask,219,"New method (+ corresponding test) to extract pixels from a ROI using OpenCV.; ; It extracts pixels from the input with non-zero values in the corresponding mask, limited to the requested (zero-based) channel index. The mask doesn't have to be multichannel; it could be, but also could be just a single channel that should be applied to all channels.; ; The corresponding unit test generates a binary image of a circle, and then duplicate it to use as the main input image. It checks if the mean value is 1 with the mask, and less than 1 without it.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1319
https://github.com/qupath/qupath/pull/1319:515,Availability,mask,mask,515,"New method (+ corresponding test) to extract pixels from a ROI using OpenCV.; ; It extracts pixels from the input with non-zero values in the corresponding mask, limited to the requested (zero-based) channel index. The mask doesn't have to be multichannel; it could be, but also could be just a single channel that should be applied to all channels.; ; The corresponding unit test generates a binary image of a circle, and then duplicate it to use as the main input image. It checks if the mean value is 1 with the mask, and less than 1 without it.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1319
https://github.com/qupath/qupath/pull/1319:28,Testability,test,test,28,"New method (+ corresponding test) to extract pixels from a ROI using OpenCV.; ; It extracts pixels from the input with non-zero values in the corresponding mask, limited to the requested (zero-based) channel index. The mask doesn't have to be multichannel; it could be, but also could be just a single channel that should be applied to all channels.; ; The corresponding unit test generates a binary image of a circle, and then duplicate it to use as the main input image. It checks if the mean value is 1 with the mask, and less than 1 without it.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1319
https://github.com/qupath/qupath/pull/1319:376,Testability,test,test,376,"New method (+ corresponding test) to extract pixels from a ROI using OpenCV.; ; It extracts pixels from the input with non-zero values in the corresponding mask, limited to the requested (zero-based) channel index. The mask doesn't have to be multichannel; it could be, but also could be just a single channel that should be applied to all channels.; ; The corresponding unit test generates a binary image of a circle, and then duplicate it to use as the main input image. It checks if the mean value is 1 with the mask, and less than 1 without it.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1319
https://github.com/qupath/qupath/issues/1322:203,Availability,down,down-after-first-image,203,"## Bug report. **Describe the bug**; There have been numerous complaints about the performance of pixel classification using batch processing, e.g. * https://forum.image.sc/t/qupath-batch-script-slowing-down-after-first-image/85810; * https://forum.image.sc/t/batch-processing-unusually-slow/49633; * https://forum.image.sc/t/qupath-pixel-classification-script-not-using-availible-resoruces-and-crashing-during-batch-processing/84593. Basically, it can be slow and then also crash at times. **To Reproduce**; I'm basing this report upon forum posts. I don't yet have clear steps to reproduce, but I assume that creating a high-resolution pixel classifier and then applying it across an image via a script would likely do it. **Expected behavior**; Pixel classification is faster, and generally doesn't crash. **Desktop (please complete the following information):**; - OS: Unspecified; - QuPath Version: v0.4.4 (and earlier). **Additional context**; The slowness is likely to be related to the calculations being single-threaded, even when they might be parallelized when run interactively through a viewer. The crashing may be related to the use of OpenCV via JavaCPP - specifically we don't have as much control over memory use as when using Java alone.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322
https://github.com/qupath/qupath/issues/1322:371,Availability,avail,availible-resoruces-and-crashing-during-batch-processing,371,"## Bug report. **Describe the bug**; There have been numerous complaints about the performance of pixel classification using batch processing, e.g. * https://forum.image.sc/t/qupath-batch-script-slowing-down-after-first-image/85810; * https://forum.image.sc/t/batch-processing-unusually-slow/49633; * https://forum.image.sc/t/qupath-pixel-classification-script-not-using-availible-resoruces-and-crashing-during-batch-processing/84593. Basically, it can be slow and then also crash at times. **To Reproduce**; I'm basing this report upon forum posts. I don't yet have clear steps to reproduce, but I assume that creating a high-resolution pixel classifier and then applying it across an image via a script would likely do it. **Expected behavior**; Pixel classification is faster, and generally doesn't crash. **Desktop (please complete the following information):**; - OS: Unspecified; - QuPath Version: v0.4.4 (and earlier). **Additional context**; The slowness is likely to be related to the calculations being single-threaded, even when they might be parallelized when run interactively through a viewer. The crashing may be related to the use of OpenCV via JavaCPP - specifically we don't have as much control over memory use as when using Java alone.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322
https://github.com/qupath/qupath/issues/1322:83,Performance,perform,performance,83,"## Bug report. **Describe the bug**; There have been numerous complaints about the performance of pixel classification using batch processing, e.g. * https://forum.image.sc/t/qupath-batch-script-slowing-down-after-first-image/85810; * https://forum.image.sc/t/batch-processing-unusually-slow/49633; * https://forum.image.sc/t/qupath-pixel-classification-script-not-using-availible-resoruces-and-crashing-during-batch-processing/84593. Basically, it can be slow and then also crash at times. **To Reproduce**; I'm basing this report upon forum posts. I don't yet have clear steps to reproduce, but I assume that creating a high-resolution pixel classifier and then applying it across an image via a script would likely do it. **Expected behavior**; Pixel classification is faster, and generally doesn't crash. **Desktop (please complete the following information):**; - OS: Unspecified; - QuPath Version: v0.4.4 (and earlier). **Additional context**; The slowness is likely to be related to the calculations being single-threaded, even when they might be parallelized when run interactively through a viewer. The crashing may be related to the use of OpenCV via JavaCPP - specifically we don't have as much control over memory use as when using Java alone.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322
https://github.com/qupath/qupath/issues/1322:567,Usability,clear,clear,567,"## Bug report. **Describe the bug**; There have been numerous complaints about the performance of pixel classification using batch processing, e.g. * https://forum.image.sc/t/qupath-batch-script-slowing-down-after-first-image/85810; * https://forum.image.sc/t/batch-processing-unusually-slow/49633; * https://forum.image.sc/t/qupath-pixel-classification-script-not-using-availible-resoruces-and-crashing-during-batch-processing/84593. Basically, it can be slow and then also crash at times. **To Reproduce**; I'm basing this report upon forum posts. I don't yet have clear steps to reproduce, but I assume that creating a high-resolution pixel classifier and then applying it across an image via a script would likely do it. **Expected behavior**; Pixel classification is faster, and generally doesn't crash. **Desktop (please complete the following information):**; - OS: Unspecified; - QuPath Version: v0.4.4 (and earlier). **Additional context**; The slowness is likely to be related to the calculations being single-threaded, even when they might be parallelized when run interactively through a viewer. The crashing may be related to the use of OpenCV via JavaCPP - specifically we don't have as much control over memory use as when using Java alone.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322
https://github.com/qupath/qupath/issues/1324:241,Deployability,release,release,241,"Before submitting your bug report, please check the following:. * [x] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; `Multiple actions registered for Shift+Shortcut+I, will keep Show input display and drop Insert into hierarchy`. **To Reproduce**; Steps to reproduce the behavior:; 1. Launch latest main build; 2. View log. Or, see: https://github.com/search?q=repo%3Aqupath%2Fqupath%20shortcut%2Bshift%2Bi&type=code. **Expected behavior**; No multimapped accelerators. Suggest adding alt to the one that's considered less important. **Desktop (please complete the following information):**; - OS: Linux; - QuPath Version: 0.5.0-SNAPSHOT",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1324
https://github.com/qupath/qupath/issues/1324:437,Deployability,release,release,437,"Before submitting your bug report, please check the following:. * [x] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; `Multiple actions registered for Shift+Shortcut+I, will keep Show input display and drop Insert into hierarchy`. **To Reproduce**; Steps to reproduce the behavior:; 1. Launch latest main build; 2. View log. Or, see: https://github.com/search?q=repo%3Aqupath%2Fqupath%20shortcut%2Bshift%2Bi&type=code. **Expected behavior**; No multimapped accelerators. Suggest adding alt to the one that's considered less important. **Desktop (please complete the following information):**; - OS: Linux; - QuPath Version: 0.5.0-SNAPSHOT",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1324
https://github.com/qupath/qupath/issues/1324:760,Testability,log,log,760,"Before submitting your bug report, please check the following:. * [x] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; `Multiple actions registered for Shift+Shortcut+I, will keep Show input display and drop Insert into hierarchy`. **To Reproduce**; Steps to reproduce the behavior:; 1. Launch latest main build; 2. View log. Or, see: https://github.com/search?q=repo%3Aqupath%2Fqupath%20shortcut%2Bshift%2Bi&type=code. **Expected behavior**; No multimapped accelerators. Suggest adding alt to the one that's considered less important. **Desktop (please complete the following information):**; - OS: Linux; - QuPath Version: 0.5.0-SNAPSHOT",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1324
https://github.com/qupath/qupath/pull/1325:98,Integrability,depend,dependency,98,"This is just proof of concept for the time being, while I check the OpenSlide builds. Removes the dependency on the OpenSlide Jar, and copies the class files almost verbatim. This removes the dependency on openslide-java, so we just need libopenslide to be on the java library path. Usage: should be unchanged. Speed: may be marginally slower, though with multiple threads and caching this doesn't seem noticable.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1325
https://github.com/qupath/qupath/pull/1325:192,Integrability,depend,dependency,192,"This is just proof of concept for the time being, while I check the OpenSlide builds. Removes the dependency on the OpenSlide Jar, and copies the class files almost verbatim. This removes the dependency on openslide-java, so we just need libopenslide to be on the java library path. Usage: should be unchanged. Speed: may be marginally slower, though with multiple threads and caching this doesn't seem noticable.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1325
https://github.com/qupath/qupath/pull/1328:208,Energy Efficiency,Reduce,Reduced,208,"* Fix https://github.com/qupath/qupath/issues/1263; * Fix https://github.com/qupath/qupath/issues/1309 (by using AWT instead of JavaFX for screenshot); * Address https://github.com/qupath/qupath/issues/1246. Reduced duplication in the code used to display slide labels. This is now rewritten, and adds an option to specify the saturation percentage for non-8-bit images. This can help with making label content visible in awkward cases (e.g. many .czi images).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1328
https://github.com/qupath/qupath/pull/1331:88,Security,access,access,88,"Fixes to coincide with https://github.com/qupath/qupath-fxtras/pull/11 Deprecate direct access to the `Preferences` object, since this can be invalidated by a call to reset (and then stops being usable).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1331
https://github.com/qupath/qupath/pull/1331:195,Usability,usab,usable,195,"Fixes to coincide with https://github.com/qupath/qupath-fxtras/pull/11 Deprecate direct access to the `Preferences` object, since this can be invalidated by a call to reset (and then stops being usable).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1331
https://github.com/qupath/qupath/pull/1332:27,Energy Efficiency,reduce,reduce,27,"Numerous changes aiming to reduce memory use, including:; * Preventing objects (and object hierarchies) from being retained for a time after an image has been closed; * Improving the efficiency of `ImageOps` with padding; * Parallelising pixel classification measurements. The last two of these should improve pixel classification generally, and making measurements in particular. It is the proposed fix for https://github.com/qupath/qupath/issues/1322. I obtained some rough timings using *Run for project* with 3 images and an extreme pixel classifier with 250 output channels:. ```groovy; setImageType('BRIGHTFIELD_H_E');; setColorDeconvolutionStains('{""Name"" : ""H&E default"", ""Stain 1"" : ""Hematoxylin"", ""Values 1"" : ""0.65111 0.70119 0.29049"", ""Stain 2"" : ""Eosin"", ""Values 2"" : ""0.2159 0.8012 0.5581"", ""Background"" : "" 255 255 255""}');; clearAllObjects();; resetSelection();; //createAnnotationsFromPixelClassifier(""My threshold"", 0.0, 0.0, ""INCLUDE_IGNORED"", ""SPLIT"") // Alternative option; createAnnotationsFromPixelClassifier(""My threshold"", 0.0, 0.0, ""INCLUDE_IGNORED""); selectAnnotations();; addPixelClassifierMeasurements(""Busy classifier"", ""Busy classifier""); println getAnnotationObjects().measurements; ```. With larger images / ROIs, the changes can result in huge speed improvements (tested using M1 Max, macOS 13.5.2):. ### v0.5.0-SNAPSHOT. ```; INFO: Starting script at Fri Sep 15 13:54:32 BST 2023; INFO: [[Busy classifier: Stroma %:57.11750411987305, Busy classifier: Stroma area µm^2:3.7282948E7, Busy classifier: Tumor %:42.88249588012695, Busy classifier: Tumor area µm^2:2.799117E7]]; INFO: Total run time: 14.97 seconds; INFO: Starting script at Fri Sep 15 13:54:47 BST 2023; INFO: [[Busy classifier: Stroma %:24.72903823852539, Busy classifier: Stroma area µm^2:122532.3984375, Busy classifier: Tumor %:75.27095794677734, Busy classifier: Tumor area µm^2:372967.65625]]; INFO: Total run time: 0.42 seconds; INFO: Starting script at Fri Sep 15 13:54:48 BST 2023; INFO: [[Busy cl",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1332
https://github.com/qupath/qupath/pull/1332:1298,Testability,test,tested,1298,"The last two of these should improve pixel classification generally, and making measurements in particular. It is the proposed fix for https://github.com/qupath/qupath/issues/1322. I obtained some rough timings using *Run for project* with 3 images and an extreme pixel classifier with 250 output channels:. ```groovy; setImageType('BRIGHTFIELD_H_E');; setColorDeconvolutionStains('{""Name"" : ""H&E default"", ""Stain 1"" : ""Hematoxylin"", ""Values 1"" : ""0.65111 0.70119 0.29049"", ""Stain 2"" : ""Eosin"", ""Values 2"" : ""0.2159 0.8012 0.5581"", ""Background"" : "" 255 255 255""}');; clearAllObjects();; resetSelection();; //createAnnotationsFromPixelClassifier(""My threshold"", 0.0, 0.0, ""INCLUDE_IGNORED"", ""SPLIT"") // Alternative option; createAnnotationsFromPixelClassifier(""My threshold"", 0.0, 0.0, ""INCLUDE_IGNORED""); selectAnnotations();; addPixelClassifierMeasurements(""Busy classifier"", ""Busy classifier""); println getAnnotationObjects().measurements; ```. With larger images / ROIs, the changes can result in huge speed improvements (tested using M1 Max, macOS 13.5.2):. ### v0.5.0-SNAPSHOT. ```; INFO: Starting script at Fri Sep 15 13:54:32 BST 2023; INFO: [[Busy classifier: Stroma %:57.11750411987305, Busy classifier: Stroma area µm^2:3.7282948E7, Busy classifier: Tumor %:42.88249588012695, Busy classifier: Tumor area µm^2:2.799117E7]]; INFO: Total run time: 14.97 seconds; INFO: Starting script at Fri Sep 15 13:54:47 BST 2023; INFO: [[Busy classifier: Stroma %:24.72903823852539, Busy classifier: Stroma area µm^2:122532.3984375, Busy classifier: Tumor %:75.27095794677734, Busy classifier: Tumor area µm^2:372967.65625]]; INFO: Total run time: 0.42 seconds; INFO: Starting script at Fri Sep 15 13:54:48 BST 2023; INFO: [[Busy classifier: Stroma %:42.06702423095703, Busy classifier: Stroma area µm^2:2.7533646E7, Busy classifier: Tumor %:57.93297576904297, Busy classifier: Tumor area µm^2:3.7918208E7]]; INFO: Total run time: 9.97 seconds; ```. ## v0.4.4; ```; INFO: Starting script at Fri Sep 15 13:",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1332
https://github.com/qupath/qupath/pull/1332:840,Usability,clear,clearAllObjects,840,"Numerous changes aiming to reduce memory use, including:; * Preventing objects (and object hierarchies) from being retained for a time after an image has been closed; * Improving the efficiency of `ImageOps` with padding; * Parallelising pixel classification measurements. The last two of these should improve pixel classification generally, and making measurements in particular. It is the proposed fix for https://github.com/qupath/qupath/issues/1322. I obtained some rough timings using *Run for project* with 3 images and an extreme pixel classifier with 250 output channels:. ```groovy; setImageType('BRIGHTFIELD_H_E');; setColorDeconvolutionStains('{""Name"" : ""H&E default"", ""Stain 1"" : ""Hematoxylin"", ""Values 1"" : ""0.65111 0.70119 0.29049"", ""Stain 2"" : ""Eosin"", ""Values 2"" : ""0.2159 0.8012 0.5581"", ""Background"" : "" 255 255 255""}');; clearAllObjects();; resetSelection();; //createAnnotationsFromPixelClassifier(""My threshold"", 0.0, 0.0, ""INCLUDE_IGNORED"", ""SPLIT"") // Alternative option; createAnnotationsFromPixelClassifier(""My threshold"", 0.0, 0.0, ""INCLUDE_IGNORED""); selectAnnotations();; addPixelClassifierMeasurements(""Busy classifier"", ""Busy classifier""); println getAnnotationObjects().measurements; ```. With larger images / ROIs, the changes can result in huge speed improvements (tested using M1 Max, macOS 13.5.2):. ### v0.5.0-SNAPSHOT. ```; INFO: Starting script at Fri Sep 15 13:54:32 BST 2023; INFO: [[Busy classifier: Stroma %:57.11750411987305, Busy classifier: Stroma area µm^2:3.7282948E7, Busy classifier: Tumor %:42.88249588012695, Busy classifier: Tumor area µm^2:2.799117E7]]; INFO: Total run time: 14.97 seconds; INFO: Starting script at Fri Sep 15 13:54:47 BST 2023; INFO: [[Busy classifier: Stroma %:24.72903823852539, Busy classifier: Stroma area µm^2:122532.3984375, Busy classifier: Tumor %:75.27095794677734, Busy classifier: Tumor area µm^2:372967.65625]]; INFO: Total run time: 0.42 seconds; INFO: Starting script at Fri Sep 15 13:54:48 BST 2023; INFO: [[Busy cl",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1332
https://github.com/qupath/qupath/pull/1335:294,Availability,avail,available,294,"Main changes:. * Optionally sync brightness/contrast settings across viewers; * Feature request from @zmikulski & @saramcardle; * Makes it easier to adjust colors and sliders with multiple images open simultaneously.; * Only has an impact if the images are 'compatible', i.e. the same channels available in the same order, and the ; * Support viewing log histogram counts; * Make it much easier to work with histograms that have a tall peak; * Rename *Keep settings* option to *Apply to similar images*; * Make it more obvious which channel is selected & prevent adjusting sliders if this is hidden; * Refactor histogram code to make it more reusable. ![BC log](https://github.com/qupath/qupath/assets/4690904/ec63bae3-dd33-4aed-aedb-5badb57a12b1)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1335
https://github.com/qupath/qupath/pull/1335:602,Modifiability,Refactor,Refactor,602,"Main changes:. * Optionally sync brightness/contrast settings across viewers; * Feature request from @zmikulski & @saramcardle; * Makes it easier to adjust colors and sliders with multiple images open simultaneously.; * Only has an impact if the images are 'compatible', i.e. the same channels available in the same order, and the ; * Support viewing log histogram counts; * Make it much easier to work with histograms that have a tall peak; * Rename *Keep settings* option to *Apply to similar images*; * Make it more obvious which channel is selected & prevent adjusting sliders if this is hidden; * Refactor histogram code to make it more reusable. ![BC log](https://github.com/qupath/qupath/assets/4690904/ec63bae3-dd33-4aed-aedb-5badb57a12b1)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1335
https://github.com/qupath/qupath/pull/1335:351,Testability,log,log,351,"Main changes:. * Optionally sync brightness/contrast settings across viewers; * Feature request from @zmikulski & @saramcardle; * Makes it easier to adjust colors and sliders with multiple images open simultaneously.; * Only has an impact if the images are 'compatible', i.e. the same channels available in the same order, and the ; * Support viewing log histogram counts; * Make it much easier to work with histograms that have a tall peak; * Rename *Keep settings* option to *Apply to similar images*; * Make it more obvious which channel is selected & prevent adjusting sliders if this is hidden; * Refactor histogram code to make it more reusable. ![BC log](https://github.com/qupath/qupath/assets/4690904/ec63bae3-dd33-4aed-aedb-5badb57a12b1)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1335
https://github.com/qupath/qupath/pull/1335:657,Testability,log,log,657,"Main changes:. * Optionally sync brightness/contrast settings across viewers; * Feature request from @zmikulski & @saramcardle; * Makes it easier to adjust colors and sliders with multiple images open simultaneously.; * Only has an impact if the images are 'compatible', i.e. the same channels available in the same order, and the ; * Support viewing log histogram counts; * Make it much easier to work with histograms that have a tall peak; * Rename *Keep settings* option to *Apply to similar images*; * Make it more obvious which channel is selected & prevent adjusting sliders if this is hidden; * Refactor histogram code to make it more reusable. ![BC log](https://github.com/qupath/qupath/assets/4690904/ec63bae3-dd33-4aed-aedb-5badb57a12b1)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1335
https://github.com/qupath/qupath/pull/1336:157,Availability,error,errors,157,Initial support for commands that can result in a badge appearing on a toolbar button (or other node). The eventual plan is to use this to draw attention to errors/warnings that may not otherwise be visible to the user.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1336
https://github.com/qupath/qupath/issues/1337:314,Deployability,install,installed,314,## Feature request. **Is your feature request related to a problem? Please describe.**; Qupath Version label on macOS. Currently QuPath will display as version 1 if you inspect the App in Finder. As an Apple admin managing Apple devices in an instituion it is not possible to discover which versions of QuPath are installed on our devices. All installations of QuPath will be on version 1 and not 0.4.3 / 0.4.4 etc. Ensuring all users are running the latest version is not possible. **Describe the solution you'd like**; In future updates of QuPath for macOS it would be great if the **info.plist** file has the correct version added to the Key **CFBundleShortVersionString**; The following command could be run prior to packaging updated installers:; `defaults write /Applications/QuPath.app/Contents/Info.plist CFBundleShortVersionString 0.4.4`. **Describe alternatives you've considered**; After deploying the PKG installer I have considered running a script to run; `defaults write /Applications/QuPath.app/Contents/Info.plist CFBundleShortVersionString 0.4.4`. Edit: you will need to change the permissions of the file after running above command as it will be 600 and should be 664; `sudo chmod 664 /Applications/QuPath.app/Contents/Info.plist`. **Additional context**; Currently:; ![Current versioning](https://github.com/qupath/qupath/assets/47144936/6cb3af89-451d-4a0d-bbd0-7b82707d61df); Desired outcome:; ![Correct versioning](https://github.com/qupath/qupath/assets/47144936/5ea74946-5b54-4b87-93b2-2cf94ed99b22),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337
https://github.com/qupath/qupath/issues/1337:344,Deployability,install,installations,344,## Feature request. **Is your feature request related to a problem? Please describe.**; Qupath Version label on macOS. Currently QuPath will display as version 1 if you inspect the App in Finder. As an Apple admin managing Apple devices in an instituion it is not possible to discover which versions of QuPath are installed on our devices. All installations of QuPath will be on version 1 and not 0.4.3 / 0.4.4 etc. Ensuring all users are running the latest version is not possible. **Describe the solution you'd like**; In future updates of QuPath for macOS it would be great if the **info.plist** file has the correct version added to the Key **CFBundleShortVersionString**; The following command could be run prior to packaging updated installers:; `defaults write /Applications/QuPath.app/Contents/Info.plist CFBundleShortVersionString 0.4.4`. **Describe alternatives you've considered**; After deploying the PKG installer I have considered running a script to run; `defaults write /Applications/QuPath.app/Contents/Info.plist CFBundleShortVersionString 0.4.4`. Edit: you will need to change the permissions of the file after running above command as it will be 600 and should be 664; `sudo chmod 664 /Applications/QuPath.app/Contents/Info.plist`. **Additional context**; Currently:; ![Current versioning](https://github.com/qupath/qupath/assets/47144936/6cb3af89-451d-4a0d-bbd0-7b82707d61df); Desired outcome:; ![Correct versioning](https://github.com/qupath/qupath/assets/47144936/5ea74946-5b54-4b87-93b2-2cf94ed99b22),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337
https://github.com/qupath/qupath/issues/1337:531,Deployability,update,updates,531,## Feature request. **Is your feature request related to a problem? Please describe.**; Qupath Version label on macOS. Currently QuPath will display as version 1 if you inspect the App in Finder. As an Apple admin managing Apple devices in an instituion it is not possible to discover which versions of QuPath are installed on our devices. All installations of QuPath will be on version 1 and not 0.4.3 / 0.4.4 etc. Ensuring all users are running the latest version is not possible. **Describe the solution you'd like**; In future updates of QuPath for macOS it would be great if the **info.plist** file has the correct version added to the Key **CFBundleShortVersionString**; The following command could be run prior to packaging updated installers:; `defaults write /Applications/QuPath.app/Contents/Info.plist CFBundleShortVersionString 0.4.4`. **Describe alternatives you've considered**; After deploying the PKG installer I have considered running a script to run; `defaults write /Applications/QuPath.app/Contents/Info.plist CFBundleShortVersionString 0.4.4`. Edit: you will need to change the permissions of the file after running above command as it will be 600 and should be 664; `sudo chmod 664 /Applications/QuPath.app/Contents/Info.plist`. **Additional context**; Currently:; ![Current versioning](https://github.com/qupath/qupath/assets/47144936/6cb3af89-451d-4a0d-bbd0-7b82707d61df); Desired outcome:; ![Correct versioning](https://github.com/qupath/qupath/assets/47144936/5ea74946-5b54-4b87-93b2-2cf94ed99b22),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337
https://github.com/qupath/qupath/issues/1337:731,Deployability,update,updated,731,## Feature request. **Is your feature request related to a problem? Please describe.**; Qupath Version label on macOS. Currently QuPath will display as version 1 if you inspect the App in Finder. As an Apple admin managing Apple devices in an instituion it is not possible to discover which versions of QuPath are installed on our devices. All installations of QuPath will be on version 1 and not 0.4.3 / 0.4.4 etc. Ensuring all users are running the latest version is not possible. **Describe the solution you'd like**; In future updates of QuPath for macOS it would be great if the **info.plist** file has the correct version added to the Key **CFBundleShortVersionString**; The following command could be run prior to packaging updated installers:; `defaults write /Applications/QuPath.app/Contents/Info.plist CFBundleShortVersionString 0.4.4`. **Describe alternatives you've considered**; After deploying the PKG installer I have considered running a script to run; `defaults write /Applications/QuPath.app/Contents/Info.plist CFBundleShortVersionString 0.4.4`. Edit: you will need to change the permissions of the file after running above command as it will be 600 and should be 664; `sudo chmod 664 /Applications/QuPath.app/Contents/Info.plist`. **Additional context**; Currently:; ![Current versioning](https://github.com/qupath/qupath/assets/47144936/6cb3af89-451d-4a0d-bbd0-7b82707d61df); Desired outcome:; ![Correct versioning](https://github.com/qupath/qupath/assets/47144936/5ea74946-5b54-4b87-93b2-2cf94ed99b22),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337
https://github.com/qupath/qupath/issues/1337:739,Deployability,install,installers,739,## Feature request. **Is your feature request related to a problem? Please describe.**; Qupath Version label on macOS. Currently QuPath will display as version 1 if you inspect the App in Finder. As an Apple admin managing Apple devices in an instituion it is not possible to discover which versions of QuPath are installed on our devices. All installations of QuPath will be on version 1 and not 0.4.3 / 0.4.4 etc. Ensuring all users are running the latest version is not possible. **Describe the solution you'd like**; In future updates of QuPath for macOS it would be great if the **info.plist** file has the correct version added to the Key **CFBundleShortVersionString**; The following command could be run prior to packaging updated installers:; `defaults write /Applications/QuPath.app/Contents/Info.plist CFBundleShortVersionString 0.4.4`. **Describe alternatives you've considered**; After deploying the PKG installer I have considered running a script to run; `defaults write /Applications/QuPath.app/Contents/Info.plist CFBundleShortVersionString 0.4.4`. Edit: you will need to change the permissions of the file after running above command as it will be 600 and should be 664; `sudo chmod 664 /Applications/QuPath.app/Contents/Info.plist`. **Additional context**; Currently:; ![Current versioning](https://github.com/qupath/qupath/assets/47144936/6cb3af89-451d-4a0d-bbd0-7b82707d61df); Desired outcome:; ![Correct versioning](https://github.com/qupath/qupath/assets/47144936/5ea74946-5b54-4b87-93b2-2cf94ed99b22),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337
https://github.com/qupath/qupath/issues/1337:899,Deployability,deploy,deploying,899,## Feature request. **Is your feature request related to a problem? Please describe.**; Qupath Version label on macOS. Currently QuPath will display as version 1 if you inspect the App in Finder. As an Apple admin managing Apple devices in an instituion it is not possible to discover which versions of QuPath are installed on our devices. All installations of QuPath will be on version 1 and not 0.4.3 / 0.4.4 etc. Ensuring all users are running the latest version is not possible. **Describe the solution you'd like**; In future updates of QuPath for macOS it would be great if the **info.plist** file has the correct version added to the Key **CFBundleShortVersionString**; The following command could be run prior to packaging updated installers:; `defaults write /Applications/QuPath.app/Contents/Info.plist CFBundleShortVersionString 0.4.4`. **Describe alternatives you've considered**; After deploying the PKG installer I have considered running a script to run; `defaults write /Applications/QuPath.app/Contents/Info.plist CFBundleShortVersionString 0.4.4`. Edit: you will need to change the permissions of the file after running above command as it will be 600 and should be 664; `sudo chmod 664 /Applications/QuPath.app/Contents/Info.plist`. **Additional context**; Currently:; ![Current versioning](https://github.com/qupath/qupath/assets/47144936/6cb3af89-451d-4a0d-bbd0-7b82707d61df); Desired outcome:; ![Correct versioning](https://github.com/qupath/qupath/assets/47144936/5ea74946-5b54-4b87-93b2-2cf94ed99b22),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337
https://github.com/qupath/qupath/issues/1337:917,Deployability,install,installer,917,## Feature request. **Is your feature request related to a problem? Please describe.**; Qupath Version label on macOS. Currently QuPath will display as version 1 if you inspect the App in Finder. As an Apple admin managing Apple devices in an instituion it is not possible to discover which versions of QuPath are installed on our devices. All installations of QuPath will be on version 1 and not 0.4.3 / 0.4.4 etc. Ensuring all users are running the latest version is not possible. **Describe the solution you'd like**; In future updates of QuPath for macOS it would be great if the **info.plist** file has the correct version added to the Key **CFBundleShortVersionString**; The following command could be run prior to packaging updated installers:; `defaults write /Applications/QuPath.app/Contents/Info.plist CFBundleShortVersionString 0.4.4`. **Describe alternatives you've considered**; After deploying the PKG installer I have considered running a script to run; `defaults write /Applications/QuPath.app/Contents/Info.plist CFBundleShortVersionString 0.4.4`. Edit: you will need to change the permissions of the file after running above command as it will be 600 and should be 664; `sudo chmod 664 /Applications/QuPath.app/Contents/Info.plist`. **Additional context**; Currently:; ![Current versioning](https://github.com/qupath/qupath/assets/47144936/6cb3af89-451d-4a0d-bbd0-7b82707d61df); Desired outcome:; ![Correct versioning](https://github.com/qupath/qupath/assets/47144936/5ea74946-5b54-4b87-93b2-2cf94ed99b22),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337
https://github.com/qupath/qupath/pull/1340:312,Deployability,toggle,toggle,312,Combined summary of the main v0.5.0 changes I can remember (along with general UI adjustments). * Save/restore display settings in projects; * Filter the channel names by text or regular expressions; * Optionally view log counts for channel histograms; * For multi-channel (non-RGB images):; * Better support to toggle channels on/off; * Remember previous selection when switching between grayscale & color; * More quickly change channel colors (the square icon is now a color picker). (Plus many other internal changes and a major refactorization / simplification of the associated codebase to make this possible),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1340
https://github.com/qupath/qupath/pull/1340:532,Modifiability,refactor,refactorization,532,Combined summary of the main v0.5.0 changes I can remember (along with general UI adjustments). * Save/restore display settings in projects; * Filter the channel names by text or regular expressions; * Optionally view log counts for channel histograms; * For multi-channel (non-RGB images):; * Better support to toggle channels on/off; * Remember previous selection when switching between grayscale & color; * More quickly change channel colors (the square icon is now a color picker). (Plus many other internal changes and a major refactorization / simplification of the associated codebase to make this possible),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1340
https://github.com/qupath/qupath/pull/1340:218,Testability,log,log,218,Combined summary of the main v0.5.0 changes I can remember (along with general UI adjustments). * Save/restore display settings in projects; * Filter the channel names by text or regular expressions; * Optionally view log counts for channel histograms; * For multi-channel (non-RGB images):; * Better support to toggle channels on/off; * Remember previous selection when switching between grayscale & color; * More quickly change channel colors (the square icon is now a color picker). (Plus many other internal changes and a major refactorization / simplification of the associated codebase to make this possible),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1340
https://github.com/qupath/qupath/pull/1340:550,Usability,simpl,simplification,550,Combined summary of the main v0.5.0 changes I can remember (along with general UI adjustments). * Save/restore display settings in projects; * Filter the channel names by text or regular expressions; * Optionally view log counts for channel histograms; * For multi-channel (non-RGB images):; * Better support to toggle channels on/off; * Remember previous selection when switching between grayscale & color; * More quickly change channel colors (the square icon is now a color picker). (Plus many other internal changes and a major refactorization / simplification of the associated codebase to make this possible),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1340
https://github.com/qupath/qupath/pull/1341:65,Availability,error,errors,65,"Show a small badge in the log toolbar button to try attention to errors. This is intended to be useful whenever the log viewer is not open, but the user may need to see an error reported there. Also set the minimum size for the main QuPath window, because @alanocallaghan had a point. ![error-badges](https://github.com/qupath/qupath/assets/4690904/e073b3e3-0a62-41dd-87e9-4b3991284f8b)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1341
https://github.com/qupath/qupath/pull/1341:172,Availability,error,error,172,"Show a small badge in the log toolbar button to try attention to errors. This is intended to be useful whenever the log viewer is not open, but the user may need to see an error reported there. Also set the minimum size for the main QuPath window, because @alanocallaghan had a point. ![error-badges](https://github.com/qupath/qupath/assets/4690904/e073b3e3-0a62-41dd-87e9-4b3991284f8b)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1341
https://github.com/qupath/qupath/pull/1341:287,Availability,error,error-badges,287,"Show a small badge in the log toolbar button to try attention to errors. This is intended to be useful whenever the log viewer is not open, but the user may need to see an error reported there. Also set the minimum size for the main QuPath window, because @alanocallaghan had a point. ![error-badges](https://github.com/qupath/qupath/assets/4690904/e073b3e3-0a62-41dd-87e9-4b3991284f8b)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1341
https://github.com/qupath/qupath/pull/1341:26,Testability,log,log,26,"Show a small badge in the log toolbar button to try attention to errors. This is intended to be useful whenever the log viewer is not open, but the user may need to see an error reported there. Also set the minimum size for the main QuPath window, because @alanocallaghan had a point. ![error-badges](https://github.com/qupath/qupath/assets/4690904/e073b3e3-0a62-41dd-87e9-4b3991284f8b)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1341
https://github.com/qupath/qupath/pull/1341:116,Testability,log,log,116,"Show a small badge in the log toolbar button to try attention to errors. This is intended to be useful whenever the log viewer is not open, but the user may need to see an error reported there. Also set the minimum size for the main QuPath window, because @alanocallaghan had a point. ![error-badges](https://github.com/qupath/qupath/assets/4690904/e073b3e3-0a62-41dd-87e9-4b3991284f8b)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1341
https://github.com/qupath/qupath/pull/1342:862,Availability,Down,Downloading,862,"Features:. - Display name, description, version; - Add extensions from a github repo[^1]; - Drag & drop repo URLs to install[^2]; - Remove and update[^3] extensions; - Open containing folder. Other changes:. - Make extensions `Map` an `Observable`; - Slightly change ""no newer version"" message, because 0.4.4 is not newer than 0.4.4 (for example); - Set minimum dimensions on welcome stage. Questionable:. - New Pane class as a (static) inner class of ExtensionManager, could be separate.; - Use of FXML for `ExtensionListCellVBox` --- it's easier for me to make sensible layouts with ML, but it also seems convoluted for a small class; - Existing ""Installed extensions"" pane distinguishes between ImageServer providers and Extensions, this one doesn't (which I think is fine, but I could easily add a wrapper class like the old `QuPathExtensionEntry` class.; - Downloading code located in DragDropImportHandler, seems like it should be in a Utils class instead. [^1]: If the repo follows some conventions; [^2]: ...hopefully, if the repo follows some conventions...; [^3]: if the extension class implements GitHubProject",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342
https://github.com/qupath/qupath/pull/1342:117,Deployability,install,install,117,"Features:. - Display name, description, version; - Add extensions from a github repo[^1]; - Drag & drop repo URLs to install[^2]; - Remove and update[^3] extensions; - Open containing folder. Other changes:. - Make extensions `Map` an `Observable`; - Slightly change ""no newer version"" message, because 0.4.4 is not newer than 0.4.4 (for example); - Set minimum dimensions on welcome stage. Questionable:. - New Pane class as a (static) inner class of ExtensionManager, could be separate.; - Use of FXML for `ExtensionListCellVBox` --- it's easier for me to make sensible layouts with ML, but it also seems convoluted for a small class; - Existing ""Installed extensions"" pane distinguishes between ImageServer providers and Extensions, this one doesn't (which I think is fine, but I could easily add a wrapper class like the old `QuPathExtensionEntry` class.; - Downloading code located in DragDropImportHandler, seems like it should be in a Utils class instead. [^1]: If the repo follows some conventions; [^2]: ...hopefully, if the repo follows some conventions...; [^3]: if the extension class implements GitHubProject",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342
https://github.com/qupath/qupath/pull/1342:143,Deployability,update,update,143,"Features:. - Display name, description, version; - Add extensions from a github repo[^1]; - Drag & drop repo URLs to install[^2]; - Remove and update[^3] extensions; - Open containing folder. Other changes:. - Make extensions `Map` an `Observable`; - Slightly change ""no newer version"" message, because 0.4.4 is not newer than 0.4.4 (for example); - Set minimum dimensions on welcome stage. Questionable:. - New Pane class as a (static) inner class of ExtensionManager, could be separate.; - Use of FXML for `ExtensionListCellVBox` --- it's easier for me to make sensible layouts with ML, but it also seems convoluted for a small class; - Existing ""Installed extensions"" pane distinguishes between ImageServer providers and Extensions, this one doesn't (which I think is fine, but I could easily add a wrapper class like the old `QuPathExtensionEntry` class.; - Downloading code located in DragDropImportHandler, seems like it should be in a Utils class instead. [^1]: If the repo follows some conventions; [^2]: ...hopefully, if the repo follows some conventions...; [^3]: if the extension class implements GitHubProject",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342
https://github.com/qupath/qupath/pull/1342:649,Deployability,Install,Installed,649,"Features:. - Display name, description, version; - Add extensions from a github repo[^1]; - Drag & drop repo URLs to install[^2]; - Remove and update[^3] extensions; - Open containing folder. Other changes:. - Make extensions `Map` an `Observable`; - Slightly change ""no newer version"" message, because 0.4.4 is not newer than 0.4.4 (for example); - Set minimum dimensions on welcome stage. Questionable:. - New Pane class as a (static) inner class of ExtensionManager, could be separate.; - Use of FXML for `ExtensionListCellVBox` --- it's easier for me to make sensible layouts with ML, but it also seems convoluted for a small class; - Existing ""Installed extensions"" pane distinguishes between ImageServer providers and Extensions, this one doesn't (which I think is fine, but I could easily add a wrapper class like the old `QuPathExtensionEntry` class.; - Downloading code located in DragDropImportHandler, seems like it should be in a Utils class instead. [^1]: If the repo follows some conventions; [^2]: ...hopefully, if the repo follows some conventions...; [^3]: if the extension class implements GitHubProject",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342
https://github.com/qupath/qupath/pull/1342:286,Integrability,message,message,286,"Features:. - Display name, description, version; - Add extensions from a github repo[^1]; - Drag & drop repo URLs to install[^2]; - Remove and update[^3] extensions; - Open containing folder. Other changes:. - Make extensions `Map` an `Observable`; - Slightly change ""no newer version"" message, because 0.4.4 is not newer than 0.4.4 (for example); - Set minimum dimensions on welcome stage. Questionable:. - New Pane class as a (static) inner class of ExtensionManager, could be separate.; - Use of FXML for `ExtensionListCellVBox` --- it's easier for me to make sensible layouts with ML, but it also seems convoluted for a small class; - Existing ""Installed extensions"" pane distinguishes between ImageServer providers and Extensions, this one doesn't (which I think is fine, but I could easily add a wrapper class like the old `QuPathExtensionEntry` class.; - Downloading code located in DragDropImportHandler, seems like it should be in a Utils class instead. [^1]: If the repo follows some conventions; [^2]: ...hopefully, if the repo follows some conventions...; [^3]: if the extension class implements GitHubProject",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342
https://github.com/qupath/qupath/pull/1342:802,Integrability,wrap,wrapper,802,"Features:. - Display name, description, version; - Add extensions from a github repo[^1]; - Drag & drop repo URLs to install[^2]; - Remove and update[^3] extensions; - Open containing folder. Other changes:. - Make extensions `Map` an `Observable`; - Slightly change ""no newer version"" message, because 0.4.4 is not newer than 0.4.4 (for example); - Set minimum dimensions on welcome stage. Questionable:. - New Pane class as a (static) inner class of ExtensionManager, could be separate.; - Use of FXML for `ExtensionListCellVBox` --- it's easier for me to make sensible layouts with ML, but it also seems convoluted for a small class; - Existing ""Installed extensions"" pane distinguishes between ImageServer providers and Extensions, this one doesn't (which I think is fine, but I could easily add a wrapper class like the old `QuPathExtensionEntry` class.; - Downloading code located in DragDropImportHandler, seems like it should be in a Utils class instead. [^1]: If the repo follows some conventions; [^2]: ...hopefully, if the repo follows some conventions...; [^3]: if the extension class implements GitHubProject",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342
https://github.com/qupath/qupath/pull/1343:657,Availability,failure,failure,657,"Fixes for; * https://github.com/qupath/qupath/issues/1265; * https://github.com/qupath/qupath/issues/1245; * https://github.com/qupath/qupath/issues/1249. Also improve image opening behavior... or non-opening when it fails ([here](https://github.com/qupath/qupath/commit/4b4955cea256d70272e96f7714cafe6e1a8b9762)). > Throw an `IOException` if `ImageDisplay.setImageData()` fails, and remove the constructor that takes an `ImageData` parameter in favor of adding a static `create()` method instead.; >; > The purpose is to 'fail faster and better' if pixels cannot be read from an image, to avoid putting the viewer into an invalid state.; > ; > Previously, failure to open an image (e.g. because JPEGXR decompression was unavailable on Apple Silicon) would lead to an extremely uninformative NPE, and then possibly a lot more exceptions when attempting to interact with the viewer in any way.; > ; > When making these changes, the constructors for `QuPathViewer` were changed to no longer take an `ImageData` as a parameter. This was always null anyway (viewers were always created without an image), so makes no real difference to the current code - but the change avoids the possibility of the constructor having to throw an exception if the image couldn't be set. Now the image must be set as a second step, after the viewer has been created.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1343
https://github.com/qupath/qupath/pull/1343:590,Safety,avoid,avoid,590,"Fixes for; * https://github.com/qupath/qupath/issues/1265; * https://github.com/qupath/qupath/issues/1245; * https://github.com/qupath/qupath/issues/1249. Also improve image opening behavior... or non-opening when it fails ([here](https://github.com/qupath/qupath/commit/4b4955cea256d70272e96f7714cafe6e1a8b9762)). > Throw an `IOException` if `ImageDisplay.setImageData()` fails, and remove the constructor that takes an `ImageData` parameter in favor of adding a static `create()` method instead.; >; > The purpose is to 'fail faster and better' if pixels cannot be read from an image, to avoid putting the viewer into an invalid state.; > ; > Previously, failure to open an image (e.g. because JPEGXR decompression was unavailable on Apple Silicon) would lead to an extremely uninformative NPE, and then possibly a lot more exceptions when attempting to interact with the viewer in any way.; > ; > When making these changes, the constructors for `QuPathViewer` were changed to no longer take an `ImageData` as a parameter. This was always null anyway (viewers were always created without an image), so makes no real difference to the current code - but the change avoids the possibility of the constructor having to throw an exception if the image couldn't be set. Now the image must be set as a second step, after the viewer has been created.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1343
https://github.com/qupath/qupath/pull/1343:1166,Safety,avoid,avoids,1166,"Fixes for; * https://github.com/qupath/qupath/issues/1265; * https://github.com/qupath/qupath/issues/1245; * https://github.com/qupath/qupath/issues/1249. Also improve image opening behavior... or non-opening when it fails ([here](https://github.com/qupath/qupath/commit/4b4955cea256d70272e96f7714cafe6e1a8b9762)). > Throw an `IOException` if `ImageDisplay.setImageData()` fails, and remove the constructor that takes an `ImageData` parameter in favor of adding a static `create()` method instead.; >; > The purpose is to 'fail faster and better' if pixels cannot be read from an image, to avoid putting the viewer into an invalid state.; > ; > Previously, failure to open an image (e.g. because JPEGXR decompression was unavailable on Apple Silicon) would lead to an extremely uninformative NPE, and then possibly a lot more exceptions when attempting to interact with the viewer in any way.; > ; > When making these changes, the constructors for `QuPathViewer` were changed to no longer take an `ImageData` as a parameter. This was always null anyway (viewers were always created without an image), so makes no real difference to the current code - but the change avoids the possibility of the constructor having to throw an exception if the image couldn't be set. Now the image must be set as a second step, after the viewer has been created.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1343
https://github.com/qupath/qupath/pull/1346:647,Availability,toler,tolerance,647,"Introduce `qupath.lib.objects.utils.ObjectMerger` as an attempt to provide a general, reusable and performant way to handle tile boundary issues with segmentation algorithms. It is designed to support different merging criteria, with three baseline implementations for now. This might be extended in the future. The following Groovy script shows it in action:. ```groovy; import qupath.lib.objects.utils.ObjectMerger. def pathObjects = getSelectedObjects(). println ""Before merging: ${pathObjects.size()}"". // Create a merger that requires one horizontal/vertical boundary to match; // (with a minimum shared length threshold, and a small overlap tolerance); double threshold = 0.75; def merger = ObjectMerger.createSharedTileBoundaryMerger(threshold). // Alternatives; // merger = ObjectMerger.createSharedClassificationMerger() // ROIs can be discontinuous; // merger = ObjectMerger.createTouchingMerger() // ROIs must touch, but not intersect. // Do the merging; def mergedObjects = merger.merge(pathObjects); println ""After merging: ${mergedObjects.size()}"". // Replace the objects; removeObjects(pathObjects, true); addObjects(mergedObjects); ```. On my M1 Max Mac Studio it is capable of reducing 88350 detections to 76394 in 2-4 seconds.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1346
https://github.com/qupath/qupath/pull/1346:288,Modifiability,extend,extended,288,"Introduce `qupath.lib.objects.utils.ObjectMerger` as an attempt to provide a general, reusable and performant way to handle tile boundary issues with segmentation algorithms. It is designed to support different merging criteria, with three baseline implementations for now. This might be extended in the future. The following Groovy script shows it in action:. ```groovy; import qupath.lib.objects.utils.ObjectMerger. def pathObjects = getSelectedObjects(). println ""Before merging: ${pathObjects.size()}"". // Create a merger that requires one horizontal/vertical boundary to match; // (with a minimum shared length threshold, and a small overlap tolerance); double threshold = 0.75; def merger = ObjectMerger.createSharedTileBoundaryMerger(threshold). // Alternatives; // merger = ObjectMerger.createSharedClassificationMerger() // ROIs can be discontinuous; // merger = ObjectMerger.createTouchingMerger() // ROIs must touch, but not intersect. // Do the merging; def mergedObjects = merger.merge(pathObjects); println ""After merging: ${mergedObjects.size()}"". // Replace the objects; removeObjects(pathObjects, true); addObjects(mergedObjects); ```. On my M1 Max Mac Studio it is capable of reducing 88350 detections to 76394 in 2-4 seconds.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1346
https://github.com/qupath/qupath/pull/1346:99,Performance,perform,performant,99,"Introduce `qupath.lib.objects.utils.ObjectMerger` as an attempt to provide a general, reusable and performant way to handle tile boundary issues with segmentation algorithms. It is designed to support different merging criteria, with three baseline implementations for now. This might be extended in the future. The following Groovy script shows it in action:. ```groovy; import qupath.lib.objects.utils.ObjectMerger. def pathObjects = getSelectedObjects(). println ""Before merging: ${pathObjects.size()}"". // Create a merger that requires one horizontal/vertical boundary to match; // (with a minimum shared length threshold, and a small overlap tolerance); double threshold = 0.75; def merger = ObjectMerger.createSharedTileBoundaryMerger(threshold). // Alternatives; // merger = ObjectMerger.createSharedClassificationMerger() // ROIs can be discontinuous; // merger = ObjectMerger.createTouchingMerger() // ROIs must touch, but not intersect. // Do the merging; def mergedObjects = merger.merge(pathObjects); println ""After merging: ${mergedObjects.size()}"". // Replace the objects; removeObjects(pathObjects, true); addObjects(mergedObjects); ```. On my M1 Max Mac Studio it is capable of reducing 88350 detections to 76394 in 2-4 seconds.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1346
https://github.com/qupath/qupath/pull/1346:1209,Safety,detect,detections,1209,"Introduce `qupath.lib.objects.utils.ObjectMerger` as an attempt to provide a general, reusable and performant way to handle tile boundary issues with segmentation algorithms. It is designed to support different merging criteria, with three baseline implementations for now. This might be extended in the future. The following Groovy script shows it in action:. ```groovy; import qupath.lib.objects.utils.ObjectMerger. def pathObjects = getSelectedObjects(). println ""Before merging: ${pathObjects.size()}"". // Create a merger that requires one horizontal/vertical boundary to match; // (with a minimum shared length threshold, and a small overlap tolerance); double threshold = 0.75; def merger = ObjectMerger.createSharedTileBoundaryMerger(threshold). // Alternatives; // merger = ObjectMerger.createSharedClassificationMerger() // ROIs can be discontinuous; // merger = ObjectMerger.createTouchingMerger() // ROIs must touch, but not intersect. // Do the merging; def mergedObjects = merger.merge(pathObjects); println ""After merging: ${mergedObjects.size()}"". // Replace the objects; removeObjects(pathObjects, true); addObjects(mergedObjects); ```. On my M1 Max Mac Studio it is capable of reducing 88350 detections to 76394 in 2-4 seconds.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1346
https://github.com/qupath/qupath/pull/1347:67,Deployability,update,updated,67,"Initially in the WSInfer extension, now moved to QuPath code - and updated to make it immutable, and create using a builder. An example script showing it in action to tile the current selected object:. ```groovy; def tiler = Tiler.builder(512, 256); .symmetric(true); .trimToParent(true); .filterByCentroid(false); .build(). def pathObject = getSelectedObject(); def tiles = tiler.createAnnotations(pathObject.getROI()). pathObject.clearChildObjects(); pathObject.addChildObjects(tiles); println ""Created ${tiles.size()} tiles""; ```",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1347
https://github.com/qupath/qupath/pull/1347:432,Usability,clear,clearChildObjects,432,"Initially in the WSInfer extension, now moved to QuPath code - and updated to make it immutable, and create using a builder. An example script showing it in action to tile the current selected object:. ```groovy; def tiler = Tiler.builder(512, 256); .symmetric(true); .trimToParent(true); .filterByCentroid(false); .build(). def pathObject = getSelectedObject(); def tiles = tiler.createAnnotations(pathObject.getROI()). pathObject.clearChildObjects(); pathObject.addChildObjects(tiles); println ""Created ${tiles.size()} tiles""; ```",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1347
https://github.com/qupath/qupath/pull/1348:100,Safety,Avoid,Avoid,100,* Reposition script & log toolbar buttons; * Add preference to control display of toolbar badges; * Avoid calling `Desktop` during startup (this was causing trouble on macOS),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1348
https://github.com/qupath/qupath/pull/1348:22,Testability,log,log,22,* Reposition script & log toolbar buttons; * Add preference to control display of toolbar badges; * Avoid calling `Desktop` during startup (this was causing trouble on macOS),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1348
https://github.com/qupath/qupath/pull/1350:564,Usability,clear,clearChildObjects,564,"Support different methods of aligning tiles with the new `Tiler` class. This addresses @ofrag's feature request in ; * https://github.com/qupath/qupath/issues/1277. ```groovy; def selected = getSelectedObject(). def tiles = qupath.lib.objects.utils.Tiler.builder(256, 512); // Just use one of the alignment options!; .alignCenter(); .alignTopLeft(); .alignTopRight(); .alignBottomLeft(); .alignBottomRight(); // Select whatever other options are needed; .filterByCentroid(false); .trimToParent(false); .build(); .createAnnotations(selected.getROI()); ; ; selected.clearChildObjects(); selected.addChildObjects(tiles); ```. The screenshot shows an example using `alignTopRight()`. ![image](https://github.com/qupath/qupath/assets/4690904/2516725c-3513-4f0c-9e2c-fdb9421c62f2)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1350
https://github.com/qupath/qupath/pull/1353:136,Integrability,wrap,wrapper,136,"Open for discussion on whether we should continue hunting for stages without min sizes set, or should just replace Stage with some thin wrapper that has some basic settings. For example I'd love a keymapping to close the currently focused window (unless it's the main QuPath window). Usually shortcut+w closes the current tab in script editors, web browsers, etc.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1353
https://github.com/qupath/qupath/pull/1355:662,Availability,Mask,MaskSupplier,662,"Create a new `qupath.lib.experimental.pixels` package, which aims to greatly simplify adding new methods that require image processing. ## Important!. **This is still at an early stage and should be used with caution!**. ## Background ; The javadoc for `PixelProcessor` describes the idea:. ```java; * A class for tiled image processing.; * <p>; * The aim of this class is to make it easy to write pixel-based processing algorithms using a variety; * of different image representations, and also to run these in parallel.; * </p>; * <p>; * There are four main components:; * <ul>; * <li>An {@link ImageSupplier} that provides the image data</li>; * <li>A {@link MaskSupplier} that can generate binary masks that correspond to the image</li>; * <li>A {@link Processor} that processes the image data</li>; * <li>An {@link OutputHandler} that handles the output of the {@link Processor}</li>; * </ul>; * The idea is that the {@link Processor} is the only component that needs to be written for a specific task...; * and it is usually the fun bit to work on.; * <p>; * The other components are often very tedious to write and hard to get working correctly; also, there is much; * overlap in the functionality required for different tasks.; * For these reasons, we provide several default implementations here, written to support different image; * representations.; * </p>; ```. In addition to handling lots of thorny issues around tiling and merging, it also simplifies parallel processing with a progress monitor. In general, you would; * Choose how you want your images represented (e.g. `BufferedImage`, `ImagePlus`, `Mat`); * Write a custom function to do whatever processing you want *or* use a built-in option; * Use an appropriate 'output-handler' to handle whatever output your function gives (e.g. new objects, measurements, classifications). ## Examples. The following examples show the idea - albeit not necessarily with very meaningful processing. ### Image processing with ImageJ. Applied to",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1355
https://github.com/qupath/qupath/pull/1355:701,Availability,mask,masks,701,"Create a new `qupath.lib.experimental.pixels` package, which aims to greatly simplify adding new methods that require image processing. ## Important!. **This is still at an early stage and should be used with caution!**. ## Background ; The javadoc for `PixelProcessor` describes the idea:. ```java; * A class for tiled image processing.; * <p>; * The aim of this class is to make it easy to write pixel-based processing algorithms using a variety; * of different image representations, and also to run these in parallel.; * </p>; * <p>; * There are four main components:; * <ul>; * <li>An {@link ImageSupplier} that provides the image data</li>; * <li>A {@link MaskSupplier} that can generate binary masks that correspond to the image</li>; * <li>A {@link Processor} that processes the image data</li>; * <li>An {@link OutputHandler} that handles the output of the {@link Processor}</li>; * </ul>; * The idea is that the {@link Processor} is the only component that needs to be written for a specific task...; * and it is usually the fun bit to work on.; * <p>; * The other components are often very tedious to write and hard to get working correctly; also, there is much; * overlap in the functionality required for different tasks.; * For these reasons, we provide several default implementations here, written to support different image; * representations.; * </p>; ```. In addition to handling lots of thorny issues around tiling and merging, it also simplifies parallel processing with a progress monitor. In general, you would; * Choose how you want your images represented (e.g. `BufferedImage`, `ImagePlus`, `Mat`); * Write a custom function to do whatever processing you want *or* use a built-in option; * Use an appropriate 'output-handler' to handle whatever output your function gives (e.g. new objects, measurements, classifications). ## Examples. The following examples show the idea - albeit not necessarily with very meaningful processing. ### Image processing with ImageJ. Applied to",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1355
https://github.com/qupath/qupath/pull/1355:1503,Energy Efficiency,monitor,monitor,1503,"riety; * of different image representations, and also to run these in parallel.; * </p>; * <p>; * There are four main components:; * <ul>; * <li>An {@link ImageSupplier} that provides the image data</li>; * <li>A {@link MaskSupplier} that can generate binary masks that correspond to the image</li>; * <li>A {@link Processor} that processes the image data</li>; * <li>An {@link OutputHandler} that handles the output of the {@link Processor}</li>; * </ul>; * The idea is that the {@link Processor} is the only component that needs to be written for a specific task...; * and it is usually the fun bit to work on.; * <p>; * The other components are often very tedious to write and hard to get working correctly; also, there is much; * overlap in the functionality required for different tasks.; * For these reasons, we provide several default implementations here, written to support different image; * representations.; * </p>; ```. In addition to handling lots of thorny issues around tiling and merging, it also simplifies parallel processing with a progress monitor. In general, you would; * Choose how you want your images represented (e.g. `BufferedImage`, `ImagePlus`, `Mat`); * Write a custom function to do whatever processing you want *or* use a built-in option; * Use an appropriate 'output-handler' to handle whatever output your function gives (e.g. new objects, measurements, classifications). ## Examples. The following examples show the idea - albeit not necessarily with very meaningful processing. ### Image processing with ImageJ. Applied to an image with some detections, this does some custom detections *inside* those detections, and classifies them according to a mean pixel value. ```groovy; import qupath.lib.experimental.pixels.*; import ij.*; import ij.process.*; import ij.plugin.filter.*. def runner = new qupath.lib.gui.PluginRunnerFX(getQuPath()); def imageData = getCurrentImageData(). def pathObjects = getSelectedObjects(); if (!pathObjects); pathObjects = getDetectio",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1355
https://github.com/qupath/qupath/pull/1355:2242,Modifiability,plugin,plugin,2242,"se reasons, we provide several default implementations here, written to support different image; * representations.; * </p>; ```. In addition to handling lots of thorny issues around tiling and merging, it also simplifies parallel processing with a progress monitor. In general, you would; * Choose how you want your images represented (e.g. `BufferedImage`, `ImagePlus`, `Mat`); * Write a custom function to do whatever processing you want *or* use a built-in option; * Use an appropriate 'output-handler' to handle whatever output your function gives (e.g. new objects, measurements, classifications). ## Examples. The following examples show the idea - albeit not necessarily with very meaningful processing. ### Image processing with ImageJ. Applied to an image with some detections, this does some custom detections *inside* those detections, and classifies them according to a mean pixel value. ```groovy; import qupath.lib.experimental.pixels.*; import ij.*; import ij.process.*; import ij.plugin.filter.*. def runner = new qupath.lib.gui.PluginRunnerFX(getQuPath()); def imageData = getCurrentImageData(). def pathObjects = getSelectedObjects(); if (!pathObjects); pathObjects = getDetectionObjects(). def processor = ImageJProcessor.builder(this::process).build(); processor.processObjects(runner, imageData, pathObjects). // This is the main custom bit; // (Admittedly, the processing here is nonsense); def process(params) {; // Calculate mean for the region; // With ImageJ, the ROI should already be set; def imp = params.getImage(); assert imp.getRoi() != null; double mean = imp.getStatistics().mean; // Add mean as a measurement; def parent = params.getParent(); parent.measurements['My mean'] = mean; if (mean > 100); parent.classifications = ['High']; else; parent.classifications = ['Low']; // Smooth the image & threshold at the mean; def fp = imp.getProcessor().convertToFloatProcessor(); fp.blurGaussian(4); fp.setThreshold(-1, mean, ImageProcessor.NO_LUT_UPDATE); // Return the ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1355
https://github.com/qupath/qupath/pull/1355:2291,Modifiability,Plugin,PluginRunnerFX,2291," different image; * representations.; * </p>; ```. In addition to handling lots of thorny issues around tiling and merging, it also simplifies parallel processing with a progress monitor. In general, you would; * Choose how you want your images represented (e.g. `BufferedImage`, `ImagePlus`, `Mat`); * Write a custom function to do whatever processing you want *or* use a built-in option; * Use an appropriate 'output-handler' to handle whatever output your function gives (e.g. new objects, measurements, classifications). ## Examples. The following examples show the idea - albeit not necessarily with very meaningful processing. ### Image processing with ImageJ. Applied to an image with some detections, this does some custom detections *inside* those detections, and classifies them according to a mean pixel value. ```groovy; import qupath.lib.experimental.pixels.*; import ij.*; import ij.process.*; import ij.plugin.filter.*. def runner = new qupath.lib.gui.PluginRunnerFX(getQuPath()); def imageData = getCurrentImageData(). def pathObjects = getSelectedObjects(); if (!pathObjects); pathObjects = getDetectionObjects(). def processor = ImageJProcessor.builder(this::process).build(); processor.processObjects(runner, imageData, pathObjects). // This is the main custom bit; // (Admittedly, the processing here is nonsense); def process(params) {; // Calculate mean for the region; // With ImageJ, the ROI should already be set; def imp = params.getImage(); assert imp.getRoi() != null; double mean = imp.getStatistics().mean; // Add mean as a measurement; def parent = params.getParent(); parent.measurements['My mean'] = mean; if (mean > 100); parent.classifications = ['High']; else; parent.classifications = ['Low']; // Smooth the image & threshold at the mean; def fp = imp.getProcessor().convertToFloatProcessor(); fp.blurGaussian(4); fp.setThreshold(-1, mean, ImageProcessor.NO_LUT_UPDATE); // Return the image with the threshold set; return fp; }; ```. Note that the `process` functi",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1355
https://github.com/qupath/qupath/pull/1355:4008,Modifiability,plugin,plugin,4008,"']; else; parent.classifications = ['Low']; // Smooth the image & threshold at the mean; def fp = imp.getProcessor().convertToFloatProcessor(); fp.blurGaussian(4); fp.setThreshold(-1, mean, ImageProcessor.NO_LUT_UPDATE); // Return the image with the threshold set; return fp; }; ```. Note that the `process` function has access to things that it may need, i.e. an `ImagePlus` representing the tile it should work on, which is already properly calibrated and with the corresponding ROI set. Also, it only returns a `FloatProcessor` with a threshold set. An `OutputHandler` automatically determines that the thresholded image should be used to create objects, which are then clipped to the parent object and added. ### Tiled processing with ImageJ. The following script applies tiled processing across an entire whole slide image to detect tissue, with regions automatically merged to form annotations. ```groovy; import qupath.lib.experimental.pixels.*; import ij.*; import ij.process.*; import ij.plugin.filter.*. def runner = new qupath.lib.gui.PluginRunnerFX(getQuPath()); def imageData = getCurrentImageData(). def pathObjects = [imageData.getHierarchy().getRootObject()]. def processor = ImageJProcessor.builder(this::process); .outputHandler(; OutputHandler.createMaskAndSplitObjectOutputHandler(; ImageJProcessor.createAnnotationConverter(); ); ); .tile(512, 512); .mergeSharedBoundaries(0.5); .pixelSize(1.0); .padding(8); .build(); ; processor.processObjects(runner, imageData, pathObjects). def process(params) {; // Calculate mean for the region; // With ImageJ, the ROI should already be set; def imp = params.getImage(); // Smooth the image & threshold at the mean; def fp = imp.getProcessor().convertToFloatProcessor(); fp.blurGaussian(4); fp.setThreshold(-1, 200, ImageProcessor.NO_LUT_UPDATE); // Return the image with the threshold set; return fp; }; ```. ### Making measurements. Finally, here's a Groovy script to make custom measurements for cells in a multiplexed image:. ```groovy",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1355
https://github.com/qupath/qupath/pull/1355:4057,Modifiability,Plugin,PluginRunnerFX,4057,"the mean; def fp = imp.getProcessor().convertToFloatProcessor(); fp.blurGaussian(4); fp.setThreshold(-1, mean, ImageProcessor.NO_LUT_UPDATE); // Return the image with the threshold set; return fp; }; ```. Note that the `process` function has access to things that it may need, i.e. an `ImagePlus` representing the tile it should work on, which is already properly calibrated and with the corresponding ROI set. Also, it only returns a `FloatProcessor` with a threshold set. An `OutputHandler` automatically determines that the thresholded image should be used to create objects, which are then clipped to the parent object and added. ### Tiled processing with ImageJ. The following script applies tiled processing across an entire whole slide image to detect tissue, with regions automatically merged to form annotations. ```groovy; import qupath.lib.experimental.pixels.*; import ij.*; import ij.process.*; import ij.plugin.filter.*. def runner = new qupath.lib.gui.PluginRunnerFX(getQuPath()); def imageData = getCurrentImageData(). def pathObjects = [imageData.getHierarchy().getRootObject()]. def processor = ImageJProcessor.builder(this::process); .outputHandler(; OutputHandler.createMaskAndSplitObjectOutputHandler(; ImageJProcessor.createAnnotationConverter(); ); ); .tile(512, 512); .mergeSharedBoundaries(0.5); .pixelSize(1.0); .padding(8); .build(); ; processor.processObjects(runner, imageData, pathObjects). def process(params) {; // Calculate mean for the region; // With ImageJ, the ROI should already be set; def imp = params.getImage(); // Smooth the image & threshold at the mean; def fp = imp.getProcessor().convertToFloatProcessor(); fp.blurGaussian(4); fp.setThreshold(-1, 200, ImageProcessor.NO_LUT_UPDATE); // Return the image with the threshold set; return fp; }; ```. ### Making measurements. Finally, here's a Groovy script to make custom measurements for cells in a multiplexed image:. ```groovy; import qupath.lib.experimental.pixels.*. // Get the current image & objects; ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1355
https://github.com/qupath/qupath/pull/1355:6254,Modifiability,Plugin,PluginRunnerFX,6254,"ulate mean for the region; // With ImageJ, the ROI should already be set; def imp = params.getImage(); // Smooth the image & threshold at the mean; def fp = imp.getProcessor().convertToFloatProcessor(); fp.blurGaussian(4); fp.setThreshold(-1, 200, ImageProcessor.NO_LUT_UPDATE); // Return the image with the threshold set; return fp; }; ```. ### Making measurements. Finally, here's a Groovy script to make custom measurements for cells in a multiplexed image:. ```groovy; import qupath.lib.experimental.pixels.*. // Get the current image & objects; def imageData = getCurrentImageData(); def pathObjects = getSelectedObjects(); if (!pathObjects); pathObjects = getDetectionObjects(). // Define single-channel percentile measurements for all channels; def measurements = []; def channels = imageData.getServer().getMetadata().getChannels(); double percentile = 90; for (def channel : channels) {; measurements << MeasurementProcessor.Measurements.singleChannel(; ""${channel.name} percentile=${percentile}"",; ColorTransforms.createChannelExtractor(channel.name),; MeasurementProcessor.Functions.percentile(percentile); ); }. // Compute the PCC across channels; for (int i = 0; i < channels.size(); i++) {; String channel1 = channels[i].name; for (int j = i+1; j < channels.size(); j++) {; String channel2 = channels[j].name; measurements << MeasurementProcessor.Measurements.multiChannel(; ""PCC $channel1 v $channel2"",; [; ColorTransforms.createChannelExtractor(channel1),; ColorTransforms.createChannelExtractor(channel2); ],; MeasurementProcessor.Functions.pearsonsCorrelation(); ); }; }. // Run the processing; def processor = MeasurementProcessor.builder(measurements).build(); def runner = new qupath.lib.gui.PluginRunnerFX(getQuPath()); processor.processObjects(runner, imageData, pathObjects); ```. This doesn't make any use of ImageJ, and instead requires the user to define a custom function that computes a measurement from a `double[]` - or (in this case) choose from preexisting functions.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1355
https://github.com/qupath/qupath/pull/1355:2021,Safety,detect,detections,2021,"e other components are often very tedious to write and hard to get working correctly; also, there is much; * overlap in the functionality required for different tasks.; * For these reasons, we provide several default implementations here, written to support different image; * representations.; * </p>; ```. In addition to handling lots of thorny issues around tiling and merging, it also simplifies parallel processing with a progress monitor. In general, you would; * Choose how you want your images represented (e.g. `BufferedImage`, `ImagePlus`, `Mat`); * Write a custom function to do whatever processing you want *or* use a built-in option; * Use an appropriate 'output-handler' to handle whatever output your function gives (e.g. new objects, measurements, classifications). ## Examples. The following examples show the idea - albeit not necessarily with very meaningful processing. ### Image processing with ImageJ. Applied to an image with some detections, this does some custom detections *inside* those detections, and classifies them according to a mean pixel value. ```groovy; import qupath.lib.experimental.pixels.*; import ij.*; import ij.process.*; import ij.plugin.filter.*. def runner = new qupath.lib.gui.PluginRunnerFX(getQuPath()); def imageData = getCurrentImageData(). def pathObjects = getSelectedObjects(); if (!pathObjects); pathObjects = getDetectionObjects(). def processor = ImageJProcessor.builder(this::process).build(); processor.processObjects(runner, imageData, pathObjects). // This is the main custom bit; // (Admittedly, the processing here is nonsense); def process(params) {; // Calculate mean for the region; // With ImageJ, the ROI should already be set; def imp = params.getImage(); assert imp.getRoi() != null; double mean = imp.getStatistics().mean; // Add mean as a measurement; def parent = params.getParent(); parent.measurements['My mean'] = mean; if (mean > 100); parent.classifications = ['High']; else; parent.classifications = ['Low']; // Smooth the",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1355
https://github.com/qupath/qupath/pull/1355:2055,Safety,detect,detections,2055,"e other components are often very tedious to write and hard to get working correctly; also, there is much; * overlap in the functionality required for different tasks.; * For these reasons, we provide several default implementations here, written to support different image; * representations.; * </p>; ```. In addition to handling lots of thorny issues around tiling and merging, it also simplifies parallel processing with a progress monitor. In general, you would; * Choose how you want your images represented (e.g. `BufferedImage`, `ImagePlus`, `Mat`); * Write a custom function to do whatever processing you want *or* use a built-in option; * Use an appropriate 'output-handler' to handle whatever output your function gives (e.g. new objects, measurements, classifications). ## Examples. The following examples show the idea - albeit not necessarily with very meaningful processing. ### Image processing with ImageJ. Applied to an image with some detections, this does some custom detections *inside* those detections, and classifies them according to a mean pixel value. ```groovy; import qupath.lib.experimental.pixels.*; import ij.*; import ij.process.*; import ij.plugin.filter.*. def runner = new qupath.lib.gui.PluginRunnerFX(getQuPath()); def imageData = getCurrentImageData(). def pathObjects = getSelectedObjects(); if (!pathObjects); pathObjects = getDetectionObjects(). def processor = ImageJProcessor.builder(this::process).build(); processor.processObjects(runner, imageData, pathObjects). // This is the main custom bit; // (Admittedly, the processing here is nonsense); def process(params) {; // Calculate mean for the region; // With ImageJ, the ROI should already be set; def imp = params.getImage(); assert imp.getRoi() != null; double mean = imp.getStatistics().mean; // Add mean as a measurement; def parent = params.getParent(); parent.measurements['My mean'] = mean; if (mean > 100); parent.classifications = ['High']; else; parent.classifications = ['Low']; // Smooth the",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1355
https://github.com/qupath/qupath/pull/1355:2081,Safety,detect,detections,2081,"e other components are often very tedious to write and hard to get working correctly; also, there is much; * overlap in the functionality required for different tasks.; * For these reasons, we provide several default implementations here, written to support different image; * representations.; * </p>; ```. In addition to handling lots of thorny issues around tiling and merging, it also simplifies parallel processing with a progress monitor. In general, you would; * Choose how you want your images represented (e.g. `BufferedImage`, `ImagePlus`, `Mat`); * Write a custom function to do whatever processing you want *or* use a built-in option; * Use an appropriate 'output-handler' to handle whatever output your function gives (e.g. new objects, measurements, classifications). ## Examples. The following examples show the idea - albeit not necessarily with very meaningful processing. ### Image processing with ImageJ. Applied to an image with some detections, this does some custom detections *inside* those detections, and classifies them according to a mean pixel value. ```groovy; import qupath.lib.experimental.pixels.*; import ij.*; import ij.process.*; import ij.plugin.filter.*. def runner = new qupath.lib.gui.PluginRunnerFX(getQuPath()); def imageData = getCurrentImageData(). def pathObjects = getSelectedObjects(); if (!pathObjects); pathObjects = getDetectionObjects(). def processor = ImageJProcessor.builder(this::process).build(); processor.processObjects(runner, imageData, pathObjects). // This is the main custom bit; // (Admittedly, the processing here is nonsense); def process(params) {; // Calculate mean for the region; // With ImageJ, the ROI should already be set; def imp = params.getImage(); assert imp.getRoi() != null; double mean = imp.getStatistics().mean; // Add mean as a measurement; def parent = params.getParent(); parent.measurements['My mean'] = mean; if (mean > 100); parent.classifications = ['High']; else; parent.classifications = ['Low']; // Smooth the",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1355
https://github.com/qupath/qupath/pull/1355:3842,Safety,detect,detect,3842," imp.getStatistics().mean; // Add mean as a measurement; def parent = params.getParent(); parent.measurements['My mean'] = mean; if (mean > 100); parent.classifications = ['High']; else; parent.classifications = ['Low']; // Smooth the image & threshold at the mean; def fp = imp.getProcessor().convertToFloatProcessor(); fp.blurGaussian(4); fp.setThreshold(-1, mean, ImageProcessor.NO_LUT_UPDATE); // Return the image with the threshold set; return fp; }; ```. Note that the `process` function has access to things that it may need, i.e. an `ImagePlus` representing the tile it should work on, which is already properly calibrated and with the corresponding ROI set. Also, it only returns a `FloatProcessor` with a threshold set. An `OutputHandler` automatically determines that the thresholded image should be used to create objects, which are then clipped to the parent object and added. ### Tiled processing with ImageJ. The following script applies tiled processing across an entire whole slide image to detect tissue, with regions automatically merged to form annotations. ```groovy; import qupath.lib.experimental.pixels.*; import ij.*; import ij.process.*; import ij.plugin.filter.*. def runner = new qupath.lib.gui.PluginRunnerFX(getQuPath()); def imageData = getCurrentImageData(). def pathObjects = [imageData.getHierarchy().getRootObject()]. def processor = ImageJProcessor.builder(this::process); .outputHandler(; OutputHandler.createMaskAndSplitObjectOutputHandler(; ImageJProcessor.createAnnotationConverter(); ); ); .tile(512, 512); .mergeSharedBoundaries(0.5); .pixelSize(1.0); .padding(8); .build(); ; processor.processObjects(runner, imageData, pathObjects). def process(params) {; // Calculate mean for the region; // With ImageJ, the ROI should already be set; def imp = params.getImage(); // Smooth the image & threshold at the mean; def fp = imp.getProcessor().convertToFloatProcessor(); fp.blurGaussian(4); fp.setThreshold(-1, 200, ImageProcessor.NO_LUT_UPDATE); // Return the ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1355
https://github.com/qupath/qupath/pull/1355:3332,Security,access,access,3332,"ta = getCurrentImageData(). def pathObjects = getSelectedObjects(); if (!pathObjects); pathObjects = getDetectionObjects(). def processor = ImageJProcessor.builder(this::process).build(); processor.processObjects(runner, imageData, pathObjects). // This is the main custom bit; // (Admittedly, the processing here is nonsense); def process(params) {; // Calculate mean for the region; // With ImageJ, the ROI should already be set; def imp = params.getImage(); assert imp.getRoi() != null; double mean = imp.getStatistics().mean; // Add mean as a measurement; def parent = params.getParent(); parent.measurements['My mean'] = mean; if (mean > 100); parent.classifications = ['High']; else; parent.classifications = ['Low']; // Smooth the image & threshold at the mean; def fp = imp.getProcessor().convertToFloatProcessor(); fp.blurGaussian(4); fp.setThreshold(-1, mean, ImageProcessor.NO_LUT_UPDATE); // Return the image with the threshold set; return fp; }; ```. Note that the `process` function has access to things that it may need, i.e. an `ImagePlus` representing the tile it should work on, which is already properly calibrated and with the corresponding ROI set. Also, it only returns a `FloatProcessor` with a threshold set. An `OutputHandler` automatically determines that the thresholded image should be used to create objects, which are then clipped to the parent object and added. ### Tiled processing with ImageJ. The following script applies tiled processing across an entire whole slide image to detect tissue, with regions automatically merged to form annotations. ```groovy; import qupath.lib.experimental.pixels.*; import ij.*; import ij.process.*; import ij.plugin.filter.*. def runner = new qupath.lib.gui.PluginRunnerFX(getQuPath()); def imageData = getCurrentImageData(). def pathObjects = [imageData.getHierarchy().getRootObject()]. def processor = ImageJProcessor.builder(this::process); .outputHandler(; OutputHandler.createMaskAndSplitObjectOutputHandler(; ImageJProcessor.cr",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1355
https://github.com/qupath/qupath/pull/1355:2792,Testability,assert,assert,2792," gives (e.g. new objects, measurements, classifications). ## Examples. The following examples show the idea - albeit not necessarily with very meaningful processing. ### Image processing with ImageJ. Applied to an image with some detections, this does some custom detections *inside* those detections, and classifies them according to a mean pixel value. ```groovy; import qupath.lib.experimental.pixels.*; import ij.*; import ij.process.*; import ij.plugin.filter.*. def runner = new qupath.lib.gui.PluginRunnerFX(getQuPath()); def imageData = getCurrentImageData(). def pathObjects = getSelectedObjects(); if (!pathObjects); pathObjects = getDetectionObjects(). def processor = ImageJProcessor.builder(this::process).build(); processor.processObjects(runner, imageData, pathObjects). // This is the main custom bit; // (Admittedly, the processing here is nonsense); def process(params) {; // Calculate mean for the region; // With ImageJ, the ROI should already be set; def imp = params.getImage(); assert imp.getRoi() != null; double mean = imp.getStatistics().mean; // Add mean as a measurement; def parent = params.getParent(); parent.measurements['My mean'] = mean; if (mean > 100); parent.classifications = ['High']; else; parent.classifications = ['Low']; // Smooth the image & threshold at the mean; def fp = imp.getProcessor().convertToFloatProcessor(); fp.blurGaussian(4); fp.setThreshold(-1, mean, ImageProcessor.NO_LUT_UPDATE); // Return the image with the threshold set; return fp; }; ```. Note that the `process` function has access to things that it may need, i.e. an `ImagePlus` representing the tile it should work on, which is already properly calibrated and with the corresponding ROI set. Also, it only returns a `FloatProcessor` with a threshold set. An `OutputHandler` automatically determines that the thresholded image should be used to create objects, which are then clipped to the parent object and added. ### Tiled processing with ImageJ. The following script applies tiled",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1355
https://github.com/qupath/qupath/pull/1355:77,Usability,simpl,simplify,77,"Create a new `qupath.lib.experimental.pixels` package, which aims to greatly simplify adding new methods that require image processing. ## Important!. **This is still at an early stage and should be used with caution!**. ## Background ; The javadoc for `PixelProcessor` describes the idea:. ```java; * A class for tiled image processing.; * <p>; * The aim of this class is to make it easy to write pixel-based processing algorithms using a variety; * of different image representations, and also to run these in parallel.; * </p>; * <p>; * There are four main components:; * <ul>; * <li>An {@link ImageSupplier} that provides the image data</li>; * <li>A {@link MaskSupplier} that can generate binary masks that correspond to the image</li>; * <li>A {@link Processor} that processes the image data</li>; * <li>An {@link OutputHandler} that handles the output of the {@link Processor}</li>; * </ul>; * The idea is that the {@link Processor} is the only component that needs to be written for a specific task...; * and it is usually the fun bit to work on.; * <p>; * The other components are often very tedious to write and hard to get working correctly; also, there is much; * overlap in the functionality required for different tasks.; * For these reasons, we provide several default implementations here, written to support different image; * representations.; * </p>; ```. In addition to handling lots of thorny issues around tiling and merging, it also simplifies parallel processing with a progress monitor. In general, you would; * Choose how you want your images represented (e.g. `BufferedImage`, `ImagePlus`, `Mat`); * Write a custom function to do whatever processing you want *or* use a built-in option; * Use an appropriate 'output-handler' to handle whatever output your function gives (e.g. new objects, measurements, classifications). ## Examples. The following examples show the idea - albeit not necessarily with very meaningful processing. ### Image processing with ImageJ. Applied to",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1355
https://github.com/qupath/qupath/pull/1355:1456,Usability,simpl,simplifies,1456,"riety; * of different image representations, and also to run these in parallel.; * </p>; * <p>; * There are four main components:; * <ul>; * <li>An {@link ImageSupplier} that provides the image data</li>; * <li>A {@link MaskSupplier} that can generate binary masks that correspond to the image</li>; * <li>A {@link Processor} that processes the image data</li>; * <li>An {@link OutputHandler} that handles the output of the {@link Processor}</li>; * </ul>; * The idea is that the {@link Processor} is the only component that needs to be written for a specific task...; * and it is usually the fun bit to work on.; * <p>; * The other components are often very tedious to write and hard to get working correctly; also, there is much; * overlap in the functionality required for different tasks.; * For these reasons, we provide several default implementations here, written to support different image; * representations.; * </p>; ```. In addition to handling lots of thorny issues around tiling and merging, it also simplifies parallel processing with a progress monitor. In general, you would; * Choose how you want your images represented (e.g. `BufferedImage`, `ImagePlus`, `Mat`); * Write a custom function to do whatever processing you want *or* use a built-in option; * Use an appropriate 'output-handler' to handle whatever output your function gives (e.g. new objects, measurements, classifications). ## Examples. The following examples show the idea - albeit not necessarily with very meaningful processing. ### Image processing with ImageJ. Applied to an image with some detections, this does some custom detections *inside* those detections, and classifies them according to a mean pixel value. ```groovy; import qupath.lib.experimental.pixels.*; import ij.*; import ij.process.*; import ij.plugin.filter.*. def runner = new qupath.lib.gui.PluginRunnerFX(getQuPath()); def imageData = getCurrentImageData(). def pathObjects = getSelectedObjects(); if (!pathObjects); pathObjects = getDetectio",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1355
https://github.com/qupath/qupath/pull/1357:23,Deployability,update,update,23,* Autocomplete options update while typing; * Pressing 'tab' or 'enter' applies the focused completion (probably the first) if none are selected; * Pressing 'Escape' removes the completion popup; * A newly-created script editor now opens with the editor in focus,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1357
https://github.com/qupath/qupath/pull/1359:407,Availability,down,downsample,407,"Support reloading display settings; 1. via drag & drop onto a viewer; 2. in a script. Here's an example that uses the display settings to export rendered RGB images with different settings (saved in the project):. ```groovy; import qupath.lib.gui.images.servers.RenderedImageServer; import qupath.lib.gui.viewer.overlays.HierarchyOverlay. import static qupath.lib.gui.scripting.QPEx.*. // Choose a sensible downsample; def imageData = getCurrentImageData(); double downsample = Math.max(1.0, Math.max(imageData.server.width, imageData.server.height) / 512). // Get the viewer for some options; def viewer = getCurrentViewer(). // Create an output directory; def dirOutput = buildFilePath(PROJECT_BASE_DIR, 'rendered_export'); mkdirs(dirOutput). // Get the image name; def name = getCurrentImageNameWithoutExtension(). // Create a rendered server that includes a hierarchy overlay using the display settings saved in the project; for (def settingsName in ['my first settings', 'my second settings']) {; def settings = loadDisplaySettings(settingsName); def server = new RenderedImageServer.Builder(imageData); .downsamples(downsample); .settings(settings); .layers(new HierarchyOverlay(viewer.getImageRegionStore(), viewer.getOverlayOptions(), imageData)); .build(); ; // Write the image; String path = buildFilePath(dirOutput, ""$name [$settingsName].png""); writeImage(server, path) ; }; ```",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1359
https://github.com/qupath/qupath/pull/1359:465,Availability,down,downsample,465,"Support reloading display settings; 1. via drag & drop onto a viewer; 2. in a script. Here's an example that uses the display settings to export rendered RGB images with different settings (saved in the project):. ```groovy; import qupath.lib.gui.images.servers.RenderedImageServer; import qupath.lib.gui.viewer.overlays.HierarchyOverlay. import static qupath.lib.gui.scripting.QPEx.*. // Choose a sensible downsample; def imageData = getCurrentImageData(); double downsample = Math.max(1.0, Math.max(imageData.server.width, imageData.server.height) / 512). // Get the viewer for some options; def viewer = getCurrentViewer(). // Create an output directory; def dirOutput = buildFilePath(PROJECT_BASE_DIR, 'rendered_export'); mkdirs(dirOutput). // Get the image name; def name = getCurrentImageNameWithoutExtension(). // Create a rendered server that includes a hierarchy overlay using the display settings saved in the project; for (def settingsName in ['my first settings', 'my second settings']) {; def settings = loadDisplaySettings(settingsName); def server = new RenderedImageServer.Builder(imageData); .downsamples(downsample); .settings(settings); .layers(new HierarchyOverlay(viewer.getImageRegionStore(), viewer.getOverlayOptions(), imageData)); .build(); ; // Write the image; String path = buildFilePath(dirOutput, ""$name [$settingsName].png""); writeImage(server, path) ; }; ```",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1359
https://github.com/qupath/qupath/pull/1359:1110,Availability,down,downsamples,1110,"Support reloading display settings; 1. via drag & drop onto a viewer; 2. in a script. Here's an example that uses the display settings to export rendered RGB images with different settings (saved in the project):. ```groovy; import qupath.lib.gui.images.servers.RenderedImageServer; import qupath.lib.gui.viewer.overlays.HierarchyOverlay. import static qupath.lib.gui.scripting.QPEx.*. // Choose a sensible downsample; def imageData = getCurrentImageData(); double downsample = Math.max(1.0, Math.max(imageData.server.width, imageData.server.height) / 512). // Get the viewer for some options; def viewer = getCurrentViewer(). // Create an output directory; def dirOutput = buildFilePath(PROJECT_BASE_DIR, 'rendered_export'); mkdirs(dirOutput). // Get the image name; def name = getCurrentImageNameWithoutExtension(). // Create a rendered server that includes a hierarchy overlay using the display settings saved in the project; for (def settingsName in ['my first settings', 'my second settings']) {; def settings = loadDisplaySettings(settingsName); def server = new RenderedImageServer.Builder(imageData); .downsamples(downsample); .settings(settings); .layers(new HierarchyOverlay(viewer.getImageRegionStore(), viewer.getOverlayOptions(), imageData)); .build(); ; // Write the image; String path = buildFilePath(dirOutput, ""$name [$settingsName].png""); writeImage(server, path) ; }; ```",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1359
https://github.com/qupath/qupath/pull/1359:1122,Availability,down,downsample,1122,"Support reloading display settings; 1. via drag & drop onto a viewer; 2. in a script. Here's an example that uses the display settings to export rendered RGB images with different settings (saved in the project):. ```groovy; import qupath.lib.gui.images.servers.RenderedImageServer; import qupath.lib.gui.viewer.overlays.HierarchyOverlay. import static qupath.lib.gui.scripting.QPEx.*. // Choose a sensible downsample; def imageData = getCurrentImageData(); double downsample = Math.max(1.0, Math.max(imageData.server.width, imageData.server.height) / 512). // Get the viewer for some options; def viewer = getCurrentViewer(). // Create an output directory; def dirOutput = buildFilePath(PROJECT_BASE_DIR, 'rendered_export'); mkdirs(dirOutput). // Get the image name; def name = getCurrentImageNameWithoutExtension(). // Create a rendered server that includes a hierarchy overlay using the display settings saved in the project; for (def settingsName in ['my first settings', 'my second settings']) {; def settings = loadDisplaySettings(settingsName); def server = new RenderedImageServer.Builder(imageData); .downsamples(downsample); .settings(settings); .layers(new HierarchyOverlay(viewer.getImageRegionStore(), viewer.getOverlayOptions(), imageData)); .build(); ; // Write the image; String path = buildFilePath(dirOutput, ""$name [$settingsName].png""); writeImage(server, path) ; }; ```",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1359
https://github.com/qupath/qupath/pull/1359:1157,Modifiability,layers,layers,1157,"Support reloading display settings; 1. via drag & drop onto a viewer; 2. in a script. Here's an example that uses the display settings to export rendered RGB images with different settings (saved in the project):. ```groovy; import qupath.lib.gui.images.servers.RenderedImageServer; import qupath.lib.gui.viewer.overlays.HierarchyOverlay. import static qupath.lib.gui.scripting.QPEx.*. // Choose a sensible downsample; def imageData = getCurrentImageData(); double downsample = Math.max(1.0, Math.max(imageData.server.width, imageData.server.height) / 512). // Get the viewer for some options; def viewer = getCurrentViewer(). // Create an output directory; def dirOutput = buildFilePath(PROJECT_BASE_DIR, 'rendered_export'); mkdirs(dirOutput). // Get the image name; def name = getCurrentImageNameWithoutExtension(). // Create a rendered server that includes a hierarchy overlay using the display settings saved in the project; for (def settingsName in ['my first settings', 'my second settings']) {; def settings = loadDisplaySettings(settingsName); def server = new RenderedImageServer.Builder(imageData); .downsamples(downsample); .settings(settings); .layers(new HierarchyOverlay(viewer.getImageRegionStore(), viewer.getOverlayOptions(), imageData)); .build(); ; // Write the image; String path = buildFilePath(dirOutput, ""$name [$settingsName].png""); writeImage(server, path) ; }; ```",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1359
https://github.com/qupath/qupath/pull/1359:1017,Performance,load,loadDisplaySettings,1017,"Support reloading display settings; 1. via drag & drop onto a viewer; 2. in a script. Here's an example that uses the display settings to export rendered RGB images with different settings (saved in the project):. ```groovy; import qupath.lib.gui.images.servers.RenderedImageServer; import qupath.lib.gui.viewer.overlays.HierarchyOverlay. import static qupath.lib.gui.scripting.QPEx.*. // Choose a sensible downsample; def imageData = getCurrentImageData(); double downsample = Math.max(1.0, Math.max(imageData.server.width, imageData.server.height) / 512). // Get the viewer for some options; def viewer = getCurrentViewer(). // Create an output directory; def dirOutput = buildFilePath(PROJECT_BASE_DIR, 'rendered_export'); mkdirs(dirOutput). // Get the image name; def name = getCurrentImageNameWithoutExtension(). // Create a rendered server that includes a hierarchy overlay using the display settings saved in the project; for (def settingsName in ['my first settings', 'my second settings']) {; def settings = loadDisplaySettings(settingsName); def server = new RenderedImageServer.Builder(imageData); .downsamples(downsample); .settings(settings); .layers(new HierarchyOverlay(viewer.getImageRegionStore(), viewer.getOverlayOptions(), imageData)); .build(); ; // Write the image; String path = buildFilePath(dirOutput, ""$name [$settingsName].png""); writeImage(server, path) ; }; ```",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1359
https://github.com/qupath/qupath/pull/1360:465,Deployability,release,releases,465,"Minor changes:; * Use 'crop' rather than 'trim' with Tiler; * Turn this setting off by default with `PixelProcessor`. Major change:; * Convert `PluginRunner` to `TaskRunner`; * Provide `QPEx.createTaskRunner()` and `QPEx.createTaskRunner(int nThreads)` methods. The reasoning is that `PluginRunner` no longer really makes sense as a name: the class rather represents a simple and generic way to run tasks in parallel. It's also more general than in previous QuPath releases. The following script shows it in action:. ```groovy; def tasks = []; for (int i in 1..50) {; int n = i; tasks << () -> sleepyTask(n); }. def runner = createTaskRunner(); runner.runTasks(tasks). def sleepyTask(int n) {; Thread.sleep(250L); println ""I'm awake! And I'm task $n""; }; ```. When run interactively, this should show a progress dialog (after a short delay). But when using *Run for project* it will switch to using a command line task runner, and not generate a new dialog of its own. The number of threads can also be specified. For example, for single-threaded tasks we can use; ```groovy; def runner = createTaskRunner(1); ```. This is an easy way to provide a progress monitor for multiple tasks.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1360
https://github.com/qupath/qupath/pull/1360:1157,Energy Efficiency,monitor,monitor,1157,"Minor changes:; * Use 'crop' rather than 'trim' with Tiler; * Turn this setting off by default with `PixelProcessor`. Major change:; * Convert `PluginRunner` to `TaskRunner`; * Provide `QPEx.createTaskRunner()` and `QPEx.createTaskRunner(int nThreads)` methods. The reasoning is that `PluginRunner` no longer really makes sense as a name: the class rather represents a simple and generic way to run tasks in parallel. It's also more general than in previous QuPath releases. The following script shows it in action:. ```groovy; def tasks = []; for (int i in 1..50) {; int n = i; tasks << () -> sleepyTask(n); }. def runner = createTaskRunner(); runner.runTasks(tasks). def sleepyTask(int n) {; Thread.sleep(250L); println ""I'm awake! And I'm task $n""; }; ```. When run interactively, this should show a progress dialog (after a short delay). But when using *Run for project* it will switch to using a command line task runner, and not generate a new dialog of its own. The number of threads can also be specified. For example, for single-threaded tasks we can use; ```groovy; def runner = createTaskRunner(1); ```. This is an easy way to provide a progress monitor for multiple tasks.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1360
https://github.com/qupath/qupath/pull/1360:144,Modifiability,Plugin,PluginRunner,144,"Minor changes:; * Use 'crop' rather than 'trim' with Tiler; * Turn this setting off by default with `PixelProcessor`. Major change:; * Convert `PluginRunner` to `TaskRunner`; * Provide `QPEx.createTaskRunner()` and `QPEx.createTaskRunner(int nThreads)` methods. The reasoning is that `PluginRunner` no longer really makes sense as a name: the class rather represents a simple and generic way to run tasks in parallel. It's also more general than in previous QuPath releases. The following script shows it in action:. ```groovy; def tasks = []; for (int i in 1..50) {; int n = i; tasks << () -> sleepyTask(n); }. def runner = createTaskRunner(); runner.runTasks(tasks). def sleepyTask(int n) {; Thread.sleep(250L); println ""I'm awake! And I'm task $n""; }; ```. When run interactively, this should show a progress dialog (after a short delay). But when using *Run for project* it will switch to using a command line task runner, and not generate a new dialog of its own. The number of threads can also be specified. For example, for single-threaded tasks we can use; ```groovy; def runner = createTaskRunner(1); ```. This is an easy way to provide a progress monitor for multiple tasks.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1360
https://github.com/qupath/qupath/pull/1360:285,Modifiability,Plugin,PluginRunner,285,"Minor changes:; * Use 'crop' rather than 'trim' with Tiler; * Turn this setting off by default with `PixelProcessor`. Major change:; * Convert `PluginRunner` to `TaskRunner`; * Provide `QPEx.createTaskRunner()` and `QPEx.createTaskRunner(int nThreads)` methods. The reasoning is that `PluginRunner` no longer really makes sense as a name: the class rather represents a simple and generic way to run tasks in parallel. It's also more general than in previous QuPath releases. The following script shows it in action:. ```groovy; def tasks = []; for (int i in 1..50) {; int n = i; tasks << () -> sleepyTask(n); }. def runner = createTaskRunner(); runner.runTasks(tasks). def sleepyTask(int n) {; Thread.sleep(250L); println ""I'm awake! And I'm task $n""; }; ```. When run interactively, this should show a progress dialog (after a short delay). But when using *Run for project* it will switch to using a command line task runner, and not generate a new dialog of its own. The number of threads can also be specified. For example, for single-threaded tasks we can use; ```groovy; def runner = createTaskRunner(1); ```. This is an easy way to provide a progress monitor for multiple tasks.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1360
https://github.com/qupath/qupath/pull/1360:369,Usability,simpl,simple,369,"Minor changes:; * Use 'crop' rather than 'trim' with Tiler; * Turn this setting off by default with `PixelProcessor`. Major change:; * Convert `PluginRunner` to `TaskRunner`; * Provide `QPEx.createTaskRunner()` and `QPEx.createTaskRunner(int nThreads)` methods. The reasoning is that `PluginRunner` no longer really makes sense as a name: the class rather represents a simple and generic way to run tasks in parallel. It's also more general than in previous QuPath releases. The following script shows it in action:. ```groovy; def tasks = []; for (int i in 1..50) {; int n = i; tasks << () -> sleepyTask(n); }. def runner = createTaskRunner(); runner.runTasks(tasks). def sleepyTask(int n) {; Thread.sleep(250L); println ""I'm awake! And I'm task $n""; }; ```. When run interactively, this should show a progress dialog (after a short delay). But when using *Run for project* it will switch to using a command line task runner, and not generate a new dialog of its own. The number of threads can also be specified. For example, for single-threaded tasks we can use; ```groovy; def runner = createTaskRunner(1); ```. This is an easy way to provide a progress monitor for multiple tasks.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1360
https://github.com/qupath/qupath/pull/1362:63,Availability,error,errors,63,"In the log badge/info message, show only the count of *unseen* errors (i.e. those that have occurred since the log viewer was last visible).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1362
https://github.com/qupath/qupath/pull/1362:22,Integrability,message,message,22,"In the log badge/info message, show only the count of *unseen* errors (i.e. those that have occurred since the log viewer was last visible).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1362
https://github.com/qupath/qupath/pull/1362:7,Testability,log,log,7,"In the log badge/info message, show only the count of *unseen* errors (i.e. those that have occurred since the log viewer was last visible).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1362
https://github.com/qupath/qupath/pull/1362:111,Testability,log,log,111,"In the log badge/info message, show only the count of *unseen* errors (i.e. those that have occurred since the log viewer was last visible).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1362
https://github.com/qupath/qupath/pull/1364:2279,Availability,down,down,2279,"galAccessException: class qupath.lib.gui.prefs.QuPathStyleManager cannot access class com.sun.javafx.css.StyleManager (in module javafx.graphics) because module javafx.graphics does not export com.sun.javafx.css to unnamed module @6150c3ec; at java.base/jdk.internal.reflect.Reflection.newIllegalAccessException(Reflection.java:392); at java.base/java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:674); at java.base/java.lang.reflect.Method.invoke(Method.java:560); at qupath.lib.gui.prefs.QuPathStyleManager.addStyleSheets(QuPathStyleManager.java:576); ```. These could be addressed by adding; ```gradle; application {; // ... other stuff. // Necessary when using ./gradlew run to support style manager to change themes; applicationDefaultJvmArgs << '--add-opens'; applicationDefaultJvmArgs << 'javafx.graphics/com.sun.javafx.css=ALL-UNNAMED'; }; ```; However this doesn't seem to be needed when using the `jpackage` output, since there the module path still is not actually used (verified using the above script again). Problems still persisted with variant-related issues when building `qupath-app` specifically, which I eventually tracked down to the use of https://github.com/jk1/Gradle-License-Report. The workaround is to incorporate `excludeGroups = ['org.openjfx']` into `licenseReport` - which is unfortunate, but the JavaFX licenses should still be bundled in QuPath via other means. ----. The requirement for `--add-opens` made this a slightly scary change to make shortly before release, in case it is also needed in other places - but as far as I can tell its importance is limited to when `./gradlew run` is used and not the final packages. The reason for doing this anyway is that it should resolve a longstanding problem whereby JavaFX dependencies with classifiers relating to the build platform are included in the pom. This can be seen [here](https://maven.scijava.org/content/repositories/releases/io/github/qupath/qupath-gui-fx/0.4.4/qupath-gui-fx-0.4.4.pom).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1364
https://github.com/qupath/qupath/pull/1364:2628,Deployability,release,release,2628,"galAccessException: class qupath.lib.gui.prefs.QuPathStyleManager cannot access class com.sun.javafx.css.StyleManager (in module javafx.graphics) because module javafx.graphics does not export com.sun.javafx.css to unnamed module @6150c3ec; at java.base/jdk.internal.reflect.Reflection.newIllegalAccessException(Reflection.java:392); at java.base/java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:674); at java.base/java.lang.reflect.Method.invoke(Method.java:560); at qupath.lib.gui.prefs.QuPathStyleManager.addStyleSheets(QuPathStyleManager.java:576); ```. These could be addressed by adding; ```gradle; application {; // ... other stuff. // Necessary when using ./gradlew run to support style manager to change themes; applicationDefaultJvmArgs << '--add-opens'; applicationDefaultJvmArgs << 'javafx.graphics/com.sun.javafx.css=ALL-UNNAMED'; }; ```; However this doesn't seem to be needed when using the `jpackage` output, since there the module path still is not actually used (verified using the above script again). Problems still persisted with variant-related issues when building `qupath-app` specifically, which I eventually tracked down to the use of https://github.com/jk1/Gradle-License-Report. The workaround is to incorporate `excludeGroups = ['org.openjfx']` into `licenseReport` - which is unfortunate, but the JavaFX licenses should still be bundled in QuPath via other means. ----. The requirement for `--add-opens` made this a slightly scary change to make shortly before release, in case it is also needed in other places - but as far as I can tell its importance is limited to when `./gradlew run` is used and not the final packages. The reason for doing this anyway is that it should resolve a longstanding problem whereby JavaFX dependencies with classifiers relating to the build platform are included in the pom. This can be seen [here](https://maven.scijava.org/content/repositories/releases/io/github/qupath/qupath-gui-fx/0.4.4/qupath-gui-fx-0.4.4.pom).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1364
https://github.com/qupath/qupath/pull/1364:3046,Deployability,release,releases,3046,"galAccessException: class qupath.lib.gui.prefs.QuPathStyleManager cannot access class com.sun.javafx.css.StyleManager (in module javafx.graphics) because module javafx.graphics does not export com.sun.javafx.css to unnamed module @6150c3ec; at java.base/jdk.internal.reflect.Reflection.newIllegalAccessException(Reflection.java:392); at java.base/java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:674); at java.base/java.lang.reflect.Method.invoke(Method.java:560); at qupath.lib.gui.prefs.QuPathStyleManager.addStyleSheets(QuPathStyleManager.java:576); ```. These could be addressed by adding; ```gradle; application {; // ... other stuff. // Necessary when using ./gradlew run to support style manager to change themes; applicationDefaultJvmArgs << '--add-opens'; applicationDefaultJvmArgs << 'javafx.graphics/com.sun.javafx.css=ALL-UNNAMED'; }; ```; However this doesn't seem to be needed when using the `jpackage` output, since there the module path still is not actually used (verified using the above script again). Problems still persisted with variant-related issues when building `qupath-app` specifically, which I eventually tracked down to the use of https://github.com/jk1/Gradle-License-Report. The workaround is to incorporate `excludeGroups = ['org.openjfx']` into `licenseReport` - which is unfortunate, but the JavaFX licenses should still be bundled in QuPath via other means. ----. The requirement for `--add-opens` made this a slightly scary change to make shortly before release, in case it is also needed in other places - but as far as I can tell its importance is limited to when `./gradlew run` is used and not the final packages. The reason for doing this anyway is that it should resolve a longstanding problem whereby JavaFX dependencies with classifiers relating to the build platform are included in the pom. This can be seen [here](https://maven.scijava.org/content/repositories/releases/io/github/qupath/qupath-gui-fx/0.4.4/qupath-gui-fx-0.4.4.pom).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1364
https://github.com/qupath/qupath/pull/1364:2889,Integrability,depend,dependencies,2889,"galAccessException: class qupath.lib.gui.prefs.QuPathStyleManager cannot access class com.sun.javafx.css.StyleManager (in module javafx.graphics) because module javafx.graphics does not export com.sun.javafx.css to unnamed module @6150c3ec; at java.base/jdk.internal.reflect.Reflection.newIllegalAccessException(Reflection.java:392); at java.base/java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:674); at java.base/java.lang.reflect.Method.invoke(Method.java:560); at qupath.lib.gui.prefs.QuPathStyleManager.addStyleSheets(QuPathStyleManager.java:576); ```. These could be addressed by adding; ```gradle; application {; // ... other stuff. // Necessary when using ./gradlew run to support style manager to change themes; applicationDefaultJvmArgs << '--add-opens'; applicationDefaultJvmArgs << 'javafx.graphics/com.sun.javafx.css=ALL-UNNAMED'; }; ```; However this doesn't seem to be needed when using the `jpackage` output, since there the module path still is not actually used (verified using the above script again). Problems still persisted with variant-related issues when building `qupath-app` specifically, which I eventually tracked down to the use of https://github.com/jk1/Gradle-License-Report. The workaround is to incorporate `excludeGroups = ['org.openjfx']` into `licenseReport` - which is unfortunate, but the JavaFX licenses should still be bundled in QuPath via other means. ----. The requirement for `--add-opens` made this a slightly scary change to make shortly before release, in case it is also needed in other places - but as far as I can tell its importance is limited to when `./gradlew run` is used and not the final packages. The reason for doing this anyway is that it should resolve a longstanding problem whereby JavaFX dependencies with classifiers relating to the build platform are included in the pom. This can be seen [here](https://maven.scijava.org/content/repositories/releases/io/github/qupath/qupath-gui-fx/0.4.4/qupath-gui-fx-0.4.4.pom).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1364
https://github.com/qupath/qupath/pull/1364:207,Modifiability,plugin,plugin,207,"This was a more painful change than it sounds, but should resolve issue with JavaFX classifiers being included in published poms. ---. See the [migration guide here](https://github.com/openjfx/javafx-gradle-plugin#migrating-from-0014-to-010). The main QuPath-related issue seems to have been [sets the `--module-path` here](https://github.com/openjfx/javafx-gradle-plugin/blob/bdf717a65ab0caac9cfa677efc9d3943e6f8483e/src/main/java/org/openjfx/gradle/JavaFXPlugin.java#L105). The module path wasn't otherwise being set, as can be seen by running the one-line script in QuPath:; ```groovy; println System.properties['jdk.module.path']; ```; which prints `null`. To get things working with the v0.1.0 plugin, I had to specify JavaFX modules inside `qupath-app`:. ```groovy; javafx {; version = libs.versions.javafx.get(); modules = [""javafx.base"",; ""javafx.controls"",; ""javafx.graphics"",; ""javafx.media"",; ""javafx.fxml"",; ""javafx.web"",; ""javafx.swing""]; }; ```. But doing that led to exceptions when using `./gradlew run` . ```; q.lib.gui.prefs.QuPathStyleManager - Unable to call addUserAgentStylesheet; java.lang.IllegalAccessException: class qupath.lib.gui.prefs.QuPathStyleManager cannot access class com.sun.javafx.css.StyleManager (in module javafx.graphics) because module javafx.graphics does not export com.sun.javafx.css to unnamed module @6150c3ec; at java.base/jdk.internal.reflect.Reflection.newIllegalAccessException(Reflection.java:392); at java.base/java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:674); at java.base/java.lang.reflect.Method.invoke(Method.java:560); at qupath.lib.gui.prefs.QuPathStyleManager.addStyleSheets(QuPathStyleManager.java:576); ```. These could be addressed by adding; ```gradle; application {; // ... other stuff. // Necessary when using ./gradlew run to support style manager to change themes; applicationDefaultJvmArgs << '--add-opens'; applicationDefaultJvmArgs << 'javafx.graphics/com.sun.javafx.css=ALL-UNNAMED'; }; ```; However this",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1364
https://github.com/qupath/qupath/pull/1364:365,Modifiability,plugin,plugin,365,"This was a more painful change than it sounds, but should resolve issue with JavaFX classifiers being included in published poms. ---. See the [migration guide here](https://github.com/openjfx/javafx-gradle-plugin#migrating-from-0014-to-010). The main QuPath-related issue seems to have been [sets the `--module-path` here](https://github.com/openjfx/javafx-gradle-plugin/blob/bdf717a65ab0caac9cfa677efc9d3943e6f8483e/src/main/java/org/openjfx/gradle/JavaFXPlugin.java#L105). The module path wasn't otherwise being set, as can be seen by running the one-line script in QuPath:; ```groovy; println System.properties['jdk.module.path']; ```; which prints `null`. To get things working with the v0.1.0 plugin, I had to specify JavaFX modules inside `qupath-app`:. ```groovy; javafx {; version = libs.versions.javafx.get(); modules = [""javafx.base"",; ""javafx.controls"",; ""javafx.graphics"",; ""javafx.media"",; ""javafx.fxml"",; ""javafx.web"",; ""javafx.swing""]; }; ```. But doing that led to exceptions when using `./gradlew run` . ```; q.lib.gui.prefs.QuPathStyleManager - Unable to call addUserAgentStylesheet; java.lang.IllegalAccessException: class qupath.lib.gui.prefs.QuPathStyleManager cannot access class com.sun.javafx.css.StyleManager (in module javafx.graphics) because module javafx.graphics does not export com.sun.javafx.css to unnamed module @6150c3ec; at java.base/jdk.internal.reflect.Reflection.newIllegalAccessException(Reflection.java:392); at java.base/java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:674); at java.base/java.lang.reflect.Method.invoke(Method.java:560); at qupath.lib.gui.prefs.QuPathStyleManager.addStyleSheets(QuPathStyleManager.java:576); ```. These could be addressed by adding; ```gradle; application {; // ... other stuff. // Necessary when using ./gradlew run to support style manager to change themes; applicationDefaultJvmArgs << '--add-opens'; applicationDefaultJvmArgs << 'javafx.graphics/com.sun.javafx.css=ALL-UNNAMED'; }; ```; However this",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1364
https://github.com/qupath/qupath/pull/1364:699,Modifiability,plugin,plugin,699,"This was a more painful change than it sounds, but should resolve issue with JavaFX classifiers being included in published poms. ---. See the [migration guide here](https://github.com/openjfx/javafx-gradle-plugin#migrating-from-0014-to-010). The main QuPath-related issue seems to have been [sets the `--module-path` here](https://github.com/openjfx/javafx-gradle-plugin/blob/bdf717a65ab0caac9cfa677efc9d3943e6f8483e/src/main/java/org/openjfx/gradle/JavaFXPlugin.java#L105). The module path wasn't otherwise being set, as can be seen by running the one-line script in QuPath:; ```groovy; println System.properties['jdk.module.path']; ```; which prints `null`. To get things working with the v0.1.0 plugin, I had to specify JavaFX modules inside `qupath-app`:. ```groovy; javafx {; version = libs.versions.javafx.get(); modules = [""javafx.base"",; ""javafx.controls"",; ""javafx.graphics"",; ""javafx.media"",; ""javafx.fxml"",; ""javafx.web"",; ""javafx.swing""]; }; ```. But doing that led to exceptions when using `./gradlew run` . ```; q.lib.gui.prefs.QuPathStyleManager - Unable to call addUserAgentStylesheet; java.lang.IllegalAccessException: class qupath.lib.gui.prefs.QuPathStyleManager cannot access class com.sun.javafx.css.StyleManager (in module javafx.graphics) because module javafx.graphics does not export com.sun.javafx.css to unnamed module @6150c3ec; at java.base/jdk.internal.reflect.Reflection.newIllegalAccessException(Reflection.java:392); at java.base/java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:674); at java.base/java.lang.reflect.Method.invoke(Method.java:560); at qupath.lib.gui.prefs.QuPathStyleManager.addStyleSheets(QuPathStyleManager.java:576); ```. These could be addressed by adding; ```gradle; application {; // ... other stuff. // Necessary when using ./gradlew run to support style manager to change themes; applicationDefaultJvmArgs << '--add-opens'; applicationDefaultJvmArgs << 'javafx.graphics/com.sun.javafx.css=ALL-UNNAMED'; }; ```; However this",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1364
https://github.com/qupath/qupath/pull/1364:1190,Security,access,access,1190,"openjfx/javafx-gradle-plugin#migrating-from-0014-to-010). The main QuPath-related issue seems to have been [sets the `--module-path` here](https://github.com/openjfx/javafx-gradle-plugin/blob/bdf717a65ab0caac9cfa677efc9d3943e6f8483e/src/main/java/org/openjfx/gradle/JavaFXPlugin.java#L105). The module path wasn't otherwise being set, as can be seen by running the one-line script in QuPath:; ```groovy; println System.properties['jdk.module.path']; ```; which prints `null`. To get things working with the v0.1.0 plugin, I had to specify JavaFX modules inside `qupath-app`:. ```groovy; javafx {; version = libs.versions.javafx.get(); modules = [""javafx.base"",; ""javafx.controls"",; ""javafx.graphics"",; ""javafx.media"",; ""javafx.fxml"",; ""javafx.web"",; ""javafx.swing""]; }; ```. But doing that led to exceptions when using `./gradlew run` . ```; q.lib.gui.prefs.QuPathStyleManager - Unable to call addUserAgentStylesheet; java.lang.IllegalAccessException: class qupath.lib.gui.prefs.QuPathStyleManager cannot access class com.sun.javafx.css.StyleManager (in module javafx.graphics) because module javafx.graphics does not export com.sun.javafx.css to unnamed module @6150c3ec; at java.base/jdk.internal.reflect.Reflection.newIllegalAccessException(Reflection.java:392); at java.base/java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:674); at java.base/java.lang.reflect.Method.invoke(Method.java:560); at qupath.lib.gui.prefs.QuPathStyleManager.addStyleSheets(QuPathStyleManager.java:576); ```. These could be addressed by adding; ```gradle; application {; // ... other stuff. // Necessary when using ./gradlew run to support style manager to change themes; applicationDefaultJvmArgs << '--add-opens'; applicationDefaultJvmArgs << 'javafx.graphics/com.sun.javafx.css=ALL-UNNAMED'; }; ```; However this doesn't seem to be needed when using the `jpackage` output, since there the module path still is not actually used (verified using the above script again). Problems still persisted wit",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1364
https://github.com/qupath/qupath/pull/1364:1482,Security,Access,AccessibleObject,1482,"h wasn't otherwise being set, as can be seen by running the one-line script in QuPath:; ```groovy; println System.properties['jdk.module.path']; ```; which prints `null`. To get things working with the v0.1.0 plugin, I had to specify JavaFX modules inside `qupath-app`:. ```groovy; javafx {; version = libs.versions.javafx.get(); modules = [""javafx.base"",; ""javafx.controls"",; ""javafx.graphics"",; ""javafx.media"",; ""javafx.fxml"",; ""javafx.web"",; ""javafx.swing""]; }; ```. But doing that led to exceptions when using `./gradlew run` . ```; q.lib.gui.prefs.QuPathStyleManager - Unable to call addUserAgentStylesheet; java.lang.IllegalAccessException: class qupath.lib.gui.prefs.QuPathStyleManager cannot access class com.sun.javafx.css.StyleManager (in module javafx.graphics) because module javafx.graphics does not export com.sun.javafx.css to unnamed module @6150c3ec; at java.base/jdk.internal.reflect.Reflection.newIllegalAccessException(Reflection.java:392); at java.base/java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:674); at java.base/java.lang.reflect.Method.invoke(Method.java:560); at qupath.lib.gui.prefs.QuPathStyleManager.addStyleSheets(QuPathStyleManager.java:576); ```. These could be addressed by adding; ```gradle; application {; // ... other stuff. // Necessary when using ./gradlew run to support style manager to change themes; applicationDefaultJvmArgs << '--add-opens'; applicationDefaultJvmArgs << 'javafx.graphics/com.sun.javafx.css=ALL-UNNAMED'; }; ```; However this doesn't seem to be needed when using the `jpackage` output, since there the module path still is not actually used (verified using the above script again). Problems still persisted with variant-related issues when building `qupath-app` specifically, which I eventually tracked down to the use of https://github.com/jk1/Gradle-License-Report. The workaround is to incorporate `excludeGroups = ['org.openjfx']` into `licenseReport` - which is unfortunate, but the JavaFX licenses should stil",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1364
https://github.com/qupath/qupath/pull/1364:1511,Security,Access,AccessibleObject,1511,"g set, as can be seen by running the one-line script in QuPath:; ```groovy; println System.properties['jdk.module.path']; ```; which prints `null`. To get things working with the v0.1.0 plugin, I had to specify JavaFX modules inside `qupath-app`:. ```groovy; javafx {; version = libs.versions.javafx.get(); modules = [""javafx.base"",; ""javafx.controls"",; ""javafx.graphics"",; ""javafx.media"",; ""javafx.fxml"",; ""javafx.web"",; ""javafx.swing""]; }; ```. But doing that led to exceptions when using `./gradlew run` . ```; q.lib.gui.prefs.QuPathStyleManager - Unable to call addUserAgentStylesheet; java.lang.IllegalAccessException: class qupath.lib.gui.prefs.QuPathStyleManager cannot access class com.sun.javafx.css.StyleManager (in module javafx.graphics) because module javafx.graphics does not export com.sun.javafx.css to unnamed module @6150c3ec; at java.base/jdk.internal.reflect.Reflection.newIllegalAccessException(Reflection.java:392); at java.base/java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:674); at java.base/java.lang.reflect.Method.invoke(Method.java:560); at qupath.lib.gui.prefs.QuPathStyleManager.addStyleSheets(QuPathStyleManager.java:576); ```. These could be addressed by adding; ```gradle; application {; // ... other stuff. // Necessary when using ./gradlew run to support style manager to change themes; applicationDefaultJvmArgs << '--add-opens'; applicationDefaultJvmArgs << 'javafx.graphics/com.sun.javafx.css=ALL-UNNAMED'; }; ```; However this doesn't seem to be needed when using the `jpackage` output, since there the module path still is not actually used (verified using the above script again). Problems still persisted with variant-related issues when building `qupath-app` specifically, which I eventually tracked down to the use of https://github.com/jk1/Gradle-License-Report. The workaround is to incorporate `excludeGroups = ['org.openjfx']` into `licenseReport` - which is unfortunate, but the JavaFX licenses should still be bundled in QuPath ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1364
https://github.com/qupath/qupath/pull/1364:154,Usability,guid,guide,154,"This was a more painful change than it sounds, but should resolve issue with JavaFX classifiers being included in published poms. ---. See the [migration guide here](https://github.com/openjfx/javafx-gradle-plugin#migrating-from-0014-to-010). The main QuPath-related issue seems to have been [sets the `--module-path` here](https://github.com/openjfx/javafx-gradle-plugin/blob/bdf717a65ab0caac9cfa677efc9d3943e6f8483e/src/main/java/org/openjfx/gradle/JavaFXPlugin.java#L105). The module path wasn't otherwise being set, as can be seen by running the one-line script in QuPath:; ```groovy; println System.properties['jdk.module.path']; ```; which prints `null`. To get things working with the v0.1.0 plugin, I had to specify JavaFX modules inside `qupath-app`:. ```groovy; javafx {; version = libs.versions.javafx.get(); modules = [""javafx.base"",; ""javafx.controls"",; ""javafx.graphics"",; ""javafx.media"",; ""javafx.fxml"",; ""javafx.web"",; ""javafx.swing""]; }; ```. But doing that led to exceptions when using `./gradlew run` . ```; q.lib.gui.prefs.QuPathStyleManager - Unable to call addUserAgentStylesheet; java.lang.IllegalAccessException: class qupath.lib.gui.prefs.QuPathStyleManager cannot access class com.sun.javafx.css.StyleManager (in module javafx.graphics) because module javafx.graphics does not export com.sun.javafx.css to unnamed module @6150c3ec; at java.base/jdk.internal.reflect.Reflection.newIllegalAccessException(Reflection.java:392); at java.base/java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:674); at java.base/java.lang.reflect.Method.invoke(Method.java:560); at qupath.lib.gui.prefs.QuPathStyleManager.addStyleSheets(QuPathStyleManager.java:576); ```. These could be addressed by adding; ```gradle; application {; // ... other stuff. // Necessary when using ./gradlew run to support style manager to change themes; applicationDefaultJvmArgs << '--add-opens'; applicationDefaultJvmArgs << 'javafx.graphics/com.sun.javafx.css=ALL-UNNAMED'; }; ```; However this",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1364
https://github.com/qupath/qupath/pull/1365:283,Availability,avail,available,283,"Document that QuPath needs macOS 11 or later - although also add a flag so that it's possible to request a different JavaFX version when building (via a system property); ```; ./gradlew clean jpackage -Djavafx-version=20.0.2; ```; Also include the module path in the system info, if available (since this is set when using `gradlew run` and is handy to see for debugging).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1365
https://github.com/qupath/qupath/pull/1366:65,Usability,simpl,simpler,65,"Could add something to the PlatformPlugin code, but I think it's simpler just to explicitly build RPMs on Fedora. If we remove the tar.gz, we should probably provide instructions to make them from source, just in case somebody's workflow relies on it.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1366
https://github.com/qupath/qupath/pull/1367:243,Deployability,update,update,243,"Bring back several key methods and classes that are used in extensions, and mark them as deprecated while logging a warning the first time they are used. The purpose is to not break more extensions than necessary, and give a clue as to how to update the code for future compatibility.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1367
https://github.com/qupath/qupath/pull/1367:106,Testability,log,logging,106,"Bring back several key methods and classes that are used in extensions, and mark them as deprecated while logging a warning the first time they are used. The purpose is to not break more extensions than necessary, and give a clue as to how to update the code for future compatibility.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1367
https://github.com/qupath/qupath/pull/1368:77,Security,checksum,checksum,77,"This should create eg `build/dist/QuPath-0.5.0-SNAPSHOT.deb.sha512` with the checksum and the file name, for all platforms. Hopefully resolve #1027",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1368
https://github.com/qupath/qupath/pull/1369:88,Availability,avail,available,88,Include checksums when using jpackage.; Update gradle wrapper for Java 21 support (when available).,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1369
https://github.com/qupath/qupath/pull/1369:40,Deployability,Update,Update,40,Include checksums when using jpackage.; Update gradle wrapper for Java 21 support (when available).,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1369
https://github.com/qupath/qupath/pull/1369:54,Integrability,wrap,wrapper,54,Include checksums when using jpackage.; Update gradle wrapper for Java 21 support (when available).,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1369
https://github.com/qupath/qupath/pull/1369:8,Security,checksum,checksums,8,Include checksums when using jpackage.; Update gradle wrapper for Java 21 support (when available).,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1369
https://github.com/qupath/qupath/pull/1371:32,Deployability,install,installer,32,"- Delete .app when creating the installer on macOS; - Create the Windows .zip directly, so that the sha512 is also computed",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1371
https://github.com/qupath/qupath/pull/1372:17,Availability,error,error,17,Give more useful error logs when unable to open files.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1372
https://github.com/qupath/qupath/pull/1372:23,Testability,log,logs,23,Give more useful error logs when unable to open files.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1372
https://github.com/qupath/qupath/pull/1379:221,Availability,down,downloaded,221,"Fixes to undo this fix:; * https://github.com/qupath/qupath/issues/1337. It turned out to be problematic in subtle ways. The main one was that there were strange permissions issues *that only emerged when the package was downloaded and installed* (not built locally). Basically, QuPath could no longer open images within its own project *unless* it had 'seen' them before in almost any interactive way (e.g. the images were opened via drag & drop, or even pasted into the script editor). When that was the case, the image opened fine consistently - and across restarts of QuPath, but not of the OS as a whole. For images QuPath hadn't seen, `new File(path).canRead()` would return false and there seemed to be no code-based way to convince it otherwise. The image-reading library didn't matter: OpenSlide, Bio-Formats, ImageJ all failed. Setting full disk access seemed promising, but ultimately didn't work consistently. The only workaround was to launch QuPath via a terminal, avoiding `launchd`. The hint that this was to blame came from; ```; tccutil reset SystemPolicyAllFiles QuPath-0.5; ```; producing an error and a report that the .plist had been modified... so macOS *knew*. Reverting this plist changes (and using Java 17) was sufficient to get things working again. The noticeable difference is that, when first trying to open an image, a system dialog pops up to ask whether QuPath can have access to Documents/Desktop/Downloads - which never happened with the change. Along the way, I learned that; * https://github.com/qupath/qupath/issues/1358. first emerged in JavaFX 20.0.1 so this PR also reverts to JavaFX 20 for now. I wanted to use Java 20 as well, but it complained when trying to build the `.pkg` from an existing `.app` because it didn't like the `app/.jpackage.xml` so that's why we're back on 17 for now.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1379
https://github.com/qupath/qupath/pull/1379:1112,Availability,error,error,1112,"Fixes to undo this fix:; * https://github.com/qupath/qupath/issues/1337. It turned out to be problematic in subtle ways. The main one was that there were strange permissions issues *that only emerged when the package was downloaded and installed* (not built locally). Basically, QuPath could no longer open images within its own project *unless* it had 'seen' them before in almost any interactive way (e.g. the images were opened via drag & drop, or even pasted into the script editor). When that was the case, the image opened fine consistently - and across restarts of QuPath, but not of the OS as a whole. For images QuPath hadn't seen, `new File(path).canRead()` would return false and there seemed to be no code-based way to convince it otherwise. The image-reading library didn't matter: OpenSlide, Bio-Formats, ImageJ all failed. Setting full disk access seemed promising, but ultimately didn't work consistently. The only workaround was to launch QuPath via a terminal, avoiding `launchd`. The hint that this was to blame came from; ```; tccutil reset SystemPolicyAllFiles QuPath-0.5; ```; producing an error and a report that the .plist had been modified... so macOS *knew*. Reverting this plist changes (and using Java 17) was sufficient to get things working again. The noticeable difference is that, when first trying to open an image, a system dialog pops up to ask whether QuPath can have access to Documents/Desktop/Downloads - which never happened with the change. Along the way, I learned that; * https://github.com/qupath/qupath/issues/1358. first emerged in JavaFX 20.0.1 so this PR also reverts to JavaFX 20 for now. I wanted to use Java 20 as well, but it complained when trying to build the `.pkg` from an existing `.app` because it didn't like the `app/.jpackage.xml` so that's why we're back on 17 for now.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1379
https://github.com/qupath/qupath/pull/1379:1432,Availability,Down,Downloads,1432,"Fixes to undo this fix:; * https://github.com/qupath/qupath/issues/1337. It turned out to be problematic in subtle ways. The main one was that there were strange permissions issues *that only emerged when the package was downloaded and installed* (not built locally). Basically, QuPath could no longer open images within its own project *unless* it had 'seen' them before in almost any interactive way (e.g. the images were opened via drag & drop, or even pasted into the script editor). When that was the case, the image opened fine consistently - and across restarts of QuPath, but not of the OS as a whole. For images QuPath hadn't seen, `new File(path).canRead()` would return false and there seemed to be no code-based way to convince it otherwise. The image-reading library didn't matter: OpenSlide, Bio-Formats, ImageJ all failed. Setting full disk access seemed promising, but ultimately didn't work consistently. The only workaround was to launch QuPath via a terminal, avoiding `launchd`. The hint that this was to blame came from; ```; tccutil reset SystemPolicyAllFiles QuPath-0.5; ```; producing an error and a report that the .plist had been modified... so macOS *knew*. Reverting this plist changes (and using Java 17) was sufficient to get things working again. The noticeable difference is that, when first trying to open an image, a system dialog pops up to ask whether QuPath can have access to Documents/Desktop/Downloads - which never happened with the change. Along the way, I learned that; * https://github.com/qupath/qupath/issues/1358. first emerged in JavaFX 20.0.1 so this PR also reverts to JavaFX 20 for now. I wanted to use Java 20 as well, but it complained when trying to build the `.pkg` from an existing `.app` because it didn't like the `app/.jpackage.xml` so that's why we're back on 17 for now.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1379
https://github.com/qupath/qupath/pull/1379:236,Deployability,install,installed,236,"Fixes to undo this fix:; * https://github.com/qupath/qupath/issues/1337. It turned out to be problematic in subtle ways. The main one was that there were strange permissions issues *that only emerged when the package was downloaded and installed* (not built locally). Basically, QuPath could no longer open images within its own project *unless* it had 'seen' them before in almost any interactive way (e.g. the images were opened via drag & drop, or even pasted into the script editor). When that was the case, the image opened fine consistently - and across restarts of QuPath, but not of the OS as a whole. For images QuPath hadn't seen, `new File(path).canRead()` would return false and there seemed to be no code-based way to convince it otherwise. The image-reading library didn't matter: OpenSlide, Bio-Formats, ImageJ all failed. Setting full disk access seemed promising, but ultimately didn't work consistently. The only workaround was to launch QuPath via a terminal, avoiding `launchd`. The hint that this was to blame came from; ```; tccutil reset SystemPolicyAllFiles QuPath-0.5; ```; producing an error and a report that the .plist had been modified... so macOS *knew*. Reverting this plist changes (and using Java 17) was sufficient to get things working again. The noticeable difference is that, when first trying to open an image, a system dialog pops up to ask whether QuPath can have access to Documents/Desktop/Downloads - which never happened with the change. Along the way, I learned that; * https://github.com/qupath/qupath/issues/1358. first emerged in JavaFX 20.0.1 so this PR also reverts to JavaFX 20 for now. I wanted to use Java 20 as well, but it complained when trying to build the `.pkg` from an existing `.app` because it didn't like the `app/.jpackage.xml` so that's why we're back on 17 for now.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1379
https://github.com/qupath/qupath/pull/1379:979,Safety,avoid,avoiding,979,"Fixes to undo this fix:; * https://github.com/qupath/qupath/issues/1337. It turned out to be problematic in subtle ways. The main one was that there were strange permissions issues *that only emerged when the package was downloaded and installed* (not built locally). Basically, QuPath could no longer open images within its own project *unless* it had 'seen' them before in almost any interactive way (e.g. the images were opened via drag & drop, or even pasted into the script editor). When that was the case, the image opened fine consistently - and across restarts of QuPath, but not of the OS as a whole. For images QuPath hadn't seen, `new File(path).canRead()` would return false and there seemed to be no code-based way to convince it otherwise. The image-reading library didn't matter: OpenSlide, Bio-Formats, ImageJ all failed. Setting full disk access seemed promising, but ultimately didn't work consistently. The only workaround was to launch QuPath via a terminal, avoiding `launchd`. The hint that this was to blame came from; ```; tccutil reset SystemPolicyAllFiles QuPath-0.5; ```; producing an error and a report that the .plist had been modified... so macOS *knew*. Reverting this plist changes (and using Java 17) was sufficient to get things working again. The noticeable difference is that, when first trying to open an image, a system dialog pops up to ask whether QuPath can have access to Documents/Desktop/Downloads - which never happened with the change. Along the way, I learned that; * https://github.com/qupath/qupath/issues/1358. first emerged in JavaFX 20.0.1 so this PR also reverts to JavaFX 20 for now. I wanted to use Java 20 as well, but it complained when trying to build the `.pkg` from an existing `.app` because it didn't like the `app/.jpackage.xml` so that's why we're back on 17 for now.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1379
https://github.com/qupath/qupath/pull/1379:856,Security,access,access,856,"Fixes to undo this fix:; * https://github.com/qupath/qupath/issues/1337. It turned out to be problematic in subtle ways. The main one was that there were strange permissions issues *that only emerged when the package was downloaded and installed* (not built locally). Basically, QuPath could no longer open images within its own project *unless* it had 'seen' them before in almost any interactive way (e.g. the images were opened via drag & drop, or even pasted into the script editor). When that was the case, the image opened fine consistently - and across restarts of QuPath, but not of the OS as a whole. For images QuPath hadn't seen, `new File(path).canRead()` would return false and there seemed to be no code-based way to convince it otherwise. The image-reading library didn't matter: OpenSlide, Bio-Formats, ImageJ all failed. Setting full disk access seemed promising, but ultimately didn't work consistently. The only workaround was to launch QuPath via a terminal, avoiding `launchd`. The hint that this was to blame came from; ```; tccutil reset SystemPolicyAllFiles QuPath-0.5; ```; producing an error and a report that the .plist had been modified... so macOS *knew*. Reverting this plist changes (and using Java 17) was sufficient to get things working again. The noticeable difference is that, when first trying to open an image, a system dialog pops up to ask whether QuPath can have access to Documents/Desktop/Downloads - which never happened with the change. Along the way, I learned that; * https://github.com/qupath/qupath/issues/1358. first emerged in JavaFX 20.0.1 so this PR also reverts to JavaFX 20 for now. I wanted to use Java 20 as well, but it complained when trying to build the `.pkg` from an existing `.app` because it didn't like the `app/.jpackage.xml` so that's why we're back on 17 for now.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1379
https://github.com/qupath/qupath/pull/1379:1404,Security,access,access,1404,"Fixes to undo this fix:; * https://github.com/qupath/qupath/issues/1337. It turned out to be problematic in subtle ways. The main one was that there were strange permissions issues *that only emerged when the package was downloaded and installed* (not built locally). Basically, QuPath could no longer open images within its own project *unless* it had 'seen' them before in almost any interactive way (e.g. the images were opened via drag & drop, or even pasted into the script editor). When that was the case, the image opened fine consistently - and across restarts of QuPath, but not of the OS as a whole. For images QuPath hadn't seen, `new File(path).canRead()` would return false and there seemed to be no code-based way to convince it otherwise. The image-reading library didn't matter: OpenSlide, Bio-Formats, ImageJ all failed. Setting full disk access seemed promising, but ultimately didn't work consistently. The only workaround was to launch QuPath via a terminal, avoiding `launchd`. The hint that this was to blame came from; ```; tccutil reset SystemPolicyAllFiles QuPath-0.5; ```; producing an error and a report that the .plist had been modified... so macOS *knew*. Reverting this plist changes (and using Java 17) was sufficient to get things working again. The noticeable difference is that, when first trying to open an image, a system dialog pops up to ask whether QuPath can have access to Documents/Desktop/Downloads - which never happened with the change. Along the way, I learned that; * https://github.com/qupath/qupath/issues/1358. first emerged in JavaFX 20.0.1 so this PR also reverts to JavaFX 20 for now. I wanted to use Java 20 as well, but it complained when trying to build the `.pkg` from an existing `.app` because it didn't like the `app/.jpackage.xml` so that's why we're back on 17 for now.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1379
https://github.com/qupath/qupath/pull/1379:9,Usability,undo,undo,9,"Fixes to undo this fix:; * https://github.com/qupath/qupath/issues/1337. It turned out to be problematic in subtle ways. The main one was that there were strange permissions issues *that only emerged when the package was downloaded and installed* (not built locally). Basically, QuPath could no longer open images within its own project *unless* it had 'seen' them before in almost any interactive way (e.g. the images were opened via drag & drop, or even pasted into the script editor). When that was the case, the image opened fine consistently - and across restarts of QuPath, but not of the OS as a whole. For images QuPath hadn't seen, `new File(path).canRead()` would return false and there seemed to be no code-based way to convince it otherwise. The image-reading library didn't matter: OpenSlide, Bio-Formats, ImageJ all failed. Setting full disk access seemed promising, but ultimately didn't work consistently. The only workaround was to launch QuPath via a terminal, avoiding `launchd`. The hint that this was to blame came from; ```; tccutil reset SystemPolicyAllFiles QuPath-0.5; ```; producing an error and a report that the .plist had been modified... so macOS *knew*. Reverting this plist changes (and using Java 17) was sufficient to get things working again. The noticeable difference is that, when first trying to open an image, a system dialog pops up to ask whether QuPath can have access to Documents/Desktop/Downloads - which never happened with the change. Along the way, I learned that; * https://github.com/qupath/qupath/issues/1358. first emerged in JavaFX 20.0.1 so this PR also reverts to JavaFX 20 for now. I wanted to use Java 20 as well, but it complained when trying to build the `.pkg` from an existing `.app` because it didn't like the `app/.jpackage.xml` so that's why we're back on 17 for now.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1379
https://github.com/qupath/qupath/pull/1379:1499,Usability,learn,learned,1499,"Fixes to undo this fix:; * https://github.com/qupath/qupath/issues/1337. It turned out to be problematic in subtle ways. The main one was that there were strange permissions issues *that only emerged when the package was downloaded and installed* (not built locally). Basically, QuPath could no longer open images within its own project *unless* it had 'seen' them before in almost any interactive way (e.g. the images were opened via drag & drop, or even pasted into the script editor). When that was the case, the image opened fine consistently - and across restarts of QuPath, but not of the OS as a whole. For images QuPath hadn't seen, `new File(path).canRead()` would return false and there seemed to be no code-based way to convince it otherwise. The image-reading library didn't matter: OpenSlide, Bio-Formats, ImageJ all failed. Setting full disk access seemed promising, but ultimately didn't work consistently. The only workaround was to launch QuPath via a terminal, avoiding `launchd`. The hint that this was to blame came from; ```; tccutil reset SystemPolicyAllFiles QuPath-0.5; ```; producing an error and a report that the .plist had been modified... so macOS *knew*. Reverting this plist changes (and using Java 17) was sufficient to get things working again. The noticeable difference is that, when first trying to open an image, a system dialog pops up to ask whether QuPath can have access to Documents/Desktop/Downloads - which never happened with the change. Along the way, I learned that; * https://github.com/qupath/qupath/issues/1358. first emerged in JavaFX 20.0.1 so this PR also reverts to JavaFX 20 for now. I wanted to use Java 20 as well, but it complained when trying to build the `.pkg` from an existing `.app` because it didn't like the `app/.jpackage.xml` so that's why we're back on 17 for now.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1379
https://github.com/qupath/qupath/pull/1389:52,Deployability,update,update,52,"Request main packages to be built with Java 21, and update several dependencies (DeepJavaLibrary, Guava and Bio-Formats).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1389
https://github.com/qupath/qupath/pull/1389:67,Integrability,depend,dependencies,67,"Request main packages to be built with Java 21, and update several dependencies (DeepJavaLibrary, Guava and Bio-Formats).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1389
https://github.com/qupath/qupath/pull/1390:111,Safety,detect,detection,111,Weird resizing bug when clicking into / out of a dialog created from `ParameterPanelFX` (e.g. the default cell detection) caused the font to change. Spotted by @finglis,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1390
https://github.com/qupath/qupath/pull/1391:102,Availability,error,error,102,"* Add fill/unfill annotations toolbar button; * Reduce update check fail to a warning (rather than an error); * Show a more informative message is (probably) unable to connect to the internet; * Add 'Training data' title to object/pixel classifier training pie charts; * Remove confusion about whether the pie charts refer to the training or predictions; * Support log histograms with 'single measurement classifier' and 'set cell intensity classification' commands; * Fix the extensions directory path (use 'extensions' subdirectory, not the user path)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1391
https://github.com/qupath/qupath/pull/1391:55,Deployability,update,update,55,"* Add fill/unfill annotations toolbar button; * Reduce update check fail to a warning (rather than an error); * Show a more informative message is (probably) unable to connect to the internet; * Add 'Training data' title to object/pixel classifier training pie charts; * Remove confusion about whether the pie charts refer to the training or predictions; * Support log histograms with 'single measurement classifier' and 'set cell intensity classification' commands; * Fix the extensions directory path (use 'extensions' subdirectory, not the user path)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1391
https://github.com/qupath/qupath/pull/1391:48,Energy Efficiency,Reduce,Reduce,48,"* Add fill/unfill annotations toolbar button; * Reduce update check fail to a warning (rather than an error); * Show a more informative message is (probably) unable to connect to the internet; * Add 'Training data' title to object/pixel classifier training pie charts; * Remove confusion about whether the pie charts refer to the training or predictions; * Support log histograms with 'single measurement classifier' and 'set cell intensity classification' commands; * Fix the extensions directory path (use 'extensions' subdirectory, not the user path)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1391
https://github.com/qupath/qupath/pull/1391:136,Integrability,message,message,136,"* Add fill/unfill annotations toolbar button; * Reduce update check fail to a warning (rather than an error); * Show a more informative message is (probably) unable to connect to the internet; * Add 'Training data' title to object/pixel classifier training pie charts; * Remove confusion about whether the pie charts refer to the training or predictions; * Support log histograms with 'single measurement classifier' and 'set cell intensity classification' commands; * Fix the extensions directory path (use 'extensions' subdirectory, not the user path)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1391
https://github.com/qupath/qupath/pull/1391:342,Safety,predict,predictions,342,"* Add fill/unfill annotations toolbar button; * Reduce update check fail to a warning (rather than an error); * Show a more informative message is (probably) unable to connect to the internet; * Add 'Training data' title to object/pixel classifier training pie charts; * Remove confusion about whether the pie charts refer to the training or predictions; * Support log histograms with 'single measurement classifier' and 'set cell intensity classification' commands; * Fix the extensions directory path (use 'extensions' subdirectory, not the user path)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1391
https://github.com/qupath/qupath/pull/1391:365,Testability,log,log,365,"* Add fill/unfill annotations toolbar button; * Reduce update check fail to a warning (rather than an error); * Show a more informative message is (probably) unable to connect to the internet; * Add 'Training data' title to object/pixel classifier training pie charts; * Remove confusion about whether the pie charts refer to the training or predictions; * Support log histograms with 'single measurement classifier' and 'set cell intensity classification' commands; * Fix the extensions directory path (use 'extensions' subdirectory, not the user path)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1391
https://github.com/qupath/qupath/pull/1392:72,Energy Efficiency,reduce,reduce,72,"* Use 'classification' rather then 'class' (to improve consistency, and reduce confusion with Java classes); * Add a new 'Object type' measurement to tables, giving a readable string ('Annotation', 'Detection', 'Cell' etc.); * No longer show a default 'Name' if no name has been set; * i.e. don't show 'PathAnnotationObject' or the classification as a placeholder, since this causes confusion for people writing scripts and requesting the name; * Renaming 'counting dialog' to 'points dialog'. Two bug fixes:; * Restore the classification colors in icons for points ROIs (regression in v0.5.0-rc1); * Fix bug that causes the pixel classifier training dialog to increase its width when some combo boxes were clicked on",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1392
https://github.com/qupath/qupath/pull/1392:199,Safety,Detect,Detection,199,"* Use 'classification' rather then 'class' (to improve consistency, and reduce confusion with Java classes); * Add a new 'Object type' measurement to tables, giving a readable string ('Annotation', 'Detection', 'Cell' etc.); * No longer show a default 'Name' if no name has been set; * i.e. don't show 'PathAnnotationObject' or the classification as a placeholder, since this causes confusion for people writing scripts and requesting the name; * Renaming 'counting dialog' to 'points dialog'. Two bug fixes:; * Restore the classification colors in icons for points ROIs (regression in v0.5.0-rc1); * Fix bug that causes the pixel classifier training dialog to increase its width when some combo boxes were clicked on",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1392
https://github.com/qupath/qupath/pull/1395:0,Deployability,Update,Update,0,Update to handle mac version on Java 21,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1395
https://github.com/qupath/qupath/pull/1398:278,Deployability,toggle,toggle,278,"Avoid setting a 'zoom-to-fit' status that affects all viewers, but instead just adjust the zoom/positioning of the current viewer. This is to avoid the problem where a user might accidentally select the option, and then find themselves unable to zoom/pan in the image until the toggle has been deselected. Also turn off 'synchronize viewers' by default, but also make it a *persistent preference* so that its status is remembered when QuPath is restarted.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1398
https://github.com/qupath/qupath/pull/1398:321,Integrability,synchroniz,synchronize,321,"Avoid setting a 'zoom-to-fit' status that affects all viewers, but instead just adjust the zoom/positioning of the current viewer. This is to avoid the problem where a user might accidentally select the option, and then find themselves unable to zoom/pan in the image until the toggle has been deselected. Also turn off 'synchronize viewers' by default, but also make it a *persistent preference* so that its status is remembered when QuPath is restarted.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1398
https://github.com/qupath/qupath/pull/1398:0,Safety,Avoid,Avoid,0,"Avoid setting a 'zoom-to-fit' status that affects all viewers, but instead just adjust the zoom/positioning of the current viewer. This is to avoid the problem where a user might accidentally select the option, and then find themselves unable to zoom/pan in the image until the toggle has been deselected. Also turn off 'synchronize viewers' by default, but also make it a *persistent preference* so that its status is remembered when QuPath is restarted.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1398
https://github.com/qupath/qupath/pull/1398:142,Safety,avoid,avoid,142,"Avoid setting a 'zoom-to-fit' status that affects all viewers, but instead just adjust the zoom/positioning of the current viewer. This is to avoid the problem where a user might accidentally select the option, and then find themselves unable to zoom/pan in the image until the toggle has been deselected. Also turn off 'synchronize viewers' by default, but also make it a *persistent preference* so that its status is remembered when QuPath is restarted.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1398
https://github.com/qupath/qupath/issues/1400:324,Modifiability,layers,layers,324,"**Describe the bug**; Opening a different image while a pyramid level is being rendered can cause QuPath to be unresponsive. A user can encounter this if they're quickly going through images searching for an example of some biological phenomenon (e.g. tumor infiltrating lymphocytes), which requires high resolution pyramid layers (level 0) to be rendered. This is easier to reproduce on systems in which rendering is slower, such as projects with image files located on HDDs, images lacking pyramids, and low core count CPUs. The images shown in the demo are 16-channel images from the COMET system, roughly 46.8 Gb in size, stored locally on an external HDD, and were converted to OME-TIFFs using the following script shown at the end of this ticket. There was a marginal decrease in instances of QuPath freezing when generating pyramids this way, rather than have bioformats handle it during import, so Pete's recommendation of pyramiding the images seems to have helped. **To Reproduce**; Video recording with Visual VM process sampling: https://youtu.be/Pas61jyrWGQ?si=lYsq57oy5-pyANnU; 1. Create a project with several large (>40Gb) multiplexed images; 2. Quickly zoom in, then open another image; 3. If QuPath doesn't become unresponsive, repeat the previous step with a new image, until it does. **Expected behavior**; Any processes related to rendering of the closed image should be stopped, and QuPath should remain responsive. **Screenshots**. Hang on StopWaiting():; ![StopWaiting screenshot](https://github.com/qupath/qupath/assets/52012166/05ac8527-76e4-4245-9cf5-9323681e6d2a); Hang on FutureTask.get():; ![FutureTask get screenshot](https://github.com/qupath/qupath/assets/52012166/c6ba65c6-268f-4202-83f9-782b7ed27035). **Desktop (please complete the following information):**; - OS: Windows 11 - 10.0; - Version: 0.5.0-rc1 (able to reproduce on 0.4.3 too); - Build time: 2023-10-06, 13:28; - Latest commit tag: '2241237'; ; **Additional context**; OME-TIFF conversion script:; ```; /",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1400
https://github.com/qupath/qupath/issues/1400:1426,Usability,responsiv,responsive,1426,"r to reproduce on systems in which rendering is slower, such as projects with image files located on HDDs, images lacking pyramids, and low core count CPUs. The images shown in the demo are 16-channel images from the COMET system, roughly 46.8 Gb in size, stored locally on an external HDD, and were converted to OME-TIFFs using the following script shown at the end of this ticket. There was a marginal decrease in instances of QuPath freezing when generating pyramids this way, rather than have bioformats handle it during import, so Pete's recommendation of pyramiding the images seems to have helped. **To Reproduce**; Video recording with Visual VM process sampling: https://youtu.be/Pas61jyrWGQ?si=lYsq57oy5-pyANnU; 1. Create a project with several large (>40Gb) multiplexed images; 2. Quickly zoom in, then open another image; 3. If QuPath doesn't become unresponsive, repeat the previous step with a new image, until it does. **Expected behavior**; Any processes related to rendering of the closed image should be stopped, and QuPath should remain responsive. **Screenshots**. Hang on StopWaiting():; ![StopWaiting screenshot](https://github.com/qupath/qupath/assets/52012166/05ac8527-76e4-4245-9cf5-9323681e6d2a); Hang on FutureTask.get():; ![FutureTask get screenshot](https://github.com/qupath/qupath/assets/52012166/c6ba65c6-268f-4202-83f9-782b7ed27035). **Desktop (please complete the following information):**; - OS: Windows 11 - 10.0; - Version: 0.5.0-rc1 (able to reproduce on 0.4.3 too); - Build time: 2023-10-06, 13:28; - Latest commit tag: '2241237'; ; **Additional context**; OME-TIFF conversion script:; ```; // **** Save 32bit multichannel ICW image as OMETiff in QuPath 0.4.0_SNAPSHOT ****. import javafx.application.Platform; import qupath.lib.scripting.QP; import qupath.lib.projects.Project; import qupath.lib.gui.scripting.QPEx; import qupath.lib.images.writers.ome.OMEPyramidWriter. // ****** PARAMETERS *********. def outpath = ""E:/pyramided images/"". // OME.Tiff paramet",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1400
https://github.com/qupath/qupath/pull/1402:71,Availability,error,errors,71,"Update logic related to reading/importing images, to try to have fewer errors and more informative messages logged when errors do occur. ## Improve checks for Bio-Formats image support. Throw an exception if unable to read a single pixel from a Bio-Formats image.; Accessing the pixel may introduce some overhead when importing images, but it avoids problems where metadata can be parsed yet the fact the image can't actually be read only becomes apparent later. This was causing trouble with .ndpi on Apple Silicon, because skipping the use of NDPIReader was causing a fallback to a regular TIFF reader... and this didn't recognize the image as pyramidal and couldn't read the pixels. So requesting Bio-Formats for .ndpi was both adding many (~12) images to a project (for the different pyramid levels), and not actually able to open them. Also fix the logic for determining which IFormatReader is used for a specified image. This was previously giving ImageReader rather than the specific reader, and therefore wasn't properly enabling the reader check to be skipped for readers generated in other threads. This also had an extra issue in Apple Silicon, because these checks could cause exceptions regarding unsupported libraries being logged, even if they weren't relevant to the image itself. ## Improve use of json with image servers. Make `JSONImageServerBuilder` genuinely useful by enabling it to read the server.json files stored within projects. This could potentially help in the future if attempting to recover data from a broken project. This involves estimating the ""builderType"" since that wasn't actually serialized within the server.json before. To simplify things in the future, the server.json now serializes the `ImageServer` and not the `ServerBuilder` - so that more information is present.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1402
https://github.com/qupath/qupath/pull/1402:120,Availability,error,errors,120,"Update logic related to reading/importing images, to try to have fewer errors and more informative messages logged when errors do occur. ## Improve checks for Bio-Formats image support. Throw an exception if unable to read a single pixel from a Bio-Formats image.; Accessing the pixel may introduce some overhead when importing images, but it avoids problems where metadata can be parsed yet the fact the image can't actually be read only becomes apparent later. This was causing trouble with .ndpi on Apple Silicon, because skipping the use of NDPIReader was causing a fallback to a regular TIFF reader... and this didn't recognize the image as pyramidal and couldn't read the pixels. So requesting Bio-Formats for .ndpi was both adding many (~12) images to a project (for the different pyramid levels), and not actually able to open them. Also fix the logic for determining which IFormatReader is used for a specified image. This was previously giving ImageReader rather than the specific reader, and therefore wasn't properly enabling the reader check to be skipped for readers generated in other threads. This also had an extra issue in Apple Silicon, because these checks could cause exceptions regarding unsupported libraries being logged, even if they weren't relevant to the image itself. ## Improve use of json with image servers. Make `JSONImageServerBuilder` genuinely useful by enabling it to read the server.json files stored within projects. This could potentially help in the future if attempting to recover data from a broken project. This involves estimating the ""builderType"" since that wasn't actually serialized within the server.json before. To simplify things in the future, the server.json now serializes the `ImageServer` and not the `ServerBuilder` - so that more information is present.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1402
https://github.com/qupath/qupath/pull/1402:1515,Availability,recover,recover,1515,"Update logic related to reading/importing images, to try to have fewer errors and more informative messages logged when errors do occur. ## Improve checks for Bio-Formats image support. Throw an exception if unable to read a single pixel from a Bio-Formats image.; Accessing the pixel may introduce some overhead when importing images, but it avoids problems where metadata can be parsed yet the fact the image can't actually be read only becomes apparent later. This was causing trouble with .ndpi on Apple Silicon, because skipping the use of NDPIReader was causing a fallback to a regular TIFF reader... and this didn't recognize the image as pyramidal and couldn't read the pixels. So requesting Bio-Formats for .ndpi was both adding many (~12) images to a project (for the different pyramid levels), and not actually able to open them. Also fix the logic for determining which IFormatReader is used for a specified image. This was previously giving ImageReader rather than the specific reader, and therefore wasn't properly enabling the reader check to be skipped for readers generated in other threads. This also had an extra issue in Apple Silicon, because these checks could cause exceptions regarding unsupported libraries being logged, even if they weren't relevant to the image itself. ## Improve use of json with image servers. Make `JSONImageServerBuilder` genuinely useful by enabling it to read the server.json files stored within projects. This could potentially help in the future if attempting to recover data from a broken project. This involves estimating the ""builderType"" since that wasn't actually serialized within the server.json before. To simplify things in the future, the server.json now serializes the `ImageServer` and not the `ServerBuilder` - so that more information is present.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1402
https://github.com/qupath/qupath/pull/1402:0,Deployability,Update,Update,0,"Update logic related to reading/importing images, to try to have fewer errors and more informative messages logged when errors do occur. ## Improve checks for Bio-Formats image support. Throw an exception if unable to read a single pixel from a Bio-Formats image.; Accessing the pixel may introduce some overhead when importing images, but it avoids problems where metadata can be parsed yet the fact the image can't actually be read only becomes apparent later. This was causing trouble with .ndpi on Apple Silicon, because skipping the use of NDPIReader was causing a fallback to a regular TIFF reader... and this didn't recognize the image as pyramidal and couldn't read the pixels. So requesting Bio-Formats for .ndpi was both adding many (~12) images to a project (for the different pyramid levels), and not actually able to open them. Also fix the logic for determining which IFormatReader is used for a specified image. This was previously giving ImageReader rather than the specific reader, and therefore wasn't properly enabling the reader check to be skipped for readers generated in other threads. This also had an extra issue in Apple Silicon, because these checks could cause exceptions regarding unsupported libraries being logged, even if they weren't relevant to the image itself. ## Improve use of json with image servers. Make `JSONImageServerBuilder` genuinely useful by enabling it to read the server.json files stored within projects. This could potentially help in the future if attempting to recover data from a broken project. This involves estimating the ""builderType"" since that wasn't actually serialized within the server.json before. To simplify things in the future, the server.json now serializes the `ImageServer` and not the `ServerBuilder` - so that more information is present.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1402
https://github.com/qupath/qupath/pull/1402:99,Integrability,message,messages,99,"Update logic related to reading/importing images, to try to have fewer errors and more informative messages logged when errors do occur. ## Improve checks for Bio-Formats image support. Throw an exception if unable to read a single pixel from a Bio-Formats image.; Accessing the pixel may introduce some overhead when importing images, but it avoids problems where metadata can be parsed yet the fact the image can't actually be read only becomes apparent later. This was causing trouble with .ndpi on Apple Silicon, because skipping the use of NDPIReader was causing a fallback to a regular TIFF reader... and this didn't recognize the image as pyramidal and couldn't read the pixels. So requesting Bio-Formats for .ndpi was both adding many (~12) images to a project (for the different pyramid levels), and not actually able to open them. Also fix the logic for determining which IFormatReader is used for a specified image. This was previously giving ImageReader rather than the specific reader, and therefore wasn't properly enabling the reader check to be skipped for readers generated in other threads. This also had an extra issue in Apple Silicon, because these checks could cause exceptions regarding unsupported libraries being logged, even if they weren't relevant to the image itself. ## Improve use of json with image servers. Make `JSONImageServerBuilder` genuinely useful by enabling it to read the server.json files stored within projects. This could potentially help in the future if attempting to recover data from a broken project. This involves estimating the ""builderType"" since that wasn't actually serialized within the server.json before. To simplify things in the future, the server.json now serializes the `ImageServer` and not the `ServerBuilder` - so that more information is present.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1402
https://github.com/qupath/qupath/pull/1402:343,Safety,avoid,avoids,343,"Update logic related to reading/importing images, to try to have fewer errors and more informative messages logged when errors do occur. ## Improve checks for Bio-Formats image support. Throw an exception if unable to read a single pixel from a Bio-Formats image.; Accessing the pixel may introduce some overhead when importing images, but it avoids problems where metadata can be parsed yet the fact the image can't actually be read only becomes apparent later. This was causing trouble with .ndpi on Apple Silicon, because skipping the use of NDPIReader was causing a fallback to a regular TIFF reader... and this didn't recognize the image as pyramidal and couldn't read the pixels. So requesting Bio-Formats for .ndpi was both adding many (~12) images to a project (for the different pyramid levels), and not actually able to open them. Also fix the logic for determining which IFormatReader is used for a specified image. This was previously giving ImageReader rather than the specific reader, and therefore wasn't properly enabling the reader check to be skipped for readers generated in other threads. This also had an extra issue in Apple Silicon, because these checks could cause exceptions regarding unsupported libraries being logged, even if they weren't relevant to the image itself. ## Improve use of json with image servers. Make `JSONImageServerBuilder` genuinely useful by enabling it to read the server.json files stored within projects. This could potentially help in the future if attempting to recover data from a broken project. This involves estimating the ""builderType"" since that wasn't actually serialized within the server.json before. To simplify things in the future, the server.json now serializes the `ImageServer` and not the `ServerBuilder` - so that more information is present.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1402
https://github.com/qupath/qupath/pull/1402:1515,Safety,recover,recover,1515,"Update logic related to reading/importing images, to try to have fewer errors and more informative messages logged when errors do occur. ## Improve checks for Bio-Formats image support. Throw an exception if unable to read a single pixel from a Bio-Formats image.; Accessing the pixel may introduce some overhead when importing images, but it avoids problems where metadata can be parsed yet the fact the image can't actually be read only becomes apparent later. This was causing trouble with .ndpi on Apple Silicon, because skipping the use of NDPIReader was causing a fallback to a regular TIFF reader... and this didn't recognize the image as pyramidal and couldn't read the pixels. So requesting Bio-Formats for .ndpi was both adding many (~12) images to a project (for the different pyramid levels), and not actually able to open them. Also fix the logic for determining which IFormatReader is used for a specified image. This was previously giving ImageReader rather than the specific reader, and therefore wasn't properly enabling the reader check to be skipped for readers generated in other threads. This also had an extra issue in Apple Silicon, because these checks could cause exceptions regarding unsupported libraries being logged, even if they weren't relevant to the image itself. ## Improve use of json with image servers. Make `JSONImageServerBuilder` genuinely useful by enabling it to read the server.json files stored within projects. This could potentially help in the future if attempting to recover data from a broken project. This involves estimating the ""builderType"" since that wasn't actually serialized within the server.json before. To simplify things in the future, the server.json now serializes the `ImageServer` and not the `ServerBuilder` - so that more information is present.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1402
https://github.com/qupath/qupath/pull/1402:265,Security,Access,Accessing,265,"Update logic related to reading/importing images, to try to have fewer errors and more informative messages logged when errors do occur. ## Improve checks for Bio-Formats image support. Throw an exception if unable to read a single pixel from a Bio-Formats image.; Accessing the pixel may introduce some overhead when importing images, but it avoids problems where metadata can be parsed yet the fact the image can't actually be read only becomes apparent later. This was causing trouble with .ndpi on Apple Silicon, because skipping the use of NDPIReader was causing a fallback to a regular TIFF reader... and this didn't recognize the image as pyramidal and couldn't read the pixels. So requesting Bio-Formats for .ndpi was both adding many (~12) images to a project (for the different pyramid levels), and not actually able to open them. Also fix the logic for determining which IFormatReader is used for a specified image. This was previously giving ImageReader rather than the specific reader, and therefore wasn't properly enabling the reader check to be skipped for readers generated in other threads. This also had an extra issue in Apple Silicon, because these checks could cause exceptions regarding unsupported libraries being logged, even if they weren't relevant to the image itself. ## Improve use of json with image servers. Make `JSONImageServerBuilder` genuinely useful by enabling it to read the server.json files stored within projects. This could potentially help in the future if attempting to recover data from a broken project. This involves estimating the ""builderType"" since that wasn't actually serialized within the server.json before. To simplify things in the future, the server.json now serializes the `ImageServer` and not the `ServerBuilder` - so that more information is present.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1402
https://github.com/qupath/qupath/pull/1402:7,Testability,log,logic,7,"Update logic related to reading/importing images, to try to have fewer errors and more informative messages logged when errors do occur. ## Improve checks for Bio-Formats image support. Throw an exception if unable to read a single pixel from a Bio-Formats image.; Accessing the pixel may introduce some overhead when importing images, but it avoids problems where metadata can be parsed yet the fact the image can't actually be read only becomes apparent later. This was causing trouble with .ndpi on Apple Silicon, because skipping the use of NDPIReader was causing a fallback to a regular TIFF reader... and this didn't recognize the image as pyramidal and couldn't read the pixels. So requesting Bio-Formats for .ndpi was both adding many (~12) images to a project (for the different pyramid levels), and not actually able to open them. Also fix the logic for determining which IFormatReader is used for a specified image. This was previously giving ImageReader rather than the specific reader, and therefore wasn't properly enabling the reader check to be skipped for readers generated in other threads. This also had an extra issue in Apple Silicon, because these checks could cause exceptions regarding unsupported libraries being logged, even if they weren't relevant to the image itself. ## Improve use of json with image servers. Make `JSONImageServerBuilder` genuinely useful by enabling it to read the server.json files stored within projects. This could potentially help in the future if attempting to recover data from a broken project. This involves estimating the ""builderType"" since that wasn't actually serialized within the server.json before. To simplify things in the future, the server.json now serializes the `ImageServer` and not the `ServerBuilder` - so that more information is present.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1402
https://github.com/qupath/qupath/pull/1402:108,Testability,log,logged,108,"Update logic related to reading/importing images, to try to have fewer errors and more informative messages logged when errors do occur. ## Improve checks for Bio-Formats image support. Throw an exception if unable to read a single pixel from a Bio-Formats image.; Accessing the pixel may introduce some overhead when importing images, but it avoids problems where metadata can be parsed yet the fact the image can't actually be read only becomes apparent later. This was causing trouble with .ndpi on Apple Silicon, because skipping the use of NDPIReader was causing a fallback to a regular TIFF reader... and this didn't recognize the image as pyramidal and couldn't read the pixels. So requesting Bio-Formats for .ndpi was both adding many (~12) images to a project (for the different pyramid levels), and not actually able to open them. Also fix the logic for determining which IFormatReader is used for a specified image. This was previously giving ImageReader rather than the specific reader, and therefore wasn't properly enabling the reader check to be skipped for readers generated in other threads. This also had an extra issue in Apple Silicon, because these checks could cause exceptions regarding unsupported libraries being logged, even if they weren't relevant to the image itself. ## Improve use of json with image servers. Make `JSONImageServerBuilder` genuinely useful by enabling it to read the server.json files stored within projects. This could potentially help in the future if attempting to recover data from a broken project. This involves estimating the ""builderType"" since that wasn't actually serialized within the server.json before. To simplify things in the future, the server.json now serializes the `ImageServer` and not the `ServerBuilder` - so that more information is present.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1402
https://github.com/qupath/qupath/pull/1402:854,Testability,log,logic,854,"Update logic related to reading/importing images, to try to have fewer errors and more informative messages logged when errors do occur. ## Improve checks for Bio-Formats image support. Throw an exception if unable to read a single pixel from a Bio-Formats image.; Accessing the pixel may introduce some overhead when importing images, but it avoids problems where metadata can be parsed yet the fact the image can't actually be read only becomes apparent later. This was causing trouble with .ndpi on Apple Silicon, because skipping the use of NDPIReader was causing a fallback to a regular TIFF reader... and this didn't recognize the image as pyramidal and couldn't read the pixels. So requesting Bio-Formats for .ndpi was both adding many (~12) images to a project (for the different pyramid levels), and not actually able to open them. Also fix the logic for determining which IFormatReader is used for a specified image. This was previously giving ImageReader rather than the specific reader, and therefore wasn't properly enabling the reader check to be skipped for readers generated in other threads. This also had an extra issue in Apple Silicon, because these checks could cause exceptions regarding unsupported libraries being logged, even if they weren't relevant to the image itself. ## Improve use of json with image servers. Make `JSONImageServerBuilder` genuinely useful by enabling it to read the server.json files stored within projects. This could potentially help in the future if attempting to recover data from a broken project. This involves estimating the ""builderType"" since that wasn't actually serialized within the server.json before. To simplify things in the future, the server.json now serializes the `ImageServer` and not the `ServerBuilder` - so that more information is present.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1402
https://github.com/qupath/qupath/pull/1402:1238,Testability,log,logged,1238,"Update logic related to reading/importing images, to try to have fewer errors and more informative messages logged when errors do occur. ## Improve checks for Bio-Formats image support. Throw an exception if unable to read a single pixel from a Bio-Formats image.; Accessing the pixel may introduce some overhead when importing images, but it avoids problems where metadata can be parsed yet the fact the image can't actually be read only becomes apparent later. This was causing trouble with .ndpi on Apple Silicon, because skipping the use of NDPIReader was causing a fallback to a regular TIFF reader... and this didn't recognize the image as pyramidal and couldn't read the pixels. So requesting Bio-Formats for .ndpi was both adding many (~12) images to a project (for the different pyramid levels), and not actually able to open them. Also fix the logic for determining which IFormatReader is used for a specified image. This was previously giving ImageReader rather than the specific reader, and therefore wasn't properly enabling the reader check to be skipped for readers generated in other threads. This also had an extra issue in Apple Silicon, because these checks could cause exceptions regarding unsupported libraries being logged, even if they weren't relevant to the image itself. ## Improve use of json with image servers. Make `JSONImageServerBuilder` genuinely useful by enabling it to read the server.json files stored within projects. This could potentially help in the future if attempting to recover data from a broken project. This involves estimating the ""builderType"" since that wasn't actually serialized within the server.json before. To simplify things in the future, the server.json now serializes the `ImageServer` and not the `ServerBuilder` - so that more information is present.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1402
https://github.com/qupath/qupath/pull/1402:1666,Usability,simpl,simplify,1666,"Update logic related to reading/importing images, to try to have fewer errors and more informative messages logged when errors do occur. ## Improve checks for Bio-Formats image support. Throw an exception if unable to read a single pixel from a Bio-Formats image.; Accessing the pixel may introduce some overhead when importing images, but it avoids problems where metadata can be parsed yet the fact the image can't actually be read only becomes apparent later. This was causing trouble with .ndpi on Apple Silicon, because skipping the use of NDPIReader was causing a fallback to a regular TIFF reader... and this didn't recognize the image as pyramidal and couldn't read the pixels. So requesting Bio-Formats for .ndpi was both adding many (~12) images to a project (for the different pyramid levels), and not actually able to open them. Also fix the logic for determining which IFormatReader is used for a specified image. This was previously giving ImageReader rather than the specific reader, and therefore wasn't properly enabling the reader check to be skipped for readers generated in other threads. This also had an extra issue in Apple Silicon, because these checks could cause exceptions regarding unsupported libraries being logged, even if they weren't relevant to the image itself. ## Improve use of json with image servers. Make `JSONImageServerBuilder` genuinely useful by enabling it to read the server.json files stored within projects. This could potentially help in the future if attempting to recover data from a broken project. This involves estimating the ""builderType"" since that wasn't actually serialized within the server.json before. To simplify things in the future, the server.json now serializes the `ImageServer` and not the `ServerBuilder` - so that more information is present.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1402
https://github.com/qupath/qupath/pull/1403:192,Availability,avail,available,192,* Support `.qpdata` files in the project import dialog; * This simplifies bringing over data from an existing project if the project file itself is missing or corrupt (assuming the images are available); * Fix bug in the update URIs command that affected the file dialog when setting a single URI; * Show a context warning if no channels are visible,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1403
https://github.com/qupath/qupath/pull/1403:221,Deployability,update,update,221,* Support `.qpdata` files in the project import dialog; * This simplifies bringing over data from an existing project if the project file itself is missing or corrupt (assuming the images are available); * Fix bug in the update URIs command that affected the file dialog when setting a single URI; * Show a context warning if no channels are visible,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1403
https://github.com/qupath/qupath/pull/1403:63,Usability,simpl,simplifies,63,* Support `.qpdata` files in the project import dialog; * This simplifies bringing over data from an existing project if the project file itself is missing or corrupt (assuming the images are available); * Fix bug in the update URIs command that affected the file dialog when setting a single URI; * Show a context warning if no channels are visible,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1403
https://github.com/qupath/qupath/pull/1404:16,Energy Efficiency,reduce,reduce,16,"Always scary to reduce synchronization, but have been unable to identify any ill effects. This aims to fix https://github.com/qupath/qupath/issues/1400",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1404
https://github.com/qupath/qupath/pull/1404:23,Integrability,synchroniz,synchronization,23,"Always scary to reduce synchronization, but have been unable to identify any ill effects. This aims to fix https://github.com/qupath/qupath/issues/1400",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1404
https://github.com/qupath/qupath/issues/1406:383,Availability,Down,Download,383,"## Bug report. **Describe the bug**; The Intel build of v0.5.0-rc2 fails on many (or all?) Apple Silicon Macs when using OpenCV's DNN, e.g. via the StarDist extension. This *may* be related to an OpenCV bug, since fixed: https://github.com/opencv/opencv/issues/23183; There's no final JavaCPP release containing the fix though. **To Reproduce**; Steps to reproduce the behavior:; 1. Download the intel (x64) build of v0.5.0-rc2 (or likely v0.5.0-rc1); 2. Run [the StarDist extension](https://github.com/qupath/qupath-extension-stardist), e.g. using CMU-1.svs and the H&E model. This is likely to either throw an exception, or shut down QuPath immediately. This problem does not occur when using the arm64 build. **Expected behavior**; The x64 build should work through Rosetta2 (just a bit slower). **Desktop (please complete the following information):**; - OS: macOS 14; - QuPath Version: v0.5.0-rc2 (and also rc1). **Additional context**; This matters to some users because Bio-Formats doesn't support Apple Silicon:; * https://github.com/ome/bioformats/issues/3756; * https://github.com/glencoesoftware/jxrlib/issues/30. Consequently, some users (particularly those with Axioscan .czi images) are forced to run the x64 builds of QuPath. This can *probably* be addressed by reverting to OpenCV 4.6.0, but that would be unfortunate since OpenCV's DNN's performance should be much improved - at least for Apple Silicon - in v4.7.0 (although that may be the source of the problem...). Timings (in minutes) for one largish region of CMU-2.svs on Apple Silicon are given below:. * v0.5.0-rc2 arm64 - 1:38; * v0.4.4 arm64 - 2:47; * v0.4.4 intel64 - 3:54. So it's a shame to penalize more users by sticking with an older OpenCV because of this bug, which should only affect a *relatively* small number of people for whom the following is true:; * Using Apple Silicon; * Using .czi files; * Using the StarDist extension. Before deciding, one thing to check is whether or not TensorFlow can work via Rosetta",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1406
https://github.com/qupath/qupath/issues/1406:631,Availability,down,down,631,"## Bug report. **Describe the bug**; The Intel build of v0.5.0-rc2 fails on many (or all?) Apple Silicon Macs when using OpenCV's DNN, e.g. via the StarDist extension. This *may* be related to an OpenCV bug, since fixed: https://github.com/opencv/opencv/issues/23183; There's no final JavaCPP release containing the fix though. **To Reproduce**; Steps to reproduce the behavior:; 1. Download the intel (x64) build of v0.5.0-rc2 (or likely v0.5.0-rc1); 2. Run [the StarDist extension](https://github.com/qupath/qupath-extension-stardist), e.g. using CMU-1.svs and the H&E model. This is likely to either throw an exception, or shut down QuPath immediately. This problem does not occur when using the arm64 build. **Expected behavior**; The x64 build should work through Rosetta2 (just a bit slower). **Desktop (please complete the following information):**; - OS: macOS 14; - QuPath Version: v0.5.0-rc2 (and also rc1). **Additional context**; This matters to some users because Bio-Formats doesn't support Apple Silicon:; * https://github.com/ome/bioformats/issues/3756; * https://github.com/glencoesoftware/jxrlib/issues/30. Consequently, some users (particularly those with Axioscan .czi images) are forced to run the x64 builds of QuPath. This can *probably* be addressed by reverting to OpenCV 4.6.0, but that would be unfortunate since OpenCV's DNN's performance should be much improved - at least for Apple Silicon - in v4.7.0 (although that may be the source of the problem...). Timings (in minutes) for one largish region of CMU-2.svs on Apple Silicon are given below:. * v0.5.0-rc2 arm64 - 1:38; * v0.4.4 arm64 - 2:47; * v0.4.4 intel64 - 3:54. So it's a shame to penalize more users by sticking with an older OpenCV because of this bug, which should only affect a *relatively* small number of people for whom the following is true:; * Using Apple Silicon; * Using .czi files; * Using the StarDist extension. Before deciding, one thing to check is whether or not TensorFlow can work via Rosetta",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1406
https://github.com/qupath/qupath/issues/1406:293,Deployability,release,release,293,"## Bug report. **Describe the bug**; The Intel build of v0.5.0-rc2 fails on many (or all?) Apple Silicon Macs when using OpenCV's DNN, e.g. via the StarDist extension. This *may* be related to an OpenCV bug, since fixed: https://github.com/opencv/opencv/issues/23183; There's no final JavaCPP release containing the fix though. **To Reproduce**; Steps to reproduce the behavior:; 1. Download the intel (x64) build of v0.5.0-rc2 (or likely v0.5.0-rc1); 2. Run [the StarDist extension](https://github.com/qupath/qupath-extension-stardist), e.g. using CMU-1.svs and the H&E model. This is likely to either throw an exception, or shut down QuPath immediately. This problem does not occur when using the arm64 build. **Expected behavior**; The x64 build should work through Rosetta2 (just a bit slower). **Desktop (please complete the following information):**; - OS: macOS 14; - QuPath Version: v0.5.0-rc2 (and also rc1). **Additional context**; This matters to some users because Bio-Formats doesn't support Apple Silicon:; * https://github.com/ome/bioformats/issues/3756; * https://github.com/glencoesoftware/jxrlib/issues/30. Consequently, some users (particularly those with Axioscan .czi images) are forced to run the x64 builds of QuPath. This can *probably* be addressed by reverting to OpenCV 4.6.0, but that would be unfortunate since OpenCV's DNN's performance should be much improved - at least for Apple Silicon - in v4.7.0 (although that may be the source of the problem...). Timings (in minutes) for one largish region of CMU-2.svs on Apple Silicon are given below:. * v0.5.0-rc2 arm64 - 1:38; * v0.4.4 arm64 - 2:47; * v0.4.4 intel64 - 3:54. So it's a shame to penalize more users by sticking with an older OpenCV because of this bug, which should only affect a *relatively* small number of people for whom the following is true:; * Using Apple Silicon; * Using .czi files; * Using the StarDist extension. Before deciding, one thing to check is whether or not TensorFlow can work via Rosetta",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1406
https://github.com/qupath/qupath/issues/1406:1355,Performance,perform,performance,1355,"he StarDist extension. This *may* be related to an OpenCV bug, since fixed: https://github.com/opencv/opencv/issues/23183; There's no final JavaCPP release containing the fix though. **To Reproduce**; Steps to reproduce the behavior:; 1. Download the intel (x64) build of v0.5.0-rc2 (or likely v0.5.0-rc1); 2. Run [the StarDist extension](https://github.com/qupath/qupath-extension-stardist), e.g. using CMU-1.svs and the H&E model. This is likely to either throw an exception, or shut down QuPath immediately. This problem does not occur when using the arm64 build. **Expected behavior**; The x64 build should work through Rosetta2 (just a bit slower). **Desktop (please complete the following information):**; - OS: macOS 14; - QuPath Version: v0.5.0-rc2 (and also rc1). **Additional context**; This matters to some users because Bio-Formats doesn't support Apple Silicon:; * https://github.com/ome/bioformats/issues/3756; * https://github.com/glencoesoftware/jxrlib/issues/30. Consequently, some users (particularly those with Axioscan .czi images) are forced to run the x64 builds of QuPath. This can *probably* be addressed by reverting to OpenCV 4.6.0, but that would be unfortunate since OpenCV's DNN's performance should be much improved - at least for Apple Silicon - in v4.7.0 (although that may be the source of the problem...). Timings (in minutes) for one largish region of CMU-2.svs on Apple Silicon are given below:. * v0.5.0-rc2 arm64 - 1:38; * v0.4.4 arm64 - 2:47; * v0.4.4 intel64 - 3:54. So it's a shame to penalize more users by sticking with an older OpenCV because of this bug, which should only affect a *relatively* small number of people for whom the following is true:; * Using Apple Silicon; * Using .czi files; * Using the StarDist extension. Before deciding, one thing to check is whether or not TensorFlow can work via Rosetta2 on the Intel build, since this would give an alternative. Previously it failed, but it's worth checking again with the latest DeepJavaLibrary.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1406
https://github.com/qupath/qupath/issues/1408:167,Availability,error,error,167,"## Bug report. **Describe the bug**; In v0.5.0 rc2, when multiple viewers are open and zooming in occurs (not on the image currently selected with the red outline) an error is produced in the log but functions as expected. **To Reproduce**; 1. Open multiple viewers (eg 2x2) and fill each with images.; 2. With one image selected, scroll to zoom in on ANOTHER image. ; 3. Each scroll wheel turn will create an error in the logs as seen attached. . **Expected behavior**; No bugs :). **Screenshots**; If applicable, add screenshots to help explain your problem. **Desktop (please complete the following information):**; - OS: Windows; - QuPath Version: v0.5.0 rc2. **Additional context**; [multiviewer scroll bug.txt](https://github.com/qupath/qupath/files/13221309/multiviewer.scroll.bug.txt)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1408
https://github.com/qupath/qupath/issues/1408:410,Availability,error,error,410,"## Bug report. **Describe the bug**; In v0.5.0 rc2, when multiple viewers are open and zooming in occurs (not on the image currently selected with the red outline) an error is produced in the log but functions as expected. **To Reproduce**; 1. Open multiple viewers (eg 2x2) and fill each with images.; 2. With one image selected, scroll to zoom in on ANOTHER image. ; 3. Each scroll wheel turn will create an error in the logs as seen attached. . **Expected behavior**; No bugs :). **Screenshots**; If applicable, add screenshots to help explain your problem. **Desktop (please complete the following information):**; - OS: Windows; - QuPath Version: v0.5.0 rc2. **Additional context**; [multiviewer scroll bug.txt](https://github.com/qupath/qupath/files/13221309/multiviewer.scroll.bug.txt)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1408
https://github.com/qupath/qupath/issues/1408:192,Testability,log,log,192,"## Bug report. **Describe the bug**; In v0.5.0 rc2, when multiple viewers are open and zooming in occurs (not on the image currently selected with the red outline) an error is produced in the log but functions as expected. **To Reproduce**; 1. Open multiple viewers (eg 2x2) and fill each with images.; 2. With one image selected, scroll to zoom in on ANOTHER image. ; 3. Each scroll wheel turn will create an error in the logs as seen attached. . **Expected behavior**; No bugs :). **Screenshots**; If applicable, add screenshots to help explain your problem. **Desktop (please complete the following information):**; - OS: Windows; - QuPath Version: v0.5.0 rc2. **Additional context**; [multiviewer scroll bug.txt](https://github.com/qupath/qupath/files/13221309/multiviewer.scroll.bug.txt)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1408
https://github.com/qupath/qupath/issues/1408:423,Testability,log,logs,423,"## Bug report. **Describe the bug**; In v0.5.0 rc2, when multiple viewers are open and zooming in occurs (not on the image currently selected with the red outline) an error is produced in the log but functions as expected. **To Reproduce**; 1. Open multiple viewers (eg 2x2) and fill each with images.; 2. With one image selected, scroll to zoom in on ANOTHER image. ; 3. Each scroll wheel turn will create an error in the logs as seen attached. . **Expected behavior**; No bugs :). **Screenshots**; If applicable, add screenshots to help explain your problem. **Desktop (please complete the following information):**; - OS: Windows; - QuPath Version: v0.5.0 rc2. **Additional context**; [multiviewer scroll bug.txt](https://github.com/qupath/qupath/files/13221309/multiviewer.scroll.bug.txt)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1408
https://github.com/qupath/qupath/issues/1411:22,Safety,detect,detection,22,"Hi. When running cell detection on Annotation with child annotation, the child annotation is being deletd.; An optional way to overcome this is by using ; `def annotations = getAnnotationObjects(); removeObjects(annotations, false); addObjects(annotations)`. as suggested for example in [this image.sc post](https://forum.image.sc/t/qupath-scripting-annotations-deleted-when-running-cell-detection/41292/6). I was thinking that resetting the object Hierarchy before cell detection and resolving it again afterward may be an alternative solution ; Is there a command that let you reset the object Hierarchy ? . Thanks; Ofra",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1411
https://github.com/qupath/qupath/issues/1411:388,Safety,detect,detection,388,"Hi. When running cell detection on Annotation with child annotation, the child annotation is being deletd.; An optional way to overcome this is by using ; `def annotations = getAnnotationObjects(); removeObjects(annotations, false); addObjects(annotations)`. as suggested for example in [this image.sc post](https://forum.image.sc/t/qupath-scripting-annotations-deleted-when-running-cell-detection/41292/6). I was thinking that resetting the object Hierarchy before cell detection and resolving it again afterward may be an alternative solution ; Is there a command that let you reset the object Hierarchy ? . Thanks; Ofra",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1411
https://github.com/qupath/qupath/issues/1411:471,Safety,detect,detection,471,"Hi. When running cell detection on Annotation with child annotation, the child annotation is being deletd.; An optional way to overcome this is by using ; `def annotations = getAnnotationObjects(); removeObjects(annotations, false); addObjects(annotations)`. as suggested for example in [this image.sc post](https://forum.image.sc/t/qupath-scripting-annotations-deleted-when-running-cell-detection/41292/6). I was thinking that resetting the object Hierarchy before cell detection and resolving it again afterward may be an alternative solution ; Is there a command that let you reset the object Hierarchy ? . Thanks; Ofra",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1411
https://github.com/qupath/qupath/pull/1415:330,Usability,Clear,Clearing,330,"Was unable to figure out the other drag & drop problem. To reproduce the other issue:. 1. Drag & drop any URL or file; 2. Drag and drop another URL from the same source. When drag&drop events come from the same source (eg, a web browser), the first URL/file/etc will persist for all following drag/drop events, on Linux at least. Clearing the dragboard programmatically has no effect (maybe expected, I'd assume it's cleared or a new one is created between events anyway).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1415
https://github.com/qupath/qupath/pull/1415:417,Usability,clear,cleared,417,"Was unable to figure out the other drag & drop problem. To reproduce the other issue:. 1. Drag & drop any URL or file; 2. Drag and drop another URL from the same source. When drag&drop events come from the same source (eg, a web browser), the first URL/file/etc will persist for all following drag/drop events, on Linux at least. Clearing the dragboard programmatically has no effect (maybe expected, I'd assume it's cleared or a new one is created between events anyway).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1415
https://github.com/qupath/qupath/pull/1416:33,Availability,error,errors,33,"Try to propagate more meaningful errors when an image can't be opened or import to a project, especially for .czi images that don't work with Apple Silicon. To help achieve this, don't rely on ImageJ to attempt any image - but instead query the image type first, and try only if ImageJ has a good chance of handling it.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1416
https://github.com/qupath/qupath/pull/1419:73,Deployability,release,release-candidate,73,"Addresses https://forum.image.sc/t/please-help-us-test-the-qupath-v0-5-0-release-candidate/87976/12. If an extension can't be deleted, inform the user and ask if the directory should be opened for manual deletion. Previously, a 'success' message was shown even if the deletion had failed. I couldn't figure out a way to make the extension 'deletable' - although I vaguely recall @yli-hallila might know more about this.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1419
https://github.com/qupath/qupath/pull/1419:238,Integrability,message,message,238,"Addresses https://forum.image.sc/t/please-help-us-test-the-qupath-v0-5-0-release-candidate/87976/12. If an extension can't be deleted, inform the user and ask if the directory should be opened for manual deletion. Previously, a 'success' message was shown even if the deletion had failed. I couldn't figure out a way to make the extension 'deletable' - although I vaguely recall @yli-hallila might know more about this.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1419
https://github.com/qupath/qupath/pull/1419:50,Testability,test,test-the-qupath-,50,"Addresses https://forum.image.sc/t/please-help-us-test-the-qupath-v0-5-0-release-candidate/87976/12. If an extension can't be deleted, inform the user and ask if the directory should be opened for manual deletion. Previously, a 'success' message was shown even if the deletion had failed. I couldn't figure out a way to make the extension 'deletable' - although I vaguely recall @yli-hallila might know more about this.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1419
https://github.com/qupath/qupath/pull/1422:34,Safety,predict,prediction,34,"Remove generic parameter and move prediction & blob functions to `AbstractDnnModel`. The motivations are:; - make it easier to implement `DnnModel`; - make it easier to handle memory management with the DeepJavaLibrary implementation. The second is because memory management seems to work best when using a `Translator` and not working directly with `NDList` inputs and outputs for prediction. This means that it's better to predict 'all at once' rather than across multiple methods (create blob, predict, convert output).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1422
https://github.com/qupath/qupath/pull/1422:382,Safety,predict,prediction,382,"Remove generic parameter and move prediction & blob functions to `AbstractDnnModel`. The motivations are:; - make it easier to implement `DnnModel`; - make it easier to handle memory management with the DeepJavaLibrary implementation. The second is because memory management seems to work best when using a `Translator` and not working directly with `NDList` inputs and outputs for prediction. This means that it's better to predict 'all at once' rather than across multiple methods (create blob, predict, convert output).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1422
https://github.com/qupath/qupath/pull/1422:425,Safety,predict,predict,425,"Remove generic parameter and move prediction & blob functions to `AbstractDnnModel`. The motivations are:; - make it easier to implement `DnnModel`; - make it easier to handle memory management with the DeepJavaLibrary implementation. The second is because memory management seems to work best when using a `Translator` and not working directly with `NDList` inputs and outputs for prediction. This means that it's better to predict 'all at once' rather than across multiple methods (create blob, predict, convert output).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1422
https://github.com/qupath/qupath/pull/1422:497,Safety,predict,predict,497,"Remove generic parameter and move prediction & blob functions to `AbstractDnnModel`. The motivations are:; - make it easier to implement `DnnModel`; - make it easier to handle memory management with the DeepJavaLibrary implementation. The second is because memory management seems to work best when using a `Translator` and not working directly with `NDList` inputs and outputs for prediction. This means that it's better to predict 'all at once' rather than across multiple methods (create blob, predict, convert output).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1422
https://github.com/qupath/qupath/pull/1424:0,Deployability,Update,Updates,0,Updates & simplifications to the gradle build scripts.; This removes warnings of deprecated features that will be incompatible with Gradle 9.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1424
https://github.com/qupath/qupath/pull/1424:10,Usability,simpl,simplifications,10,Updates & simplifications to the gradle build scripts.; This removes warnings of deprecated features that will be incompatible with Gradle 9.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1424
https://github.com/qupath/qupath/pull/1430:455,Security,access,access,455,"This provides more opportunities to customize QuPath at launch, rather than afterwards. It may be useful for setting paths or options for DJL or JNA, without relying on persistent preferences. Example:; ```; /path/to/QuPath -DPYTORCH_VERSION=1.13.1 -Doffline=false; ```. It's also possible to do; ```; /path/to/QuPath -Djava.library.path=/something/; ```; but I'm not sure if that works... it should however work to set JNA paths, see https://java-native-access.github.io/jna/4.2.1/com/sun/jna/NativeLibrary.html",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1430
https://github.com/qupath/qupath/pull/1433:35,Deployability,update,update,35,"In the Brightness/Contrast dialog, update the settings combo box whenever settings are modified (e.g. sliders moved) to include an asterisk and name in italics. This is intended to address https://forum.image.sc/t/please-help-us-test-the-qupath-v0-5-0-release-candidate/87976/23. The change is relatively conservative, aiming to avoid any substantial overhead whenever changes are made quickly. Specifically, we don't check whether and changes have been *reversed* so that the settings are now 'unmodified again'. We also don't try to handle settings being flagged as changed when switching across multiple viewers. Therefore the asterisk and italics doesn't mean the settings are different, only that they might be different. This could be addressed, but the tests would be more expensive to perform and therefore a little risky immediately before release, in case the performance impact is noticeable. @lacan @MichaelSNelson",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1433
https://github.com/qupath/qupath/pull/1433:252,Deployability,release,release-candidate,252,"In the Brightness/Contrast dialog, update the settings combo box whenever settings are modified (e.g. sliders moved) to include an asterisk and name in italics. This is intended to address https://forum.image.sc/t/please-help-us-test-the-qupath-v0-5-0-release-candidate/87976/23. The change is relatively conservative, aiming to avoid any substantial overhead whenever changes are made quickly. Specifically, we don't check whether and changes have been *reversed* so that the settings are now 'unmodified again'. We also don't try to handle settings being flagged as changed when switching across multiple viewers. Therefore the asterisk and italics doesn't mean the settings are different, only that they might be different. This could be addressed, but the tests would be more expensive to perform and therefore a little risky immediately before release, in case the performance impact is noticeable. @lacan @MichaelSNelson",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1433
https://github.com/qupath/qupath/pull/1433:849,Deployability,release,release,849,"In the Brightness/Contrast dialog, update the settings combo box whenever settings are modified (e.g. sliders moved) to include an asterisk and name in italics. This is intended to address https://forum.image.sc/t/please-help-us-test-the-qupath-v0-5-0-release-candidate/87976/23. The change is relatively conservative, aiming to avoid any substantial overhead whenever changes are made quickly. Specifically, we don't check whether and changes have been *reversed* so that the settings are now 'unmodified again'. We also don't try to handle settings being flagged as changed when switching across multiple viewers. Therefore the asterisk and italics doesn't mean the settings are different, only that they might be different. This could be addressed, but the tests would be more expensive to perform and therefore a little risky immediately before release, in case the performance impact is noticeable. @lacan @MichaelSNelson",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1433
https://github.com/qupath/qupath/pull/1433:793,Performance,perform,perform,793,"In the Brightness/Contrast dialog, update the settings combo box whenever settings are modified (e.g. sliders moved) to include an asterisk and name in italics. This is intended to address https://forum.image.sc/t/please-help-us-test-the-qupath-v0-5-0-release-candidate/87976/23. The change is relatively conservative, aiming to avoid any substantial overhead whenever changes are made quickly. Specifically, we don't check whether and changes have been *reversed* so that the settings are now 'unmodified again'. We also don't try to handle settings being flagged as changed when switching across multiple viewers. Therefore the asterisk and italics doesn't mean the settings are different, only that they might be different. This could be addressed, but the tests would be more expensive to perform and therefore a little risky immediately before release, in case the performance impact is noticeable. @lacan @MichaelSNelson",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1433
https://github.com/qupath/qupath/pull/1433:870,Performance,perform,performance,870,"In the Brightness/Contrast dialog, update the settings combo box whenever settings are modified (e.g. sliders moved) to include an asterisk and name in italics. This is intended to address https://forum.image.sc/t/please-help-us-test-the-qupath-v0-5-0-release-candidate/87976/23. The change is relatively conservative, aiming to avoid any substantial overhead whenever changes are made quickly. Specifically, we don't check whether and changes have been *reversed* so that the settings are now 'unmodified again'. We also don't try to handle settings being flagged as changed when switching across multiple viewers. Therefore the asterisk and italics doesn't mean the settings are different, only that they might be different. This could be addressed, but the tests would be more expensive to perform and therefore a little risky immediately before release, in case the performance impact is noticeable. @lacan @MichaelSNelson",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1433
https://github.com/qupath/qupath/pull/1433:329,Safety,avoid,avoid,329,"In the Brightness/Contrast dialog, update the settings combo box whenever settings are modified (e.g. sliders moved) to include an asterisk and name in italics. This is intended to address https://forum.image.sc/t/please-help-us-test-the-qupath-v0-5-0-release-candidate/87976/23. The change is relatively conservative, aiming to avoid any substantial overhead whenever changes are made quickly. Specifically, we don't check whether and changes have been *reversed* so that the settings are now 'unmodified again'. We also don't try to handle settings being flagged as changed when switching across multiple viewers. Therefore the asterisk and italics doesn't mean the settings are different, only that they might be different. This could be addressed, but the tests would be more expensive to perform and therefore a little risky immediately before release, in case the performance impact is noticeable. @lacan @MichaelSNelson",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1433
https://github.com/qupath/qupath/pull/1433:824,Safety,risk,risky,824,"In the Brightness/Contrast dialog, update the settings combo box whenever settings are modified (e.g. sliders moved) to include an asterisk and name in italics. This is intended to address https://forum.image.sc/t/please-help-us-test-the-qupath-v0-5-0-release-candidate/87976/23. The change is relatively conservative, aiming to avoid any substantial overhead whenever changes are made quickly. Specifically, we don't check whether and changes have been *reversed* so that the settings are now 'unmodified again'. We also don't try to handle settings being flagged as changed when switching across multiple viewers. Therefore the asterisk and italics doesn't mean the settings are different, only that they might be different. This could be addressed, but the tests would be more expensive to perform and therefore a little risky immediately before release, in case the performance impact is noticeable. @lacan @MichaelSNelson",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1433
https://github.com/qupath/qupath/pull/1433:229,Testability,test,test-the-qupath-,229,"In the Brightness/Contrast dialog, update the settings combo box whenever settings are modified (e.g. sliders moved) to include an asterisk and name in italics. This is intended to address https://forum.image.sc/t/please-help-us-test-the-qupath-v0-5-0-release-candidate/87976/23. The change is relatively conservative, aiming to avoid any substantial overhead whenever changes are made quickly. Specifically, we don't check whether and changes have been *reversed* so that the settings are now 'unmodified again'. We also don't try to handle settings being flagged as changed when switching across multiple viewers. Therefore the asterisk and italics doesn't mean the settings are different, only that they might be different. This could be addressed, but the tests would be more expensive to perform and therefore a little risky immediately before release, in case the performance impact is noticeable. @lacan @MichaelSNelson",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1433
https://github.com/qupath/qupath/pull/1433:760,Testability,test,tests,760,"In the Brightness/Contrast dialog, update the settings combo box whenever settings are modified (e.g. sliders moved) to include an asterisk and name in italics. This is intended to address https://forum.image.sc/t/please-help-us-test-the-qupath-v0-5-0-release-candidate/87976/23. The change is relatively conservative, aiming to avoid any substantial overhead whenever changes are made quickly. Specifically, we don't check whether and changes have been *reversed* so that the settings are now 'unmodified again'. We also don't try to handle settings being flagged as changed when switching across multiple viewers. Therefore the asterisk and italics doesn't mean the settings are different, only that they might be different. This could be addressed, but the tests would be more expensive to perform and therefore a little risky immediately before release, in case the performance impact is noticeable. @lacan @MichaelSNelson",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1433
https://github.com/qupath/qupath/issues/1436:339,Availability,error,error,339,"**Describe the bug**; When trying to hide QuPath via the menu bar or by pressing cmd + h, the ""About"" window is opened instead of QuPath being hidden. **To Reproduce**; Steps to reproduce the behavior:; 1. Click on app name (""QuPath-0.5.0-arm64"") in menu bar.; 2. Click on ""Hide QuPath-0.5.0-arm64"" (alternatively: press cmd + h).; 4. See error. **Expected behavior**; QuPath window being hidden. **Screenshots**; <img width=""553"" alt=""qupath-bug"" src=""https://github.com/qupath/qupath/assets/69714383/7e5be5b2-1bd6-408f-8f56-46a1ff4c3f67"">. **Desktop (please complete the following information):**; - OS: macOS 14.1.2; - QuPath Version: 0.5.0-arm64",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1436
https://github.com/qupath/qupath/issues/1438:193,Availability,error,error-prone,193,"It is often necessary/helpful to select all child objects of annotations, e.g. to delete or classify them. The selection of child objects in the object list on the Hierarchy tab is tedious and error-prone - especially when the number of objects is large. A function (in the menu and in the context menu of annotations) for selecting all child objects of all selected annotations would be desirable and helpful. Until now this selection can be done via scripting:; ```; childs = getSelectedObject().getChildObjects(); selectObjects(childs); ```; In my opinion, the function described is so basic that it should be available in the menu.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1438
https://github.com/qupath/qupath/issues/1438:613,Availability,avail,available,613,"It is often necessary/helpful to select all child objects of annotations, e.g. to delete or classify them. The selection of child objects in the object list on the Hierarchy tab is tedious and error-prone - especially when the number of objects is large. A function (in the menu and in the context menu of annotations) for selecting all child objects of all selected annotations would be desirable and helpful. Until now this selection can be done via scripting:; ```; childs = getSelectedObject().getChildObjects(); selectObjects(childs); ```; In my opinion, the function described is so basic that it should be available in the menu.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1438
https://github.com/qupath/qupath/issues/1439:199,Deployability,install,install,199,## Bug report. **Describe the bug**; See https://forum.image.sc/t/qupath-extensions-folder-does-not-allow-for-sub-folders-anymore/89752. **To Reproduce**; Steps to reproduce the behavior:; 1. Try to install an extension in a subdirectory of the extensions directory; 2. Find that it isn't installed. **Expected behavior**; It should be possible to add extensions within subdirectories (at least one or two layers deep). **Desktop (please complete the following information):**; - OS: All; - QuPath Version: v0.5.0. **Additional context**; Introduced unintentionally. May be fixable simply by increasing the `depth` value at https://github.com/qupath/qupath/blame/864ac71893a8749ff226c99e51642a5e10ea89ea/qupath-gui-fx/src/main/java/qupath/lib/gui/ExtensionClassLoader.java#L115,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1439
https://github.com/qupath/qupath/issues/1439:289,Deployability,install,installed,289,## Bug report. **Describe the bug**; See https://forum.image.sc/t/qupath-extensions-folder-does-not-allow-for-sub-folders-anymore/89752. **To Reproduce**; Steps to reproduce the behavior:; 1. Try to install an extension in a subdirectory of the extensions directory; 2. Find that it isn't installed. **Expected behavior**; It should be possible to add extensions within subdirectories (at least one or two layers deep). **Desktop (please complete the following information):**; - OS: All; - QuPath Version: v0.5.0. **Additional context**; Introduced unintentionally. May be fixable simply by increasing the `depth` value at https://github.com/qupath/qupath/blame/864ac71893a8749ff226c99e51642a5e10ea89ea/qupath-gui-fx/src/main/java/qupath/lib/gui/ExtensionClassLoader.java#L115,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1439
https://github.com/qupath/qupath/issues/1439:406,Modifiability,layers,layers,406,## Bug report. **Describe the bug**; See https://forum.image.sc/t/qupath-extensions-folder-does-not-allow-for-sub-folders-anymore/89752. **To Reproduce**; Steps to reproduce the behavior:; 1. Try to install an extension in a subdirectory of the extensions directory; 2. Find that it isn't installed. **Expected behavior**; It should be possible to add extensions within subdirectories (at least one or two layers deep). **Desktop (please complete the following information):**; - OS: All; - QuPath Version: v0.5.0. **Additional context**; Introduced unintentionally. May be fixable simply by increasing the `depth` value at https://github.com/qupath/qupath/blame/864ac71893a8749ff226c99e51642a5e10ea89ea/qupath-gui-fx/src/main/java/qupath/lib/gui/ExtensionClassLoader.java#L115,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1439
https://github.com/qupath/qupath/issues/1439:582,Usability,simpl,simply,582,## Bug report. **Describe the bug**; See https://forum.image.sc/t/qupath-extensions-folder-does-not-allow-for-sub-folders-anymore/89752. **To Reproduce**; Steps to reproduce the behavior:; 1. Try to install an extension in a subdirectory of the extensions directory; 2. Find that it isn't installed. **Expected behavior**; It should be possible to add extensions within subdirectories (at least one or two layers deep). **Desktop (please complete the following information):**; - OS: All; - QuPath Version: v0.5.0. **Additional context**; Introduced unintentionally. May be fixable simply by increasing the `depth` value at https://github.com/qupath/qupath/blame/864ac71893a8749ff226c99e51642a5e10ea89ea/qupath-gui-fx/src/main/java/qupath/lib/gui/ExtensionClassLoader.java#L115,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1439
https://github.com/qupath/qupath/issues/1441:87,Availability,error,error-when-trying-to-open-saved-script,87,"## Bug report. **Describe the bug**; See https://forum.image.sc/t/qupath-script-editor-error-when-trying-to-open-saved-script/89826/1. **To Reproduce**; Steps to reproduce the behavior:; 1. Open a script in the script editor, with *File &rarr; Open*; 2. Delete or rename the folder containing the script; 3. Try to open a script in the script editor, with *File &rarr; Open*; 4. See the exception. ```; 18:07:12.434	[JavaFX Application Thread]	ERROR	qupath.lib.gui.QuPathUncaughtExceptionHandler	Folder parameter must be a valid folder	java.lang.IllegalArgumentException: Folder parameter must be a valid folder; 	at com.sun.glass.ui.CommonDialogs.convertFolder(CommonDialogs.java:239); 	at com.sun.glass.ui.CommonDialogs.showFileChooser(CommonDialogs.java:191); 	at com.sun.javafx.tk.quantum.QuantumToolkit.showFileChooser(QuantumToolkit.java:1719); 	at javafx.stage.FileChooser.showDialog(FileChooser.java:419); 	at javafx.stage.FileChooser.showOpenDialog(FileChooser.java:354); ```. **Expected behavior**; The open dialog opens properly. **Desktop (please complete the following information):**; - OS: All (presumably, definitely macOS); - QuPath Version: 0.5.0. **Additional context**; This happens when the previous directory used in the dialog doesn't exist. Other commands may be affected as well.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1441
https://github.com/qupath/qupath/issues/1441:444,Availability,ERROR,ERROR,444,"## Bug report. **Describe the bug**; See https://forum.image.sc/t/qupath-script-editor-error-when-trying-to-open-saved-script/89826/1. **To Reproduce**; Steps to reproduce the behavior:; 1. Open a script in the script editor, with *File &rarr; Open*; 2. Delete or rename the folder containing the script; 3. Try to open a script in the script editor, with *File &rarr; Open*; 4. See the exception. ```; 18:07:12.434	[JavaFX Application Thread]	ERROR	qupath.lib.gui.QuPathUncaughtExceptionHandler	Folder parameter must be a valid folder	java.lang.IllegalArgumentException: Folder parameter must be a valid folder; 	at com.sun.glass.ui.CommonDialogs.convertFolder(CommonDialogs.java:239); 	at com.sun.glass.ui.CommonDialogs.showFileChooser(CommonDialogs.java:191); 	at com.sun.javafx.tk.quantum.QuantumToolkit.showFileChooser(QuantumToolkit.java:1719); 	at javafx.stage.FileChooser.showDialog(FileChooser.java:419); 	at javafx.stage.FileChooser.showOpenDialog(FileChooser.java:354); ```. **Expected behavior**; The open dialog opens properly. **Desktop (please complete the following information):**; - OS: All (presumably, definitely macOS); - QuPath Version: 0.5.0. **Additional context**; This happens when the previous directory used in the dialog doesn't exist. Other commands may be affected as well.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1441
https://github.com/qupath/qupath/issues/1443:194,Availability,error,errors,194,"## Bug report. **Describe the bug**; When optimising perameters for a project by creating a sparse composite image from different image entries. When running cell detection using script editor, errors are generated for the final tiles **IF** the entire shape is not a perfect rectangle. If using stardist script for cell detection, errors are generated before any detections. **Can avoid both by manual annotation** with a polygon tool to follow image boundaries -> so not sure if a crucial bug. Carried over from last release to v5. **To Reproduce**; Steps to reproduce the behavior:; 1. Ctl+Shift+A; 2. Run cell detection as a script:; ```; setImageType('FLUORESCENCE');; selectAnnotations();; runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImage"":""DAPI"",""requestedPixelSizeMicrons"":0.1,""backgroundRadiusMicrons"":4.0,""backgroundByReconstruction"":true,""medianRadiusMicrons"":1.0,""sigmaMicrons"":2.5,""minAreaMicrons"":11.0,""maxAreaMicrons"":400.0,""threshold"":1000.0,""watershedPostProcess"":true,""cellExpansionMicrons"":5.0,""includeNuclei"":true,""smoothBoundaries"":true,""makeMeasurements"":true}'); ```; 4. Error:; ```; ERROR: Error running plugin: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; java.util.concurrent.ExecutionException: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.QuPathGUI.runPlugin(QuPathGUI.java:2245); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:248); ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:332,Availability,error,errors,332,"## Bug report. **Describe the bug**; When optimising perameters for a project by creating a sparse composite image from different image entries. When running cell detection using script editor, errors are generated for the final tiles **IF** the entire shape is not a perfect rectangle. If using stardist script for cell detection, errors are generated before any detections. **Can avoid both by manual annotation** with a polygon tool to follow image boundaries -> so not sure if a crucial bug. Carried over from last release to v5. **To Reproduce**; Steps to reproduce the behavior:; 1. Ctl+Shift+A; 2. Run cell detection as a script:; ```; setImageType('FLUORESCENCE');; selectAnnotations();; runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImage"":""DAPI"",""requestedPixelSizeMicrons"":0.1,""backgroundRadiusMicrons"":4.0,""backgroundByReconstruction"":true,""medianRadiusMicrons"":1.0,""sigmaMicrons"":2.5,""minAreaMicrons"":11.0,""maxAreaMicrons"":400.0,""threshold"":1000.0,""watershedPostProcess"":true,""cellExpansionMicrons"":5.0,""includeNuclei"":true,""smoothBoundaries"":true,""makeMeasurements"":true}'); ```; 4. Error:; ```; ERROR: Error running plugin: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; java.util.concurrent.ExecutionException: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.QuPathGUI.runPlugin(QuPathGUI.java:2245); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:248); ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:1126,Availability,Error,Error,1126," running cell detection using script editor, errors are generated for the final tiles **IF** the entire shape is not a perfect rectangle. If using stardist script for cell detection, errors are generated before any detections. **Can avoid both by manual annotation** with a polygon tool to follow image boundaries -> so not sure if a crucial bug. Carried over from last release to v5. **To Reproduce**; Steps to reproduce the behavior:; 1. Ctl+Shift+A; 2. Run cell detection as a script:; ```; setImageType('FLUORESCENCE');; selectAnnotations();; runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImage"":""DAPI"",""requestedPixelSizeMicrons"":0.1,""backgroundRadiusMicrons"":4.0,""backgroundByReconstruction"":true,""medianRadiusMicrons"":1.0,""sigmaMicrons"":2.5,""minAreaMicrons"":11.0,""maxAreaMicrons"":400.0,""threshold"":1000.0,""watershedPostProcess"":true,""cellExpansionMicrons"":5.0,""includeNuclei"":true,""smoothBoundaries"":true,""makeMeasurements"":true}'); ```; 4. Error:; ```; ERROR: Error running plugin: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; java.util.concurrent.ExecutionException: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.QuPathGUI.runPlugin(QuPathGUI.java:2245); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:248); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:270); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at Qu",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:1139,Availability,ERROR,ERROR,1139," running cell detection using script editor, errors are generated for the final tiles **IF** the entire shape is not a perfect rectangle. If using stardist script for cell detection, errors are generated before any detections. **Can avoid both by manual annotation** with a polygon tool to follow image boundaries -> so not sure if a crucial bug. Carried over from last release to v5. **To Reproduce**; Steps to reproduce the behavior:; 1. Ctl+Shift+A; 2. Run cell detection as a script:; ```; setImageType('FLUORESCENCE');; selectAnnotations();; runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImage"":""DAPI"",""requestedPixelSizeMicrons"":0.1,""backgroundRadiusMicrons"":4.0,""backgroundByReconstruction"":true,""medianRadiusMicrons"":1.0,""sigmaMicrons"":2.5,""minAreaMicrons"":11.0,""maxAreaMicrons"":400.0,""threshold"":1000.0,""watershedPostProcess"":true,""cellExpansionMicrons"":5.0,""includeNuclei"":true,""smoothBoundaries"":true,""makeMeasurements"":true}'); ```; 4. Error:; ```; ERROR: Error running plugin: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; java.util.concurrent.ExecutionException: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.QuPathGUI.runPlugin(QuPathGUI.java:2245); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:248); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:270); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at Qu",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:1146,Availability,Error,Error,1146," running cell detection using script editor, errors are generated for the final tiles **IF** the entire shape is not a perfect rectangle. If using stardist script for cell detection, errors are generated before any detections. **Can avoid both by manual annotation** with a polygon tool to follow image boundaries -> so not sure if a crucial bug. Carried over from last release to v5. **To Reproduce**; Steps to reproduce the behavior:; 1. Ctl+Shift+A; 2. Run cell detection as a script:; ```; setImageType('FLUORESCENCE');; selectAnnotations();; runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImage"":""DAPI"",""requestedPixelSizeMicrons"":0.1,""backgroundRadiusMicrons"":4.0,""backgroundByReconstruction"":true,""medianRadiusMicrons"":1.0,""sigmaMicrons"":2.5,""minAreaMicrons"":11.0,""maxAreaMicrons"":400.0,""threshold"":1000.0,""watershedPostProcess"":true,""cellExpansionMicrons"":5.0,""includeNuclei"":true,""smoothBoundaries"":true,""makeMeasurements"":true}'); ```; 4. Error:; ```; ERROR: Error running plugin: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; java.util.concurrent.ExecutionException: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.QuPathGUI.runPlugin(QuPathGUI.java:2245); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:248); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:270); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at Qu",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:4045,Availability,Error,Error,4045,"3.run(DefaultScriptEditor.java:1534); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null at qupath.imagej.tools.IJTools.convertToUncalibratedImagePlus(IJTools.java:791); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:864); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); ```; 6. Error repeats per tile. **Expected behavior**; To recognise bounds or the image in ""create full image annotation"" command, excluding what the error is calling ""null"" regions. **Screenshots**; ![image](https://github.com/qupath/qupath/assets/154437026/e0daa716-19b8-47f9-b337-aa02cb1e44e9). ![image](https://github.com/qupath/qupath/assets/154437026/990ad117-5649-4e15-b376-8bce56d722bb). **Desktop (please complete the following information):**; - OS: Windows 11; - QuPath Version: 0.5.0. **Additional context**; Same issue was present in previous version (0.4.4)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:4187,Availability,error,error,4187,"3.run(DefaultScriptEditor.java:1534); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null at qupath.imagej.tools.IJTools.convertToUncalibratedImagePlus(IJTools.java:791); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:864); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); ```; 6. Error repeats per tile. **Expected behavior**; To recognise bounds or the image in ""create full image annotation"" command, excluding what the error is calling ""null"" regions. **Screenshots**; ![image](https://github.com/qupath/qupath/assets/154437026/e0daa716-19b8-47f9-b337-aa02cb1e44e9). ![image](https://github.com/qupath/qupath/assets/154437026/990ad117-5649-4e15-b376-8bce56d722bb). **Desktop (please complete the following information):**; - OS: Windows 11; - QuPath Version: 0.5.0. **Additional context**; Same issue was present in previous version (0.4.4)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:519,Deployability,release,release,519,"## Bug report. **Describe the bug**; When optimising perameters for a project by creating a sparse composite image from different image entries. When running cell detection using script editor, errors are generated for the final tiles **IF** the entire shape is not a perfect rectangle. If using stardist script for cell detection, errors are generated before any detections. **Can avoid both by manual annotation** with a polygon tool to follow image boundaries -> so not sure if a crucial bug. Carried over from last release to v5. **To Reproduce**; Steps to reproduce the behavior:; 1. Ctl+Shift+A; 2. Run cell detection as a script:; ```; setImageType('FLUORESCENCE');; selectAnnotations();; runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImage"":""DAPI"",""requestedPixelSizeMicrons"":0.1,""backgroundRadiusMicrons"":4.0,""backgroundByReconstruction"":true,""medianRadiusMicrons"":1.0,""sigmaMicrons"":2.5,""minAreaMicrons"":11.0,""maxAreaMicrons"":400.0,""threshold"":1000.0,""watershedPostProcess"":true,""cellExpansionMicrons"":5.0,""includeNuclei"":true,""smoothBoundaries"":true,""makeMeasurements"":true}'); ```; 4. Error:; ```; ERROR: Error running plugin: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; java.util.concurrent.ExecutionException: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.QuPathGUI.runPlugin(QuPathGUI.java:2245); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:248); ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:1160,Modifiability,plugin,plugin,1160," running cell detection using script editor, errors are generated for the final tiles **IF** the entire shape is not a perfect rectangle. If using stardist script for cell detection, errors are generated before any detections. **Can avoid both by manual annotation** with a polygon tool to follow image boundaries -> so not sure if a crucial bug. Carried over from last release to v5. **To Reproduce**; Steps to reproduce the behavior:; 1. Ctl+Shift+A; 2. Run cell detection as a script:; ```; setImageType('FLUORESCENCE');; selectAnnotations();; runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImage"":""DAPI"",""requestedPixelSizeMicrons"":0.1,""backgroundRadiusMicrons"":4.0,""backgroundByReconstruction"":true,""medianRadiusMicrons"":1.0,""sigmaMicrons"":2.5,""minAreaMicrons"":11.0,""maxAreaMicrons"":400.0,""threshold"":1000.0,""watershedPostProcess"":true,""cellExpansionMicrons"":5.0,""includeNuclei"":true,""smoothBoundaries"":true,""makeMeasurements"":true}'); ```; 4. Error:; ```; ERROR: Error running plugin: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; java.util.concurrent.ExecutionException: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.QuPathGUI.runPlugin(QuPathGUI.java:2245); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:248); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:270); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at Qu",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:1592,Modifiability,plugin,plugins,1592,"ft+A; 2. Run cell detection as a script:; ```; setImageType('FLUORESCENCE');; selectAnnotations();; runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImage"":""DAPI"",""requestedPixelSizeMicrons"":0.1,""backgroundRadiusMicrons"":4.0,""backgroundByReconstruction"":true,""medianRadiusMicrons"":1.0,""sigmaMicrons"":2.5,""minAreaMicrons"":11.0,""maxAreaMicrons"":400.0,""threshold"":1000.0,""watershedPostProcess"":true,""cellExpansionMicrons"":5.0,""includeNuclei"":true,""smoothBoundaries"":true,""makeMeasurements"":true}'); ```; 4. Error:; ```; ERROR: Error running plugin: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; java.util.concurrent.ExecutionException: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.QuPathGUI.runPlugin(QuPathGUI.java:2245); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:248); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:270); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:4); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:331); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:161); at qupath.lib.gui.scripting.languages.DefaultScriptLanguage.execute(DefaultScriptLanguage.java:234); at qupath.lib.gui.scripting.DefaultScriptEditor.executeScript(DefaultScriptEditor.java:1166); at qupath.lib.gui.scripting.DefaultS",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:1679,Modifiability,plugin,plugins,1679,"otations();; runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImage"":""DAPI"",""requestedPixelSizeMicrons"":0.1,""backgroundRadiusMicrons"":4.0,""backgroundByReconstruction"":true,""medianRadiusMicrons"":1.0,""sigmaMicrons"":2.5,""minAreaMicrons"":11.0,""maxAreaMicrons"":400.0,""threshold"":1000.0,""watershedPostProcess"":true,""cellExpansionMicrons"":5.0,""includeNuclei"":true,""smoothBoundaries"":true,""makeMeasurements"":true}'); ```; 4. Error:; ```; ERROR: Error running plugin: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; java.util.concurrent.ExecutionException: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.QuPathGUI.runPlugin(QuPathGUI.java:2245); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:248); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:270); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:4); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:331); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:161); at qupath.lib.gui.scripting.languages.DefaultScriptLanguage.execute(DefaultScriptLanguage.java:234); at qupath.lib.gui.scripting.DefaultScriptEditor.executeScript(DefaultScriptEditor.java:1166); at qupath.lib.gui.scripting.DefaultScriptEditor$3.run(DefaultScriptEditor.java:1534); at java.base/java.util.concurrent.Exe",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:1823,Modifiability,plugin,plugins,1823,"dRadiusMicrons"":4.0,""backgroundByReconstruction"":true,""medianRadiusMicrons"":1.0,""sigmaMicrons"":2.5,""minAreaMicrons"":11.0,""maxAreaMicrons"":400.0,""threshold"":1000.0,""watershedPostProcess"":true,""cellExpansionMicrons"":5.0,""includeNuclei"":true,""smoothBoundaries"":true,""makeMeasurements"":true}'); ```; 4. Error:; ```; ERROR: Error running plugin: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; java.util.concurrent.ExecutionException: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.QuPathGUI.runPlugin(QuPathGUI.java:2245); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:248); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:270); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:4); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:331); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:161); at qupath.lib.gui.scripting.languages.DefaultScriptLanguage.execute(DefaultScriptLanguage.java:234); at qupath.lib.gui.scripting.DefaultScriptEditor.executeScript(DefaultScriptEditor.java:1166); at qupath.lib.gui.scripting.DefaultScriptEditor$3.run(DefaultScriptEditor.java:1534); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:3446,Modifiability,plugin,plugins,3446,"uage.java:234); at qupath.lib.gui.scripting.DefaultScriptEditor.executeScript(DefaultScriptEditor.java:1166); at qupath.lib.gui.scripting.DefaultScriptEditor$3.run(DefaultScriptEditor.java:1534); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null at qupath.imagej.tools.IJTools.convertToUncalibratedImagePlus(IJTools.java:791); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:864); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); ```; 6. Error repeats per tile. **Expected behavior**; To recognise bounds or the image in ""create full image annotation"" command, excluding what the error is calling ""null"" regions. **Screenshots**; ![image](https://github.com/qupath/qupath/assets/154437026/e0daa716-19b8-47f9-b337-aa02cb1e44e9). ![image](https://github.com/qupath/qupath/assets/154437026/990ad117-5649-4e15-b376-8bce56d722bb). **Desktop (please",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:1295,Performance,concurren,concurrent,1295,"dist script for cell detection, errors are generated before any detections. **Can avoid both by manual annotation** with a polygon tool to follow image boundaries -> so not sure if a crucial bug. Carried over from last release to v5. **To Reproduce**; Steps to reproduce the behavior:; 1. Ctl+Shift+A; 2. Run cell detection as a script:; ```; setImageType('FLUORESCENCE');; selectAnnotations();; runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImage"":""DAPI"",""requestedPixelSizeMicrons"":0.1,""backgroundRadiusMicrons"":4.0,""backgroundByReconstruction"":true,""medianRadiusMicrons"":1.0,""sigmaMicrons"":2.5,""minAreaMicrons"":11.0,""maxAreaMicrons"":400.0,""threshold"":1000.0,""watershedPostProcess"":true,""cellExpansionMicrons"":5.0,""includeNuclei"":true,""smoothBoundaries"":true,""makeMeasurements"":true}'); ```; 4. Error:; ```; ERROR: Error running plugin: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; java.util.concurrent.ExecutionException: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.QuPathGUI.runPlugin(QuPathGUI.java:2245); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:248); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:270); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:4); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:331); at org.codehaus.groovy.jsr22",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:1466,Performance,concurren,concurrent,1466,"t sure if a crucial bug. Carried over from last release to v5. **To Reproduce**; Steps to reproduce the behavior:; 1. Ctl+Shift+A; 2. Run cell detection as a script:; ```; setImageType('FLUORESCENCE');; selectAnnotations();; runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImage"":""DAPI"",""requestedPixelSizeMicrons"":0.1,""backgroundRadiusMicrons"":4.0,""backgroundByReconstruction"":true,""medianRadiusMicrons"":1.0,""sigmaMicrons"":2.5,""minAreaMicrons"":11.0,""maxAreaMicrons"":400.0,""threshold"":1000.0,""watershedPostProcess"":true,""cellExpansionMicrons"":5.0,""includeNuclei"":true,""smoothBoundaries"":true,""makeMeasurements"":true}'); ```; 4. Error:; ```; ERROR: Error running plugin: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; java.util.concurrent.ExecutionException: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.QuPathGUI.runPlugin(QuPathGUI.java:2245); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:248); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:270); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:4); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:331); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:161); at qupath.lib.gui.scripting.languages.DefaultScriptLanguage.execute(DefaultScriptLanguage.java:234); at qup",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:1535,Performance,concurren,concurrent,1535,"eproduce**; Steps to reproduce the behavior:; 1. Ctl+Shift+A; 2. Run cell detection as a script:; ```; setImageType('FLUORESCENCE');; selectAnnotations();; runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImage"":""DAPI"",""requestedPixelSizeMicrons"":0.1,""backgroundRadiusMicrons"":4.0,""backgroundByReconstruction"":true,""medianRadiusMicrons"":1.0,""sigmaMicrons"":2.5,""minAreaMicrons"":11.0,""maxAreaMicrons"":400.0,""threshold"":1000.0,""watershedPostProcess"":true,""cellExpansionMicrons"":5.0,""includeNuclei"":true,""smoothBoundaries"":true,""makeMeasurements"":true}'); ```; 4. Error:; ```; ERROR: Error running plugin: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; java.util.concurrent.ExecutionException: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.QuPathGUI.runPlugin(QuPathGUI.java:2245); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:248); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:270); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:4); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:331); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:161); at qupath.lib.gui.scripting.languages.DefaultScriptLanguage.execute(DefaultScriptLanguage.java:234); at qupath.lib.gui.scripting.DefaultScriptEditor.executeScript(DefaultScript",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:2669,Performance,concurren,concurrent,2669,".lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.QuPathGUI.runPlugin(QuPathGUI.java:2245); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:248); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:270); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:4); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:331); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:161); at qupath.lib.gui.scripting.languages.DefaultScriptLanguage.execute(DefaultScriptLanguage.java:234); at qupath.lib.gui.scripting.DefaultScriptEditor.executeScript(DefaultScriptEditor.java:1166); at qupath.lib.gui.scripting.DefaultScriptEditor$3.run(DefaultScriptEditor.java:1534); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null at qupath.imagej.tools.IJTools.convertToUncalibratedImagePlus(IJTools.java:791); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:864); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:2751,Performance,concurren,concurrent,2751,"ib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.QuPathGUI.runPlugin(QuPathGUI.java:2245); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:248); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:270); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:4); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:331); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:161); at qupath.lib.gui.scripting.languages.DefaultScriptLanguage.execute(DefaultScriptLanguage.java:234); at qupath.lib.gui.scripting.DefaultScriptEditor.executeScript(DefaultScriptEditor.java:1166); at qupath.lib.gui.scripting.DefaultScriptEditor$3.run(DefaultScriptEditor.java:1534); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null at qupath.imagej.tools.IJTools.convertToUncalibratedImagePlus(IJTools.java:791); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:864); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:2817,Performance,concurren,concurrent,2817,".plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.QuPathGUI.runPlugin(QuPathGUI.java:2245); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:248); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:270); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:4); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:331); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:161); at qupath.lib.gui.scripting.languages.DefaultScriptLanguage.execute(DefaultScriptLanguage.java:234); at qupath.lib.gui.scripting.DefaultScriptEditor.executeScript(DefaultScriptEditor.java:1166); at qupath.lib.gui.scripting.DefaultScriptEditor$3.run(DefaultScriptEditor.java:1534); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null at qupath.imagej.tools.IJTools.convertToUncalibratedImagePlus(IJTools.java:791); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:864); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:2897,Performance,concurren,concurrent,2897,"PathGUI.runPlugin(QuPathGUI.java:2245); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:248); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:270); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:4); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:331); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:161); at qupath.lib.gui.scripting.languages.DefaultScriptLanguage.execute(DefaultScriptLanguage.java:234); at qupath.lib.gui.scripting.DefaultScriptEditor.executeScript(DefaultScriptEditor.java:1166); at qupath.lib.gui.scripting.DefaultScriptEditor$3.run(DefaultScriptEditor.java:1534); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null at qupath.imagej.tools.IJTools.convertToUncalibratedImagePlus(IJTools.java:791); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:864); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:3552,Performance,concurren,concurrent,3552,"); at qupath.lib.gui.scripting.DefaultScriptEditor$3.run(DefaultScriptEditor.java:1534); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null at qupath.imagej.tools.IJTools.convertToUncalibratedImagePlus(IJTools.java:791); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:864); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); ```; 6. Error repeats per tile. **Expected behavior**; To recognise bounds or the image in ""create full image annotation"" command, excluding what the error is calling ""null"" regions. **Screenshots**; ![image](https://github.com/qupath/qupath/assets/154437026/e0daa716-19b8-47f9-b337-aa02cb1e44e9). ![image](https://github.com/qupath/qupath/assets/154437026/990ad117-5649-4e15-b376-8bce56d722bb). **Desktop (please complete the following information):**; - OS: Windows 11; - QuPath Version: 0.5.0. **Additional context**; ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:3634,Performance,concurren,concurrent,3634,"3.run(DefaultScriptEditor.java:1534); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null at qupath.imagej.tools.IJTools.convertToUncalibratedImagePlus(IJTools.java:791); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:864); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); ```; 6. Error repeats per tile. **Expected behavior**; To recognise bounds or the image in ""create full image annotation"" command, excluding what the error is calling ""null"" regions. **Screenshots**; ![image](https://github.com/qupath/qupath/assets/154437026/e0daa716-19b8-47f9-b337-aa02cb1e44e9). ![image](https://github.com/qupath/qupath/assets/154437026/990ad117-5649-4e15-b376-8bce56d722bb). **Desktop (please complete the following information):**; - OS: Windows 11; - QuPath Version: 0.5.0. **Additional context**; Same issue was present in previous version (0.4.4)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:3700,Performance,concurren,concurrent,3700,"3.run(DefaultScriptEditor.java:1534); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null at qupath.imagej.tools.IJTools.convertToUncalibratedImagePlus(IJTools.java:791); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:864); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); ```; 6. Error repeats per tile. **Expected behavior**; To recognise bounds or the image in ""create full image annotation"" command, excluding what the error is calling ""null"" regions. **Screenshots**; ![image](https://github.com/qupath/qupath/assets/154437026/e0daa716-19b8-47f9-b337-aa02cb1e44e9). ![image](https://github.com/qupath/qupath/assets/154437026/990ad117-5649-4e15-b376-8bce56d722bb). **Desktop (please complete the following information):**; - OS: Windows 11; - QuPath Version: 0.5.0. **Additional context**; Same issue was present in previous version (0.4.4)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:3782,Performance,concurren,concurrent,3782,"3.run(DefaultScriptEditor.java:1534); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null at qupath.imagej.tools.IJTools.convertToUncalibratedImagePlus(IJTools.java:791); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:864); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); ```; 6. Error repeats per tile. **Expected behavior**; To recognise bounds or the image in ""create full image annotation"" command, excluding what the error is calling ""null"" regions. **Screenshots**; ![image](https://github.com/qupath/qupath/assets/154437026/e0daa716-19b8-47f9-b337-aa02cb1e44e9). ![image](https://github.com/qupath/qupath/assets/154437026/990ad117-5649-4e15-b376-8bce56d722bb). **Desktop (please complete the following information):**; - OS: Windows 11; - QuPath Version: 0.5.0. **Additional context**; Same issue was present in previous version (0.4.4)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:3848,Performance,concurren,concurrent,3848,"3.run(DefaultScriptEditor.java:1534); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null at qupath.imagej.tools.IJTools.convertToUncalibratedImagePlus(IJTools.java:791); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:864); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); ```; 6. Error repeats per tile. **Expected behavior**; To recognise bounds or the image in ""create full image annotation"" command, excluding what the error is calling ""null"" regions. **Screenshots**; ![image](https://github.com/qupath/qupath/assets/154437026/e0daa716-19b8-47f9-b337-aa02cb1e44e9). ![image](https://github.com/qupath/qupath/assets/154437026/990ad117-5649-4e15-b376-8bce56d722bb). **Desktop (please complete the following information):**; - OS: Windows 11; - QuPath Version: 0.5.0. **Additional context**; Same issue was present in previous version (0.4.4)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:3928,Performance,concurren,concurrent,3928,"3.run(DefaultScriptEditor.java:1534); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null at qupath.imagej.tools.IJTools.convertToUncalibratedImagePlus(IJTools.java:791); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:864); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); ```; 6. Error repeats per tile. **Expected behavior**; To recognise bounds or the image in ""create full image annotation"" command, excluding what the error is calling ""null"" regions. **Screenshots**; ![image](https://github.com/qupath/qupath/assets/154437026/e0daa716-19b8-47f9-b337-aa02cb1e44e9). ![image](https://github.com/qupath/qupath/assets/154437026/990ad117-5649-4e15-b376-8bce56d722bb). **Desktop (please complete the following information):**; - OS: Windows 11; - QuPath Version: 0.5.0. **Additional context**; Same issue was present in previous version (0.4.4)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:163,Safety,detect,detection,163,"## Bug report. **Describe the bug**; When optimising perameters for a project by creating a sparse composite image from different image entries. When running cell detection using script editor, errors are generated for the final tiles **IF** the entire shape is not a perfect rectangle. If using stardist script for cell detection, errors are generated before any detections. **Can avoid both by manual annotation** with a polygon tool to follow image boundaries -> so not sure if a crucial bug. Carried over from last release to v5. **To Reproduce**; Steps to reproduce the behavior:; 1. Ctl+Shift+A; 2. Run cell detection as a script:; ```; setImageType('FLUORESCENCE');; selectAnnotations();; runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImage"":""DAPI"",""requestedPixelSizeMicrons"":0.1,""backgroundRadiusMicrons"":4.0,""backgroundByReconstruction"":true,""medianRadiusMicrons"":1.0,""sigmaMicrons"":2.5,""minAreaMicrons"":11.0,""maxAreaMicrons"":400.0,""threshold"":1000.0,""watershedPostProcess"":true,""cellExpansionMicrons"":5.0,""includeNuclei"":true,""smoothBoundaries"":true,""makeMeasurements"":true}'); ```; 4. Error:; ```; ERROR: Error running plugin: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; java.util.concurrent.ExecutionException: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.QuPathGUI.runPlugin(QuPathGUI.java:2245); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:248); ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:321,Safety,detect,detection,321,"## Bug report. **Describe the bug**; When optimising perameters for a project by creating a sparse composite image from different image entries. When running cell detection using script editor, errors are generated for the final tiles **IF** the entire shape is not a perfect rectangle. If using stardist script for cell detection, errors are generated before any detections. **Can avoid both by manual annotation** with a polygon tool to follow image boundaries -> so not sure if a crucial bug. Carried over from last release to v5. **To Reproduce**; Steps to reproduce the behavior:; 1. Ctl+Shift+A; 2. Run cell detection as a script:; ```; setImageType('FLUORESCENCE');; selectAnnotations();; runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImage"":""DAPI"",""requestedPixelSizeMicrons"":0.1,""backgroundRadiusMicrons"":4.0,""backgroundByReconstruction"":true,""medianRadiusMicrons"":1.0,""sigmaMicrons"":2.5,""minAreaMicrons"":11.0,""maxAreaMicrons"":400.0,""threshold"":1000.0,""watershedPostProcess"":true,""cellExpansionMicrons"":5.0,""includeNuclei"":true,""smoothBoundaries"":true,""makeMeasurements"":true}'); ```; 4. Error:; ```; ERROR: Error running plugin: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; java.util.concurrent.ExecutionException: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.QuPathGUI.runPlugin(QuPathGUI.java:2245); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:248); ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:364,Safety,detect,detections,364,"## Bug report. **Describe the bug**; When optimising perameters for a project by creating a sparse composite image from different image entries. When running cell detection using script editor, errors are generated for the final tiles **IF** the entire shape is not a perfect rectangle. If using stardist script for cell detection, errors are generated before any detections. **Can avoid both by manual annotation** with a polygon tool to follow image boundaries -> so not sure if a crucial bug. Carried over from last release to v5. **To Reproduce**; Steps to reproduce the behavior:; 1. Ctl+Shift+A; 2. Run cell detection as a script:; ```; setImageType('FLUORESCENCE');; selectAnnotations();; runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImage"":""DAPI"",""requestedPixelSizeMicrons"":0.1,""backgroundRadiusMicrons"":4.0,""backgroundByReconstruction"":true,""medianRadiusMicrons"":1.0,""sigmaMicrons"":2.5,""minAreaMicrons"":11.0,""maxAreaMicrons"":400.0,""threshold"":1000.0,""watershedPostProcess"":true,""cellExpansionMicrons"":5.0,""includeNuclei"":true,""smoothBoundaries"":true,""makeMeasurements"":true}'); ```; 4. Error:; ```; ERROR: Error running plugin: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; java.util.concurrent.ExecutionException: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.QuPathGUI.runPlugin(QuPathGUI.java:2245); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:248); ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:382,Safety,avoid,avoid,382,"## Bug report. **Describe the bug**; When optimising perameters for a project by creating a sparse composite image from different image entries. When running cell detection using script editor, errors are generated for the final tiles **IF** the entire shape is not a perfect rectangle. If using stardist script for cell detection, errors are generated before any detections. **Can avoid both by manual annotation** with a polygon tool to follow image boundaries -> so not sure if a crucial bug. Carried over from last release to v5. **To Reproduce**; Steps to reproduce the behavior:; 1. Ctl+Shift+A; 2. Run cell detection as a script:; ```; setImageType('FLUORESCENCE');; selectAnnotations();; runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImage"":""DAPI"",""requestedPixelSizeMicrons"":0.1,""backgroundRadiusMicrons"":4.0,""backgroundByReconstruction"":true,""medianRadiusMicrons"":1.0,""sigmaMicrons"":2.5,""minAreaMicrons"":11.0,""maxAreaMicrons"":400.0,""threshold"":1000.0,""watershedPostProcess"":true,""cellExpansionMicrons"":5.0,""includeNuclei"":true,""smoothBoundaries"":true,""makeMeasurements"":true}'); ```; 4. Error:; ```; ERROR: Error running plugin: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; java.util.concurrent.ExecutionException: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.QuPathGUI.runPlugin(QuPathGUI.java:2245); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:248); ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:614,Safety,detect,detection,614,"## Bug report. **Describe the bug**; When optimising perameters for a project by creating a sparse composite image from different image entries. When running cell detection using script editor, errors are generated for the final tiles **IF** the entire shape is not a perfect rectangle. If using stardist script for cell detection, errors are generated before any detections. **Can avoid both by manual annotation** with a polygon tool to follow image boundaries -> so not sure if a crucial bug. Carried over from last release to v5. **To Reproduce**; Steps to reproduce the behavior:; 1. Ctl+Shift+A; 2. Run cell detection as a script:; ```; setImageType('FLUORESCENCE');; selectAnnotations();; runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImage"":""DAPI"",""requestedPixelSizeMicrons"":0.1,""backgroundRadiusMicrons"":4.0,""backgroundByReconstruction"":true,""medianRadiusMicrons"":1.0,""sigmaMicrons"":2.5,""minAreaMicrons"":11.0,""maxAreaMicrons"":400.0,""threshold"":1000.0,""watershedPostProcess"":true,""cellExpansionMicrons"":5.0,""includeNuclei"":true,""smoothBoundaries"":true,""makeMeasurements"":true}'); ```; 4. Error:; ```; ERROR: Error running plugin: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; java.util.concurrent.ExecutionException: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.QuPathGUI.runPlugin(QuPathGUI.java:2245); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:248); ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:721,Safety,detect,detect,721,"## Bug report. **Describe the bug**; When optimising perameters for a project by creating a sparse composite image from different image entries. When running cell detection using script editor, errors are generated for the final tiles **IF** the entire shape is not a perfect rectangle. If using stardist script for cell detection, errors are generated before any detections. **Can avoid both by manual annotation** with a polygon tool to follow image boundaries -> so not sure if a crucial bug. Carried over from last release to v5. **To Reproduce**; Steps to reproduce the behavior:; 1. Ctl+Shift+A; 2. Run cell detection as a script:; ```; setImageType('FLUORESCENCE');; selectAnnotations();; runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImage"":""DAPI"",""requestedPixelSizeMicrons"":0.1,""backgroundRadiusMicrons"":4.0,""backgroundByReconstruction"":true,""medianRadiusMicrons"":1.0,""sigmaMicrons"":2.5,""minAreaMicrons"":11.0,""maxAreaMicrons"":400.0,""threshold"":1000.0,""watershedPostProcess"":true,""cellExpansionMicrons"":5.0,""includeNuclei"":true,""smoothBoundaries"":true,""makeMeasurements"":true}'); ```; 4. Error:; ```; ERROR: Error running plugin: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; java.util.concurrent.ExecutionException: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.QuPathGUI.runPlugin(QuPathGUI.java:2245); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:248); ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:762,Safety,detect,detectionImage,762,"## Bug report. **Describe the bug**; When optimising perameters for a project by creating a sparse composite image from different image entries. When running cell detection using script editor, errors are generated for the final tiles **IF** the entire shape is not a perfect rectangle. If using stardist script for cell detection, errors are generated before any detections. **Can avoid both by manual annotation** with a polygon tool to follow image boundaries -> so not sure if a crucial bug. Carried over from last release to v5. **To Reproduce**; Steps to reproduce the behavior:; 1. Ctl+Shift+A; 2. Run cell detection as a script:; ```; setImageType('FLUORESCENCE');; selectAnnotations();; runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImage"":""DAPI"",""requestedPixelSizeMicrons"":0.1,""backgroundRadiusMicrons"":4.0,""backgroundByReconstruction"":true,""medianRadiusMicrons"":1.0,""sigmaMicrons"":2.5,""minAreaMicrons"":11.0,""maxAreaMicrons"":400.0,""threshold"":1000.0,""watershedPostProcess"":true,""cellExpansionMicrons"":5.0,""includeNuclei"":true,""smoothBoundaries"":true,""makeMeasurements"":true}'); ```; 4. Error:; ```; ERROR: Error running plugin: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; java.util.concurrent.ExecutionException: java.lang.NullPointerException: Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.QuPathGUI.runPlugin(QuPathGUI.java:2245); at qupath.lib.gui.scripting.QPEx.runPlugin(QPEx.java:248); ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:3336,Safety,detect,detect,3336,"riptEngineImpl.java:161); at qupath.lib.gui.scripting.languages.DefaultScriptLanguage.execute(DefaultScriptLanguage.java:234); at qupath.lib.gui.scripting.DefaultScriptEditor.executeScript(DefaultScriptEditor.java:1166); at qupath.lib.gui.scripting.DefaultScriptEditor$3.run(DefaultScriptEditor.java:1534); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null at qupath.imagej.tools.IJTools.convertToUncalibratedImagePlus(IJTools.java:791); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:864); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); ```; 6. Error repeats per tile. **Expected behavior**; To recognise bounds or the image in ""create full image annotation"" command, excluding what the error is calling ""null"" regions. **Screenshots**; ![image](https://github.com/qupath/qupath/assets/154437026/e0daa716-19b8-47f9-b337-aa02cb1e44e9). ![ima",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:3454,Safety,Detect,DetectionPluginTools,3454,"th.lib.gui.scripting.DefaultScriptEditor.executeScript(DefaultScriptEditor.java:1166); at qupath.lib.gui.scripting.DefaultScriptEditor$3.run(DefaultScriptEditor.java:1534); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null at qupath.imagej.tools.IJTools.convertToUncalibratedImagePlus(IJTools.java:791); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:864); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); ```; 6. Error repeats per tile. **Expected behavior**; To recognise bounds or the image in ""create full image annotation"" command, excluding what the error is calling ""null"" regions. **Screenshots**; ![image](https://github.com/qupath/qupath/assets/154437026/e0daa716-19b8-47f9-b337-aa02cb1e44e9). ![image](https://github.com/qupath/qupath/assets/154437026/990ad117-5649-4e15-b376-8bce56d722bb). **Desktop (please complete the following ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:3475,Safety,Detect,DetectionRunnable,3475,"th.lib.gui.scripting.DefaultScriptEditor.executeScript(DefaultScriptEditor.java:1166); at qupath.lib.gui.scripting.DefaultScriptEditor$3.run(DefaultScriptEditor.java:1534); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null at qupath.imagej.tools.IJTools.convertToUncalibratedImagePlus(IJTools.java:791); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:864); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); ```; 6. Error repeats per tile. **Expected behavior**; To recognise bounds or the image in ""create full image annotation"" command, excluding what the error is calling ""null"" regions. **Screenshots**; ![image](https://github.com/qupath/qupath/assets/154437026/e0daa716-19b8-47f9-b337-aa02cb1e44e9). ![image](https://github.com/qupath/qupath/assets/154437026/990ad117-5649-4e15-b376-8bce56d722bb). **Desktop (please complete the following ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:3497,Safety,Detect,DetectionPluginTools,3497,"ptEditor.executeScript(DefaultScriptEditor.java:1166); at qupath.lib.gui.scripting.DefaultScriptEditor$3.run(DefaultScriptEditor.java:1534); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by Cannot invoke ""java.awt.image.BufferedImage.getSampleModel()"" because ""img"" is null at qupath.imagej.tools.IJTools.convertToUncalibratedImagePlus(IJTools.java:791); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:864); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); ```; 6. Error repeats per tile. **Expected behavior**; To recognise bounds or the image in ""create full image annotation"" command, excluding what the error is calling ""null"" regions. **Screenshots**; ![image](https://github.com/qupath/qupath/assets/154437026/e0daa716-19b8-47f9-b337-aa02cb1e44e9). ![image](https://github.com/qupath/qupath/assets/154437026/990ad117-5649-4e15-b376-8bce56d722bb). **Desktop (please complete the following information):**; - OS: Windows 1",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1444:237,Availability,Error,Error,237,"Reopening this as it's very similar and still happening in QuPath 0.5.0; A user had an annotation inside which there was another annotation filled with detections (over 5000); When runing ""Delaunay cluster features 2D"" we ran into; ```; Error running plugin: java.util.ConcurrentModificationException; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concu",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444
https://github.com/qupath/qupath/issues/1444:1295,Integrability,Synchroniz,SynchronizedMap,1295,ion; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurr,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444
https://github.com/qupath/qupath/issues/1444:251,Modifiability,plugin,plugin,251,"Reopening this as it's very similar and still happening in QuPath 0.5.0; A user had an annotation inside which there was another annotation filled with detections (over 5000); When runing ""Delaunay cluster features 2D"" we ran into; ```; Error running plugin: java.util.ConcurrentModificationException; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concu",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444
https://github.com/qupath/qupath/issues/1444:535,Modifiability,plugin,plugins,535,"Reopening this as it's very similar and still happening in QuPath 0.5.0; A user had an annotation inside which there was another annotation filled with detections (over 5000); When runing ""Delaunay cluster features 2D"" we ran into; ```; Error running plugin: java.util.ConcurrentModificationException; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concu",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444
https://github.com/qupath/qupath/issues/1444:622,Modifiability,plugin,plugins,622,"Reopening this as it's very similar and still happening in QuPath 0.5.0; A user had an annotation inside which there was another annotation filled with detections (over 5000); When runing ""Delaunay cluster features 2D"" we ran into; ```; Error running plugin: java.util.ConcurrentModificationException; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concu",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444
https://github.com/qupath/qupath/issues/1444:766,Modifiability,plugin,plugins,766,"Reopening this as it's very similar and still happening in QuPath 0.5.0; A user had an annotation inside which there was another annotation filled with detections (over 5000); When runing ""Delaunay cluster features 2D"" we ran into; ```; Error running plugin: java.util.ConcurrentModificationException; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concu",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444
https://github.com/qupath/qupath/issues/1444:269,Performance,Concurren,ConcurrentModificationException,269,"Reopening this as it's very similar and still happening in QuPath 0.5.0; A user had an annotation inside which there was another annotation filled with detections (over 5000); When runing ""Delaunay cluster features 2D"" we ran into; ```; Error running plugin: java.util.ConcurrentModificationException; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concu",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444
https://github.com/qupath/qupath/issues/1444:312,Performance,concurren,concurrent,312,"Reopening this as it's very similar and still happening in QuPath 0.5.0; A user had an annotation inside which there was another annotation filled with detections (over 5000); When runing ""Delaunay cluster features 2D"" we ran into; ```; Error running plugin: java.util.ConcurrentModificationException; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concu",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444
https://github.com/qupath/qupath/issues/1444:353,Performance,Concurren,ConcurrentModificationException,353,"Reopening this as it's very similar and still happening in QuPath 0.5.0; A user had an annotation inside which there was another annotation filled with detections (over 5000); When runing ""Delaunay cluster features 2D"" we ran into; ```; Error running plugin: java.util.ConcurrentModificationException; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concu",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444
https://github.com/qupath/qupath/issues/1444:409,Performance,concurren,concurrent,409,"Reopening this as it's very similar and still happening in QuPath 0.5.0; A user had an annotation inside which there was another annotation filled with detections (over 5000); When runing ""Delaunay cluster features 2D"" we ran into; ```; Error running plugin: java.util.ConcurrentModificationException; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concu",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444
https://github.com/qupath/qupath/issues/1444:478,Performance,concurren,concurrent,478,"Reopening this as it's very similar and still happening in QuPath 0.5.0; A user had an annotation inside which there was another annotation filled with detections (over 5000); When runing ""Delaunay cluster features 2D"" we ran into; ```; Error running plugin: java.util.ConcurrentModificationException; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concu",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444
https://github.com/qupath/qupath/issues/1444:978,Performance,Concurren,ConcurrentModificationException,978,"Reopening this as it's very similar and still happening in QuPath 0.5.0; A user had an annotation inside which there was another annotation filled with detections (over 5000); When runing ""Delaunay cluster features 2D"" we ran into; ```; Error running plugin: java.util.ConcurrentModificationException; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concu",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444
https://github.com/qupath/qupath/issues/1444:1914,Performance,concurren,concurrent,1914,AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); ```; I can ask them to share a QuPath project if it's useful to you. . The issue appeared on a built from source linux QuPath if that's of any use. All the best and happy new year. _Originally posted by @lacan in https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601_,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444
https://github.com/qupath/qupath/issues/1444:1996,Performance,concurren,concurrent,1996,AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); ```; I can ask them to share a QuPath project if it's useful to you. . The issue appeared on a built from source linux QuPath if that's of any use. All the best and happy new year. _Originally posted by @lacan in https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601_,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444
https://github.com/qupath/qupath/issues/1444:2062,Performance,concurren,concurrent,2062,AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); ```; I can ask them to share a QuPath project if it's useful to you. . The issue appeared on a built from source linux QuPath if that's of any use. All the best and happy new year. _Originally posted by @lacan in https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601_,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444
https://github.com/qupath/qupath/issues/1444:2144,Performance,concurren,concurrent,2144,AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); ```; I can ask them to share a QuPath project if it's useful to you. . The issue appeared on a built from source linux QuPath if that's of any use. All the best and happy new year. _Originally posted by @lacan in https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601_,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444
https://github.com/qupath/qupath/issues/1444:2210,Performance,concurren,concurrent,2210,AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); ```; I can ask them to share a QuPath project if it's useful to you. . The issue appeared on a built from source linux QuPath if that's of any use. All the best and happy new year. _Originally posted by @lacan in https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601_,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444
https://github.com/qupath/qupath/issues/1444:2290,Performance,concurren,concurrent,2290,AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); ```; I can ask them to share a QuPath project if it's useful to you. . The issue appeared on a built from source linux QuPath if that's of any use. All the best and happy new year. _Originally posted by @lacan in https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601_,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444
https://github.com/qupath/qupath/issues/1444:152,Safety,detect,detections,152,"Reopening this as it's very similar and still happening in QuPath 0.5.0; A user had an annotation inside which there was another annotation filled with detections (over 5000); When runing ""Delaunay cluster features 2D"" we ran into; ```; Error running plugin: java.util.ConcurrentModificationException; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concu",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444
https://github.com/qupath/qupath/issues/1446:1179,Performance,cache,cache,1179,"## Bug report. **Describe the bug**; See https://forum.image.sc/t/apply-script-to-non-imported-images/90559. **To Reproduce**; Steps to reproduce the behavior:; 1. Create a project; 2. Add a *lot* of images (perhaps > 1,000); 3. Scroll around the project tab. It may be laggy and annoying as thumbnails are being generated, and also afterwards as they are read from disk. (I should admit I haven't tried this myself... I'm just assuming this will be problematic based on the description). **Expected behavior**; The project tab should be responsive, especially after thumbnails are created. **Desktop (please complete the following information):**; - OS: All; - QuPath Version: v0.5.0 (and earlier). **Additional context**; The relevant code is [here](https://github.com/qupath/qupath/blob/864ac71893a8749ff226c99e51642a5e10ea89ea/qupath-gui-fx/src/main/java/qupath/lib/gui/panes/ProjectBrowser.java#L1223). Generating a thumbnail can be expensive, so is currently done lazily on-demand in a single thread. For example, a large non-pyramidal image might require a lot of memory - and so attempting to parallelize thumbnail generation could be risky. We also might not be able to cache *all* thumbnails in a map, as this could be too memory demanding. We might nevertheless consider; 1. A ‘None’ option to not show thumbnails; 2. A ‘Generate missing thumbnails’ option to instruct QuPath to create all of them at once, instead of on-demand.; 3. Using the main tile cache for project thumbnail caching (since this should eject old entries when too much memory is needed)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1446
https://github.com/qupath/qupath/issues/1446:1464,Performance,cache,cache,1464,"## Bug report. **Describe the bug**; See https://forum.image.sc/t/apply-script-to-non-imported-images/90559. **To Reproduce**; Steps to reproduce the behavior:; 1. Create a project; 2. Add a *lot* of images (perhaps > 1,000); 3. Scroll around the project tab. It may be laggy and annoying as thumbnails are being generated, and also afterwards as they are read from disk. (I should admit I haven't tried this myself... I'm just assuming this will be problematic based on the description). **Expected behavior**; The project tab should be responsive, especially after thumbnails are created. **Desktop (please complete the following information):**; - OS: All; - QuPath Version: v0.5.0 (and earlier). **Additional context**; The relevant code is [here](https://github.com/qupath/qupath/blob/864ac71893a8749ff226c99e51642a5e10ea89ea/qupath-gui-fx/src/main/java/qupath/lib/gui/panes/ProjectBrowser.java#L1223). Generating a thumbnail can be expensive, so is currently done lazily on-demand in a single thread. For example, a large non-pyramidal image might require a lot of memory - and so attempting to parallelize thumbnail generation could be risky. We also might not be able to cache *all* thumbnails in a map, as this could be too memory demanding. We might nevertheless consider; 1. A ‘None’ option to not show thumbnails; 2. A ‘Generate missing thumbnails’ option to instruct QuPath to create all of them at once, instead of on-demand.; 3. Using the main tile cache for project thumbnail caching (since this should eject old entries when too much memory is needed)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1446
https://github.com/qupath/qupath/issues/1446:1143,Safety,risk,risky,1143,"## Bug report. **Describe the bug**; See https://forum.image.sc/t/apply-script-to-non-imported-images/90559. **To Reproduce**; Steps to reproduce the behavior:; 1. Create a project; 2. Add a *lot* of images (perhaps > 1,000); 3. Scroll around the project tab. It may be laggy and annoying as thumbnails are being generated, and also afterwards as they are read from disk. (I should admit I haven't tried this myself... I'm just assuming this will be problematic based on the description). **Expected behavior**; The project tab should be responsive, especially after thumbnails are created. **Desktop (please complete the following information):**; - OS: All; - QuPath Version: v0.5.0 (and earlier). **Additional context**; The relevant code is [here](https://github.com/qupath/qupath/blob/864ac71893a8749ff226c99e51642a5e10ea89ea/qupath-gui-fx/src/main/java/qupath/lib/gui/panes/ProjectBrowser.java#L1223). Generating a thumbnail can be expensive, so is currently done lazily on-demand in a single thread. For example, a large non-pyramidal image might require a lot of memory - and so attempting to parallelize thumbnail generation could be risky. We also might not be able to cache *all* thumbnails in a map, as this could be too memory demanding. We might nevertheless consider; 1. A ‘None’ option to not show thumbnails; 2. A ‘Generate missing thumbnails’ option to instruct QuPath to create all of them at once, instead of on-demand.; 3. Using the main tile cache for project thumbnail caching (since this should eject old entries when too much memory is needed)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1446
https://github.com/qupath/qupath/issues/1446:538,Usability,responsiv,responsive,538,"## Bug report. **Describe the bug**; See https://forum.image.sc/t/apply-script-to-non-imported-images/90559. **To Reproduce**; Steps to reproduce the behavior:; 1. Create a project; 2. Add a *lot* of images (perhaps > 1,000); 3. Scroll around the project tab. It may be laggy and annoying as thumbnails are being generated, and also afterwards as they are read from disk. (I should admit I haven't tried this myself... I'm just assuming this will be problematic based on the description). **Expected behavior**; The project tab should be responsive, especially after thumbnails are created. **Desktop (please complete the following information):**; - OS: All; - QuPath Version: v0.5.0 (and earlier). **Additional context**; The relevant code is [here](https://github.com/qupath/qupath/blob/864ac71893a8749ff226c99e51642a5e10ea89ea/qupath-gui-fx/src/main/java/qupath/lib/gui/panes/ProjectBrowser.java#L1223). Generating a thumbnail can be expensive, so is currently done lazily on-demand in a single thread. For example, a large non-pyramidal image might require a lot of memory - and so attempting to parallelize thumbnail generation could be risky. We also might not be able to cache *all* thumbnails in a map, as this could be too memory demanding. We might nevertheless consider; 1. A ‘None’ option to not show thumbnails; 2. A ‘Generate missing thumbnails’ option to instruct QuPath to create all of them at once, instead of on-demand.; 3. Using the main tile cache for project thumbnail caching (since this should eject old entries when too much memory is needed)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1446
https://github.com/qupath/qupath/pull/1447:103,Availability,error,error,103,"When running a script from the command line, extensions aren't loaded until much later, so we throw an error if you try to open an image with openslide. See https://forum.image.sc/t/running-qupath-through-command-line-unable-to-access-image-data/90746 for an example",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1447
https://github.com/qupath/qupath/pull/1447:63,Performance,load,loaded,63,"When running a script from the command line, extensions aren't loaded until much later, so we throw an error if you try to open an image with openslide. See https://forum.image.sc/t/running-qupath-through-command-line-unable-to-access-image-data/90746 for an example",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1447
https://github.com/qupath/qupath/pull/1447:228,Security,access,access-image-data,228,"When running a script from the command line, extensions aren't loaded until much later, so we throw an error if you try to open an image with openslide. See https://forum.image.sc/t/running-qupath-through-command-line-unable-to-access-image-data/90746 for an example",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1447
https://github.com/qupath/qupath/issues/1448:277,Availability,down,download-on-my-Mac-not-showing-up-on-launchpad-They-re-accessible-via-finder-only-in-the-applications-folder,277,"## Bug report. **Describe the bug**; After installing QuPath x64 on an M1 mac, everything works as intended. It is in the Applications folder and can be found using `CMD+Space`; However, it does not show up on the Launchpad. We tried ; https://www.quora.com/Why-are-the-apps-I-download-on-my-Mac-not-showing-up-on-launchpad-They-re-accessible-via-finder-only-in-the-applications-folder; but the command line that was suggested did not change the behaviour. **To Reproduce**; Steps to reproduce the behavior:; 1. Have QuPath 0.4.3 installed; 2. Notice how it can be found in the Launchpad; 3. Download and install QuPath 0.5.0-x64 for MacOS; 4. Notice QuPath 0.5.0-x64 in the Applications folder; 5. Try to find QuPath 0.5.0 in the Launchpa. **Expected behavior**; With previous versions of QuPath, it would automatically show up on the Launchpad. **Desktop**; - OS: MacOS Sonoma 14.2.1; - QuPath Version: 0.5.0. While definitely not a dealbreaker, it was an interesting behaviour to notice. It might be linked to there being two QuPath versions existing, however the user said that this had not been an issue in the past.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1448
https://github.com/qupath/qupath/issues/1448:592,Availability,Down,Download,592,"## Bug report. **Describe the bug**; After installing QuPath x64 on an M1 mac, everything works as intended. It is in the Applications folder and can be found using `CMD+Space`; However, it does not show up on the Launchpad. We tried ; https://www.quora.com/Why-are-the-apps-I-download-on-my-Mac-not-showing-up-on-launchpad-They-re-accessible-via-finder-only-in-the-applications-folder; but the command line that was suggested did not change the behaviour. **To Reproduce**; Steps to reproduce the behavior:; 1. Have QuPath 0.4.3 installed; 2. Notice how it can be found in the Launchpad; 3. Download and install QuPath 0.5.0-x64 for MacOS; 4. Notice QuPath 0.5.0-x64 in the Applications folder; 5. Try to find QuPath 0.5.0 in the Launchpa. **Expected behavior**; With previous versions of QuPath, it would automatically show up on the Launchpad. **Desktop**; - OS: MacOS Sonoma 14.2.1; - QuPath Version: 0.5.0. While definitely not a dealbreaker, it was an interesting behaviour to notice. It might be linked to there being two QuPath versions existing, however the user said that this had not been an issue in the past.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1448
https://github.com/qupath/qupath/issues/1448:43,Deployability,install,installing,43,"## Bug report. **Describe the bug**; After installing QuPath x64 on an M1 mac, everything works as intended. It is in the Applications folder and can be found using `CMD+Space`; However, it does not show up on the Launchpad. We tried ; https://www.quora.com/Why-are-the-apps-I-download-on-my-Mac-not-showing-up-on-launchpad-They-re-accessible-via-finder-only-in-the-applications-folder; but the command line that was suggested did not change the behaviour. **To Reproduce**; Steps to reproduce the behavior:; 1. Have QuPath 0.4.3 installed; 2. Notice how it can be found in the Launchpad; 3. Download and install QuPath 0.5.0-x64 for MacOS; 4. Notice QuPath 0.5.0-x64 in the Applications folder; 5. Try to find QuPath 0.5.0 in the Launchpa. **Expected behavior**; With previous versions of QuPath, it would automatically show up on the Launchpad. **Desktop**; - OS: MacOS Sonoma 14.2.1; - QuPath Version: 0.5.0. While definitely not a dealbreaker, it was an interesting behaviour to notice. It might be linked to there being two QuPath versions existing, however the user said that this had not been an issue in the past.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1448
https://github.com/qupath/qupath/issues/1448:530,Deployability,install,installed,530,"## Bug report. **Describe the bug**; After installing QuPath x64 on an M1 mac, everything works as intended. It is in the Applications folder and can be found using `CMD+Space`; However, it does not show up on the Launchpad. We tried ; https://www.quora.com/Why-are-the-apps-I-download-on-my-Mac-not-showing-up-on-launchpad-They-re-accessible-via-finder-only-in-the-applications-folder; but the command line that was suggested did not change the behaviour. **To Reproduce**; Steps to reproduce the behavior:; 1. Have QuPath 0.4.3 installed; 2. Notice how it can be found in the Launchpad; 3. Download and install QuPath 0.5.0-x64 for MacOS; 4. Notice QuPath 0.5.0-x64 in the Applications folder; 5. Try to find QuPath 0.5.0 in the Launchpa. **Expected behavior**; With previous versions of QuPath, it would automatically show up on the Launchpad. **Desktop**; - OS: MacOS Sonoma 14.2.1; - QuPath Version: 0.5.0. While definitely not a dealbreaker, it was an interesting behaviour to notice. It might be linked to there being two QuPath versions existing, however the user said that this had not been an issue in the past.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1448
https://github.com/qupath/qupath/issues/1448:605,Deployability,install,install,605,"## Bug report. **Describe the bug**; After installing QuPath x64 on an M1 mac, everything works as intended. It is in the Applications folder and can be found using `CMD+Space`; However, it does not show up on the Launchpad. We tried ; https://www.quora.com/Why-are-the-apps-I-download-on-my-Mac-not-showing-up-on-launchpad-They-re-accessible-via-finder-only-in-the-applications-folder; but the command line that was suggested did not change the behaviour. **To Reproduce**; Steps to reproduce the behavior:; 1. Have QuPath 0.4.3 installed; 2. Notice how it can be found in the Launchpad; 3. Download and install QuPath 0.5.0-x64 for MacOS; 4. Notice QuPath 0.5.0-x64 in the Applications folder; 5. Try to find QuPath 0.5.0 in the Launchpa. **Expected behavior**; With previous versions of QuPath, it would automatically show up on the Launchpad. **Desktop**; - OS: MacOS Sonoma 14.2.1; - QuPath Version: 0.5.0. While definitely not a dealbreaker, it was an interesting behaviour to notice. It might be linked to there being two QuPath versions existing, however the user said that this had not been an issue in the past.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1448
https://github.com/qupath/qupath/issues/1448:332,Security,access,accessible-via-finder-only-in-the-applications-folder,332,"## Bug report. **Describe the bug**; After installing QuPath x64 on an M1 mac, everything works as intended. It is in the Applications folder and can be found using `CMD+Space`; However, it does not show up on the Launchpad. We tried ; https://www.quora.com/Why-are-the-apps-I-download-on-my-Mac-not-showing-up-on-launchpad-They-re-accessible-via-finder-only-in-the-applications-folder; but the command line that was suggested did not change the behaviour. **To Reproduce**; Steps to reproduce the behavior:; 1. Have QuPath 0.4.3 installed; 2. Notice how it can be found in the Launchpad; 3. Download and install QuPath 0.5.0-x64 for MacOS; 4. Notice QuPath 0.5.0-x64 in the Applications folder; 5. Try to find QuPath 0.5.0 in the Launchpa. **Expected behavior**; With previous versions of QuPath, it would automatically show up on the Launchpad. **Desktop**; - OS: MacOS Sonoma 14.2.1; - QuPath Version: 0.5.0. While definitely not a dealbreaker, it was an interesting behaviour to notice. It might be linked to there being two QuPath versions existing, however the user said that this had not been an issue in the past.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1448
https://github.com/qupath/qupath/pull/1449:283,Performance,load,loading,283,"Recently my laboratory had to move all its files from a Samba storage server to a linux one, accessible only through SFTP/SSH.; For this reason my colleagues' Windows PCs were forced to use [`sshfs-win`](https://github.com/winfsp/sshfs-win) in order to mount the remote storage when loading images from QuPath. Everything seem to work as intended, however saving projects (and probably other files too) is problematic. This is not a problem of QuPath itself, but rather [a know problem](https://github.com/winfsp/sshfs-win/issues/349) of `sshfs-win` not (yet) supporting Windows' `GetFileInformationByHandle` to retrieve file identifiers.; These identifiers are actively used by Java's Windows' filesystem provider to check whether two files [are the same](https://github.com/openjdk/jdk/blob/cbfddf4e1d3ff8dddb95bcb9242b31c175b768fc/src/java.base/windows/classes/sun/nio/fs/WindowsFileAttributes.java#L349) when requesting for a [`copy()`](https://github.com/openjdk/jdk/blob/cbfddf4e1d3ff8dddb95bcb9242b31c175b768fc/src/java.base/windows/classes/sun/nio/fs/WindowsFileCopy.java#L126) or [`move()`](https://github.com/openjdk/jdk/blob/cbfddf4e1d3ff8dddb95bcb9242b31c175b768fc/src/java.base/windows/classes/sun/nio/fs/WindowsFileCopy.java#L363) operation.; All this PR does is to use `Files.deleteIfExists()` instead of calling `copy()` and `move()` with `StandardCopyOption.REPLACE_EXISTING`. Semantically the result is the same. I know that the issue is not on QuPath's side, however since the fix is very small on yourside i was hoping you would accept this PR anyway. It may come handy to other people in similar scenarios that don't know how to takle the problem",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1449
https://github.com/qupath/qupath/pull/1449:93,Security,access,accessible,93,"Recently my laboratory had to move all its files from a Samba storage server to a linux one, accessible only through SFTP/SSH.; For this reason my colleagues' Windows PCs were forced to use [`sshfs-win`](https://github.com/winfsp/sshfs-win) in order to mount the remote storage when loading images from QuPath. Everything seem to work as intended, however saving projects (and probably other files too) is problematic. This is not a problem of QuPath itself, but rather [a know problem](https://github.com/winfsp/sshfs-win/issues/349) of `sshfs-win` not (yet) supporting Windows' `GetFileInformationByHandle` to retrieve file identifiers.; These identifiers are actively used by Java's Windows' filesystem provider to check whether two files [are the same](https://github.com/openjdk/jdk/blob/cbfddf4e1d3ff8dddb95bcb9242b31c175b768fc/src/java.base/windows/classes/sun/nio/fs/WindowsFileAttributes.java#L349) when requesting for a [`copy()`](https://github.com/openjdk/jdk/blob/cbfddf4e1d3ff8dddb95bcb9242b31c175b768fc/src/java.base/windows/classes/sun/nio/fs/WindowsFileCopy.java#L126) or [`move()`](https://github.com/openjdk/jdk/blob/cbfddf4e1d3ff8dddb95bcb9242b31c175b768fc/src/java.base/windows/classes/sun/nio/fs/WindowsFileCopy.java#L363) operation.; All this PR does is to use `Files.deleteIfExists()` instead of calling `copy()` and `move()` with `StandardCopyOption.REPLACE_EXISTING`. Semantically the result is the same. I know that the issue is not on QuPath's side, however since the fix is very small on yourside i was hoping you would accept this PR anyway. It may come handy to other people in similar scenarios that don't know how to takle the problem",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1449
https://github.com/qupath/qupath/issues/1451:930,Availability,failure,failure,930,"## IMPORTANT!. This section is **only** for bug reports, which **must** follow the template below. Please post any other questions to the official QuPath forum at https://forum.image.sc/tags/qupath. If in doubt, use [image.sc](https://forum.image.sc/tags/qupath). This helps us keep things organized. ## Before we begin... Before submitting your bug report, please check the following:. * [x] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; `QuPath convert-ome` returns exit code 0 despite failure. **To Reproduce**; Steps to reproduce the behavior:; ```; scale=2; tile=1024; comp=ZLIB; input=broken_image.tif; output=broke_omage.ome.tif; QuPath convert-ome $input $output \; --pyramid-scale=$scale \; --tile-size=$tile \; --compression=$comp \; --parallelize; ```; Output (truncated); ```; 20:39:42.582 [main] [INFO ] q.l.i.s.b.BioFormatsServerOptions - Setting max Bio-Formats readers to 2; 20:39:43.272 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.274 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.275 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; ...; 20:39:43.604 [main] [ERROR] q.l.i.writers.ome.ConvertCommand - Unable to open file:broken_image.tif; java.io.IOException: Unable to open file:broken_image.tif; at qupath.lib.images.servers.ImageServers.buildServer(ImageServers.java:306); at qupath.lib.images.writers.ome.ConvertCommand.run(ConvertCommand.java:147); at picocli.CommandLine.executeUserObject(CommandLine.java:2026); at picocli.C",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1451
https://github.com/qupath/qupath/issues/1451:1354,Availability,ERROR,ERROR,1354,"rt, please check the following:. * [x] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; `QuPath convert-ome` returns exit code 0 despite failure. **To Reproduce**; Steps to reproduce the behavior:; ```; scale=2; tile=1024; comp=ZLIB; input=broken_image.tif; output=broke_omage.ome.tif; QuPath convert-ome $input $output \; --pyramid-scale=$scale \; --tile-size=$tile \; --compression=$comp \; --parallelize; ```; Output (truncated); ```; 20:39:42.582 [main] [INFO ] q.l.i.s.b.BioFormatsServerOptions - Setting max Bio-Formats readers to 2; 20:39:43.272 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.274 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.275 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; ...; 20:39:43.604 [main] [ERROR] q.l.i.writers.ome.ConvertCommand - Unable to open file:broken_image.tif; java.io.IOException: Unable to open file:broken_image.tif; at qupath.lib.images.servers.ImageServers.buildServer(ImageServers.java:306); at qupath.lib.images.writers.ome.ConvertCommand.run(ConvertCommand.java:147); at picocli.CommandLine.executeUserObject(CommandLine.java:2026); at picocli.CommandLine.access$1500(CommandLine.java:148); at picocli.CommandLine$RunLast.executeUserObjectOfLastSubcommandWithSameParent(CommandLine.java:2461); at picocli.CommandLine$RunLast.handle(CommandLine.java:2453); at picocli.CommandLine$RunLast.handle(CommandLine.java:2415); at picocli.CommandLine$AbstractParseResultHandler.execute(CommandLine.java:2273)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1451
https://github.com/qupath/qupath/issues/1451:1392,Availability,Error,Error,1392,"ely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; `QuPath convert-ome` returns exit code 0 despite failure. **To Reproduce**; Steps to reproduce the behavior:; ```; scale=2; tile=1024; comp=ZLIB; input=broken_image.tif; output=broke_omage.ome.tif; QuPath convert-ome $input $output \; --pyramid-scale=$scale \; --tile-size=$tile \; --compression=$comp \; --parallelize; ```; Output (truncated); ```; 20:39:42.582 [main] [INFO ] q.l.i.s.b.BioFormatsServerOptions - Setting max Bio-Formats readers to 2; 20:39:43.272 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.274 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.275 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; ...; 20:39:43.604 [main] [ERROR] q.l.i.writers.ome.ConvertCommand - Unable to open file:broken_image.tif; java.io.IOException: Unable to open file:broken_image.tif; at qupath.lib.images.servers.ImageServers.buildServer(ImageServers.java:306); at qupath.lib.images.writers.ome.ConvertCommand.run(ConvertCommand.java:147); at picocli.CommandLine.executeUserObject(CommandLine.java:2026); at picocli.CommandLine.access$1500(CommandLine.java:148); at picocli.CommandLine$RunLast.executeUserObjectOfLastSubcommandWithSameParent(CommandLine.java:2461); at picocli.CommandLine$RunLast.handle(CommandLine.java:2453); at picocli.CommandLine$RunLast.handle(CommandLine.java:2415); at picocli.CommandLine$AbstractParseResultHandler.execute(CommandLine.java:2273); at picocli.CommandLine$RunLast.execute(CommandLine",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1451
https://github.com/qupath/qupath/issues/1451:1444,Availability,ERROR,ERROR,1444,ease use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; `QuPath convert-ome` returns exit code 0 despite failure. **To Reproduce**; Steps to reproduce the behavior:; ```; scale=2; tile=1024; comp=ZLIB; input=broken_image.tif; output=broke_omage.ome.tif; QuPath convert-ome $input $output \; --pyramid-scale=$scale \; --tile-size=$tile \; --compression=$comp \; --parallelize; ```; Output (truncated); ```; 20:39:42.582 [main] [INFO ] q.l.i.s.b.BioFormatsServerOptions - Setting max Bio-Formats readers to 2; 20:39:43.272 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.274 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.275 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; ...; 20:39:43.604 [main] [ERROR] q.l.i.writers.ome.ConvertCommand - Unable to open file:broken_image.tif; java.io.IOException: Unable to open file:broken_image.tif; at qupath.lib.images.servers.ImageServers.buildServer(ImageServers.java:306); at qupath.lib.images.writers.ome.ConvertCommand.run(ConvertCommand.java:147); at picocli.CommandLine.executeUserObject(CommandLine.java:2026); at picocli.CommandLine.access$1500(CommandLine.java:148); at picocli.CommandLine$RunLast.executeUserObjectOfLastSubcommandWithSameParent(CommandLine.java:2461); at picocli.CommandLine$RunLast.handle(CommandLine.java:2453); at picocli.CommandLine$RunLast.handle(CommandLine.java:2415); at picocli.CommandLine$AbstractParseResultHandler.execute(CommandLine.java:2273); at picocli.CommandLine$RunLast.execute(CommandLine.java:2417); at picocli.CommandLine.ex,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1451
https://github.com/qupath/qupath/issues/1451:1482,Availability,Error,Error,1482,ath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; `QuPath convert-ome` returns exit code 0 despite failure. **To Reproduce**; Steps to reproduce the behavior:; ```; scale=2; tile=1024; comp=ZLIB; input=broken_image.tif; output=broke_omage.ome.tif; QuPath convert-ome $input $output \; --pyramid-scale=$scale \; --tile-size=$tile \; --compression=$comp \; --parallelize; ```; Output (truncated); ```; 20:39:42.582 [main] [INFO ] q.l.i.s.b.BioFormatsServerOptions - Setting max Bio-Formats readers to 2; 20:39:43.272 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.274 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.275 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; ...; 20:39:43.604 [main] [ERROR] q.l.i.writers.ome.ConvertCommand - Unable to open file:broken_image.tif; java.io.IOException: Unable to open file:broken_image.tif; at qupath.lib.images.servers.ImageServers.buildServer(ImageServers.java:306); at qupath.lib.images.writers.ome.ConvertCommand.run(ConvertCommand.java:147); at picocli.CommandLine.executeUserObject(CommandLine.java:2026); at picocli.CommandLine.access$1500(CommandLine.java:148); at picocli.CommandLine$RunLast.executeUserObjectOfLastSubcommandWithSameParent(CommandLine.java:2461); at picocli.CommandLine$RunLast.handle(CommandLine.java:2453); at picocli.CommandLine$RunLast.handle(CommandLine.java:2415); at picocli.CommandLine$AbstractParseResultHandler.execute(CommandLine.java:2273); at picocli.CommandLine$RunLast.execute(CommandLine.java:2417); at picocli.CommandLine.execute(CommandLine.java:2170); at qupath.QuPath.main(,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1451
https://github.com/qupath/qupath/issues/1451:1534,Availability,ERROR,ERROR,1534,://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; `QuPath convert-ome` returns exit code 0 despite failure. **To Reproduce**; Steps to reproduce the behavior:; ```; scale=2; tile=1024; comp=ZLIB; input=broken_image.tif; output=broke_omage.ome.tif; QuPath convert-ome $input $output \; --pyramid-scale=$scale \; --tile-size=$tile \; --compression=$comp \; --parallelize; ```; Output (truncated); ```; 20:39:42.582 [main] [INFO ] q.l.i.s.b.BioFormatsServerOptions - Setting max Bio-Formats readers to 2; 20:39:43.272 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.274 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.275 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; ...; 20:39:43.604 [main] [ERROR] q.l.i.writers.ome.ConvertCommand - Unable to open file:broken_image.tif; java.io.IOException: Unable to open file:broken_image.tif; at qupath.lib.images.servers.ImageServers.buildServer(ImageServers.java:306); at qupath.lib.images.writers.ome.ConvertCommand.run(ConvertCommand.java:147); at picocli.CommandLine.executeUserObject(CommandLine.java:2026); at picocli.CommandLine.access$1500(CommandLine.java:148); at picocli.CommandLine$RunLast.executeUserObjectOfLastSubcommandWithSameParent(CommandLine.java:2461); at picocli.CommandLine$RunLast.handle(CommandLine.java:2453); at picocli.CommandLine$RunLast.handle(CommandLine.java:2415); at picocli.CommandLine$AbstractParseResultHandler.execute(CommandLine.java:2273); at picocli.CommandLine$RunLast.execute(CommandLine.java:2417); at picocli.CommandLine.execute(CommandLine.java:2170); at qupath.QuPath.main(QuPath.java:202); Suppressed: java.io.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1451
https://github.com/qupath/qupath/issues/1451:1572,Availability,Error,Error,1572,t already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; `QuPath convert-ome` returns exit code 0 despite failure. **To Reproduce**; Steps to reproduce the behavior:; ```; scale=2; tile=1024; comp=ZLIB; input=broken_image.tif; output=broke_omage.ome.tif; QuPath convert-ome $input $output \; --pyramid-scale=$scale \; --tile-size=$tile \; --compression=$comp \; --parallelize; ```; Output (truncated); ```; 20:39:42.582 [main] [INFO ] q.l.i.s.b.BioFormatsServerOptions - Setting max Bio-Formats readers to 2; 20:39:43.272 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.274 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.275 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; ...; 20:39:43.604 [main] [ERROR] q.l.i.writers.ome.ConvertCommand - Unable to open file:broken_image.tif; java.io.IOException: Unable to open file:broken_image.tif; at qupath.lib.images.servers.ImageServers.buildServer(ImageServers.java:306); at qupath.lib.images.writers.ome.ConvertCommand.run(ConvertCommand.java:147); at picocli.CommandLine.executeUserObject(CommandLine.java:2026); at picocli.CommandLine.access$1500(CommandLine.java:148); at picocli.CommandLine$RunLast.executeUserObjectOfLastSubcommandWithSameParent(CommandLine.java:2461); at picocli.CommandLine$RunLast.handle(CommandLine.java:2453); at picocli.CommandLine$RunLast.handle(CommandLine.java:2415); at picocli.CommandLine$AbstractParseResultHandler.execute(CommandLine.java:2273); at picocli.CommandLine$RunLast.execute(CommandLine.java:2417); at picocli.CommandLine.execute(CommandLine.java:2170); at qupath.QuPath.main(QuPath.java:202); Suppressed: java.io.IOException: Unable to build ImageServer for fil,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1451
https://github.com/qupath/qupath/issues/1451:1629,Availability,ERROR,ERROR,1629,cked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; `QuPath convert-ome` returns exit code 0 despite failure. **To Reproduce**; Steps to reproduce the behavior:; ```; scale=2; tile=1024; comp=ZLIB; input=broken_image.tif; output=broke_omage.ome.tif; QuPath convert-ome $input $output \; --pyramid-scale=$scale \; --tile-size=$tile \; --compression=$comp \; --parallelize; ```; Output (truncated); ```; 20:39:42.582 [main] [INFO ] q.l.i.s.b.BioFormatsServerOptions - Setting max Bio-Formats readers to 2; 20:39:43.272 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.274 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.275 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; ...; 20:39:43.604 [main] [ERROR] q.l.i.writers.ome.ConvertCommand - Unable to open file:broken_image.tif; java.io.IOException: Unable to open file:broken_image.tif; at qupath.lib.images.servers.ImageServers.buildServer(ImageServers.java:306); at qupath.lib.images.writers.ome.ConvertCommand.run(ConvertCommand.java:147); at picocli.CommandLine.executeUserObject(CommandLine.java:2026); at picocli.CommandLine.access$1500(CommandLine.java:148); at picocli.CommandLine$RunLast.executeUserObjectOfLastSubcommandWithSameParent(CommandLine.java:2461); at picocli.CommandLine$RunLast.handle(CommandLine.java:2453); at picocli.CommandLine$RunLast.handle(CommandLine.java:2415); at picocli.CommandLine$AbstractParseResultHandler.execute(CommandLine.java:2273); at picocli.CommandLine$RunLast.execute(CommandLine.java:2417); at picocli.CommandLine.execute(CommandLine.java:2170); at qupath.QuPath.main(QuPath.java:202); Suppressed: java.io.IOException: Unable to build ImageServer for file:/scratch/a56/jr9959/tmp/xenium-images/unassi,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1451
https://github.com/qupath/qupath/issues/1451:3165,Availability,echo,echo,3165, 2; 20:39:43.272 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.274 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.275 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; ...; 20:39:43.604 [main] [ERROR] q.l.i.writers.ome.ConvertCommand - Unable to open file:broken_image.tif; java.io.IOException: Unable to open file:broken_image.tif; at qupath.lib.images.servers.ImageServers.buildServer(ImageServers.java:306); at qupath.lib.images.writers.ome.ConvertCommand.run(ConvertCommand.java:147); at picocli.CommandLine.executeUserObject(CommandLine.java:2026); at picocli.CommandLine.access$1500(CommandLine.java:148); at picocli.CommandLine$RunLast.executeUserObjectOfLastSubcommandWithSameParent(CommandLine.java:2461); at picocli.CommandLine$RunLast.handle(CommandLine.java:2453); at picocli.CommandLine$RunLast.handle(CommandLine.java:2415); at picocli.CommandLine$AbstractParseResultHandler.execute(CommandLine.java:2273); at picocli.CommandLine$RunLast.execute(CommandLine.java:2417); at picocli.CommandLine.execute(CommandLine.java:2170); at qupath.QuPath.main(QuPath.java:202); Suppressed: java.io.IOException: Unable to build ImageServer for file:/scratch/a56/jr9959/tmp/xenium-images/unassigned/230629_Xenium_ID4369_Primary_3962_LA-Spots/230629_Xenium_ID4369_Primary_3962_LA-Spot000001.tif with requested provider qupath.imagej.images.servers.ImageJServerBuilder; at qupath.lib.images.servers.ImageServerBuilder$DefaultImageServerBuilder.buildOriginal(ImageServerBuilder.java:369); at qupath.lib.images.servers.ImageServerBuilder$AbstractServerBuilder.build(ImageServerBuilder.java:174); at qupath.lib.images.servers.ImageServers.buildServer(ImageServers.java:299); ... 10 common frames omitted; ```; Checkout exit code:; ```; echo $?; 0; ```. **Expected behavior**; Expected a non-zero return code. **Desktop (HPC):**; - OS: Rocky Linux release 8.8 (Green Obsidian); - QuPath Version: 0.5.0,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1451
https://github.com/qupath/qupath/issues/1451:564,Deployability,release,release,564,"## IMPORTANT!. This section is **only** for bug reports, which **must** follow the template below. Please post any other questions to the official QuPath forum at https://forum.image.sc/tags/qupath. If in doubt, use [image.sc](https://forum.image.sc/tags/qupath). This helps us keep things organized. ## Before we begin... Before submitting your bug report, please check the following:. * [x] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; `QuPath convert-ome` returns exit code 0 despite failure. **To Reproduce**; Steps to reproduce the behavior:; ```; scale=2; tile=1024; comp=ZLIB; input=broken_image.tif; output=broke_omage.ome.tif; QuPath convert-ome $input $output \; --pyramid-scale=$scale \; --tile-size=$tile \; --compression=$comp \; --parallelize; ```; Output (truncated); ```; 20:39:42.582 [main] [INFO ] q.l.i.s.b.BioFormatsServerOptions - Setting max Bio-Formats readers to 2; 20:39:43.272 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.274 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.275 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; ...; 20:39:43.604 [main] [ERROR] q.l.i.writers.ome.ConvertCommand - Unable to open file:broken_image.tif; java.io.IOException: Unable to open file:broken_image.tif; at qupath.lib.images.servers.ImageServers.buildServer(ImageServers.java:306); at qupath.lib.images.writers.ome.ConvertCommand.run(ConvertCommand.java:147); at picocli.CommandLine.executeUserObject(CommandLine.java:2026); at picocli.C",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1451
https://github.com/qupath/qupath/issues/1451:760,Deployability,release,release,760,"## IMPORTANT!. This section is **only** for bug reports, which **must** follow the template below. Please post any other questions to the official QuPath forum at https://forum.image.sc/tags/qupath. If in doubt, use [image.sc](https://forum.image.sc/tags/qupath). This helps us keep things organized. ## Before we begin... Before submitting your bug report, please check the following:. * [x] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; `QuPath convert-ome` returns exit code 0 despite failure. **To Reproduce**; Steps to reproduce the behavior:; ```; scale=2; tile=1024; comp=ZLIB; input=broken_image.tif; output=broke_omage.ome.tif; QuPath convert-ome $input $output \; --pyramid-scale=$scale \; --tile-size=$tile \; --compression=$comp \; --parallelize; ```; Output (truncated); ```; 20:39:42.582 [main] [INFO ] q.l.i.s.b.BioFormatsServerOptions - Setting max Bio-Formats readers to 2; 20:39:43.272 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.274 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.275 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; ...; 20:39:43.604 [main] [ERROR] q.l.i.writers.ome.ConvertCommand - Unable to open file:broken_image.tif; java.io.IOException: Unable to open file:broken_image.tif; at qupath.lib.images.servers.ImageServers.buildServer(ImageServers.java:306); at qupath.lib.images.writers.ome.ConvertCommand.run(ConvertCommand.java:147); at picocli.CommandLine.executeUserObject(CommandLine.java:2026); at picocli.C",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1451
https://github.com/qupath/qupath/issues/1451:3276,Deployability,release,release,3276, 2; 20:39:43.272 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.274 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.275 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; ...; 20:39:43.604 [main] [ERROR] q.l.i.writers.ome.ConvertCommand - Unable to open file:broken_image.tif; java.io.IOException: Unable to open file:broken_image.tif; at qupath.lib.images.servers.ImageServers.buildServer(ImageServers.java:306); at qupath.lib.images.writers.ome.ConvertCommand.run(ConvertCommand.java:147); at picocli.CommandLine.executeUserObject(CommandLine.java:2026); at picocli.CommandLine.access$1500(CommandLine.java:148); at picocli.CommandLine$RunLast.executeUserObjectOfLastSubcommandWithSameParent(CommandLine.java:2461); at picocli.CommandLine$RunLast.handle(CommandLine.java:2453); at picocli.CommandLine$RunLast.handle(CommandLine.java:2415); at picocli.CommandLine$AbstractParseResultHandler.execute(CommandLine.java:2273); at picocli.CommandLine$RunLast.execute(CommandLine.java:2417); at picocli.CommandLine.execute(CommandLine.java:2170); at qupath.QuPath.main(QuPath.java:202); Suppressed: java.io.IOException: Unable to build ImageServer for file:/scratch/a56/jr9959/tmp/xenium-images/unassigned/230629_Xenium_ID4369_Primary_3962_LA-Spots/230629_Xenium_ID4369_Primary_3962_LA-Spot000001.tif with requested provider qupath.imagej.images.servers.ImageJServerBuilder; at qupath.lib.images.servers.ImageServerBuilder$DefaultImageServerBuilder.buildOriginal(ImageServerBuilder.java:369); at qupath.lib.images.servers.ImageServerBuilder$AbstractServerBuilder.build(ImageServerBuilder.java:174); at qupath.lib.images.servers.ImageServers.buildServer(ImageServers.java:299); ... 10 common frames omitted; ```; Checkout exit code:; ```; echo $?; 0; ```. **Expected behavior**; Expected a non-zero return code. **Desktop (HPC):**; - OS: Rocky Linux release 8.8 (Green Obsidian); - QuPath Version: 0.5.0,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1451
https://github.com/qupath/qupath/issues/1451:3289,Energy Efficiency,Green,Green,3289, 2; 20:39:43.272 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.274 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.275 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; ...; 20:39:43.604 [main] [ERROR] q.l.i.writers.ome.ConvertCommand - Unable to open file:broken_image.tif; java.io.IOException: Unable to open file:broken_image.tif; at qupath.lib.images.servers.ImageServers.buildServer(ImageServers.java:306); at qupath.lib.images.writers.ome.ConvertCommand.run(ConvertCommand.java:147); at picocli.CommandLine.executeUserObject(CommandLine.java:2026); at picocli.CommandLine.access$1500(CommandLine.java:148); at picocli.CommandLine$RunLast.executeUserObjectOfLastSubcommandWithSameParent(CommandLine.java:2461); at picocli.CommandLine$RunLast.handle(CommandLine.java:2453); at picocli.CommandLine$RunLast.handle(CommandLine.java:2415); at picocli.CommandLine$AbstractParseResultHandler.execute(CommandLine.java:2273); at picocli.CommandLine$RunLast.execute(CommandLine.java:2417); at picocli.CommandLine.execute(CommandLine.java:2170); at qupath.QuPath.main(QuPath.java:202); Suppressed: java.io.IOException: Unable to build ImageServer for file:/scratch/a56/jr9959/tmp/xenium-images/unassigned/230629_Xenium_ID4369_Primary_3962_LA-Spots/230629_Xenium_ID4369_Primary_3962_LA-Spot000001.tif with requested provider qupath.imagej.images.servers.ImageJServerBuilder; at qupath.lib.images.servers.ImageServerBuilder$DefaultImageServerBuilder.buildOriginal(ImageServerBuilder.java:369); at qupath.lib.images.servers.ImageServerBuilder$AbstractServerBuilder.build(ImageServerBuilder.java:174); at qupath.lib.images.servers.ImageServers.buildServer(ImageServers.java:299); ... 10 common frames omitted; ```; Checkout exit code:; ```; echo $?; 0; ```. **Expected behavior**; Expected a non-zero return code. **Desktop (HPC):**; - OS: Rocky Linux release 8.8 (Green Obsidian); - QuPath Version: 0.5.0,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1451
https://github.com/qupath/qupath/issues/1451:2012,Security,access,access,2012,B; input=broken_image.tif; output=broke_omage.ome.tif; QuPath convert-ome $input $output \; --pyramid-scale=$scale \; --tile-size=$tile \; --compression=$comp \; --parallelize; ```; Output (truncated); ```; 20:39:42.582 [main] [INFO ] q.l.i.s.b.BioFormatsServerOptions - Setting max Bio-Formats readers to 2; 20:39:43.272 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.274 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; 20:39:43.275 [main] [ERROR] loci.formats.tiff.TiffParser - Error reading IFD type at: 14; ...; 20:39:43.604 [main] [ERROR] q.l.i.writers.ome.ConvertCommand - Unable to open file:broken_image.tif; java.io.IOException: Unable to open file:broken_image.tif; at qupath.lib.images.servers.ImageServers.buildServer(ImageServers.java:306); at qupath.lib.images.writers.ome.ConvertCommand.run(ConvertCommand.java:147); at picocli.CommandLine.executeUserObject(CommandLine.java:2026); at picocli.CommandLine.access$1500(CommandLine.java:148); at picocli.CommandLine$RunLast.executeUserObjectOfLastSubcommandWithSameParent(CommandLine.java:2461); at picocli.CommandLine$RunLast.handle(CommandLine.java:2453); at picocli.CommandLine$RunLast.handle(CommandLine.java:2415); at picocli.CommandLine$AbstractParseResultHandler.execute(CommandLine.java:2273); at picocli.CommandLine$RunLast.execute(CommandLine.java:2417); at picocli.CommandLine.execute(CommandLine.java:2170); at qupath.QuPath.main(QuPath.java:202); Suppressed: java.io.IOException: Unable to build ImageServer for file:/scratch/a56/jr9959/tmp/xenium-images/unassigned/230629_Xenium_ID4369_Primary_3962_LA-Spots/230629_Xenium_ID4369_Primary_3962_LA-Spot000001.tif with requested provider qupath.imagej.images.servers.ImageJServerBuilder; at qupath.lib.images.servers.ImageServerBuilder$DefaultImageServerBuilder.buildOriginal(ImageServerBuilder.java:369); at qupath.lib.images.servers.ImageServerBuilder$AbstractServerBuilder.build(ImageServerBuilder.java:174),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1451
https://github.com/qupath/qupath/issues/1453:1622,Safety,Risk,Risks,1622,"s is a feature proposal for consideration and discussion**_. ## Feature request. **Is your feature request related to a problem? Please describe.**; Some aspects of QuPath require having a project. This can result in the user having to create a project they don't want, just to explore some feature quickly. Then they have to delete the project folder afterwards - or have it linger, with lots of `untitled folder` polluting their desktops. **Describe the solution you'd like**; The proposal here is to *always* have a project in QuPath. If one isn't chosen by the user, QuPath behaves as if it still has a 'temporary' project, using a temp directory if needed. This temp project should automatically be deleted after QuPath is closed. **Describe alternatives you've considered**; 1. We could keep the current behavior... although it is a bit annoying.; 2. We could make it possible to create a project for the currently-open image, rather than requiring the decision to make a project to happen *before* starting any kind of analysis. **Additional context**. Advantages of the 'temp project' approach:; * It should become possible to work on multiple images (and saved pixel/object classifiers) during a quick QuPath session, without having to create a new project folder explicitly. ; * Greater consistency in QuPath's behaviour. For example, it would mean we can _always_ handle drag & drop of multiple images (noted by @lauranicolass); * The user can decide to make a temp project permanent *after* having done some work; if they choose to save their changes, the temp folder is copied to their chosen location. Risks/Disadvantages:; * It needs to be **very clear** to the user what is what is happening, due to the potential for data loss if someone thinks they have a persistent project, but really only has a temp project.; * The assumption is that we can always write a temp directory. I'm not sure if we need to handle cases where we don't write anything to disk at all.; * Added complexity.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1453
https://github.com/qupath/qupath/issues/1453:1668,Usability,clear,clear,1668,"s is a feature proposal for consideration and discussion**_. ## Feature request. **Is your feature request related to a problem? Please describe.**; Some aspects of QuPath require having a project. This can result in the user having to create a project they don't want, just to explore some feature quickly. Then they have to delete the project folder afterwards - or have it linger, with lots of `untitled folder` polluting their desktops. **Describe the solution you'd like**; The proposal here is to *always* have a project in QuPath. If one isn't chosen by the user, QuPath behaves as if it still has a 'temporary' project, using a temp directory if needed. This temp project should automatically be deleted after QuPath is closed. **Describe alternatives you've considered**; 1. We could keep the current behavior... although it is a bit annoying.; 2. We could make it possible to create a project for the currently-open image, rather than requiring the decision to make a project to happen *before* starting any kind of analysis. **Additional context**. Advantages of the 'temp project' approach:; * It should become possible to work on multiple images (and saved pixel/object classifiers) during a quick QuPath session, without having to create a new project folder explicitly. ; * Greater consistency in QuPath's behaviour. For example, it would mean we can _always_ handle drag & drop of multiple images (noted by @lauranicolass); * The user can decide to make a temp project permanent *after* having done some work; if they choose to save their changes, the temp folder is copied to their chosen location. Risks/Disadvantages:; * It needs to be **very clear** to the user what is what is happening, due to the potential for data loss if someone thinks they have a persistent project, but really only has a temp project.; * The assumption is that we can always write a temp directory. I'm not sure if we need to handle cases where we don't write anything to disk at all.; * Added complexity.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1453
https://github.com/qupath/qupath/issues/1454:65,Safety,detect,detection,65,"## Bug report. **Describe the bug**; After running QuPath's cell detection on a multichannel fluorescent image with Channel names ""Nuclei"" and ""Protein X"", the measurements; 'Nucleus: Nuclei sum` and `Nucleus: Protein X sum` are computed. However the following measurements are missing; 'Cell: Nuclei sum` and `Cell: Protein X sum`; 'Cytoplasm: Nuclei sum` and `Cytoplasm: Protein X sum`. **To Reproduce**; Steps to reproduce the behavior:; 1. Open a fluorescence image; 2. Use Cell detection with a non zero expansion; 3. Look a the resulting measurements for each cell. **Expected behavior**; All compartments should have `sum` measurement for all channels or not have it at all. **Screenshots**; ![image](https://github.com/qupath/qupath/assets/319932/9bbf5da2-b5bb-4cae-a0b1-4efa96e2ec5a); Image with cells detected and the detectiom measurements showing the columns containing `sum`; The non-`Nucleus` compartments do not have a `sum` measurement. **Desktop (please complete the following information):**; - OS: Windows 11; - QuPath Version: 0.5.0. All the best",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1454
https://github.com/qupath/qupath/issues/1454:483,Safety,detect,detection,483,"## Bug report. **Describe the bug**; After running QuPath's cell detection on a multichannel fluorescent image with Channel names ""Nuclei"" and ""Protein X"", the measurements; 'Nucleus: Nuclei sum` and `Nucleus: Protein X sum` are computed. However the following measurements are missing; 'Cell: Nuclei sum` and `Cell: Protein X sum`; 'Cytoplasm: Nuclei sum` and `Cytoplasm: Protein X sum`. **To Reproduce**; Steps to reproduce the behavior:; 1. Open a fluorescence image; 2. Use Cell detection with a non zero expansion; 3. Look a the resulting measurements for each cell. **Expected behavior**; All compartments should have `sum` measurement for all channels or not have it at all. **Screenshots**; ![image](https://github.com/qupath/qupath/assets/319932/9bbf5da2-b5bb-4cae-a0b1-4efa96e2ec5a); Image with cells detected and the detectiom measurements showing the columns containing `sum`; The non-`Nucleus` compartments do not have a `sum` measurement. **Desktop (please complete the following information):**; - OS: Windows 11; - QuPath Version: 0.5.0. All the best",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1454
https://github.com/qupath/qupath/issues/1454:811,Safety,detect,detected,811,"## Bug report. **Describe the bug**; After running QuPath's cell detection on a multichannel fluorescent image with Channel names ""Nuclei"" and ""Protein X"", the measurements; 'Nucleus: Nuclei sum` and `Nucleus: Protein X sum` are computed. However the following measurements are missing; 'Cell: Nuclei sum` and `Cell: Protein X sum`; 'Cytoplasm: Nuclei sum` and `Cytoplasm: Protein X sum`. **To Reproduce**; Steps to reproduce the behavior:; 1. Open a fluorescence image; 2. Use Cell detection with a non zero expansion; 3. Look a the resulting measurements for each cell. **Expected behavior**; All compartments should have `sum` measurement for all channels or not have it at all. **Screenshots**; ![image](https://github.com/qupath/qupath/assets/319932/9bbf5da2-b5bb-4cae-a0b1-4efa96e2ec5a); Image with cells detected and the detectiom measurements showing the columns containing `sum`; The non-`Nucleus` compartments do not have a `sum` measurement. **Desktop (please complete the following information):**; - OS: Windows 11; - QuPath Version: 0.5.0. All the best",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1454
https://github.com/qupath/qupath/issues/1454:828,Safety,detect,detectiom,828,"## Bug report. **Describe the bug**; After running QuPath's cell detection on a multichannel fluorescent image with Channel names ""Nuclei"" and ""Protein X"", the measurements; 'Nucleus: Nuclei sum` and `Nucleus: Protein X sum` are computed. However the following measurements are missing; 'Cell: Nuclei sum` and `Cell: Protein X sum`; 'Cytoplasm: Nuclei sum` and `Cytoplasm: Protein X sum`. **To Reproduce**; Steps to reproduce the behavior:; 1. Open a fluorescence image; 2. Use Cell detection with a non zero expansion; 3. Look a the resulting measurements for each cell. **Expected behavior**; All compartments should have `sum` measurement for all channels or not have it at all. **Screenshots**; ![image](https://github.com/qupath/qupath/assets/319932/9bbf5da2-b5bb-4cae-a0b1-4efa96e2ec5a); Image with cells detected and the detectiom measurements showing the columns containing `sum`; The non-`Nucleus` compartments do not have a `sum` measurement. **Desktop (please complete the following information):**; - OS: Windows 11; - QuPath Version: 0.5.0. All the best",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1454
https://github.com/qupath/qupath/pull/1455:25,Modifiability,refactor,refactor,25,See #1451. Should I also refactor the class to follow the new style guide?,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1455
https://github.com/qupath/qupath/pull/1455:68,Usability,guid,guide,68,See #1451. Should I also refactor the class to follow the new style guide?,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1455
https://github.com/qupath/qupath/issues/1458:312,Availability,avail,available-to-open-source,312,"hello friendly qupath team, i wanted to let you all know that github actions now has an apple m1 runner. this might be useful to package qupath on arm macs -- though i see that qupath already has arm releases for apple. https://github.blog/changelog/2024-01-30-github-actions-introducing-the-new-m1-macos-runner-available-to-open-source/",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1458
https://github.com/qupath/qupath/issues/1458:200,Deployability,release,releases,200,"hello friendly qupath team, i wanted to let you all know that github actions now has an apple m1 runner. this might be useful to package qupath on arm macs -- though i see that qupath already has arm releases for apple. https://github.blog/changelog/2024-01-30-github-actions-introducing-the-new-m1-macos-runner-available-to-open-source/",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1458
https://github.com/qupath/qupath/issues/1459:167,Deployability,update,update,167,"## Bug report. **Describe the bug**; When switching between images with similar channels with the Brightness/Contrast window open, the histogram doesn't automatically update as it should. Rather, the user sometimes need to select a different channel and then return to the one they wanted to look at. **To Reproduce**; Steps to reproduce the behavior:; 1. Create a project with some similar images (same channels, names); 2. Open Brightness/Contrast; 3. Open the first image, see the histogram displayed; 4. Open the second image; the histogram from the first probably still lingers. **Expected behavior**; The histogram updates when the image updates. **Desktop (please complete the following information):**; - OS: macOS (but presumably all); - QuPath Version: 0.5.0. **Additional context**; The 'Apply to similar images' setting doesn't seem to make any difference to this behavior. The issue isn't evident if the images have different channels.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1459
https://github.com/qupath/qupath/issues/1459:621,Deployability,update,updates,621,"## Bug report. **Describe the bug**; When switching between images with similar channels with the Brightness/Contrast window open, the histogram doesn't automatically update as it should. Rather, the user sometimes need to select a different channel and then return to the one they wanted to look at. **To Reproduce**; Steps to reproduce the behavior:; 1. Create a project with some similar images (same channels, names); 2. Open Brightness/Contrast; 3. Open the first image, see the histogram displayed; 4. Open the second image; the histogram from the first probably still lingers. **Expected behavior**; The histogram updates when the image updates. **Desktop (please complete the following information):**; - OS: macOS (but presumably all); - QuPath Version: 0.5.0. **Additional context**; The 'Apply to similar images' setting doesn't seem to make any difference to this behavior. The issue isn't evident if the images have different channels.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1459
https://github.com/qupath/qupath/issues/1459:644,Deployability,update,updates,644,"## Bug report. **Describe the bug**; When switching between images with similar channels with the Brightness/Contrast window open, the histogram doesn't automatically update as it should. Rather, the user sometimes need to select a different channel and then return to the one they wanted to look at. **To Reproduce**; Steps to reproduce the behavior:; 1. Create a project with some similar images (same channels, names); 2. Open Brightness/Contrast; 3. Open the first image, see the histogram displayed; 4. Open the second image; the histogram from the first probably still lingers. **Expected behavior**; The histogram updates when the image updates. **Desktop (please complete the following information):**; - OS: macOS (but presumably all); - QuPath Version: 0.5.0. **Additional context**; The 'Apply to similar images' setting doesn't seem to make any difference to this behavior. The issue isn't evident if the images have different channels.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1459
https://github.com/qupath/qupath/pull/1461:135,Safety,safe,safe,135,I removed the depth parameter when searching for extension jars (it was set at 1). This corrects the bug but I don't know if it's very safe to not have a depth at all. Maybe I should just set a higher depth (like 5)?. I also implemented a try-with-resources block because `Files.walk()` needs to be closed.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1461
https://github.com/qupath/qupath/pull/1462:915,Deployability,update,updateChannelOptions,915,"This PR attempts to fix #1459. I **replicated** the issue by:; * Creating and opening a project containing `LuCa-7color_[13860,52919]_1x1component_data.tif` (refered as `A`) and `LuCa-7color_[17572,60173]_3x3component_data.tif` (refered as `B`), two different images but with the same channels.; * Opening `A`.; * Opening the brightness & contrast dialog. The histogram of `A` is displayed.; * Opening `B` while keeping the brightness & contrast dialog open. The histogram of `A` is still displayed. **The issue** comes from the fact that in [ImageDisplay](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java), the function [setImageData()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L202) is called when an image is open in QuPath. This function calls the `updateChannelOptions()` function and then the `updateHistogramMap()` function (see [here](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L228C4-L228C24)):; * `updateChannelOptions()` updates the [channelOptions](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L504) variable. It's an ObservableValue and, because of listeners, the [BrightnessContrastHistogramPane.updateHistogram()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/gui/commands/display/BrightnessContrastHistogramPane.java#L162C17-L162C32) function is called. This is the function responsible for displaying the histogram.; * `updateHistogramMap()` updates the `histogramManager` variable. This variable is responsible for providing the histogram values. So the problem is that the function displaying the histogram can be called before the function updatin",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1462
https://github.com/qupath/qupath/pull/1462:962,Deployability,update,updateHistogramMap,962,"This PR attempts to fix #1459. I **replicated** the issue by:; * Creating and opening a project containing `LuCa-7color_[13860,52919]_1x1component_data.tif` (refered as `A`) and `LuCa-7color_[17572,60173]_3x3component_data.tif` (refered as `B`), two different images but with the same channels.; * Opening `A`.; * Opening the brightness & contrast dialog. The histogram of `A` is displayed.; * Opening `B` while keeping the brightness & contrast dialog open. The histogram of `A` is still displayed. **The issue** comes from the fact that in [ImageDisplay](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java), the function [setImageData()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L202) is called when an image is open in QuPath. This function calls the `updateChannelOptions()` function and then the `updateHistogramMap()` function (see [here](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L228C4-L228C24)):; * `updateChannelOptions()` updates the [channelOptions](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L504) variable. It's an ObservableValue and, because of listeners, the [BrightnessContrastHistogramPane.updateHistogram()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/gui/commands/display/BrightnessContrastHistogramPane.java#L162C17-L162C32) function is called. This is the function responsible for displaying the histogram.; * `updateHistogramMap()` updates the `histogramManager` variable. This variable is responsible for providing the histogram values. So the problem is that the function displaying the histogram can be called before the function updatin",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1462
https://github.com/qupath/qupath/pull/1462:1171,Deployability,update,updateChannelOptions,1171,"[17572,60173]_3x3component_data.tif` (refered as `B`), two different images but with the same channels.; * Opening `A`.; * Opening the brightness & contrast dialog. The histogram of `A` is displayed.; * Opening `B` while keeping the brightness & contrast dialog open. The histogram of `A` is still displayed. **The issue** comes from the fact that in [ImageDisplay](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java), the function [setImageData()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L202) is called when an image is open in QuPath. This function calls the `updateChannelOptions()` function and then the `updateHistogramMap()` function (see [here](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L228C4-L228C24)):; * `updateChannelOptions()` updates the [channelOptions](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L504) variable. It's an ObservableValue and, because of listeners, the [BrightnessContrastHistogramPane.updateHistogram()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/gui/commands/display/BrightnessContrastHistogramPane.java#L162C17-L162C32) function is called. This is the function responsible for displaying the histogram.; * `updateHistogramMap()` updates the `histogramManager` variable. This variable is responsible for providing the histogram values. So the problem is that the function displaying the histogram can be called before the function updating the histogram values. It is not possible to simply switch the calls of the `updateChannelOptions()` and `updateHistogramMap()` functions. **The solution** I found was to make `histogramMana",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1462
https://github.com/qupath/qupath/pull/1462:1195,Deployability,update,updates,1195,"[17572,60173]_3x3component_data.tif` (refered as `B`), two different images but with the same channels.; * Opening `A`.; * Opening the brightness & contrast dialog. The histogram of `A` is displayed.; * Opening `B` while keeping the brightness & contrast dialog open. The histogram of `A` is still displayed. **The issue** comes from the fact that in [ImageDisplay](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java), the function [setImageData()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L202) is called when an image is open in QuPath. This function calls the `updateChannelOptions()` function and then the `updateHistogramMap()` function (see [here](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L228C4-L228C24)):; * `updateChannelOptions()` updates the [channelOptions](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L504) variable. It's an ObservableValue and, because of listeners, the [BrightnessContrastHistogramPane.updateHistogram()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/gui/commands/display/BrightnessContrastHistogramPane.java#L162C17-L162C32) function is called. This is the function responsible for displaying the histogram.; * `updateHistogramMap()` updates the `histogramManager` variable. This variable is responsible for providing the histogram values. So the problem is that the function displaying the histogram can be called before the function updating the histogram values. It is not possible to simply switch the calls of the `updateChannelOptions()` and `updateHistogramMap()` functions. **The solution** I found was to make `histogramMana",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1462
https://github.com/qupath/qupath/pull/1462:1472,Deployability,update,updateHistogram,1472,"displayed. **The issue** comes from the fact that in [ImageDisplay](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java), the function [setImageData()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L202) is called when an image is open in QuPath. This function calls the `updateChannelOptions()` function and then the `updateHistogramMap()` function (see [here](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L228C4-L228C24)):; * `updateChannelOptions()` updates the [channelOptions](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L504) variable. It's an ObservableValue and, because of listeners, the [BrightnessContrastHistogramPane.updateHistogram()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/gui/commands/display/BrightnessContrastHistogramPane.java#L162C17-L162C32) function is called. This is the function responsible for displaying the histogram.; * `updateHistogramMap()` updates the `histogramManager` variable. This variable is responsible for providing the histogram values. So the problem is that the function displaying the histogram can be called before the function updating the histogram values. It is not possible to simply switch the calls of the `updateChannelOptions()` and `updateHistogramMap()` functions. **The solution** I found was to make `histogramManager` an ObservableValue. In this case, `BrightnessContrastHistogramPane.updateHistogram()` can be called each time the `histogramManager` value changes. I don't like this solution as it exposes the `histogramManager` variable (which is an implementation detail). But this was the solution requirin",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1462
https://github.com/qupath/qupath/pull/1462:1771,Deployability,update,updateHistogramMap,1771,"act that in [ImageDisplay](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java), the function [setImageData()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L202) is called when an image is open in QuPath. This function calls the `updateChannelOptions()` function and then the `updateHistogramMap()` function (see [here](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L228C4-L228C24)):; * `updateChannelOptions()` updates the [channelOptions](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L504) variable. It's an ObservableValue and, because of listeners, the [BrightnessContrastHistogramPane.updateHistogram()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/gui/commands/display/BrightnessContrastHistogramPane.java#L162C17-L162C32) function is called. This is the function responsible for displaying the histogram.; * `updateHistogramMap()` updates the `histogramManager` variable. This variable is responsible for providing the histogram values. So the problem is that the function displaying the histogram can be called before the function updating the histogram values. It is not possible to simply switch the calls of the `updateChannelOptions()` and `updateHistogramMap()` functions. **The solution** I found was to make `histogramManager` an ObservableValue. In this case, `BrightnessContrastHistogramPane.updateHistogram()` can be called each time the `histogramManager` value changes. I don't like this solution as it exposes the `histogramManager` variable (which is an implementation detail). But this was the solution requiring the less amount of refactoring I found.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1462
https://github.com/qupath/qupath/pull/1462:1793,Deployability,update,updates,1793,"act that in [ImageDisplay](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java), the function [setImageData()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L202) is called when an image is open in QuPath. This function calls the `updateChannelOptions()` function and then the `updateHistogramMap()` function (see [here](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L228C4-L228C24)):; * `updateChannelOptions()` updates the [channelOptions](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L504) variable. It's an ObservableValue and, because of listeners, the [BrightnessContrastHistogramPane.updateHistogram()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/gui/commands/display/BrightnessContrastHistogramPane.java#L162C17-L162C32) function is called. This is the function responsible for displaying the histogram.; * `updateHistogramMap()` updates the `histogramManager` variable. This variable is responsible for providing the histogram values. So the problem is that the function displaying the histogram can be called before the function updating the histogram values. It is not possible to simply switch the calls of the `updateChannelOptions()` and `updateHistogramMap()` functions. **The solution** I found was to make `histogramManager` an ObservableValue. In this case, `BrightnessContrastHistogramPane.updateHistogram()` can be called each time the `histogramManager` value changes. I don't like this solution as it exposes the `histogramManager` variable (which is an implementation detail). But this was the solution requiring the less amount of refactoring I found.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1462
https://github.com/qupath/qupath/pull/1462:2079,Deployability,update,updateChannelOptions,2079,"act that in [ImageDisplay](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java), the function [setImageData()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L202) is called when an image is open in QuPath. This function calls the `updateChannelOptions()` function and then the `updateHistogramMap()` function (see [here](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L228C4-L228C24)):; * `updateChannelOptions()` updates the [channelOptions](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L504) variable. It's an ObservableValue and, because of listeners, the [BrightnessContrastHistogramPane.updateHistogram()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/gui/commands/display/BrightnessContrastHistogramPane.java#L162C17-L162C32) function is called. This is the function responsible for displaying the histogram.; * `updateHistogramMap()` updates the `histogramManager` variable. This variable is responsible for providing the histogram values. So the problem is that the function displaying the histogram can be called before the function updating the histogram values. It is not possible to simply switch the calls of the `updateChannelOptions()` and `updateHistogramMap()` functions. **The solution** I found was to make `histogramManager` an ObservableValue. In this case, `BrightnessContrastHistogramPane.updateHistogram()` can be called each time the `histogramManager` value changes. I don't like this solution as it exposes the `histogramManager` variable (which is an implementation detail). But this was the solution requiring the less amount of refactoring I found.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1462
https://github.com/qupath/qupath/pull/1462:2108,Deployability,update,updateHistogramMap,2108,"act that in [ImageDisplay](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java), the function [setImageData()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L202) is called when an image is open in QuPath. This function calls the `updateChannelOptions()` function and then the `updateHistogramMap()` function (see [here](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L228C4-L228C24)):; * `updateChannelOptions()` updates the [channelOptions](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L504) variable. It's an ObservableValue and, because of listeners, the [BrightnessContrastHistogramPane.updateHistogram()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/gui/commands/display/BrightnessContrastHistogramPane.java#L162C17-L162C32) function is called. This is the function responsible for displaying the histogram.; * `updateHistogramMap()` updates the `histogramManager` variable. This variable is responsible for providing the histogram values. So the problem is that the function displaying the histogram can be called before the function updating the histogram values. It is not possible to simply switch the calls of the `updateChannelOptions()` and `updateHistogramMap()` functions. **The solution** I found was to make `histogramManager` an ObservableValue. In this case, `BrightnessContrastHistogramPane.updateHistogram()` can be called each time the `histogramManager` value changes. I don't like this solution as it exposes the `histogramManager` variable (which is an implementation detail). But this was the solution requiring the less amount of refactoring I found.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1462
https://github.com/qupath/qupath/pull/1462:2264,Deployability,update,updateHistogram,2264,"act that in [ImageDisplay](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java), the function [setImageData()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L202) is called when an image is open in QuPath. This function calls the `updateChannelOptions()` function and then the `updateHistogramMap()` function (see [here](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L228C4-L228C24)):; * `updateChannelOptions()` updates the [channelOptions](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L504) variable. It's an ObservableValue and, because of listeners, the [BrightnessContrastHistogramPane.updateHistogram()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/gui/commands/display/BrightnessContrastHistogramPane.java#L162C17-L162C32) function is called. This is the function responsible for displaying the histogram.; * `updateHistogramMap()` updates the `histogramManager` variable. This variable is responsible for providing the histogram values. So the problem is that the function displaying the histogram can be called before the function updating the histogram values. It is not possible to simply switch the calls of the `updateChannelOptions()` and `updateHistogramMap()` functions. **The solution** I found was to make `histogramManager` an ObservableValue. In this case, `BrightnessContrastHistogramPane.updateHistogram()` can be called each time the `histogramManager` value changes. I don't like this solution as it exposes the `histogramManager` variable (which is an implementation detail). But this was the solution requiring the less amount of refactoring I found.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1462
https://github.com/qupath/qupath/pull/1462:1374,Modifiability,variab,variable,1374,"`A` is displayed.; * Opening `B` while keeping the brightness & contrast dialog open. The histogram of `A` is still displayed. **The issue** comes from the fact that in [ImageDisplay](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java), the function [setImageData()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L202) is called when an image is open in QuPath. This function calls the `updateChannelOptions()` function and then the `updateHistogramMap()` function (see [here](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L228C4-L228C24)):; * `updateChannelOptions()` updates the [channelOptions](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L504) variable. It's an ObservableValue and, because of listeners, the [BrightnessContrastHistogramPane.updateHistogram()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/gui/commands/display/BrightnessContrastHistogramPane.java#L162C17-L162C32) function is called. This is the function responsible for displaying the histogram.; * `updateHistogramMap()` updates the `histogramManager` variable. This variable is responsible for providing the histogram values. So the problem is that the function displaying the histogram can be called before the function updating the histogram values. It is not possible to simply switch the calls of the `updateChannelOptions()` and `updateHistogramMap()` functions. **The solution** I found was to make `histogramManager` an ObservableValue. In this case, `BrightnessContrastHistogramPane.updateHistogram()` can be called each time the `histogramManager` value changes. I don't like this solution a",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1462
https://github.com/qupath/qupath/pull/1462:1824,Modifiability,variab,variable,1824,"act that in [ImageDisplay](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java), the function [setImageData()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L202) is called when an image is open in QuPath. This function calls the `updateChannelOptions()` function and then the `updateHistogramMap()` function (see [here](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L228C4-L228C24)):; * `updateChannelOptions()` updates the [channelOptions](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L504) variable. It's an ObservableValue and, because of listeners, the [BrightnessContrastHistogramPane.updateHistogram()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/gui/commands/display/BrightnessContrastHistogramPane.java#L162C17-L162C32) function is called. This is the function responsible for displaying the histogram.; * `updateHistogramMap()` updates the `histogramManager` variable. This variable is responsible for providing the histogram values. So the problem is that the function displaying the histogram can be called before the function updating the histogram values. It is not possible to simply switch the calls of the `updateChannelOptions()` and `updateHistogramMap()` functions. **The solution** I found was to make `histogramManager` an ObservableValue. In this case, `BrightnessContrastHistogramPane.updateHistogram()` can be called each time the `histogramManager` value changes. I don't like this solution as it exposes the `histogramManager` variable (which is an implementation detail). But this was the solution requiring the less amount of refactoring I found.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1462
https://github.com/qupath/qupath/pull/1462:1839,Modifiability,variab,variable,1839,"act that in [ImageDisplay](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java), the function [setImageData()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L202) is called when an image is open in QuPath. This function calls the `updateChannelOptions()` function and then the `updateHistogramMap()` function (see [here](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L228C4-L228C24)):; * `updateChannelOptions()` updates the [channelOptions](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L504) variable. It's an ObservableValue and, because of listeners, the [BrightnessContrastHistogramPane.updateHistogram()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/gui/commands/display/BrightnessContrastHistogramPane.java#L162C17-L162C32) function is called. This is the function responsible for displaying the histogram.; * `updateHistogramMap()` updates the `histogramManager` variable. This variable is responsible for providing the histogram values. So the problem is that the function displaying the histogram can be called before the function updating the histogram values. It is not possible to simply switch the calls of the `updateChannelOptions()` and `updateHistogramMap()` functions. **The solution** I found was to make `histogramManager` an ObservableValue. In this case, `BrightnessContrastHistogramPane.updateHistogram()` can be called each time the `histogramManager` value changes. I don't like this solution as it exposes the `histogramManager` variable (which is an implementation detail). But this was the solution requiring the less amount of refactoring I found.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1462
https://github.com/qupath/qupath/pull/1462:2409,Modifiability,variab,variable,2409,"act that in [ImageDisplay](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java), the function [setImageData()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L202) is called when an image is open in QuPath. This function calls the `updateChannelOptions()` function and then the `updateHistogramMap()` function (see [here](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L228C4-L228C24)):; * `updateChannelOptions()` updates the [channelOptions](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L504) variable. It's an ObservableValue and, because of listeners, the [BrightnessContrastHistogramPane.updateHistogram()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/gui/commands/display/BrightnessContrastHistogramPane.java#L162C17-L162C32) function is called. This is the function responsible for displaying the histogram.; * `updateHistogramMap()` updates the `histogramManager` variable. This variable is responsible for providing the histogram values. So the problem is that the function displaying the histogram can be called before the function updating the histogram values. It is not possible to simply switch the calls of the `updateChannelOptions()` and `updateHistogramMap()` functions. **The solution** I found was to make `histogramManager` an ObservableValue. In this case, `BrightnessContrastHistogramPane.updateHistogram()` can be called each time the `histogramManager` value changes. I don't like this solution as it exposes the `histogramManager` variable (which is an implementation detail). But this was the solution requiring the less amount of refactoring I found.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1462
https://github.com/qupath/qupath/pull/1462:2510,Modifiability,refactor,refactoring,2510,"act that in [ImageDisplay](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java), the function [setImageData()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L202) is called when an image is open in QuPath. This function calls the `updateChannelOptions()` function and then the `updateHistogramMap()` function (see [here](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L228C4-L228C24)):; * `updateChannelOptions()` updates the [channelOptions](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L504) variable. It's an ObservableValue and, because of listeners, the [BrightnessContrastHistogramPane.updateHistogram()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/gui/commands/display/BrightnessContrastHistogramPane.java#L162C17-L162C32) function is called. This is the function responsible for displaying the histogram.; * `updateHistogramMap()` updates the `histogramManager` variable. This variable is responsible for providing the histogram values. So the problem is that the function displaying the histogram can be called before the function updating the histogram values. It is not possible to simply switch the calls of the `updateChannelOptions()` and `updateHistogramMap()` functions. **The solution** I found was to make `histogramManager` an ObservableValue. In this case, `BrightnessContrastHistogramPane.updateHistogram()` can be called each time the `histogramManager` value changes. I don't like this solution as it exposes the `histogramManager` variable (which is an implementation detail). But this was the solution requiring the less amount of refactoring I found.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1462
https://github.com/qupath/qupath/pull/1462:2378,Security,expose,exposes,2378,"act that in [ImageDisplay](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java), the function [setImageData()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L202) is called when an image is open in QuPath. This function calls the `updateChannelOptions()` function and then the `updateHistogramMap()` function (see [here](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L228C4-L228C24)):; * `updateChannelOptions()` updates the [channelOptions](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L504) variable. It's an ObservableValue and, because of listeners, the [BrightnessContrastHistogramPane.updateHistogram()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/gui/commands/display/BrightnessContrastHistogramPane.java#L162C17-L162C32) function is called. This is the function responsible for displaying the histogram.; * `updateHistogramMap()` updates the `histogramManager` variable. This variable is responsible for providing the histogram values. So the problem is that the function displaying the histogram can be called before the function updating the histogram values. It is not possible to simply switch the calls of the `updateChannelOptions()` and `updateHistogramMap()` functions. **The solution** I found was to make `histogramManager` an ObservableValue. In this case, `BrightnessContrastHistogramPane.updateHistogram()` can be called each time the `histogramManager` value changes. I don't like this solution as it exposes the `histogramManager` variable (which is an implementation detail). But this was the solution requiring the less amount of refactoring I found.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1462
https://github.com/qupath/qupath/pull/1462:2047,Usability,simpl,simply,2047,"act that in [ImageDisplay](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java), the function [setImageData()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L202) is called when an image is open in QuPath. This function calls the `updateChannelOptions()` function and then the `updateHistogramMap()` function (see [here](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L228C4-L228C24)):; * `updateChannelOptions()` updates the [channelOptions](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/display/ImageDisplay.java#L504) variable. It's an ObservableValue and, because of listeners, the [BrightnessContrastHistogramPane.updateHistogram()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-gui-fx/src/main/java/qupath/lib/gui/commands/display/BrightnessContrastHistogramPane.java#L162C17-L162C32) function is called. This is the function responsible for displaying the histogram.; * `updateHistogramMap()` updates the `histogramManager` variable. This variable is responsible for providing the histogram values. So the problem is that the function displaying the histogram can be called before the function updating the histogram values. It is not possible to simply switch the calls of the `updateChannelOptions()` and `updateHistogramMap()` functions. **The solution** I found was to make `histogramManager` an ObservableValue. In this case, `BrightnessContrastHistogramPane.updateHistogram()` can be called each time the `histogramManager` value changes. I don't like this solution as it exposes the `histogramManager` variable (which is an implementation detail). But this was the solution requiring the less amount of refactoring I found.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1462
https://github.com/qupath/qupath/pull/1464:308,Availability,down,download,308,"- Adds mac arm64 build; - Only uploads javadoc from mac arm64 ; - Removes the linux stuff as RPMs weren't usable for snapshot/rc builds.; - Bumps action versions to remove some warnings. See #1460. So workflow would basically be, run the jpackage action, add info about release draft (changelog/etc), people download + test the artifacts from the draft release, when happy make a tag and publish the release",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1464
https://github.com/qupath/qupath/pull/1464:270,Deployability,release,release,270,"- Adds mac arm64 build; - Only uploads javadoc from mac arm64 ; - Removes the linux stuff as RPMs weren't usable for snapshot/rc builds.; - Bumps action versions to remove some warnings. See #1460. So workflow would basically be, run the jpackage action, add info about release draft (changelog/etc), people download + test the artifacts from the draft release, when happy make a tag and publish the release",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1464
https://github.com/qupath/qupath/pull/1464:353,Deployability,release,release,353,"- Adds mac arm64 build; - Only uploads javadoc from mac arm64 ; - Removes the linux stuff as RPMs weren't usable for snapshot/rc builds.; - Bumps action versions to remove some warnings. See #1460. So workflow would basically be, run the jpackage action, add info about release draft (changelog/etc), people download + test the artifacts from the draft release, when happy make a tag and publish the release",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1464
https://github.com/qupath/qupath/pull/1464:400,Deployability,release,release,400,"- Adds mac arm64 build; - Only uploads javadoc from mac arm64 ; - Removes the linux stuff as RPMs weren't usable for snapshot/rc builds.; - Bumps action versions to remove some warnings. See #1460. So workflow would basically be, run the jpackage action, add info about release draft (changelog/etc), people download + test the artifacts from the draft release, when happy make a tag and publish the release",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1464
https://github.com/qupath/qupath/pull/1464:319,Testability,test,test,319,"- Adds mac arm64 build; - Only uploads javadoc from mac arm64 ; - Removes the linux stuff as RPMs weren't usable for snapshot/rc builds.; - Bumps action versions to remove some warnings. See #1460. So workflow would basically be, run the jpackage action, add info about release draft (changelog/etc), people download + test the artifacts from the draft release, when happy make a tag and publish the release",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1464
https://github.com/qupath/qupath/pull/1464:106,Usability,usab,usable,106,"- Adds mac arm64 build; - Only uploads javadoc from mac arm64 ; - Removes the linux stuff as RPMs weren't usable for snapshot/rc builds.; - Bumps action versions to remove some warnings. See #1460. So workflow would basically be, run the jpackage action, add info about release draft (changelog/etc), people download + test the artifacts from the draft release, when happy make a tag and publish the release",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1464
https://github.com/qupath/qupath/pull/1465:886,Availability,error,errors,886,"When reading an **empty** region (I'm not sure of the term, see the first screenshot of #1443) from a [SparseImageServer](https://github.com/qupath/qupath/blob/main/qupath-core/src/main/java/qupath/lib/images/servers/SparseImageServer.java):; * the [SparseImageServer.readTile()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-core/src/main/java/qupath/lib/images/servers/SparseImageServer.java#L221) function returns an empty `BufferedImage`.; * but the [AbstractTileableImageServer.readRegion()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L266) (which is extended by SparseImageServer) function returns `null`. This means that calling `SparseImageServer.readRegion()` on empty regions will return `null`, which can triggers errors (see #1443). This PR makes `AbstractTileableImageServer.readRegion()` return an empty tile (instead of `null`) when `AbstractTileableImageServer.readTile()` returns an empty tile. This should fix the first issue of #1443.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1465
https://github.com/qupath/qupath/pull/1465:717,Modifiability,extend,extended,717,"When reading an **empty** region (I'm not sure of the term, see the first screenshot of #1443) from a [SparseImageServer](https://github.com/qupath/qupath/blob/main/qupath-core/src/main/java/qupath/lib/images/servers/SparseImageServer.java):; * the [SparseImageServer.readTile()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-core/src/main/java/qupath/lib/images/servers/SparseImageServer.java#L221) function returns an empty `BufferedImage`.; * but the [AbstractTileableImageServer.readRegion()](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L266) (which is extended by SparseImageServer) function returns `null`. This means that calling `SparseImageServer.readRegion()` on empty regions will return `null`, which can triggers errors (see #1443). This PR makes `AbstractTileableImageServer.readRegion()` return an empty tile (instead of `null`) when `AbstractTileableImageServer.readTile()` returns an empty tile. This should fix the first issue of #1443.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1465
https://github.com/qupath/qupath/pull/1466:60,Integrability,synchroniz,synchronized,60,Fix #1444 by making NumericMeasurementList thread-safe. The synchronized keyword was added on every public or package-private function that was reading or writing to mutable states.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1466
https://github.com/qupath/qupath/pull/1466:50,Safety,safe,safe,50,Fix #1444 by making NumericMeasurementList thread-safe. The synchronized keyword was added on every public or package-private function that was reading or writing to mutable states.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1466
https://github.com/qupath/qupath/issues/1470:263,Deployability,release,release,263,"## Before we begin... Before submitting your bug report, please check the following:. * [x] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; When using Jet (legacy), the ColorMap returns the first RGB map value for all values if max < min. Reported here first: https://forum.image.sc/t/qupath-lut-change-in-measurmernts-maps/92030/4. **To Reproduce**; Steps to reproduce the behavior:; 1. Create detections; 2. Open measurement maps; 3. Select jet color scheme; 4. Move max above min. **Expected behavior**; A clear and concise description of what you expected to happen. **Screenshots**. Regular:; ![Screenshot from 2024-02-19 12-12-14](https://github.com/qupath/qupath/assets/10779688/eadbae26-a73b-4f47-997c-51ff574fbdcc). Inverted:; ![Screenshot from 2024-02-19 12-12-22](https://github.com/qupath/qupath/assets/10779688/8571c9fa-e4ce-4971-b5fc-0bcefe2933c0). **Desktop:**. - OS: Linux (any though); - QuPath Version: [e.g. 0.5.0]. **Additional context**; PR incoming, this is just to document the behaviour",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1470
https://github.com/qupath/qupath/issues/1470:459,Deployability,release,release,459,"## Before we begin... Before submitting your bug report, please check the following:. * [x] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; When using Jet (legacy), the ColorMap returns the first RGB map value for all values if max < min. Reported here first: https://forum.image.sc/t/qupath-lut-change-in-measurmernts-maps/92030/4. **To Reproduce**; Steps to reproduce the behavior:; 1. Create detections; 2. Open measurement maps; 3. Select jet color scheme; 4. Move max above min. **Expected behavior**; A clear and concise description of what you expected to happen. **Screenshots**. Regular:; ![Screenshot from 2024-02-19 12-12-14](https://github.com/qupath/qupath/assets/10779688/eadbae26-a73b-4f47-997c-51ff574fbdcc). Inverted:; ![Screenshot from 2024-02-19 12-12-22](https://github.com/qupath/qupath/assets/10779688/8571c9fa-e4ce-4971-b5fc-0bcefe2933c0). **Desktop:**. - OS: Linux (any though); - QuPath Version: [e.g. 0.5.0]. **Additional context**; PR incoming, this is just to document the behaviour",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1470
https://github.com/qupath/qupath/issues/1470:835,Safety,detect,detections,835,"## Before we begin... Before submitting your bug report, please check the following:. * [x] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; When using Jet (legacy), the ColorMap returns the first RGB map value for all values if max < min. Reported here first: https://forum.image.sc/t/qupath-lut-change-in-measurmernts-maps/92030/4. **To Reproduce**; Steps to reproduce the behavior:; 1. Create detections; 2. Open measurement maps; 3. Select jet color scheme; 4. Move max above min. **Expected behavior**; A clear and concise description of what you expected to happen. **Screenshots**. Regular:; ![Screenshot from 2024-02-19 12-12-14](https://github.com/qupath/qupath/assets/10779688/eadbae26-a73b-4f47-997c-51ff574fbdcc). Inverted:; ![Screenshot from 2024-02-19 12-12-22](https://github.com/qupath/qupath/assets/10779688/8571c9fa-e4ce-4971-b5fc-0bcefe2933c0). **Desktop:**. - OS: Linux (any though); - QuPath Version: [e.g. 0.5.0]. **Additional context**; PR incoming, this is just to document the behaviour",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1470
https://github.com/qupath/qupath/issues/1470:949,Usability,clear,clear,949,"## Before we begin... Before submitting your bug report, please check the following:. * [x] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; When using Jet (legacy), the ColorMap returns the first RGB map value for all values if max < min. Reported here first: https://forum.image.sc/t/qupath-lut-change-in-measurmernts-maps/92030/4. **To Reproduce**; Steps to reproduce the behavior:; 1. Create detections; 2. Open measurement maps; 3. Select jet color scheme; 4. Move max above min. **Expected behavior**; A clear and concise description of what you expected to happen. **Screenshots**. Regular:; ![Screenshot from 2024-02-19 12-12-14](https://github.com/qupath/qupath/assets/10779688/eadbae26-a73b-4f47-997c-51ff574fbdcc). Inverted:; ![Screenshot from 2024-02-19 12-12-22](https://github.com/qupath/qupath/assets/10779688/8571c9fa-e4ce-4971-b5fc-0bcefe2933c0). **Desktop:**. - OS: Linux (any though); - QuPath Version: [e.g. 0.5.0]. **Additional context**; PR incoming, this is just to document the behaviour",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1470
https://github.com/qupath/qupath/issues/1472:212,Deployability,toggle,toggled,212,"## Feature request. **Is your feature request related to a problem? Please describe.**; After using the TMA dearrayer, viewing the cores within the TMA grid view wont show cores unless the ""show measurements"" is toggled on or an order is selected. . **Describe the solution you'd like**; Would be good if this additional step is removed and the cores are visible within the TMA grid view on opening. **Describe alternatives you've considered**. **Additional context**",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1472
https://github.com/qupath/qupath/issues/1473:431,Availability,error,error,431,"## Bug report. **Describe the bug**; When using the TMA grid viewer, adjusting the size of the window to smaller than the largest tile results in a break. **To Reproduce**; Steps to reproduce the behaviour:; 1. Create a TMA grid (either using dearrayer or specify TMA grid) ; 2. Open up the grid view via _Measure -> show views-> show TMA grid view_; 3. Set the tile size to large; 4. Narrow the window below the tile width; 5. An error may appear. **Expected behavior**; No error. **Screenshots**. **Desktop (please complete the following information):**; Windows v0.5.0. **Additional context**. ```; 14:54:59.317	[JavaFX Application Thread]	ERROR	qupath.lib.gui.QuPathUncaughtExceptionHandler	/ by zero	java.lang.ArithmeticException: / by zero; 	at qupath.lib.gui.commands.PathObjectGridView$QuPathGridView.layoutChildren(PathObjectGridView.java:588); 	at javafx.scene.Parent.layout(Parent.java:1208); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Scene.doLayoutPass(Scene.java:594); 	at javafx.scene.Scene$ScenePulseListener.pulse(Scene.java:2596); 	at com.sun.javafx.tk.Toolkit.lambda$runPulse$2(Toolkit.java:398); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.Toolkit.runPulse(Toolkit.java:397); 	at com.sun.javafx.tk.Toolkit.firePulse(Toolkit.java:427); 	at com.sun.javafx.tk.quantum.QuantumToolkit.pulse(QuantumToolkit.java:592); 	at com.sun.javafx.tk.quantum.PaintCollector.liveRepaintRenderJob(PaintCollector.java:327); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler$ViewEventNotification.run(GlassViewEventHandler.java:889); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler$ViewEventNotification.run(GlassViewEventHandler.java:849); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.quantum.G",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1473
https://github.com/qupath/qupath/issues/1473:475,Availability,error,error,475,"## Bug report. **Describe the bug**; When using the TMA grid viewer, adjusting the size of the window to smaller than the largest tile results in a break. **To Reproduce**; Steps to reproduce the behaviour:; 1. Create a TMA grid (either using dearrayer or specify TMA grid) ; 2. Open up the grid view via _Measure -> show views-> show TMA grid view_; 3. Set the tile size to large; 4. Narrow the window below the tile width; 5. An error may appear. **Expected behavior**; No error. **Screenshots**. **Desktop (please complete the following information):**; Windows v0.5.0. **Additional context**. ```; 14:54:59.317	[JavaFX Application Thread]	ERROR	qupath.lib.gui.QuPathUncaughtExceptionHandler	/ by zero	java.lang.ArithmeticException: / by zero; 	at qupath.lib.gui.commands.PathObjectGridView$QuPathGridView.layoutChildren(PathObjectGridView.java:588); 	at javafx.scene.Parent.layout(Parent.java:1208); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Scene.doLayoutPass(Scene.java:594); 	at javafx.scene.Scene$ScenePulseListener.pulse(Scene.java:2596); 	at com.sun.javafx.tk.Toolkit.lambda$runPulse$2(Toolkit.java:398); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.Toolkit.runPulse(Toolkit.java:397); 	at com.sun.javafx.tk.Toolkit.firePulse(Toolkit.java:427); 	at com.sun.javafx.tk.quantum.QuantumToolkit.pulse(QuantumToolkit.java:592); 	at com.sun.javafx.tk.quantum.PaintCollector.liveRepaintRenderJob(PaintCollector.java:327); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler$ViewEventNotification.run(GlassViewEventHandler.java:889); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler$ViewEventNotification.run(GlassViewEventHandler.java:849); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.quantum.G",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1473
https://github.com/qupath/qupath/issues/1473:643,Availability,ERROR,ERROR,643,"## Bug report. **Describe the bug**; When using the TMA grid viewer, adjusting the size of the window to smaller than the largest tile results in a break. **To Reproduce**; Steps to reproduce the behaviour:; 1. Create a TMA grid (either using dearrayer or specify TMA grid) ; 2. Open up the grid view via _Measure -> show views-> show TMA grid view_; 3. Set the tile size to large; 4. Narrow the window below the tile width; 5. An error may appear. **Expected behavior**; No error. **Screenshots**. **Desktop (please complete the following information):**; Windows v0.5.0. **Additional context**. ```; 14:54:59.317	[JavaFX Application Thread]	ERROR	qupath.lib.gui.QuPathUncaughtExceptionHandler	/ by zero	java.lang.ArithmeticException: / by zero; 	at qupath.lib.gui.commands.PathObjectGridView$QuPathGridView.layoutChildren(PathObjectGridView.java:588); 	at javafx.scene.Parent.layout(Parent.java:1208); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Scene.doLayoutPass(Scene.java:594); 	at javafx.scene.Scene$ScenePulseListener.pulse(Scene.java:2596); 	at com.sun.javafx.tk.Toolkit.lambda$runPulse$2(Toolkit.java:398); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.Toolkit.runPulse(Toolkit.java:397); 	at com.sun.javafx.tk.Toolkit.firePulse(Toolkit.java:427); 	at com.sun.javafx.tk.quantum.QuantumToolkit.pulse(QuantumToolkit.java:592); 	at com.sun.javafx.tk.quantum.PaintCollector.liveRepaintRenderJob(PaintCollector.java:327); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler$ViewEventNotification.run(GlassViewEventHandler.java:889); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler$ViewEventNotification.run(GlassViewEventHandler.java:849); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.quantum.G",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1473
https://github.com/qupath/qupath/issues/1473:1309,Security,secur,security,1309, -> show views-> show TMA grid view_; 3. Set the tile size to large; 4. Narrow the window below the tile width; 5. An error may appear. **Expected behavior**; No error. **Screenshots**. **Desktop (please complete the following information):**; Windows v0.5.0. **Additional context**. ```; 14:54:59.317	[JavaFX Application Thread]	ERROR	qupath.lib.gui.QuPathUncaughtExceptionHandler	/ by zero	java.lang.ArithmeticException: / by zero; 	at qupath.lib.gui.commands.PathObjectGridView$QuPathGridView.layoutChildren(PathObjectGridView.java:588); 	at javafx.scene.Parent.layout(Parent.java:1208); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Scene.doLayoutPass(Scene.java:594); 	at javafx.scene.Scene$ScenePulseListener.pulse(Scene.java:2596); 	at com.sun.javafx.tk.Toolkit.lambda$runPulse$2(Toolkit.java:398); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.Toolkit.runPulse(Toolkit.java:397); 	at com.sun.javafx.tk.Toolkit.firePulse(Toolkit.java:427); 	at com.sun.javafx.tk.quantum.QuantumToolkit.pulse(QuantumToolkit.java:592); 	at com.sun.javafx.tk.quantum.PaintCollector.liveRepaintRenderJob(PaintCollector.java:327); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler$ViewEventNotification.run(GlassViewEventHandler.java:889); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler$ViewEventNotification.run(GlassViewEventHandler.java:849); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.lambda$handleViewEvent$15(GlassViewEventHandler.java:931); 	at com.sun.javafx.tk.quantum.QuantumToolkit.runWithoutRenderLock(QuantumToolkit.java:424); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.handleViewEvent(GlassViewEventHandler.java:930); 	at com.sun.glass.ui.View.handleViewEven,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1473
https://github.com/qupath/qupath/issues/1473:1318,Security,Access,AccessController,1318,s-> show TMA grid view_; 3. Set the tile size to large; 4. Narrow the window below the tile width; 5. An error may appear. **Expected behavior**; No error. **Screenshots**. **Desktop (please complete the following information):**; Windows v0.5.0. **Additional context**. ```; 14:54:59.317	[JavaFX Application Thread]	ERROR	qupath.lib.gui.QuPathUncaughtExceptionHandler	/ by zero	java.lang.ArithmeticException: / by zero; 	at qupath.lib.gui.commands.PathObjectGridView$QuPathGridView.layoutChildren(PathObjectGridView.java:588); 	at javafx.scene.Parent.layout(Parent.java:1208); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Scene.doLayoutPass(Scene.java:594); 	at javafx.scene.Scene$ScenePulseListener.pulse(Scene.java:2596); 	at com.sun.javafx.tk.Toolkit.lambda$runPulse$2(Toolkit.java:398); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.Toolkit.runPulse(Toolkit.java:397); 	at com.sun.javafx.tk.Toolkit.firePulse(Toolkit.java:427); 	at com.sun.javafx.tk.quantum.QuantumToolkit.pulse(QuantumToolkit.java:592); 	at com.sun.javafx.tk.quantum.PaintCollector.liveRepaintRenderJob(PaintCollector.java:327); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler$ViewEventNotification.run(GlassViewEventHandler.java:889); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler$ViewEventNotification.run(GlassViewEventHandler.java:849); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.lambda$handleViewEvent$15(GlassViewEventHandler.java:931); 	at com.sun.javafx.tk.quantum.QuantumToolkit.runWithoutRenderLock(QuantumToolkit.java:424); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.handleViewEvent(GlassViewEventHandler.java:930); 	at com.sun.glass.ui.View.handleViewEvent(View.java:5,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1473
https://github.com/qupath/qupath/issues/1473:1348,Security,Access,AccessController,1348, 3. Set the tile size to large; 4. Narrow the window below the tile width; 5. An error may appear. **Expected behavior**; No error. **Screenshots**. **Desktop (please complete the following information):**; Windows v0.5.0. **Additional context**. ```; 14:54:59.317	[JavaFX Application Thread]	ERROR	qupath.lib.gui.QuPathUncaughtExceptionHandler	/ by zero	java.lang.ArithmeticException: / by zero; 	at qupath.lib.gui.commands.PathObjectGridView$QuPathGridView.layoutChildren(PathObjectGridView.java:588); 	at javafx.scene.Parent.layout(Parent.java:1208); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Scene.doLayoutPass(Scene.java:594); 	at javafx.scene.Scene$ScenePulseListener.pulse(Scene.java:2596); 	at com.sun.javafx.tk.Toolkit.lambda$runPulse$2(Toolkit.java:398); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.Toolkit.runPulse(Toolkit.java:397); 	at com.sun.javafx.tk.Toolkit.firePulse(Toolkit.java:427); 	at com.sun.javafx.tk.quantum.QuantumToolkit.pulse(QuantumToolkit.java:592); 	at com.sun.javafx.tk.quantum.PaintCollector.liveRepaintRenderJob(PaintCollector.java:327); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler$ViewEventNotification.run(GlassViewEventHandler.java:889); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler$ViewEventNotification.run(GlassViewEventHandler.java:849); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.lambda$handleViewEvent$15(GlassViewEventHandler.java:931); 	at com.sun.javafx.tk.quantum.QuantumToolkit.runWithoutRenderLock(QuantumToolkit.java:424); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.handleViewEvent(GlassViewEventHandler.java:930); 	at com.sun.glass.ui.View.handleViewEvent(View.java:535); 	at com.sun.glass.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1473
https://github.com/qupath/qupath/issues/1473:1903,Security,secur,security,1903,.lib.gui.QuPathUncaughtExceptionHandler	/ by zero	java.lang.ArithmeticException: / by zero; 	at qupath.lib.gui.commands.PathObjectGridView$QuPathGridView.layoutChildren(PathObjectGridView.java:588); 	at javafx.scene.Parent.layout(Parent.java:1208); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Scene.doLayoutPass(Scene.java:594); 	at javafx.scene.Scene$ScenePulseListener.pulse(Scene.java:2596); 	at com.sun.javafx.tk.Toolkit.lambda$runPulse$2(Toolkit.java:398); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.Toolkit.runPulse(Toolkit.java:397); 	at com.sun.javafx.tk.Toolkit.firePulse(Toolkit.java:427); 	at com.sun.javafx.tk.quantum.QuantumToolkit.pulse(QuantumToolkit.java:592); 	at com.sun.javafx.tk.quantum.PaintCollector.liveRepaintRenderJob(PaintCollector.java:327); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler$ViewEventNotification.run(GlassViewEventHandler.java:889); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler$ViewEventNotification.run(GlassViewEventHandler.java:849); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.lambda$handleViewEvent$15(GlassViewEventHandler.java:931); 	at com.sun.javafx.tk.quantum.QuantumToolkit.runWithoutRenderLock(QuantumToolkit.java:424); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.handleViewEvent(GlassViewEventHandler.java:930); 	at com.sun.glass.ui.View.handleViewEvent(View.java:535); 	at com.sun.glass.ui.View.notifyResize(View.java:875); 	at com.sun.glass.ui.win.WinView.notifyResize(WinView.java:91); 	at com.sun.glass.ui.win.WinApplication._runLoop(Native Method); 	at com.sun.glass.ui.win.WinApplication.lambda$runLoop$3(WinApplication.java:185); 	at java.base/java.lang.Thread.run(Thread.java:840); ```,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1473
https://github.com/qupath/qupath/issues/1473:1912,Security,Access,AccessController,1912,.lib.gui.QuPathUncaughtExceptionHandler	/ by zero	java.lang.ArithmeticException: / by zero; 	at qupath.lib.gui.commands.PathObjectGridView$QuPathGridView.layoutChildren(PathObjectGridView.java:588); 	at javafx.scene.Parent.layout(Parent.java:1208); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Scene.doLayoutPass(Scene.java:594); 	at javafx.scene.Scene$ScenePulseListener.pulse(Scene.java:2596); 	at com.sun.javafx.tk.Toolkit.lambda$runPulse$2(Toolkit.java:398); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.Toolkit.runPulse(Toolkit.java:397); 	at com.sun.javafx.tk.Toolkit.firePulse(Toolkit.java:427); 	at com.sun.javafx.tk.quantum.QuantumToolkit.pulse(QuantumToolkit.java:592); 	at com.sun.javafx.tk.quantum.PaintCollector.liveRepaintRenderJob(PaintCollector.java:327); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler$ViewEventNotification.run(GlassViewEventHandler.java:889); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler$ViewEventNotification.run(GlassViewEventHandler.java:849); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.lambda$handleViewEvent$15(GlassViewEventHandler.java:931); 	at com.sun.javafx.tk.quantum.QuantumToolkit.runWithoutRenderLock(QuantumToolkit.java:424); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.handleViewEvent(GlassViewEventHandler.java:930); 	at com.sun.glass.ui.View.handleViewEvent(View.java:535); 	at com.sun.glass.ui.View.notifyResize(View.java:875); 	at com.sun.glass.ui.win.WinView.notifyResize(WinView.java:91); 	at com.sun.glass.ui.win.WinApplication._runLoop(Native Method); 	at com.sun.glass.ui.win.WinApplication.lambda$runLoop$3(WinApplication.java:185); 	at java.base/java.lang.Thread.run(Thread.java:840); ```,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1473
https://github.com/qupath/qupath/issues/1473:1942,Security,Access,AccessController,1942,.lib.gui.QuPathUncaughtExceptionHandler	/ by zero	java.lang.ArithmeticException: / by zero; 	at qupath.lib.gui.commands.PathObjectGridView$QuPathGridView.layoutChildren(PathObjectGridView.java:588); 	at javafx.scene.Parent.layout(Parent.java:1208); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Parent.layout(Parent.java:1215); 	at javafx.scene.Scene.doLayoutPass(Scene.java:594); 	at javafx.scene.Scene$ScenePulseListener.pulse(Scene.java:2596); 	at com.sun.javafx.tk.Toolkit.lambda$runPulse$2(Toolkit.java:398); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.Toolkit.runPulse(Toolkit.java:397); 	at com.sun.javafx.tk.Toolkit.firePulse(Toolkit.java:427); 	at com.sun.javafx.tk.quantum.QuantumToolkit.pulse(QuantumToolkit.java:592); 	at com.sun.javafx.tk.quantum.PaintCollector.liveRepaintRenderJob(PaintCollector.java:327); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler$ViewEventNotification.run(GlassViewEventHandler.java:889); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler$ViewEventNotification.run(GlassViewEventHandler.java:849); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.lambda$handleViewEvent$15(GlassViewEventHandler.java:931); 	at com.sun.javafx.tk.quantum.QuantumToolkit.runWithoutRenderLock(QuantumToolkit.java:424); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.handleViewEvent(GlassViewEventHandler.java:930); 	at com.sun.glass.ui.View.handleViewEvent(View.java:535); 	at com.sun.glass.ui.View.notifyResize(View.java:875); 	at com.sun.glass.ui.win.WinView.notifyResize(WinView.java:91); 	at com.sun.glass.ui.win.WinApplication._runLoop(Native Method); 	at com.sun.glass.ui.win.WinApplication.lambda$runLoop$3(WinApplication.java:185); 	at java.base/java.lang.Thread.run(Thread.java:840); ```,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1473
https://github.com/qupath/qupath/pull/1475:0,Deployability,Update,Updates,0,Updates to the grid viewer to:; 1. ~~Increase default window size~~; 2. Fix [#1473](https://github.com/qupath/qupath/issues/1473) that crashes the viewer when the window width is less than the image tile width and spacing issues related to that.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1475
https://github.com/qupath/qupath/pull/1476:12,Usability,simpl,simple,12,Alternative simple approach (hack) to address https://github.com/qupath/qupath/issues/1459 based on @Rylern's detailed investigations at https://github.com/qupath/qupath/pull/1462,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1476
https://github.com/qupath/qupath/pull/1478:207,Availability,avail,available,207,Fixes https://github.com/qupath/qupath/issues/1472 Also speeds up the animations a bit (as they were quite sluggish) and sets a 'No measurements!' placeholder in the combo box when there are no measurements available.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1478
https://github.com/qupath/qupath/pull/1479:176,Availability,error,error,176,"Fixes https://github.com/qupath/qupath/issues/1469 The problem was that viewers were being added to new split panes before they were removed from old ones. This didn't give an error, but also didn't work.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1479
https://github.com/qupath/qupath/pull/1482:232,Availability,avail,availableChannels,232,"Fixes https://github.com/qupath/qupath/issues/1468. There may still be an underlying issue whenever the display is initialized with a new server. What happened was that `selectedChannels` contained one extra channel that wasn't in `availableChannels`, so this was never removed within the `updateFromJSON` method. The bonus channel had the same name/properties as the in `availableChannels`, but the object itself was different. The situation 'corrected itself' whenever the image's channels were manipulated directly, not via 'Apply to similar image' changes in a different viewer. Nevertheless, anything in the selected channels list *should* always be in the available channels list - if that was truly the case, the previous implementation would have worked.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1482
https://github.com/qupath/qupath/pull/1482:372,Availability,avail,availableChannels,372,"Fixes https://github.com/qupath/qupath/issues/1468. There may still be an underlying issue whenever the display is initialized with a new server. What happened was that `selectedChannels` contained one extra channel that wasn't in `availableChannels`, so this was never removed within the `updateFromJSON` method. The bonus channel had the same name/properties as the in `availableChannels`, but the object itself was different. The situation 'corrected itself' whenever the image's channels were manipulated directly, not via 'Apply to similar image' changes in a different viewer. Nevertheless, anything in the selected channels list *should* always be in the available channels list - if that was truly the case, the previous implementation would have worked.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1482
https://github.com/qupath/qupath/pull/1482:662,Availability,avail,available,662,"Fixes https://github.com/qupath/qupath/issues/1468. There may still be an underlying issue whenever the display is initialized with a new server. What happened was that `selectedChannels` contained one extra channel that wasn't in `availableChannels`, so this was never removed within the `updateFromJSON` method. The bonus channel had the same name/properties as the in `availableChannels`, but the object itself was different. The situation 'corrected itself' whenever the image's channels were manipulated directly, not via 'Apply to similar image' changes in a different viewer. Nevertheless, anything in the selected channels list *should* always be in the available channels list - if that was truly the case, the previous implementation would have worked.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1482
https://github.com/qupath/qupath/pull/1482:290,Deployability,update,updateFromJSON,290,"Fixes https://github.com/qupath/qupath/issues/1468. There may still be an underlying issue whenever the display is initialized with a new server. What happened was that `selectedChannels` contained one extra channel that wasn't in `availableChannels`, so this was never removed within the `updateFromJSON` method. The bonus channel had the same name/properties as the in `availableChannels`, but the object itself was different. The situation 'corrected itself' whenever the image's channels were manipulated directly, not via 'Apply to similar image' changes in a different viewer. Nevertheless, anything in the selected channels list *should* always be in the available channels list - if that was truly the case, the previous implementation would have worked.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1482
https://github.com/qupath/qupath/pull/1483:259,Performance,load,loading,259,"Aims to fix https://github.com/qupath/qupath/issues/1446. The [soft reference](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ref/SoftReference.html) should be cleared whenever memory is scarce. Otherwise, it should speed up thumbnail loading within the UI, without a requirement to introduce a separate cache within the UI code itself.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1483
https://github.com/qupath/qupath/pull/1483:328,Performance,cache,cache,328,"Aims to fix https://github.com/qupath/qupath/issues/1446. The [soft reference](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ref/SoftReference.html) should be cleared whenever memory is scarce. Otherwise, it should speed up thumbnail loading within the UI, without a requirement to introduce a separate cache within the UI code itself.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1483
https://github.com/qupath/qupath/pull/1483:184,Usability,clear,cleared,184,"Aims to fix https://github.com/qupath/qupath/issues/1446. The [soft reference](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ref/SoftReference.html) should be cleared whenever memory is scarce. Otherwise, it should speed up thumbnail loading within the UI, without a requirement to introduce a separate cache within the UI code itself.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1483
https://github.com/qupath/qupath/pull/1485:3,Availability,fault,fault,3,"My fault for [trying to write a valid tar from memory](https://xkcd.com/1168/) but the current linux build ends up as a tar.xz that contains the build/dist/QuPath directory, rather than the top level being QuPath",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1485
https://github.com/qupath/qupath/pull/1486:438,Availability,down,downloads,438,"Previously, we just assumed qupath extension releases would follow the convention `qupath-extension-[name]-[version].jar` (or similar, I can't really remember). This version uses the github API to poll for the latest release. If there's only one release, it goes with that. If there's more than one, it presents them as options in a table. Once the user has selected one, it then asks the github API about the assets of that release, and downloads the first matching one, assuming it's not a javadoc or sources jar. If there's more than one, it presents them as options to the user.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1486
https://github.com/qupath/qupath/pull/1486:45,Deployability,release,releases,45,"Previously, we just assumed qupath extension releases would follow the convention `qupath-extension-[name]-[version].jar` (or similar, I can't really remember). This version uses the github API to poll for the latest release. If there's only one release, it goes with that. If there's more than one, it presents them as options in a table. Once the user has selected one, it then asks the github API about the assets of that release, and downloads the first matching one, assuming it's not a javadoc or sources jar. If there's more than one, it presents them as options to the user.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1486
https://github.com/qupath/qupath/pull/1486:217,Deployability,release,release,217,"Previously, we just assumed qupath extension releases would follow the convention `qupath-extension-[name]-[version].jar` (or similar, I can't really remember). This version uses the github API to poll for the latest release. If there's only one release, it goes with that. If there's more than one, it presents them as options in a table. Once the user has selected one, it then asks the github API about the assets of that release, and downloads the first matching one, assuming it's not a javadoc or sources jar. If there's more than one, it presents them as options to the user.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1486
https://github.com/qupath/qupath/pull/1486:246,Deployability,release,release,246,"Previously, we just assumed qupath extension releases would follow the convention `qupath-extension-[name]-[version].jar` (or similar, I can't really remember). This version uses the github API to poll for the latest release. If there's only one release, it goes with that. If there's more than one, it presents them as options in a table. Once the user has selected one, it then asks the github API about the assets of that release, and downloads the first matching one, assuming it's not a javadoc or sources jar. If there's more than one, it presents them as options to the user.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1486
https://github.com/qupath/qupath/pull/1486:425,Deployability,release,release,425,"Previously, we just assumed qupath extension releases would follow the convention `qupath-extension-[name]-[version].jar` (or similar, I can't really remember). This version uses the github API to poll for the latest release. If there's only one release, it goes with that. If there's more than one, it presents them as options in a table. Once the user has selected one, it then asks the github API about the assets of that release, and downloads the first matching one, assuming it's not a javadoc or sources jar. If there's more than one, it presents them as options to the user.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1486
https://github.com/qupath/qupath/issues/1487:241,Deployability,release,release,241,"Before submitting your bug report, please check the following:. * [x] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; If you import objects from a file, then select an object like a rectangle and change/move it and then finally using; undo it weirdly going to delete all added objects instead of undoing the change/move. **To Reproduce**; Steps to reproduce the behavior:; 1. Loading image using `Open...`; 2. Loading objects using `Import objects from file`; 3. Double click (select) any object; 4. Move/Change the selected object, like transforming a rectangle or whatever; 5. Undoing the action. **Expected behavior**; Undoing the move/change of the object.; Instead it just deletes all objects. **Desktop (please complete the following information):**; - OS: Windows; - QuPath Version: 0.5.1",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1487
https://github.com/qupath/qupath/issues/1487:437,Deployability,release,release,437,"Before submitting your bug report, please check the following:. * [x] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; If you import objects from a file, then select an object like a rectangle and change/move it and then finally using; undo it weirdly going to delete all added objects instead of undoing the change/move. **To Reproduce**; Steps to reproduce the behavior:; 1. Loading image using `Open...`; 2. Loading objects using `Import objects from file`; 3. Double click (select) any object; 4. Move/Change the selected object, like transforming a rectangle or whatever; 5. Undoing the action. **Expected behavior**; Undoing the move/change of the object.; Instead it just deletes all objects. **Desktop (please complete the following information):**; - OS: Windows; - QuPath Version: 0.5.1",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1487
https://github.com/qupath/qupath/issues/1487:816,Performance,Load,Loading,816,"Before submitting your bug report, please check the following:. * [x] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; If you import objects from a file, then select an object like a rectangle and change/move it and then finally using; undo it weirdly going to delete all added objects instead of undoing the change/move. **To Reproduce**; Steps to reproduce the behavior:; 1. Loading image using `Open...`; 2. Loading objects using `Import objects from file`; 3. Double click (select) any object; 4. Move/Change the selected object, like transforming a rectangle or whatever; 5. Undoing the action. **Expected behavior**; Undoing the move/change of the object.; Instead it just deletes all objects. **Desktop (please complete the following information):**; - OS: Windows; - QuPath Version: 0.5.1",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1487
https://github.com/qupath/qupath/issues/1487:850,Performance,Load,Loading,850,"Before submitting your bug report, please check the following:. * [x] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; If you import objects from a file, then select an object like a rectangle and change/move it and then finally using; undo it weirdly going to delete all added objects instead of undoing the change/move. **To Reproduce**; Steps to reproduce the behavior:; 1. Loading image using `Open...`; 2. Loading objects using `Import objects from file`; 3. Double click (select) any object; 4. Move/Change the selected object, like transforming a rectangle or whatever; 5. Undoing the action. **Expected behavior**; Undoing the move/change of the object.; Instead it just deletes all objects. **Desktop (please complete the following information):**; - OS: Windows; - QuPath Version: 0.5.1",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1487
https://github.com/qupath/qupath/issues/1487:675,Usability,undo,undo,675,"Before submitting your bug report, please check the following:. * [x] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; If you import objects from a file, then select an object like a rectangle and change/move it and then finally using; undo it weirdly going to delete all added objects instead of undoing the change/move. **To Reproduce**; Steps to reproduce the behavior:; 1. Loading image using `Open...`; 2. Loading objects using `Import objects from file`; 3. Double click (select) any object; 4. Move/Change the selected object, like transforming a rectangle or whatever; 5. Undoing the action. **Expected behavior**; Undoing the move/change of the object.; Instead it just deletes all objects. **Desktop (please complete the following information):**; - OS: Windows; - QuPath Version: 0.5.1",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1487
https://github.com/qupath/qupath/issues/1487:736,Usability,undo,undoing,736,"Before submitting your bug report, please check the following:. * [x] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; If you import objects from a file, then select an object like a rectangle and change/move it and then finally using; undo it weirdly going to delete all added objects instead of undoing the change/move. **To Reproduce**; Steps to reproduce the behavior:; 1. Loading image using `Open...`; 2. Loading objects using `Import objects from file`; 3. Double click (select) any object; 4. Move/Change the selected object, like transforming a rectangle or whatever; 5. Undoing the action. **Expected behavior**; Undoing the move/change of the object.; Instead it just deletes all objects. **Desktop (please complete the following information):**; - OS: Windows; - QuPath Version: 0.5.1",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1487
https://github.com/qupath/qupath/issues/1487:1019,Usability,Undo,Undoing,1019,"Before submitting your bug report, please check the following:. * [x] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; If you import objects from a file, then select an object like a rectangle and change/move it and then finally using; undo it weirdly going to delete all added objects instead of undoing the change/move. **To Reproduce**; Steps to reproduce the behavior:; 1. Loading image using `Open...`; 2. Loading objects using `Import objects from file`; 3. Double click (select) any object; 4. Move/Change the selected object, like transforming a rectangle or whatever; 5. Undoing the action. **Expected behavior**; Undoing the move/change of the object.; Instead it just deletes all objects. **Desktop (please complete the following information):**; - OS: Windows; - QuPath Version: 0.5.1",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1487
https://github.com/qupath/qupath/issues/1487:1062,Usability,Undo,Undoing,1062,"Before submitting your bug report, please check the following:. * [x] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; If you import objects from a file, then select an object like a rectangle and change/move it and then finally using; undo it weirdly going to delete all added objects instead of undoing the change/move. **To Reproduce**; Steps to reproduce the behavior:; 1. Loading image using `Open...`; 2. Loading objects using `Import objects from file`; 3. Double click (select) any object; 4. Move/Change the selected object, like transforming a rectangle or whatever; 5. Undoing the action. **Expected behavior**; Undoing the move/change of the object.; Instead it just deletes all objects. **Desktop (please complete the following information):**; - OS: Windows; - QuPath Version: 0.5.1",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1487
https://github.com/qupath/qupath/pull/1488:954,Availability,down,downsample,954,"## WHAT; This PR improves performance when running a script that does not need to access the image files on multiple images.; Additionally, allowed to modify `ObjectClassifierCommand` too so that it can read all detections' measurements in the training set without uselessly reading the image files.; This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds.; I feel like this change is useful when a laboratory works with large projects with image locations being on a remote server. This is also possible thanks to QuPath's amazing design choice to never directly modify images.; If the scripts being run wants to access the images' pixels, it gracefully halts the execution of the all the following project entries too. _example_:; ```groovy; import qupath.imagej.tools.IJTools; import qupath.lib.images.PathImage; import ij.ImagePlus. var server = getCurrentServer(); var downsample = server.getDownsampleForResolution(Math.min(server.nResolutions()-1, 4)); PathImage<ImagePlus> pathImage = IJTools.convertToImagePlus(server, RegionRequest.createInstance(server, downsample)); ```; ""_Run for project (without saving and opening)_"":; ```; INFO: Starting script at Tue Mar 26 15:20:37 CET 2024; ERROR: The script tried to read pixels off an image while also requiring to run the script without accessing the image files.; WARN: Script cancelled with 53 image(s) remaining; INFO: Processed 54 images; INFO: Total processing time: 280 milliseconds; ```. ## HOW; Essentially this works by creating a `ImageServerStub` that extends `AbstractImageServer`. It retrieves metadata from the ProjectImageEntry itself (which in turn, i think, it gets them from the `.qpproj` file) and fails when `readRegion()` is being called. Additionally, it does not provide a server builder. This way, if the resulting image data are to be saved, the original ImageServer won't be overwritten/lost.; You can now pass a `openImage` boolean to `P",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488
https://github.com/qupath/qupath/pull/1488:1145,Availability,down,downsample,1145,"out uselessly reading the image files.; This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds.; I feel like this change is useful when a laboratory works with large projects with image locations being on a remote server. This is also possible thanks to QuPath's amazing design choice to never directly modify images.; If the scripts being run wants to access the images' pixels, it gracefully halts the execution of the all the following project entries too. _example_:; ```groovy; import qupath.imagej.tools.IJTools; import qupath.lib.images.PathImage; import ij.ImagePlus. var server = getCurrentServer(); var downsample = server.getDownsampleForResolution(Math.min(server.nResolutions()-1, 4)); PathImage<ImagePlus> pathImage = IJTools.convertToImagePlus(server, RegionRequest.createInstance(server, downsample)); ```; ""_Run for project (without saving and opening)_"":; ```; INFO: Starting script at Tue Mar 26 15:20:37 CET 2024; ERROR: The script tried to read pixels off an image while also requiring to run the script without accessing the image files.; WARN: Script cancelled with 53 image(s) remaining; INFO: Processed 54 images; INFO: Total processing time: 280 milliseconds; ```. ## HOW; Essentially this works by creating a `ImageServerStub` that extends `AbstractImageServer`. It retrieves metadata from the ProjectImageEntry itself (which in turn, i think, it gets them from the `.qpproj` file) and fails when `readRegion()` is being called. Additionally, it does not provide a server builder. This way, if the resulting image data are to be saved, the original ImageServer won't be overwritten/lost.; You can now pass a `openImage` boolean to `ProjectImageEntry.readImageData()` that, when false, just avoids getting the default image server, but just uses an instance of `ImageServerStub`. When running a `ProjectTask`, it will catch whether the script tried to access the image file. If it did, it stops",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488
https://github.com/qupath/qupath/pull/1488:1275,Availability,ERROR,ERROR,1275,"out uselessly reading the image files.; This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds.; I feel like this change is useful when a laboratory works with large projects with image locations being on a remote server. This is also possible thanks to QuPath's amazing design choice to never directly modify images.; If the scripts being run wants to access the images' pixels, it gracefully halts the execution of the all the following project entries too. _example_:; ```groovy; import qupath.imagej.tools.IJTools; import qupath.lib.images.PathImage; import ij.ImagePlus. var server = getCurrentServer(); var downsample = server.getDownsampleForResolution(Math.min(server.nResolutions()-1, 4)); PathImage<ImagePlus> pathImage = IJTools.convertToImagePlus(server, RegionRequest.createInstance(server, downsample)); ```; ""_Run for project (without saving and opening)_"":; ```; INFO: Starting script at Tue Mar 26 15:20:37 CET 2024; ERROR: The script tried to read pixels off an image while also requiring to run the script without accessing the image files.; WARN: Script cancelled with 53 image(s) remaining; INFO: Processed 54 images; INFO: Total processing time: 280 milliseconds; ```. ## HOW; Essentially this works by creating a `ImageServerStub` that extends `AbstractImageServer`. It retrieves metadata from the ProjectImageEntry itself (which in turn, i think, it gets them from the `.qpproj` file) and fails when `readRegion()` is being called. Additionally, it does not provide a server builder. This way, if the resulting image data are to be saved, the original ImageServer won't be overwritten/lost.; You can now pass a `openImage` boolean to `ProjectImageEntry.readImageData()` that, when false, just avoids getting the default image server, but just uses an instance of `ImageServerStub`. When running a `ProjectTask`, it will catch whether the script tried to access the image file. If it did, it stops",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488
https://github.com/qupath/qupath/pull/1488:1600,Modifiability,extend,extends,1600,"ible thanks to QuPath's amazing design choice to never directly modify images.; If the scripts being run wants to access the images' pixels, it gracefully halts the execution of the all the following project entries too. _example_:; ```groovy; import qupath.imagej.tools.IJTools; import qupath.lib.images.PathImage; import ij.ImagePlus. var server = getCurrentServer(); var downsample = server.getDownsampleForResolution(Math.min(server.nResolutions()-1, 4)); PathImage<ImagePlus> pathImage = IJTools.convertToImagePlus(server, RegionRequest.createInstance(server, downsample)); ```; ""_Run for project (without saving and opening)_"":; ```; INFO: Starting script at Tue Mar 26 15:20:37 CET 2024; ERROR: The script tried to read pixels off an image while also requiring to run the script without accessing the image files.; WARN: Script cancelled with 53 image(s) remaining; INFO: Processed 54 images; INFO: Total processing time: 280 milliseconds; ```. ## HOW; Essentially this works by creating a `ImageServerStub` that extends `AbstractImageServer`. It retrieves metadata from the ProjectImageEntry itself (which in turn, i think, it gets them from the `.qpproj` file) and fails when `readRegion()` is being called. Additionally, it does not provide a server builder. This way, if the resulting image data are to be saved, the original ImageServer won't be overwritten/lost.; You can now pass a `openImage` boolean to `ProjectImageEntry.readImageData()` that, when false, just avoids getting the default image server, but just uses an instance of `ImageServerStub`. When running a `ProjectTask`, it will catch whether the script tried to access the image file. If it did, it stops the execution for the current image and all the following in the queue. ### Minor proposal; Finally, i'd like to discuss whether we could initially run all scripts with `ImageServerStub` by default and, only if they fail because they need to read the image files, run them with the correct ImageServer.; This point, how",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488
https://github.com/qupath/qupath/pull/1488:26,Performance,perform,performance,26,"## WHAT; This PR improves performance when running a script that does not need to access the image files on multiple images.; Additionally, allowed to modify `ObjectClassifierCommand` too so that it can read all detections' measurements in the training set without uselessly reading the image files.; This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds.; I feel like this change is useful when a laboratory works with large projects with image locations being on a remote server. This is also possible thanks to QuPath's amazing design choice to never directly modify images.; If the scripts being run wants to access the images' pixels, it gracefully halts the execution of the all the following project entries too. _example_:; ```groovy; import qupath.imagej.tools.IJTools; import qupath.lib.images.PathImage; import ij.ImagePlus. var server = getCurrentServer(); var downsample = server.getDownsampleForResolution(Math.min(server.nResolutions()-1, 4)); PathImage<ImagePlus> pathImage = IJTools.convertToImagePlus(server, RegionRequest.createInstance(server, downsample)); ```; ""_Run for project (without saving and opening)_"":; ```; INFO: Starting script at Tue Mar 26 15:20:37 CET 2024; ERROR: The script tried to read pixels off an image while also requiring to run the script without accessing the image files.; WARN: Script cancelled with 53 image(s) remaining; INFO: Processed 54 images; INFO: Total processing time: 280 milliseconds; ```. ## HOW; Essentially this works by creating a `ImageServerStub` that extends `AbstractImageServer`. It retrieves metadata from the ProjectImageEntry itself (which in turn, i think, it gets them from the `.qpproj` file) and fails when `readRegion()` is being called. Additionally, it does not provide a server builder. This way, if the resulting image data are to be saved, the original ImageServer won't be overwritten/lost.; You can now pass a `openImage` boolean to `P",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488
https://github.com/qupath/qupath/pull/1488:2327,Performance,queue,queue,2327,"es.; If the scripts being run wants to access the images' pixels, it gracefully halts the execution of the all the following project entries too. _example_:; ```groovy; import qupath.imagej.tools.IJTools; import qupath.lib.images.PathImage; import ij.ImagePlus. var server = getCurrentServer(); var downsample = server.getDownsampleForResolution(Math.min(server.nResolutions()-1, 4)); PathImage<ImagePlus> pathImage = IJTools.convertToImagePlus(server, RegionRequest.createInstance(server, downsample)); ```; ""_Run for project (without saving and opening)_"":; ```; INFO: Starting script at Tue Mar 26 15:20:37 CET 2024; ERROR: The script tried to read pixels off an image while also requiring to run the script without accessing the image files.; WARN: Script cancelled with 53 image(s) remaining; INFO: Processed 54 images; INFO: Total processing time: 280 milliseconds; ```. ## HOW; Essentially this works by creating a `ImageServerStub` that extends `AbstractImageServer`. It retrieves metadata from the ProjectImageEntry itself (which in turn, i think, it gets them from the `.qpproj` file) and fails when `readRegion()` is being called. Additionally, it does not provide a server builder. This way, if the resulting image data are to be saved, the original ImageServer won't be overwritten/lost.; You can now pass a `openImage` boolean to `ProjectImageEntry.readImageData()` that, when false, just avoids getting the default image server, but just uses an instance of `ImageServerStub`. When running a `ProjectTask`, it will catch whether the script tried to access the image file. If it did, it stops the execution for the current image and all the following in the queue. ### Minor proposal; Finally, i'd like to discuss whether we could initially run all scripts with `ImageServerStub` by default and, only if they fail because they need to read the image files, run them with the correct ImageServer.; This point, however, is not really important and can be addressed in a future PR as well.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488
https://github.com/qupath/qupath/pull/1488:212,Safety,detect,detections,212,"## WHAT; This PR improves performance when running a script that does not need to access the image files on multiple images.; Additionally, allowed to modify `ObjectClassifierCommand` too so that it can read all detections' measurements in the training set without uselessly reading the image files.; This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds.; I feel like this change is useful when a laboratory works with large projects with image locations being on a remote server. This is also possible thanks to QuPath's amazing design choice to never directly modify images.; If the scripts being run wants to access the images' pixels, it gracefully halts the execution of the all the following project entries too. _example_:; ```groovy; import qupath.imagej.tools.IJTools; import qupath.lib.images.PathImage; import ij.ImagePlus. var server = getCurrentServer(); var downsample = server.getDownsampleForResolution(Math.min(server.nResolutions()-1, 4)); PathImage<ImagePlus> pathImage = IJTools.convertToImagePlus(server, RegionRequest.createInstance(server, downsample)); ```; ""_Run for project (without saving and opening)_"":; ```; INFO: Starting script at Tue Mar 26 15:20:37 CET 2024; ERROR: The script tried to read pixels off an image while also requiring to run the script without accessing the image files.; WARN: Script cancelled with 53 image(s) remaining; INFO: Processed 54 images; INFO: Total processing time: 280 milliseconds; ```. ## HOW; Essentially this works by creating a `ImageServerStub` that extends `AbstractImageServer`. It retrieves metadata from the ProjectImageEntry itself (which in turn, i think, it gets them from the `.qpproj` file) and fails when `readRegion()` is being called. Additionally, it does not provide a server builder. This way, if the resulting image data are to be saved, the original ImageServer won't be overwritten/lost.; You can now pass a `openImage` boolean to `P",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488
https://github.com/qupath/qupath/pull/1488:2058,Safety,avoid,avoids,2058,"es.; If the scripts being run wants to access the images' pixels, it gracefully halts the execution of the all the following project entries too. _example_:; ```groovy; import qupath.imagej.tools.IJTools; import qupath.lib.images.PathImage; import ij.ImagePlus. var server = getCurrentServer(); var downsample = server.getDownsampleForResolution(Math.min(server.nResolutions()-1, 4)); PathImage<ImagePlus> pathImage = IJTools.convertToImagePlus(server, RegionRequest.createInstance(server, downsample)); ```; ""_Run for project (without saving and opening)_"":; ```; INFO: Starting script at Tue Mar 26 15:20:37 CET 2024; ERROR: The script tried to read pixels off an image while also requiring to run the script without accessing the image files.; WARN: Script cancelled with 53 image(s) remaining; INFO: Processed 54 images; INFO: Total processing time: 280 milliseconds; ```. ## HOW; Essentially this works by creating a `ImageServerStub` that extends `AbstractImageServer`. It retrieves metadata from the ProjectImageEntry itself (which in turn, i think, it gets them from the `.qpproj` file) and fails when `readRegion()` is being called. Additionally, it does not provide a server builder. This way, if the resulting image data are to be saved, the original ImageServer won't be overwritten/lost.; You can now pass a `openImage` boolean to `ProjectImageEntry.readImageData()` that, when false, just avoids getting the default image server, but just uses an instance of `ImageServerStub`. When running a `ProjectTask`, it will catch whether the script tried to access the image file. If it did, it stops the execution for the current image and all the following in the queue. ### Minor proposal; Finally, i'd like to discuss whether we could initially run all scripts with `ImageServerStub` by default and, only if they fail because they need to read the image files, run them with the correct ImageServer.; This point, however, is not really important and can be addressed in a future PR as well.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488
https://github.com/qupath/qupath/pull/1488:82,Security,access,access,82,"## WHAT; This PR improves performance when running a script that does not need to access the image files on multiple images.; Additionally, allowed to modify `ObjectClassifierCommand` too so that it can read all detections' measurements in the training set without uselessly reading the image files.; This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds.; I feel like this change is useful when a laboratory works with large projects with image locations being on a remote server. This is also possible thanks to QuPath's amazing design choice to never directly modify images.; If the scripts being run wants to access the images' pixels, it gracefully halts the execution of the all the following project entries too. _example_:; ```groovy; import qupath.imagej.tools.IJTools; import qupath.lib.images.PathImage; import ij.ImagePlus. var server = getCurrentServer(); var downsample = server.getDownsampleForResolution(Math.min(server.nResolutions()-1, 4)); PathImage<ImagePlus> pathImage = IJTools.convertToImagePlus(server, RegionRequest.createInstance(server, downsample)); ```; ""_Run for project (without saving and opening)_"":; ```; INFO: Starting script at Tue Mar 26 15:20:37 CET 2024; ERROR: The script tried to read pixels off an image while also requiring to run the script without accessing the image files.; WARN: Script cancelled with 53 image(s) remaining; INFO: Processed 54 images; INFO: Total processing time: 280 milliseconds; ```. ## HOW; Essentially this works by creating a `ImageServerStub` that extends `AbstractImageServer`. It retrieves metadata from the ProjectImageEntry itself (which in turn, i think, it gets them from the `.qpproj` file) and fails when `readRegion()` is being called. Additionally, it does not provide a server builder. This way, if the resulting image data are to be saved, the original ImageServer won't be overwritten/lost.; You can now pass a `openImage` boolean to `P",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488
https://github.com/qupath/qupath/pull/1488:694,Security,access,access,694,"## WHAT; This PR improves performance when running a script that does not need to access the image files on multiple images.; Additionally, allowed to modify `ObjectClassifierCommand` too so that it can read all detections' measurements in the training set without uselessly reading the image files.; This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds.; I feel like this change is useful when a laboratory works with large projects with image locations being on a remote server. This is also possible thanks to QuPath's amazing design choice to never directly modify images.; If the scripts being run wants to access the images' pixels, it gracefully halts the execution of the all the following project entries too. _example_:; ```groovy; import qupath.imagej.tools.IJTools; import qupath.lib.images.PathImage; import ij.ImagePlus. var server = getCurrentServer(); var downsample = server.getDownsampleForResolution(Math.min(server.nResolutions()-1, 4)); PathImage<ImagePlus> pathImage = IJTools.convertToImagePlus(server, RegionRequest.createInstance(server, downsample)); ```; ""_Run for project (without saving and opening)_"":; ```; INFO: Starting script at Tue Mar 26 15:20:37 CET 2024; ERROR: The script tried to read pixels off an image while also requiring to run the script without accessing the image files.; WARN: Script cancelled with 53 image(s) remaining; INFO: Processed 54 images; INFO: Total processing time: 280 milliseconds; ```. ## HOW; Essentially this works by creating a `ImageServerStub` that extends `AbstractImageServer`. It retrieves metadata from the ProjectImageEntry itself (which in turn, i think, it gets them from the `.qpproj` file) and fails when `readRegion()` is being called. Additionally, it does not provide a server builder. This way, if the resulting image data are to be saved, the original ImageServer won't be overwritten/lost.; You can now pass a `openImage` boolean to `P",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488
https://github.com/qupath/qupath/pull/1488:1374,Security,access,accessing,1374,"out uselessly reading the image files.; This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds.; I feel like this change is useful when a laboratory works with large projects with image locations being on a remote server. This is also possible thanks to QuPath's amazing design choice to never directly modify images.; If the scripts being run wants to access the images' pixels, it gracefully halts the execution of the all the following project entries too. _example_:; ```groovy; import qupath.imagej.tools.IJTools; import qupath.lib.images.PathImage; import ij.ImagePlus. var server = getCurrentServer(); var downsample = server.getDownsampleForResolution(Math.min(server.nResolutions()-1, 4)); PathImage<ImagePlus> pathImage = IJTools.convertToImagePlus(server, RegionRequest.createInstance(server, downsample)); ```; ""_Run for project (without saving and opening)_"":; ```; INFO: Starting script at Tue Mar 26 15:20:37 CET 2024; ERROR: The script tried to read pixels off an image while also requiring to run the script without accessing the image files.; WARN: Script cancelled with 53 image(s) remaining; INFO: Processed 54 images; INFO: Total processing time: 280 milliseconds; ```. ## HOW; Essentially this works by creating a `ImageServerStub` that extends `AbstractImageServer`. It retrieves metadata from the ProjectImageEntry itself (which in turn, i think, it gets them from the `.qpproj` file) and fails when `readRegion()` is being called. Additionally, it does not provide a server builder. This way, if the resulting image data are to be saved, the original ImageServer won't be overwritten/lost.; You can now pass a `openImage` boolean to `ProjectImageEntry.readImageData()` that, when false, just avoids getting the default image server, but just uses an instance of `ImageServerStub`. When running a `ProjectTask`, it will catch whether the script tried to access the image file. If it did, it stops",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488
https://github.com/qupath/qupath/pull/1488:2219,Security,access,access,2219,"es.; If the scripts being run wants to access the images' pixels, it gracefully halts the execution of the all the following project entries too. _example_:; ```groovy; import qupath.imagej.tools.IJTools; import qupath.lib.images.PathImage; import ij.ImagePlus. var server = getCurrentServer(); var downsample = server.getDownsampleForResolution(Math.min(server.nResolutions()-1, 4)); PathImage<ImagePlus> pathImage = IJTools.convertToImagePlus(server, RegionRequest.createInstance(server, downsample)); ```; ""_Run for project (without saving and opening)_"":; ```; INFO: Starting script at Tue Mar 26 15:20:37 CET 2024; ERROR: The script tried to read pixels off an image while also requiring to run the script without accessing the image files.; WARN: Script cancelled with 53 image(s) remaining; INFO: Processed 54 images; INFO: Total processing time: 280 milliseconds; ```. ## HOW; Essentially this works by creating a `ImageServerStub` that extends `AbstractImageServer`. It retrieves metadata from the ProjectImageEntry itself (which in turn, i think, it gets them from the `.qpproj` file) and fails when `readRegion()` is being called. Additionally, it does not provide a server builder. This way, if the resulting image data are to be saved, the original ImageServer won't be overwritten/lost.; You can now pass a `openImage` boolean to `ProjectImageEntry.readImageData()` that, when false, just avoids getting the default image server, but just uses an instance of `ImageServerStub`. When running a `ProjectTask`, it will catch whether the script tried to access the image file. If it did, it stops the execution for the current image and all the following in the queue. ### Minor proposal; Finally, i'd like to discuss whether we could initially run all scripts with `ImageServerStub` by default and, only if they fail because they need to read the image files, run them with the correct ImageServer.; This point, however, is not really important and can be addressed in a future PR as well.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488
https://github.com/qupath/qupath/issues/1490:0,Deployability,Update,Update,0,Update log viewer version to 0.2.0-SNAPSHOT,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1490
https://github.com/qupath/qupath/issues/1490:7,Testability,log,log,7,Update log viewer version to 0.2.0-SNAPSHOT,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1490
https://github.com/qupath/qupath/issues/1491:417,Availability,error,error,417,"I am encountering an issue with the QuPath Viewer while attempting to load a .tiff image. When I click on the image to view it in the viewer, the QuPath UI hangs, and it appears that the OpenSlide library is not loading correctly. I have attempted to resolve this by installing the OpenSlide library using the package manager, but the problem persists. The logs indicate that OpenSlide is loaded successfully, yet an error is thrown stating “No OpenSlide search path supplied and failed to load OpenSlide.”. It’s worth noting that I have created a project and added the .tiff image to the project using a Groovy script. I am invoking QuPath through the command line. Note: I have successfully loaded a .tiff image in QuPath Viewer using a script without any issues on the Windows platform(openslide installed with qupath binary). However, on Linux, I encountered a problem where OpenSlide is not installed by default with QuPath binaries. Even after installing OpenSlide separately using a package manager, the issue persists. Any insights or suggestions on resolving this issue would be greatly appreciated. qupath_exe=“/opt/QuPath/bin/QuPath”; “$qupath_exe” script /usr/addImages.groovy --args “$volumeDataDir” --args “$QupathProjDir”; “$qupath_exe” -q -p “$QupathProjDir”/QuPathProject/project.qpproj. OS : Ubuntu :22.04. ![image](https://github.com/qupath/qupath/assets/6927393/5bc64744-cde9-4e11-8261-dc2c401727f4); ![image](https://github.com/qupath/qupath/assets/6927393/cad90c79-ef22-4339-8068-e50407028b6c)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1491
https://github.com/qupath/qupath/issues/1491:267,Deployability,install,installing,267,"I am encountering an issue with the QuPath Viewer while attempting to load a .tiff image. When I click on the image to view it in the viewer, the QuPath UI hangs, and it appears that the OpenSlide library is not loading correctly. I have attempted to resolve this by installing the OpenSlide library using the package manager, but the problem persists. The logs indicate that OpenSlide is loaded successfully, yet an error is thrown stating “No OpenSlide search path supplied and failed to load OpenSlide.”. It’s worth noting that I have created a project and added the .tiff image to the project using a Groovy script. I am invoking QuPath through the command line. Note: I have successfully loaded a .tiff image in QuPath Viewer using a script without any issues on the Windows platform(openslide installed with qupath binary). However, on Linux, I encountered a problem where OpenSlide is not installed by default with QuPath binaries. Even after installing OpenSlide separately using a package manager, the issue persists. Any insights or suggestions on resolving this issue would be greatly appreciated. qupath_exe=“/opt/QuPath/bin/QuPath”; “$qupath_exe” script /usr/addImages.groovy --args “$volumeDataDir” --args “$QupathProjDir”; “$qupath_exe” -q -p “$QupathProjDir”/QuPathProject/project.qpproj. OS : Ubuntu :22.04. ![image](https://github.com/qupath/qupath/assets/6927393/5bc64744-cde9-4e11-8261-dc2c401727f4); ![image](https://github.com/qupath/qupath/assets/6927393/cad90c79-ef22-4339-8068-e50407028b6c)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1491
https://github.com/qupath/qupath/issues/1491:799,Deployability,install,installed,799,"I am encountering an issue with the QuPath Viewer while attempting to load a .tiff image. When I click on the image to view it in the viewer, the QuPath UI hangs, and it appears that the OpenSlide library is not loading correctly. I have attempted to resolve this by installing the OpenSlide library using the package manager, but the problem persists. The logs indicate that OpenSlide is loaded successfully, yet an error is thrown stating “No OpenSlide search path supplied and failed to load OpenSlide.”. It’s worth noting that I have created a project and added the .tiff image to the project using a Groovy script. I am invoking QuPath through the command line. Note: I have successfully loaded a .tiff image in QuPath Viewer using a script without any issues on the Windows platform(openslide installed with qupath binary). However, on Linux, I encountered a problem where OpenSlide is not installed by default with QuPath binaries. Even after installing OpenSlide separately using a package manager, the issue persists. Any insights or suggestions on resolving this issue would be greatly appreciated. qupath_exe=“/opt/QuPath/bin/QuPath”; “$qupath_exe” script /usr/addImages.groovy --args “$volumeDataDir” --args “$QupathProjDir”; “$qupath_exe” -q -p “$QupathProjDir”/QuPathProject/project.qpproj. OS : Ubuntu :22.04. ![image](https://github.com/qupath/qupath/assets/6927393/5bc64744-cde9-4e11-8261-dc2c401727f4); ![image](https://github.com/qupath/qupath/assets/6927393/cad90c79-ef22-4339-8068-e50407028b6c)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1491
https://github.com/qupath/qupath/issues/1491:896,Deployability,install,installed,896,"I am encountering an issue with the QuPath Viewer while attempting to load a .tiff image. When I click on the image to view it in the viewer, the QuPath UI hangs, and it appears that the OpenSlide library is not loading correctly. I have attempted to resolve this by installing the OpenSlide library using the package manager, but the problem persists. The logs indicate that OpenSlide is loaded successfully, yet an error is thrown stating “No OpenSlide search path supplied and failed to load OpenSlide.”. It’s worth noting that I have created a project and added the .tiff image to the project using a Groovy script. I am invoking QuPath through the command line. Note: I have successfully loaded a .tiff image in QuPath Viewer using a script without any issues on the Windows platform(openslide installed with qupath binary). However, on Linux, I encountered a problem where OpenSlide is not installed by default with QuPath binaries. Even after installing OpenSlide separately using a package manager, the issue persists. Any insights or suggestions on resolving this issue would be greatly appreciated. qupath_exe=“/opt/QuPath/bin/QuPath”; “$qupath_exe” script /usr/addImages.groovy --args “$volumeDataDir” --args “$QupathProjDir”; “$qupath_exe” -q -p “$QupathProjDir”/QuPathProject/project.qpproj. OS : Ubuntu :22.04. ![image](https://github.com/qupath/qupath/assets/6927393/5bc64744-cde9-4e11-8261-dc2c401727f4); ![image](https://github.com/qupath/qupath/assets/6927393/cad90c79-ef22-4339-8068-e50407028b6c)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1491
https://github.com/qupath/qupath/issues/1491:950,Deployability,install,installing,950,"I am encountering an issue with the QuPath Viewer while attempting to load a .tiff image. When I click on the image to view it in the viewer, the QuPath UI hangs, and it appears that the OpenSlide library is not loading correctly. I have attempted to resolve this by installing the OpenSlide library using the package manager, but the problem persists. The logs indicate that OpenSlide is loaded successfully, yet an error is thrown stating “No OpenSlide search path supplied and failed to load OpenSlide.”. It’s worth noting that I have created a project and added the .tiff image to the project using a Groovy script. I am invoking QuPath through the command line. Note: I have successfully loaded a .tiff image in QuPath Viewer using a script without any issues on the Windows platform(openslide installed with qupath binary). However, on Linux, I encountered a problem where OpenSlide is not installed by default with QuPath binaries. Even after installing OpenSlide separately using a package manager, the issue persists. Any insights or suggestions on resolving this issue would be greatly appreciated. qupath_exe=“/opt/QuPath/bin/QuPath”; “$qupath_exe” script /usr/addImages.groovy --args “$volumeDataDir” --args “$QupathProjDir”; “$qupath_exe” -q -p “$QupathProjDir”/QuPathProject/project.qpproj. OS : Ubuntu :22.04. ![image](https://github.com/qupath/qupath/assets/6927393/5bc64744-cde9-4e11-8261-dc2c401727f4); ![image](https://github.com/qupath/qupath/assets/6927393/cad90c79-ef22-4339-8068-e50407028b6c)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1491
https://github.com/qupath/qupath/issues/1491:70,Performance,load,load,70,"I am encountering an issue with the QuPath Viewer while attempting to load a .tiff image. When I click on the image to view it in the viewer, the QuPath UI hangs, and it appears that the OpenSlide library is not loading correctly. I have attempted to resolve this by installing the OpenSlide library using the package manager, but the problem persists. The logs indicate that OpenSlide is loaded successfully, yet an error is thrown stating “No OpenSlide search path supplied and failed to load OpenSlide.”. It’s worth noting that I have created a project and added the .tiff image to the project using a Groovy script. I am invoking QuPath through the command line. Note: I have successfully loaded a .tiff image in QuPath Viewer using a script without any issues on the Windows platform(openslide installed with qupath binary). However, on Linux, I encountered a problem where OpenSlide is not installed by default with QuPath binaries. Even after installing OpenSlide separately using a package manager, the issue persists. Any insights or suggestions on resolving this issue would be greatly appreciated. qupath_exe=“/opt/QuPath/bin/QuPath”; “$qupath_exe” script /usr/addImages.groovy --args “$volumeDataDir” --args “$QupathProjDir”; “$qupath_exe” -q -p “$QupathProjDir”/QuPathProject/project.qpproj. OS : Ubuntu :22.04. ![image](https://github.com/qupath/qupath/assets/6927393/5bc64744-cde9-4e11-8261-dc2c401727f4); ![image](https://github.com/qupath/qupath/assets/6927393/cad90c79-ef22-4339-8068-e50407028b6c)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1491
https://github.com/qupath/qupath/issues/1491:212,Performance,load,loading,212,"I am encountering an issue with the QuPath Viewer while attempting to load a .tiff image. When I click on the image to view it in the viewer, the QuPath UI hangs, and it appears that the OpenSlide library is not loading correctly. I have attempted to resolve this by installing the OpenSlide library using the package manager, but the problem persists. The logs indicate that OpenSlide is loaded successfully, yet an error is thrown stating “No OpenSlide search path supplied and failed to load OpenSlide.”. It’s worth noting that I have created a project and added the .tiff image to the project using a Groovy script. I am invoking QuPath through the command line. Note: I have successfully loaded a .tiff image in QuPath Viewer using a script without any issues on the Windows platform(openslide installed with qupath binary). However, on Linux, I encountered a problem where OpenSlide is not installed by default with QuPath binaries. Even after installing OpenSlide separately using a package manager, the issue persists. Any insights or suggestions on resolving this issue would be greatly appreciated. qupath_exe=“/opt/QuPath/bin/QuPath”; “$qupath_exe” script /usr/addImages.groovy --args “$volumeDataDir” --args “$QupathProjDir”; “$qupath_exe” -q -p “$QupathProjDir”/QuPathProject/project.qpproj. OS : Ubuntu :22.04. ![image](https://github.com/qupath/qupath/assets/6927393/5bc64744-cde9-4e11-8261-dc2c401727f4); ![image](https://github.com/qupath/qupath/assets/6927393/cad90c79-ef22-4339-8068-e50407028b6c)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1491
https://github.com/qupath/qupath/issues/1491:389,Performance,load,loaded,389,"I am encountering an issue with the QuPath Viewer while attempting to load a .tiff image. When I click on the image to view it in the viewer, the QuPath UI hangs, and it appears that the OpenSlide library is not loading correctly. I have attempted to resolve this by installing the OpenSlide library using the package manager, but the problem persists. The logs indicate that OpenSlide is loaded successfully, yet an error is thrown stating “No OpenSlide search path supplied and failed to load OpenSlide.”. It’s worth noting that I have created a project and added the .tiff image to the project using a Groovy script. I am invoking QuPath through the command line. Note: I have successfully loaded a .tiff image in QuPath Viewer using a script without any issues on the Windows platform(openslide installed with qupath binary). However, on Linux, I encountered a problem where OpenSlide is not installed by default with QuPath binaries. Even after installing OpenSlide separately using a package manager, the issue persists. Any insights or suggestions on resolving this issue would be greatly appreciated. qupath_exe=“/opt/QuPath/bin/QuPath”; “$qupath_exe” script /usr/addImages.groovy --args “$volumeDataDir” --args “$QupathProjDir”; “$qupath_exe” -q -p “$QupathProjDir”/QuPathProject/project.qpproj. OS : Ubuntu :22.04. ![image](https://github.com/qupath/qupath/assets/6927393/5bc64744-cde9-4e11-8261-dc2c401727f4); ![image](https://github.com/qupath/qupath/assets/6927393/cad90c79-ef22-4339-8068-e50407028b6c)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1491
https://github.com/qupath/qupath/issues/1491:490,Performance,load,load,490,"I am encountering an issue with the QuPath Viewer while attempting to load a .tiff image. When I click on the image to view it in the viewer, the QuPath UI hangs, and it appears that the OpenSlide library is not loading correctly. I have attempted to resolve this by installing the OpenSlide library using the package manager, but the problem persists. The logs indicate that OpenSlide is loaded successfully, yet an error is thrown stating “No OpenSlide search path supplied and failed to load OpenSlide.”. It’s worth noting that I have created a project and added the .tiff image to the project using a Groovy script. I am invoking QuPath through the command line. Note: I have successfully loaded a .tiff image in QuPath Viewer using a script without any issues on the Windows platform(openslide installed with qupath binary). However, on Linux, I encountered a problem where OpenSlide is not installed by default with QuPath binaries. Even after installing OpenSlide separately using a package manager, the issue persists. Any insights or suggestions on resolving this issue would be greatly appreciated. qupath_exe=“/opt/QuPath/bin/QuPath”; “$qupath_exe” script /usr/addImages.groovy --args “$volumeDataDir” --args “$QupathProjDir”; “$qupath_exe” -q -p “$QupathProjDir”/QuPathProject/project.qpproj. OS : Ubuntu :22.04. ![image](https://github.com/qupath/qupath/assets/6927393/5bc64744-cde9-4e11-8261-dc2c401727f4); ![image](https://github.com/qupath/qupath/assets/6927393/cad90c79-ef22-4339-8068-e50407028b6c)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1491
https://github.com/qupath/qupath/issues/1491:693,Performance,load,loaded,693,"I am encountering an issue with the QuPath Viewer while attempting to load a .tiff image. When I click on the image to view it in the viewer, the QuPath UI hangs, and it appears that the OpenSlide library is not loading correctly. I have attempted to resolve this by installing the OpenSlide library using the package manager, but the problem persists. The logs indicate that OpenSlide is loaded successfully, yet an error is thrown stating “No OpenSlide search path supplied and failed to load OpenSlide.”. It’s worth noting that I have created a project and added the .tiff image to the project using a Groovy script. I am invoking QuPath through the command line. Note: I have successfully loaded a .tiff image in QuPath Viewer using a script without any issues on the Windows platform(openslide installed with qupath binary). However, on Linux, I encountered a problem where OpenSlide is not installed by default with QuPath binaries. Even after installing OpenSlide separately using a package manager, the issue persists. Any insights or suggestions on resolving this issue would be greatly appreciated. qupath_exe=“/opt/QuPath/bin/QuPath”; “$qupath_exe” script /usr/addImages.groovy --args “$volumeDataDir” --args “$QupathProjDir”; “$qupath_exe” -q -p “$QupathProjDir”/QuPathProject/project.qpproj. OS : Ubuntu :22.04. ![image](https://github.com/qupath/qupath/assets/6927393/5bc64744-cde9-4e11-8261-dc2c401727f4); ![image](https://github.com/qupath/qupath/assets/6927393/cad90c79-ef22-4339-8068-e50407028b6c)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1491
https://github.com/qupath/qupath/issues/1491:357,Testability,log,logs,357,"I am encountering an issue with the QuPath Viewer while attempting to load a .tiff image. When I click on the image to view it in the viewer, the QuPath UI hangs, and it appears that the OpenSlide library is not loading correctly. I have attempted to resolve this by installing the OpenSlide library using the package manager, but the problem persists. The logs indicate that OpenSlide is loaded successfully, yet an error is thrown stating “No OpenSlide search path supplied and failed to load OpenSlide.”. It’s worth noting that I have created a project and added the .tiff image to the project using a Groovy script. I am invoking QuPath through the command line. Note: I have successfully loaded a .tiff image in QuPath Viewer using a script without any issues on the Windows platform(openslide installed with qupath binary). However, on Linux, I encountered a problem where OpenSlide is not installed by default with QuPath binaries. Even after installing OpenSlide separately using a package manager, the issue persists. Any insights or suggestions on resolving this issue would be greatly appreciated. qupath_exe=“/opt/QuPath/bin/QuPath”; “$qupath_exe” script /usr/addImages.groovy --args “$volumeDataDir” --args “$QupathProjDir”; “$qupath_exe” -q -p “$QupathProjDir”/QuPathProject/project.qpproj. OS : Ubuntu :22.04. ![image](https://github.com/qupath/qupath/assets/6927393/5bc64744-cde9-4e11-8261-dc2c401727f4); ![image](https://github.com/qupath/qupath/assets/6927393/cad90c79-ef22-4339-8068-e50407028b6c)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1491
https://github.com/qupath/qupath/pull/1492:37,Testability,test,test,37,"Essentially the title. the following test fails on the last three assumptions. ```java; 	@Test; 	public void rectangleContains() {; 		ROI rectangle = ROIs.createRectangleROI(0,0,1,1, ImagePlane.getDefaultPlane());; 		assertTrue(rectangle.contains(.5, .5));; 		assertTrue(rectangle.contains(.9999, .9999));; 		assertFalse(rectangle.contains(1.0001, 1.0001));; 		assertTrue(rectangle.contains(0, 0));; 		assertTrue(rectangle.contains(.9999, 0));; 		assertTrue(rectangle.contains(0, .9999));; 		assertTrue(rectangle.contains(1, 0)); // FAILS; 		assertTrue(rectangle.contains(0, 1)); // FAILS; 		assertTrue(rectangle.contains(1, 1)); // FAILS; 	}; ```. This PR fixes this and adds a small test for it",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492
https://github.com/qupath/qupath/pull/1492:90,Testability,Test,Test,90,"Essentially the title. the following test fails on the last three assumptions. ```java; 	@Test; 	public void rectangleContains() {; 		ROI rectangle = ROIs.createRectangleROI(0,0,1,1, ImagePlane.getDefaultPlane());; 		assertTrue(rectangle.contains(.5, .5));; 		assertTrue(rectangle.contains(.9999, .9999));; 		assertFalse(rectangle.contains(1.0001, 1.0001));; 		assertTrue(rectangle.contains(0, 0));; 		assertTrue(rectangle.contains(.9999, 0));; 		assertTrue(rectangle.contains(0, .9999));; 		assertTrue(rectangle.contains(1, 0)); // FAILS; 		assertTrue(rectangle.contains(0, 1)); // FAILS; 		assertTrue(rectangle.contains(1, 1)); // FAILS; 	}; ```. This PR fixes this and adds a small test for it",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492
https://github.com/qupath/qupath/pull/1492:217,Testability,assert,assertTrue,217,"Essentially the title. the following test fails on the last three assumptions. ```java; 	@Test; 	public void rectangleContains() {; 		ROI rectangle = ROIs.createRectangleROI(0,0,1,1, ImagePlane.getDefaultPlane());; 		assertTrue(rectangle.contains(.5, .5));; 		assertTrue(rectangle.contains(.9999, .9999));; 		assertFalse(rectangle.contains(1.0001, 1.0001));; 		assertTrue(rectangle.contains(0, 0));; 		assertTrue(rectangle.contains(.9999, 0));; 		assertTrue(rectangle.contains(0, .9999));; 		assertTrue(rectangle.contains(1, 0)); // FAILS; 		assertTrue(rectangle.contains(0, 1)); // FAILS; 		assertTrue(rectangle.contains(1, 1)); // FAILS; 	}; ```. This PR fixes this and adds a small test for it",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492
https://github.com/qupath/qupath/pull/1492:260,Testability,assert,assertTrue,260,"Essentially the title. the following test fails on the last three assumptions. ```java; 	@Test; 	public void rectangleContains() {; 		ROI rectangle = ROIs.createRectangleROI(0,0,1,1, ImagePlane.getDefaultPlane());; 		assertTrue(rectangle.contains(.5, .5));; 		assertTrue(rectangle.contains(.9999, .9999));; 		assertFalse(rectangle.contains(1.0001, 1.0001));; 		assertTrue(rectangle.contains(0, 0));; 		assertTrue(rectangle.contains(.9999, 0));; 		assertTrue(rectangle.contains(0, .9999));; 		assertTrue(rectangle.contains(1, 0)); // FAILS; 		assertTrue(rectangle.contains(0, 1)); // FAILS; 		assertTrue(rectangle.contains(1, 1)); // FAILS; 	}; ```. This PR fixes this and adds a small test for it",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492
https://github.com/qupath/qupath/pull/1492:309,Testability,assert,assertFalse,309,"Essentially the title. the following test fails on the last three assumptions. ```java; 	@Test; 	public void rectangleContains() {; 		ROI rectangle = ROIs.createRectangleROI(0,0,1,1, ImagePlane.getDefaultPlane());; 		assertTrue(rectangle.contains(.5, .5));; 		assertTrue(rectangle.contains(.9999, .9999));; 		assertFalse(rectangle.contains(1.0001, 1.0001));; 		assertTrue(rectangle.contains(0, 0));; 		assertTrue(rectangle.contains(.9999, 0));; 		assertTrue(rectangle.contains(0, .9999));; 		assertTrue(rectangle.contains(1, 0)); // FAILS; 		assertTrue(rectangle.contains(0, 1)); // FAILS; 		assertTrue(rectangle.contains(1, 1)); // FAILS; 	}; ```. This PR fixes this and adds a small test for it",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492
https://github.com/qupath/qupath/pull/1492:361,Testability,assert,assertTrue,361,"Essentially the title. the following test fails on the last three assumptions. ```java; 	@Test; 	public void rectangleContains() {; 		ROI rectangle = ROIs.createRectangleROI(0,0,1,1, ImagePlane.getDefaultPlane());; 		assertTrue(rectangle.contains(.5, .5));; 		assertTrue(rectangle.contains(.9999, .9999));; 		assertFalse(rectangle.contains(1.0001, 1.0001));; 		assertTrue(rectangle.contains(0, 0));; 		assertTrue(rectangle.contains(.9999, 0));; 		assertTrue(rectangle.contains(0, .9999));; 		assertTrue(rectangle.contains(1, 0)); // FAILS; 		assertTrue(rectangle.contains(0, 1)); // FAILS; 		assertTrue(rectangle.contains(1, 1)); // FAILS; 	}; ```. This PR fixes this and adds a small test for it",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492
https://github.com/qupath/qupath/pull/1492:402,Testability,assert,assertTrue,402,"Essentially the title. the following test fails on the last three assumptions. ```java; 	@Test; 	public void rectangleContains() {; 		ROI rectangle = ROIs.createRectangleROI(0,0,1,1, ImagePlane.getDefaultPlane());; 		assertTrue(rectangle.contains(.5, .5));; 		assertTrue(rectangle.contains(.9999, .9999));; 		assertFalse(rectangle.contains(1.0001, 1.0001));; 		assertTrue(rectangle.contains(0, 0));; 		assertTrue(rectangle.contains(.9999, 0));; 		assertTrue(rectangle.contains(0, .9999));; 		assertTrue(rectangle.contains(1, 0)); // FAILS; 		assertTrue(rectangle.contains(0, 1)); // FAILS; 		assertTrue(rectangle.contains(1, 1)); // FAILS; 	}; ```. This PR fixes this and adds a small test for it",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492
https://github.com/qupath/qupath/pull/1492:447,Testability,assert,assertTrue,447,"Essentially the title. the following test fails on the last three assumptions. ```java; 	@Test; 	public void rectangleContains() {; 		ROI rectangle = ROIs.createRectangleROI(0,0,1,1, ImagePlane.getDefaultPlane());; 		assertTrue(rectangle.contains(.5, .5));; 		assertTrue(rectangle.contains(.9999, .9999));; 		assertFalse(rectangle.contains(1.0001, 1.0001));; 		assertTrue(rectangle.contains(0, 0));; 		assertTrue(rectangle.contains(.9999, 0));; 		assertTrue(rectangle.contains(0, .9999));; 		assertTrue(rectangle.contains(1, 0)); // FAILS; 		assertTrue(rectangle.contains(0, 1)); // FAILS; 		assertTrue(rectangle.contains(1, 1)); // FAILS; 	}; ```. This PR fixes this and adds a small test for it",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492
https://github.com/qupath/qupath/pull/1492:492,Testability,assert,assertTrue,492,"Essentially the title. the following test fails on the last three assumptions. ```java; 	@Test; 	public void rectangleContains() {; 		ROI rectangle = ROIs.createRectangleROI(0,0,1,1, ImagePlane.getDefaultPlane());; 		assertTrue(rectangle.contains(.5, .5));; 		assertTrue(rectangle.contains(.9999, .9999));; 		assertFalse(rectangle.contains(1.0001, 1.0001));; 		assertTrue(rectangle.contains(0, 0));; 		assertTrue(rectangle.contains(.9999, 0));; 		assertTrue(rectangle.contains(0, .9999));; 		assertTrue(rectangle.contains(1, 0)); // FAILS; 		assertTrue(rectangle.contains(0, 1)); // FAILS; 		assertTrue(rectangle.contains(1, 1)); // FAILS; 	}; ```. This PR fixes this and adds a small test for it",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492
https://github.com/qupath/qupath/pull/1492:542,Testability,assert,assertTrue,542,"Essentially the title. the following test fails on the last three assumptions. ```java; 	@Test; 	public void rectangleContains() {; 		ROI rectangle = ROIs.createRectangleROI(0,0,1,1, ImagePlane.getDefaultPlane());; 		assertTrue(rectangle.contains(.5, .5));; 		assertTrue(rectangle.contains(.9999, .9999));; 		assertFalse(rectangle.contains(1.0001, 1.0001));; 		assertTrue(rectangle.contains(0, 0));; 		assertTrue(rectangle.contains(.9999, 0));; 		assertTrue(rectangle.contains(0, .9999));; 		assertTrue(rectangle.contains(1, 0)); // FAILS; 		assertTrue(rectangle.contains(0, 1)); // FAILS; 		assertTrue(rectangle.contains(1, 1)); // FAILS; 	}; ```. This PR fixes this and adds a small test for it",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492
https://github.com/qupath/qupath/pull/1492:592,Testability,assert,assertTrue,592,"Essentially the title. the following test fails on the last three assumptions. ```java; 	@Test; 	public void rectangleContains() {; 		ROI rectangle = ROIs.createRectangleROI(0,0,1,1, ImagePlane.getDefaultPlane());; 		assertTrue(rectangle.contains(.5, .5));; 		assertTrue(rectangle.contains(.9999, .9999));; 		assertFalse(rectangle.contains(1.0001, 1.0001));; 		assertTrue(rectangle.contains(0, 0));; 		assertTrue(rectangle.contains(.9999, 0));; 		assertTrue(rectangle.contains(0, .9999));; 		assertTrue(rectangle.contains(1, 0)); // FAILS; 		assertTrue(rectangle.contains(0, 1)); // FAILS; 		assertTrue(rectangle.contains(1, 1)); // FAILS; 	}; ```. This PR fixes this and adds a small test for it",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492
https://github.com/qupath/qupath/pull/1492:685,Testability,test,test,685,"Essentially the title. the following test fails on the last three assumptions. ```java; 	@Test; 	public void rectangleContains() {; 		ROI rectangle = ROIs.createRectangleROI(0,0,1,1, ImagePlane.getDefaultPlane());; 		assertTrue(rectangle.contains(.5, .5));; 		assertTrue(rectangle.contains(.9999, .9999));; 		assertFalse(rectangle.contains(1.0001, 1.0001));; 		assertTrue(rectangle.contains(0, 0));; 		assertTrue(rectangle.contains(.9999, 0));; 		assertTrue(rectangle.contains(0, .9999));; 		assertTrue(rectangle.contains(1, 0)); // FAILS; 		assertTrue(rectangle.contains(0, 1)); // FAILS; 		assertTrue(rectangle.contains(1, 1)); // FAILS; 	}; ```. This PR fixes this and adds a small test for it",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492
https://github.com/qupath/qupath/issues/1494:38,Integrability,Wrap,WrappedBufferedImageServer,38,## Bug report. **Describe the bug**; `WrappedBufferedImageServer` does a dubious RGB check that can result in images wrongly being converted to 8-bit. This can be troublesome when using the `TileExporter` and selecting .ome.tif as the output file format. **To Reproduce**; Use the export script at https://forum.image.sc/t/tilesorter-saving-as-8bit-instead-of-16bit/94848/3 with a non-32-bit image (e.g. LuCa-7color) and .ome.tif as output. The export will likely be 8-bit. **Expected behavior**; The bit-depth of the original image is preserved. **Desktop (please complete the following information):**; - OS: All; - QuPath Version: v0.5.1,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1494
https://github.com/qupath/qupath/pull/1496:272,Availability,avail,available,272,"These will likely cause some problems:; * Any JavaFX from 20.0.1 onwards breaks (javascript) search links within javadocs - at least when accessing javadocs from within a .jar; * Deep Java Library has probably broken the approach previously used to test if an `Engine` is available before attempting to download it. Nevertheless, we don't want to be stuck on old dependencies - so merging early in the path towards v0.6.0 will hopefully give us time to find fixes/workarounds. This commit also updates the pref name to have the correct QuPath version.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1496
https://github.com/qupath/qupath/pull/1496:303,Availability,down,download,303,"These will likely cause some problems:; * Any JavaFX from 20.0.1 onwards breaks (javascript) search links within javadocs - at least when accessing javadocs from within a .jar; * Deep Java Library has probably broken the approach previously used to test if an `Engine` is available before attempting to download it. Nevertheless, we don't want to be stuck on old dependencies - so merging early in the path towards v0.6.0 will hopefully give us time to find fixes/workarounds. This commit also updates the pref name to have the correct QuPath version.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1496
https://github.com/qupath/qupath/pull/1496:494,Deployability,update,updates,494,"These will likely cause some problems:; * Any JavaFX from 20.0.1 onwards breaks (javascript) search links within javadocs - at least when accessing javadocs from within a .jar; * Deep Java Library has probably broken the approach previously used to test if an `Engine` is available before attempting to download it. Nevertheless, we don't want to be stuck on old dependencies - so merging early in the path towards v0.6.0 will hopefully give us time to find fixes/workarounds. This commit also updates the pref name to have the correct QuPath version.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1496
https://github.com/qupath/qupath/pull/1496:363,Integrability,depend,dependencies,363,"These will likely cause some problems:; * Any JavaFX from 20.0.1 onwards breaks (javascript) search links within javadocs - at least when accessing javadocs from within a .jar; * Deep Java Library has probably broken the approach previously used to test if an `Engine` is available before attempting to download it. Nevertheless, we don't want to be stuck on old dependencies - so merging early in the path towards v0.6.0 will hopefully give us time to find fixes/workarounds. This commit also updates the pref name to have the correct QuPath version.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1496
https://github.com/qupath/qupath/pull/1496:138,Security,access,accessing,138,"These will likely cause some problems:; * Any JavaFX from 20.0.1 onwards breaks (javascript) search links within javadocs - at least when accessing javadocs from within a .jar; * Deep Java Library has probably broken the approach previously used to test if an `Engine` is available before attempting to download it. Nevertheless, we don't want to be stuck on old dependencies - so merging early in the path towards v0.6.0 will hopefully give us time to find fixes/workarounds. This commit also updates the pref name to have the correct QuPath version.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1496
https://github.com/qupath/qupath/pull/1496:249,Testability,test,test,249,"These will likely cause some problems:; * Any JavaFX from 20.0.1 onwards breaks (javascript) search links within javadocs - at least when accessing javadocs from within a .jar; * Deep Java Library has probably broken the approach previously used to test if an `Engine` is available before attempting to download it. Nevertheless, we don't want to be stuck on old dependencies - so merging early in the path towards v0.6.0 will hopefully give us time to find fixes/workarounds. This commit also updates the pref name to have the correct QuPath version.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1496
https://github.com/qupath/qupath/issues/1497:322,Deployability,release,release-notes,322,"See https://github.com/qupath/qupath/pull/1496 and https://github.com/qupath/qupath/issues/1358. The workaround in v0.5 was to revert to JavaFX 20, but we don't want to be stuck indefinitely on an out-of-date version. There have been many fixes and improvements, e.g. see; * https://gluonhq.com/products/javafx/openjfx-22-release-notes/; * https://gluonhq.com/products/javafx/openjfx-21-release-notes/. So we need to try to figure out a fix - or document the limitation - for v0.6.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1497
https://github.com/qupath/qupath/issues/1497:387,Deployability,release,release-notes,387,"See https://github.com/qupath/qupath/pull/1496 and https://github.com/qupath/qupath/issues/1358. The workaround in v0.5 was to revert to JavaFX 20, but we don't want to be stuck indefinitely on an out-of-date version. There have been many fixes and improvements, e.g. see; * https://gluonhq.com/products/javafx/openjfx-22-release-notes/; * https://gluonhq.com/products/javafx/openjfx-21-release-notes/. So we need to try to figure out a fix - or document the limitation - for v0.6.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1497
https://github.com/qupath/qupath/issues/1498:66,Availability,down,down,66,"## Bug report. **Describe the bug**; When right clicking the drop down box to toggle channel selection for pixel classifier (see below), the channel options and the intended options show at the same time causing overlap. Note: using a macbook and a trackpad. . **To Reproduce**; Steps to reproduce the behavior:; 1. Go to ""train pixel classifier""; 2. Click on ""edit"" next to ""features""; 3. Right click on channels ; 4. Both the channels and the Select all/none options appear; <img width=""820"" alt=""image"" src=""https://github.com/qupath/qupath/assets/42358257/dd15195c-ebfb-4118-948a-202b7c2ff5b2"">. **Expected behavior**; <img width=""824"" alt=""image"" src=""https://github.com/qupath/qupath/assets/42358257/3d10e366-524c-42cb-a438-8741abeb7434"">. **Screenshots**. **Desktop (please complete the following information):**; - OS: macOS; - QuPath Version: 0.5.1. **Additional context** ; Unsure if it's specific to mac and/or the trackpad",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1498
https://github.com/qupath/qupath/issues/1498:78,Deployability,toggle,toggle,78,"## Bug report. **Describe the bug**; When right clicking the drop down box to toggle channel selection for pixel classifier (see below), the channel options and the intended options show at the same time causing overlap. Note: using a macbook and a trackpad. . **To Reproduce**; Steps to reproduce the behavior:; 1. Go to ""train pixel classifier""; 2. Click on ""edit"" next to ""features""; 3. Right click on channels ; 4. Both the channels and the Select all/none options appear; <img width=""820"" alt=""image"" src=""https://github.com/qupath/qupath/assets/42358257/dd15195c-ebfb-4118-948a-202b7c2ff5b2"">. **Expected behavior**; <img width=""824"" alt=""image"" src=""https://github.com/qupath/qupath/assets/42358257/3d10e366-524c-42cb-a438-8741abeb7434"">. **Screenshots**. **Desktop (please complete the following information):**; - OS: macOS; - QuPath Version: 0.5.1. **Additional context** ; Unsure if it's specific to mac and/or the trackpad",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1498
https://github.com/qupath/qupath/issues/1501:90,Safety,detect,detections,90,"Since it seems (from what I can tell) that all the commands within this menu work only on detections and not annotations, the submenu should be called Detection classification, so as not to give the impression that they work on annotations.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501
https://github.com/qupath/qupath/issues/1501:151,Safety,Detect,Detection,151,"Since it seems (from what I can tell) that all the commands within this menu work only on detections and not annotations, the submenu should be called Detection classification, so as not to give the impression that they work on annotations.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501
https://github.com/qupath/qupath/pull/1502:260,Availability,mask,mask,260,"Simple merger that checks if IoU is higher than the given threshold. I also implemented an OutputHandler that does something like this:. 1. create objects within the regionRequest; 2. remove any objects within N pixels of the boundary of the regionRequest; 3. mask objects based on the parent annotation (not the proxy/tile, as is usually done). Since these are probably useful together, should I add this OutputHandler to this PR?",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1502
https://github.com/qupath/qupath/pull/1502:0,Usability,Simpl,Simple,0,"Simple merger that checks if IoU is higher than the given threshold. I also implemented an OutputHandler that does something like this:. 1. create objects within the regionRequest; 2. remove any objects within N pixels of the boundary of the regionRequest; 3. mask objects based on the parent annotation (not the proxy/tile, as is usually done). Since these are probably useful together, should I add this OutputHandler to this PR?",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1502
https://github.com/qupath/qupath/pull/1504:11,Testability,test,tests,11,"When merge tests are relatively expensive and there's a lot of objects, this provides a substantial (50% for me) improvement. Uses the ForkJoinPool.commonPool by default so won't spawn new threads (in theory).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1504
https://github.com/qupath/qupath/pull/1509:56,Deployability,release,releases,56,"Temporarily during development, until we make the final releases.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1509
https://github.com/qupath/qupath/pull/1510:124,Integrability,interface,interface,124,Previously the export measurements window was a fixed size resulting in a small controlsfx ListSelectionView component. The interface is now resizable with the list boxes flexing to fill the space.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1510
https://github.com/qupath/qupath/pull/1512:206,Performance,load,load,206,"Makes the ""Select project images"" window for pixel and object classifier resizable so image names can be viewed without scrolling. To access: Classify -> Object classification -> train object classifier -> load training button . Other `listSelectionView` uses within QuPath are resizable windows already (eg. script editor -> run -> run for project).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1512
https://github.com/qupath/qupath/pull/1512:134,Security,access,access,134,"Makes the ""Select project images"" window for pixel and object classifier resizable so image names can be viewed without scrolling. To access: Classify -> Object classification -> train object classifier -> load training button . Other `listSelectionView` uses within QuPath are resizable windows already (eg. script editor -> run -> run for project).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1512
https://github.com/qupath/qupath/pull/1513:65,Integrability,depend,dependencies,65,"This PR makes the `jpackage` gradle task put the Javadocs of all dependencies alongside the Javadocs of QuPath when creating the executable (in `Content/app/docs` for MacOS for example). This adds 279.8 MB to the size of the executable, so it may be better to skip some dependencies.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1513
https://github.com/qupath/qupath/pull/1513:270,Integrability,depend,dependencies,270,"This PR makes the `jpackage` gradle task put the Javadocs of all dependencies alongside the Javadocs of QuPath when creating the executable (in `Content/app/docs` for MacOS for example). This adds 279.8 MB to the size of the executable, so it may be better to skip some dependencies.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1513
https://github.com/qupath/qupath/issues/1516:1094,Availability,error,error,1094,"## Bug report. **Describe the bug**; When using the `TileExporter`, pixel size and channel color information can be lost. **To Reproduce**; Use the `TileExporter` class to export fixed-size tiles as ImageJ TIFF, e.g. with this script applied to the LuCa sample image:. ```groovy; def path = buildPathInProject(""tiles""); mkdirs(path); def imageData = getCurrentImageData(); new TileExporter(imageData); .writeTiles(path); ```. Open the resulting TIFFs in ImageJ and see that no calibration is set. **Expected behavior**; Channel colors are preserved, and the image properties are set (pixel size and origin). **Desktop (please complete the following information):**; - OS: All; - QuPath Version: v0.5.1 (and earlier). **Additional context**; Relates to https://github.com/qupath/qupath/issues/1503 but is not identical. The relevant code is at; https://github.com/qupath/qupath/blob/0ab5d054a2aac2e21d1bcc234306e164e44965bb/qupath-core/src/main/java/qupath/lib/images/writers/TileExporter.java#L786. The difficulty is guaranteeing that tiles have a fixed size, rather than risking an off-by-one error, when we can only define the region with an `ImageServer` and `RegionRequest` that can have an arbitrary downsample.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1516
https://github.com/qupath/qupath/issues/1516:1205,Availability,down,downsample,1205,"## Bug report. **Describe the bug**; When using the `TileExporter`, pixel size and channel color information can be lost. **To Reproduce**; Use the `TileExporter` class to export fixed-size tiles as ImageJ TIFF, e.g. with this script applied to the LuCa sample image:. ```groovy; def path = buildPathInProject(""tiles""); mkdirs(path); def imageData = getCurrentImageData(); new TileExporter(imageData); .writeTiles(path); ```. Open the resulting TIFFs in ImageJ and see that no calibration is set. **Expected behavior**; Channel colors are preserved, and the image properties are set (pixel size and origin). **Desktop (please complete the following information):**; - OS: All; - QuPath Version: v0.5.1 (and earlier). **Additional context**; Relates to https://github.com/qupath/qupath/issues/1503 but is not identical. The relevant code is at; https://github.com/qupath/qupath/blob/0ab5d054a2aac2e21d1bcc234306e164e44965bb/qupath-core/src/main/java/qupath/lib/images/writers/TileExporter.java#L786. The difficulty is guaranteeing that tiles have a fixed size, rather than risking an off-by-one error, when we can only define the region with an `ImageServer` and `RegionRequest` that can have an arbitrary downsample.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1516
https://github.com/qupath/qupath/issues/1516:1072,Safety,risk,risking,1072,"## Bug report. **Describe the bug**; When using the `TileExporter`, pixel size and channel color information can be lost. **To Reproduce**; Use the `TileExporter` class to export fixed-size tiles as ImageJ TIFF, e.g. with this script applied to the LuCa sample image:. ```groovy; def path = buildPathInProject(""tiles""); mkdirs(path); def imageData = getCurrentImageData(); new TileExporter(imageData); .writeTiles(path); ```. Open the resulting TIFFs in ImageJ and see that no calibration is set. **Expected behavior**; Channel colors are preserved, and the image properties are set (pixel size and origin). **Desktop (please complete the following information):**; - OS: All; - QuPath Version: v0.5.1 (and earlier). **Additional context**; Relates to https://github.com/qupath/qupath/issues/1503 but is not identical. The relevant code is at; https://github.com/qupath/qupath/blob/0ab5d054a2aac2e21d1bcc234306e164e44965bb/qupath-core/src/main/java/qupath/lib/images/writers/TileExporter.java#L786. The difficulty is guaranteeing that tiles have a fixed size, rather than risking an off-by-one error, when we can only define the region with an `ImageServer` and `RegionRequest` that can have an arbitrary downsample.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1516
https://github.com/qupath/qupath/pull/1520:589,Safety,risk,risky,589,"This makes `ContourTracing` much faster in some circumstances - especially when labeled images were involved. There are two main differences:; 1. Previously, the code would tend to loop through all pixels to generate the contour for each label; now it generates bounding boxes in a single loop, and then iterates only through the relevant bounding box for each label (when using `createROIs`); 2. The tracing algorithm has been replaced by a reliance on JTS's `Polygonizer` class; this was already used before, but now we rely on it more heavily. The second of these makes this *slightly* risky - I encountered exceptions and infinite loops along the way, so this needs to be tested very carefully.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1520
https://github.com/qupath/qupath/pull/1520:676,Testability,test,tested,676,"This makes `ContourTracing` much faster in some circumstances - especially when labeled images were involved. There are two main differences:; 1. Previously, the code would tend to loop through all pixels to generate the contour for each label; now it generates bounding boxes in a single loop, and then iterates only through the relevant bounding box for each label (when using `createROIs`); 2. The tracing algorithm has been replaced by a reliance on JTS's `Polygonizer` class; this was already used before, but now we rely on it more heavily. The second of these makes this *slightly* risky - I encountered exceptions and infinite loops along the way, so this needs to be tested very carefully.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1520
https://github.com/qupath/qupath/pull/1521:203,Availability,down,downsample,203,"This was causing trouble in https://forum.image.sc/t/how-can-display-more-than-one-images-in-qupath-viewer-using-scripting/96156/ initially because the width and height here zero, leading to an infinite downsample value... and persistent JavaFX complaints upon all interactions with the viewer. This happened when setting the viewer grid size and then *immediately* setting the image in the viewer; somehow this resulted in wrong values being calculated, and a non-invertible AffineTransform that caused trouble indefinitely. The workaround here avoids many repeated exceptions, although still results in the image being opened at full resolution rather than the expected (fitted) downsample.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1521
https://github.com/qupath/qupath/pull/1521:681,Availability,down,downsample,681,"This was causing trouble in https://forum.image.sc/t/how-can-display-more-than-one-images-in-qupath-viewer-using-scripting/96156/ initially because the width and height here zero, leading to an infinite downsample value... and persistent JavaFX complaints upon all interactions with the viewer. This happened when setting the viewer grid size and then *immediately* setting the image in the viewer; somehow this resulted in wrong values being calculated, and a non-invertible AffineTransform that caused trouble indefinitely. The workaround here avoids many repeated exceptions, although still results in the image being opened at full resolution rather than the expected (fitted) downsample.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1521
https://github.com/qupath/qupath/pull/1521:546,Safety,avoid,avoids,546,"This was causing trouble in https://forum.image.sc/t/how-can-display-more-than-one-images-in-qupath-viewer-using-scripting/96156/ initially because the width and height here zero, leading to an infinite downsample value... and persistent JavaFX complaints upon all interactions with the viewer. This happened when setting the viewer grid size and then *immediately* setting the image in the viewer; somehow this resulted in wrong values being calculated, and a non-invertible AffineTransform that caused trouble indefinitely. The workaround here avoids many repeated exceptions, although still results in the image being opened at full resolution rather than the expected (fitted) downsample.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1521
https://github.com/qupath/qupath/issues/1522:415,Integrability,depend,dependency,415,"## Bug report. **Describe the bug**; See https://forum.image.sc/t/unexpected-behavior-difference-in-imagej-macro-runner-vs-send-region-to-imagej/96089. **Expected behavior**; It's possible to transfer the cell nucleus and cell boundary to ImageJ for use with the macro runner. *Possibly* this should also pay attention to the `OverlayOptions` in the viewer by default... but this is questionable as it introduces a dependency on the viewer settings. **Desktop (please complete the following information):**; - OS: All; - QuPath Version: v0.5.1 (and earlier). **Additional context**; The issue relates to `OverlayOptions` not being passed through, as shown at https://github.com/qupath/qupath/blob/5066159c6e4fa197c28d003662798dbf08804f08/qupath-extension-processing/src/main/java/qupath/imagej/gui/ImageJMacroRunner.java#L238",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1522
https://github.com/qupath/qupath/pull/1523:114,Integrability,depend,depending,114,"A step towards fixing https://github.com/qupath/qupath/issues/1522. Incomplete, because it behaves inconsistently depending upon whether the macro is being run on a selected object or across all annotations / TMA cores. In the first case, the `ImageDisplay` and `OverlayOptions` may be used, but in the second case they are unavailable.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1523
https://github.com/qupath/qupath/pull/1524:205,Integrability,interface,interface,205,"This means that when a user attempts to close QuPath, we can check if there are any open scripts with unsaved changes and handle these as with other types of unsaved changes. Unsure if changing the editor interface is a big deal, presumably there aren't too many implementations out there. Raised by @finglis",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1524
https://github.com/qupath/qupath/pull/1526:43,Modifiability,extend,extends,43,"In the `RoiTools.intersection(Collection<? extends ROI> rois)` function (see [here](https://github.com/qupath/qupath/blob/5066159c6e4fa197c28d003662798dbf08804f08/qupath-core/src/main/java/qupath/lib/roi/RoiTools.java#L185C10-L185C23)), the `GeometryTools.geometryToROI(Geometry geometry, ImagePlane plane)` (see [here](https://github.com/qupath/qupath/blob/5066159c6e4fa197c28d003662798dbf08804f08/qupath-core/src/main/java/qupath/lib/roi/GeometryTools.java#L1278)) is called with the `first` and `plane` local variables. In some situations, the `first` variable is a non homogeneous geometry collection, [which triggers a warning in `GeometryTools.geometryToROI()`](https://github.com/qupath/qupath/blob/5066159c6e4fa197c28d003662798dbf08804f08/qupath-core/src/main/java/qupath/lib/roi/GeometryTools.java#L1285). This PR simply homogenizes the `first` parameter before calling `GeometryTools.geometryToROI()`. This only prevents the warning log from appearing and doesn't change anything else, [as the geometry was homogenized anyway](https://github.com/qupath/qupath/blob/5066159c6e4fa197c28d003662798dbf08804f08/qupath-core/src/main/java/qupath/lib/roi/GeometryTools.java#L1286).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1526
https://github.com/qupath/qupath/pull/1526:512,Modifiability,variab,variables,512,"In the `RoiTools.intersection(Collection<? extends ROI> rois)` function (see [here](https://github.com/qupath/qupath/blob/5066159c6e4fa197c28d003662798dbf08804f08/qupath-core/src/main/java/qupath/lib/roi/RoiTools.java#L185C10-L185C23)), the `GeometryTools.geometryToROI(Geometry geometry, ImagePlane plane)` (see [here](https://github.com/qupath/qupath/blob/5066159c6e4fa197c28d003662798dbf08804f08/qupath-core/src/main/java/qupath/lib/roi/GeometryTools.java#L1278)) is called with the `first` and `plane` local variables. In some situations, the `first` variable is a non homogeneous geometry collection, [which triggers a warning in `GeometryTools.geometryToROI()`](https://github.com/qupath/qupath/blob/5066159c6e4fa197c28d003662798dbf08804f08/qupath-core/src/main/java/qupath/lib/roi/GeometryTools.java#L1285). This PR simply homogenizes the `first` parameter before calling `GeometryTools.geometryToROI()`. This only prevents the warning log from appearing and doesn't change anything else, [as the geometry was homogenized anyway](https://github.com/qupath/qupath/blob/5066159c6e4fa197c28d003662798dbf08804f08/qupath-core/src/main/java/qupath/lib/roi/GeometryTools.java#L1286).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1526
https://github.com/qupath/qupath/pull/1526:555,Modifiability,variab,variable,555,"In the `RoiTools.intersection(Collection<? extends ROI> rois)` function (see [here](https://github.com/qupath/qupath/blob/5066159c6e4fa197c28d003662798dbf08804f08/qupath-core/src/main/java/qupath/lib/roi/RoiTools.java#L185C10-L185C23)), the `GeometryTools.geometryToROI(Geometry geometry, ImagePlane plane)` (see [here](https://github.com/qupath/qupath/blob/5066159c6e4fa197c28d003662798dbf08804f08/qupath-core/src/main/java/qupath/lib/roi/GeometryTools.java#L1278)) is called with the `first` and `plane` local variables. In some situations, the `first` variable is a non homogeneous geometry collection, [which triggers a warning in `GeometryTools.geometryToROI()`](https://github.com/qupath/qupath/blob/5066159c6e4fa197c28d003662798dbf08804f08/qupath-core/src/main/java/qupath/lib/roi/GeometryTools.java#L1285). This PR simply homogenizes the `first` parameter before calling `GeometryTools.geometryToROI()`. This only prevents the warning log from appearing and doesn't change anything else, [as the geometry was homogenized anyway](https://github.com/qupath/qupath/blob/5066159c6e4fa197c28d003662798dbf08804f08/qupath-core/src/main/java/qupath/lib/roi/GeometryTools.java#L1286).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1526
https://github.com/qupath/qupath/pull/1526:943,Testability,log,log,943,"In the `RoiTools.intersection(Collection<? extends ROI> rois)` function (see [here](https://github.com/qupath/qupath/blob/5066159c6e4fa197c28d003662798dbf08804f08/qupath-core/src/main/java/qupath/lib/roi/RoiTools.java#L185C10-L185C23)), the `GeometryTools.geometryToROI(Geometry geometry, ImagePlane plane)` (see [here](https://github.com/qupath/qupath/blob/5066159c6e4fa197c28d003662798dbf08804f08/qupath-core/src/main/java/qupath/lib/roi/GeometryTools.java#L1278)) is called with the `first` and `plane` local variables. In some situations, the `first` variable is a non homogeneous geometry collection, [which triggers a warning in `GeometryTools.geometryToROI()`](https://github.com/qupath/qupath/blob/5066159c6e4fa197c28d003662798dbf08804f08/qupath-core/src/main/java/qupath/lib/roi/GeometryTools.java#L1285). This PR simply homogenizes the `first` parameter before calling `GeometryTools.geometryToROI()`. This only prevents the warning log from appearing and doesn't change anything else, [as the geometry was homogenized anyway](https://github.com/qupath/qupath/blob/5066159c6e4fa197c28d003662798dbf08804f08/qupath-core/src/main/java/qupath/lib/roi/GeometryTools.java#L1286).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1526
https://github.com/qupath/qupath/pull/1526:823,Usability,simpl,simply,823,"In the `RoiTools.intersection(Collection<? extends ROI> rois)` function (see [here](https://github.com/qupath/qupath/blob/5066159c6e4fa197c28d003662798dbf08804f08/qupath-core/src/main/java/qupath/lib/roi/RoiTools.java#L185C10-L185C23)), the `GeometryTools.geometryToROI(Geometry geometry, ImagePlane plane)` (see [here](https://github.com/qupath/qupath/blob/5066159c6e4fa197c28d003662798dbf08804f08/qupath-core/src/main/java/qupath/lib/roi/GeometryTools.java#L1278)) is called with the `first` and `plane` local variables. In some situations, the `first` variable is a non homogeneous geometry collection, [which triggers a warning in `GeometryTools.geometryToROI()`](https://github.com/qupath/qupath/blob/5066159c6e4fa197c28d003662798dbf08804f08/qupath-core/src/main/java/qupath/lib/roi/GeometryTools.java#L1285). This PR simply homogenizes the `first` parameter before calling `GeometryTools.geometryToROI()`. This only prevents the warning log from appearing and doesn't change anything else, [as the geometry was homogenized anyway](https://github.com/qupath/qupath/blob/5066159c6e4fa197c28d003662798dbf08804f08/qupath-core/src/main/java/qupath/lib/roi/GeometryTools.java#L1286).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1526
https://github.com/qupath/qupath/issues/1527:43,Availability,down,downsample,43,"## Bug report. *Describe the bug*; At some downsample levels, images can display a 1 pixel-width black column on the right edge. *To Reproduce*; 1. Open the [GTEX-12584-1526 image](https://brd.nci.nih.gov/brd/imagedownload/GTEX-12584-1526; ). This image has levels with downsamples 1, 4, and 16.; 2. Check the right edge of the image. No black column, everything is normal.; 3. Click on File, Export images..., Original pixels, JPEG (or PNG) and downsample of 32.; 4. Check the right edge of the produced image. There is a black column of width 1. *Expected behavior*; No black column on any downsample. *Desktop:*; - OS: macOS and Linux, so probably not OS dependant.; - QuPath Version: 0.6.0-SNAPSHOT. *Additional context*; The problem occurs in the [AbstractTileableImageServer.readRegion()](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L266) function. When requesting an image with downsample 32:; * A black image of width 1432 (=`round(imageWidth/32)`) is created ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L302C4-L302C17)).; * All tiles with downsample 16 (because it's the lowest resolution) are retrieved ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L275C3-L275C13)).; * Images corresponding to the above tiles are drawn to the above black image ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L328)). The problem is that the resulting image of downsample 32 is of width 1432, which corresponds to pixels 0 to **45824** (=`1432*32`) of the full resolution image on the x-axis, while the width o",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1527
https://github.com/qupath/qupath/issues/1527:270,Availability,down,downsamples,270,"## Bug report. *Describe the bug*; At some downsample levels, images can display a 1 pixel-width black column on the right edge. *To Reproduce*; 1. Open the [GTEX-12584-1526 image](https://brd.nci.nih.gov/brd/imagedownload/GTEX-12584-1526; ). This image has levels with downsamples 1, 4, and 16.; 2. Check the right edge of the image. No black column, everything is normal.; 3. Click on File, Export images..., Original pixels, JPEG (or PNG) and downsample of 32.; 4. Check the right edge of the produced image. There is a black column of width 1. *Expected behavior*; No black column on any downsample. *Desktop:*; - OS: macOS and Linux, so probably not OS dependant.; - QuPath Version: 0.6.0-SNAPSHOT. *Additional context*; The problem occurs in the [AbstractTileableImageServer.readRegion()](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L266) function. When requesting an image with downsample 32:; * A black image of width 1432 (=`round(imageWidth/32)`) is created ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L302C4-L302C17)).; * All tiles with downsample 16 (because it's the lowest resolution) are retrieved ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L275C3-L275C13)).; * Images corresponding to the above tiles are drawn to the above black image ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L328)). The problem is that the resulting image of downsample 32 is of width 1432, which corresponds to pixels 0 to **45824** (=`1432*32`) of the full resolution image on the x-axis, while the width o",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1527
https://github.com/qupath/qupath/issues/1527:446,Availability,down,downsample,446,"## Bug report. *Describe the bug*; At some downsample levels, images can display a 1 pixel-width black column on the right edge. *To Reproduce*; 1. Open the [GTEX-12584-1526 image](https://brd.nci.nih.gov/brd/imagedownload/GTEX-12584-1526; ). This image has levels with downsamples 1, 4, and 16.; 2. Check the right edge of the image. No black column, everything is normal.; 3. Click on File, Export images..., Original pixels, JPEG (or PNG) and downsample of 32.; 4. Check the right edge of the produced image. There is a black column of width 1. *Expected behavior*; No black column on any downsample. *Desktop:*; - OS: macOS and Linux, so probably not OS dependant.; - QuPath Version: 0.6.0-SNAPSHOT. *Additional context*; The problem occurs in the [AbstractTileableImageServer.readRegion()](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L266) function. When requesting an image with downsample 32:; * A black image of width 1432 (=`round(imageWidth/32)`) is created ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L302C4-L302C17)).; * All tiles with downsample 16 (because it's the lowest resolution) are retrieved ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L275C3-L275C13)).; * Images corresponding to the above tiles are drawn to the above black image ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L328)). The problem is that the resulting image of downsample 32 is of width 1432, which corresponds to pixels 0 to **45824** (=`1432*32`) of the full resolution image on the x-axis, while the width o",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1527
https://github.com/qupath/qupath/issues/1527:592,Availability,down,downsample,592,"## Bug report. *Describe the bug*; At some downsample levels, images can display a 1 pixel-width black column on the right edge. *To Reproduce*; 1. Open the [GTEX-12584-1526 image](https://brd.nci.nih.gov/brd/imagedownload/GTEX-12584-1526; ). This image has levels with downsamples 1, 4, and 16.; 2. Check the right edge of the image. No black column, everything is normal.; 3. Click on File, Export images..., Original pixels, JPEG (or PNG) and downsample of 32.; 4. Check the right edge of the produced image. There is a black column of width 1. *Expected behavior*; No black column on any downsample. *Desktop:*; - OS: macOS and Linux, so probably not OS dependant.; - QuPath Version: 0.6.0-SNAPSHOT. *Additional context*; The problem occurs in the [AbstractTileableImageServer.readRegion()](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L266) function. When requesting an image with downsample 32:; * A black image of width 1432 (=`round(imageWidth/32)`) is created ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L302C4-L302C17)).; * All tiles with downsample 16 (because it's the lowest resolution) are retrieved ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L275C3-L275C13)).; * Images corresponding to the above tiles are drawn to the above black image ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L328)). The problem is that the resulting image of downsample 32 is of width 1432, which corresponds to pixels 0 to **45824** (=`1432*32`) of the full resolution image on the x-axis, while the width o",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1527
https://github.com/qupath/qupath/issues/1527:1005,Availability,down,downsample,1005," downsample levels, images can display a 1 pixel-width black column on the right edge. *To Reproduce*; 1. Open the [GTEX-12584-1526 image](https://brd.nci.nih.gov/brd/imagedownload/GTEX-12584-1526; ). This image has levels with downsamples 1, 4, and 16.; 2. Check the right edge of the image. No black column, everything is normal.; 3. Click on File, Export images..., Original pixels, JPEG (or PNG) and downsample of 32.; 4. Check the right edge of the produced image. There is a black column of width 1. *Expected behavior*; No black column on any downsample. *Desktop:*; - OS: macOS and Linux, so probably not OS dependant.; - QuPath Version: 0.6.0-SNAPSHOT. *Additional context*; The problem occurs in the [AbstractTileableImageServer.readRegion()](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L266) function. When requesting an image with downsample 32:; * A black image of width 1432 (=`round(imageWidth/32)`) is created ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L302C4-L302C17)).; * All tiles with downsample 16 (because it's the lowest resolution) are retrieved ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L275C3-L275C13)).; * Images corresponding to the above tiles are drawn to the above black image ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L328)). The problem is that the resulting image of downsample 32 is of width 1432, which corresponds to pixels 0 to **45824** (=`1432*32`) of the full resolution image on the x-axis, while the width of the image of downsample 16 is 2863, whic",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1527
https://github.com/qupath/qupath/issues/1527:1296,Availability,down,downsample,1296,"age. No black column, everything is normal.; 3. Click on File, Export images..., Original pixels, JPEG (or PNG) and downsample of 32.; 4. Check the right edge of the produced image. There is a black column of width 1. *Expected behavior*; No black column on any downsample. *Desktop:*; - OS: macOS and Linux, so probably not OS dependant.; - QuPath Version: 0.6.0-SNAPSHOT. *Additional context*; The problem occurs in the [AbstractTileableImageServer.readRegion()](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L266) function. When requesting an image with downsample 32:; * A black image of width 1432 (=`round(imageWidth/32)`) is created ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L302C4-L302C17)).; * All tiles with downsample 16 (because it's the lowest resolution) are retrieved ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L275C3-L275C13)).; * Images corresponding to the above tiles are drawn to the above black image ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L328)). The problem is that the resulting image of downsample 32 is of width 1432, which corresponds to pixels 0 to **45824** (=`1432*32`) of the full resolution image on the x-axis, while the width of the image of downsample 16 is 2863, which corresponds to pixels 0 to **45808** (=`2863*16`) of the full resolution image. `45808 < 45824`, so the last pixel of each row of the resulting image of downsample 32 is not painted. The image of downsample 16 covers pixels 0 to 45808, because `imageWidth/16 = 2863.4375`, and its width",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1527
https://github.com/qupath/qupath/issues/1527:1852,Availability,down,downsample,1852,"pixels, JPEG (or PNG) and downsample of 32.; 4. Check the right edge of the produced image. There is a black column of width 1. *Expected behavior*; No black column on any downsample. *Desktop:*; - OS: macOS and Linux, so probably not OS dependant.; - QuPath Version: 0.6.0-SNAPSHOT. *Additional context*; The problem occurs in the [AbstractTileableImageServer.readRegion()](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L266) function. When requesting an image with downsample 32:; * A black image of width 1432 (=`round(imageWidth/32)`) is created ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L302C4-L302C17)).; * All tiles with downsample 16 (because it's the lowest resolution) are retrieved ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L275C3-L275C13)).; * Images corresponding to the above tiles are drawn to the above black image ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L328)). The problem is that the resulting image of downsample 32 is of width 1432, which corresponds to pixels 0 to **45824** (=`1432*32`) of the full resolution image on the x-axis, while the width of the image of downsample 16 is 2863, which corresponds to pixels 0 to **45808** (=`2863*16`) of the full resolution image. `45808 < 45824`, so the last pixel of each row of the resulting image of downsample 32 is not painted. The image of downsample 16 covers pixels 0 to 45808, because `imageWidth/16 = 2863.4375`, and its width is `round(imageWidth/16) = 2863`, so some pixel values are lost when rounding 2863.4375.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1527
https://github.com/qupath/qupath/issues/1527:2016,Availability,down,downsample,2016,"pixels, JPEG (or PNG) and downsample of 32.; 4. Check the right edge of the produced image. There is a black column of width 1. *Expected behavior*; No black column on any downsample. *Desktop:*; - OS: macOS and Linux, so probably not OS dependant.; - QuPath Version: 0.6.0-SNAPSHOT. *Additional context*; The problem occurs in the [AbstractTileableImageServer.readRegion()](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L266) function. When requesting an image with downsample 32:; * A black image of width 1432 (=`round(imageWidth/32)`) is created ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L302C4-L302C17)).; * All tiles with downsample 16 (because it's the lowest resolution) are retrieved ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L275C3-L275C13)).; * Images corresponding to the above tiles are drawn to the above black image ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L328)). The problem is that the resulting image of downsample 32 is of width 1432, which corresponds to pixels 0 to **45824** (=`1432*32`) of the full resolution image on the x-axis, while the width of the image of downsample 16 is 2863, which corresponds to pixels 0 to **45808** (=`2863*16`) of the full resolution image. `45808 < 45824`, so the last pixel of each row of the resulting image of downsample 32 is not painted. The image of downsample 16 covers pixels 0 to 45808, because `imageWidth/16 = 2863.4375`, and its width is `round(imageWidth/16) = 2863`, so some pixel values are lost when rounding 2863.4375.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1527
https://github.com/qupath/qupath/issues/1527:2198,Availability,down,downsample,2198,"pixels, JPEG (or PNG) and downsample of 32.; 4. Check the right edge of the produced image. There is a black column of width 1. *Expected behavior*; No black column on any downsample. *Desktop:*; - OS: macOS and Linux, so probably not OS dependant.; - QuPath Version: 0.6.0-SNAPSHOT. *Additional context*; The problem occurs in the [AbstractTileableImageServer.readRegion()](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L266) function. When requesting an image with downsample 32:; * A black image of width 1432 (=`round(imageWidth/32)`) is created ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L302C4-L302C17)).; * All tiles with downsample 16 (because it's the lowest resolution) are retrieved ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L275C3-L275C13)).; * Images corresponding to the above tiles are drawn to the above black image ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L328)). The problem is that the resulting image of downsample 32 is of width 1432, which corresponds to pixels 0 to **45824** (=`1432*32`) of the full resolution image on the x-axis, while the width of the image of downsample 16 is 2863, which corresponds to pixels 0 to **45808** (=`2863*16`) of the full resolution image. `45808 < 45824`, so the last pixel of each row of the resulting image of downsample 32 is not painted. The image of downsample 16 covers pixels 0 to 45808, because `imageWidth/16 = 2863.4375`, and its width is `round(imageWidth/16) = 2863`, so some pixel values are lost when rounding 2863.4375.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1527
https://github.com/qupath/qupath/issues/1527:2241,Availability,down,downsample,2241,"pixels, JPEG (or PNG) and downsample of 32.; 4. Check the right edge of the produced image. There is a black column of width 1. *Expected behavior*; No black column on any downsample. *Desktop:*; - OS: macOS and Linux, so probably not OS dependant.; - QuPath Version: 0.6.0-SNAPSHOT. *Additional context*; The problem occurs in the [AbstractTileableImageServer.readRegion()](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L266) function. When requesting an image with downsample 32:; * A black image of width 1432 (=`round(imageWidth/32)`) is created ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L302C4-L302C17)).; * All tiles with downsample 16 (because it's the lowest resolution) are retrieved ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L275C3-L275C13)).; * Images corresponding to the above tiles are drawn to the above black image ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L328)). The problem is that the resulting image of downsample 32 is of width 1432, which corresponds to pixels 0 to **45824** (=`1432*32`) of the full resolution image on the x-axis, while the width of the image of downsample 16 is 2863, which corresponds to pixels 0 to **45808** (=`2863*16`) of the full resolution image. `45808 < 45824`, so the last pixel of each row of the resulting image of downsample 32 is not painted. The image of downsample 16 covers pixels 0 to 45808, because `imageWidth/16 = 2863.4375`, and its width is `round(imageWidth/16) = 2863`, so some pixel values are lost when rounding 2863.4375.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1527
https://github.com/qupath/qupath/issues/1527:658,Integrability,depend,dependant,658,"## Bug report. *Describe the bug*; At some downsample levels, images can display a 1 pixel-width black column on the right edge. *To Reproduce*; 1. Open the [GTEX-12584-1526 image](https://brd.nci.nih.gov/brd/imagedownload/GTEX-12584-1526; ). This image has levels with downsamples 1, 4, and 16.; 2. Check the right edge of the image. No black column, everything is normal.; 3. Click on File, Export images..., Original pixels, JPEG (or PNG) and downsample of 32.; 4. Check the right edge of the produced image. There is a black column of width 1. *Expected behavior*; No black column on any downsample. *Desktop:*; - OS: macOS and Linux, so probably not OS dependant.; - QuPath Version: 0.6.0-SNAPSHOT. *Additional context*; The problem occurs in the [AbstractTileableImageServer.readRegion()](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L266) function. When requesting an image with downsample 32:; * A black image of width 1432 (=`round(imageWidth/32)`) is created ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L302C4-L302C17)).; * All tiles with downsample 16 (because it's the lowest resolution) are retrieved ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L275C3-L275C13)).; * Images corresponding to the above tiles are drawn to the above black image ([here](https://github.com/qupath/qupath/blob/76415104d0653c674716d69a1ecb51e59dae0e83/qupath-core/src/main/java/qupath/lib/images/servers/AbstractTileableImageServer.java#L328)). The problem is that the resulting image of downsample 32 is of width 1432, which corresponds to pixels 0 to **45824** (=`1432*32`) of the full resolution image on the x-axis, while the width o",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1527
https://github.com/qupath/qupath/pull/1528:72,Availability,down,downsampled,72,"A proposal to fix #1527. It simply consists in reducing the size of the downsampled image by rounding down its width and height, instead of rounding it.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1528
https://github.com/qupath/qupath/pull/1528:102,Availability,down,down,102,"A proposal to fix #1527. It simply consists in reducing the size of the downsampled image by rounding down its width and height, instead of rounding it.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1528
https://github.com/qupath/qupath/pull/1528:28,Usability,simpl,simply,28,"A proposal to fix #1527. It simply consists in reducing the size of the downsampled image by rounding down its width and height, instead of rounding it.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1528
https://github.com/qupath/qupath/pull/1531:318,Availability,avail,available,318,"Attempts to fix https://github.com/qupath/qupath/issues/1527. This tries to take a conservative approach that should fix the most common occurrence of this: basically, if a request is made for to get the 'last' pixels on the right or bottom of the image, then a check is made to see if this can be fulfilled using the available lower resolution tiles. If the tiles don't quite make it (due to the lower pyramid levels being truncated), then a slightly smaller image can be returned - typically missing the last row and/or column. The unfortunate consequence would be that we can't compute the returned image size based upon the `RegionRequest` (width, height and downsample) - because this might have been internally adjusted. To handle that, we resize then to fit expectations. It feels messy and suboptimal, but failing to do this can result in black rows or columns appearing - which can thwart thresholds and image statistics and certain resolutions, and this is more problematic.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1531
https://github.com/qupath/qupath/pull/1531:663,Availability,down,downsample,663,"Attempts to fix https://github.com/qupath/qupath/issues/1527. This tries to take a conservative approach that should fix the most common occurrence of this: basically, if a request is made for to get the 'last' pixels on the right or bottom of the image, then a check is made to see if this can be fulfilled using the available lower resolution tiles. If the tiles don't quite make it (due to the lower pyramid levels being truncated), then a slightly smaller image can be returned - typically missing the last row and/or column. The unfortunate consequence would be that we can't compute the returned image size based upon the `RegionRequest` (width, height and downsample) - because this might have been internally adjusted. To handle that, we resize then to fit expectations. It feels messy and suboptimal, but failing to do this can result in black rows or columns appearing - which can thwart thresholds and image statistics and certain resolutions, and this is more problematic.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1531
https://github.com/qupath/qupath/issues/1533:379,Availability,down,down,379,"## Bug report. **Describe the bug**; Sometimes a full image annotation can be shifted outside the image bounds, so that its origin is at `(-1,-1)`. **To Reproduce**; Steps to reproduce the behavior:; 1. Open an image; 2. *Objects → Annotations... → Create full image annotation*; 3. Run the script `println getSelectedROI()` to confirm the bounds; 4. Try to drag the annotation *down to the right*; 5. Run the script `println getSelectedROI()` to see it has mysteriously shifted a pixel in the opposite direction . **Expected behavior**; The annotation doesn't move. **Desktop (please complete the following information):**; - OS: All; - QuPath Version: v0.5.1 (and earlier). **Additional context**; Hoping this is an easy fix as the stay-within-bounds logic is just 'over-correcting'.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1533
https://github.com/qupath/qupath/issues/1533:753,Testability,log,logic,753,"## Bug report. **Describe the bug**; Sometimes a full image annotation can be shifted outside the image bounds, so that its origin is at `(-1,-1)`. **To Reproduce**; Steps to reproduce the behavior:; 1. Open an image; 2. *Objects → Annotations... → Create full image annotation*; 3. Run the script `println getSelectedROI()` to confirm the bounds; 4. Try to drag the annotation *down to the right*; 5. Run the script `println getSelectedROI()` to see it has mysteriously shifted a pixel in the opposite direction . **Expected behavior**; The annotation doesn't move. **Desktop (please complete the following information):**; - OS: All; - QuPath Version: v0.5.1 (and earlier). **Additional context**; Hoping this is an easy fix as the stay-within-bounds logic is just 'over-correcting'.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1533
https://github.com/qupath/qupath/issues/1536:75,Deployability,install,install,75,Thank u for developed such convenient tool like this . Is that possible to install this app by use scoop?,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1536
https://github.com/qupath/qupath/issues/1537:160,Deployability,update,update,160,"## Feature request. **Is your feature request related to a problem? Please describe.**; Project sorting is not persistent across QuPath instances, and does not update based on updated metadata values.; Nice-to-have would be to add metadata values when images are dragged and dropped, but I feel that's going to be a stretch goal. **Describe the solution you'd like**; In order of priority/feasibility:. 1. Project sorting persists; 2. Sorting is updated when metadata values change; 3. Dragging & dropping a file into a project sorted by metadata value sets the corresponding value. **Describe alternatives you've considered**; Manually re-sorting on project opening and when values change, and manually setting metadata values. **Additional context**. ImageSC posts:. - https://forum.image.sc/t/qupath-feature-request-persist-image-sorting-per-metadata/91406/4; - https://forum.image.sc/t/qupath-sort-by/85398",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1537
https://github.com/qupath/qupath/issues/1537:176,Deployability,update,updated,176,"## Feature request. **Is your feature request related to a problem? Please describe.**; Project sorting is not persistent across QuPath instances, and does not update based on updated metadata values.; Nice-to-have would be to add metadata values when images are dragged and dropped, but I feel that's going to be a stretch goal. **Describe the solution you'd like**; In order of priority/feasibility:. 1. Project sorting persists; 2. Sorting is updated when metadata values change; 3. Dragging & dropping a file into a project sorted by metadata value sets the corresponding value. **Describe alternatives you've considered**; Manually re-sorting on project opening and when values change, and manually setting metadata values. **Additional context**. ImageSC posts:. - https://forum.image.sc/t/qupath-feature-request-persist-image-sorting-per-metadata/91406/4; - https://forum.image.sc/t/qupath-sort-by/85398",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1537
https://github.com/qupath/qupath/issues/1537:446,Deployability,update,updated,446,"## Feature request. **Is your feature request related to a problem? Please describe.**; Project sorting is not persistent across QuPath instances, and does not update based on updated metadata values.; Nice-to-have would be to add metadata values when images are dragged and dropped, but I feel that's going to be a stretch goal. **Describe the solution you'd like**; In order of priority/feasibility:. 1. Project sorting persists; 2. Sorting is updated when metadata values change; 3. Dragging & dropping a file into a project sorted by metadata value sets the corresponding value. **Describe alternatives you've considered**; Manually re-sorting on project opening and when values change, and manually setting metadata values. **Additional context**. ImageSC posts:. - https://forum.image.sc/t/qupath-feature-request-persist-image-sorting-per-metadata/91406/4; - https://forum.image.sc/t/qupath-sort-by/85398",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1537
https://github.com/qupath/qupath/issues/1539:1268,Availability,error,error,1268,"## IMPORTANT!. This section is **only** for bug reports, which **must** follow the template below. Please post any other questions to the official QuPath forum at https://forum.image.sc/tags/qupath. If in doubt, use [image.sc](https://forum.image.sc/tags/qupath). This helps us keep things organized. ## Before we begin... Before submitting your bug report, please check the following:. * [x] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; ""Custom color"" window closes when trying use a custom color either by typing in a box, clicking on a slider, or clicking on the color picker. . **To Reproduce**; Steps to reproduce the behavior:; 1. Go to ""Brightness and Contrast""; 2. Click on the color next to a channel and click ""Custom color...""; 3. Try to adjust a slider, use color picker, or type in one of the text boxes; 4. See error (window immediately closes). **Expected behavior**; It is expected that the window remain open while dragging a slider, moving the color picker, or typing in one of the boxes such that a color can actually be customized and adjusted. . **Screenshots**; If applicable, add screenshots to help explain your problem. **Desktop (please complete the following information):**; - OS: Windows 10 Pro; - QuPath Version: 0.5.1. **Additional context**; Add any other context about the problem here.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1539
https://github.com/qupath/qupath/issues/1539:564,Deployability,release,release,564,"## IMPORTANT!. This section is **only** for bug reports, which **must** follow the template below. Please post any other questions to the official QuPath forum at https://forum.image.sc/tags/qupath. If in doubt, use [image.sc](https://forum.image.sc/tags/qupath). This helps us keep things organized. ## Before we begin... Before submitting your bug report, please check the following:. * [x] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; ""Custom color"" window closes when trying use a custom color either by typing in a box, clicking on a slider, or clicking on the color picker. . **To Reproduce**; Steps to reproduce the behavior:; 1. Go to ""Brightness and Contrast""; 2. Click on the color next to a channel and click ""Custom color...""; 3. Try to adjust a slider, use color picker, or type in one of the text boxes; 4. See error (window immediately closes). **Expected behavior**; It is expected that the window remain open while dragging a slider, moving the color picker, or typing in one of the boxes such that a color can actually be customized and adjusted. . **Screenshots**; If applicable, add screenshots to help explain your problem. **Desktop (please complete the following information):**; - OS: Windows 10 Pro; - QuPath Version: 0.5.1. **Additional context**; Add any other context about the problem here.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1539
https://github.com/qupath/qupath/issues/1539:760,Deployability,release,release,760,"## IMPORTANT!. This section is **only** for bug reports, which **must** follow the template below. Please post any other questions to the official QuPath forum at https://forum.image.sc/tags/qupath. If in doubt, use [image.sc](https://forum.image.sc/tags/qupath). This helps us keep things organized. ## Before we begin... Before submitting your bug report, please check the following:. * [x] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; ""Custom color"" window closes when trying use a custom color either by typing in a box, clicking on a slider, or clicking on the color picker. . **To Reproduce**; Steps to reproduce the behavior:; 1. Go to ""Brightness and Contrast""; 2. Click on the color next to a channel and click ""Custom color...""; 3. Try to adjust a slider, use color picker, or type in one of the text boxes; 4. See error (window immediately closes). **Expected behavior**; It is expected that the window remain open while dragging a slider, moving the color picker, or typing in one of the boxes such that a color can actually be customized and adjusted. . **Screenshots**; If applicable, add screenshots to help explain your problem. **Desktop (please complete the following information):**; - OS: Windows 10 Pro; - QuPath Version: 0.5.1. **Additional context**; Add any other context about the problem here.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1539
https://github.com/qupath/qupath/pull/1540:27,Testability,log,log,27,Also use log10 rather than log (thanks Alan!),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1540
https://github.com/qupath/qupath/issues/1541:245,Safety,detect,detection,245,"## Bug report. **Describe the bug**; You can enter arbitrary values in the text fields of a ParameterPanelFX, even though it knows what type(s?) the parameter accepts. **To Reproduce**; Steps to reproduce the behavior:; 1. Ctrl/Cmd + L; 3. Cell detection; 5. Tab twice/select pixel size text field; 7. Type ""dakjdpokowakdapodw"" into pixel size text field. **Expected behavior**; Parameter input fields should only accept (potentially) valid input",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1541
https://github.com/qupath/qupath/issues/1542:117,Availability,down,download,117,"Hello, I was wondering how to package the program into an exe file from the source code of QuPath? I don't mean just download the installer you provide, but I want to package it directly from source into an exe file myself. Is there any good way? How did you do it? Your answer is very important to me, thank you!",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1542
https://github.com/qupath/qupath/issues/1542:130,Deployability,install,installer,130,"Hello, I was wondering how to package the program into an exe file from the source code of QuPath? I don't mean just download the installer you provide, but I want to package it directly from source into an exe file myself. Is there any good way? How did you do it? Your answer is very important to me, thank you!",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1542
https://github.com/qupath/qupath/pull/1543:919,Availability,error,error,919,"Implement a much faster approach to computing the union of large numbers of polygons when they are not all connected, including parallelisation. The algorithm is:; 1. Extract all polygons from the input.; 2. Identify intersecting and non-intersecting polygons; 3. Group all polygons that should potentially be merged, because they intersect (directly or indirectly) with other polygons in the group; each polygon should be represented in only one group; 4. Union all the polygon groups; 5. Combine all resulting polygons into a single polygon or multipolygon. This addressing the pixel classification performance bottleneck described at https://forum.image.sc/t/can-creating-detections-from-pixel-classifier-be-made-to-run-faster/96745. When implementing this, it became clear that extremely complex polygons couldn't be displayed in the viewer because generating an `Area` object failed (ultimately with out-of-memory error). Also, `PolygonROI.getGeometry()` was slow when called repeatedly because the geometry is recomputed each time. So the PR uses a `SoftReference` to avoid this, while still allowing references to be dropped when memory is low. When the geometry isn't needed, the overhead should be avoided. This PR also addresses this problem by using JTS' shape representation instead. ## To test. ### Union of many objects. A simple test:; * Detect cells in an image; * Run the following script. ```groovy; import qupath.lib.common.Timeit; import qupath.lib.roi.GeometryTools. import static qupath.lib.scripting.QP.*. def detections = getDetectionObjects(). List<GeometryTools> geoms = detections.collect {it.getROI().getGeometry()}. def timeit = new Timeit(); .start(); def geomUnion = GeometryTools.union(geoms); println timeit.stop(). double sumArea = geoms.sum {g -> g.getArea()}; println ""Sum area: \t${sumArea}""; println ""Num geometries: \t${geoms.size()}""; def roi = GeometryTools.geometryToROI(geomUnion, ImagePlane.getDefaultPlane()); def pathClass = getPathClass(""Merged geometrie",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1543
https://github.com/qupath/qupath/pull/1543:601,Performance,perform,performance,601,"Implement a much faster approach to computing the union of large numbers of polygons when they are not all connected, including parallelisation. The algorithm is:; 1. Extract all polygons from the input.; 2. Identify intersecting and non-intersecting polygons; 3. Group all polygons that should potentially be merged, because they intersect (directly or indirectly) with other polygons in the group; each polygon should be represented in only one group; 4. Union all the polygon groups; 5. Combine all resulting polygons into a single polygon or multipolygon. This addressing the pixel classification performance bottleneck described at https://forum.image.sc/t/can-creating-detections-from-pixel-classifier-be-made-to-run-faster/96745. When implementing this, it became clear that extremely complex polygons couldn't be displayed in the viewer because generating an `Area` object failed (ultimately with out-of-memory error). Also, `PolygonROI.getGeometry()` was slow when called repeatedly because the geometry is recomputed each time. So the PR uses a `SoftReference` to avoid this, while still allowing references to be dropped when memory is low. When the geometry isn't needed, the overhead should be avoided. This PR also addresses this problem by using JTS' shape representation instead. ## To test. ### Union of many objects. A simple test:; * Detect cells in an image; * Run the following script. ```groovy; import qupath.lib.common.Timeit; import qupath.lib.roi.GeometryTools. import static qupath.lib.scripting.QP.*. def detections = getDetectionObjects(). List<GeometryTools> geoms = detections.collect {it.getROI().getGeometry()}. def timeit = new Timeit(); .start(); def geomUnion = GeometryTools.union(geoms); println timeit.stop(). double sumArea = geoms.sum {g -> g.getArea()}; println ""Sum area: \t${sumArea}""; println ""Num geometries: \t${geoms.size()}""; def roi = GeometryTools.geometryToROI(geomUnion, ImagePlane.getDefaultPlane()); def pathClass = getPathClass(""Merged geometrie",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1543
https://github.com/qupath/qupath/pull/1543:613,Performance,bottleneck,bottleneck,613,"Implement a much faster approach to computing the union of large numbers of polygons when they are not all connected, including parallelisation. The algorithm is:; 1. Extract all polygons from the input.; 2. Identify intersecting and non-intersecting polygons; 3. Group all polygons that should potentially be merged, because they intersect (directly or indirectly) with other polygons in the group; each polygon should be represented in only one group; 4. Union all the polygon groups; 5. Combine all resulting polygons into a single polygon or multipolygon. This addressing the pixel classification performance bottleneck described at https://forum.image.sc/t/can-creating-detections-from-pixel-classifier-be-made-to-run-faster/96745. When implementing this, it became clear that extremely complex polygons couldn't be displayed in the viewer because generating an `Area` object failed (ultimately with out-of-memory error). Also, `PolygonROI.getGeometry()` was slow when called repeatedly because the geometry is recomputed each time. So the PR uses a `SoftReference` to avoid this, while still allowing references to be dropped when memory is low. When the geometry isn't needed, the overhead should be avoided. This PR also addresses this problem by using JTS' shape representation instead. ## To test. ### Union of many objects. A simple test:; * Detect cells in an image; * Run the following script. ```groovy; import qupath.lib.common.Timeit; import qupath.lib.roi.GeometryTools. import static qupath.lib.scripting.QP.*. def detections = getDetectionObjects(). List<GeometryTools> geoms = detections.collect {it.getROI().getGeometry()}. def timeit = new Timeit(); .start(); def geomUnion = GeometryTools.union(geoms); println timeit.stop(). double sumArea = geoms.sum {g -> g.getArea()}; println ""Sum area: \t${sumArea}""; println ""Num geometries: \t${geoms.size()}""; def roi = GeometryTools.geometryToROI(geomUnion, ImagePlane.getDefaultPlane()); def pathClass = getPathClass(""Merged geometrie",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1543
https://github.com/qupath/qupath/pull/1543:675,Safety,detect,detections-from-pixel-classifier-be-made-to-run-faster,675,"Implement a much faster approach to computing the union of large numbers of polygons when they are not all connected, including parallelisation. The algorithm is:; 1. Extract all polygons from the input.; 2. Identify intersecting and non-intersecting polygons; 3. Group all polygons that should potentially be merged, because they intersect (directly or indirectly) with other polygons in the group; each polygon should be represented in only one group; 4. Union all the polygon groups; 5. Combine all resulting polygons into a single polygon or multipolygon. This addressing the pixel classification performance bottleneck described at https://forum.image.sc/t/can-creating-detections-from-pixel-classifier-be-made-to-run-faster/96745. When implementing this, it became clear that extremely complex polygons couldn't be displayed in the viewer because generating an `Area` object failed (ultimately with out-of-memory error). Also, `PolygonROI.getGeometry()` was slow when called repeatedly because the geometry is recomputed each time. So the PR uses a `SoftReference` to avoid this, while still allowing references to be dropped when memory is low. When the geometry isn't needed, the overhead should be avoided. This PR also addresses this problem by using JTS' shape representation instead. ## To test. ### Union of many objects. A simple test:; * Detect cells in an image; * Run the following script. ```groovy; import qupath.lib.common.Timeit; import qupath.lib.roi.GeometryTools. import static qupath.lib.scripting.QP.*. def detections = getDetectionObjects(). List<GeometryTools> geoms = detections.collect {it.getROI().getGeometry()}. def timeit = new Timeit(); .start(); def geomUnion = GeometryTools.union(geoms); println timeit.stop(). double sumArea = geoms.sum {g -> g.getArea()}; println ""Sum area: \t${sumArea}""; println ""Num geometries: \t${geoms.size()}""; def roi = GeometryTools.geometryToROI(geomUnion, ImagePlane.getDefaultPlane()); def pathClass = getPathClass(""Merged geometrie",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1543
https://github.com/qupath/qupath/pull/1543:1074,Safety,avoid,avoid,1074," are not all connected, including parallelisation. The algorithm is:; 1. Extract all polygons from the input.; 2. Identify intersecting and non-intersecting polygons; 3. Group all polygons that should potentially be merged, because they intersect (directly or indirectly) with other polygons in the group; each polygon should be represented in only one group; 4. Union all the polygon groups; 5. Combine all resulting polygons into a single polygon or multipolygon. This addressing the pixel classification performance bottleneck described at https://forum.image.sc/t/can-creating-detections-from-pixel-classifier-be-made-to-run-faster/96745. When implementing this, it became clear that extremely complex polygons couldn't be displayed in the viewer because generating an `Area` object failed (ultimately with out-of-memory error). Also, `PolygonROI.getGeometry()` was slow when called repeatedly because the geometry is recomputed each time. So the PR uses a `SoftReference` to avoid this, while still allowing references to be dropped when memory is low. When the geometry isn't needed, the overhead should be avoided. This PR also addresses this problem by using JTS' shape representation instead. ## To test. ### Union of many objects. A simple test:; * Detect cells in an image; * Run the following script. ```groovy; import qupath.lib.common.Timeit; import qupath.lib.roi.GeometryTools. import static qupath.lib.scripting.QP.*. def detections = getDetectionObjects(). List<GeometryTools> geoms = detections.collect {it.getROI().getGeometry()}. def timeit = new Timeit(); .start(); def geomUnion = GeometryTools.union(geoms); println timeit.stop(). double sumArea = geoms.sum {g -> g.getArea()}; println ""Sum area: \t${sumArea}""; println ""Num geometries: \t${geoms.size()}""; def roi = GeometryTools.geometryToROI(geomUnion, ImagePlane.getDefaultPlane()); def pathClass = getPathClass(""Merged geometries""); removeObjects(getAnnotationObjects().findAll(p -> p.getPathClass() == pathClass), true);",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1543
https://github.com/qupath/qupath/pull/1543:1207,Safety,avoid,avoided,1207,"gons from the input.; 2. Identify intersecting and non-intersecting polygons; 3. Group all polygons that should potentially be merged, because they intersect (directly or indirectly) with other polygons in the group; each polygon should be represented in only one group; 4. Union all the polygon groups; 5. Combine all resulting polygons into a single polygon or multipolygon. This addressing the pixel classification performance bottleneck described at https://forum.image.sc/t/can-creating-detections-from-pixel-classifier-be-made-to-run-faster/96745. When implementing this, it became clear that extremely complex polygons couldn't be displayed in the viewer because generating an `Area` object failed (ultimately with out-of-memory error). Also, `PolygonROI.getGeometry()` was slow when called repeatedly because the geometry is recomputed each time. So the PR uses a `SoftReference` to avoid this, while still allowing references to be dropped when memory is low. When the geometry isn't needed, the overhead should be avoided. This PR also addresses this problem by using JTS' shape representation instead. ## To test. ### Union of many objects. A simple test:; * Detect cells in an image; * Run the following script. ```groovy; import qupath.lib.common.Timeit; import qupath.lib.roi.GeometryTools. import static qupath.lib.scripting.QP.*. def detections = getDetectionObjects(). List<GeometryTools> geoms = detections.collect {it.getROI().getGeometry()}. def timeit = new Timeit(); .start(); def geomUnion = GeometryTools.union(geoms); println timeit.stop(). double sumArea = geoms.sum {g -> g.getArea()}; println ""Sum area: \t${sumArea}""; println ""Num geometries: \t${geoms.size()}""; def roi = GeometryTools.geometryToROI(geomUnion, ImagePlane.getDefaultPlane()); def pathClass = getPathClass(""Merged geometries""); removeObjects(getAnnotationObjects().findAll(p -> p.getPathClass() == pathClass), true); addObject(PathObjects.createAnnotationObject(roi, pathClass)); ```. ### Pixel classifica",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1543
https://github.com/qupath/qupath/pull/1543:1353,Safety,Detect,Detect,1353," other polygons in the group; each polygon should be represented in only one group; 4. Union all the polygon groups; 5. Combine all resulting polygons into a single polygon or multipolygon. This addressing the pixel classification performance bottleneck described at https://forum.image.sc/t/can-creating-detections-from-pixel-classifier-be-made-to-run-faster/96745. When implementing this, it became clear that extremely complex polygons couldn't be displayed in the viewer because generating an `Area` object failed (ultimately with out-of-memory error). Also, `PolygonROI.getGeometry()` was slow when called repeatedly because the geometry is recomputed each time. So the PR uses a `SoftReference` to avoid this, while still allowing references to be dropped when memory is low. When the geometry isn't needed, the overhead should be avoided. This PR also addresses this problem by using JTS' shape representation instead. ## To test. ### Union of many objects. A simple test:; * Detect cells in an image; * Run the following script. ```groovy; import qupath.lib.common.Timeit; import qupath.lib.roi.GeometryTools. import static qupath.lib.scripting.QP.*. def detections = getDetectionObjects(). List<GeometryTools> geoms = detections.collect {it.getROI().getGeometry()}. def timeit = new Timeit(); .start(); def geomUnion = GeometryTools.union(geoms); println timeit.stop(). double sumArea = geoms.sum {g -> g.getArea()}; println ""Sum area: \t${sumArea}""; println ""Num geometries: \t${geoms.size()}""; def roi = GeometryTools.geometryToROI(geomUnion, ImagePlane.getDefaultPlane()); def pathClass = getPathClass(""Merged geometries""); removeObjects(getAnnotationObjects().findAll(p -> p.getPathClass() == pathClass), true); addObject(PathObjects.createAnnotationObject(roi, pathClass)); ```. ### Pixel classification. One approach to test with CMU-1.svs is to save the following pixel classifier:; * [Nuclei.json](https://github.com/user-attachments/files/15809355/Nuclei.json). and run a simple scr",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1543
https://github.com/qupath/qupath/pull/1543:1533,Safety,detect,detections,1533,"resulting polygons into a single polygon or multipolygon. This addressing the pixel classification performance bottleneck described at https://forum.image.sc/t/can-creating-detections-from-pixel-classifier-be-made-to-run-faster/96745. When implementing this, it became clear that extremely complex polygons couldn't be displayed in the viewer because generating an `Area` object failed (ultimately with out-of-memory error). Also, `PolygonROI.getGeometry()` was slow when called repeatedly because the geometry is recomputed each time. So the PR uses a `SoftReference` to avoid this, while still allowing references to be dropped when memory is low. When the geometry isn't needed, the overhead should be avoided. This PR also addresses this problem by using JTS' shape representation instead. ## To test. ### Union of many objects. A simple test:; * Detect cells in an image; * Run the following script. ```groovy; import qupath.lib.common.Timeit; import qupath.lib.roi.GeometryTools. import static qupath.lib.scripting.QP.*. def detections = getDetectionObjects(). List<GeometryTools> geoms = detections.collect {it.getROI().getGeometry()}. def timeit = new Timeit(); .start(); def geomUnion = GeometryTools.union(geoms); println timeit.stop(). double sumArea = geoms.sum {g -> g.getArea()}; println ""Sum area: \t${sumArea}""; println ""Num geometries: \t${geoms.size()}""; def roi = GeometryTools.geometryToROI(geomUnion, ImagePlane.getDefaultPlane()); def pathClass = getPathClass(""Merged geometries""); removeObjects(getAnnotationObjects().findAll(p -> p.getPathClass() == pathClass), true); addObject(PathObjects.createAnnotationObject(roi, pathClass)); ```. ### Pixel classification. One approach to test with CMU-1.svs is to save the following pixel classifier:; * [Nuclei.json](https://github.com/user-attachments/files/15809355/Nuclei.json). and run a simple script to generate detections in a large region, e.g.; ```groovy; createDetectionsFromPixelClassifier(""Nuclei"", 5.0, 5.0, ""SPLIT""); ```",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1543
https://github.com/qupath/qupath/pull/1543:1597,Safety,detect,detections,1597,"resulting polygons into a single polygon or multipolygon. This addressing the pixel classification performance bottleneck described at https://forum.image.sc/t/can-creating-detections-from-pixel-classifier-be-made-to-run-faster/96745. When implementing this, it became clear that extremely complex polygons couldn't be displayed in the viewer because generating an `Area` object failed (ultimately with out-of-memory error). Also, `PolygonROI.getGeometry()` was slow when called repeatedly because the geometry is recomputed each time. So the PR uses a `SoftReference` to avoid this, while still allowing references to be dropped when memory is low. When the geometry isn't needed, the overhead should be avoided. This PR also addresses this problem by using JTS' shape representation instead. ## To test. ### Union of many objects. A simple test:; * Detect cells in an image; * Run the following script. ```groovy; import qupath.lib.common.Timeit; import qupath.lib.roi.GeometryTools. import static qupath.lib.scripting.QP.*. def detections = getDetectionObjects(). List<GeometryTools> geoms = detections.collect {it.getROI().getGeometry()}. def timeit = new Timeit(); .start(); def geomUnion = GeometryTools.union(geoms); println timeit.stop(). double sumArea = geoms.sum {g -> g.getArea()}; println ""Sum area: \t${sumArea}""; println ""Num geometries: \t${geoms.size()}""; def roi = GeometryTools.geometryToROI(geomUnion, ImagePlane.getDefaultPlane()); def pathClass = getPathClass(""Merged geometries""); removeObjects(getAnnotationObjects().findAll(p -> p.getPathClass() == pathClass), true); addObject(PathObjects.createAnnotationObject(roi, pathClass)); ```. ### Pixel classification. One approach to test with CMU-1.svs is to save the following pixel classifier:; * [Nuclei.json](https://github.com/user-attachments/files/15809355/Nuclei.json). and run a simple script to generate detections in a large region, e.g.; ```groovy; createDetectionsFromPixelClassifier(""Nuclei"", 5.0, 5.0, ""SPLIT""); ```",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1543
https://github.com/qupath/qupath/pull/1543:2386,Safety,detect,detections,2386,"resulting polygons into a single polygon or multipolygon. This addressing the pixel classification performance bottleneck described at https://forum.image.sc/t/can-creating-detections-from-pixel-classifier-be-made-to-run-faster/96745. When implementing this, it became clear that extremely complex polygons couldn't be displayed in the viewer because generating an `Area` object failed (ultimately with out-of-memory error). Also, `PolygonROI.getGeometry()` was slow when called repeatedly because the geometry is recomputed each time. So the PR uses a `SoftReference` to avoid this, while still allowing references to be dropped when memory is low. When the geometry isn't needed, the overhead should be avoided. This PR also addresses this problem by using JTS' shape representation instead. ## To test. ### Union of many objects. A simple test:; * Detect cells in an image; * Run the following script. ```groovy; import qupath.lib.common.Timeit; import qupath.lib.roi.GeometryTools. import static qupath.lib.scripting.QP.*. def detections = getDetectionObjects(). List<GeometryTools> geoms = detections.collect {it.getROI().getGeometry()}. def timeit = new Timeit(); .start(); def geomUnion = GeometryTools.union(geoms); println timeit.stop(). double sumArea = geoms.sum {g -> g.getArea()}; println ""Sum area: \t${sumArea}""; println ""Num geometries: \t${geoms.size()}""; def roi = GeometryTools.geometryToROI(geomUnion, ImagePlane.getDefaultPlane()); def pathClass = getPathClass(""Merged geometries""); removeObjects(getAnnotationObjects().findAll(p -> p.getPathClass() == pathClass), true); addObject(PathObjects.createAnnotationObject(roi, pathClass)); ```. ### Pixel classification. One approach to test with CMU-1.svs is to save the following pixel classifier:; * [Nuclei.json](https://github.com/user-attachments/files/15809355/Nuclei.json). and run a simple script to generate detections in a large region, e.g.; ```groovy; createDetectionsFromPixelClassifier(""Nuclei"", 5.0, 5.0, ""SPLIT""); ```",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1543
https://github.com/qupath/qupath/pull/1543:1302,Testability,test,test,1302,"ially be merged, because they intersect (directly or indirectly) with other polygons in the group; each polygon should be represented in only one group; 4. Union all the polygon groups; 5. Combine all resulting polygons into a single polygon or multipolygon. This addressing the pixel classification performance bottleneck described at https://forum.image.sc/t/can-creating-detections-from-pixel-classifier-be-made-to-run-faster/96745. When implementing this, it became clear that extremely complex polygons couldn't be displayed in the viewer because generating an `Area` object failed (ultimately with out-of-memory error). Also, `PolygonROI.getGeometry()` was slow when called repeatedly because the geometry is recomputed each time. So the PR uses a `SoftReference` to avoid this, while still allowing references to be dropped when memory is low. When the geometry isn't needed, the overhead should be avoided. This PR also addresses this problem by using JTS' shape representation instead. ## To test. ### Union of many objects. A simple test:; * Detect cells in an image; * Run the following script. ```groovy; import qupath.lib.common.Timeit; import qupath.lib.roi.GeometryTools. import static qupath.lib.scripting.QP.*. def detections = getDetectionObjects(). List<GeometryTools> geoms = detections.collect {it.getROI().getGeometry()}. def timeit = new Timeit(); .start(); def geomUnion = GeometryTools.union(geoms); println timeit.stop(). double sumArea = geoms.sum {g -> g.getArea()}; println ""Sum area: \t${sumArea}""; println ""Num geometries: \t${geoms.size()}""; def roi = GeometryTools.geometryToROI(geomUnion, ImagePlane.getDefaultPlane()); def pathClass = getPathClass(""Merged geometries""); removeObjects(getAnnotationObjects().findAll(p -> p.getPathClass() == pathClass), true); addObject(PathObjects.createAnnotationObject(roi, pathClass)); ```. ### Pixel classification. One approach to test with CMU-1.svs is to save the following pixel classifier:; * [Nuclei.json](https://github.c",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1543
https://github.com/qupath/qupath/pull/1543:1344,Testability,test,test,1344," other polygons in the group; each polygon should be represented in only one group; 4. Union all the polygon groups; 5. Combine all resulting polygons into a single polygon or multipolygon. This addressing the pixel classification performance bottleneck described at https://forum.image.sc/t/can-creating-detections-from-pixel-classifier-be-made-to-run-faster/96745. When implementing this, it became clear that extremely complex polygons couldn't be displayed in the viewer because generating an `Area` object failed (ultimately with out-of-memory error). Also, `PolygonROI.getGeometry()` was slow when called repeatedly because the geometry is recomputed each time. So the PR uses a `SoftReference` to avoid this, while still allowing references to be dropped when memory is low. When the geometry isn't needed, the overhead should be avoided. This PR also addresses this problem by using JTS' shape representation instead. ## To test. ### Union of many objects. A simple test:; * Detect cells in an image; * Run the following script. ```groovy; import qupath.lib.common.Timeit; import qupath.lib.roi.GeometryTools. import static qupath.lib.scripting.QP.*. def detections = getDetectionObjects(). List<GeometryTools> geoms = detections.collect {it.getROI().getGeometry()}. def timeit = new Timeit(); .start(); def geomUnion = GeometryTools.union(geoms); println timeit.stop(). double sumArea = geoms.sum {g -> g.getArea()}; println ""Sum area: \t${sumArea}""; println ""Num geometries: \t${geoms.size()}""; def roi = GeometryTools.geometryToROI(geomUnion, ImagePlane.getDefaultPlane()); def pathClass = getPathClass(""Merged geometries""); removeObjects(getAnnotationObjects().findAll(p -> p.getPathClass() == pathClass), true); addObject(PathObjects.createAnnotationObject(roi, pathClass)); ```. ### Pixel classification. One approach to test with CMU-1.svs is to save the following pixel classifier:; * [Nuclei.json](https://github.com/user-attachments/files/15809355/Nuclei.json). and run a simple scr",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1543
https://github.com/qupath/qupath/pull/1543:2205,Testability,test,test,2205,"resulting polygons into a single polygon or multipolygon. This addressing the pixel classification performance bottleneck described at https://forum.image.sc/t/can-creating-detections-from-pixel-classifier-be-made-to-run-faster/96745. When implementing this, it became clear that extremely complex polygons couldn't be displayed in the viewer because generating an `Area` object failed (ultimately with out-of-memory error). Also, `PolygonROI.getGeometry()` was slow when called repeatedly because the geometry is recomputed each time. So the PR uses a `SoftReference` to avoid this, while still allowing references to be dropped when memory is low. When the geometry isn't needed, the overhead should be avoided. This PR also addresses this problem by using JTS' shape representation instead. ## To test. ### Union of many objects. A simple test:; * Detect cells in an image; * Run the following script. ```groovy; import qupath.lib.common.Timeit; import qupath.lib.roi.GeometryTools. import static qupath.lib.scripting.QP.*. def detections = getDetectionObjects(). List<GeometryTools> geoms = detections.collect {it.getROI().getGeometry()}. def timeit = new Timeit(); .start(); def geomUnion = GeometryTools.union(geoms); println timeit.stop(). double sumArea = geoms.sum {g -> g.getArea()}; println ""Sum area: \t${sumArea}""; println ""Num geometries: \t${geoms.size()}""; def roi = GeometryTools.geometryToROI(geomUnion, ImagePlane.getDefaultPlane()); def pathClass = getPathClass(""Merged geometries""); removeObjects(getAnnotationObjects().findAll(p -> p.getPathClass() == pathClass), true); addObject(PathObjects.createAnnotationObject(roi, pathClass)); ```. ### Pixel classification. One approach to test with CMU-1.svs is to save the following pixel classifier:; * [Nuclei.json](https://github.com/user-attachments/files/15809355/Nuclei.json). and run a simple script to generate detections in a large region, e.g.; ```groovy; createDetectionsFromPixelClassifier(""Nuclei"", 5.0, 5.0, ""SPLIT""); ```",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1543
https://github.com/qupath/qupath/pull/1543:771,Usability,clear,clear,771,"Implement a much faster approach to computing the union of large numbers of polygons when they are not all connected, including parallelisation. The algorithm is:; 1. Extract all polygons from the input.; 2. Identify intersecting and non-intersecting polygons; 3. Group all polygons that should potentially be merged, because they intersect (directly or indirectly) with other polygons in the group; each polygon should be represented in only one group; 4. Union all the polygon groups; 5. Combine all resulting polygons into a single polygon or multipolygon. This addressing the pixel classification performance bottleneck described at https://forum.image.sc/t/can-creating-detections-from-pixel-classifier-be-made-to-run-faster/96745. When implementing this, it became clear that extremely complex polygons couldn't be displayed in the viewer because generating an `Area` object failed (ultimately with out-of-memory error). Also, `PolygonROI.getGeometry()` was slow when called repeatedly because the geometry is recomputed each time. So the PR uses a `SoftReference` to avoid this, while still allowing references to be dropped when memory is low. When the geometry isn't needed, the overhead should be avoided. This PR also addresses this problem by using JTS' shape representation instead. ## To test. ### Union of many objects. A simple test:; * Detect cells in an image; * Run the following script. ```groovy; import qupath.lib.common.Timeit; import qupath.lib.roi.GeometryTools. import static qupath.lib.scripting.QP.*. def detections = getDetectionObjects(). List<GeometryTools> geoms = detections.collect {it.getROI().getGeometry()}. def timeit = new Timeit(); .start(); def geomUnion = GeometryTools.union(geoms); println timeit.stop(). double sumArea = geoms.sum {g -> g.getArea()}; println ""Sum area: \t${sumArea}""; println ""Num geometries: \t${geoms.size()}""; def roi = GeometryTools.geometryToROI(geomUnion, ImagePlane.getDefaultPlane()); def pathClass = getPathClass(""Merged geometrie",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1543
https://github.com/qupath/qupath/pull/1543:1337,Usability,simpl,simple,1337," other polygons in the group; each polygon should be represented in only one group; 4. Union all the polygon groups; 5. Combine all resulting polygons into a single polygon or multipolygon. This addressing the pixel classification performance bottleneck described at https://forum.image.sc/t/can-creating-detections-from-pixel-classifier-be-made-to-run-faster/96745. When implementing this, it became clear that extremely complex polygons couldn't be displayed in the viewer because generating an `Area` object failed (ultimately with out-of-memory error). Also, `PolygonROI.getGeometry()` was slow when called repeatedly because the geometry is recomputed each time. So the PR uses a `SoftReference` to avoid this, while still allowing references to be dropped when memory is low. When the geometry isn't needed, the overhead should be avoided. This PR also addresses this problem by using JTS' shape representation instead. ## To test. ### Union of many objects. A simple test:; * Detect cells in an image; * Run the following script. ```groovy; import qupath.lib.common.Timeit; import qupath.lib.roi.GeometryTools. import static qupath.lib.scripting.QP.*. def detections = getDetectionObjects(). List<GeometryTools> geoms = detections.collect {it.getROI().getGeometry()}. def timeit = new Timeit(); .start(); def geomUnion = GeometryTools.union(geoms); println timeit.stop(). double sumArea = geoms.sum {g -> g.getArea()}; println ""Sum area: \t${sumArea}""; println ""Num geometries: \t${geoms.size()}""; def roi = GeometryTools.geometryToROI(geomUnion, ImagePlane.getDefaultPlane()); def pathClass = getPathClass(""Merged geometries""); removeObjects(getAnnotationObjects().findAll(p -> p.getPathClass() == pathClass), true); addObject(PathObjects.createAnnotationObject(roi, pathClass)); ```. ### Pixel classification. One approach to test with CMU-1.svs is to save the following pixel classifier:; * [Nuclei.json](https://github.com/user-attachments/files/15809355/Nuclei.json). and run a simple scr",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1543
https://github.com/qupath/qupath/pull/1543:2360,Usability,simpl,simple,2360,"resulting polygons into a single polygon or multipolygon. This addressing the pixel classification performance bottleneck described at https://forum.image.sc/t/can-creating-detections-from-pixel-classifier-be-made-to-run-faster/96745. When implementing this, it became clear that extremely complex polygons couldn't be displayed in the viewer because generating an `Area` object failed (ultimately with out-of-memory error). Also, `PolygonROI.getGeometry()` was slow when called repeatedly because the geometry is recomputed each time. So the PR uses a `SoftReference` to avoid this, while still allowing references to be dropped when memory is low. When the geometry isn't needed, the overhead should be avoided. This PR also addresses this problem by using JTS' shape representation instead. ## To test. ### Union of many objects. A simple test:; * Detect cells in an image; * Run the following script. ```groovy; import qupath.lib.common.Timeit; import qupath.lib.roi.GeometryTools. import static qupath.lib.scripting.QP.*. def detections = getDetectionObjects(). List<GeometryTools> geoms = detections.collect {it.getROI().getGeometry()}. def timeit = new Timeit(); .start(); def geomUnion = GeometryTools.union(geoms); println timeit.stop(). double sumArea = geoms.sum {g -> g.getArea()}; println ""Sum area: \t${sumArea}""; println ""Num geometries: \t${geoms.size()}""; def roi = GeometryTools.geometryToROI(geomUnion, ImagePlane.getDefaultPlane()); def pathClass = getPathClass(""Merged geometries""); removeObjects(getAnnotationObjects().findAll(p -> p.getPathClass() == pathClass), true); addObject(PathObjects.createAnnotationObject(roi, pathClass)); ```. ### Pixel classification. One approach to test with CMU-1.svs is to save the following pixel classifier:; * [Nuclei.json](https://github.com/user-attachments/files/15809355/Nuclei.json). and run a simple script to generate detections in a large region, e.g.; ```groovy; createDetectionsFromPixelClassifier(""Nuclei"", 5.0, 5.0, ""SPLIT""); ```",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1543
https://github.com/qupath/qupath/pull/1544:685,Deployability,update,update,685,"First draft implementation of two measurement classifier and scatter plots in measurement viewer (along with histograms). Ideally I think these two panes should be merged, with an X and Y dropdown. If X or Y alone is selected, or if ==Y, then do a histogram. If both are selected and different, do a scatter plot. Saves space and I doubt many people will want to see histogram & scatter plot at the same time. Two measurement classifier currently uses composite classifier, but really it should be something like a ""union"" classifier... or some kind of logical operand classifier. But I'm not currently sure what or how. The point colours on the scatter plot should also probably live update. The code here is horrendous and needs to be refactored in both cases, but works as a POC.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1544
https://github.com/qupath/qupath/pull/1544:737,Modifiability,refactor,refactored,737,"First draft implementation of two measurement classifier and scatter plots in measurement viewer (along with histograms). Ideally I think these two panes should be merged, with an X and Y dropdown. If X or Y alone is selected, or if ==Y, then do a histogram. If both are selected and different, do a scatter plot. Saves space and I doubt many people will want to see histogram & scatter plot at the same time. Two measurement classifier currently uses composite classifier, but really it should be something like a ""union"" classifier... or some kind of logical operand classifier. But I'm not currently sure what or how. The point colours on the scatter plot should also probably live update. The code here is horrendous and needs to be refactored in both cases, but works as a POC.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1544
https://github.com/qupath/qupath/pull/1544:553,Testability,log,logical,553,"First draft implementation of two measurement classifier and scatter plots in measurement viewer (along with histograms). Ideally I think these two panes should be merged, with an X and Y dropdown. If X or Y alone is selected, or if ==Y, then do a histogram. If both are selected and different, do a scatter plot. Saves space and I doubt many people will want to see histogram & scatter plot at the same time. Two measurement classifier currently uses composite classifier, but really it should be something like a ""union"" classifier... or some kind of logical operand classifier. But I'm not currently sure what or how. The point colours on the scatter plot should also probably live update. The code here is horrendous and needs to be refactored in both cases, but works as a POC.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1544
https://github.com/qupath/qupath/issues/1547:104,Deployability,configurat,configuration,104,"Hi, I'm getting the following bug when launching QuPath from a ssh server:. WARNING: Unsupported JavaFX configuration: classes were loaded from 'unnamed module @62379589'; Exception in thread ""main"" java.lang.UnsupportedOperationException: Unable to open DISPLAY; at com.sun.glass.ui.gtk.GtkApplication.lambda$new$5(GtkApplication.java:165); at java.base/java.security.AccessController.doPrivileged(Unknown Source); at com.sun.glass.ui.gtk.GtkApplication.<init>(GtkApplication.java:163); at com.sun.glass.ui.gtk.GtkPlatformFactory.createApplication(GtkPlatformFactory.java:40); at com.sun.glass.ui.Application.run(Application.java:145); at com.sun.javafx.tk.quantum.QuantumToolkit.startup(QuantumToolkit.java:290); at com.sun.javafx.application.PlatformImpl.startup(PlatformImpl.java:292); at com.sun.javafx.application.PlatformImpl.startup(PlatformImpl.java:162); at com.sun.javafx.application.LauncherImpl.startToolkit(LauncherImpl.java:651); at com.sun.javafx.application.LauncherImpl.launchApplication1(LauncherImpl.java:671); at com.sun.javafx.application.LauncherImpl.lambda$launchApplication$2(LauncherImpl.java:196); at java.base/java.lang.Thread.run(Unknown Source). Anyone knows why this is happening?. Using latest version QuPath and JDK 17, but nothing seems to work",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1547
https://github.com/qupath/qupath/issues/1547:104,Modifiability,config,configuration,104,"Hi, I'm getting the following bug when launching QuPath from a ssh server:. WARNING: Unsupported JavaFX configuration: classes were loaded from 'unnamed module @62379589'; Exception in thread ""main"" java.lang.UnsupportedOperationException: Unable to open DISPLAY; at com.sun.glass.ui.gtk.GtkApplication.lambda$new$5(GtkApplication.java:165); at java.base/java.security.AccessController.doPrivileged(Unknown Source); at com.sun.glass.ui.gtk.GtkApplication.<init>(GtkApplication.java:163); at com.sun.glass.ui.gtk.GtkPlatformFactory.createApplication(GtkPlatformFactory.java:40); at com.sun.glass.ui.Application.run(Application.java:145); at com.sun.javafx.tk.quantum.QuantumToolkit.startup(QuantumToolkit.java:290); at com.sun.javafx.application.PlatformImpl.startup(PlatformImpl.java:292); at com.sun.javafx.application.PlatformImpl.startup(PlatformImpl.java:162); at com.sun.javafx.application.LauncherImpl.startToolkit(LauncherImpl.java:651); at com.sun.javafx.application.LauncherImpl.launchApplication1(LauncherImpl.java:671); at com.sun.javafx.application.LauncherImpl.lambda$launchApplication$2(LauncherImpl.java:196); at java.base/java.lang.Thread.run(Unknown Source). Anyone knows why this is happening?. Using latest version QuPath and JDK 17, but nothing seems to work",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1547
https://github.com/qupath/qupath/issues/1547:132,Performance,load,loaded,132,"Hi, I'm getting the following bug when launching QuPath from a ssh server:. WARNING: Unsupported JavaFX configuration: classes were loaded from 'unnamed module @62379589'; Exception in thread ""main"" java.lang.UnsupportedOperationException: Unable to open DISPLAY; at com.sun.glass.ui.gtk.GtkApplication.lambda$new$5(GtkApplication.java:165); at java.base/java.security.AccessController.doPrivileged(Unknown Source); at com.sun.glass.ui.gtk.GtkApplication.<init>(GtkApplication.java:163); at com.sun.glass.ui.gtk.GtkPlatformFactory.createApplication(GtkPlatformFactory.java:40); at com.sun.glass.ui.Application.run(Application.java:145); at com.sun.javafx.tk.quantum.QuantumToolkit.startup(QuantumToolkit.java:290); at com.sun.javafx.application.PlatformImpl.startup(PlatformImpl.java:292); at com.sun.javafx.application.PlatformImpl.startup(PlatformImpl.java:162); at com.sun.javafx.application.LauncherImpl.startToolkit(LauncherImpl.java:651); at com.sun.javafx.application.LauncherImpl.launchApplication1(LauncherImpl.java:671); at com.sun.javafx.application.LauncherImpl.lambda$launchApplication$2(LauncherImpl.java:196); at java.base/java.lang.Thread.run(Unknown Source). Anyone knows why this is happening?. Using latest version QuPath and JDK 17, but nothing seems to work",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1547
https://github.com/qupath/qupath/issues/1547:360,Security,secur,security,360,"Hi, I'm getting the following bug when launching QuPath from a ssh server:. WARNING: Unsupported JavaFX configuration: classes were loaded from 'unnamed module @62379589'; Exception in thread ""main"" java.lang.UnsupportedOperationException: Unable to open DISPLAY; at com.sun.glass.ui.gtk.GtkApplication.lambda$new$5(GtkApplication.java:165); at java.base/java.security.AccessController.doPrivileged(Unknown Source); at com.sun.glass.ui.gtk.GtkApplication.<init>(GtkApplication.java:163); at com.sun.glass.ui.gtk.GtkPlatformFactory.createApplication(GtkPlatformFactory.java:40); at com.sun.glass.ui.Application.run(Application.java:145); at com.sun.javafx.tk.quantum.QuantumToolkit.startup(QuantumToolkit.java:290); at com.sun.javafx.application.PlatformImpl.startup(PlatformImpl.java:292); at com.sun.javafx.application.PlatformImpl.startup(PlatformImpl.java:162); at com.sun.javafx.application.LauncherImpl.startToolkit(LauncherImpl.java:651); at com.sun.javafx.application.LauncherImpl.launchApplication1(LauncherImpl.java:671); at com.sun.javafx.application.LauncherImpl.lambda$launchApplication$2(LauncherImpl.java:196); at java.base/java.lang.Thread.run(Unknown Source). Anyone knows why this is happening?. Using latest version QuPath and JDK 17, but nothing seems to work",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1547
https://github.com/qupath/qupath/issues/1547:369,Security,Access,AccessController,369,"Hi, I'm getting the following bug when launching QuPath from a ssh server:. WARNING: Unsupported JavaFX configuration: classes were loaded from 'unnamed module @62379589'; Exception in thread ""main"" java.lang.UnsupportedOperationException: Unable to open DISPLAY; at com.sun.glass.ui.gtk.GtkApplication.lambda$new$5(GtkApplication.java:165); at java.base/java.security.AccessController.doPrivileged(Unknown Source); at com.sun.glass.ui.gtk.GtkApplication.<init>(GtkApplication.java:163); at com.sun.glass.ui.gtk.GtkPlatformFactory.createApplication(GtkPlatformFactory.java:40); at com.sun.glass.ui.Application.run(Application.java:145); at com.sun.javafx.tk.quantum.QuantumToolkit.startup(QuantumToolkit.java:290); at com.sun.javafx.application.PlatformImpl.startup(PlatformImpl.java:292); at com.sun.javafx.application.PlatformImpl.startup(PlatformImpl.java:162); at com.sun.javafx.application.LauncherImpl.startToolkit(LauncherImpl.java:651); at com.sun.javafx.application.LauncherImpl.launchApplication1(LauncherImpl.java:671); at com.sun.javafx.application.LauncherImpl.lambda$launchApplication$2(LauncherImpl.java:196); at java.base/java.lang.Thread.run(Unknown Source). Anyone knows why this is happening?. Using latest version QuPath and JDK 17, but nothing seems to work",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1547
https://github.com/qupath/qupath/pull/1548:14,Testability,test,test,14,Initial PR to test https://github.com/qupath/qupath-fxtras/pull/34 in action. Applied only to a few relevant windows for now.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1548
https://github.com/qupath/qupath/pull/1549:42,Safety,detect,detections-from-pixel-classifier-be-made-to-run-faster,42,"See https://forum.image.sc/t/can-creating-detections-from-pixel-classifier-be-made-to-run-faster/96745/25 Bio-Formats 7.2.0 handles pyramid levels differently for SVS images, which would break compatibility with the metadata stored in QuPath projects. Basically, the levels stored in the project would override the levels that Bio-Formats expects to find. Consequence: if a project was created in v0.5.1 (or earlier), including SVS images read using Bio-Formats, these images could not be opened in v0.6.0. This PR logs a warning when this occurs, and uses the 'new' pyramid levels are used instead of the ones stored in the saved metadata.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1549
https://github.com/qupath/qupath/pull/1549:515,Testability,log,logs,515,"See https://forum.image.sc/t/can-creating-detections-from-pixel-classifier-be-made-to-run-faster/96745/25 Bio-Formats 7.2.0 handles pyramid levels differently for SVS images, which would break compatibility with the metadata stored in QuPath projects. Basically, the levels stored in the project would override the levels that Bio-Formats expects to find. Consequence: if a project was created in v0.5.1 (or earlier), including SVS images read using Bio-Formats, these images could not be opened in v0.6.0. This PR logs a warning when this occurs, and uses the 'new' pyramid levels are used instead of the ones stored in the saved metadata.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1549
https://github.com/qupath/qupath/issues/1550:48,Safety,detect,detections,48,"## Bug report. **Describe the bug**; If we have detections and cell objects and try to run Detection Centroid Distances 2D, it will only output a result for the cells and not the detections. . **To Reproduce**; Steps to reproduce the behavior:; 1. Annotate a small region and use cell detection to create cells (with expansion) and classify them as ""Stroma""; 2. Annotate another region (It can overlap with the other, but it does not matter) and detect cells **without** expansion, label them as ""Other""; 3. Use **Detection Centroid Distances 2D** with the defaults; 4. If you look at the Cell objects, they have a **Distance to detection with Stroma um**; 5. If you look at the Detections (not expanded cells) there is no measurement. If you repeat the steps above but make only **Cell objects** or **Detections without expansion** (Where both are of the same type) then it works as expected, meaning both PathObjects have the distance measurements. **Expected behavior**; I would expect the Detection Centroid Distances 2D would work for heterogeneous groups (cells and detections) as cells are detections too. **Desktop (please complete the following information):**; - OS: Win 11; - QuPath Version: 0.5.1",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550
https://github.com/qupath/qupath/issues/1550:91,Safety,Detect,Detection,91,"## Bug report. **Describe the bug**; If we have detections and cell objects and try to run Detection Centroid Distances 2D, it will only output a result for the cells and not the detections. . **To Reproduce**; Steps to reproduce the behavior:; 1. Annotate a small region and use cell detection to create cells (with expansion) and classify them as ""Stroma""; 2. Annotate another region (It can overlap with the other, but it does not matter) and detect cells **without** expansion, label them as ""Other""; 3. Use **Detection Centroid Distances 2D** with the defaults; 4. If you look at the Cell objects, they have a **Distance to detection with Stroma um**; 5. If you look at the Detections (not expanded cells) there is no measurement. If you repeat the steps above but make only **Cell objects** or **Detections without expansion** (Where both are of the same type) then it works as expected, meaning both PathObjects have the distance measurements. **Expected behavior**; I would expect the Detection Centroid Distances 2D would work for heterogeneous groups (cells and detections) as cells are detections too. **Desktop (please complete the following information):**; - OS: Win 11; - QuPath Version: 0.5.1",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550
https://github.com/qupath/qupath/issues/1550:179,Safety,detect,detections,179,"## Bug report. **Describe the bug**; If we have detections and cell objects and try to run Detection Centroid Distances 2D, it will only output a result for the cells and not the detections. . **To Reproduce**; Steps to reproduce the behavior:; 1. Annotate a small region and use cell detection to create cells (with expansion) and classify them as ""Stroma""; 2. Annotate another region (It can overlap with the other, but it does not matter) and detect cells **without** expansion, label them as ""Other""; 3. Use **Detection Centroid Distances 2D** with the defaults; 4. If you look at the Cell objects, they have a **Distance to detection with Stroma um**; 5. If you look at the Detections (not expanded cells) there is no measurement. If you repeat the steps above but make only **Cell objects** or **Detections without expansion** (Where both are of the same type) then it works as expected, meaning both PathObjects have the distance measurements. **Expected behavior**; I would expect the Detection Centroid Distances 2D would work for heterogeneous groups (cells and detections) as cells are detections too. **Desktop (please complete the following information):**; - OS: Win 11; - QuPath Version: 0.5.1",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550
https://github.com/qupath/qupath/issues/1550:285,Safety,detect,detection,285,"## Bug report. **Describe the bug**; If we have detections and cell objects and try to run Detection Centroid Distances 2D, it will only output a result for the cells and not the detections. . **To Reproduce**; Steps to reproduce the behavior:; 1. Annotate a small region and use cell detection to create cells (with expansion) and classify them as ""Stroma""; 2. Annotate another region (It can overlap with the other, but it does not matter) and detect cells **without** expansion, label them as ""Other""; 3. Use **Detection Centroid Distances 2D** with the defaults; 4. If you look at the Cell objects, they have a **Distance to detection with Stroma um**; 5. If you look at the Detections (not expanded cells) there is no measurement. If you repeat the steps above but make only **Cell objects** or **Detections without expansion** (Where both are of the same type) then it works as expected, meaning both PathObjects have the distance measurements. **Expected behavior**; I would expect the Detection Centroid Distances 2D would work for heterogeneous groups (cells and detections) as cells are detections too. **Desktop (please complete the following information):**; - OS: Win 11; - QuPath Version: 0.5.1",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550
https://github.com/qupath/qupath/issues/1550:446,Safety,detect,detect,446,"## Bug report. **Describe the bug**; If we have detections and cell objects and try to run Detection Centroid Distances 2D, it will only output a result for the cells and not the detections. . **To Reproduce**; Steps to reproduce the behavior:; 1. Annotate a small region and use cell detection to create cells (with expansion) and classify them as ""Stroma""; 2. Annotate another region (It can overlap with the other, but it does not matter) and detect cells **without** expansion, label them as ""Other""; 3. Use **Detection Centroid Distances 2D** with the defaults; 4. If you look at the Cell objects, they have a **Distance to detection with Stroma um**; 5. If you look at the Detections (not expanded cells) there is no measurement. If you repeat the steps above but make only **Cell objects** or **Detections without expansion** (Where both are of the same type) then it works as expected, meaning both PathObjects have the distance measurements. **Expected behavior**; I would expect the Detection Centroid Distances 2D would work for heterogeneous groups (cells and detections) as cells are detections too. **Desktop (please complete the following information):**; - OS: Win 11; - QuPath Version: 0.5.1",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550
https://github.com/qupath/qupath/issues/1550:514,Safety,Detect,Detection,514,"## Bug report. **Describe the bug**; If we have detections and cell objects and try to run Detection Centroid Distances 2D, it will only output a result for the cells and not the detections. . **To Reproduce**; Steps to reproduce the behavior:; 1. Annotate a small region and use cell detection to create cells (with expansion) and classify them as ""Stroma""; 2. Annotate another region (It can overlap with the other, but it does not matter) and detect cells **without** expansion, label them as ""Other""; 3. Use **Detection Centroid Distances 2D** with the defaults; 4. If you look at the Cell objects, they have a **Distance to detection with Stroma um**; 5. If you look at the Detections (not expanded cells) there is no measurement. If you repeat the steps above but make only **Cell objects** or **Detections without expansion** (Where both are of the same type) then it works as expected, meaning both PathObjects have the distance measurements. **Expected behavior**; I would expect the Detection Centroid Distances 2D would work for heterogeneous groups (cells and detections) as cells are detections too. **Desktop (please complete the following information):**; - OS: Win 11; - QuPath Version: 0.5.1",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550
https://github.com/qupath/qupath/issues/1550:629,Safety,detect,detection,629,"## Bug report. **Describe the bug**; If we have detections and cell objects and try to run Detection Centroid Distances 2D, it will only output a result for the cells and not the detections. . **To Reproduce**; Steps to reproduce the behavior:; 1. Annotate a small region and use cell detection to create cells (with expansion) and classify them as ""Stroma""; 2. Annotate another region (It can overlap with the other, but it does not matter) and detect cells **without** expansion, label them as ""Other""; 3. Use **Detection Centroid Distances 2D** with the defaults; 4. If you look at the Cell objects, they have a **Distance to detection with Stroma um**; 5. If you look at the Detections (not expanded cells) there is no measurement. If you repeat the steps above but make only **Cell objects** or **Detections without expansion** (Where both are of the same type) then it works as expected, meaning both PathObjects have the distance measurements. **Expected behavior**; I would expect the Detection Centroid Distances 2D would work for heterogeneous groups (cells and detections) as cells are detections too. **Desktop (please complete the following information):**; - OS: Win 11; - QuPath Version: 0.5.1",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550
https://github.com/qupath/qupath/issues/1550:679,Safety,Detect,Detections,679,"## Bug report. **Describe the bug**; If we have detections and cell objects and try to run Detection Centroid Distances 2D, it will only output a result for the cells and not the detections. . **To Reproduce**; Steps to reproduce the behavior:; 1. Annotate a small region and use cell detection to create cells (with expansion) and classify them as ""Stroma""; 2. Annotate another region (It can overlap with the other, but it does not matter) and detect cells **without** expansion, label them as ""Other""; 3. Use **Detection Centroid Distances 2D** with the defaults; 4. If you look at the Cell objects, they have a **Distance to detection with Stroma um**; 5. If you look at the Detections (not expanded cells) there is no measurement. If you repeat the steps above but make only **Cell objects** or **Detections without expansion** (Where both are of the same type) then it works as expected, meaning both PathObjects have the distance measurements. **Expected behavior**; I would expect the Detection Centroid Distances 2D would work for heterogeneous groups (cells and detections) as cells are detections too. **Desktop (please complete the following information):**; - OS: Win 11; - QuPath Version: 0.5.1",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550
https://github.com/qupath/qupath/issues/1550:802,Safety,Detect,Detections,802,"## Bug report. **Describe the bug**; If we have detections and cell objects and try to run Detection Centroid Distances 2D, it will only output a result for the cells and not the detections. . **To Reproduce**; Steps to reproduce the behavior:; 1. Annotate a small region and use cell detection to create cells (with expansion) and classify them as ""Stroma""; 2. Annotate another region (It can overlap with the other, but it does not matter) and detect cells **without** expansion, label them as ""Other""; 3. Use **Detection Centroid Distances 2D** with the defaults; 4. If you look at the Cell objects, they have a **Distance to detection with Stroma um**; 5. If you look at the Detections (not expanded cells) there is no measurement. If you repeat the steps above but make only **Cell objects** or **Detections without expansion** (Where both are of the same type) then it works as expected, meaning both PathObjects have the distance measurements. **Expected behavior**; I would expect the Detection Centroid Distances 2D would work for heterogeneous groups (cells and detections) as cells are detections too. **Desktop (please complete the following information):**; - OS: Win 11; - QuPath Version: 0.5.1",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550
https://github.com/qupath/qupath/issues/1550:993,Safety,Detect,Detection,993,"## Bug report. **Describe the bug**; If we have detections and cell objects and try to run Detection Centroid Distances 2D, it will only output a result for the cells and not the detections. . **To Reproduce**; Steps to reproduce the behavior:; 1. Annotate a small region and use cell detection to create cells (with expansion) and classify them as ""Stroma""; 2. Annotate another region (It can overlap with the other, but it does not matter) and detect cells **without** expansion, label them as ""Other""; 3. Use **Detection Centroid Distances 2D** with the defaults; 4. If you look at the Cell objects, they have a **Distance to detection with Stroma um**; 5. If you look at the Detections (not expanded cells) there is no measurement. If you repeat the steps above but make only **Cell objects** or **Detections without expansion** (Where both are of the same type) then it works as expected, meaning both PathObjects have the distance measurements. **Expected behavior**; I would expect the Detection Centroid Distances 2D would work for heterogeneous groups (cells and detections) as cells are detections too. **Desktop (please complete the following information):**; - OS: Win 11; - QuPath Version: 0.5.1",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550
https://github.com/qupath/qupath/issues/1550:1072,Safety,detect,detections,1072,"## Bug report. **Describe the bug**; If we have detections and cell objects and try to run Detection Centroid Distances 2D, it will only output a result for the cells and not the detections. . **To Reproduce**; Steps to reproduce the behavior:; 1. Annotate a small region and use cell detection to create cells (with expansion) and classify them as ""Stroma""; 2. Annotate another region (It can overlap with the other, but it does not matter) and detect cells **without** expansion, label them as ""Other""; 3. Use **Detection Centroid Distances 2D** with the defaults; 4. If you look at the Cell objects, they have a **Distance to detection with Stroma um**; 5. If you look at the Detections (not expanded cells) there is no measurement. If you repeat the steps above but make only **Cell objects** or **Detections without expansion** (Where both are of the same type) then it works as expected, meaning both PathObjects have the distance measurements. **Expected behavior**; I would expect the Detection Centroid Distances 2D would work for heterogeneous groups (cells and detections) as cells are detections too. **Desktop (please complete the following information):**; - OS: Win 11; - QuPath Version: 0.5.1",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550
https://github.com/qupath/qupath/issues/1550:1097,Safety,detect,detections,1097,"## Bug report. **Describe the bug**; If we have detections and cell objects and try to run Detection Centroid Distances 2D, it will only output a result for the cells and not the detections. . **To Reproduce**; Steps to reproduce the behavior:; 1. Annotate a small region and use cell detection to create cells (with expansion) and classify them as ""Stroma""; 2. Annotate another region (It can overlap with the other, but it does not matter) and detect cells **without** expansion, label them as ""Other""; 3. Use **Detection Centroid Distances 2D** with the defaults; 4. If you look at the Cell objects, they have a **Distance to detection with Stroma um**; 5. If you look at the Detections (not expanded cells) there is no measurement. If you repeat the steps above but make only **Cell objects** or **Detections without expansion** (Where both are of the same type) then it works as expected, meaning both PathObjects have the distance measurements. **Expected behavior**; I would expect the Detection Centroid Distances 2D would work for heterogeneous groups (cells and detections) as cells are detections too. **Desktop (please complete the following information):**; - OS: Win 11; - QuPath Version: 0.5.1",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550
https://github.com/qupath/qupath/issues/1551:1763,Availability,mask,mask,1763,"still has the basic form of 'make measurements at the same time as detection'. I think we need to decouple these two things, or at least ensure that it's possible to add cell measurements *after* detection. **Describe the solution you'd like**; A new, scriptable command to add cell measurements. **Describe alternatives you've considered**; Build upon the existing *'Add intensity features'* command. I can think of a few relevant considerations:. * We want shape measurements as well, not just intensity measurements (although perhaps the command could be generalized to include shapes too); * *'Add intensity features'* can simultaneously give too many and too few measurements. We probably don't need the Haralick features generally, but do need the possibility of membrane measurements (possibly with control over thickness?).; * *'Add intensity features'* tries to handle the tricky problem of arbitrarily large ROIs, by tiling. It is easier to code more imaginative feature measurements if we can assume that all pixels and binary mask can fit easily into RAM.; * *'Add intensity features'* does *not* handle the different cell compartments currently (i.e. nucleus, cytoplasm, cell, membrane). **Additional context**; In writing this, it's not clear to me if we should replace *'Add intensity features'* and *'Add shape features'* with a single, better command at the same time as trying to solve this issue. A few extra considerations and complexities:; * We need to be able to handle color transforms (e.g. color deconvolution); * We need to consider the resolution at which the measurements are calculated; * We need to think a lot about the measurement names; specifically, these need to be unique (since they are effectively stored in a map), and efficiently encode the key info (e.g. compartment, resolution, measurement type). An occasional complaint is that QuPath's cell detection and the StarDist extension use different naming conventions. This was a conscious decision, because the ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1551
https://github.com/qupath/qupath/issues/1551:209,Energy Efficiency,sustainab,sustainable,209,"## Feature request. **Is your feature request related to a problem? Please describe.**; QuPath's built-in cell detection makes measurements at the same time and at the same resolution as detection. This isn't sustainable as we support a wider range of cell detection methods. That's why the [`ObjectMeasurements`](https://github.com/qupath/qupath/blob/a5c02a0d8e8e2a010824a2a0dc0fb0c45602fd76/qupath-core-processing/src/main/java/qupath/lib/analysis/features/ObjectMeasurements.java#L74) class exists. This is used internally [by the QuPath StarDist extension](https://github.com/qupath/qupath-extension-stardist/blob/c9424b488a356a3af26ef7bc58eb9bce2592a108/src/main/java/qupath/ext/stardist/StarDist2D.java#L1014) - but it still has the basic form of 'make measurements at the same time as detection'. I think we need to decouple these two things, or at least ensure that it's possible to add cell measurements *after* detection. **Describe the solution you'd like**; A new, scriptable command to add cell measurements. **Describe alternatives you've considered**; Build upon the existing *'Add intensity features'* command. I can think of a few relevant considerations:. * We want shape measurements as well, not just intensity measurements (although perhaps the command could be generalized to include shapes too); * *'Add intensity features'* can simultaneously give too many and too few measurements. We probably don't need the Haralick features generally, but do need the possibility of membrane measurements (possibly with control over thickness?).; * *'Add intensity features'* tries to handle the tricky problem of arbitrarily large ROIs, by tiling. It is easier to code more imaginative feature measurements if we can assume that all pixels and binary mask can fit easily into RAM.; * *'Add intensity features'* does *not* handle the different cell compartments currently (i.e. nucleus, cytoplasm, cell, membrane). **Additional context**; In writing this, it's not clear to me if we should ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1551
https://github.com/qupath/qupath/issues/1551:2484,Energy Efficiency,efficient,efficiently,2484,"y and too few measurements. We probably don't need the Haralick features generally, but do need the possibility of membrane measurements (possibly with control over thickness?).; * *'Add intensity features'* tries to handle the tricky problem of arbitrarily large ROIs, by tiling. It is easier to code more imaginative feature measurements if we can assume that all pixels and binary mask can fit easily into RAM.; * *'Add intensity features'* does *not* handle the different cell compartments currently (i.e. nucleus, cytoplasm, cell, membrane). **Additional context**; In writing this, it's not clear to me if we should replace *'Add intensity features'* and *'Add shape features'* with a single, better command at the same time as trying to solve this issue. A few extra considerations and complexities:; * We need to be able to handle color transforms (e.g. color deconvolution); * We need to consider the resolution at which the measurements are calculated; * We need to think a lot about the measurement names; specifically, these need to be unique (since they are effectively stored in a map), and efficiently encode the key info (e.g. compartment, resolution, measurement type). An occasional complaint is that QuPath's cell detection and the StarDist extension use different naming conventions. This was a conscious decision, because the measurements weren't expected to be directly comparable - and so shouldn't be used interchangeably (e.g. when training a cell classifier). But I don't think it was necessarily a *good* decision. With default cell detection, you'd get; ```; Nucleus: Hematoxylin OD mean; ```; but with StarDist (i.e. `ObjectMeasurements`) you woul dhave; ```; Hematoxylin: Nucleus: Mean; ```. Both share the idea of splitting parts with colons... but inconsistently in most respects. If we had a better convention, then this might also be useful to show measurements in a *grouped* way. I suspect grouping first by compartment would be more sensible than by stain. The clo",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1551
https://github.com/qupath/qupath/issues/1551:111,Safety,detect,detection,111,"## Feature request. **Is your feature request related to a problem? Please describe.**; QuPath's built-in cell detection makes measurements at the same time and at the same resolution as detection. This isn't sustainable as we support a wider range of cell detection methods. That's why the [`ObjectMeasurements`](https://github.com/qupath/qupath/blob/a5c02a0d8e8e2a010824a2a0dc0fb0c45602fd76/qupath-core-processing/src/main/java/qupath/lib/analysis/features/ObjectMeasurements.java#L74) class exists. This is used internally [by the QuPath StarDist extension](https://github.com/qupath/qupath-extension-stardist/blob/c9424b488a356a3af26ef7bc58eb9bce2592a108/src/main/java/qupath/ext/stardist/StarDist2D.java#L1014) - but it still has the basic form of 'make measurements at the same time as detection'. I think we need to decouple these two things, or at least ensure that it's possible to add cell measurements *after* detection. **Describe the solution you'd like**; A new, scriptable command to add cell measurements. **Describe alternatives you've considered**; Build upon the existing *'Add intensity features'* command. I can think of a few relevant considerations:. * We want shape measurements as well, not just intensity measurements (although perhaps the command could be generalized to include shapes too); * *'Add intensity features'* can simultaneously give too many and too few measurements. We probably don't need the Haralick features generally, but do need the possibility of membrane measurements (possibly with control over thickness?).; * *'Add intensity features'* tries to handle the tricky problem of arbitrarily large ROIs, by tiling. It is easier to code more imaginative feature measurements if we can assume that all pixels and binary mask can fit easily into RAM.; * *'Add intensity features'* does *not* handle the different cell compartments currently (i.e. nucleus, cytoplasm, cell, membrane). **Additional context**; In writing this, it's not clear to me if we should ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1551
https://github.com/qupath/qupath/issues/1551:187,Safety,detect,detection,187,"## Feature request. **Is your feature request related to a problem? Please describe.**; QuPath's built-in cell detection makes measurements at the same time and at the same resolution as detection. This isn't sustainable as we support a wider range of cell detection methods. That's why the [`ObjectMeasurements`](https://github.com/qupath/qupath/blob/a5c02a0d8e8e2a010824a2a0dc0fb0c45602fd76/qupath-core-processing/src/main/java/qupath/lib/analysis/features/ObjectMeasurements.java#L74) class exists. This is used internally [by the QuPath StarDist extension](https://github.com/qupath/qupath-extension-stardist/blob/c9424b488a356a3af26ef7bc58eb9bce2592a108/src/main/java/qupath/ext/stardist/StarDist2D.java#L1014) - but it still has the basic form of 'make measurements at the same time as detection'. I think we need to decouple these two things, or at least ensure that it's possible to add cell measurements *after* detection. **Describe the solution you'd like**; A new, scriptable command to add cell measurements. **Describe alternatives you've considered**; Build upon the existing *'Add intensity features'* command. I can think of a few relevant considerations:. * We want shape measurements as well, not just intensity measurements (although perhaps the command could be generalized to include shapes too); * *'Add intensity features'* can simultaneously give too many and too few measurements. We probably don't need the Haralick features generally, but do need the possibility of membrane measurements (possibly with control over thickness?).; * *'Add intensity features'* tries to handle the tricky problem of arbitrarily large ROIs, by tiling. It is easier to code more imaginative feature measurements if we can assume that all pixels and binary mask can fit easily into RAM.; * *'Add intensity features'* does *not* handle the different cell compartments currently (i.e. nucleus, cytoplasm, cell, membrane). **Additional context**; In writing this, it's not clear to me if we should ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1551
https://github.com/qupath/qupath/issues/1551:257,Safety,detect,detection,257,"## Feature request. **Is your feature request related to a problem? Please describe.**; QuPath's built-in cell detection makes measurements at the same time and at the same resolution as detection. This isn't sustainable as we support a wider range of cell detection methods. That's why the [`ObjectMeasurements`](https://github.com/qupath/qupath/blob/a5c02a0d8e8e2a010824a2a0dc0fb0c45602fd76/qupath-core-processing/src/main/java/qupath/lib/analysis/features/ObjectMeasurements.java#L74) class exists. This is used internally [by the QuPath StarDist extension](https://github.com/qupath/qupath-extension-stardist/blob/c9424b488a356a3af26ef7bc58eb9bce2592a108/src/main/java/qupath/ext/stardist/StarDist2D.java#L1014) - but it still has the basic form of 'make measurements at the same time as detection'. I think we need to decouple these two things, or at least ensure that it's possible to add cell measurements *after* detection. **Describe the solution you'd like**; A new, scriptable command to add cell measurements. **Describe alternatives you've considered**; Build upon the existing *'Add intensity features'* command. I can think of a few relevant considerations:. * We want shape measurements as well, not just intensity measurements (although perhaps the command could be generalized to include shapes too); * *'Add intensity features'* can simultaneously give too many and too few measurements. We probably don't need the Haralick features generally, but do need the possibility of membrane measurements (possibly with control over thickness?).; * *'Add intensity features'* tries to handle the tricky problem of arbitrarily large ROIs, by tiling. It is easier to code more imaginative feature measurements if we can assume that all pixels and binary mask can fit easily into RAM.; * *'Add intensity features'* does *not* handle the different cell compartments currently (i.e. nucleus, cytoplasm, cell, membrane). **Additional context**; In writing this, it's not clear to me if we should ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1551
https://github.com/qupath/qupath/issues/1551:792,Safety,detect,detection,792,"## Feature request. **Is your feature request related to a problem? Please describe.**; QuPath's built-in cell detection makes measurements at the same time and at the same resolution as detection. This isn't sustainable as we support a wider range of cell detection methods. That's why the [`ObjectMeasurements`](https://github.com/qupath/qupath/blob/a5c02a0d8e8e2a010824a2a0dc0fb0c45602fd76/qupath-core-processing/src/main/java/qupath/lib/analysis/features/ObjectMeasurements.java#L74) class exists. This is used internally [by the QuPath StarDist extension](https://github.com/qupath/qupath-extension-stardist/blob/c9424b488a356a3af26ef7bc58eb9bce2592a108/src/main/java/qupath/ext/stardist/StarDist2D.java#L1014) - but it still has the basic form of 'make measurements at the same time as detection'. I think we need to decouple these two things, or at least ensure that it's possible to add cell measurements *after* detection. **Describe the solution you'd like**; A new, scriptable command to add cell measurements. **Describe alternatives you've considered**; Build upon the existing *'Add intensity features'* command. I can think of a few relevant considerations:. * We want shape measurements as well, not just intensity measurements (although perhaps the command could be generalized to include shapes too); * *'Add intensity features'* can simultaneously give too many and too few measurements. We probably don't need the Haralick features generally, but do need the possibility of membrane measurements (possibly with control over thickness?).; * *'Add intensity features'* tries to handle the tricky problem of arbitrarily large ROIs, by tiling. It is easier to code more imaginative feature measurements if we can assume that all pixels and binary mask can fit easily into RAM.; * *'Add intensity features'* does *not* handle the different cell compartments currently (i.e. nucleus, cytoplasm, cell, membrane). **Additional context**; In writing this, it's not clear to me if we should ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1551
https://github.com/qupath/qupath/issues/1551:921,Safety,detect,detection,921,"## Feature request. **Is your feature request related to a problem? Please describe.**; QuPath's built-in cell detection makes measurements at the same time and at the same resolution as detection. This isn't sustainable as we support a wider range of cell detection methods. That's why the [`ObjectMeasurements`](https://github.com/qupath/qupath/blob/a5c02a0d8e8e2a010824a2a0dc0fb0c45602fd76/qupath-core-processing/src/main/java/qupath/lib/analysis/features/ObjectMeasurements.java#L74) class exists. This is used internally [by the QuPath StarDist extension](https://github.com/qupath/qupath-extension-stardist/blob/c9424b488a356a3af26ef7bc58eb9bce2592a108/src/main/java/qupath/ext/stardist/StarDist2D.java#L1014) - but it still has the basic form of 'make measurements at the same time as detection'. I think we need to decouple these two things, or at least ensure that it's possible to add cell measurements *after* detection. **Describe the solution you'd like**; A new, scriptable command to add cell measurements. **Describe alternatives you've considered**; Build upon the existing *'Add intensity features'* command. I can think of a few relevant considerations:. * We want shape measurements as well, not just intensity measurements (although perhaps the command could be generalized to include shapes too); * *'Add intensity features'* can simultaneously give too many and too few measurements. We probably don't need the Haralick features generally, but do need the possibility of membrane measurements (possibly with control over thickness?).; * *'Add intensity features'* tries to handle the tricky problem of arbitrarily large ROIs, by tiling. It is easier to code more imaginative feature measurements if we can assume that all pixels and binary mask can fit easily into RAM.; * *'Add intensity features'* does *not* handle the different cell compartments currently (i.e. nucleus, cytoplasm, cell, membrane). **Additional context**; In writing this, it's not clear to me if we should ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1551
https://github.com/qupath/qupath/issues/1551:2612,Safety,detect,detection,2612,"ol over thickness?).; * *'Add intensity features'* tries to handle the tricky problem of arbitrarily large ROIs, by tiling. It is easier to code more imaginative feature measurements if we can assume that all pixels and binary mask can fit easily into RAM.; * *'Add intensity features'* does *not* handle the different cell compartments currently (i.e. nucleus, cytoplasm, cell, membrane). **Additional context**; In writing this, it's not clear to me if we should replace *'Add intensity features'* and *'Add shape features'* with a single, better command at the same time as trying to solve this issue. A few extra considerations and complexities:; * We need to be able to handle color transforms (e.g. color deconvolution); * We need to consider the resolution at which the measurements are calculated; * We need to think a lot about the measurement names; specifically, these need to be unique (since they are effectively stored in a map), and efficiently encode the key info (e.g. compartment, resolution, measurement type). An occasional complaint is that QuPath's cell detection and the StarDist extension use different naming conventions. This was a conscious decision, because the measurements weren't expected to be directly comparable - and so shouldn't be used interchangeably (e.g. when training a cell classifier). But I don't think it was necessarily a *good* decision. With default cell detection, you'd get; ```; Nucleus: Hematoxylin OD mean; ```; but with StarDist (i.e. `ObjectMeasurements`) you woul dhave; ```; Hematoxylin: Nucleus: Mean; ```. Both share the idea of splitting parts with colons... but inconsistently in most respects. If we had a better convention, then this might also be useful to show measurements in a *grouped* way. I suspect grouping first by compartment would be more sensible than by stain. The closest comparable measurement from *'Add intensity features'* would be; ```; ROI: 2.00 µm per pixel: Hematoxylin: Mean; ```; which also groups... confusingly.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1551
https://github.com/qupath/qupath/issues/1551:2939,Safety,detect,detection,2939,"ol over thickness?).; * *'Add intensity features'* tries to handle the tricky problem of arbitrarily large ROIs, by tiling. It is easier to code more imaginative feature measurements if we can assume that all pixels and binary mask can fit easily into RAM.; * *'Add intensity features'* does *not* handle the different cell compartments currently (i.e. nucleus, cytoplasm, cell, membrane). **Additional context**; In writing this, it's not clear to me if we should replace *'Add intensity features'* and *'Add shape features'* with a single, better command at the same time as trying to solve this issue. A few extra considerations and complexities:; * We need to be able to handle color transforms (e.g. color deconvolution); * We need to consider the resolution at which the measurements are calculated; * We need to think a lot about the measurement names; specifically, these need to be unique (since they are effectively stored in a map), and efficiently encode the key info (e.g. compartment, resolution, measurement type). An occasional complaint is that QuPath's cell detection and the StarDist extension use different naming conventions. This was a conscious decision, because the measurements weren't expected to be directly comparable - and so shouldn't be used interchangeably (e.g. when training a cell classifier). But I don't think it was necessarily a *good* decision. With default cell detection, you'd get; ```; Nucleus: Hematoxylin OD mean; ```; but with StarDist (i.e. `ObjectMeasurements`) you woul dhave; ```; Hematoxylin: Nucleus: Mean; ```. Both share the idea of splitting parts with colons... but inconsistently in most respects. If we had a better convention, then this might also be useful to show measurements in a *grouped* way. I suspect grouping first by compartment would be more sensible than by stain. The closest comparable measurement from *'Add intensity features'* would be; ```; ROI: 2.00 µm per pixel: Hematoxylin: Mean; ```; which also groups... confusingly.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1551
https://github.com/qupath/qupath/issues/1551:1976,Usability,clear,clear,1976," alternatives you've considered**; Build upon the existing *'Add intensity features'* command. I can think of a few relevant considerations:. * We want shape measurements as well, not just intensity measurements (although perhaps the command could be generalized to include shapes too); * *'Add intensity features'* can simultaneously give too many and too few measurements. We probably don't need the Haralick features generally, but do need the possibility of membrane measurements (possibly with control over thickness?).; * *'Add intensity features'* tries to handle the tricky problem of arbitrarily large ROIs, by tiling. It is easier to code more imaginative feature measurements if we can assume that all pixels and binary mask can fit easily into RAM.; * *'Add intensity features'* does *not* handle the different cell compartments currently (i.e. nucleus, cytoplasm, cell, membrane). **Additional context**; In writing this, it's not clear to me if we should replace *'Add intensity features'* and *'Add shape features'* with a single, better command at the same time as trying to solve this issue. A few extra considerations and complexities:; * We need to be able to handle color transforms (e.g. color deconvolution); * We need to consider the resolution at which the measurements are calculated; * We need to think a lot about the measurement names; specifically, these need to be unique (since they are effectively stored in a map), and efficiently encode the key info (e.g. compartment, resolution, measurement type). An occasional complaint is that QuPath's cell detection and the StarDist extension use different naming conventions. This was a conscious decision, because the measurements weren't expected to be directly comparable - and so shouldn't be used interchangeably (e.g. when training a cell classifier). But I don't think it was necessarily a *good* decision. With default cell detection, you'd get; ```; Nucleus: Hematoxylin OD mean; ```; but with StarDist (i.e. `ObjectM",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1551
https://github.com/qupath/qupath/pull/1554:4379,Availability,down,download,4379,"ains targetStains, double[] scales = null) {; return new TransformedServerBuilder(imageData.getServer()); .stainNormalize(imageData.getColorDeconvolutionStains(), targetStains, scales); .build(); }. /**; * Get the default stains for an image type, or null if no default stains are defined; * @param imageType; * @return; */; ColorDeconvolutionStains getDefaultTargetStains(ImageData<?> imageData, boolean preferDefaultStains) {; if (preferDefaultStains) {; switch (imageData.getImageType()) {; case ImageData.ImageType.BRIGHTFIELD_H_E:; return ColorDeconvolutionStains.makeDefaultColorDeconvolutionStains(; ColorDeconvolutionStains.DefaultColorDeconvolutionStains.H_E); case ImageData.ImageType.BRIGHTFIELD_H_DAB:; return ColorDeconvolutionStains.makeDefaultColorDeconvolutionStains(; ColorDeconvolutionStains.DefaultColorDeconvolutionStains.H_DAB); default:; println ""WARN: No default stains defined for image type ${imageData.getImageType()}""; }; }; // The most we can do is 'whiten' the background; return imageData.getColorDeconvolutionStains().changeMaxValues(255, 255, 255); }; ```. ## Example; Here, I've applied the script to [CMU-1.ndpi (CC0, from OpenSlide test data)](https://openslide.cs.cmu.edu/download/openslide-testdata/Hamamatsu/CMU-1.ndpi). ### Original image; ![cmu-1-ndpi-orig](https://github.com/qupath/qupath/assets/4690904/84b18c6c-260e-47d7-acf2-9ee97d9c3c76). ### After running the script; ![cmu-1-ndpi-normalized-full](https://github.com/qupath/qupath/assets/4690904/ecd1d6a7-9b49-4a93-b635-2298d43abf09). ### With stain intensity adjustment. The script above effectively shifts the stain colors and sets the background to white. Updating the `scales` variable to; ```groovy; def scales = [1, 0.5, 0] as double[]; ```; effectively suppresses the residual value and weakens the eosin - demonstrating how intensity variations can also be compensated for. ![cmu-1-ndpi-normalized-less-eosin](https://github.com/qupath/qupath/assets/4690904/12d7060b-35bc-40ca-89a3-f837c5417dbf)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1554
https://github.com/qupath/qupath/pull/1554:4849,Modifiability,variab,variable,4849,"ains targetStains, double[] scales = null) {; return new TransformedServerBuilder(imageData.getServer()); .stainNormalize(imageData.getColorDeconvolutionStains(), targetStains, scales); .build(); }. /**; * Get the default stains for an image type, or null if no default stains are defined; * @param imageType; * @return; */; ColorDeconvolutionStains getDefaultTargetStains(ImageData<?> imageData, boolean preferDefaultStains) {; if (preferDefaultStains) {; switch (imageData.getImageType()) {; case ImageData.ImageType.BRIGHTFIELD_H_E:; return ColorDeconvolutionStains.makeDefaultColorDeconvolutionStains(; ColorDeconvolutionStains.DefaultColorDeconvolutionStains.H_E); case ImageData.ImageType.BRIGHTFIELD_H_DAB:; return ColorDeconvolutionStains.makeDefaultColorDeconvolutionStains(; ColorDeconvolutionStains.DefaultColorDeconvolutionStains.H_DAB); default:; println ""WARN: No default stains defined for image type ${imageData.getImageType()}""; }; }; // The most we can do is 'whiten' the background; return imageData.getColorDeconvolutionStains().changeMaxValues(255, 255, 255); }; ```. ## Example; Here, I've applied the script to [CMU-1.ndpi (CC0, from OpenSlide test data)](https://openslide.cs.cmu.edu/download/openslide-testdata/Hamamatsu/CMU-1.ndpi). ### Original image; ![cmu-1-ndpi-orig](https://github.com/qupath/qupath/assets/4690904/84b18c6c-260e-47d7-acf2-9ee97d9c3c76). ### After running the script; ![cmu-1-ndpi-normalized-full](https://github.com/qupath/qupath/assets/4690904/ecd1d6a7-9b49-4a93-b635-2298d43abf09). ### With stain intensity adjustment. The script above effectively shifts the stain colors and sets the background to white. Updating the `scales` variable to; ```groovy; def scales = [1, 0.5, 0] as double[]; ```; effectively suppresses the residual value and weakens the eosin - demonstrating how intensity variations can also be compensated for. ![cmu-1-ndpi-normalized-less-eosin](https://github.com/qupath/qupath/assets/4690904/12d7060b-35bc-40ca-89a3-f837c5417dbf)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1554
https://github.com/qupath/qupath/pull/1554:4338,Testability,test,test,4338,"ains targetStains, double[] scales = null) {; return new TransformedServerBuilder(imageData.getServer()); .stainNormalize(imageData.getColorDeconvolutionStains(), targetStains, scales); .build(); }. /**; * Get the default stains for an image type, or null if no default stains are defined; * @param imageType; * @return; */; ColorDeconvolutionStains getDefaultTargetStains(ImageData<?> imageData, boolean preferDefaultStains) {; if (preferDefaultStains) {; switch (imageData.getImageType()) {; case ImageData.ImageType.BRIGHTFIELD_H_E:; return ColorDeconvolutionStains.makeDefaultColorDeconvolutionStains(; ColorDeconvolutionStains.DefaultColorDeconvolutionStains.H_E); case ImageData.ImageType.BRIGHTFIELD_H_DAB:; return ColorDeconvolutionStains.makeDefaultColorDeconvolutionStains(; ColorDeconvolutionStains.DefaultColorDeconvolutionStains.H_DAB); default:; println ""WARN: No default stains defined for image type ${imageData.getImageType()}""; }; }; // The most we can do is 'whiten' the background; return imageData.getColorDeconvolutionStains().changeMaxValues(255, 255, 255); }; ```. ## Example; Here, I've applied the script to [CMU-1.ndpi (CC0, from OpenSlide test data)](https://openslide.cs.cmu.edu/download/openslide-testdata/Hamamatsu/CMU-1.ndpi). ### Original image; ![cmu-1-ndpi-orig](https://github.com/qupath/qupath/assets/4690904/84b18c6c-260e-47d7-acf2-9ee97d9c3c76). ### After running the script; ![cmu-1-ndpi-normalized-full](https://github.com/qupath/qupath/assets/4690904/ecd1d6a7-9b49-4a93-b635-2298d43abf09). ### With stain intensity adjustment. The script above effectively shifts the stain colors and sets the background to white. Updating the `scales` variable to; ```groovy; def scales = [1, 0.5, 0] as double[]; ```; effectively suppresses the residual value and weakens the eosin - demonstrating how intensity variations can also be compensated for. ![cmu-1-ndpi-normalized-less-eosin](https://github.com/qupath/qupath/assets/4690904/12d7060b-35bc-40ca-89a3-f837c5417dbf)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1554
https://github.com/qupath/qupath/pull/1554:4398,Testability,test,testdata,4398,"ains targetStains, double[] scales = null) {; return new TransformedServerBuilder(imageData.getServer()); .stainNormalize(imageData.getColorDeconvolutionStains(), targetStains, scales); .build(); }. /**; * Get the default stains for an image type, or null if no default stains are defined; * @param imageType; * @return; */; ColorDeconvolutionStains getDefaultTargetStains(ImageData<?> imageData, boolean preferDefaultStains) {; if (preferDefaultStains) {; switch (imageData.getImageType()) {; case ImageData.ImageType.BRIGHTFIELD_H_E:; return ColorDeconvolutionStains.makeDefaultColorDeconvolutionStains(; ColorDeconvolutionStains.DefaultColorDeconvolutionStains.H_E); case ImageData.ImageType.BRIGHTFIELD_H_DAB:; return ColorDeconvolutionStains.makeDefaultColorDeconvolutionStains(; ColorDeconvolutionStains.DefaultColorDeconvolutionStains.H_DAB); default:; println ""WARN: No default stains defined for image type ${imageData.getImageType()}""; }; }; // The most we can do is 'whiten' the background; return imageData.getColorDeconvolutionStains().changeMaxValues(255, 255, 255); }; ```. ## Example; Here, I've applied the script to [CMU-1.ndpi (CC0, from OpenSlide test data)](https://openslide.cs.cmu.edu/download/openslide-testdata/Hamamatsu/CMU-1.ndpi). ### Original image; ![cmu-1-ndpi-orig](https://github.com/qupath/qupath/assets/4690904/84b18c6c-260e-47d7-acf2-9ee97d9c3c76). ### After running the script; ![cmu-1-ndpi-normalized-full](https://github.com/qupath/qupath/assets/4690904/ecd1d6a7-9b49-4a93-b635-2298d43abf09). ### With stain intensity adjustment. The script above effectively shifts the stain colors and sets the background to white. Updating the `scales` variable to; ```groovy; def scales = [1, 0.5, 0] as double[]; ```; effectively suppresses the residual value and weakens the eosin - demonstrating how intensity variations can also be compensated for. ![cmu-1-ndpi-normalized-less-eosin](https://github.com/qupath/qupath/assets/4690904/12d7060b-35bc-40ca-89a3-f837c5417dbf)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1554
https://github.com/qupath/qupath/pull/1556:287,Availability,mask,masking,287,* Support hiding project thumbnails; * Supporting hiding / resizing thumbnails from a context menu (not just the preferences); * Hiding thumbnails may improve performance for large projects if thumbnails haven't been generated yet; * It also addresses a request for hide thumbnails when masking image names; * Improve code by separating out some methods; * Fix a bug that meant metadata couldn't be edited when using `gradlew run`; * Retain sorting after adding metadata (stolen from @alanocallaghan's code at #1538); * Move styles to `main.css` (rather than calling `setStyle(String)`),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1556
https://github.com/qupath/qupath/pull/1556:159,Performance,perform,performance,159,* Support hiding project thumbnails; * Supporting hiding / resizing thumbnails from a context menu (not just the preferences); * Hiding thumbnails may improve performance for large projects if thumbnails haven't been generated yet; * It also addresses a request for hide thumbnails when masking image names; * Improve code by separating out some methods; * Fix a bug that meant metadata couldn't be edited when using `gradlew run`; * Retain sorting after adding metadata (stolen from @alanocallaghan's code at #1538); * Move styles to `main.css` (rather than calling `setStyle(String)`),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1556
https://github.com/qupath/qupath/pull/1560:32,Modifiability,plugin,plugin,32,This means that any interactive plugin windows are effectively singletons. See https://github.com/qupath/planner/issues/2,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1560
https://github.com/qupath/qupath/issues/1561:763,Availability,ERROR,ERROR,763,"* [x] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; I encountered some reproducible crashes on macOS (Macbook Air, M1) when running the below script for ~100 images within a project. The script will run fine at first. After ~100 images, an exception will be thrown. And after a few more executions, the app will crash. > ERROR: unable to create native thread: possibly out of memory or process/resource limits reached"". . **To Reproduce**. ```groovy; import qupath.lib.gui.viewer.overlays.HierarchyOverlay; import qupath.lib.gui.images.servers.RenderedImageServer. def viewer = getCurrentViewer(); def imageData = getCurrentImageData(). def name = GeneralTools.getNameWithoutExtension(imageData.getServer().getMetadata().getName()); def pathOutput = <output_path>. double requestedPixelSize = 15; double downsample = requestedPixelSize / imageData.getServer().getPixelCalibration().getAveragedPixelSize(). def display = qupath.lib.display.ImageDisplay.create(imageData); def server = new RenderedImageServer.Builder(imageData); .display(display); .downsamples(downsample); .layers(new HierarchyOverlay(viewer.getImageRegionStore(), viewer.getOverlayOptions(), imageData)); .build(). ```. **Expected behavior**; The above script can run for the whole project without crashing. **Screenshots**; If applicable, add screenshots to help explain your problem. **Desktop (please complete the following information):**; - OS: macOS (MacBook Air, M1); - QuPath Version: 0.5.1-arm64. **Additional context**. Stack trace; ```; ERROR: unable to create native thread: poss",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1561
https://github.com/qupath/qupath/issues/1561:1246,Availability,down,downsample,1246," [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; I encountered some reproducible crashes on macOS (Macbook Air, M1) when running the below script for ~100 images within a project. The script will run fine at first. After ~100 images, an exception will be thrown. And after a few more executions, the app will crash. > ERROR: unable to create native thread: possibly out of memory or process/resource limits reached"". . **To Reproduce**. ```groovy; import qupath.lib.gui.viewer.overlays.HierarchyOverlay; import qupath.lib.gui.images.servers.RenderedImageServer. def viewer = getCurrentViewer(); def imageData = getCurrentImageData(). def name = GeneralTools.getNameWithoutExtension(imageData.getServer().getMetadata().getName()); def pathOutput = <output_path>. double requestedPixelSize = 15; double downsample = requestedPixelSize / imageData.getServer().getPixelCalibration().getAveragedPixelSize(). def display = qupath.lib.display.ImageDisplay.create(imageData); def server = new RenderedImageServer.Builder(imageData); .display(display); .downsamples(downsample); .layers(new HierarchyOverlay(viewer.getImageRegionStore(), viewer.getOverlayOptions(), imageData)); .build(). ```. **Expected behavior**; The above script can run for the whole project without crashing. **Screenshots**; If applicable, add screenshots to help explain your problem. **Desktop (please complete the following information):**; - OS: macOS (MacBook Air, M1); - QuPath Version: 0.5.1-arm64. **Additional context**. Stack trace; ```; ERROR: unable to create native thread: possibly out of memory or process/resource limits reached in thread_leak_repro.groovy at line number 25; java.base/java.lang.Thread.start0(Native Method); java.base/java.lang.Thread.start(Unknown Source); java.base/java.lang.System$2.start(Unknown Sou",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1561
https://github.com/qupath/qupath/issues/1561:1490,Availability,down,downsamples,1490,"ered some reproducible crashes on macOS (Macbook Air, M1) when running the below script for ~100 images within a project. The script will run fine at first. After ~100 images, an exception will be thrown. And after a few more executions, the app will crash. > ERROR: unable to create native thread: possibly out of memory or process/resource limits reached"". . **To Reproduce**. ```groovy; import qupath.lib.gui.viewer.overlays.HierarchyOverlay; import qupath.lib.gui.images.servers.RenderedImageServer. def viewer = getCurrentViewer(); def imageData = getCurrentImageData(). def name = GeneralTools.getNameWithoutExtension(imageData.getServer().getMetadata().getName()); def pathOutput = <output_path>. double requestedPixelSize = 15; double downsample = requestedPixelSize / imageData.getServer().getPixelCalibration().getAveragedPixelSize(). def display = qupath.lib.display.ImageDisplay.create(imageData); def server = new RenderedImageServer.Builder(imageData); .display(display); .downsamples(downsample); .layers(new HierarchyOverlay(viewer.getImageRegionStore(), viewer.getOverlayOptions(), imageData)); .build(). ```. **Expected behavior**; The above script can run for the whole project without crashing. **Screenshots**; If applicable, add screenshots to help explain your problem. **Desktop (please complete the following information):**; - OS: macOS (MacBook Air, M1); - QuPath Version: 0.5.1-arm64. **Additional context**. Stack trace; ```; ERROR: unable to create native thread: possibly out of memory or process/resource limits reached in thread_leak_repro.groovy at line number 25; java.base/java.lang.Thread.start0(Native Method); java.base/java.lang.Thread.start(Unknown Source); java.base/java.lang.System$2.start(Unknown Source); java.base/jdk.internal.vm.SharedThreadContainer.start(Unknown Source); java.base/java.util.concurrent.ThreadPoolExecutor.addWorker(Unknown Source); java.base/java.util.concurrent.ThreadPoolExecutor.execute(Unknown Source); qupath.lib.gui.images.stor",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1561
https://github.com/qupath/qupath/issues/1561:1502,Availability,down,downsample,1502,"ered some reproducible crashes on macOS (Macbook Air, M1) when running the below script for ~100 images within a project. The script will run fine at first. After ~100 images, an exception will be thrown. And after a few more executions, the app will crash. > ERROR: unable to create native thread: possibly out of memory or process/resource limits reached"". . **To Reproduce**. ```groovy; import qupath.lib.gui.viewer.overlays.HierarchyOverlay; import qupath.lib.gui.images.servers.RenderedImageServer. def viewer = getCurrentViewer(); def imageData = getCurrentImageData(). def name = GeneralTools.getNameWithoutExtension(imageData.getServer().getMetadata().getName()); def pathOutput = <output_path>. double requestedPixelSize = 15; double downsample = requestedPixelSize / imageData.getServer().getPixelCalibration().getAveragedPixelSize(). def display = qupath.lib.display.ImageDisplay.create(imageData); def server = new RenderedImageServer.Builder(imageData); .display(display); .downsamples(downsample); .layers(new HierarchyOverlay(viewer.getImageRegionStore(), viewer.getOverlayOptions(), imageData)); .build(). ```. **Expected behavior**; The above script can run for the whole project without crashing. **Screenshots**; If applicable, add screenshots to help explain your problem. **Desktop (please complete the following information):**; - OS: macOS (MacBook Air, M1); - QuPath Version: 0.5.1-arm64. **Additional context**. Stack trace; ```; ERROR: unable to create native thread: possibly out of memory or process/resource limits reached in thread_leak_repro.groovy at line number 25; java.base/java.lang.Thread.start0(Native Method); java.base/java.lang.Thread.start(Unknown Source); java.base/java.lang.System$2.start(Unknown Source); java.base/jdk.internal.vm.SharedThreadContainer.start(Unknown Source); java.base/java.util.concurrent.ThreadPoolExecutor.addWorker(Unknown Source); java.base/java.util.concurrent.ThreadPoolExecutor.execute(Unknown Source); qupath.lib.gui.images.stor",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1561
https://github.com/qupath/qupath/issues/1561:1958,Availability,ERROR,ERROR,1958,"def viewer = getCurrentViewer(); def imageData = getCurrentImageData(). def name = GeneralTools.getNameWithoutExtension(imageData.getServer().getMetadata().getName()); def pathOutput = <output_path>. double requestedPixelSize = 15; double downsample = requestedPixelSize / imageData.getServer().getPixelCalibration().getAveragedPixelSize(). def display = qupath.lib.display.ImageDisplay.create(imageData); def server = new RenderedImageServer.Builder(imageData); .display(display); .downsamples(downsample); .layers(new HierarchyOverlay(viewer.getImageRegionStore(), viewer.getOverlayOptions(), imageData)); .build(). ```. **Expected behavior**; The above script can run for the whole project without crashing. **Screenshots**; If applicable, add screenshots to help explain your problem. **Desktop (please complete the following information):**; - OS: macOS (MacBook Air, M1); - QuPath Version: 0.5.1-arm64. **Additional context**. Stack trace; ```; ERROR: unable to create native thread: possibly out of memory or process/resource limits reached in thread_leak_repro.groovy at line number 25; java.base/java.lang.Thread.start0(Native Method); java.base/java.lang.Thread.start(Unknown Source); java.base/java.lang.System$2.start(Unknown Source); java.base/jdk.internal.vm.SharedThreadContainer.start(Unknown Source); java.base/java.util.concurrent.ThreadPoolExecutor.addWorker(Unknown Source); java.base/java.util.concurrent.ThreadPoolExecutor.execute(Unknown Source); qupath.lib.gui.images.stores.AbstractImageRegionStore.requestImageTile(AbstractImageRegionStore.java:374); qupath.lib.gui.images.stores.DefaultImageRegionStore.paintRegionCompletely(DefaultImageRegionStore.java:104); qupath.lib.gui.images.servers.RenderedImageServer.readTile(RenderedImageServer.java:363); qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); java.base/java.util.concurrent.FutureTask.run(Unknown Source); qupath.lib.images.servers.AbstractTileableI",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1561
https://github.com/qupath/qupath/issues/1561:177,Deployability,release,release,177,"* [x] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; I encountered some reproducible crashes on macOS (Macbook Air, M1) when running the below script for ~100 images within a project. The script will run fine at first. After ~100 images, an exception will be thrown. And after a few more executions, the app will crash. > ERROR: unable to create native thread: possibly out of memory or process/resource limits reached"". . **To Reproduce**. ```groovy; import qupath.lib.gui.viewer.overlays.HierarchyOverlay; import qupath.lib.gui.images.servers.RenderedImageServer. def viewer = getCurrentViewer(); def imageData = getCurrentImageData(). def name = GeneralTools.getNameWithoutExtension(imageData.getServer().getMetadata().getName()); def pathOutput = <output_path>. double requestedPixelSize = 15; double downsample = requestedPixelSize / imageData.getServer().getPixelCalibration().getAveragedPixelSize(). def display = qupath.lib.display.ImageDisplay.create(imageData); def server = new RenderedImageServer.Builder(imageData); .display(display); .downsamples(downsample); .layers(new HierarchyOverlay(viewer.getImageRegionStore(), viewer.getOverlayOptions(), imageData)); .build(). ```. **Expected behavior**; The above script can run for the whole project without crashing. **Screenshots**; If applicable, add screenshots to help explain your problem. **Desktop (please complete the following information):**; - OS: macOS (MacBook Air, M1); - QuPath Version: 0.5.1-arm64. **Additional context**. Stack trace; ```; ERROR: unable to create native thread: poss",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1561
https://github.com/qupath/qupath/issues/1561:373,Deployability,release,release,373,"* [x] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [x] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [x] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [x] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; I encountered some reproducible crashes on macOS (Macbook Air, M1) when running the below script for ~100 images within a project. The script will run fine at first. After ~100 images, an exception will be thrown. And after a few more executions, the app will crash. > ERROR: unable to create native thread: possibly out of memory or process/resource limits reached"". . **To Reproduce**. ```groovy; import qupath.lib.gui.viewer.overlays.HierarchyOverlay; import qupath.lib.gui.images.servers.RenderedImageServer. def viewer = getCurrentViewer(); def imageData = getCurrentImageData(). def name = GeneralTools.getNameWithoutExtension(imageData.getServer().getMetadata().getName()); def pathOutput = <output_path>. double requestedPixelSize = 15; double downsample = requestedPixelSize / imageData.getServer().getPixelCalibration().getAveragedPixelSize(). def display = qupath.lib.display.ImageDisplay.create(imageData); def server = new RenderedImageServer.Builder(imageData); .display(display); .downsamples(downsample); .layers(new HierarchyOverlay(viewer.getImageRegionStore(), viewer.getOverlayOptions(), imageData)); .build(). ```. **Expected behavior**; The above script can run for the whole project without crashing. **Screenshots**; If applicable, add screenshots to help explain your problem. **Desktop (please complete the following information):**; - OS: macOS (MacBook Air, M1); - QuPath Version: 0.5.1-arm64. **Additional context**. Stack trace; ```; ERROR: unable to create native thread: poss",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1561
https://github.com/qupath/qupath/issues/1561:1516,Modifiability,layers,layers,1516," on macOS (Macbook Air, M1) when running the below script for ~100 images within a project. The script will run fine at first. After ~100 images, an exception will be thrown. And after a few more executions, the app will crash. > ERROR: unable to create native thread: possibly out of memory or process/resource limits reached"". . **To Reproduce**. ```groovy; import qupath.lib.gui.viewer.overlays.HierarchyOverlay; import qupath.lib.gui.images.servers.RenderedImageServer. def viewer = getCurrentViewer(); def imageData = getCurrentImageData(). def name = GeneralTools.getNameWithoutExtension(imageData.getServer().getMetadata().getName()); def pathOutput = <output_path>. double requestedPixelSize = 15; double downsample = requestedPixelSize / imageData.getServer().getPixelCalibration().getAveragedPixelSize(). def display = qupath.lib.display.ImageDisplay.create(imageData); def server = new RenderedImageServer.Builder(imageData); .display(display); .downsamples(downsample); .layers(new HierarchyOverlay(viewer.getImageRegionStore(), viewer.getOverlayOptions(), imageData)); .build(). ```. **Expected behavior**; The above script can run for the whole project without crashing. **Screenshots**; If applicable, add screenshots to help explain your problem. **Desktop (please complete the following information):**; - OS: macOS (MacBook Air, M1); - QuPath Version: 0.5.1-arm64. **Additional context**. Stack trace; ```; ERROR: unable to create native thread: possibly out of memory or process/resource limits reached in thread_leak_repro.groovy at line number 25; java.base/java.lang.Thread.start0(Native Method); java.base/java.lang.Thread.start(Unknown Source); java.base/java.lang.System$2.start(Unknown Source); java.base/jdk.internal.vm.SharedThreadContainer.start(Unknown Source); java.base/java.util.concurrent.ThreadPoolExecutor.addWorker(Unknown Source); java.base/java.util.concurrent.ThreadPoolExecutor.execute(Unknown Source); qupath.lib.gui.images.stores.AbstractImageRegionStore.req",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1561
https://github.com/qupath/qupath/issues/1561:2345,Performance,concurren,concurrent,2345,"f display = qupath.lib.display.ImageDisplay.create(imageData); def server = new RenderedImageServer.Builder(imageData); .display(display); .downsamples(downsample); .layers(new HierarchyOverlay(viewer.getImageRegionStore(), viewer.getOverlayOptions(), imageData)); .build(). ```. **Expected behavior**; The above script can run for the whole project without crashing. **Screenshots**; If applicable, add screenshots to help explain your problem. **Desktop (please complete the following information):**; - OS: macOS (MacBook Air, M1); - QuPath Version: 0.5.1-arm64. **Additional context**. Stack trace; ```; ERROR: unable to create native thread: possibly out of memory or process/resource limits reached in thread_leak_repro.groovy at line number 25; java.base/java.lang.Thread.start0(Native Method); java.base/java.lang.Thread.start(Unknown Source); java.base/java.lang.System$2.start(Unknown Source); java.base/jdk.internal.vm.SharedThreadContainer.start(Unknown Source); java.base/java.util.concurrent.ThreadPoolExecutor.addWorker(Unknown Source); java.base/java.util.concurrent.ThreadPoolExecutor.execute(Unknown Source); qupath.lib.gui.images.stores.AbstractImageRegionStore.requestImageTile(AbstractImageRegionStore.java:374); qupath.lib.gui.images.stores.DefaultImageRegionStore.paintRegionCompletely(DefaultImageRegionStore.java:104); qupath.lib.gui.images.servers.RenderedImageServer.readTile(RenderedImageServer.java:363); qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); java.base/java.util.concurrent.FutureTask.run(Unknown Source); qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); qupath.lib.images.writers.AbstractImageIOWriter.writeImage(AbstractIma",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1561
https://github.com/qupath/qupath/issues/1561:2422,Performance,concurren,concurrent,2422,"ew RenderedImageServer.Builder(imageData); .display(display); .downsamples(downsample); .layers(new HierarchyOverlay(viewer.getImageRegionStore(), viewer.getOverlayOptions(), imageData)); .build(). ```. **Expected behavior**; The above script can run for the whole project without crashing. **Screenshots**; If applicable, add screenshots to help explain your problem. **Desktop (please complete the following information):**; - OS: macOS (MacBook Air, M1); - QuPath Version: 0.5.1-arm64. **Additional context**. Stack trace; ```; ERROR: unable to create native thread: possibly out of memory or process/resource limits reached in thread_leak_repro.groovy at line number 25; java.base/java.lang.Thread.start0(Native Method); java.base/java.lang.Thread.start(Unknown Source); java.base/java.lang.System$2.start(Unknown Source); java.base/jdk.internal.vm.SharedThreadContainer.start(Unknown Source); java.base/java.util.concurrent.ThreadPoolExecutor.addWorker(Unknown Source); java.base/java.util.concurrent.ThreadPoolExecutor.execute(Unknown Source); qupath.lib.gui.images.stores.AbstractImageRegionStore.requestImageTile(AbstractImageRegionStore.java:374); qupath.lib.gui.images.stores.DefaultImageRegionStore.paintRegionCompletely(DefaultImageRegionStore.java:104); qupath.lib.gui.images.servers.RenderedImageServer.readTile(RenderedImageServer.java:363); qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); java.base/java.util.concurrent.FutureTask.run(Unknown Source); qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); qupath.lib.images.writers.AbstractImageIOWriter.writeImage(AbstractImageIOWriter.java:82); qupath.lib.images.writers.PngWriter.writeImage(PngWriter",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1561
https://github.com/qupath/qupath/issues/1561:2922,Performance,concurren,concurrent,2922,"l context**. Stack trace; ```; ERROR: unable to create native thread: possibly out of memory or process/resource limits reached in thread_leak_repro.groovy at line number 25; java.base/java.lang.Thread.start0(Native Method); java.base/java.lang.Thread.start(Unknown Source); java.base/java.lang.System$2.start(Unknown Source); java.base/jdk.internal.vm.SharedThreadContainer.start(Unknown Source); java.base/java.util.concurrent.ThreadPoolExecutor.addWorker(Unknown Source); java.base/java.util.concurrent.ThreadPoolExecutor.execute(Unknown Source); qupath.lib.gui.images.stores.AbstractImageRegionStore.requestImageTile(AbstractImageRegionStore.java:374); qupath.lib.gui.images.stores.DefaultImageRegionStore.paintRegionCompletely(DefaultImageRegionStore.java:104); qupath.lib.gui.images.servers.RenderedImageServer.readTile(RenderedImageServer.java:363); qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); java.base/java.util.concurrent.FutureTask.run(Unknown Source); qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); qupath.lib.images.writers.AbstractImageIOWriter.writeImage(AbstractImageIOWriter.java:82); qupath.lib.images.writers.PngWriter.writeImage(PngWriter.java:42); qupath.lib.images.writers.AbstractImageIOWriter.writeImage(AbstractImageIOWriter.java:96); qupath.lib.images.writers.PngWriter.writeImage(PngWriter.java:42); qupath.lib.images.writers.ImageWriterTools.writeImage(ImageWriterTools.java:163); qupath.lib.scripting.QP.writeImage(QP.java:3365); ```. `jstack -l` lists 4096 threads of the following kind; ```; ""region-store-1"" #4103 [2125611] prio=5 os_prio=31 cpu=0.27ms elapsed=19.36s tid=0x000000031cc05800 nid=2125611 waiting on condition [0",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1561
https://github.com/qupath/qupath/pull/1562:11,Safety,avoid,avoid,11,"This is to avoid the current `JavadocViewer -> JavadocViewerCommand -> JavadocViewer` chain of objects, with the same class name in both `qupath.ui.javadocviewer.gui.viewer` and `qupath.lib.gui`. See https://github.com/qupath/javadoc-viewer/pull/6",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1562
https://github.com/qupath/qupath/pull/1563:205,Deployability,release,releases,205,"## Background; A goal of this PR is to further reduce the requirement to refer to specific Java subclasses of `PathObject`, e.g. `PathDetectionObject`, `PathAnnotationObject`. This process started several releases back, e.g.; * `pathObject.isAnnotation()` should be used in preference of `pathObject instanceof PathAnnotationObject`; * `PathObjects.createAnnotationObject(ROI)` should be used instead of `new PathAnnotationObject(ROI)`. Eventually the specific subclasses may be removed entirely, in favor of using a single `PathObject` class. Along the way, the API should become easier to understand and to use. ## What has changed. One of the main times when the specific Java class remains relevant is when querying objects from `PathObjectHierarchy` using one of the following methods:; ```java; public Collection<PathObject> getObjectsForROI(Class<? extends PathObject> cls, ROI roi). public Collection<PathObject> getObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region, Collection<PathObject> pathObjects). public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). public synchronized Collection<PathObject> getPointObjects(Class<? extends PathObject> cls); ```. This PR deprecates these methods, and provides alternatives that do not require Java classes to be specified. ### Accessing objects for a `ROI`; This provides a way to access objects within (in some sense!) a specified ROI:; ```java; // Old method, discouraged (but not yet deprecated); public Collection<PathObject> getObjectsForROI(Class<? extends PathObject> cls, ROI roi). // New methods; public Collection<PathObject> getAllObjectsForROI(ROI roi); public Collection<PathObject> getAnnotationsForROI(ROI roi); public Collection<PathObject> getTilesForROI(ROI roi); public Collection<PathObject> getCellsForROI(ROI roi); public Collection<PathObject> getAllDetectionsForROI(ROI roi); ```. **There is an important (and possibly-unexpected) subtlety here!**. The new methods follow ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:6435,Deployability,update,updated,6435,"t> Collection<T> filterByROIIntersectsNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsNucleusCentroid(ROI roi, Collection<T> pathObjects); ```. In case you just want to check if objects are present quickly - but don't necessarily need the objects themselves - you can use:. ```java; // Old method, deprecated; public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). // New methods; public boolean hasObjectsForRegion(ImageRegion region); public boolean hasAnnotationsForRegion(ImageRegion region); public boolean hasDetectionsForRegion(ImageRegion region); ```. These should effectively report whether `getXXXForRegion` would return an empty collection or not, without needing to generate that collection. ### Accessing objects with point ROIs; This simply accesses objects then filters by ROI type. ```java; // Old method, deprecated; public synchronized Collection<PathObject> getPointObjects(Class<? extends PathObject> cls). // New methods; public Collection<PathObject> getAllPointObjects(); public Collection<PathObject> getAllPointAnnotations() ; ```; This should be sufficiently obscure that there is no need to have separate methods to request point objects of more classes. If you *really* need point detections, for example. filtering the resulting collection should be straightforward, e.g.; ```java; var pointAnnotations = hierarchy.getAllPointObjects().stream().filter(PathObject::isDetection).toList();; ```. ---. To support these changes, `GeometryROI.contains(x, y)` was also updated to make use of an [`IndexedPointInAreaLocator`](https://locationtech.github.io/jts/javadoc/org/locationtech/jts/algorithm/locate/IndexedPointInAreaLocator.html) for complex geometries - enabling centroid tests to benefit from performance improvements with no special logic required outside the `ROI` class itself. Also, some deprecated methods - and deprecated classes that used them - were removed.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:47,Energy Efficiency,reduce,reduce,47,"## Background; A goal of this PR is to further reduce the requirement to refer to specific Java subclasses of `PathObject`, e.g. `PathDetectionObject`, `PathAnnotationObject`. This process started several releases back, e.g.; * `pathObject.isAnnotation()` should be used in preference of `pathObject instanceof PathAnnotationObject`; * `PathObjects.createAnnotationObject(ROI)` should be used instead of `new PathAnnotationObject(ROI)`. Eventually the specific subclasses may be removed entirely, in favor of using a single `PathObject` class. Along the way, the API should become easier to understand and to use. ## What has changed. One of the main times when the specific Java class remains relevant is when querying objects from `PathObjectHierarchy` using one of the following methods:; ```java; public Collection<PathObject> getObjectsForROI(Class<? extends PathObject> cls, ROI roi). public Collection<PathObject> getObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region, Collection<PathObject> pathObjects). public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). public synchronized Collection<PathObject> getPointObjects(Class<? extends PathObject> cls); ```. This PR deprecates these methods, and provides alternatives that do not require Java classes to be specified. ### Accessing objects for a `ROI`; This provides a way to access objects within (in some sense!) a specified ROI:; ```java; // Old method, discouraged (but not yet deprecated); public Collection<PathObject> getObjectsForROI(Class<? extends PathObject> cls, ROI roi). // New methods; public Collection<PathObject> getAllObjectsForROI(ROI roi); public Collection<PathObject> getAnnotationsForROI(ROI roi); public Collection<PathObject> getTilesForROI(ROI roi); public Collection<PathObject> getCellsForROI(ROI roi); public Collection<PathObject> getAllDetectionsForROI(ROI roi); ```. **There is an important (and possibly-unexpected) subtlety here!**. The new methods follow ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:1127,Integrability,synchroniz,synchronized,1127,"bject`. This process started several releases back, e.g.; * `pathObject.isAnnotation()` should be used in preference of `pathObject instanceof PathAnnotationObject`; * `PathObjects.createAnnotationObject(ROI)` should be used instead of `new PathAnnotationObject(ROI)`. Eventually the specific subclasses may be removed entirely, in favor of using a single `PathObject` class. Along the way, the API should become easier to understand and to use. ## What has changed. One of the main times when the specific Java class remains relevant is when querying objects from `PathObjectHierarchy` using one of the following methods:; ```java; public Collection<PathObject> getObjectsForROI(Class<? extends PathObject> cls, ROI roi). public Collection<PathObject> getObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region, Collection<PathObject> pathObjects). public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). public synchronized Collection<PathObject> getPointObjects(Class<? extends PathObject> cls); ```. This PR deprecates these methods, and provides alternatives that do not require Java classes to be specified. ### Accessing objects for a `ROI`; This provides a way to access objects within (in some sense!) a specified ROI:; ```java; // Old method, discouraged (but not yet deprecated); public Collection<PathObject> getObjectsForROI(Class<? extends PathObject> cls, ROI roi). // New methods; public Collection<PathObject> getAllObjectsForROI(ROI roi); public Collection<PathObject> getAnnotationsForROI(ROI roi); public Collection<PathObject> getTilesForROI(ROI roi); public Collection<PathObject> getCellsForROI(ROI roi); public Collection<PathObject> getAllDetectionsForROI(ROI roi); ```. **There is an important (and possibly-unexpected) subtlety here!**. The new methods follow the original in *returning objects using QuPath's 'hierarchy' rules*:; * An annotation is 'within' a ROI if it is *completely contained* by the ROI; * A detection is '",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:5785,Integrability,synchroniz,synchronized,5785,"); public static <T extends PathObject> Collection<T> filterByROIIntersectsNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsNucleusCentroid(ROI roi, Collection<T> pathObjects); ```. In case you just want to check if objects are present quickly - but don't necessarily need the objects themselves - you can use:. ```java; // Old method, deprecated; public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). // New methods; public boolean hasObjectsForRegion(ImageRegion region); public boolean hasAnnotationsForRegion(ImageRegion region); public boolean hasDetectionsForRegion(ImageRegion region); ```. These should effectively report whether `getXXXForRegion` would return an empty collection or not, without needing to generate that collection. ### Accessing objects with point ROIs; This simply accesses objects then filters by ROI type. ```java; // Old method, deprecated; public synchronized Collection<PathObject> getPointObjects(Class<? extends PathObject> cls). // New methods; public Collection<PathObject> getAllPointObjects(); public Collection<PathObject> getAllPointAnnotations() ; ```; This should be sufficiently obscure that there is no need to have separate methods to request point objects of more classes. If you *really* need point detections, for example. filtering the resulting collection should be straightforward, e.g.; ```java; var pointAnnotations = hierarchy.getAllPointObjects().stream().filter(PathObject::isDetection).toList();; ```. ---. To support these changes, `GeometryROI.contains(x, y)` was also updated to make use of an [`IndexedPointInAreaLocator`](https://locationtech.github.io/jts/javadoc/org/locationtech/jts/algorithm/locate/IndexedPointInAreaLocator.html) for complex geometries - enabling centroid tests to benefit from performance improvements with no special logic required outside the `ROI` class itself. Also, some deprecated methods - and deprecated cl",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:856,Modifiability,extend,extends,856,"## Background; A goal of this PR is to further reduce the requirement to refer to specific Java subclasses of `PathObject`, e.g. `PathDetectionObject`, `PathAnnotationObject`. This process started several releases back, e.g.; * `pathObject.isAnnotation()` should be used in preference of `pathObject instanceof PathAnnotationObject`; * `PathObjects.createAnnotationObject(ROI)` should be used instead of `new PathAnnotationObject(ROI)`. Eventually the specific subclasses may be removed entirely, in favor of using a single `PathObject` class. Along the way, the API should become easier to understand and to use. ## What has changed. One of the main times when the specific Java class remains relevant is when querying objects from `PathObjectHierarchy` using one of the following methods:; ```java; public Collection<PathObject> getObjectsForROI(Class<? extends PathObject> cls, ROI roi). public Collection<PathObject> getObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region, Collection<PathObject> pathObjects). public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). public synchronized Collection<PathObject> getPointObjects(Class<? extends PathObject> cls); ```. This PR deprecates these methods, and provides alternatives that do not require Java classes to be specified. ### Accessing objects for a `ROI`; This provides a way to access objects within (in some sense!) a specified ROI:; ```java; // Old method, discouraged (but not yet deprecated); public Collection<PathObject> getObjectsForROI(Class<? extends PathObject> cls, ROI roi). // New methods; public Collection<PathObject> getAllObjectsForROI(ROI roi); public Collection<PathObject> getAnnotationsForROI(ROI roi); public Collection<PathObject> getTilesForROI(ROI roi); public Collection<PathObject> getCellsForROI(ROI roi); public Collection<PathObject> getAllDetectionsForROI(ROI roi); ```. **There is an important (and possibly-unexpected) subtlety here!**. The new methods follow ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:949,Modifiability,extend,extends,949,"## Background; A goal of this PR is to further reduce the requirement to refer to specific Java subclasses of `PathObject`, e.g. `PathDetectionObject`, `PathAnnotationObject`. This process started several releases back, e.g.; * `pathObject.isAnnotation()` should be used in preference of `pathObject instanceof PathAnnotationObject`; * `PathObjects.createAnnotationObject(ROI)` should be used instead of `new PathAnnotationObject(ROI)`. Eventually the specific subclasses may be removed entirely, in favor of using a single `PathObject` class. Along the way, the API should become easier to understand and to use. ## What has changed. One of the main times when the specific Java class remains relevant is when querying objects from `PathObjectHierarchy` using one of the following methods:; ```java; public Collection<PathObject> getObjectsForROI(Class<? extends PathObject> cls, ROI roi). public Collection<PathObject> getObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region, Collection<PathObject> pathObjects). public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). public synchronized Collection<PathObject> getPointObjects(Class<? extends PathObject> cls); ```. This PR deprecates these methods, and provides alternatives that do not require Java classes to be specified. ### Accessing objects for a `ROI`; This provides a way to access objects within (in some sense!) a specified ROI:; ```java; // Old method, discouraged (but not yet deprecated); public Collection<PathObject> getObjectsForROI(Class<? extends PathObject> cls, ROI roi). // New methods; public Collection<PathObject> getAllObjectsForROI(ROI roi); public Collection<PathObject> getAnnotationsForROI(ROI roi); public Collection<PathObject> getTilesForROI(ROI roi); public Collection<PathObject> getCellsForROI(ROI roi); public Collection<PathObject> getAllDetectionsForROI(ROI roi); ```. **There is an important (and possibly-unexpected) subtlety here!**. The new methods follow ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:1074,Modifiability,extend,extends,1074,"efer to specific Java subclasses of `PathObject`, e.g. `PathDetectionObject`, `PathAnnotationObject`. This process started several releases back, e.g.; * `pathObject.isAnnotation()` should be used in preference of `pathObject instanceof PathAnnotationObject`; * `PathObjects.createAnnotationObject(ROI)` should be used instead of `new PathAnnotationObject(ROI)`. Eventually the specific subclasses may be removed entirely, in favor of using a single `PathObject` class. Along the way, the API should become easier to understand and to use. ## What has changed. One of the main times when the specific Java class remains relevant is when querying objects from `PathObjectHierarchy` using one of the following methods:; ```java; public Collection<PathObject> getObjectsForROI(Class<? extends PathObject> cls, ROI roi). public Collection<PathObject> getObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region, Collection<PathObject> pathObjects). public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). public synchronized Collection<PathObject> getPointObjects(Class<? extends PathObject> cls); ```. This PR deprecates these methods, and provides alternatives that do not require Java classes to be specified. ### Accessing objects for a `ROI`; This provides a way to access objects within (in some sense!) a specified ROI:; ```java; // Old method, discouraged (but not yet deprecated); public Collection<PathObject> getObjectsForROI(Class<? extends PathObject> cls, ROI roi). // New methods; public Collection<PathObject> getAllObjectsForROI(ROI roi); public Collection<PathObject> getAnnotationsForROI(ROI roi); public Collection<PathObject> getTilesForROI(ROI roi); public Collection<PathObject> getCellsForROI(ROI roi); public Collection<PathObject> getAllDetectionsForROI(ROI roi); ```. **There is an important (and possibly-unexpected) subtlety here!**. The new methods follow the original in *returning objects using QuPath's 'hierarchy' rules*:; * A",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:1187,Modifiability,extend,extends,1187,"bject`. This process started several releases back, e.g.; * `pathObject.isAnnotation()` should be used in preference of `pathObject instanceof PathAnnotationObject`; * `PathObjects.createAnnotationObject(ROI)` should be used instead of `new PathAnnotationObject(ROI)`. Eventually the specific subclasses may be removed entirely, in favor of using a single `PathObject` class. Along the way, the API should become easier to understand and to use. ## What has changed. One of the main times when the specific Java class remains relevant is when querying objects from `PathObjectHierarchy` using one of the following methods:; ```java; public Collection<PathObject> getObjectsForROI(Class<? extends PathObject> cls, ROI roi). public Collection<PathObject> getObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region, Collection<PathObject> pathObjects). public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). public synchronized Collection<PathObject> getPointObjects(Class<? extends PathObject> cls); ```. This PR deprecates these methods, and provides alternatives that do not require Java classes to be specified. ### Accessing objects for a `ROI`; This provides a way to access objects within (in some sense!) a specified ROI:; ```java; // Old method, discouraged (but not yet deprecated); public Collection<PathObject> getObjectsForROI(Class<? extends PathObject> cls, ROI roi). // New methods; public Collection<PathObject> getAllObjectsForROI(ROI roi); public Collection<PathObject> getAnnotationsForROI(ROI roi); public Collection<PathObject> getTilesForROI(ROI roi); public Collection<PathObject> getCellsForROI(ROI roi); public Collection<PathObject> getAllDetectionsForROI(ROI roi); ```. **There is an important (and possibly-unexpected) subtlety here!**. The new methods follow the original in *returning objects using QuPath's 'hierarchy' rules*:; * An annotation is 'within' a ROI if it is *completely contained* by the ROI; * A detection is '",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:1560,Modifiability,extend,extends,1560," subclasses may be removed entirely, in favor of using a single `PathObject` class. Along the way, the API should become easier to understand and to use. ## What has changed. One of the main times when the specific Java class remains relevant is when querying objects from `PathObjectHierarchy` using one of the following methods:; ```java; public Collection<PathObject> getObjectsForROI(Class<? extends PathObject> cls, ROI roi). public Collection<PathObject> getObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region, Collection<PathObject> pathObjects). public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). public synchronized Collection<PathObject> getPointObjects(Class<? extends PathObject> cls); ```. This PR deprecates these methods, and provides alternatives that do not require Java classes to be specified. ### Accessing objects for a `ROI`; This provides a way to access objects within (in some sense!) a specified ROI:; ```java; // Old method, discouraged (but not yet deprecated); public Collection<PathObject> getObjectsForROI(Class<? extends PathObject> cls, ROI roi). // New methods; public Collection<PathObject> getAllObjectsForROI(ROI roi); public Collection<PathObject> getAnnotationsForROI(ROI roi); public Collection<PathObject> getTilesForROI(ROI roi); public Collection<PathObject> getCellsForROI(ROI roi); public Collection<PathObject> getAllDetectionsForROI(ROI roi); ```. **There is an important (and possibly-unexpected) subtlety here!**. The new methods follow the original in *returning objects using QuPath's 'hierarchy' rules*:; * An annotation is 'within' a ROI if it is *completely contained* by the ROI; * A detection is 'within' a ROI if *its centroid* is within the ROI. Note that these methods take a `ROI` as input and not a `PathObject`: they aren't using the parent/child relationships between objects when deciding what to return. However they do correspond with how QuPath determines dynamic measurements (e",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:2913,Modifiability,extend,extends,2913,"``. **There is an important (and possibly-unexpected) subtlety here!**. The new methods follow the original in *returning objects using QuPath's 'hierarchy' rules*:; * An annotation is 'within' a ROI if it is *completely contained* by the ROI; * A detection is 'within' a ROI if *its centroid* is within the ROI. Note that these methods take a `ROI` as input and not a `PathObject`: they aren't using the parent/child relationships between objects when deciding what to return. However they do correspond with how QuPath determines dynamic measurements (e.g. Positive % of cells), or what happens when `resolveHierarchy()` is called. If all this seems too confusing and you just want to get objects for a defined area, you may instead want to try... ### Accessing objects for an `ImageRegion`; This provides a way to get all objects that intersect (or even just *may* intersect) with a specified 2D image region. ```java; // Old method, deprecated; public Collection<PathObject> getObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region, Collection<PathObject> pathObjects). // New methods (the collection parameter is optional & can be null); public Collection<PathObject> getAllObjectsForRegion(ImageRegion region, Collection<PathObject> pathObjects); public Collection<PathObject> getAnnotationsForRegion(ImageRegion region, Collection<PathObject> pathObjects); public Collection<PathObject> getAllDetectionsForRegion(ImageRegion region, Collection<PathObject> pathObjects). public Collection<PathObject> getAllObjectsForRegion(ImageRegion region); public Collection<PathObject> getAnnotationsForRegion(ImageRegion region); public Collection<PathObject> getAllDetectionsForRegion(ImageRegion region); ```. As the javadocs mention, this is permitted to return *too many objects*.; Its purpose is to act as a fast spatial cache, where returned objects are likely to be filtered further. To help with this, there are new methods in `PathObjectTools`:; ```java; public static <T extends ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:3898,Modifiability,extend,extends,3898,"ptional & can be null); public Collection<PathObject> getAllObjectsForRegion(ImageRegion region, Collection<PathObject> pathObjects); public Collection<PathObject> getAnnotationsForRegion(ImageRegion region, Collection<PathObject> pathObjects); public Collection<PathObject> getAllDetectionsForRegion(ImageRegion region, Collection<PathObject> pathObjects). public Collection<PathObject> getAllObjectsForRegion(ImageRegion region); public Collection<PathObject> getAnnotationsForRegion(ImageRegion region); public Collection<PathObject> getAllDetectionsForRegion(ImageRegion region); ```. As the javadocs mention, this is permitted to return *too many objects*.; Its purpose is to act as a fast spatial cache, where returned objects are likely to be filtered further. To help with this, there are new methods in `PathObjectTools`:; ```java; public static <T extends PathObject> Collection<T> filterByROICovers(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIIntersects(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsCentroid(ROI roi, Collection<T> pathObjects); ```; These can apply filters that normally require some `ROI.getGeometry()` gymnastics, and may be faster through the use of prepared geometries and parallel streams. When cells are involved, one might want to perform the tests using the *nucleus* ROI rather than the main (outer) ROI. This is also what happens internally with the hierarchy checks (i.e. the nucleus centroid is used where possible to check if a cell is inside a ROI). The following methods support that:; ```java; public static <T extends PathObject> Collection<T> filterByROICoversNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIIntersectsNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsNucleusCentroid(ROI roi, Collection<T> pathObj",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:4004,Modifiability,extend,extends,4004,"ptional & can be null); public Collection<PathObject> getAllObjectsForRegion(ImageRegion region, Collection<PathObject> pathObjects); public Collection<PathObject> getAnnotationsForRegion(ImageRegion region, Collection<PathObject> pathObjects); public Collection<PathObject> getAllDetectionsForRegion(ImageRegion region, Collection<PathObject> pathObjects). public Collection<PathObject> getAllObjectsForRegion(ImageRegion region); public Collection<PathObject> getAnnotationsForRegion(ImageRegion region); public Collection<PathObject> getAllDetectionsForRegion(ImageRegion region); ```. As the javadocs mention, this is permitted to return *too many objects*.; Its purpose is to act as a fast spatial cache, where returned objects are likely to be filtered further. To help with this, there are new methods in `PathObjectTools`:; ```java; public static <T extends PathObject> Collection<T> filterByROICovers(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIIntersects(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsCentroid(ROI roi, Collection<T> pathObjects); ```; These can apply filters that normally require some `ROI.getGeometry()` gymnastics, and may be faster through the use of prepared geometries and parallel streams. When cells are involved, one might want to perform the tests using the *nucleus* ROI rather than the main (outer) ROI. This is also what happens internally with the hierarchy checks (i.e. the nucleus centroid is used where possible to check if a cell is inside a ROI). The following methods support that:; ```java; public static <T extends PathObject> Collection<T> filterByROICoversNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIIntersectsNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsNucleusCentroid(ROI roi, Collection<T> pathObj",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:4114,Modifiability,extend,extends,4114,"ptional & can be null); public Collection<PathObject> getAllObjectsForRegion(ImageRegion region, Collection<PathObject> pathObjects); public Collection<PathObject> getAnnotationsForRegion(ImageRegion region, Collection<PathObject> pathObjects); public Collection<PathObject> getAllDetectionsForRegion(ImageRegion region, Collection<PathObject> pathObjects). public Collection<PathObject> getAllObjectsForRegion(ImageRegion region); public Collection<PathObject> getAnnotationsForRegion(ImageRegion region); public Collection<PathObject> getAllDetectionsForRegion(ImageRegion region); ```. As the javadocs mention, this is permitted to return *too many objects*.; Its purpose is to act as a fast spatial cache, where returned objects are likely to be filtered further. To help with this, there are new methods in `PathObjectTools`:; ```java; public static <T extends PathObject> Collection<T> filterByROICovers(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIIntersects(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsCentroid(ROI roi, Collection<T> pathObjects); ```; These can apply filters that normally require some `ROI.getGeometry()` gymnastics, and may be faster through the use of prepared geometries and parallel streams. When cells are involved, one might want to perform the tests using the *nucleus* ROI rather than the main (outer) ROI. This is also what happens internally with the hierarchy checks (i.e. the nucleus centroid is used where possible to check if a cell is inside a ROI). The following methods support that:; ```java; public static <T extends PathObject> Collection<T> filterByROICoversNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIIntersectsNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsNucleusCentroid(ROI roi, Collection<T> pathObj",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:4712,Modifiability,extend,extends,4712,"n `PathObjectTools`:; ```java; public static <T extends PathObject> Collection<T> filterByROICovers(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIIntersects(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsCentroid(ROI roi, Collection<T> pathObjects); ```; These can apply filters that normally require some `ROI.getGeometry()` gymnastics, and may be faster through the use of prepared geometries and parallel streams. When cells are involved, one might want to perform the tests using the *nucleus* ROI rather than the main (outer) ROI. This is also what happens internally with the hierarchy checks (i.e. the nucleus centroid is used where possible to check if a cell is inside a ROI). The following methods support that:; ```java; public static <T extends PathObject> Collection<T> filterByROICoversNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIIntersectsNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsNucleusCentroid(ROI roi, Collection<T> pathObjects); ```. In case you just want to check if objects are present quickly - but don't necessarily need the objects themselves - you can use:. ```java; // Old method, deprecated; public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). // New methods; public boolean hasObjectsForRegion(ImageRegion region); public boolean hasAnnotationsForRegion(ImageRegion region); public boolean hasDetectionsForRegion(ImageRegion region); ```. These should effectively report whether `getXXXForRegion` would return an empty collection or not, without needing to generate that collection. ### Accessing objects with point ROIs; This simply accesses objects then filters by ROI type. ```java; // Old method, deprecated; public synchronized Collection<PathObject> getPointObjects(Class<? exten",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:4825,Modifiability,extend,extends,4825,"n `PathObjectTools`:; ```java; public static <T extends PathObject> Collection<T> filterByROICovers(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIIntersects(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsCentroid(ROI roi, Collection<T> pathObjects); ```; These can apply filters that normally require some `ROI.getGeometry()` gymnastics, and may be faster through the use of prepared geometries and parallel streams. When cells are involved, one might want to perform the tests using the *nucleus* ROI rather than the main (outer) ROI. This is also what happens internally with the hierarchy checks (i.e. the nucleus centroid is used where possible to check if a cell is inside a ROI). The following methods support that:; ```java; public static <T extends PathObject> Collection<T> filterByROICoversNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIIntersectsNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsNucleusCentroid(ROI roi, Collection<T> pathObjects); ```. In case you just want to check if objects are present quickly - but don't necessarily need the objects themselves - you can use:. ```java; // Old method, deprecated; public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). // New methods; public boolean hasObjectsForRegion(ImageRegion region); public boolean hasAnnotationsForRegion(ImageRegion region); public boolean hasDetectionsForRegion(ImageRegion region); ```. These should effectively report whether `getXXXForRegion` would return an empty collection or not, without needing to generate that collection. ### Accessing objects with point ROIs; This simply accesses objects then filters by ROI type. ```java; // Old method, deprecated; public synchronized Collection<PathObject> getPointObjects(Class<? exten",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:4942,Modifiability,extend,extends,4942,"n `PathObjectTools`:; ```java; public static <T extends PathObject> Collection<T> filterByROICovers(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIIntersects(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsCentroid(ROI roi, Collection<T> pathObjects); ```; These can apply filters that normally require some `ROI.getGeometry()` gymnastics, and may be faster through the use of prepared geometries and parallel streams. When cells are involved, one might want to perform the tests using the *nucleus* ROI rather than the main (outer) ROI. This is also what happens internally with the hierarchy checks (i.e. the nucleus centroid is used where possible to check if a cell is inside a ROI). The following methods support that:; ```java; public static <T extends PathObject> Collection<T> filterByROICoversNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIIntersectsNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsNucleusCentroid(ROI roi, Collection<T> pathObjects); ```. In case you just want to check if objects are present quickly - but don't necessarily need the objects themselves - you can use:. ```java; // Old method, deprecated; public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). // New methods; public boolean hasObjectsForRegion(ImageRegion region); public boolean hasAnnotationsForRegion(ImageRegion region); public boolean hasDetectionsForRegion(ImageRegion region); ```. These should effectively report whether `getXXXForRegion` would return an empty collection or not, without needing to generate that collection. ### Accessing objects with point ROIs; This simply accesses objects then filters by ROI type. ```java; // Old method, deprecated; public synchronized Collection<PathObject> getPointObjects(Class<? exten",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:5262,Modifiability,extend,extends,5262,"at normally require some `ROI.getGeometry()` gymnastics, and may be faster through the use of prepared geometries and parallel streams. When cells are involved, one might want to perform the tests using the *nucleus* ROI rather than the main (outer) ROI. This is also what happens internally with the hierarchy checks (i.e. the nucleus centroid is used where possible to check if a cell is inside a ROI). The following methods support that:; ```java; public static <T extends PathObject> Collection<T> filterByROICoversNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIIntersectsNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsNucleusCentroid(ROI roi, Collection<T> pathObjects); ```. In case you just want to check if objects are present quickly - but don't necessarily need the objects themselves - you can use:. ```java; // Old method, deprecated; public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). // New methods; public boolean hasObjectsForRegion(ImageRegion region); public boolean hasAnnotationsForRegion(ImageRegion region); public boolean hasDetectionsForRegion(ImageRegion region); ```. These should effectively report whether `getXXXForRegion` would return an empty collection or not, without needing to generate that collection. ### Accessing objects with point ROIs; This simply accesses objects then filters by ROI type. ```java; // Old method, deprecated; public synchronized Collection<PathObject> getPointObjects(Class<? extends PathObject> cls). // New methods; public Collection<PathObject> getAllPointObjects(); public Collection<PathObject> getAllPointAnnotations() ; ```; This should be sufficiently obscure that there is no need to have separate methods to request point objects of more classes. If you *really* need point detections, for example. filtering the resulting collection should be straightforward, e.g.;",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:5845,Modifiability,extend,extends,5845,"); public static <T extends PathObject> Collection<T> filterByROIIntersectsNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsNucleusCentroid(ROI roi, Collection<T> pathObjects); ```. In case you just want to check if objects are present quickly - but don't necessarily need the objects themselves - you can use:. ```java; // Old method, deprecated; public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). // New methods; public boolean hasObjectsForRegion(ImageRegion region); public boolean hasAnnotationsForRegion(ImageRegion region); public boolean hasDetectionsForRegion(ImageRegion region); ```. These should effectively report whether `getXXXForRegion` would return an empty collection or not, without needing to generate that collection. ### Accessing objects with point ROIs; This simply accesses objects then filters by ROI type. ```java; // Old method, deprecated; public synchronized Collection<PathObject> getPointObjects(Class<? extends PathObject> cls). // New methods; public Collection<PathObject> getAllPointObjects(); public Collection<PathObject> getAllPointAnnotations() ; ```; This should be sufficiently obscure that there is no need to have separate methods to request point objects of more classes. If you *really* need point detections, for example. filtering the resulting collection should be straightforward, e.g.; ```java; var pointAnnotations = hierarchy.getAllPointObjects().stream().filter(PathObject::isDetection).toList();; ```. ---. To support these changes, `GeometryROI.contains(x, y)` was also updated to make use of an [`IndexedPointInAreaLocator`](https://locationtech.github.io/jts/javadoc/org/locationtech/jts/algorithm/locate/IndexedPointInAreaLocator.html) for complex geometries - enabling centroid tests to benefit from performance improvements with no special logic required outside the `ROI` class itself. Also, some deprecated methods - and deprecated cl",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:3743,Performance,cache,cache,3743,"(or even just *may* intersect) with a specified 2D image region. ```java; // Old method, deprecated; public Collection<PathObject> getObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region, Collection<PathObject> pathObjects). // New methods (the collection parameter is optional & can be null); public Collection<PathObject> getAllObjectsForRegion(ImageRegion region, Collection<PathObject> pathObjects); public Collection<PathObject> getAnnotationsForRegion(ImageRegion region, Collection<PathObject> pathObjects); public Collection<PathObject> getAllDetectionsForRegion(ImageRegion region, Collection<PathObject> pathObjects). public Collection<PathObject> getAllObjectsForRegion(ImageRegion region); public Collection<PathObject> getAnnotationsForRegion(ImageRegion region); public Collection<PathObject> getAllDetectionsForRegion(ImageRegion region); ```. As the javadocs mention, this is permitted to return *too many objects*.; Its purpose is to act as a fast spatial cache, where returned objects are likely to be filtered further. To help with this, there are new methods in `PathObjectTools`:; ```java; public static <T extends PathObject> Collection<T> filterByROICovers(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIIntersects(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsCentroid(ROI roi, Collection<T> pathObjects); ```; These can apply filters that normally require some `ROI.getGeometry()` gymnastics, and may be faster through the use of prepared geometries and parallel streams. When cells are involved, one might want to perform the tests using the *nucleus* ROI rather than the main (outer) ROI. This is also what happens internally with the hierarchy checks (i.e. the nucleus centroid is used where possible to check if a cell is inside a ROI). The following methods support that:; ```java; public static <T extends PathObject> Collection<T> filterBy",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:4423,Performance,perform,perform,4423,"ctsForRegion(ImageRegion region); public Collection<PathObject> getAnnotationsForRegion(ImageRegion region); public Collection<PathObject> getAllDetectionsForRegion(ImageRegion region); ```. As the javadocs mention, this is permitted to return *too many objects*.; Its purpose is to act as a fast spatial cache, where returned objects are likely to be filtered further. To help with this, there are new methods in `PathObjectTools`:; ```java; public static <T extends PathObject> Collection<T> filterByROICovers(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIIntersects(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsCentroid(ROI roi, Collection<T> pathObjects); ```; These can apply filters that normally require some `ROI.getGeometry()` gymnastics, and may be faster through the use of prepared geometries and parallel streams. When cells are involved, one might want to perform the tests using the *nucleus* ROI rather than the main (outer) ROI. This is also what happens internally with the hierarchy checks (i.e. the nucleus centroid is used where possible to check if a cell is inside a ROI). The following methods support that:; ```java; public static <T extends PathObject> Collection<T> filterByROICoversNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIIntersectsNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsNucleusCentroid(ROI roi, Collection<T> pathObjects); ```. In case you just want to check if objects are present quickly - but don't necessarily need the objects themselves - you can use:. ```java; // Old method, deprecated; public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). // New methods; public boolean hasObjectsForRegion(ImageRegion region); public boolean hasAnnotationsForRegion(ImageRegion region);",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:6669,Performance,perform,performance,6669,"t> Collection<T> filterByROIIntersectsNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsNucleusCentroid(ROI roi, Collection<T> pathObjects); ```. In case you just want to check if objects are present quickly - but don't necessarily need the objects themselves - you can use:. ```java; // Old method, deprecated; public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). // New methods; public boolean hasObjectsForRegion(ImageRegion region); public boolean hasAnnotationsForRegion(ImageRegion region); public boolean hasDetectionsForRegion(ImageRegion region); ```. These should effectively report whether `getXXXForRegion` would return an empty collection or not, without needing to generate that collection. ### Accessing objects with point ROIs; This simply accesses objects then filters by ROI type. ```java; // Old method, deprecated; public synchronized Collection<PathObject> getPointObjects(Class<? extends PathObject> cls). // New methods; public Collection<PathObject> getAllPointObjects(); public Collection<PathObject> getAllPointAnnotations() ; ```; This should be sufficiently obscure that there is no need to have separate methods to request point objects of more classes. If you *really* need point detections, for example. filtering the resulting collection should be straightforward, e.g.; ```java; var pointAnnotations = hierarchy.getAllPointObjects().stream().filter(PathObject::isDetection).toList();; ```. ---. To support these changes, `GeometryROI.contains(x, y)` was also updated to make use of an [`IndexedPointInAreaLocator`](https://locationtech.github.io/jts/javadoc/org/locationtech/jts/algorithm/locate/IndexedPointInAreaLocator.html) for complex geometries - enabling centroid tests to benefit from performance improvements with no special logic required outside the `ROI` class itself. Also, some deprecated methods - and deprecated classes that used them - were removed.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:2154,Safety,detect,detection,2154,", ImageRegion region). public synchronized Collection<PathObject> getPointObjects(Class<? extends PathObject> cls); ```. This PR deprecates these methods, and provides alternatives that do not require Java classes to be specified. ### Accessing objects for a `ROI`; This provides a way to access objects within (in some sense!) a specified ROI:; ```java; // Old method, discouraged (but not yet deprecated); public Collection<PathObject> getObjectsForROI(Class<? extends PathObject> cls, ROI roi). // New methods; public Collection<PathObject> getAllObjectsForROI(ROI roi); public Collection<PathObject> getAnnotationsForROI(ROI roi); public Collection<PathObject> getTilesForROI(ROI roi); public Collection<PathObject> getCellsForROI(ROI roi); public Collection<PathObject> getAllDetectionsForROI(ROI roi); ```. **There is an important (and possibly-unexpected) subtlety here!**. The new methods follow the original in *returning objects using QuPath's 'hierarchy' rules*:; * An annotation is 'within' a ROI if it is *completely contained* by the ROI; * A detection is 'within' a ROI if *its centroid* is within the ROI. Note that these methods take a `ROI` as input and not a `PathObject`: they aren't using the parent/child relationships between objects when deciding what to return. However they do correspond with how QuPath determines dynamic measurements (e.g. Positive % of cells), or what happens when `resolveHierarchy()` is called. If all this seems too confusing and you just want to get objects for a defined area, you may instead want to try... ### Accessing objects for an `ImageRegion`; This provides a way to get all objects that intersect (or even just *may* intersect) with a specified 2D image region. ```java; // Old method, deprecated; public Collection<PathObject> getObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region, Collection<PathObject> pathObjects). // New methods (the collection parameter is optional & can be null); public Collection<PathObject> getA",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:6153,Safety,detect,detections,6153,"t> Collection<T> filterByROIIntersectsNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsNucleusCentroid(ROI roi, Collection<T> pathObjects); ```. In case you just want to check if objects are present quickly - but don't necessarily need the objects themselves - you can use:. ```java; // Old method, deprecated; public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). // New methods; public boolean hasObjectsForRegion(ImageRegion region); public boolean hasAnnotationsForRegion(ImageRegion region); public boolean hasDetectionsForRegion(ImageRegion region); ```. These should effectively report whether `getXXXForRegion` would return an empty collection or not, without needing to generate that collection. ### Accessing objects with point ROIs; This simply accesses objects then filters by ROI type. ```java; // Old method, deprecated; public synchronized Collection<PathObject> getPointObjects(Class<? extends PathObject> cls). // New methods; public Collection<PathObject> getAllPointObjects(); public Collection<PathObject> getAllPointAnnotations() ; ```; This should be sufficiently obscure that there is no need to have separate methods to request point objects of more classes. If you *really* need point detections, for example. filtering the resulting collection should be straightforward, e.g.; ```java; var pointAnnotations = hierarchy.getAllPointObjects().stream().filter(PathObject::isDetection).toList();; ```. ---. To support these changes, `GeometryROI.contains(x, y)` was also updated to make use of an [`IndexedPointInAreaLocator`](https://locationtech.github.io/jts/javadoc/org/locationtech/jts/algorithm/locate/IndexedPointInAreaLocator.html) for complex geometries - enabling centroid tests to benefit from performance improvements with no special logic required outside the `ROI` class itself. Also, some deprecated methods - and deprecated classes that used them - were removed.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:1332,Security,Access,Accessing,1332," subclasses may be removed entirely, in favor of using a single `PathObject` class. Along the way, the API should become easier to understand and to use. ## What has changed. One of the main times when the specific Java class remains relevant is when querying objects from `PathObjectHierarchy` using one of the following methods:; ```java; public Collection<PathObject> getObjectsForROI(Class<? extends PathObject> cls, ROI roi). public Collection<PathObject> getObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region, Collection<PathObject> pathObjects). public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). public synchronized Collection<PathObject> getPointObjects(Class<? extends PathObject> cls); ```. This PR deprecates these methods, and provides alternatives that do not require Java classes to be specified. ### Accessing objects for a `ROI`; This provides a way to access objects within (in some sense!) a specified ROI:; ```java; // Old method, discouraged (but not yet deprecated); public Collection<PathObject> getObjectsForROI(Class<? extends PathObject> cls, ROI roi). // New methods; public Collection<PathObject> getAllObjectsForROI(ROI roi); public Collection<PathObject> getAnnotationsForROI(ROI roi); public Collection<PathObject> getTilesForROI(ROI roi); public Collection<PathObject> getCellsForROI(ROI roi); public Collection<PathObject> getAllDetectionsForROI(ROI roi); ```. **There is an important (and possibly-unexpected) subtlety here!**. The new methods follow the original in *returning objects using QuPath's 'hierarchy' rules*:; * An annotation is 'within' a ROI if it is *completely contained* by the ROI; * A detection is 'within' a ROI if *its centroid* is within the ROI. Note that these methods take a `ROI` as input and not a `PathObject`: they aren't using the parent/child relationships between objects when deciding what to return. However they do correspond with how QuPath determines dynamic measurements (e",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:1386,Security,access,access,1386," subclasses may be removed entirely, in favor of using a single `PathObject` class. Along the way, the API should become easier to understand and to use. ## What has changed. One of the main times when the specific Java class remains relevant is when querying objects from `PathObjectHierarchy` using one of the following methods:; ```java; public Collection<PathObject> getObjectsForROI(Class<? extends PathObject> cls, ROI roi). public Collection<PathObject> getObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region, Collection<PathObject> pathObjects). public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). public synchronized Collection<PathObject> getPointObjects(Class<? extends PathObject> cls); ```. This PR deprecates these methods, and provides alternatives that do not require Java classes to be specified. ### Accessing objects for a `ROI`; This provides a way to access objects within (in some sense!) a specified ROI:; ```java; // Old method, discouraged (but not yet deprecated); public Collection<PathObject> getObjectsForROI(Class<? extends PathObject> cls, ROI roi). // New methods; public Collection<PathObject> getAllObjectsForROI(ROI roi); public Collection<PathObject> getAnnotationsForROI(ROI roi); public Collection<PathObject> getTilesForROI(ROI roi); public Collection<PathObject> getCellsForROI(ROI roi); public Collection<PathObject> getAllDetectionsForROI(ROI roi); ```. **There is an important (and possibly-unexpected) subtlety here!**. The new methods follow the original in *returning objects using QuPath's 'hierarchy' rules*:; * An annotation is 'within' a ROI if it is *completely contained* by the ROI; * A detection is 'within' a ROI if *its centroid* is within the ROI. Note that these methods take a `ROI` as input and not a `PathObject`: they aren't using the parent/child relationships between objects when deciding what to return. However they do correspond with how QuPath determines dynamic measurements (e",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:2660,Security,Access,Accessing,2660,"ic Collection<PathObject> getTilesForROI(ROI roi); public Collection<PathObject> getCellsForROI(ROI roi); public Collection<PathObject> getAllDetectionsForROI(ROI roi); ```. **There is an important (and possibly-unexpected) subtlety here!**. The new methods follow the original in *returning objects using QuPath's 'hierarchy' rules*:; * An annotation is 'within' a ROI if it is *completely contained* by the ROI; * A detection is 'within' a ROI if *its centroid* is within the ROI. Note that these methods take a `ROI` as input and not a `PathObject`: they aren't using the parent/child relationships between objects when deciding what to return. However they do correspond with how QuPath determines dynamic measurements (e.g. Positive % of cells), or what happens when `resolveHierarchy()` is called. If all this seems too confusing and you just want to get objects for a defined area, you may instead want to try... ### Accessing objects for an `ImageRegion`; This provides a way to get all objects that intersect (or even just *may* intersect) with a specified 2D image region. ```java; // Old method, deprecated; public Collection<PathObject> getObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region, Collection<PathObject> pathObjects). // New methods (the collection parameter is optional & can be null); public Collection<PathObject> getAllObjectsForRegion(ImageRegion region, Collection<PathObject> pathObjects); public Collection<PathObject> getAnnotationsForRegion(ImageRegion region, Collection<PathObject> pathObjects); public Collection<PathObject> getAllDetectionsForRegion(ImageRegion region, Collection<PathObject> pathObjects). public Collection<PathObject> getAllObjectsForRegion(ImageRegion region); public Collection<PathObject> getAnnotationsForRegion(ImageRegion region); public Collection<PathObject> getAllDetectionsForRegion(ImageRegion region); ```. As the javadocs mention, this is permitted to return *too many objects*.; Its purpose is to act as a fast sp",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:5652,Security,Access,Accessing,5652," public static <T extends PathObject> Collection<T> filterByROICoversNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIIntersectsNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsNucleusCentroid(ROI roi, Collection<T> pathObjects); ```. In case you just want to check if objects are present quickly - but don't necessarily need the objects themselves - you can use:. ```java; // Old method, deprecated; public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). // New methods; public boolean hasObjectsForRegion(ImageRegion region); public boolean hasAnnotationsForRegion(ImageRegion region); public boolean hasDetectionsForRegion(ImageRegion region); ```. These should effectively report whether `getXXXForRegion` would return an empty collection or not, without needing to generate that collection. ### Accessing objects with point ROIs; This simply accesses objects then filters by ROI type. ```java; // Old method, deprecated; public synchronized Collection<PathObject> getPointObjects(Class<? extends PathObject> cls). // New methods; public Collection<PathObject> getAllPointObjects(); public Collection<PathObject> getAllPointAnnotations() ; ```; This should be sufficiently obscure that there is no need to have separate methods to request point objects of more classes. If you *really* need point detections, for example. filtering the resulting collection should be straightforward, e.g.; ```java; var pointAnnotations = hierarchy.getAllPointObjects().stream().filter(PathObject::isDetection).toList();; ```. ---. To support these changes, `GeometryROI.contains(x, y)` was also updated to make use of an [`IndexedPointInAreaLocator`](https://locationtech.github.io/jts/javadoc/org/locationtech/jts/algorithm/locate/IndexedPointInAreaLocator.html) for complex geometries - enabling centroid tests to benefit from performance improvements ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:5699,Security,access,accesses,5699," public static <T extends PathObject> Collection<T> filterByROICoversNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIIntersectsNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsNucleusCentroid(ROI roi, Collection<T> pathObjects); ```. In case you just want to check if objects are present quickly - but don't necessarily need the objects themselves - you can use:. ```java; // Old method, deprecated; public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). // New methods; public boolean hasObjectsForRegion(ImageRegion region); public boolean hasAnnotationsForRegion(ImageRegion region); public boolean hasDetectionsForRegion(ImageRegion region); ```. These should effectively report whether `getXXXForRegion` would return an empty collection or not, without needing to generate that collection. ### Accessing objects with point ROIs; This simply accesses objects then filters by ROI type. ```java; // Old method, deprecated; public synchronized Collection<PathObject> getPointObjects(Class<? extends PathObject> cls). // New methods; public Collection<PathObject> getAllPointObjects(); public Collection<PathObject> getAllPointAnnotations() ; ```; This should be sufficiently obscure that there is no need to have separate methods to request point objects of more classes. If you *really* need point detections, for example. filtering the resulting collection should be straightforward, e.g.; ```java; var pointAnnotations = hierarchy.getAllPointObjects().stream().filter(PathObject::isDetection).toList();; ```. ---. To support these changes, `GeometryROI.contains(x, y)` was also updated to make use of an [`IndexedPointInAreaLocator`](https://locationtech.github.io/jts/javadoc/org/locationtech/jts/algorithm/locate/IndexedPointInAreaLocator.html) for complex geometries - enabling centroid tests to benefit from performance improvements ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:4435,Testability,test,tests,4435,"ctsForRegion(ImageRegion region); public Collection<PathObject> getAnnotationsForRegion(ImageRegion region); public Collection<PathObject> getAllDetectionsForRegion(ImageRegion region); ```. As the javadocs mention, this is permitted to return *too many objects*.; Its purpose is to act as a fast spatial cache, where returned objects are likely to be filtered further. To help with this, there are new methods in `PathObjectTools`:; ```java; public static <T extends PathObject> Collection<T> filterByROICovers(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIIntersects(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsCentroid(ROI roi, Collection<T> pathObjects); ```; These can apply filters that normally require some `ROI.getGeometry()` gymnastics, and may be faster through the use of prepared geometries and parallel streams. When cells are involved, one might want to perform the tests using the *nucleus* ROI rather than the main (outer) ROI. This is also what happens internally with the hierarchy checks (i.e. the nucleus centroid is used where possible to check if a cell is inside a ROI). The following methods support that:; ```java; public static <T extends PathObject> Collection<T> filterByROICoversNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIIntersectsNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsNucleusCentroid(ROI roi, Collection<T> pathObjects); ```. In case you just want to check if objects are present quickly - but don't necessarily need the objects themselves - you can use:. ```java; // Old method, deprecated; public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). // New methods; public boolean hasObjectsForRegion(ImageRegion region); public boolean hasAnnotationsForRegion(ImageRegion region);",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:6647,Testability,test,tests,6647,"t> Collection<T> filterByROIIntersectsNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsNucleusCentroid(ROI roi, Collection<T> pathObjects); ```. In case you just want to check if objects are present quickly - but don't necessarily need the objects themselves - you can use:. ```java; // Old method, deprecated; public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). // New methods; public boolean hasObjectsForRegion(ImageRegion region); public boolean hasAnnotationsForRegion(ImageRegion region); public boolean hasDetectionsForRegion(ImageRegion region); ```. These should effectively report whether `getXXXForRegion` would return an empty collection or not, without needing to generate that collection. ### Accessing objects with point ROIs; This simply accesses objects then filters by ROI type. ```java; // Old method, deprecated; public synchronized Collection<PathObject> getPointObjects(Class<? extends PathObject> cls). // New methods; public Collection<PathObject> getAllPointObjects(); public Collection<PathObject> getAllPointAnnotations() ; ```; This should be sufficiently obscure that there is no need to have separate methods to request point objects of more classes. If you *really* need point detections, for example. filtering the resulting collection should be straightforward, e.g.; ```java; var pointAnnotations = hierarchy.getAllPointObjects().stream().filter(PathObject::isDetection).toList();; ```. ---. To support these changes, `GeometryROI.contains(x, y)` was also updated to make use of an [`IndexedPointInAreaLocator`](https://locationtech.github.io/jts/javadoc/org/locationtech/jts/algorithm/locate/IndexedPointInAreaLocator.html) for complex geometries - enabling centroid tests to benefit from performance improvements with no special logic required outside the `ROI` class itself. Also, some deprecated methods - and deprecated classes that used them - were removed.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:6710,Testability,log,logic,6710,"t> Collection<T> filterByROIIntersectsNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsNucleusCentroid(ROI roi, Collection<T> pathObjects); ```. In case you just want to check if objects are present quickly - but don't necessarily need the objects themselves - you can use:. ```java; // Old method, deprecated; public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). // New methods; public boolean hasObjectsForRegion(ImageRegion region); public boolean hasAnnotationsForRegion(ImageRegion region); public boolean hasDetectionsForRegion(ImageRegion region); ```. These should effectively report whether `getXXXForRegion` would return an empty collection or not, without needing to generate that collection. ### Accessing objects with point ROIs; This simply accesses objects then filters by ROI type. ```java; // Old method, deprecated; public synchronized Collection<PathObject> getPointObjects(Class<? extends PathObject> cls). // New methods; public Collection<PathObject> getAllPointObjects(); public Collection<PathObject> getAllPointAnnotations() ; ```; This should be sufficiently obscure that there is no need to have separate methods to request point objects of more classes. If you *really* need point detections, for example. filtering the resulting collection should be straightforward, e.g.; ```java; var pointAnnotations = hierarchy.getAllPointObjects().stream().filter(PathObject::isDetection).toList();; ```. ---. To support these changes, `GeometryROI.contains(x, y)` was also updated to make use of an [`IndexedPointInAreaLocator`](https://locationtech.github.io/jts/javadoc/org/locationtech/jts/algorithm/locate/IndexedPointInAreaLocator.html) for complex geometries - enabling centroid tests to benefit from performance improvements with no special logic required outside the `ROI` class itself. Also, some deprecated methods - and deprecated classes that used them - were removed.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1563:5692,Usability,simpl,simply,5692," public static <T extends PathObject> Collection<T> filterByROICoversNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIIntersectsNucleus(ROI roi, Collection<T> pathObjects); public static <T extends PathObject> Collection<T> filterByROIContainsNucleusCentroid(ROI roi, Collection<T> pathObjects); ```. In case you just want to check if objects are present quickly - but don't necessarily need the objects themselves - you can use:. ```java; // Old method, deprecated; public boolean hasObjectsForRegion(Class<? extends PathObject> cls, ImageRegion region). // New methods; public boolean hasObjectsForRegion(ImageRegion region); public boolean hasAnnotationsForRegion(ImageRegion region); public boolean hasDetectionsForRegion(ImageRegion region); ```. These should effectively report whether `getXXXForRegion` would return an empty collection or not, without needing to generate that collection. ### Accessing objects with point ROIs; This simply accesses objects then filters by ROI type. ```java; // Old method, deprecated; public synchronized Collection<PathObject> getPointObjects(Class<? extends PathObject> cls). // New methods; public Collection<PathObject> getAllPointObjects(); public Collection<PathObject> getAllPointAnnotations() ; ```; This should be sufficiently obscure that there is no need to have separate methods to request point objects of more classes. If you *really* need point detections, for example. filtering the resulting collection should be straightforward, e.g.; ```java; var pointAnnotations = hierarchy.getAllPointObjects().stream().filter(PathObject::isDetection).toList();; ```. ---. To support these changes, `GeometryROI.contains(x, y)` was also updated to make use of an [`IndexedPointInAreaLocator`](https://locationtech.github.io/jts/javadoc/org/locationtech/jts/algorithm/locate/IndexedPointInAreaLocator.html) for complex geometries - enabling centroid tests to benefit from performance improvements ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/issues/1564:201,Testability,log,logic,201,"**Describe the bug**; As can be seen from https://github.com/qupath/qupath/blob/f12b38a32906e0257a34ea380e9a66d67e58ae75/qupath-core-processing/src/main/java/qupath/opencv/ops/ImageOps.java#L2189. The logic seems to be broken as `newValue` is never initialized, I think it should be; ```; ReplaceValueOp(double originalValue, double newValue) {; 	this.originalValue = originalValue;; 	this.newValue = newValue;; }; ...; ```",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1564
https://github.com/qupath/qupath/pull/1566:411,Modifiability,refactor,refactored,411,"The goal of this PR was to find a good solution for [this issue](https://forum.image.sc/t/add-additional-channel-in-fluorescence-image-after-scanning/99174/) (in short, creating a new channel by linearly combining existing channels). . This was done by adding a new `ColorTransforms` called `LinearCombinationChannel` that applies a linear combination to the channels. The existing `ColorTransforms` were a bit refactored to remove the warnings and improve null safety (but their behaviors stay the same). Tests were added for all existing `ColorTransforms` and the new `LinearCombinationChannel`. Implementations for `hashCode` and `equals` in `ColorDeconvolutionStains` were also added because it was needed for unit tests.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1566
https://github.com/qupath/qupath/pull/1566:462,Safety,safe,safety,462,"The goal of this PR was to find a good solution for [this issue](https://forum.image.sc/t/add-additional-channel-in-fluorescence-image-after-scanning/99174/) (in short, creating a new channel by linearly combining existing channels). . This was done by adding a new `ColorTransforms` called `LinearCombinationChannel` that applies a linear combination to the channels. The existing `ColorTransforms` were a bit refactored to remove the warnings and improve null safety (but their behaviors stay the same). Tests were added for all existing `ColorTransforms` and the new `LinearCombinationChannel`. Implementations for `hashCode` and `equals` in `ColorDeconvolutionStains` were also added because it was needed for unit tests.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1566
https://github.com/qupath/qupath/pull/1566:619,Security,hash,hashCode,619,"The goal of this PR was to find a good solution for [this issue](https://forum.image.sc/t/add-additional-channel-in-fluorescence-image-after-scanning/99174/) (in short, creating a new channel by linearly combining existing channels). . This was done by adding a new `ColorTransforms` called `LinearCombinationChannel` that applies a linear combination to the channels. The existing `ColorTransforms` were a bit refactored to remove the warnings and improve null safety (but their behaviors stay the same). Tests were added for all existing `ColorTransforms` and the new `LinearCombinationChannel`. Implementations for `hashCode` and `equals` in `ColorDeconvolutionStains` were also added because it was needed for unit tests.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1566
https://github.com/qupath/qupath/pull/1566:506,Testability,Test,Tests,506,"The goal of this PR was to find a good solution for [this issue](https://forum.image.sc/t/add-additional-channel-in-fluorescence-image-after-scanning/99174/) (in short, creating a new channel by linearly combining existing channels). . This was done by adding a new `ColorTransforms` called `LinearCombinationChannel` that applies a linear combination to the channels. The existing `ColorTransforms` were a bit refactored to remove the warnings and improve null safety (but their behaviors stay the same). Tests were added for all existing `ColorTransforms` and the new `LinearCombinationChannel`. Implementations for `hashCode` and `equals` in `ColorDeconvolutionStains` were also added because it was needed for unit tests.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1566
https://github.com/qupath/qupath/pull/1566:719,Testability,test,tests,719,"The goal of this PR was to find a good solution for [this issue](https://forum.image.sc/t/add-additional-channel-in-fluorescence-image-after-scanning/99174/) (in short, creating a new channel by linearly combining existing channels). . This was done by adding a new `ColorTransforms` called `LinearCombinationChannel` that applies a linear combination to the channels. The existing `ColorTransforms` were a bit refactored to remove the warnings and improve null safety (but their behaviors stay the same). Tests were added for all existing `ColorTransforms` and the new `LinearCombinationChannel`. Implementations for `hashCode` and `equals` in `ColorDeconvolutionStains` were also added because it was needed for unit tests.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1566
https://github.com/qupath/qupath/pull/1570:62,Availability,downtime,downtime,62,Will try get to the legacy test file next week if I have some downtime. Some test names not hugely descriptive,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1570
https://github.com/qupath/qupath/pull/1570:27,Testability,test,test,27,Will try get to the legacy test file next week if I have some downtime. Some test names not hugely descriptive,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1570
https://github.com/qupath/qupath/pull/1570:77,Testability,test,test,77,Will try get to the legacy test file next week if I have some downtime. Some test names not hugely descriptive,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1570
https://github.com/qupath/qupath/pull/1571:96,Testability,test,tests,96,* Make it easier to extract the largest `Polygon` from a `GeometryCollection`.; * Add some more tests for `GeometryTools`,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1571
https://github.com/qupath/qupath/pull/1572:344,Availability,avail,available,344,"* TMA cores can now have classifications assigned to them; * Default color for TMA cores is lighter (to make it easier to see on both bright and dark backgrounds); * TMA core 'missing' status is now shown using opacity, not a different color, to preserve any classification color; * Viewer location string shows TMA core classifications, where available",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1572
https://github.com/qupath/qupath/pull/1574:212,Modifiability,variab,variable,212,Set Javadoc viewer scrollbars to always use light mode to avoid this:; ; ![image](https://github.com/user-attachments/assets/633fa351-876f-4800-9414-dd9ea6858f15). This was done by redefining the main JavaFX CSS variable.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1574
https://github.com/qupath/qupath/pull/1574:58,Safety,avoid,avoid,58,Set Javadoc viewer scrollbars to always use light mode to avoid this:; ; ![image](https://github.com/user-attachments/assets/633fa351-876f-4800-9414-dd9ea6858f15). This was done by redefining the main JavaFX CSS variable.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1574
https://github.com/qupath/qupath/pull/1576:25,Testability,log,log,25,"Don't need an info-level log every time a model can't be built, but worth warning if no builder works.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1576
https://github.com/qupath/qupath/pull/1578:287,Deployability,update,update,287,"A proposal to fix #1487. The [`UndoRedoManager.hierarchyChanged()`](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L472) function is called each time the hierarchy changes and is supposed to update the `UndoRedoManager` state. However, when loading objects using `Import objects from file`, the `PathObjectHierarchyEvent` parameter of this function contains no changed objects (`PathObjectHierarchyEvent.getChangedObjects()` function). So, [this condition](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L474) is `true`, the event is ignored, and the `UndoRedoManager` doesn't update its state. This creates the issues described in #1487. Therefore, the issue is not coming from the `UndoRedoManager`, but from the function that created the event. The event is created in [`PathObjectHierarchy.addObjects()`](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-core/src/main/java/qupath/lib/objects/hierarchy/PathObjectHierarchy.java#L626). I'm sure there is reason behind it, but here a hierarchy changed event is emitted, instead of an object added event. This PR simply emits an object added event instead of a hierarchy changed event. The `PathObjectHierarchy.addObjects()` function add several objects, but in the PR only one object event is emitted. It seems to be enough still.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1578
https://github.com/qupath/qupath/pull/1578:769,Deployability,update,update,769,"A proposal to fix #1487. The [`UndoRedoManager.hierarchyChanged()`](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L472) function is called each time the hierarchy changes and is supposed to update the `UndoRedoManager` state. However, when loading objects using `Import objects from file`, the `PathObjectHierarchyEvent` parameter of this function contains no changed objects (`PathObjectHierarchyEvent.getChangedObjects()` function). So, [this condition](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L474) is `true`, the event is ignored, and the `UndoRedoManager` doesn't update its state. This creates the issues described in #1487. Therefore, the issue is not coming from the `UndoRedoManager`, but from the function that created the event. The event is created in [`PathObjectHierarchy.addObjects()`](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-core/src/main/java/qupath/lib/objects/hierarchy/PathObjectHierarchy.java#L626). I'm sure there is reason behind it, but here a hierarchy changed event is emitted, instead of an object added event. This PR simply emits an object added event instead of a hierarchy changed event. The `PathObjectHierarchy.addObjects()` function add several objects, but in the PR only one object event is emitted. It seems to be enough still.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1578
https://github.com/qupath/qupath/pull/1578:337,Performance,load,loading,337,"A proposal to fix #1487. The [`UndoRedoManager.hierarchyChanged()`](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L472) function is called each time the hierarchy changes and is supposed to update the `UndoRedoManager` state. However, when loading objects using `Import objects from file`, the `PathObjectHierarchyEvent` parameter of this function contains no changed objects (`PathObjectHierarchyEvent.getChangedObjects()` function). So, [this condition](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L474) is `true`, the event is ignored, and the `UndoRedoManager` doesn't update its state. This creates the issues described in #1487. Therefore, the issue is not coming from the `UndoRedoManager`, but from the function that created the event. The event is created in [`PathObjectHierarchy.addObjects()`](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-core/src/main/java/qupath/lib/objects/hierarchy/PathObjectHierarchy.java#L626). I'm sure there is reason behind it, but here a hierarchy changed event is emitted, instead of an object added event. This PR simply emits an object added event instead of a hierarchy changed event. The `PathObjectHierarchy.addObjects()` function add several objects, but in the PR only one object event is emitted. It seems to be enough still.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1578
https://github.com/qupath/qupath/pull/1578:31,Usability,Undo,UndoRedoManager,31,"A proposal to fix #1487. The [`UndoRedoManager.hierarchyChanged()`](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L472) function is called each time the hierarchy changes and is supposed to update the `UndoRedoManager` state. However, when loading objects using `Import objects from file`, the `PathObjectHierarchyEvent` parameter of this function contains no changed objects (`PathObjectHierarchyEvent.getChangedObjects()` function). So, [this condition](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L474) is `true`, the event is ignored, and the `UndoRedoManager` doesn't update its state. This creates the issues described in #1487. Therefore, the issue is not coming from the `UndoRedoManager`, but from the function that created the event. The event is created in [`PathObjectHierarchy.addObjects()`](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-core/src/main/java/qupath/lib/objects/hierarchy/PathObjectHierarchy.java#L626). I'm sure there is reason behind it, but here a hierarchy changed event is emitted, instead of an object added event. This PR simply emits an object added event instead of a hierarchy changed event. The `PathObjectHierarchy.addObjects()` function add several objects, but in the PR only one object event is emitted. It seems to be enough still.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1578
https://github.com/qupath/qupath/pull/1578:190,Usability,Undo,UndoRedoManager,190,"A proposal to fix #1487. The [`UndoRedoManager.hierarchyChanged()`](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L472) function is called each time the hierarchy changes and is supposed to update the `UndoRedoManager` state. However, when loading objects using `Import objects from file`, the `PathObjectHierarchyEvent` parameter of this function contains no changed objects (`PathObjectHierarchyEvent.getChangedObjects()` function). So, [this condition](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L474) is `true`, the event is ignored, and the `UndoRedoManager` doesn't update its state. This creates the issues described in #1487. Therefore, the issue is not coming from the `UndoRedoManager`, but from the function that created the event. The event is created in [`PathObjectHierarchy.addObjects()`](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-core/src/main/java/qupath/lib/objects/hierarchy/PathObjectHierarchy.java#L626). I'm sure there is reason behind it, but here a hierarchy changed event is emitted, instead of an object added event. This PR simply emits an object added event instead of a hierarchy changed event. The `PathObjectHierarchy.addObjects()` function add several objects, but in the PR only one object event is emitted. It seems to be enough still.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1578
https://github.com/qupath/qupath/pull/1578:299,Usability,Undo,UndoRedoManager,299,"A proposal to fix #1487. The [`UndoRedoManager.hierarchyChanged()`](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L472) function is called each time the hierarchy changes and is supposed to update the `UndoRedoManager` state. However, when loading objects using `Import objects from file`, the `PathObjectHierarchyEvent` parameter of this function contains no changed objects (`PathObjectHierarchyEvent.getChangedObjects()` function). So, [this condition](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L474) is `true`, the event is ignored, and the `UndoRedoManager` doesn't update its state. This creates the issues described in #1487. Therefore, the issue is not coming from the `UndoRedoManager`, but from the function that created the event. The event is created in [`PathObjectHierarchy.addObjects()`](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-core/src/main/java/qupath/lib/objects/hierarchy/PathObjectHierarchy.java#L626). I'm sure there is reason behind it, but here a hierarchy changed event is emitted, instead of an object added event. This PR simply emits an object added event instead of a hierarchy changed event. The `PathObjectHierarchy.addObjects()` function add several objects, but in the PR only one object event is emitted. It seems to be enough still.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1578
https://github.com/qupath/qupath/pull/1578:675,Usability,Undo,UndoRedoManager,675,"A proposal to fix #1487. The [`UndoRedoManager.hierarchyChanged()`](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L472) function is called each time the hierarchy changes and is supposed to update the `UndoRedoManager` state. However, when loading objects using `Import objects from file`, the `PathObjectHierarchyEvent` parameter of this function contains no changed objects (`PathObjectHierarchyEvent.getChangedObjects()` function). So, [this condition](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L474) is `true`, the event is ignored, and the `UndoRedoManager` doesn't update its state. This creates the issues described in #1487. Therefore, the issue is not coming from the `UndoRedoManager`, but from the function that created the event. The event is created in [`PathObjectHierarchy.addObjects()`](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-core/src/main/java/qupath/lib/objects/hierarchy/PathObjectHierarchy.java#L626). I'm sure there is reason behind it, but here a hierarchy changed event is emitted, instead of an object added event. This PR simply emits an object added event instead of a hierarchy changed event. The `PathObjectHierarchy.addObjects()` function add several objects, but in the PR only one object event is emitted. It seems to be enough still.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1578
https://github.com/qupath/qupath/pull/1578:744,Usability,Undo,UndoRedoManager,744,"A proposal to fix #1487. The [`UndoRedoManager.hierarchyChanged()`](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L472) function is called each time the hierarchy changes and is supposed to update the `UndoRedoManager` state. However, when loading objects using `Import objects from file`, the `PathObjectHierarchyEvent` parameter of this function contains no changed objects (`PathObjectHierarchyEvent.getChangedObjects()` function). So, [this condition](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L474) is `true`, the event is ignored, and the `UndoRedoManager` doesn't update its state. This creates the issues described in #1487. Therefore, the issue is not coming from the `UndoRedoManager`, but from the function that created the event. The event is created in [`PathObjectHierarchy.addObjects()`](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-core/src/main/java/qupath/lib/objects/hierarchy/PathObjectHierarchy.java#L626). I'm sure there is reason behind it, but here a hierarchy changed event is emitted, instead of an object added event. This PR simply emits an object added event instead of a hierarchy changed event. The `PathObjectHierarchy.addObjects()` function add several objects, but in the PR only one object event is emitted. It seems to be enough still.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1578
https://github.com/qupath/qupath/pull/1578:876,Usability,Undo,UndoRedoManager,876,"A proposal to fix #1487. The [`UndoRedoManager.hierarchyChanged()`](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L472) function is called each time the hierarchy changes and is supposed to update the `UndoRedoManager` state. However, when loading objects using `Import objects from file`, the `PathObjectHierarchyEvent` parameter of this function contains no changed objects (`PathObjectHierarchyEvent.getChangedObjects()` function). So, [this condition](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L474) is `true`, the event is ignored, and the `UndoRedoManager` doesn't update its state. This creates the issues described in #1487. Therefore, the issue is not coming from the `UndoRedoManager`, but from the function that created the event. The event is created in [`PathObjectHierarchy.addObjects()`](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-core/src/main/java/qupath/lib/objects/hierarchy/PathObjectHierarchy.java#L626). I'm sure there is reason behind it, but here a hierarchy changed event is emitted, instead of an object added event. This PR simply emits an object added event instead of a hierarchy changed event. The `PathObjectHierarchy.addObjects()` function add several objects, but in the PR only one object event is emitted. It seems to be enough still.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1578
https://github.com/qupath/qupath/pull/1578:1292,Usability,simpl,simply,1292,"A proposal to fix #1487. The [`UndoRedoManager.hierarchyChanged()`](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L472) function is called each time the hierarchy changes and is supposed to update the `UndoRedoManager` state. However, when loading objects using `Import objects from file`, the `PathObjectHierarchyEvent` parameter of this function contains no changed objects (`PathObjectHierarchyEvent.getChangedObjects()` function). So, [this condition](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L474) is `true`, the event is ignored, and the `UndoRedoManager` doesn't update its state. This creates the issues described in #1487. Therefore, the issue is not coming from the `UndoRedoManager`, but from the function that created the event. The event is created in [`PathObjectHierarchy.addObjects()`](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-core/src/main/java/qupath/lib/objects/hierarchy/PathObjectHierarchy.java#L626). I'm sure there is reason behind it, but here a hierarchy changed event is emitted, instead of an object added event. This PR simply emits an object added event instead of a hierarchy changed event. The `PathObjectHierarchy.addObjects()` function add several objects, but in the PR only one object event is emitted. It seems to be enough still.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1578
https://github.com/qupath/qupath/issues/1580:564,Deployability,release,release,564,"## IMPORTANT!. This section is **only** for bug reports, which **must** follow the template below. Please post any other questions to the official QuPath forum at https://forum.image.sc/tags/qupath. If in doubt, use [image.sc](https://forum.image.sc/tags/qupath). This helps us keep things organized. ## Before we begin... Before submitting your bug report, please check the following:. * [X] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [X] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [X] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [X] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; Whenever I try to use QuPath, the application crashes on me. I have uninstalled and reinstalled x2 and am fully up to date (QuPath-v0.5.1-Mac-arm64). I can open the application and open my project, but when I try to view an image it crashes on me. . It also causes my computer system wide issues and Ive had to restart twice. I am on a Mac with . **To Reproduce**; Steps to reproduce the behavior:; Unsure. **Expected behavior**; It should open the image for H&E (20x) for an scn file from Versa; <img width=""1498"" alt=""Screenshot 2024-08-08 at 3 24 02 PM"" src=""https://github.com/user-attachments/assets/c69bcc7f-14ca-450b-ac7c-6981ca2903c1"">. **Screenshots**; If applicable, add screenshots to help explain your problem. **Desktop (please complete the following information):**; - OS: macOS 14.4.1.; - QuPath Version: v0.5.1. **Additional context**; This is happening for all my QuPath projects, not just a specific one.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1580
https://github.com/qupath/qupath/issues/1580:760,Deployability,release,release,760,"## IMPORTANT!. This section is **only** for bug reports, which **must** follow the template below. Please post any other questions to the official QuPath forum at https://forum.image.sc/tags/qupath. If in doubt, use [image.sc](https://forum.image.sc/tags/qupath). This helps us keep things organized. ## Before we begin... Before submitting your bug report, please check the following:. * [X] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [X] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [X] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [X] I've checked for existing GitHub issues describing the same problem. ## Bug report. **Describe the bug**; Whenever I try to use QuPath, the application crashes on me. I have uninstalled and reinstalled x2 and am fully up to date (QuPath-v0.5.1-Mac-arm64). I can open the application and open my project, but when I try to view an image it crashes on me. . It also causes my computer system wide issues and Ive had to restart twice. I am on a Mac with . **To Reproduce**; Steps to reproduce the behavior:; Unsure. **Expected behavior**; It should open the image for H&E (20x) for an scn file from Versa; <img width=""1498"" alt=""Screenshot 2024-08-08 at 3 24 02 PM"" src=""https://github.com/user-attachments/assets/c69bcc7f-14ca-450b-ac7c-6981ca2903c1"">. **Screenshots**; If applicable, add screenshots to help explain your problem. **Desktop (please complete the following information):**; - OS: macOS 14.4.1.; - QuPath Version: v0.5.1. **Additional context**; This is happening for all my QuPath projects, not just a specific one.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1580
https://github.com/qupath/qupath/pull/1581:450,Performance,perform,performed,450,"Add support for converting the `PixelType` of an image. Here is an example that converts the pixel type of the current image to float32, and opens it in the current viewer:; ```groovy; def server = getCurrentServer(); def server2 = new TransformedServerBuilder(server); .convertType(PixelType.FLOAT32); .build(). def imageData2 = new ImageData<>(server2); Platform.runLater {getCurrentViewer().setImageData(imageData2)}; ```. Note that no scaling is performed, but this may be done using other methods in `TransformedServerBuilder`. This is most useful when exporting transformed images. It provides a workaround to the fact that color transforms (like color deconvolution, but also channel extraction) enforce conversion to float32.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1581
https://github.com/qupath/qupath/pull/1582:127,Safety,detect,detections,127,"Fix the behavior in the viewer so that object names aren't shown if the object itself is not shown. Also support showing named detections, not just annotations.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1582
https://github.com/qupath/qupath/pull/1583:28,Usability,simpl,simply,28,"A proposal to fix #1221. It simply adds the possibility to right click on the color map of the measurement map window, this opens a context menu with a `Copy` option, and clicking on this option will copy the color map to the clipboard.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1583
https://github.com/qupath/qupath/pull/1584:441,Integrability,interface,interface,441,"This PR is linked with issues #1537 and #1289 and implements [Alan's idea](https://github.com/qupath/qupath/issues/1537#issuecomment-2141451238). It adds a [`Manager`](https://github.com/qupath/qupath/blob/7b272e5ee4c79d27dcf4e332d26ea4d0e5c80e3a/qupath-core/src/main/java/qupath/lib/projects/ResourceManager.java#L69) to the [`Project`](https://github.com/qupath/qupath/blob/main/qupath-core/src/main/java/qupath/lib/projects/Project.java) interface through the `Project.getSortingKeys()` function. The names of this manager correspond to sorting keys, while their values are string representations of booleans corresponding to whether the key is in ascending or descending order. The current state of this PR makes project sorting persists when projects are closed / reopened. It also enable to store several sorting keys and to define the sorting order (ascending or descending) for each of these keys, so that we could achieve this:; ![image](https://github.com/user-attachments/assets/a7f6c570-dc2f-40f4-8d85-d88bdb392871); ; However, the UI has to be changed to allow this. I can work on it, but I wanted to have your opinions on the current state of this PR first.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1584
https://github.com/qupath/qupath/pull/1585:301,Testability,log,log,301,"Fix the infinite recursion caused by a recent change, and occurring when attempting to open a .qpdata file outside a project. Also clean up some other parts of the class, and add simpler `readImageData` methods that don't require so many parameters. Deprecate the previous `readImageData` methods and log warnings when they are called.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1585
https://github.com/qupath/qupath/pull/1585:179,Usability,simpl,simpler,179,"Fix the infinite recursion caused by a recent change, and occurring when attempting to open a .qpdata file outside a project. Also clean up some other parts of the class, and add simpler `readImageData` methods that don't require so many parameters. Deprecate the previous `readImageData` methods and log warnings when they are called.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1585
https://github.com/qupath/qupath/issues/1586:152,Availability,error,error,152,"Hey. I'm trying to open an image through a symlink. I've created symlinks for both the folders with the metadata and the .vsi files, but I'm getting an error:. ![image](https://github.com/user-attachments/assets/329325f0-7e2c-4c82-b9f4-76f0745578e6). How can one create/open symlinks? I can open the images on the original paths just fine, but can't open the symlinks. Thanks",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1586
https://github.com/qupath/qupath/pull/1587:2151,Deployability,update,updates,2151,"se a convenient Groovy syntax, e.g.; ```groovy; getProject().metadata['key'] = 'value'; getProjectEntry().metadata['key'] = 'value'; getSelectedObject().metadata['key'] = 'value'; ```. ## Don't use metadata too much!; For `PathObject`, the metadata is generated lazily on demand - so imposes no overhead if it isn't needed. This means that *it's generally a bad idea to start adding metadata to detections* - especially if we may have a huge number.; It introduces considerable overhead to store a `Map` for each object.; This is typically find for other kinds of `PathObject`, but we don't want to store millions of additional maps if they are not needed. ## Use `""_key""` format for internal use; A documented convention for `MinimalMetadataStore` is to use `""_""` as the first character for metadata values that are used internally. The practical implication is that values starting with `""_""` aren't typically shown to the user, e.g. within measurement tables. ## Thread safety; The maps returned by `DefaultProject` and its image entries are synchronized. The map returned by `PathObject.getMetadata()` is currently *not* thread-safe. This can be confirmed with the following script:; ```groovy; def pathObject = PathObjects.createAnnotationObject(ROIs.createEmptyROI()). // Control synchronization; boolean doSynchronize = true. // Make sure we have no metadata at the start; pathObject.metadata.clear(); int before = pathObject.metadata.size(). java.util.stream.IntStream.range(0, 1000); .parallel(); .forEach(i -> {; def map = pathObject.metadata; if (doSynchronize) {; synchronized (map) {; map[UUID.randomUUID().toString()] = ""Yes""; }; } else {; map[UUID.randomUUID().toString()] = ""Yes""; }. }); ; int after = pathObject.metadata.size(); print ""Metadata added: ${after - before}""; ```; If using `synchronized (map)` for the updates, then 1000 values should be added. But otherwise, you will likely see fewer values at the end. > It is probably worth synchronizing the map in a future version.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1587
https://github.com/qupath/qupath/pull/1587:35,Integrability,interface,interface,35,"Introduce a `MinimalMetadataStore` interface (may be renamed) and use it with `PathObject`, `Project` and `ProjectImageEntry`. This adds support for `String` key/value metadata, and enables us to deprecate some old metadata-related code. ## Use. Because a standard modifiable `Map<String, String>` is returned, we can use a convenient Groovy syntax, e.g.; ```groovy; getProject().metadata['key'] = 'value'; getProjectEntry().metadata['key'] = 'value'; getSelectedObject().metadata['key'] = 'value'; ```. ## Don't use metadata too much!; For `PathObject`, the metadata is generated lazily on demand - so imposes no overhead if it isn't needed. This means that *it's generally a bad idea to start adding metadata to detections* - especially if we may have a huge number.; It introduces considerable overhead to store a `Map` for each object.; This is typically find for other kinds of `PathObject`, but we don't want to store millions of additional maps if they are not needed. ## Use `""_key""` format for internal use; A documented convention for `MinimalMetadataStore` is to use `""_""` as the first character for metadata values that are used internally. The practical implication is that values starting with `""_""` aren't typically shown to the user, e.g. within measurement tables. ## Thread safety; The maps returned by `DefaultProject` and its image entries are synchronized. The map returned by `PathObject.getMetadata()` is currently *not* thread-safe. This can be confirmed with the following script:; ```groovy; def pathObject = PathObjects.createAnnotationObject(ROIs.createEmptyROI()). // Control synchronization; boolean doSynchronize = true. // Make sure we have no metadata at the start; pathObject.metadata.clear(); int before = pathObject.metadata.size(). java.util.stream.IntStream.range(0, 1000); .parallel(); .forEach(i -> {; def map = pathObject.metadata; if (doSynchronize) {; synchronized (map) {; map[UUID.randomUUID().toString()] = ""Yes""; }; } else {; map[UUID.randomUUID().toStri",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1587
https://github.com/qupath/qupath/pull/1587:1364,Integrability,synchroniz,synchronized,1364,"se a convenient Groovy syntax, e.g.; ```groovy; getProject().metadata['key'] = 'value'; getProjectEntry().metadata['key'] = 'value'; getSelectedObject().metadata['key'] = 'value'; ```. ## Don't use metadata too much!; For `PathObject`, the metadata is generated lazily on demand - so imposes no overhead if it isn't needed. This means that *it's generally a bad idea to start adding metadata to detections* - especially if we may have a huge number.; It introduces considerable overhead to store a `Map` for each object.; This is typically find for other kinds of `PathObject`, but we don't want to store millions of additional maps if they are not needed. ## Use `""_key""` format for internal use; A documented convention for `MinimalMetadataStore` is to use `""_""` as the first character for metadata values that are used internally. The practical implication is that values starting with `""_""` aren't typically shown to the user, e.g. within measurement tables. ## Thread safety; The maps returned by `DefaultProject` and its image entries are synchronized. The map returned by `PathObject.getMetadata()` is currently *not* thread-safe. This can be confirmed with the following script:; ```groovy; def pathObject = PathObjects.createAnnotationObject(ROIs.createEmptyROI()). // Control synchronization; boolean doSynchronize = true. // Make sure we have no metadata at the start; pathObject.metadata.clear(); int before = pathObject.metadata.size(). java.util.stream.IntStream.range(0, 1000); .parallel(); .forEach(i -> {; def map = pathObject.metadata; if (doSynchronize) {; synchronized (map) {; map[UUID.randomUUID().toString()] = ""Yes""; }; } else {; map[UUID.randomUUID().toString()] = ""Yes""; }. }); ; int after = pathObject.metadata.size(); print ""Metadata added: ${after - before}""; ```; If using `synchronized (map)` for the updates, then 1000 values should be added. But otherwise, you will likely see fewer values at the end. > It is probably worth synchronizing the map in a future version.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1587
https://github.com/qupath/qupath/pull/1587:1605,Integrability,synchroniz,synchronization,1605,"se a convenient Groovy syntax, e.g.; ```groovy; getProject().metadata['key'] = 'value'; getProjectEntry().metadata['key'] = 'value'; getSelectedObject().metadata['key'] = 'value'; ```. ## Don't use metadata too much!; For `PathObject`, the metadata is generated lazily on demand - so imposes no overhead if it isn't needed. This means that *it's generally a bad idea to start adding metadata to detections* - especially if we may have a huge number.; It introduces considerable overhead to store a `Map` for each object.; This is typically find for other kinds of `PathObject`, but we don't want to store millions of additional maps if they are not needed. ## Use `""_key""` format for internal use; A documented convention for `MinimalMetadataStore` is to use `""_""` as the first character for metadata values that are used internally. The practical implication is that values starting with `""_""` aren't typically shown to the user, e.g. within measurement tables. ## Thread safety; The maps returned by `DefaultProject` and its image entries are synchronized. The map returned by `PathObject.getMetadata()` is currently *not* thread-safe. This can be confirmed with the following script:; ```groovy; def pathObject = PathObjects.createAnnotationObject(ROIs.createEmptyROI()). // Control synchronization; boolean doSynchronize = true. // Make sure we have no metadata at the start; pathObject.metadata.clear(); int before = pathObject.metadata.size(). java.util.stream.IntStream.range(0, 1000); .parallel(); .forEach(i -> {; def map = pathObject.metadata; if (doSynchronize) {; synchronized (map) {; map[UUID.randomUUID().toString()] = ""Yes""; }; } else {; map[UUID.randomUUID().toString()] = ""Yes""; }. }); ; int after = pathObject.metadata.size(); print ""Metadata added: ${after - before}""; ```; If using `synchronized (map)` for the updates, then 1000 values should be added. But otherwise, you will likely see fewer values at the end. > It is probably worth synchronizing the map in a future version.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1587
https://github.com/qupath/qupath/pull/1587:1895,Integrability,synchroniz,synchronized,1895,"se a convenient Groovy syntax, e.g.; ```groovy; getProject().metadata['key'] = 'value'; getProjectEntry().metadata['key'] = 'value'; getSelectedObject().metadata['key'] = 'value'; ```. ## Don't use metadata too much!; For `PathObject`, the metadata is generated lazily on demand - so imposes no overhead if it isn't needed. This means that *it's generally a bad idea to start adding metadata to detections* - especially if we may have a huge number.; It introduces considerable overhead to store a `Map` for each object.; This is typically find for other kinds of `PathObject`, but we don't want to store millions of additional maps if they are not needed. ## Use `""_key""` format for internal use; A documented convention for `MinimalMetadataStore` is to use `""_""` as the first character for metadata values that are used internally. The practical implication is that values starting with `""_""` aren't typically shown to the user, e.g. within measurement tables. ## Thread safety; The maps returned by `DefaultProject` and its image entries are synchronized. The map returned by `PathObject.getMetadata()` is currently *not* thread-safe. This can be confirmed with the following script:; ```groovy; def pathObject = PathObjects.createAnnotationObject(ROIs.createEmptyROI()). // Control synchronization; boolean doSynchronize = true. // Make sure we have no metadata at the start; pathObject.metadata.clear(); int before = pathObject.metadata.size(). java.util.stream.IntStream.range(0, 1000); .parallel(); .forEach(i -> {; def map = pathObject.metadata; if (doSynchronize) {; synchronized (map) {; map[UUID.randomUUID().toString()] = ""Yes""; }; } else {; map[UUID.randomUUID().toString()] = ""Yes""; }. }); ; int after = pathObject.metadata.size(); print ""Metadata added: ${after - before}""; ```; If using `synchronized (map)` for the updates, then 1000 values should be added. But otherwise, you will likely see fewer values at the end. > It is probably worth synchronizing the map in a future version.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1587
https://github.com/qupath/qupath/pull/1587:2123,Integrability,synchroniz,synchronized,2123,"se a convenient Groovy syntax, e.g.; ```groovy; getProject().metadata['key'] = 'value'; getProjectEntry().metadata['key'] = 'value'; getSelectedObject().metadata['key'] = 'value'; ```. ## Don't use metadata too much!; For `PathObject`, the metadata is generated lazily on demand - so imposes no overhead if it isn't needed. This means that *it's generally a bad idea to start adding metadata to detections* - especially if we may have a huge number.; It introduces considerable overhead to store a `Map` for each object.; This is typically find for other kinds of `PathObject`, but we don't want to store millions of additional maps if they are not needed. ## Use `""_key""` format for internal use; A documented convention for `MinimalMetadataStore` is to use `""_""` as the first character for metadata values that are used internally. The practical implication is that values starting with `""_""` aren't typically shown to the user, e.g. within measurement tables. ## Thread safety; The maps returned by `DefaultProject` and its image entries are synchronized. The map returned by `PathObject.getMetadata()` is currently *not* thread-safe. This can be confirmed with the following script:; ```groovy; def pathObject = PathObjects.createAnnotationObject(ROIs.createEmptyROI()). // Control synchronization; boolean doSynchronize = true. // Make sure we have no metadata at the start; pathObject.metadata.clear(); int before = pathObject.metadata.size(). java.util.stream.IntStream.range(0, 1000); .parallel(); .forEach(i -> {; def map = pathObject.metadata; if (doSynchronize) {; synchronized (map) {; map[UUID.randomUUID().toString()] = ""Yes""; }; } else {; map[UUID.randomUUID().toString()] = ""Yes""; }. }); ; int after = pathObject.metadata.size(); print ""Metadata added: ${after - before}""; ```; If using `synchronized (map)` for the updates, then 1000 values should be added. But otherwise, you will likely see fewer values at the end. > It is probably worth synchronizing the map in a future version.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1587
https://github.com/qupath/qupath/pull/1587:2277,Integrability,synchroniz,synchronizing,2277,"se a convenient Groovy syntax, e.g.; ```groovy; getProject().metadata['key'] = 'value'; getProjectEntry().metadata['key'] = 'value'; getSelectedObject().metadata['key'] = 'value'; ```. ## Don't use metadata too much!; For `PathObject`, the metadata is generated lazily on demand - so imposes no overhead if it isn't needed. This means that *it's generally a bad idea to start adding metadata to detections* - especially if we may have a huge number.; It introduces considerable overhead to store a `Map` for each object.; This is typically find for other kinds of `PathObject`, but we don't want to store millions of additional maps if they are not needed. ## Use `""_key""` format for internal use; A documented convention for `MinimalMetadataStore` is to use `""_""` as the first character for metadata values that are used internally. The practical implication is that values starting with `""_""` aren't typically shown to the user, e.g. within measurement tables. ## Thread safety; The maps returned by `DefaultProject` and its image entries are synchronized. The map returned by `PathObject.getMetadata()` is currently *not* thread-safe. This can be confirmed with the following script:; ```groovy; def pathObject = PathObjects.createAnnotationObject(ROIs.createEmptyROI()). // Control synchronization; boolean doSynchronize = true. // Make sure we have no metadata at the start; pathObject.metadata.clear(); int before = pathObject.metadata.size(). java.util.stream.IntStream.range(0, 1000); .parallel(); .forEach(i -> {; def map = pathObject.metadata; if (doSynchronize) {; synchronized (map) {; map[UUID.randomUUID().toString()] = ""Yes""; }; } else {; map[UUID.randomUUID().toString()] = ""Yes""; }. }); ; int after = pathObject.metadata.size(); print ""Metadata added: ${after - before}""; ```; If using `synchronized (map)` for the updates, then 1000 values should be added. But otherwise, you will likely see fewer values at the end. > It is probably worth synchronizing the map in a future version.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1587
https://github.com/qupath/qupath/pull/1587:714,Safety,detect,detections,714,"Introduce a `MinimalMetadataStore` interface (may be renamed) and use it with `PathObject`, `Project` and `ProjectImageEntry`. This adds support for `String` key/value metadata, and enables us to deprecate some old metadata-related code. ## Use. Because a standard modifiable `Map<String, String>` is returned, we can use a convenient Groovy syntax, e.g.; ```groovy; getProject().metadata['key'] = 'value'; getProjectEntry().metadata['key'] = 'value'; getSelectedObject().metadata['key'] = 'value'; ```. ## Don't use metadata too much!; For `PathObject`, the metadata is generated lazily on demand - so imposes no overhead if it isn't needed. This means that *it's generally a bad idea to start adding metadata to detections* - especially if we may have a huge number.; It introduces considerable overhead to store a `Map` for each object.; This is typically find for other kinds of `PathObject`, but we don't want to store millions of additional maps if they are not needed. ## Use `""_key""` format for internal use; A documented convention for `MinimalMetadataStore` is to use `""_""` as the first character for metadata values that are used internally. The practical implication is that values starting with `""_""` aren't typically shown to the user, e.g. within measurement tables. ## Thread safety; The maps returned by `DefaultProject` and its image entries are synchronized. The map returned by `PathObject.getMetadata()` is currently *not* thread-safe. This can be confirmed with the following script:; ```groovy; def pathObject = PathObjects.createAnnotationObject(ROIs.createEmptyROI()). // Control synchronization; boolean doSynchronize = true. // Make sure we have no metadata at the start; pathObject.metadata.clear(); int before = pathObject.metadata.size(). java.util.stream.IntStream.range(0, 1000); .parallel(); .forEach(i -> {; def map = pathObject.metadata; if (doSynchronize) {; synchronized (map) {; map[UUID.randomUUID().toString()] = ""Yes""; }; } else {; map[UUID.randomUUID().toStri",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1587
https://github.com/qupath/qupath/pull/1587:1292,Safety,safe,safety,1292,"se a convenient Groovy syntax, e.g.; ```groovy; getProject().metadata['key'] = 'value'; getProjectEntry().metadata['key'] = 'value'; getSelectedObject().metadata['key'] = 'value'; ```. ## Don't use metadata too much!; For `PathObject`, the metadata is generated lazily on demand - so imposes no overhead if it isn't needed. This means that *it's generally a bad idea to start adding metadata to detections* - especially if we may have a huge number.; It introduces considerable overhead to store a `Map` for each object.; This is typically find for other kinds of `PathObject`, but we don't want to store millions of additional maps if they are not needed. ## Use `""_key""` format for internal use; A documented convention for `MinimalMetadataStore` is to use `""_""` as the first character for metadata values that are used internally. The practical implication is that values starting with `""_""` aren't typically shown to the user, e.g. within measurement tables. ## Thread safety; The maps returned by `DefaultProject` and its image entries are synchronized. The map returned by `PathObject.getMetadata()` is currently *not* thread-safe. This can be confirmed with the following script:; ```groovy; def pathObject = PathObjects.createAnnotationObject(ROIs.createEmptyROI()). // Control synchronization; boolean doSynchronize = true. // Make sure we have no metadata at the start; pathObject.metadata.clear(); int before = pathObject.metadata.size(). java.util.stream.IntStream.range(0, 1000); .parallel(); .forEach(i -> {; def map = pathObject.metadata; if (doSynchronize) {; synchronized (map) {; map[UUID.randomUUID().toString()] = ""Yes""; }; } else {; map[UUID.randomUUID().toString()] = ""Yes""; }. }); ; int after = pathObject.metadata.size(); print ""Metadata added: ${after - before}""; ```; If using `synchronized (map)` for the updates, then 1000 values should be added. But otherwise, you will likely see fewer values at the end. > It is probably worth synchronizing the map in a future version.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1587
https://github.com/qupath/qupath/pull/1587:1451,Safety,safe,safe,1451,"se a convenient Groovy syntax, e.g.; ```groovy; getProject().metadata['key'] = 'value'; getProjectEntry().metadata['key'] = 'value'; getSelectedObject().metadata['key'] = 'value'; ```. ## Don't use metadata too much!; For `PathObject`, the metadata is generated lazily on demand - so imposes no overhead if it isn't needed. This means that *it's generally a bad idea to start adding metadata to detections* - especially if we may have a huge number.; It introduces considerable overhead to store a `Map` for each object.; This is typically find for other kinds of `PathObject`, but we don't want to store millions of additional maps if they are not needed. ## Use `""_key""` format for internal use; A documented convention for `MinimalMetadataStore` is to use `""_""` as the first character for metadata values that are used internally. The practical implication is that values starting with `""_""` aren't typically shown to the user, e.g. within measurement tables. ## Thread safety; The maps returned by `DefaultProject` and its image entries are synchronized. The map returned by `PathObject.getMetadata()` is currently *not* thread-safe. This can be confirmed with the following script:; ```groovy; def pathObject = PathObjects.createAnnotationObject(ROIs.createEmptyROI()). // Control synchronization; boolean doSynchronize = true. // Make sure we have no metadata at the start; pathObject.metadata.clear(); int before = pathObject.metadata.size(). java.util.stream.IntStream.range(0, 1000); .parallel(); .forEach(i -> {; def map = pathObject.metadata; if (doSynchronize) {; synchronized (map) {; map[UUID.randomUUID().toString()] = ""Yes""; }; } else {; map[UUID.randomUUID().toString()] = ""Yes""; }. }); ; int after = pathObject.metadata.size(); print ""Metadata added: ${after - before}""; ```; If using `synchronized (map)` for the updates, then 1000 values should be added. But otherwise, you will likely see fewer values at the end. > It is probably worth synchronizing the map in a future version.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1587
https://github.com/qupath/qupath/pull/1587:1719,Usability,clear,clear,1719,"se a convenient Groovy syntax, e.g.; ```groovy; getProject().metadata['key'] = 'value'; getProjectEntry().metadata['key'] = 'value'; getSelectedObject().metadata['key'] = 'value'; ```. ## Don't use metadata too much!; For `PathObject`, the metadata is generated lazily on demand - so imposes no overhead if it isn't needed. This means that *it's generally a bad idea to start adding metadata to detections* - especially if we may have a huge number.; It introduces considerable overhead to store a `Map` for each object.; This is typically find for other kinds of `PathObject`, but we don't want to store millions of additional maps if they are not needed. ## Use `""_key""` format for internal use; A documented convention for `MinimalMetadataStore` is to use `""_""` as the first character for metadata values that are used internally. The practical implication is that values starting with `""_""` aren't typically shown to the user, e.g. within measurement tables. ## Thread safety; The maps returned by `DefaultProject` and its image entries are synchronized. The map returned by `PathObject.getMetadata()` is currently *not* thread-safe. This can be confirmed with the following script:; ```groovy; def pathObject = PathObjects.createAnnotationObject(ROIs.createEmptyROI()). // Control synchronization; boolean doSynchronize = true. // Make sure we have no metadata at the start; pathObject.metadata.clear(); int before = pathObject.metadata.size(). java.util.stream.IntStream.range(0, 1000); .parallel(); .forEach(i -> {; def map = pathObject.metadata; if (doSynchronize) {; synchronized (map) {; map[UUID.randomUUID().toString()] = ""Yes""; }; } else {; map[UUID.randomUUID().toString()] = ""Yes""; }. }); ; int after = pathObject.metadata.size(); print ""Metadata added: ${after - before}""; ```; If using `synchronized (map)` for the updates, then 1000 values should be added. But otherwise, you will likely see fewer values at the end. > It is probably worth synchronizing the map in a future version.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1587
https://github.com/qupath/qupath/pull/1588:214,Deployability,toggle,toggle,214,"This enables users to sort objects in the annotation/TMA core grid view by their classification. Previously it was only possible to sort by numeric measurements. Additionally, add a dropdown menu enabling users to toggle which classes of object are displayed in the grid view. ![A TMA core grid view showing only Tumor and Stroma cores, ignoring Unclassified cores, sorted by core name.](https://github.com/user-attachments/assets/7cd9b934-1235-47e8-b0b2-411f50ea376f); ![A TMA core grid view showing only Tumor and Stroma cores, ignoring Unclassified cores, sorted by classification.](https://github.com/user-attachments/assets/01789a52-a5ca-41ef-8f01-a354ac4beff3); ![A TMA core grid view showing only Tumor cores, ignoring Unclassified and Stroma cores.](https://github.com/user-attachments/assets/85fb40e9-807e-451b-b087-6de2ef8c7081)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1588
https://github.com/qupath/qupath/pull/1589:17,Integrability,wrap,wrapper,17,"Including gradle wrapper, so should build on Java 23",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1589
https://github.com/qupath/qupath/issues/1590:983,Availability,ERROR,ERROR,983,"## Bug report. **Describe the bug**; The behavior of *Analyze → Spatial analysis → Delaunay cluster features 2D* is not well-defined when applying the command to annotations that are nested (in the hierarchy) or overlapping. For 'flat' annotation arrangements the behavior is *mostly ok*, except that it does rely on *hierarchy relationships* rather than *spatial relationships*.; Which is to say, it hasn't really changed since v0.1.2. **To Reproduce**; Create an arrangement of objects similar to that shown below:. ![0-orig](https://github.com/user-attachments/assets/cf1a87fc-c73a-4ac6-be24-d830f0014604). 1. If I run *Delaunay cluster features 2D* with **_all_ annotations selected**, I see triangulation lines which *do not cross the boundary between the annotations containing cells*. ![1-all selected](https://github.com/user-attachments/assets/3309e1e3-76ca-4ec7-bf5c-e0c76b8f2d96). But I **also** get a `ConcurrentModificationException`:; ```; 15:47:01.829	[Plugin thread]	ERROR	qupath.lib.plugins.AbstractTaskRunner	Error running plugin: java.util.ConcurrentModificationException	java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; 	at java.base/java.util.concurrent.FutureTask.report(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.get(Unknown Source); 	at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); 	at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); 	at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); 	at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); 	at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); 	at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; 	at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); 	at java.base/java.util.ArrayList$Itr.next(Unknown Source); 	at java.base/java.util.Collections$UnmodifiableCollect",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:1027,Availability,Error,Error,1027,"ug**; The behavior of *Analyze → Spatial analysis → Delaunay cluster features 2D* is not well-defined when applying the command to annotations that are nested (in the hierarchy) or overlapping. For 'flat' annotation arrangements the behavior is *mostly ok*, except that it does rely on *hierarchy relationships* rather than *spatial relationships*.; Which is to say, it hasn't really changed since v0.1.2. **To Reproduce**; Create an arrangement of objects similar to that shown below:. ![0-orig](https://github.com/user-attachments/assets/cf1a87fc-c73a-4ac6-be24-d830f0014604). 1. If I run *Delaunay cluster features 2D* with **_all_ annotations selected**, I see triangulation lines which *do not cross the boundary between the annotations containing cells*. ![1-all selected](https://github.com/user-attachments/assets/3309e1e3-76ca-4ec7-bf5c-e0c76b8f2d96). But I **also** get a `ConcurrentModificationException`:; ```; 15:47:01.829	[Plugin thread]	ERROR	qupath.lib.plugins.AbstractTaskRunner	Error running plugin: java.util.ConcurrentModificationException	java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; 	at java.base/java.util.concurrent.FutureTask.report(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.get(Unknown Source); 	at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); 	at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); 	at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); 	at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); 	at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); 	at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; 	at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); 	at java.base/java.util.ArrayList$Itr.next(Unknown Source); 	at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); 	a",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:968,Modifiability,Plugin,Plugin,968,"## Bug report. **Describe the bug**; The behavior of *Analyze → Spatial analysis → Delaunay cluster features 2D* is not well-defined when applying the command to annotations that are nested (in the hierarchy) or overlapping. For 'flat' annotation arrangements the behavior is *mostly ok*, except that it does rely on *hierarchy relationships* rather than *spatial relationships*.; Which is to say, it hasn't really changed since v0.1.2. **To Reproduce**; Create an arrangement of objects similar to that shown below:. ![0-orig](https://github.com/user-attachments/assets/cf1a87fc-c73a-4ac6-be24-d830f0014604). 1. If I run *Delaunay cluster features 2D* with **_all_ annotations selected**, I see triangulation lines which *do not cross the boundary between the annotations containing cells*. ![1-all selected](https://github.com/user-attachments/assets/3309e1e3-76ca-4ec7-bf5c-e0c76b8f2d96). But I **also** get a `ConcurrentModificationException`:; ```; 15:47:01.829	[Plugin thread]	ERROR	qupath.lib.plugins.AbstractTaskRunner	Error running plugin: java.util.ConcurrentModificationException	java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; 	at java.base/java.util.concurrent.FutureTask.report(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.get(Unknown Source); 	at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); 	at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); 	at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); 	at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); 	at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); 	at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; 	at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); 	at java.base/java.util.ArrayList$Itr.next(Unknown Source); 	at java.base/java.util.Collections$UnmodifiableCollect",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:1000,Modifiability,plugin,plugins,1000,"ug report. **Describe the bug**; The behavior of *Analyze → Spatial analysis → Delaunay cluster features 2D* is not well-defined when applying the command to annotations that are nested (in the hierarchy) or overlapping. For 'flat' annotation arrangements the behavior is *mostly ok*, except that it does rely on *hierarchy relationships* rather than *spatial relationships*.; Which is to say, it hasn't really changed since v0.1.2. **To Reproduce**; Create an arrangement of objects similar to that shown below:. ![0-orig](https://github.com/user-attachments/assets/cf1a87fc-c73a-4ac6-be24-d830f0014604). 1. If I run *Delaunay cluster features 2D* with **_all_ annotations selected**, I see triangulation lines which *do not cross the boundary between the annotations containing cells*. ![1-all selected](https://github.com/user-attachments/assets/3309e1e3-76ca-4ec7-bf5c-e0c76b8f2d96). But I **also** get a `ConcurrentModificationException`:; ```; 15:47:01.829	[Plugin thread]	ERROR	qupath.lib.plugins.AbstractTaskRunner	Error running plugin: java.util.ConcurrentModificationException	java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; 	at java.base/java.util.concurrent.FutureTask.report(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.get(Unknown Source); 	at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); 	at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); 	at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); 	at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); 	at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); 	at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; 	at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); 	at java.base/java.util.ArrayList$Itr.next(Unknown Source); 	at java.base/java.util.Collections$UnmodifiableCollection",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:1041,Modifiability,plugin,plugin,1041,"ug**; The behavior of *Analyze → Spatial analysis → Delaunay cluster features 2D* is not well-defined when applying the command to annotations that are nested (in the hierarchy) or overlapping. For 'flat' annotation arrangements the behavior is *mostly ok*, except that it does rely on *hierarchy relationships* rather than *spatial relationships*.; Which is to say, it hasn't really changed since v0.1.2. **To Reproduce**; Create an arrangement of objects similar to that shown below:. ![0-orig](https://github.com/user-attachments/assets/cf1a87fc-c73a-4ac6-be24-d830f0014604). 1. If I run *Delaunay cluster features 2D* with **_all_ annotations selected**, I see triangulation lines which *do not cross the boundary between the annotations containing cells*. ![1-all selected](https://github.com/user-attachments/assets/3309e1e3-76ca-4ec7-bf5c-e0c76b8f2d96). But I **also** get a `ConcurrentModificationException`:; ```; 15:47:01.829	[Plugin thread]	ERROR	qupath.lib.plugins.AbstractTaskRunner	Error running plugin: java.util.ConcurrentModificationException	java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; 	at java.base/java.util.concurrent.FutureTask.report(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.get(Unknown Source); 	at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); 	at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); 	at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); 	at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); 	at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); 	at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; 	at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); 	at java.base/java.util.ArrayList$Itr.next(Unknown Source); 	at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); 	a",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:1327,Modifiability,plugin,plugins,1327,"ationships* rather than *spatial relationships*.; Which is to say, it hasn't really changed since v0.1.2. **To Reproduce**; Create an arrangement of objects similar to that shown below:. ![0-orig](https://github.com/user-attachments/assets/cf1a87fc-c73a-4ac6-be24-d830f0014604). 1. If I run *Delaunay cluster features 2D* with **_all_ annotations selected**, I see triangulation lines which *do not cross the boundary between the annotations containing cells*. ![1-all selected](https://github.com/user-attachments/assets/3309e1e3-76ca-4ec7-bf5c-e0c76b8f2d96). But I **also** get a `ConcurrentModificationException`:; ```; 15:47:01.829	[Plugin thread]	ERROR	qupath.lib.plugins.AbstractTaskRunner	Error running plugin: java.util.ConcurrentModificationException	java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; 	at java.base/java.util.concurrent.FutureTask.report(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.get(Unknown Source); 	at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); 	at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); 	at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); 	at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); 	at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); 	at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; 	at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); 	at java.base/java.util.ArrayList$Itr.next(Unknown Source); 	at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); 	at java.base/java.util.AbstractCollection.addAll(Unknown Source); 	at qupath.lib.objects.PathObjectTools.getAvailableFeatures(PathObjectTools.java:2026); 	at qupath.opencv.features.DelaunayTriangulation.<init>(DelaunayTriangulation.java:86); 	at qupath.opencv.features.DelaunayClusteringPlugin$Delauna",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:1415,Modifiability,plugin,plugins,1415,"ged since v0.1.2. **To Reproduce**; Create an arrangement of objects similar to that shown below:. ![0-orig](https://github.com/user-attachments/assets/cf1a87fc-c73a-4ac6-be24-d830f0014604). 1. If I run *Delaunay cluster features 2D* with **_all_ annotations selected**, I see triangulation lines which *do not cross the boundary between the annotations containing cells*. ![1-all selected](https://github.com/user-attachments/assets/3309e1e3-76ca-4ec7-bf5c-e0c76b8f2d96). But I **also** get a `ConcurrentModificationException`:; ```; 15:47:01.829	[Plugin thread]	ERROR	qupath.lib.plugins.AbstractTaskRunner	Error running plugin: java.util.ConcurrentModificationException	java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; 	at java.base/java.util.concurrent.FutureTask.report(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.get(Unknown Source); 	at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); 	at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); 	at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); 	at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); 	at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); 	at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; 	at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); 	at java.base/java.util.ArrayList$Itr.next(Unknown Source); 	at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); 	at java.base/java.util.AbstractCollection.addAll(Unknown Source); 	at qupath.lib.objects.PathObjectTools.getAvailableFeatures(PathObjectTools.java:2026); 	at qupath.opencv.features.DelaunayTriangulation.<init>(DelaunayTriangulation.java:86); 	at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:208); 	at java.base/java.util.concurrent.Exe",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:1561,Modifiability,plugin,plugins,1561,"ssets/cf1a87fc-c73a-4ac6-be24-d830f0014604). 1. If I run *Delaunay cluster features 2D* with **_all_ annotations selected**, I see triangulation lines which *do not cross the boundary between the annotations containing cells*. ![1-all selected](https://github.com/user-attachments/assets/3309e1e3-76ca-4ec7-bf5c-e0c76b8f2d96). But I **also** get a `ConcurrentModificationException`:; ```; 15:47:01.829	[Plugin thread]	ERROR	qupath.lib.plugins.AbstractTaskRunner	Error running plugin: java.util.ConcurrentModificationException	java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; 	at java.base/java.util.concurrent.FutureTask.report(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.get(Unknown Source); 	at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); 	at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); 	at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); 	at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); 	at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); 	at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; 	at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); 	at java.base/java.util.ArrayList$Itr.next(Unknown Source); 	at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); 	at java.base/java.util.AbstractCollection.addAll(Unknown Source); 	at qupath.lib.objects.PathObjectTools.getAvailableFeatures(PathObjectTools.java:2026); 	at qupath.opencv.features.DelaunayTriangulation.<init>(DelaunayTriangulation.java:86); 	at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:208); 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.run(Unknown Source); 	at java.base/java.util.concurrent",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:914,Performance,Concurren,ConcurrentModificationException,914,"## Bug report. **Describe the bug**; The behavior of *Analyze → Spatial analysis → Delaunay cluster features 2D* is not well-defined when applying the command to annotations that are nested (in the hierarchy) or overlapping. For 'flat' annotation arrangements the behavior is *mostly ok*, except that it does rely on *hierarchy relationships* rather than *spatial relationships*.; Which is to say, it hasn't really changed since v0.1.2. **To Reproduce**; Create an arrangement of objects similar to that shown below:. ![0-orig](https://github.com/user-attachments/assets/cf1a87fc-c73a-4ac6-be24-d830f0014604). 1. If I run *Delaunay cluster features 2D* with **_all_ annotations selected**, I see triangulation lines which *do not cross the boundary between the annotations containing cells*. ![1-all selected](https://github.com/user-attachments/assets/3309e1e3-76ca-4ec7-bf5c-e0c76b8f2d96). But I **also** get a `ConcurrentModificationException`:; ```; 15:47:01.829	[Plugin thread]	ERROR	qupath.lib.plugins.AbstractTaskRunner	Error running plugin: java.util.ConcurrentModificationException	java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; 	at java.base/java.util.concurrent.FutureTask.report(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.get(Unknown Source); 	at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); 	at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); 	at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); 	at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); 	at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); 	at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; 	at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); 	at java.base/java.util.ArrayList$Itr.next(Unknown Source); 	at java.base/java.util.Collections$UnmodifiableCollect",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:1059,Performance,Concurren,ConcurrentModificationException,1059,"sis → Delaunay cluster features 2D* is not well-defined when applying the command to annotations that are nested (in the hierarchy) or overlapping. For 'flat' annotation arrangements the behavior is *mostly ok*, except that it does rely on *hierarchy relationships* rather than *spatial relationships*.; Which is to say, it hasn't really changed since v0.1.2. **To Reproduce**; Create an arrangement of objects similar to that shown below:. ![0-orig](https://github.com/user-attachments/assets/cf1a87fc-c73a-4ac6-be24-d830f0014604). 1. If I run *Delaunay cluster features 2D* with **_all_ annotations selected**, I see triangulation lines which *do not cross the boundary between the annotations containing cells*. ![1-all selected](https://github.com/user-attachments/assets/3309e1e3-76ca-4ec7-bf5c-e0c76b8f2d96). But I **also** get a `ConcurrentModificationException`:; ```; 15:47:01.829	[Plugin thread]	ERROR	qupath.lib.plugins.AbstractTaskRunner	Error running plugin: java.util.ConcurrentModificationException	java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; 	at java.base/java.util.concurrent.FutureTask.report(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.get(Unknown Source); 	at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); 	at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); 	at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); 	at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); 	at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); 	at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; 	at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); 	at java.base/java.util.ArrayList$Itr.next(Unknown Source); 	at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); 	at java.base/java.util.AbstractCollection.addAll",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:1101,Performance,concurren,concurrent,1101,"es 2D* is not well-defined when applying the command to annotations that are nested (in the hierarchy) or overlapping. For 'flat' annotation arrangements the behavior is *mostly ok*, except that it does rely on *hierarchy relationships* rather than *spatial relationships*.; Which is to say, it hasn't really changed since v0.1.2. **To Reproduce**; Create an arrangement of objects similar to that shown below:. ![0-orig](https://github.com/user-attachments/assets/cf1a87fc-c73a-4ac6-be24-d830f0014604). 1. If I run *Delaunay cluster features 2D* with **_all_ annotations selected**, I see triangulation lines which *do not cross the boundary between the annotations containing cells*. ![1-all selected](https://github.com/user-attachments/assets/3309e1e3-76ca-4ec7-bf5c-e0c76b8f2d96). But I **also** get a `ConcurrentModificationException`:; ```; 15:47:01.829	[Plugin thread]	ERROR	qupath.lib.plugins.AbstractTaskRunner	Error running plugin: java.util.ConcurrentModificationException	java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; 	at java.base/java.util.concurrent.FutureTask.report(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.get(Unknown Source); 	at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); 	at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); 	at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); 	at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); 	at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); 	at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; 	at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); 	at java.base/java.util.ArrayList$Itr.next(Unknown Source); 	at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); 	at java.base/java.util.AbstractCollection.addAll(Unknown Source); 	at qupath.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:1142,Performance,Concurren,ConcurrentModificationException,1142,"nnotations that are nested (in the hierarchy) or overlapping. For 'flat' annotation arrangements the behavior is *mostly ok*, except that it does rely on *hierarchy relationships* rather than *spatial relationships*.; Which is to say, it hasn't really changed since v0.1.2. **To Reproduce**; Create an arrangement of objects similar to that shown below:. ![0-orig](https://github.com/user-attachments/assets/cf1a87fc-c73a-4ac6-be24-d830f0014604). 1. If I run *Delaunay cluster features 2D* with **_all_ annotations selected**, I see triangulation lines which *do not cross the boundary between the annotations containing cells*. ![1-all selected](https://github.com/user-attachments/assets/3309e1e3-76ca-4ec7-bf5c-e0c76b8f2d96). But I **also** get a `ConcurrentModificationException`:; ```; 15:47:01.829	[Plugin thread]	ERROR	qupath.lib.plugins.AbstractTaskRunner	Error running plugin: java.util.ConcurrentModificationException	java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; 	at java.base/java.util.concurrent.FutureTask.report(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.get(Unknown Source); 	at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); 	at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); 	at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); 	at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); 	at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); 	at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; 	at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); 	at java.base/java.util.ArrayList$Itr.next(Unknown Source); 	at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); 	at java.base/java.util.AbstractCollection.addAll(Unknown Source); 	at qupath.lib.objects.PathObjectTools.getAvailableFeatures(PathObj",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:1199,Performance,concurren,concurrent,1199,"chy) or overlapping. For 'flat' annotation arrangements the behavior is *mostly ok*, except that it does rely on *hierarchy relationships* rather than *spatial relationships*.; Which is to say, it hasn't really changed since v0.1.2. **To Reproduce**; Create an arrangement of objects similar to that shown below:. ![0-orig](https://github.com/user-attachments/assets/cf1a87fc-c73a-4ac6-be24-d830f0014604). 1. If I run *Delaunay cluster features 2D* with **_all_ annotations selected**, I see triangulation lines which *do not cross the boundary between the annotations containing cells*. ![1-all selected](https://github.com/user-attachments/assets/3309e1e3-76ca-4ec7-bf5c-e0c76b8f2d96). But I **also** get a `ConcurrentModificationException`:; ```; 15:47:01.829	[Plugin thread]	ERROR	qupath.lib.plugins.AbstractTaskRunner	Error running plugin: java.util.ConcurrentModificationException	java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; 	at java.base/java.util.concurrent.FutureTask.report(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.get(Unknown Source); 	at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); 	at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); 	at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); 	at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); 	at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); 	at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; 	at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); 	at java.base/java.util.ArrayList$Itr.next(Unknown Source); 	at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); 	at java.base/java.util.AbstractCollection.addAll(Unknown Source); 	at qupath.lib.objects.PathObjectTools.getAvailableFeatures(PathObjectTools.java:2026); 	at qupath.opencv.fea",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:1269,Performance,concurren,concurrent,1269,"s *mostly ok*, except that it does rely on *hierarchy relationships* rather than *spatial relationships*.; Which is to say, it hasn't really changed since v0.1.2. **To Reproduce**; Create an arrangement of objects similar to that shown below:. ![0-orig](https://github.com/user-attachments/assets/cf1a87fc-c73a-4ac6-be24-d830f0014604). 1. If I run *Delaunay cluster features 2D* with **_all_ annotations selected**, I see triangulation lines which *do not cross the boundary between the annotations containing cells*. ![1-all selected](https://github.com/user-attachments/assets/3309e1e3-76ca-4ec7-bf5c-e0c76b8f2d96). But I **also** get a `ConcurrentModificationException`:; ```; 15:47:01.829	[Plugin thread]	ERROR	qupath.lib.plugins.AbstractTaskRunner	Error running plugin: java.util.ConcurrentModificationException	java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; 	at java.base/java.util.concurrent.FutureTask.report(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.get(Unknown Source); 	at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); 	at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); 	at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); 	at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); 	at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); 	at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; 	at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); 	at java.base/java.util.ArrayList$Itr.next(Unknown Source); 	at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); 	at java.base/java.util.AbstractCollection.addAll(Unknown Source); 	at qupath.lib.objects.PathObjectTools.getAvailableFeatures(PathObjectTools.java:2026); 	at qupath.opencv.features.DelaunayTriangulation.<init>(DelaunayTriangulation.java:86); 	at",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:1775,Performance,Concurren,ConcurrentModificationException,1775,all selected](https://github.com/user-attachments/assets/3309e1e3-76ca-4ec7-bf5c-e0c76b8f2d96). But I **also** get a `ConcurrentModificationException`:; ```; 15:47:01.829	[Plugin thread]	ERROR	qupath.lib.plugins.AbstractTaskRunner	Error running plugin: java.util.ConcurrentModificationException	java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; 	at java.base/java.util.concurrent.FutureTask.report(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.get(Unknown Source); 	at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); 	at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); 	at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); 	at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); 	at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); 	at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; 	at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); 	at java.base/java.util.ArrayList$Itr.next(Unknown Source); 	at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); 	at java.base/java.util.AbstractCollection.addAll(Unknown Source); 	at qupath.lib.objects.PathObjectTools.getAvailableFeatures(PathObjectTools.java:2026); 	at qupath.opencv.features.DelaunayTriangulation.<init>(DelaunayTriangulation.java:86); 	at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:208); 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.run(Unknown Source); 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.run(Unknown Source); 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); 	at java.base/java.util.concurrent,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:2405,Performance,concurren,concurrent,2405,".lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); 	at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); 	at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); 	at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); 	at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; 	at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); 	at java.base/java.util.ArrayList$Itr.next(Unknown Source); 	at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); 	at java.base/java.util.AbstractCollection.addAll(Unknown Source); 	at qupath.lib.objects.PathObjectTools.getAvailableFeatures(PathObjectTools.java:2026); 	at qupath.opencv.features.DelaunayTriangulation.<init>(DelaunayTriangulation.java:86); 	at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:208); 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.run(Unknown Source); 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.run(Unknown Source); 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); 	... 1 more; ```. 2. If I repeat with **the outer rectangle selected**, then I *do* see connections.; This is because the triangulation uses *all descendant detections below the rectangle, based on the object hierarchy*. ![2-rectangle](https://github.com/user-attachments/assets/21b82d18-ce97-45c3-9644-7abdf85ab007). 3. If I repeat with **the outer ellipse selected**, I get *no connections at all*.; This is because the ellipse isn't set to be a parent of any of the other objects - this would change if I called *Resolve hierarchy* first. ![3-ellipse](https://gith",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:2488,Performance,concurren,concurrent,2488,"ib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); 	at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); 	at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); 	at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; 	at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); 	at java.base/java.util.ArrayList$Itr.next(Unknown Source); 	at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); 	at java.base/java.util.AbstractCollection.addAll(Unknown Source); 	at qupath.lib.objects.PathObjectTools.getAvailableFeatures(PathObjectTools.java:2026); 	at qupath.opencv.features.DelaunayTriangulation.<init>(DelaunayTriangulation.java:86); 	at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:208); 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.run(Unknown Source); 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.run(Unknown Source); 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); 	... 1 more; ```. 2. If I repeat with **the outer rectangle selected**, then I *do* see connections.; This is because the triangulation uses *all descendant detections below the rectangle, based on the object hierarchy*. ![2-rectangle](https://github.com/user-attachments/assets/21b82d18-ce97-45c3-9644-7abdf85ab007). 3. If I repeat with **the outer ellipse selected**, I get *no connections at all*.; This is because the ellipse isn't set to be a parent of any of the other objects - this would change if I called *Resolve hierarchy* first. ![3-ellipse](https://github.com/user-attachments/assets/3c39bea5-9a9c-4ae3-bcc9-7ece1e8bae9c). 4. If I repea",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:2555,Performance,concurren,concurrent,2555,".plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); 	at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); 	at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; 	at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); 	at java.base/java.util.ArrayList$Itr.next(Unknown Source); 	at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); 	at java.base/java.util.AbstractCollection.addAll(Unknown Source); 	at qupath.lib.objects.PathObjectTools.getAvailableFeatures(PathObjectTools.java:2026); 	at qupath.opencv.features.DelaunayTriangulation.<init>(DelaunayTriangulation.java:86); 	at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:208); 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.run(Unknown Source); 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.run(Unknown Source); 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); 	... 1 more; ```. 2. If I repeat with **the outer rectangle selected**, then I *do* see connections.; This is because the triangulation uses *all descendant detections below the rectangle, based on the object hierarchy*. ![2-rectangle](https://github.com/user-attachments/assets/21b82d18-ce97-45c3-9644-7abdf85ab007). 3. If I repeat with **the outer ellipse selected**, I get *no connections at all*.; This is because the ellipse isn't set to be a parent of any of the other objects - this would change if I called *Resolve hierarchy* first. ![3-ellipse](https://github.com/user-attachments/assets/3c39bea5-9a9c-4ae3-bcc9-7ece1e8bae9c). 4. If I repeat with **the inner rectangles selected**, I get connections that do",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:2638,Performance,concurren,concurrent,2638,"meterDialogWrapper$1.run(ParameterDialogWrapper.java:177); 	at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; 	at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); 	at java.base/java.util.ArrayList$Itr.next(Unknown Source); 	at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); 	at java.base/java.util.AbstractCollection.addAll(Unknown Source); 	at qupath.lib.objects.PathObjectTools.getAvailableFeatures(PathObjectTools.java:2026); 	at qupath.opencv.features.DelaunayTriangulation.<init>(DelaunayTriangulation.java:86); 	at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:208); 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.run(Unknown Source); 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.run(Unknown Source); 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); 	... 1 more; ```. 2. If I repeat with **the outer rectangle selected**, then I *do* see connections.; This is because the triangulation uses *all descendant detections below the rectangle, based on the object hierarchy*. ![2-rectangle](https://github.com/user-attachments/assets/21b82d18-ce97-45c3-9644-7abdf85ab007). 3. If I repeat with **the outer ellipse selected**, I get *no connections at all*.; This is because the ellipse isn't set to be a parent of any of the other objects - this would change if I called *Resolve hierarchy* first. ![3-ellipse](https://github.com/user-attachments/assets/3c39bea5-9a9c-4ae3-bcc9-7ece1e8bae9c). 4. If I repeat with **the inner rectangles selected**, I get connections that don't cross *and I don't get any exception*.; This is because each cell is only handl",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:2705,Performance,concurren,concurrent,2705,".base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; 	at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); 	at java.base/java.util.ArrayList$Itr.next(Unknown Source); 	at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); 	at java.base/java.util.AbstractCollection.addAll(Unknown Source); 	at qupath.lib.objects.PathObjectTools.getAvailableFeatures(PathObjectTools.java:2026); 	at qupath.opencv.features.DelaunayTriangulation.<init>(DelaunayTriangulation.java:86); 	at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:208); 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.run(Unknown Source); 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.run(Unknown Source); 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); 	... 1 more; ```. 2. If I repeat with **the outer rectangle selected**, then I *do* see connections.; This is because the triangulation uses *all descendant detections below the rectangle, based on the object hierarchy*. ![2-rectangle](https://github.com/user-attachments/assets/21b82d18-ce97-45c3-9644-7abdf85ab007). 3. If I repeat with **the outer ellipse selected**, I get *no connections at all*.; This is because the ellipse isn't set to be a parent of any of the other objects - this would change if I called *Resolve hierarchy* first. ![3-ellipse](https://github.com/user-attachments/assets/3c39bea5-9a9c-4ae3-bcc9-7ece1e8bae9c). 4. If I repeat with **the inner rectangles selected**, I get connections that don't cross *and I don't get any exception*.; This is because each cell is only handled once, so I don't get the concurrency trouble. ![4-inner rectangl",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:2786,Performance,concurren,concurrent,2786,"cationException; 	at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); 	at java.base/java.util.ArrayList$Itr.next(Unknown Source); 	at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); 	at java.base/java.util.AbstractCollection.addAll(Unknown Source); 	at qupath.lib.objects.PathObjectTools.getAvailableFeatures(PathObjectTools.java:2026); 	at qupath.opencv.features.DelaunayTriangulation.<init>(DelaunayTriangulation.java:86); 	at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:208); 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.run(Unknown Source); 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.run(Unknown Source); 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); 	... 1 more; ```. 2. If I repeat with **the outer rectangle selected**, then I *do* see connections.; This is because the triangulation uses *all descendant detections below the rectangle, based on the object hierarchy*. ![2-rectangle](https://github.com/user-attachments/assets/21b82d18-ce97-45c3-9644-7abdf85ab007). 3. If I repeat with **the outer ellipse selected**, I get *no connections at all*.; This is because the ellipse isn't set to be a parent of any of the other objects - this would change if I called *Resolve hierarchy* first. ![3-ellipse](https://github.com/user-attachments/assets/3c39bea5-9a9c-4ae3-bcc9-7ece1e8bae9c). 4. If I repeat with **the inner rectangles selected**, I get connections that don't cross *and I don't get any exception*.; This is because each cell is only handled once, so I don't get the concurrency trouble. ![4-inner rectangles](https://github.com/user-attachments/assets/74edf4a3-05c0-49ea-bd38-f82d327d95",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:3672,Performance,concurren,concurrency,3672,"t.FutureTask.run(Unknown Source); 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); 	... 1 more; ```. 2. If I repeat with **the outer rectangle selected**, then I *do* see connections.; This is because the triangulation uses *all descendant detections below the rectangle, based on the object hierarchy*. ![2-rectangle](https://github.com/user-attachments/assets/21b82d18-ce97-45c3-9644-7abdf85ab007). 3. If I repeat with **the outer ellipse selected**, I get *no connections at all*.; This is because the ellipse isn't set to be a parent of any of the other objects - this would change if I called *Resolve hierarchy* first. ![3-ellipse](https://github.com/user-attachments/assets/3c39bea5-9a9c-4ae3-bcc9-7ece1e8bae9c). 4. If I repeat with **the inner rectangles selected**, I get connections that don't cross *and I don't get any exception*.; This is because each cell is only handled once, so I don't get the concurrency trouble. ![4-inner rectangles](https://github.com/user-attachments/assets/74edf4a3-05c0-49ea-bd38-f82d327d9564). 5. If I repeat with **only 1 inner rectangle selected**, I get connections within that rectangle only. ![5-single rectangle](https://github.com/user-attachments/assets/492cf523-c58d-4b48-b417-ac44662a7a5a). **Expected behavior**; This isn't obvious... Nevertheless:; 1. The `ConcurrentModificationException` is clearly bad. But it's also kind of helpful here, because 2. and 4. give different results... and when that's the case, if we select all the annotations in 2. and 4. in one go, it's not obvious what *should* happen.; 2. The reliance on hierarchical relationships may not be very intuitive to a user, since measurements like 'Positive %' are dynamically computed using spatial location relative to any selected annotation - not hierarchical relationships. **Desktop (please complete the following information):**; - OS: All; - QuPath Version:",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:4072,Performance,Concurren,ConcurrentModificationException,4072,"b.com/user-attachments/assets/21b82d18-ce97-45c3-9644-7abdf85ab007). 3. If I repeat with **the outer ellipse selected**, I get *no connections at all*.; This is because the ellipse isn't set to be a parent of any of the other objects - this would change if I called *Resolve hierarchy* first. ![3-ellipse](https://github.com/user-attachments/assets/3c39bea5-9a9c-4ae3-bcc9-7ece1e8bae9c). 4. If I repeat with **the inner rectangles selected**, I get connections that don't cross *and I don't get any exception*.; This is because each cell is only handled once, so I don't get the concurrency trouble. ![4-inner rectangles](https://github.com/user-attachments/assets/74edf4a3-05c0-49ea-bd38-f82d327d9564). 5. If I repeat with **only 1 inner rectangle selected**, I get connections within that rectangle only. ![5-single rectangle](https://github.com/user-attachments/assets/492cf523-c58d-4b48-b417-ac44662a7a5a). **Expected behavior**; This isn't obvious... Nevertheless:; 1. The `ConcurrentModificationException` is clearly bad. But it's also kind of helpful here, because 2. and 4. give different results... and when that's the case, if we select all the annotations in 2. and 4. in one go, it's not obvious what *should* happen.; 2. The reliance on hierarchical relationships may not be very intuitive to a user, since measurements like 'Positive %' are dynamically computed using spatial location relative to any selected annotation - not hierarchical relationships. **Desktop (please complete the following information):**; - OS: All; - QuPath Version: v0.5.1 (and earlier). **Additional context**; This relates to:; * #1444; * #1466. The behavior of *Delaunay cluster features 2D* is *in general* not very good for more reasons than these. For example, the display of the connection lines is already a bit of a hack (smuggled into `ImageData` properties) - and showing/hiding these can be unreliable. But fixing #1466 risks swallowing the `ConcurrentModificationException`, meaning we get unexpec",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:5037,Performance,Concurren,ConcurrentModificationException,5037,"). 3. If I repeat with **the outer ellipse selected**, I get *no connections at all*.; This is because the ellipse isn't set to be a parent of any of the other objects - this would change if I called *Resolve hierarchy* first. ![3-ellipse](https://github.com/user-attachments/assets/3c39bea5-9a9c-4ae3-bcc9-7ece1e8bae9c). 4. If I repeat with **the inner rectangles selected**, I get connections that don't cross *and I don't get any exception*.; This is because each cell is only handled once, so I don't get the concurrency trouble. ![4-inner rectangles](https://github.com/user-attachments/assets/74edf4a3-05c0-49ea-bd38-f82d327d9564). 5. If I repeat with **only 1 inner rectangle selected**, I get connections within that rectangle only. ![5-single rectangle](https://github.com/user-attachments/assets/492cf523-c58d-4b48-b417-ac44662a7a5a). **Expected behavior**; This isn't obvious... Nevertheless:; 1. The `ConcurrentModificationException` is clearly bad. But it's also kind of helpful here, because 2. and 4. give different results... and when that's the case, if we select all the annotations in 2. and 4. in one go, it's not obvious what *should* happen.; 2. The reliance on hierarchical relationships may not be very intuitive to a user, since measurements like 'Positive %' are dynamically computed using spatial location relative to any selected annotation - not hierarchical relationships. **Desktop (please complete the following information):**; - OS: All; - QuPath Version: v0.5.1 (and earlier). **Additional context**; This relates to:; * #1444; * #1466. The behavior of *Delaunay cluster features 2D* is *in general* not very good for more reasons than these. For example, the display of the connection lines is already a bit of a hack (smuggled into `ImageData` properties) - and showing/hiding these can be unreliable. But fixing #1466 risks swallowing the `ConcurrentModificationException`, meaning we get unexpected results rather than an exception - which is potentially worse.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:3001,Safety,detect,detections,3001,"$1.next(Unknown Source); 	at java.base/java.util.AbstractCollection.addAll(Unknown Source); 	at qupath.lib.objects.PathObjectTools.getAvailableFeatures(PathObjectTools.java:2026); 	at qupath.opencv.features.DelaunayTriangulation.<init>(DelaunayTriangulation.java:86); 	at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:208); 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.run(Unknown Source); 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); 	at java.base/java.util.concurrent.FutureTask.run(Unknown Source); 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); 	... 1 more; ```. 2. If I repeat with **the outer rectangle selected**, then I *do* see connections.; This is because the triangulation uses *all descendant detections below the rectangle, based on the object hierarchy*. ![2-rectangle](https://github.com/user-attachments/assets/21b82d18-ce97-45c3-9644-7abdf85ab007). 3. If I repeat with **the outer ellipse selected**, I get *no connections at all*.; This is because the ellipse isn't set to be a parent of any of the other objects - this would change if I called *Resolve hierarchy* first. ![3-ellipse](https://github.com/user-attachments/assets/3c39bea5-9a9c-4ae3-bcc9-7ece1e8bae9c). 4. If I repeat with **the inner rectangles selected**, I get connections that don't cross *and I don't get any exception*.; This is because each cell is only handled once, so I don't get the concurrency trouble. ![4-inner rectangles](https://github.com/user-attachments/assets/74edf4a3-05c0-49ea-bd38-f82d327d9564). 5. If I repeat with **only 1 inner rectangle selected**, I get connections within that rectangle only. ![5-single rectangle](https://github.com/user-attachments/assets/492cf523-c58d-4b48-b417-ac44662a7a5a). ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:5015,Safety,risk,risks,5015,"). 3. If I repeat with **the outer ellipse selected**, I get *no connections at all*.; This is because the ellipse isn't set to be a parent of any of the other objects - this would change if I called *Resolve hierarchy* first. ![3-ellipse](https://github.com/user-attachments/assets/3c39bea5-9a9c-4ae3-bcc9-7ece1e8bae9c). 4. If I repeat with **the inner rectangles selected**, I get connections that don't cross *and I don't get any exception*.; This is because each cell is only handled once, so I don't get the concurrency trouble. ![4-inner rectangles](https://github.com/user-attachments/assets/74edf4a3-05c0-49ea-bd38-f82d327d9564). 5. If I repeat with **only 1 inner rectangle selected**, I get connections within that rectangle only. ![5-single rectangle](https://github.com/user-attachments/assets/492cf523-c58d-4b48-b417-ac44662a7a5a). **Expected behavior**; This isn't obvious... Nevertheless:; 1. The `ConcurrentModificationException` is clearly bad. But it's also kind of helpful here, because 2. and 4. give different results... and when that's the case, if we select all the annotations in 2. and 4. in one go, it's not obvious what *should* happen.; 2. The reliance on hierarchical relationships may not be very intuitive to a user, since measurements like 'Positive %' are dynamically computed using spatial location relative to any selected annotation - not hierarchical relationships. **Desktop (please complete the following information):**; - OS: All; - QuPath Version: v0.5.1 (and earlier). **Additional context**; This relates to:; * #1444; * #1466. The behavior of *Delaunay cluster features 2D* is *in general* not very good for more reasons than these. For example, the display of the connection lines is already a bit of a hack (smuggled into `ImageData` properties) - and showing/hiding these can be unreliable. But fixing #1466 risks swallowing the `ConcurrentModificationException`, meaning we get unexpected results rather than an exception - which is potentially worse.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:4108,Usability,clear,clearly,4108,"b.com/user-attachments/assets/21b82d18-ce97-45c3-9644-7abdf85ab007). 3. If I repeat with **the outer ellipse selected**, I get *no connections at all*.; This is because the ellipse isn't set to be a parent of any of the other objects - this would change if I called *Resolve hierarchy* first. ![3-ellipse](https://github.com/user-attachments/assets/3c39bea5-9a9c-4ae3-bcc9-7ece1e8bae9c). 4. If I repeat with **the inner rectangles selected**, I get connections that don't cross *and I don't get any exception*.; This is because each cell is only handled once, so I don't get the concurrency trouble. ![4-inner rectangles](https://github.com/user-attachments/assets/74edf4a3-05c0-49ea-bd38-f82d327d9564). 5. If I repeat with **only 1 inner rectangle selected**, I get connections within that rectangle only. ![5-single rectangle](https://github.com/user-attachments/assets/492cf523-c58d-4b48-b417-ac44662a7a5a). **Expected behavior**; This isn't obvious... Nevertheless:; 1. The `ConcurrentModificationException` is clearly bad. But it's also kind of helpful here, because 2. and 4. give different results... and when that's the case, if we select all the annotations in 2. and 4. in one go, it's not obvious what *should* happen.; 2. The reliance on hierarchical relationships may not be very intuitive to a user, since measurements like 'Positive %' are dynamically computed using spatial location relative to any selected annotation - not hierarchical relationships. **Desktop (please complete the following information):**; - OS: All; - QuPath Version: v0.5.1 (and earlier). **Additional context**; This relates to:; * #1444; * #1466. The behavior of *Delaunay cluster features 2D* is *in general* not very good for more reasons than these. For example, the display of the connection lines is already a bit of a hack (smuggled into `ImageData` properties) - and showing/hiding these can be unreliable. But fixing #1466 risks swallowing the `ConcurrentModificationException`, meaning we get unexpec",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1590:4386,Usability,intuit,intuitive,4386,"). 3. If I repeat with **the outer ellipse selected**, I get *no connections at all*.; This is because the ellipse isn't set to be a parent of any of the other objects - this would change if I called *Resolve hierarchy* first. ![3-ellipse](https://github.com/user-attachments/assets/3c39bea5-9a9c-4ae3-bcc9-7ece1e8bae9c). 4. If I repeat with **the inner rectangles selected**, I get connections that don't cross *and I don't get any exception*.; This is because each cell is only handled once, so I don't get the concurrency trouble. ![4-inner rectangles](https://github.com/user-attachments/assets/74edf4a3-05c0-49ea-bd38-f82d327d9564). 5. If I repeat with **only 1 inner rectangle selected**, I get connections within that rectangle only. ![5-single rectangle](https://github.com/user-attachments/assets/492cf523-c58d-4b48-b417-ac44662a7a5a). **Expected behavior**; This isn't obvious... Nevertheless:; 1. The `ConcurrentModificationException` is clearly bad. But it's also kind of helpful here, because 2. and 4. give different results... and when that's the case, if we select all the annotations in 2. and 4. in one go, it's not obvious what *should* happen.; 2. The reliance on hierarchical relationships may not be very intuitive to a user, since measurements like 'Positive %' are dynamically computed using spatial location relative to any selected annotation - not hierarchical relationships. **Desktop (please complete the following information):**; - OS: All; - QuPath Version: v0.5.1 (and earlier). **Additional context**; This relates to:; * #1444; * #1466. The behavior of *Delaunay cluster features 2D* is *in general* not very good for more reasons than these. For example, the display of the connection lines is already a bit of a hack (smuggled into `ImageData` properties) - and showing/hiding these can be unreliable. But fixing #1466 risks swallowing the `ConcurrentModificationException`, meaning we get unexpected results rather than an exception - which is potentially worse.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590
https://github.com/qupath/qupath/issues/1591:1090,Availability,ERROR,ERROR,1090,"xception` can be thrown when working with measurement lists in parallel threads. A related issue is reported at https://github.com/qupath/qupath/pull/1466 but the proposed fix does not solve the problem here. **To Reproduce**; Try running the script below:; ```groovy; // A growing list of objects; def pathObjects = Collections.synchronizedList([]). // Number of iterations; int n = 1000. // Create a thread to continually request all measurement names; def t = new Thread( {; while (pathObjects.size() < n) {; def list = PathObjectTools.getAvailableFeatures(new ArrayList<>(pathObjects)); }; }); t.start(). // Create a parallel stream to add new objects; java.util.stream.IntStream.range(0, n); .parallel(); .forEach(i -> {; // This happens only with detections!; def pathObject = PathObjects.createDetectionObject(ROIs.createEmptyROI()); pathObjects << pathObject; for (int k = 0; k <= i; k++); pathObject.measurementList.put(""M_$k"", i); }); t.join(); ; println ""Done!""; ```. I see an exception; ```; ERROR: null; java.util.ConcurrentModificationException: null; at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); at java.base/java.util.ArrayList$Itr.next(Unknown Source); at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); at java.base/java.util.AbstractCollection.addAll(Unknown Source); at qupath.lib.objects.PathObjectTools.getAvailableFeatures(PathObjectTools.java:2026); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript$_run_closure1.doCall(QuPathScript:11); at QuPathScript$_run_closure1.doCall(QuPathScript); at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(Unknown Source); at java.base/java.lang.reflect.Method.invoke(Unknown Source); at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:343); at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:328); at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaCl",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1591
https://github.com/qupath/qupath/issues/1591:2918,Availability,robust,robustness,2918,"on: null; at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); at java.base/java.util.ArrayList$Itr.next(Unknown Source); at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); at java.base/java.util.AbstractCollection.addAll(Unknown Source); at qupath.lib.objects.PathObjectTools.getAvailableFeatures(PathObjectTools.java:2026); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript$_run_closure1.doCall(QuPathScript:11); at QuPathScript$_run_closure1.doCall(QuPathScript); at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(Unknown Source); at java.base/java.lang.reflect.Method.invoke(Unknown Source); at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:343); at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:328); at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:279); at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1008); at groovy.lang.Closure.call(Closure.java:433); at groovy.lang.Closure.call(Closure.java:412); at groovy.lang.Closure.run(Closure.java:505); at java.base/java.lang.Thread.run(Unknown Source); ```. **Expected behavior**; The code runs without any exception. **Desktop (please complete the following information):**; - OS: macOS (but probably all); - QuPath Version: v0.5.1. **Additional context**; This seems to only occur with detections. The underlying issue in this specific case seems to be that these can return an unmodifiable list of measurement names, but when this is used by `PathObjectTools.getAvailableFeatures(Collection)` the underlying list is being modified. A fix may require revising `MeasurementList` more thoroughly to improve its robustness. > Edit: The original 'failing' script I posted here was failing because `pathObjects` was being modified... the version after I ended the issue fails in the 'right' place to show the issue I was trying to report.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1591
https://github.com/qupath/qupath/issues/1591:415,Integrability,synchroniz,synchronizedList,415,"## Bug report. **Describe the bug**; In some circumstances, a `ConcurrentModificationException` can be thrown when working with measurement lists in parallel threads. A related issue is reported at https://github.com/qupath/qupath/pull/1466 but the proposed fix does not solve the problem here. **To Reproduce**; Try running the script below:; ```groovy; // A growing list of objects; def pathObjects = Collections.synchronizedList([]). // Number of iterations; int n = 1000. // Create a thread to continually request all measurement names; def t = new Thread( {; while (pathObjects.size() < n) {; def list = PathObjectTools.getAvailableFeatures(new ArrayList<>(pathObjects)); }; }); t.start(). // Create a parallel stream to add new objects; java.util.stream.IntStream.range(0, n); .parallel(); .forEach(i -> {; // This happens only with detections!; def pathObject = PathObjects.createDetectionObject(ROIs.createEmptyROI()); pathObjects << pathObject; for (int k = 0; k <= i; k++); pathObject.measurementList.put(""M_$k"", i); }); t.join(); ; println ""Done!""; ```. I see an exception; ```; ERROR: null; java.util.ConcurrentModificationException: null; at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); at java.base/java.util.ArrayList$Itr.next(Unknown Source); at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); at java.base/java.util.AbstractCollection.addAll(Unknown Source); at qupath.lib.objects.PathObjectTools.getAvailableFeatures(PathObjectTools.java:2026); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript$_run_closure1.doCall(QuPathScript:11); at QuPathScript$_run_closure1.doCall(QuPathScript); at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(Unknown Source); at java.base/java.lang.reflect.Method.invoke(Unknown Source); at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:343); at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:328);",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1591
https://github.com/qupath/qupath/issues/1591:63,Performance,Concurren,ConcurrentModificationException,63,"## Bug report. **Describe the bug**; In some circumstances, a `ConcurrentModificationException` can be thrown when working with measurement lists in parallel threads. A related issue is reported at https://github.com/qupath/qupath/pull/1466 but the proposed fix does not solve the problem here. **To Reproduce**; Try running the script below:; ```groovy; // A growing list of objects; def pathObjects = Collections.synchronizedList([]). // Number of iterations; int n = 1000. // Create a thread to continually request all measurement names; def t = new Thread( {; while (pathObjects.size() < n) {; def list = PathObjectTools.getAvailableFeatures(new ArrayList<>(pathObjects)); }; }); t.start(). // Create a parallel stream to add new objects; java.util.stream.IntStream.range(0, n); .parallel(); .forEach(i -> {; // This happens only with detections!; def pathObject = PathObjects.createDetectionObject(ROIs.createEmptyROI()); pathObjects << pathObject; for (int k = 0; k <= i; k++); pathObject.measurementList.put(""M_$k"", i); }); t.join(); ; println ""Done!""; ```. I see an exception; ```; ERROR: null; java.util.ConcurrentModificationException: null; at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); at java.base/java.util.ArrayList$Itr.next(Unknown Source); at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); at java.base/java.util.AbstractCollection.addAll(Unknown Source); at qupath.lib.objects.PathObjectTools.getAvailableFeatures(PathObjectTools.java:2026); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript$_run_closure1.doCall(QuPathScript:11); at QuPathScript$_run_closure1.doCall(QuPathScript); at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(Unknown Source); at java.base/java.lang.reflect.Method.invoke(Unknown Source); at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:343); at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:328);",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1591
https://github.com/qupath/qupath/issues/1591:1113,Performance,Concurren,ConcurrentModificationException,1113,"ent lists in parallel threads. A related issue is reported at https://github.com/qupath/qupath/pull/1466 but the proposed fix does not solve the problem here. **To Reproduce**; Try running the script below:; ```groovy; // A growing list of objects; def pathObjects = Collections.synchronizedList([]). // Number of iterations; int n = 1000. // Create a thread to continually request all measurement names; def t = new Thread( {; while (pathObjects.size() < n) {; def list = PathObjectTools.getAvailableFeatures(new ArrayList<>(pathObjects)); }; }); t.start(). // Create a parallel stream to add new objects; java.util.stream.IntStream.range(0, n); .parallel(); .forEach(i -> {; // This happens only with detections!; def pathObject = PathObjects.createDetectionObject(ROIs.createEmptyROI()); pathObjects << pathObject; for (int k = 0; k <= i; k++); pathObject.measurementList.put(""M_$k"", i); }); t.join(); ; println ""Done!""; ```. I see an exception; ```; ERROR: null; java.util.ConcurrentModificationException: null; at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); at java.base/java.util.ArrayList$Itr.next(Unknown Source); at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); at java.base/java.util.AbstractCollection.addAll(Unknown Source); at qupath.lib.objects.PathObjectTools.getAvailableFeatures(PathObjectTools.java:2026); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript$_run_closure1.doCall(QuPathScript:11); at QuPathScript$_run_closure1.doCall(QuPathScript); at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(Unknown Source); at java.base/java.lang.reflect.Method.invoke(Unknown Source); at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:343); at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:328); at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:279); at groovy.lang.MetaClassImpl.invokeM",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1591
https://github.com/qupath/qupath/issues/1591:1895,Performance,Cache,CachedMethod,1895,"t(ROIs.createEmptyROI()); pathObjects << pathObject; for (int k = 0; k <= i; k++); pathObject.measurementList.put(""M_$k"", i); }); t.join(); ; println ""Done!""; ```. I see an exception; ```; ERROR: null; java.util.ConcurrentModificationException: null; at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); at java.base/java.util.ArrayList$Itr.next(Unknown Source); at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); at java.base/java.util.AbstractCollection.addAll(Unknown Source); at qupath.lib.objects.PathObjectTools.getAvailableFeatures(PathObjectTools.java:2026); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript$_run_closure1.doCall(QuPathScript:11); at QuPathScript$_run_closure1.doCall(QuPathScript); at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(Unknown Source); at java.base/java.lang.reflect.Method.invoke(Unknown Source); at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:343); at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:328); at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:279); at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1008); at groovy.lang.Closure.call(Closure.java:433); at groovy.lang.Closure.call(Closure.java:412); at groovy.lang.Closure.run(Closure.java:505); at java.base/java.lang.Thread.run(Unknown Source); ```. **Expected behavior**; The code runs without any exception. **Desktop (please complete the following information):**; - OS: macOS (but probably all); - QuPath Version: v0.5.1. **Additional context**; This seems to only occur with detections. The underlying issue in this specific case seems to be that these can return an unmodifiable list of measurement names, but when this is used by `PathObjectTools.getAvailableFeatures(Collection)` the underlying list is being modified. A fix may require revising `MeasurementList` more thoroughly",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1591
https://github.com/qupath/qupath/issues/1591:1915,Performance,Cache,CachedMethod,1915,"yROI()); pathObjects << pathObject; for (int k = 0; k <= i; k++); pathObject.measurementList.put(""M_$k"", i); }); t.join(); ; println ""Done!""; ```. I see an exception; ```; ERROR: null; java.util.ConcurrentModificationException: null; at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); at java.base/java.util.ArrayList$Itr.next(Unknown Source); at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); at java.base/java.util.AbstractCollection.addAll(Unknown Source); at qupath.lib.objects.PathObjectTools.getAvailableFeatures(PathObjectTools.java:2026); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript$_run_closure1.doCall(QuPathScript:11); at QuPathScript$_run_closure1.doCall(QuPathScript); at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(Unknown Source); at java.base/java.lang.reflect.Method.invoke(Unknown Source); at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:343); at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:328); at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:279); at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1008); at groovy.lang.Closure.call(Closure.java:433); at groovy.lang.Closure.call(Closure.java:412); at groovy.lang.Closure.run(Closure.java:505); at java.base/java.lang.Thread.run(Unknown Source); ```. **Expected behavior**; The code runs without any exception. **Desktop (please complete the following information):**; - OS: macOS (but probably all); - QuPath Version: v0.5.1. **Additional context**; This seems to only occur with detections. The underlying issue in this specific case seems to be that these can return an unmodifiable list of measurement names, but when this is used by `PathObjectTools.getAvailableFeatures(Collection)` the underlying list is being modified. A fix may require revising `MeasurementList` more thoroughly to improve its ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1591
https://github.com/qupath/qupath/issues/1591:839,Safety,detect,detections,839,"## Bug report. **Describe the bug**; In some circumstances, a `ConcurrentModificationException` can be thrown when working with measurement lists in parallel threads. A related issue is reported at https://github.com/qupath/qupath/pull/1466 but the proposed fix does not solve the problem here. **To Reproduce**; Try running the script below:; ```groovy; // A growing list of objects; def pathObjects = Collections.synchronizedList([]). // Number of iterations; int n = 1000. // Create a thread to continually request all measurement names; def t = new Thread( {; while (pathObjects.size() < n) {; def list = PathObjectTools.getAvailableFeatures(new ArrayList<>(pathObjects)); }; }); t.start(). // Create a parallel stream to add new objects; java.util.stream.IntStream.range(0, n); .parallel(); .forEach(i -> {; // This happens only with detections!; def pathObject = PathObjects.createDetectionObject(ROIs.createEmptyROI()); pathObjects << pathObject; for (int k = 0; k <= i; k++); pathObject.measurementList.put(""M_$k"", i); }); t.join(); ; println ""Done!""; ```. I see an exception; ```; ERROR: null; java.util.ConcurrentModificationException: null; at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); at java.base/java.util.ArrayList$Itr.next(Unknown Source); at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); at java.base/java.util.AbstractCollection.addAll(Unknown Source); at qupath.lib.objects.PathObjectTools.getAvailableFeatures(PathObjectTools.java:2026); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript$_run_closure1.doCall(QuPathScript:11); at QuPathScript$_run_closure1.doCall(QuPathScript); at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(Unknown Source); at java.base/java.lang.reflect.Method.invoke(Unknown Source); at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:343); at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:328);",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1591
https://github.com/qupath/qupath/issues/1591:2595,Safety,detect,detections,2595,"on: null; at java.base/java.util.ArrayList$Itr.checkForComodification(Unknown Source); at java.base/java.util.ArrayList$Itr.next(Unknown Source); at java.base/java.util.Collections$UnmodifiableCollection$1.next(Unknown Source); at java.base/java.util.AbstractCollection.addAll(Unknown Source); at qupath.lib.objects.PathObjectTools.getAvailableFeatures(PathObjectTools.java:2026); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript$_run_closure1.doCall(QuPathScript:11); at QuPathScript$_run_closure1.doCall(QuPathScript); at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(Unknown Source); at java.base/java.lang.reflect.Method.invoke(Unknown Source); at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:343); at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:328); at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:279); at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1008); at groovy.lang.Closure.call(Closure.java:433); at groovy.lang.Closure.call(Closure.java:412); at groovy.lang.Closure.run(Closure.java:505); at java.base/java.lang.Thread.run(Unknown Source); ```. **Expected behavior**; The code runs without any exception. **Desktop (please complete the following information):**; - OS: macOS (but probably all); - QuPath Version: v0.5.1. **Additional context**; This seems to only occur with detections. The underlying issue in this specific case seems to be that these can return an unmodifiable list of measurement names, but when this is used by `PathObjectTools.getAvailableFeatures(Collection)` the underlying list is being modified. A fix may require revising `MeasurementList` more thoroughly to improve its robustness. > Edit: The original 'failing' script I posted here was failing because `pathObjects` was being modified... the version after I ended the issue fails in the 'right' place to show the issue I was trying to report.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1591
https://github.com/qupath/qupath/pull/1592:353,Availability,robust,robustness,353,"Relates to; * https://github.com/qupath/qupath/issues/1444; * https://github.com/qupath/qupath/issues/1591 . and incorporates synchronization from; * https://github.com/qupath/qupath/pull/1466. ---. This substantially updates the `MeasurementList` API, while avoiding any serialization-breaking changes.; It also adds many new tests to help improve the robustness of both the `MeasurementList` directly and any associated `Map` view. Methods that were deprecated since v0.4.0 have now been removed, and there are 2 more deprecations.; The replacement methods have shorter names and should have reliable performance.; `MeasurementList` implementations should also now be threadsafe (if they prove not to be, please report a bug). Several other key changes:; * `getNames()` (previously `getMeasurementNames()`) returns a defensive copy of the measurement. Before, it would sometimes return an unmodifiable list that wrapped a list that could still change - and that was sometimes responsible for #1444 and #1591; * `List<Measurement> getMeasurements()` and `Measurement getByIndex(int)` now provide ways to access a snapshot of one or more measurements. Previously, `getMeasurementName(int)` and `getMeasurementValue(int)` were used - but when requesting these sequentially, there was no way to guarantee that the values were properly in sync.; * `String.intern()` is now used with all `MeasurementList` implementations. Previously, it was only used for the 'general' list used for annotations. It wasn't important if other lists were closed, but if they weren't then we could end up with huge numbers of duplicate strings greatly increasing memory use. In general, the goal of `MeasurementList` is to optimize mostly for memory use and good behavior.; Updating and querying measurements is generally rare enough that small computational costs (e.g. synchronization, defensive copying) shouldn't matter a great deal - but if we are to cope with millions of objects having hundreds of measurements each, ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1592
https://github.com/qupath/qupath/pull/1592:594,Availability,reliab,reliable,594,"Relates to; * https://github.com/qupath/qupath/issues/1444; * https://github.com/qupath/qupath/issues/1591 . and incorporates synchronization from; * https://github.com/qupath/qupath/pull/1466. ---. This substantially updates the `MeasurementList` API, while avoiding any serialization-breaking changes.; It also adds many new tests to help improve the robustness of both the `MeasurementList` directly and any associated `Map` view. Methods that were deprecated since v0.4.0 have now been removed, and there are 2 more deprecations.; The replacement methods have shorter names and should have reliable performance.; `MeasurementList` implementations should also now be threadsafe (if they prove not to be, please report a bug). Several other key changes:; * `getNames()` (previously `getMeasurementNames()`) returns a defensive copy of the measurement. Before, it would sometimes return an unmodifiable list that wrapped a list that could still change - and that was sometimes responsible for #1444 and #1591; * `List<Measurement> getMeasurements()` and `Measurement getByIndex(int)` now provide ways to access a snapshot of one or more measurements. Previously, `getMeasurementName(int)` and `getMeasurementValue(int)` were used - but when requesting these sequentially, there was no way to guarantee that the values were properly in sync.; * `String.intern()` is now used with all `MeasurementList` implementations. Previously, it was only used for the 'general' list used for annotations. It wasn't important if other lists were closed, but if they weren't then we could end up with huge numbers of duplicate strings greatly increasing memory use. In general, the goal of `MeasurementList` is to optimize mostly for memory use and good behavior.; Updating and querying measurements is generally rare enough that small computational costs (e.g. synchronization, defensive copying) shouldn't matter a great deal - but if we are to cope with millions of objects having hundreds of measurements each, ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1592
https://github.com/qupath/qupath/pull/1592:218,Deployability,update,updates,218,"Relates to; * https://github.com/qupath/qupath/issues/1444; * https://github.com/qupath/qupath/issues/1591 . and incorporates synchronization from; * https://github.com/qupath/qupath/pull/1466. ---. This substantially updates the `MeasurementList` API, while avoiding any serialization-breaking changes.; It also adds many new tests to help improve the robustness of both the `MeasurementList` directly and any associated `Map` view. Methods that were deprecated since v0.4.0 have now been removed, and there are 2 more deprecations.; The replacement methods have shorter names and should have reliable performance.; `MeasurementList` implementations should also now be threadsafe (if they prove not to be, please report a bug). Several other key changes:; * `getNames()` (previously `getMeasurementNames()`) returns a defensive copy of the measurement. Before, it would sometimes return an unmodifiable list that wrapped a list that could still change - and that was sometimes responsible for #1444 and #1591; * `List<Measurement> getMeasurements()` and `Measurement getByIndex(int)` now provide ways to access a snapshot of one or more measurements. Previously, `getMeasurementName(int)` and `getMeasurementValue(int)` were used - but when requesting these sequentially, there was no way to guarantee that the values were properly in sync.; * `String.intern()` is now used with all `MeasurementList` implementations. Previously, it was only used for the 'general' list used for annotations. It wasn't important if other lists were closed, but if they weren't then we could end up with huge numbers of duplicate strings greatly increasing memory use. In general, the goal of `MeasurementList` is to optimize mostly for memory use and good behavior.; Updating and querying measurements is generally rare enough that small computational costs (e.g. synchronization, defensive copying) shouldn't matter a great deal - but if we are to cope with millions of objects having hundreds of measurements each, ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1592
https://github.com/qupath/qupath/pull/1592:126,Integrability,synchroniz,synchronization,126,"Relates to; * https://github.com/qupath/qupath/issues/1444; * https://github.com/qupath/qupath/issues/1591 . and incorporates synchronization from; * https://github.com/qupath/qupath/pull/1466. ---. This substantially updates the `MeasurementList` API, while avoiding any serialization-breaking changes.; It also adds many new tests to help improve the robustness of both the `MeasurementList` directly and any associated `Map` view. Methods that were deprecated since v0.4.0 have now been removed, and there are 2 more deprecations.; The replacement methods have shorter names and should have reliable performance.; `MeasurementList` implementations should also now be threadsafe (if they prove not to be, please report a bug). Several other key changes:; * `getNames()` (previously `getMeasurementNames()`) returns a defensive copy of the measurement. Before, it would sometimes return an unmodifiable list that wrapped a list that could still change - and that was sometimes responsible for #1444 and #1591; * `List<Measurement> getMeasurements()` and `Measurement getByIndex(int)` now provide ways to access a snapshot of one or more measurements. Previously, `getMeasurementName(int)` and `getMeasurementValue(int)` were used - but when requesting these sequentially, there was no way to guarantee that the values were properly in sync.; * `String.intern()` is now used with all `MeasurementList` implementations. Previously, it was only used for the 'general' list used for annotations. It wasn't important if other lists were closed, but if they weren't then we could end up with huge numbers of duplicate strings greatly increasing memory use. In general, the goal of `MeasurementList` is to optimize mostly for memory use and good behavior.; Updating and querying measurements is generally rare enough that small computational costs (e.g. synchronization, defensive copying) shouldn't matter a great deal - but if we are to cope with millions of objects having hundreds of measurements each, ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1592
https://github.com/qupath/qupath/pull/1592:914,Integrability,wrap,wrapped,914,"lates to; * https://github.com/qupath/qupath/issues/1444; * https://github.com/qupath/qupath/issues/1591 . and incorporates synchronization from; * https://github.com/qupath/qupath/pull/1466. ---. This substantially updates the `MeasurementList` API, while avoiding any serialization-breaking changes.; It also adds many new tests to help improve the robustness of both the `MeasurementList` directly and any associated `Map` view. Methods that were deprecated since v0.4.0 have now been removed, and there are 2 more deprecations.; The replacement methods have shorter names and should have reliable performance.; `MeasurementList` implementations should also now be threadsafe (if they prove not to be, please report a bug). Several other key changes:; * `getNames()` (previously `getMeasurementNames()`) returns a defensive copy of the measurement. Before, it would sometimes return an unmodifiable list that wrapped a list that could still change - and that was sometimes responsible for #1444 and #1591; * `List<Measurement> getMeasurements()` and `Measurement getByIndex(int)` now provide ways to access a snapshot of one or more measurements. Previously, `getMeasurementName(int)` and `getMeasurementValue(int)` were used - but when requesting these sequentially, there was no way to guarantee that the values were properly in sync.; * `String.intern()` is now used with all `MeasurementList` implementations. Previously, it was only used for the 'general' list used for annotations. It wasn't important if other lists were closed, but if they weren't then we could end up with huge numbers of duplicate strings greatly increasing memory use. In general, the goal of `MeasurementList` is to optimize mostly for memory use and good behavior.; Updating and querying measurements is generally rare enough that small computational costs (e.g. synchronization, defensive copying) shouldn't matter a great deal - but if we are to cope with millions of objects having hundreds of measurements each, w",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1592
https://github.com/qupath/qupath/pull/1592:1848,Integrability,synchroniz,synchronization,1848,"h/qupath/issues/1444; * https://github.com/qupath/qupath/issues/1591 . and incorporates synchronization from; * https://github.com/qupath/qupath/pull/1466. ---. This substantially updates the `MeasurementList` API, while avoiding any serialization-breaking changes.; It also adds many new tests to help improve the robustness of both the `MeasurementList` directly and any associated `Map` view. Methods that were deprecated since v0.4.0 have now been removed, and there are 2 more deprecations.; The replacement methods have shorter names and should have reliable performance.; `MeasurementList` implementations should also now be threadsafe (if they prove not to be, please report a bug). Several other key changes:; * `getNames()` (previously `getMeasurementNames()`) returns a defensive copy of the measurement. Before, it would sometimes return an unmodifiable list that wrapped a list that could still change - and that was sometimes responsible for #1444 and #1591; * `List<Measurement> getMeasurements()` and `Measurement getByIndex(int)` now provide ways to access a snapshot of one or more measurements. Previously, `getMeasurementName(int)` and `getMeasurementValue(int)` were used - but when requesting these sequentially, there was no way to guarantee that the values were properly in sync.; * `String.intern()` is now used with all `MeasurementList` implementations. Previously, it was only used for the 'general' list used for annotations. It wasn't important if other lists were closed, but if they weren't then we could end up with huge numbers of duplicate strings greatly increasing memory use. In general, the goal of `MeasurementList` is to optimize mostly for memory use and good behavior.; Updating and querying measurements is generally rare enough that small computational costs (e.g. synchronization, defensive copying) shouldn't matter a great deal - but if we are to cope with millions of objects having hundreds of measurements each, we need to keep memory under control.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1592
https://github.com/qupath/qupath/pull/1592:603,Performance,perform,performance,603,"Relates to; * https://github.com/qupath/qupath/issues/1444; * https://github.com/qupath/qupath/issues/1591 . and incorporates synchronization from; * https://github.com/qupath/qupath/pull/1466. ---. This substantially updates the `MeasurementList` API, while avoiding any serialization-breaking changes.; It also adds many new tests to help improve the robustness of both the `MeasurementList` directly and any associated `Map` view. Methods that were deprecated since v0.4.0 have now been removed, and there are 2 more deprecations.; The replacement methods have shorter names and should have reliable performance.; `MeasurementList` implementations should also now be threadsafe (if they prove not to be, please report a bug). Several other key changes:; * `getNames()` (previously `getMeasurementNames()`) returns a defensive copy of the measurement. Before, it would sometimes return an unmodifiable list that wrapped a list that could still change - and that was sometimes responsible for #1444 and #1591; * `List<Measurement> getMeasurements()` and `Measurement getByIndex(int)` now provide ways to access a snapshot of one or more measurements. Previously, `getMeasurementName(int)` and `getMeasurementValue(int)` were used - but when requesting these sequentially, there was no way to guarantee that the values were properly in sync.; * `String.intern()` is now used with all `MeasurementList` implementations. Previously, it was only used for the 'general' list used for annotations. It wasn't important if other lists were closed, but if they weren't then we could end up with huge numbers of duplicate strings greatly increasing memory use. In general, the goal of `MeasurementList` is to optimize mostly for memory use and good behavior.; Updating and querying measurements is generally rare enough that small computational costs (e.g. synchronization, defensive copying) shouldn't matter a great deal - but if we are to cope with millions of objects having hundreds of measurements each, ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1592
https://github.com/qupath/qupath/pull/1592:1700,Performance,optimiz,optimize,1700,"h/qupath/issues/1444; * https://github.com/qupath/qupath/issues/1591 . and incorporates synchronization from; * https://github.com/qupath/qupath/pull/1466. ---. This substantially updates the `MeasurementList` API, while avoiding any serialization-breaking changes.; It also adds many new tests to help improve the robustness of both the `MeasurementList` directly and any associated `Map` view. Methods that were deprecated since v0.4.0 have now been removed, and there are 2 more deprecations.; The replacement methods have shorter names and should have reliable performance.; `MeasurementList` implementations should also now be threadsafe (if they prove not to be, please report a bug). Several other key changes:; * `getNames()` (previously `getMeasurementNames()`) returns a defensive copy of the measurement. Before, it would sometimes return an unmodifiable list that wrapped a list that could still change - and that was sometimes responsible for #1444 and #1591; * `List<Measurement> getMeasurements()` and `Measurement getByIndex(int)` now provide ways to access a snapshot of one or more measurements. Previously, `getMeasurementName(int)` and `getMeasurementValue(int)` were used - but when requesting these sequentially, there was no way to guarantee that the values were properly in sync.; * `String.intern()` is now used with all `MeasurementList` implementations. Previously, it was only used for the 'general' list used for annotations. It wasn't important if other lists were closed, but if they weren't then we could end up with huge numbers of duplicate strings greatly increasing memory use. In general, the goal of `MeasurementList` is to optimize mostly for memory use and good behavior.; Updating and querying measurements is generally rare enough that small computational costs (e.g. synchronization, defensive copying) shouldn't matter a great deal - but if we are to cope with millions of objects having hundreds of measurements each, we need to keep memory under control.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1592
https://github.com/qupath/qupath/pull/1592:259,Safety,avoid,avoiding,259,"Relates to; * https://github.com/qupath/qupath/issues/1444; * https://github.com/qupath/qupath/issues/1591 . and incorporates synchronization from; * https://github.com/qupath/qupath/pull/1466. ---. This substantially updates the `MeasurementList` API, while avoiding any serialization-breaking changes.; It also adds many new tests to help improve the robustness of both the `MeasurementList` directly and any associated `Map` view. Methods that were deprecated since v0.4.0 have now been removed, and there are 2 more deprecations.; The replacement methods have shorter names and should have reliable performance.; `MeasurementList` implementations should also now be threadsafe (if they prove not to be, please report a bug). Several other key changes:; * `getNames()` (previously `getMeasurementNames()`) returns a defensive copy of the measurement. Before, it would sometimes return an unmodifiable list that wrapped a list that could still change - and that was sometimes responsible for #1444 and #1591; * `List<Measurement> getMeasurements()` and `Measurement getByIndex(int)` now provide ways to access a snapshot of one or more measurements. Previously, `getMeasurementName(int)` and `getMeasurementValue(int)` were used - but when requesting these sequentially, there was no way to guarantee that the values were properly in sync.; * `String.intern()` is now used with all `MeasurementList` implementations. Previously, it was only used for the 'general' list used for annotations. It wasn't important if other lists were closed, but if they weren't then we could end up with huge numbers of duplicate strings greatly increasing memory use. In general, the goal of `MeasurementList` is to optimize mostly for memory use and good behavior.; Updating and querying measurements is generally rare enough that small computational costs (e.g. synchronization, defensive copying) shouldn't matter a great deal - but if we are to cope with millions of objects having hundreds of measurements each, ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1592
https://github.com/qupath/qupath/pull/1592:1105,Security,access,access,1105,"lates to; * https://github.com/qupath/qupath/issues/1444; * https://github.com/qupath/qupath/issues/1591 . and incorporates synchronization from; * https://github.com/qupath/qupath/pull/1466. ---. This substantially updates the `MeasurementList` API, while avoiding any serialization-breaking changes.; It also adds many new tests to help improve the robustness of both the `MeasurementList` directly and any associated `Map` view. Methods that were deprecated since v0.4.0 have now been removed, and there are 2 more deprecations.; The replacement methods have shorter names and should have reliable performance.; `MeasurementList` implementations should also now be threadsafe (if they prove not to be, please report a bug). Several other key changes:; * `getNames()` (previously `getMeasurementNames()`) returns a defensive copy of the measurement. Before, it would sometimes return an unmodifiable list that wrapped a list that could still change - and that was sometimes responsible for #1444 and #1591; * `List<Measurement> getMeasurements()` and `Measurement getByIndex(int)` now provide ways to access a snapshot of one or more measurements. Previously, `getMeasurementName(int)` and `getMeasurementValue(int)` were used - but when requesting these sequentially, there was no way to guarantee that the values were properly in sync.; * `String.intern()` is now used with all `MeasurementList` implementations. Previously, it was only used for the 'general' list used for annotations. It wasn't important if other lists were closed, but if they weren't then we could end up with huge numbers of duplicate strings greatly increasing memory use. In general, the goal of `MeasurementList` is to optimize mostly for memory use and good behavior.; Updating and querying measurements is generally rare enough that small computational costs (e.g. synchronization, defensive copying) shouldn't matter a great deal - but if we are to cope with millions of objects having hundreds of measurements each, w",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1592
https://github.com/qupath/qupath/pull/1592:327,Testability,test,tests,327,"Relates to; * https://github.com/qupath/qupath/issues/1444; * https://github.com/qupath/qupath/issues/1591 . and incorporates synchronization from; * https://github.com/qupath/qupath/pull/1466. ---. This substantially updates the `MeasurementList` API, while avoiding any serialization-breaking changes.; It also adds many new tests to help improve the robustness of both the `MeasurementList` directly and any associated `Map` view. Methods that were deprecated since v0.4.0 have now been removed, and there are 2 more deprecations.; The replacement methods have shorter names and should have reliable performance.; `MeasurementList` implementations should also now be threadsafe (if they prove not to be, please report a bug). Several other key changes:; * `getNames()` (previously `getMeasurementNames()`) returns a defensive copy of the measurement. Before, it would sometimes return an unmodifiable list that wrapped a list that could still change - and that was sometimes responsible for #1444 and #1591; * `List<Measurement> getMeasurements()` and `Measurement getByIndex(int)` now provide ways to access a snapshot of one or more measurements. Previously, `getMeasurementName(int)` and `getMeasurementValue(int)` were used - but when requesting these sequentially, there was no way to guarantee that the values were properly in sync.; * `String.intern()` is now used with all `MeasurementList` implementations. Previously, it was only used for the 'general' list used for annotations. It wasn't important if other lists were closed, but if they weren't then we could end up with huge numbers of duplicate strings greatly increasing memory use. In general, the goal of `MeasurementList` is to optimize mostly for memory use and good behavior.; Updating and querying measurements is generally rare enough that small computational costs (e.g. synchronization, defensive copying) shouldn't matter a great deal - but if we are to cope with millions of objects having hundreds of measurements each, ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1592
https://github.com/qupath/qupath/pull/1593:2252,Energy Efficiency,power,powerful,2252,"t part of the classification, but *not* the color; this is intended for cases when you'd really like to have *multiple* classifications, and what to treat the 'derived' parts of a classification as if they are basically separate classifications (e.g. `CD3: CD8`). In Groovy, checking if a cell has the derived classification ""Tumor: Positive"", and setting it to ""Tumor: Negative"" if not, would look like this:; ```groovy; // Original Java way (used in QuPath for all of the early years); if (pathObject.getPathClass() != getPathClass(""Tumor: Positive"")) {; pathObject.setPathClass(getPathClass(""Tumor: Negative"")); }. // Using Groovy's way to avoid get/set; if (pathObject.pathClass != getPathClass(""Tumor: Positive"")) {; pathObject.pathClass = getPathClass(""Tumor: Negative""); }. // With strings; if (pathObject.classification != ""Tumor: Positive"") {; pathObject.classification = ""Tumor: Negative""; }. // With classifications; if (pathObject.classifications != [""Tumor: Positive""] as Set) {; pathObject.classifications = [""Tumor"", ""Negative""]; }; ```; I think the working with string is a bit less cumbersome and confusing than needing to add lots of `getPathClass()` lines. But it is more powerful with tricks like this. ```groovy; // Set all cells to be classified as 'Tumor'; getCellObjects().each {it.classification = 'Tumor'}. // And 'Negative' as a (sub?) classification to all cells; getCellObjects().each {it.classifications += 'Negative'}. // Remove 'Negative' as a (sub?) classification from all cells; getCellObjects().each {it.classifications -= 'Negative'}. // Select all the objects classification *exactly* as tumor; selectObjects {it.classification == 'Tumor'}. // Select all the objects with 'Tumor' *somewhere* in their classification; selectObjects {'Tumor' in it.classifications}; ```. The fact that `classification` and `classifications` differ by only a letter might be a bit confusing, but getting it wrong should throw an exception.... so hopefully the benefits are worth it.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1593
https://github.com/qupath/qupath/pull/1593:1704,Safety,avoid,avoid,1704,"ut the classification: the different pieces (e.g. subclassifications) and the color; this is used internally; 2. The 'classification' is simply a `String` representation of the `PathClass`; it can represent the key pieces (with a colon delimiter for subclassifications), but *not* the color; 3. The 'classifications' are a set that represents the different part of the classification, but *not* the color; this is intended for cases when you'd really like to have *multiple* classifications, and what to treat the 'derived' parts of a classification as if they are basically separate classifications (e.g. `CD3: CD8`). In Groovy, checking if a cell has the derived classification ""Tumor: Positive"", and setting it to ""Tumor: Negative"" if not, would look like this:; ```groovy; // Original Java way (used in QuPath for all of the early years); if (pathObject.getPathClass() != getPathClass(""Tumor: Positive"")) {; pathObject.setPathClass(getPathClass(""Tumor: Negative"")); }. // Using Groovy's way to avoid get/set; if (pathObject.pathClass != getPathClass(""Tumor: Positive"")) {; pathObject.pathClass = getPathClass(""Tumor: Negative""); }. // With strings; if (pathObject.classification != ""Tumor: Positive"") {; pathObject.classification = ""Tumor: Negative""; }. // With classifications; if (pathObject.classifications != [""Tumor: Positive""] as Set) {; pathObject.classifications = [""Tumor"", ""Negative""]; }; ```; I think the working with string is a bit less cumbersome and confusing than needing to add lots of `getPathClass()` lines. But it is more powerful with tricks like this. ```groovy; // Set all cells to be classified as 'Tumor'; getCellObjects().each {it.classification = 'Tumor'}. // And 'Negative' as a (sub?) classification to all cells; getCellObjects().each {it.classifications += 'Negative'}. // Remove 'Negative' as a (sub?) classification from all cells; getCellObjects().each {it.classifications -= 'Negative'}. // Select all the objects classification *exactly* as tumor; selectObject",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1593
https://github.com/qupath/qupath/pull/1593:603,Usability,intuit,intuitive,603,"This PR removes some methods from `PathObject` that were previously deprecated. It also introduces; ```java; public void setClassification(String classification); public String getClassification(); ```; which now exist alongside the earlier methods; ```java; // The originals; public void setPathClass(PathClass pathClass); public PathClass getPathClass(). // New in v0.4.0; public void setClassifications(Collection<String> classifications); public Set<String> getClassifications(); ```. Having 3 different ways to set/get classifications may seem a bit much, but the intention is to make scripting as intuitive as possible. Each method has a different purpose:; 1. `PathClass` encapsulates everything about the classification: the different pieces (e.g. subclassifications) and the color; this is used internally; 2. The 'classification' is simply a `String` representation of the `PathClass`; it can represent the key pieces (with a colon delimiter for subclassifications), but *not* the color; 3. The 'classifications' are a set that represents the different part of the classification, but *not* the color; this is intended for cases when you'd really like to have *multiple* classifications, and what to treat the 'derived' parts of a classification as if they are basically separate classifications (e.g. `CD3: CD8`). In Groovy, checking if a cell has the derived classification ""Tumor: Positive"", and setting it to ""Tumor: Negative"" if not, would look like this:; ```groovy; // Original Java way (used in QuPath for all of the early years); if (pathObject.getPathClass() != getPathClass(""Tumor: Positive"")) {; pathObject.setPathClass(getPathClass(""Tumor: Negative"")); }. // Using Groovy's way to avoid get/set; if (pathObject.pathClass != getPathClass(""Tumor: Positive"")) {; pathObject.pathClass = getPathClass(""Tumor: Negative""); }. // With strings; if (pathObject.classification != ""Tumor: Positive"") {; pathObject.classification = ""Tumor: Negative""; }. // With classifications; if (pathObje",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1593
https://github.com/qupath/qupath/pull/1593:843,Usability,simpl,simply,843,"This PR removes some methods from `PathObject` that were previously deprecated. It also introduces; ```java; public void setClassification(String classification); public String getClassification(); ```; which now exist alongside the earlier methods; ```java; // The originals; public void setPathClass(PathClass pathClass); public PathClass getPathClass(). // New in v0.4.0; public void setClassifications(Collection<String> classifications); public Set<String> getClassifications(); ```. Having 3 different ways to set/get classifications may seem a bit much, but the intention is to make scripting as intuitive as possible. Each method has a different purpose:; 1. `PathClass` encapsulates everything about the classification: the different pieces (e.g. subclassifications) and the color; this is used internally; 2. The 'classification' is simply a `String` representation of the `PathClass`; it can represent the key pieces (with a colon delimiter for subclassifications), but *not* the color; 3. The 'classifications' are a set that represents the different part of the classification, but *not* the color; this is intended for cases when you'd really like to have *multiple* classifications, and what to treat the 'derived' parts of a classification as if they are basically separate classifications (e.g. `CD3: CD8`). In Groovy, checking if a cell has the derived classification ""Tumor: Positive"", and setting it to ""Tumor: Negative"" if not, would look like this:; ```groovy; // Original Java way (used in QuPath for all of the early years); if (pathObject.getPathClass() != getPathClass(""Tumor: Positive"")) {; pathObject.setPathClass(getPathClass(""Tumor: Negative"")); }. // Using Groovy's way to avoid get/set; if (pathObject.pathClass != getPathClass(""Tumor: Positive"")) {; pathObject.pathClass = getPathClass(""Tumor: Negative""); }. // With strings; if (pathObject.classification != ""Tumor: Positive"") {; pathObject.classification = ""Tumor: Negative""; }. // With classifications; if (pathObje",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1593
https://github.com/qupath/qupath/pull/1597:2931,Modifiability,plugin,plugin-derived,2931," -> c.parent == cell.parent}; ```. ## Assumptions & limitations. In this current (draft) form, there are some assumptions:; * The triangulation involves all objects with the exact same Java class (e.g. `PathDetectionObject`, `PathCellObject`, `PathTileObject`, `PathAnnotationObject`); * There is nothing to prevent connections being made *across parent objects*. So if there were disconnected pieces of tissue - or even TMA cores - neighbors would still be found across these.; * Everything is done in 2D (this is all JTS's Delaunay triangulation supports anyway); * All measurements are in pixel units, *and pixels are assumed to be square*. The last of these is because the calculations are done within `PathObjectHierarchy`, which has no access to the `PixelCalibration` object that stores pixel sizes. We could move this into `ImageData` so that pixel calibration could be accessed, but it feels to me less intuitive to have it there. I'm not sure if this could become problematic at some point though, so the PR is flagged as a draft - subject to more development & discussion. ## Possible improvements. Potential developments to consider:; * Prevent connections being made across TMA cores; * Use annotation boundaries, not centroids; * What should happen with points annotations...?; * Introduce other spatial querying to `PathObjectHierarchy` (e.g. find the closest object meeting specific criteria); * Enable a Delaunay overlay using these computations, rather than the existing (awkward, buggy-plugin-derived) strategy. ## Alternative. `DelaunayTools` can already be used to create a `Subdivision`, and this used to get all the same info - and that *does* provide a way to incorporate `PixelCalibration`, and introduce more criteria to get more exactly. So the main decision is whether it is worthwhile having a simple version of Delaunay triangulation built-in to the `PathObjectHierarchy` to make it very easy to use for common cases... or whether it just complicates the class too much.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1597
https://github.com/qupath/qupath/pull/1597:2168,Security,access,access,2168,"unay command is rather buggy https://github.com/qupath/qupath/issues/1590 this could give a convenient alternative. If we need tests such as ensuring the same parent object then this can be implemented, e.g.; ```; def sharedParent = hierarchy.findAllNeighbors(cell).findAll {c -> c.parent == cell.parent}; ```. ## Assumptions & limitations. In this current (draft) form, there are some assumptions:; * The triangulation involves all objects with the exact same Java class (e.g. `PathDetectionObject`, `PathCellObject`, `PathTileObject`, `PathAnnotationObject`); * There is nothing to prevent connections being made *across parent objects*. So if there were disconnected pieces of tissue - or even TMA cores - neighbors would still be found across these.; * Everything is done in 2D (this is all JTS's Delaunay triangulation supports anyway); * All measurements are in pixel units, *and pixels are assumed to be square*. The last of these is because the calculations are done within `PathObjectHierarchy`, which has no access to the `PixelCalibration` object that stores pixel sizes. We could move this into `ImageData` so that pixel calibration could be accessed, but it feels to me less intuitive to have it there. I'm not sure if this could become problematic at some point though, so the PR is flagged as a draft - subject to more development & discussion. ## Possible improvements. Potential developments to consider:; * Prevent connections being made across TMA cores; * Use annotation boundaries, not centroids; * What should happen with points annotations...?; * Introduce other spatial querying to `PathObjectHierarchy` (e.g. find the closest object meeting specific criteria); * Enable a Delaunay overlay using these computations, rather than the existing (awkward, buggy-plugin-derived) strategy. ## Alternative. `DelaunayTools` can already be used to create a `Subdivision`, and this used to get all the same info - and that *does* provide a way to incorporate `PixelCalibration`, and intro",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1597
https://github.com/qupath/qupath/pull/1597:2304,Security,access,accessed,2304,"g the same parent object then this can be implemented, e.g.; ```; def sharedParent = hierarchy.findAllNeighbors(cell).findAll {c -> c.parent == cell.parent}; ```. ## Assumptions & limitations. In this current (draft) form, there are some assumptions:; * The triangulation involves all objects with the exact same Java class (e.g. `PathDetectionObject`, `PathCellObject`, `PathTileObject`, `PathAnnotationObject`); * There is nothing to prevent connections being made *across parent objects*. So if there were disconnected pieces of tissue - or even TMA cores - neighbors would still be found across these.; * Everything is done in 2D (this is all JTS's Delaunay triangulation supports anyway); * All measurements are in pixel units, *and pixels are assumed to be square*. The last of these is because the calculations are done within `PathObjectHierarchy`, which has no access to the `PixelCalibration` object that stores pixel sizes. We could move this into `ImageData` so that pixel calibration could be accessed, but it feels to me less intuitive to have it there. I'm not sure if this could become problematic at some point though, so the PR is flagged as a draft - subject to more development & discussion. ## Possible improvements. Potential developments to consider:; * Prevent connections being made across TMA cores; * Use annotation boundaries, not centroids; * What should happen with points annotations...?; * Introduce other spatial querying to `PathObjectHierarchy` (e.g. find the closest object meeting specific criteria); * Enable a Delaunay overlay using these computations, rather than the existing (awkward, buggy-plugin-derived) strategy. ## Alternative. `DelaunayTools` can already be used to create a `Subdivision`, and this used to get all the same info - and that *does* provide a way to incorporate `PixelCalibration`, and introduce more criteria to get more exactly. So the main decision is whether it is worthwhile having a simple version of Delaunay triangulation built-in ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1597
https://github.com/qupath/qupath/pull/1597:1277,Testability,test,tests,1277,". Here's an example script that counts the number of neighbors, and adds it as a measurement to each object:; ```groovy; def hierarchy = getCurrentHierarchy(); def cells = getCellObjects(); for (cell in cells) {; cell.measurements['Num neighbors'] = hierarchy.findAllNeighbors(cell).size(); }; ```. Or this adds measurements giving counts of immediate neighbors with specific classifications:; ```groovy; def hierarchy = getCurrentHierarchy(); def cells = getCellObjects(); def allClassifications = getCellObjects().collect(c -> c.classification) as TreeSet; for (cell in cells) {; def counts = hierarchy.findAllNeighbors(cell).countBy(n -> n.classification); for (classification in allClassifications) {; cell.measurements[""Num ${classification} neighbors""] = counts.getOrDefault(classification, 0); }; }; ```. Given that the existing Delaunay command is rather buggy https://github.com/qupath/qupath/issues/1590 this could give a convenient alternative. If we need tests such as ensuring the same parent object then this can be implemented, e.g.; ```; def sharedParent = hierarchy.findAllNeighbors(cell).findAll {c -> c.parent == cell.parent}; ```. ## Assumptions & limitations. In this current (draft) form, there are some assumptions:; * The triangulation involves all objects with the exact same Java class (e.g. `PathDetectionObject`, `PathCellObject`, `PathTileObject`, `PathAnnotationObject`); * There is nothing to prevent connections being made *across parent objects*. So if there were disconnected pieces of tissue - or even TMA cores - neighbors would still be found across these.; * Everything is done in 2D (this is all JTS's Delaunay triangulation supports anyway); * All measurements are in pixel units, *and pixels are assumed to be square*. The last of these is because the calculations are done within `PathObjectHierarchy`, which has no access to the `PixelCalibration` object that stores pixel sizes. We could move this into `ImageData` so that pixel calibration could be access",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1597
https://github.com/qupath/qupath/pull/1597:2338,Usability,intuit,intuitive,2338,"g the same parent object then this can be implemented, e.g.; ```; def sharedParent = hierarchy.findAllNeighbors(cell).findAll {c -> c.parent == cell.parent}; ```. ## Assumptions & limitations. In this current (draft) form, there are some assumptions:; * The triangulation involves all objects with the exact same Java class (e.g. `PathDetectionObject`, `PathCellObject`, `PathTileObject`, `PathAnnotationObject`); * There is nothing to prevent connections being made *across parent objects*. So if there were disconnected pieces of tissue - or even TMA cores - neighbors would still be found across these.; * Everything is done in 2D (this is all JTS's Delaunay triangulation supports anyway); * All measurements are in pixel units, *and pixels are assumed to be square*. The last of these is because the calculations are done within `PathObjectHierarchy`, which has no access to the `PixelCalibration` object that stores pixel sizes. We could move this into `ImageData` so that pixel calibration could be accessed, but it feels to me less intuitive to have it there. I'm not sure if this could become problematic at some point though, so the PR is flagged as a draft - subject to more development & discussion. ## Possible improvements. Potential developments to consider:; * Prevent connections being made across TMA cores; * Use annotation boundaries, not centroids; * What should happen with points annotations...?; * Introduce other spatial querying to `PathObjectHierarchy` (e.g. find the closest object meeting specific criteria); * Enable a Delaunay overlay using these computations, rather than the existing (awkward, buggy-plugin-derived) strategy. ## Alternative. `DelaunayTools` can already be used to create a `Subdivision`, and this used to get all the same info - and that *does* provide a way to incorporate `PixelCalibration`, and introduce more criteria to get more exactly. So the main decision is whether it is worthwhile having a simple version of Delaunay triangulation built-in ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1597
https://github.com/qupath/qupath/pull/1597:3249,Usability,simpl,simple,3249," -> c.parent == cell.parent}; ```. ## Assumptions & limitations. In this current (draft) form, there are some assumptions:; * The triangulation involves all objects with the exact same Java class (e.g. `PathDetectionObject`, `PathCellObject`, `PathTileObject`, `PathAnnotationObject`); * There is nothing to prevent connections being made *across parent objects*. So if there were disconnected pieces of tissue - or even TMA cores - neighbors would still be found across these.; * Everything is done in 2D (this is all JTS's Delaunay triangulation supports anyway); * All measurements are in pixel units, *and pixels are assumed to be square*. The last of these is because the calculations are done within `PathObjectHierarchy`, which has no access to the `PixelCalibration` object that stores pixel sizes. We could move this into `ImageData` so that pixel calibration could be accessed, but it feels to me less intuitive to have it there. I'm not sure if this could become problematic at some point though, so the PR is flagged as a draft - subject to more development & discussion. ## Possible improvements. Potential developments to consider:; * Prevent connections being made across TMA cores; * Use annotation boundaries, not centroids; * What should happen with points annotations...?; * Introduce other spatial querying to `PathObjectHierarchy` (e.g. find the closest object meeting specific criteria); * Enable a Delaunay overlay using these computations, rather than the existing (awkward, buggy-plugin-derived) strategy. ## Alternative. `DelaunayTools` can already be used to create a `Subdivision`, and this used to get all the same info - and that *does* provide a way to incorporate `PixelCalibration`, and introduce more criteria to get more exactly. So the main decision is whether it is worthwhile having a simple version of Delaunay triangulation built-in to the `PathObjectHierarchy` to make it very easy to use for common cases... or whether it just complicates the class too much.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1597
https://github.com/qupath/qupath/pull/1599:43,Deployability,Update,Update,43,"Several improvements to Selection mode:; * Update icon, and switch to dashed lines for drawing tools when selection mode is turned on; * Fix the *Shift + S* shortcut (which wasn't working); * Support line ROIs with selection mode; select objects intersecting with the line. <img width=""411"" alt=""Selection mode"" src=""https://github.com/user-attachments/assets/c20c5456-ed6e-4881-b29f-08508e92e05a"">",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1599
https://github.com/qupath/qupath/pull/1600:47,Availability,down,down,47,Temporarily active 'Selection mode' by holding down the `S` key while interacting with a viewer,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1600
https://github.com/qupath/qupath/pull/1603:518,Deployability,update,updates,518,"We already default to using Java 21, but we were still building artifacts with Java 17. This meant we couldn't actually use any features from after Java 17. Things we can now use (roughly in order of relevance):; - Sequenced collections - https://openjdk.org/jeps/431; - Code snippets in Javadocs - https://openjdk.org/jeps/431; - Pattern matching for switch - https://openjdk.org/jeps/441; - Virtual threads - https://openjdk.org/jeps/444; - Record patterns - https://openjdk.org/jeps/440. Note that this may require updates in any extensions that declare v0.6.0 dependencies, to ensure they also use Java 21 (and have a suitably recent Gradle wrapper).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1603
https://github.com/qupath/qupath/pull/1603:564,Integrability,depend,dependencies,564,"We already default to using Java 21, but we were still building artifacts with Java 17. This meant we couldn't actually use any features from after Java 17. Things we can now use (roughly in order of relevance):; - Sequenced collections - https://openjdk.org/jeps/431; - Code snippets in Javadocs - https://openjdk.org/jeps/431; - Pattern matching for switch - https://openjdk.org/jeps/441; - Virtual threads - https://openjdk.org/jeps/444; - Record patterns - https://openjdk.org/jeps/440. Note that this may require updates in any extensions that declare v0.6.0 dependencies, to ensure they also use Java 21 (and have a suitably recent Gradle wrapper).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1603
https://github.com/qupath/qupath/pull/1603:645,Integrability,wrap,wrapper,645,"We already default to using Java 21, but we were still building artifacts with Java 17. This meant we couldn't actually use any features from after Java 17. Things we can now use (roughly in order of relevance):; - Sequenced collections - https://openjdk.org/jeps/431; - Code snippets in Javadocs - https://openjdk.org/jeps/431; - Pattern matching for switch - https://openjdk.org/jeps/441; - Virtual threads - https://openjdk.org/jeps/444; - Record patterns - https://openjdk.org/jeps/440. Note that this may require updates in any extensions that declare v0.6.0 dependencies, to ensure they also use Java 21 (and have a suitably recent Gradle wrapper).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1603
https://github.com/qupath/qupath/issues/1605:36,Deployability,install,installing,36,"We have recently encountered issues installing QuPath on our computers at our academic hospital. According to our IT department, who investigated the matter, the problem is due to QuPath lacking an 'Extended Validation Code Signing Certificate'. Would it be possible to include this certificate in future builds so that we can continue using the software?",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1605
https://github.com/qupath/qupath/issues/1605:199,Modifiability,Extend,Extended,199,"We have recently encountered issues installing QuPath on our computers at our academic hospital. According to our IT department, who investigated the matter, the problem is due to QuPath lacking an 'Extended Validation Code Signing Certificate'. Would it be possible to include this certificate in future builds so that we can continue using the software?",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1605
https://github.com/qupath/qupath/issues/1605:208,Security,Validat,Validation,208,"We have recently encountered issues installing QuPath on our computers at our academic hospital. According to our IT department, who investigated the matter, the problem is due to QuPath lacking an 'Extended Validation Code Signing Certificate'. Would it be possible to include this certificate in future builds so that we can continue using the software?",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1605
https://github.com/qupath/qupath/issues/1605:232,Security,Certificate,Certificate,232,"We have recently encountered issues installing QuPath on our computers at our academic hospital. According to our IT department, who investigated the matter, the problem is due to QuPath lacking an 'Extended Validation Code Signing Certificate'. Would it be possible to include this certificate in future builds so that we can continue using the software?",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1605
https://github.com/qupath/qupath/issues/1605:283,Security,certificate,certificate,283,"We have recently encountered issues installing QuPath on our computers at our academic hospital. According to our IT department, who investigated the matter, the problem is due to QuPath lacking an 'Extended Validation Code Signing Certificate'. Would it be possible to include this certificate in future builds so that we can continue using the software?",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1605
https://github.com/qupath/qupath/issues/1606:51,Safety,detect,detections-with-out-of-bounds-annotations,51,See https://forum.image.sc/t/qupath-wrongly-placed-detections-with-out-of-bounds-annotations/100914 for full details.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1606
https://github.com/qupath/qupath/pull/1607:421,Deployability,release,release,421,"Fixes https://github.com/qupath/qupath/issues/1606. Note that this makes the change at a higher level than cell detection, so potentially impacts (fixes?) other commands. Note also that it can potentially change how tiling operates, by adjusting the parent ROI temporarily. In other words, large regions may be tiled with a different origin - and so have boundaries in a different place. However it is planned for a v0.x release, and most ROIs shouldn't be outside the image, so any reproducibility impact is expected to be minimal.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1607
https://github.com/qupath/qupath/pull/1607:112,Safety,detect,detection,112,"Fixes https://github.com/qupath/qupath/issues/1606. Note that this makes the change at a higher level than cell detection, so potentially impacts (fixes?) other commands. Note also that it can potentially change how tiling operates, by adjusting the parent ROI temporarily. In other words, large regions may be tiled with a different origin - and so have boundaries in a different place. However it is planned for a v0.x release, and most ROIs shouldn't be outside the image, so any reproducibility impact is expected to be minimal.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1607
https://github.com/qupath/qupath/pull/1608:28,Availability,avail,available,28,- Don't warn TensorFlow not available on Apple Silicon (it is with DJL v0.29.0); - Fix Delaunay display for empty tiles; - Fix creating an empty Delaunay subdivision; - Add DuplicatesStrategy so that builds don't fail when using `importFlat` during development,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1608
https://github.com/qupath/qupath/issues/1610:425,Availability,down,down,425,"## Bug report. ### Describe the bug; Reported with videos at https://forum.image.sc/t/an-issue-with-the-polygon-annotation-tool/100797. ### To Reproduce. #### The easy way; Run this script and then try interacting with a viewer; ```groovy; getCurrentViewer().setSpaceDown(false); ```. #### The more realistic way; 1. Create a viewer grid containing at least two viewers with open images; 2. Click within one viewer, and hold down spacebar; 3. Click within another viewer, and only *then* release the spacebar; 4. Return to the first viewer, and try using drawing tools (e.g. polygon, rectangle). ### Expected behavior; Using the spacebar to temporarily activate the `Move` tool works across multiple viewers.; The spacebar status properly supports. ### Screenshots; See the linked forum post. ### Desktop (please complete the following information):; - OS: All; - QuPath Version: v0.5.1 (and earlier)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1610
https://github.com/qupath/qupath/issues/1610:488,Deployability,release,release,488,"## Bug report. ### Describe the bug; Reported with videos at https://forum.image.sc/t/an-issue-with-the-polygon-annotation-tool/100797. ### To Reproduce. #### The easy way; Run this script and then try interacting with a viewer; ```groovy; getCurrentViewer().setSpaceDown(false); ```. #### The more realistic way; 1. Create a viewer grid containing at least two viewers with open images; 2. Click within one viewer, and hold down spacebar; 3. Click within another viewer, and only *then* release the spacebar; 4. Return to the first viewer, and try using drawing tools (e.g. polygon, rectangle). ### Expected behavior; Using the spacebar to temporarily activate the `Move` tool works across multiple viewers.; The spacebar status properly supports. ### Screenshots; See the linked forum post. ### Desktop (please complete the following information):; - OS: All; - QuPath Version: v0.5.1 (and earlier)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1610
https://github.com/qupath/qupath/pull/1613:118,Modifiability,extend,extend,118,"Support changing classifications for TMA cores via right-click. Previously this only worked for annotations. We could extend this to detections, but for now I don't want to make that *too* easy.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1613
https://github.com/qupath/qupath/pull/1613:133,Safety,detect,detections,133,"Support changing classifications for TMA cores via right-click. Previously this only worked for annotations. We could extend this to detections, but for now I don't want to make that *too* easy.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1613
https://github.com/qupath/qupath/pull/1614:63,Usability,learn,learned,63,"An unsatisfying exploration into ROI-to-Geometry conversion. I learned that `Polygonizer` has non-deterministic behavior, and this can't be corrected externally. It can also fail for complex, randomly-generated polygons - although the behavior seems 'stable enough' for real-world data.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1614
https://github.com/qupath/qupath/pull/1615:134,Usability,intuit,intuitive,134,"Use the `Compartment: Channel: Measurement` with `ObjectMeasurements`. This is to group measurements by compartment, which seems more intuitive and easier to work with than grouping by channel.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1615
https://github.com/qupath/qupath/pull/1617:225,Availability,reliab,reliable,225,"This gets rid of the warnings about deprecation during startup. Only the Bio-Formats and OpenSlide servers relied upon this as a backup in case `ImageServer.close()`, and both now use `Cleaner`. Note that this should be more reliable anyway, since servers that wrapped other servers don't reliably call `close()` on the servers that they wrap. They arguably should, but if multiple servers wrap the same core server then there's a chance it is closed even while still in use... so it's safer to rely on the `Cleaner` (unfortunately). One way to test this is to run a script such as ; ```groovy; int n = 10; for (int i = 0; i < n; i++) {; def server = getProjectEntry().getServerBuilder().build(); println server; }; ```; for a project with an OpenSlide or Bio-Formats image open, and check the log for evidence that `Cleaner` was used (at debug level).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1617
https://github.com/qupath/qupath/pull/1617:289,Availability,reliab,reliably,289,"This gets rid of the warnings about deprecation during startup. Only the Bio-Formats and OpenSlide servers relied upon this as a backup in case `ImageServer.close()`, and both now use `Cleaner`. Note that this should be more reliable anyway, since servers that wrapped other servers don't reliably call `close()` on the servers that they wrap. They arguably should, but if multiple servers wrap the same core server then there's a chance it is closed even while still in use... so it's safer to rely on the `Cleaner` (unfortunately). One way to test this is to run a script such as ; ```groovy; int n = 10; for (int i = 0; i < n; i++) {; def server = getProjectEntry().getServerBuilder().build(); println server; }; ```; for a project with an OpenSlide or Bio-Formats image open, and check the log for evidence that `Cleaner` was used (at debug level).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1617
https://github.com/qupath/qupath/pull/1617:261,Integrability,wrap,wrapped,261,"This gets rid of the warnings about deprecation during startup. Only the Bio-Formats and OpenSlide servers relied upon this as a backup in case `ImageServer.close()`, and both now use `Cleaner`. Note that this should be more reliable anyway, since servers that wrapped other servers don't reliably call `close()` on the servers that they wrap. They arguably should, but if multiple servers wrap the same core server then there's a chance it is closed even while still in use... so it's safer to rely on the `Cleaner` (unfortunately). One way to test this is to run a script such as ; ```groovy; int n = 10; for (int i = 0; i < n; i++) {; def server = getProjectEntry().getServerBuilder().build(); println server; }; ```; for a project with an OpenSlide or Bio-Formats image open, and check the log for evidence that `Cleaner` was used (at debug level).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1617
https://github.com/qupath/qupath/pull/1617:338,Integrability,wrap,wrap,338,"This gets rid of the warnings about deprecation during startup. Only the Bio-Formats and OpenSlide servers relied upon this as a backup in case `ImageServer.close()`, and both now use `Cleaner`. Note that this should be more reliable anyway, since servers that wrapped other servers don't reliably call `close()` on the servers that they wrap. They arguably should, but if multiple servers wrap the same core server then there's a chance it is closed even while still in use... so it's safer to rely on the `Cleaner` (unfortunately). One way to test this is to run a script such as ; ```groovy; int n = 10; for (int i = 0; i < n; i++) {; def server = getProjectEntry().getServerBuilder().build(); println server; }; ```; for a project with an OpenSlide or Bio-Formats image open, and check the log for evidence that `Cleaner` was used (at debug level).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1617
https://github.com/qupath/qupath/pull/1617:390,Integrability,wrap,wrap,390,"This gets rid of the warnings about deprecation during startup. Only the Bio-Formats and OpenSlide servers relied upon this as a backup in case `ImageServer.close()`, and both now use `Cleaner`. Note that this should be more reliable anyway, since servers that wrapped other servers don't reliably call `close()` on the servers that they wrap. They arguably should, but if multiple servers wrap the same core server then there's a chance it is closed even while still in use... so it's safer to rely on the `Cleaner` (unfortunately). One way to test this is to run a script such as ; ```groovy; int n = 10; for (int i = 0; i < n; i++) {; def server = getProjectEntry().getServerBuilder().build(); println server; }; ```; for a project with an OpenSlide or Bio-Formats image open, and check the log for evidence that `Cleaner` was used (at debug level).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1617
https://github.com/qupath/qupath/pull/1617:486,Safety,safe,safer,486,"This gets rid of the warnings about deprecation during startup. Only the Bio-Formats and OpenSlide servers relied upon this as a backup in case `ImageServer.close()`, and both now use `Cleaner`. Note that this should be more reliable anyway, since servers that wrapped other servers don't reliably call `close()` on the servers that they wrap. They arguably should, but if multiple servers wrap the same core server then there's a chance it is closed even while still in use... so it's safer to rely on the `Cleaner` (unfortunately). One way to test this is to run a script such as ; ```groovy; int n = 10; for (int i = 0; i < n; i++) {; def server = getProjectEntry().getServerBuilder().build(); println server; }; ```; for a project with an OpenSlide or Bio-Formats image open, and check the log for evidence that `Cleaner` was used (at debug level).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1617
https://github.com/qupath/qupath/pull/1617:545,Testability,test,test,545,"This gets rid of the warnings about deprecation during startup. Only the Bio-Formats and OpenSlide servers relied upon this as a backup in case `ImageServer.close()`, and both now use `Cleaner`. Note that this should be more reliable anyway, since servers that wrapped other servers don't reliably call `close()` on the servers that they wrap. They arguably should, but if multiple servers wrap the same core server then there's a chance it is closed even while still in use... so it's safer to rely on the `Cleaner` (unfortunately). One way to test this is to run a script such as ; ```groovy; int n = 10; for (int i = 0; i < n; i++) {; def server = getProjectEntry().getServerBuilder().build(); println server; }; ```; for a project with an OpenSlide or Bio-Formats image open, and check the log for evidence that `Cleaner` was used (at debug level).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1617
https://github.com/qupath/qupath/pull/1617:794,Testability,log,log,794,"This gets rid of the warnings about deprecation during startup. Only the Bio-Formats and OpenSlide servers relied upon this as a backup in case `ImageServer.close()`, and both now use `Cleaner`. Note that this should be more reliable anyway, since servers that wrapped other servers don't reliably call `close()` on the servers that they wrap. They arguably should, but if multiple servers wrap the same core server then there's a chance it is closed even while still in use... so it's safer to rely on the `Cleaner` (unfortunately). One way to test this is to run a script such as ; ```groovy; int n = 10; for (int i = 0; i < n; i++) {; def server = getProjectEntry().getServerBuilder().build(); println server; }; ```; for a project with an OpenSlide or Bio-Formats image open, and check the log for evidence that `Cleaner` was used (at debug level).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1617
https://github.com/qupath/qupath/pull/1618:81,Usability,intuit,intuitive,81,Support using *Intersection over minimum area* with `ObjectMerger`. This is more intuitive than IoU when we want small objects that fall inside large objects to be swallowed up by those larger objects.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1618
https://github.com/qupath/qupath/pull/1619:394,Energy Efficiency,efficient,efficiently,394,"This exists alongside `ObjectMerger` to provide more post-processing that is relevant when resolving the processing tiles. `OverlapFixer` prioritizes objects according to a `Comparator` (e.g. to prefer larger areas), then can do two main things when objects overlap:; * Drop the lower priority objects; * Clip the lower priority objects. The aim of this class is to do those tasks flexibly and efficiently.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1619
https://github.com/qupath/qupath/pull/1620:461,Availability,down,downloads,461,"Proposed fix for https://github.com/qupath/qupath/issues/1586. @alanocallaghan @Rylern please test this and let me know what you think, I don't use symlinks much... Ideal tests should involve a range of file types, including images and .qpdata, via drag & drop and opened in other ways. In particular, the original report related to an image that involves multiple files (.vsi). I don't know of good .vsi examples are public, but .ndpis is similar-ish: https://downloads.openmicroscopy.org/images/Hamamatsu-NDPI/manuel/. Then you have 3 .ndpi files that *could* be opened independently, but if you open the .ndpis then the other files should act as different channels. The trouble for me is that it won't work on an Apple Silicon Mac due to Bio-Formats - it needs an Intel build.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1620
https://github.com/qupath/qupath/pull/1620:94,Testability,test,test,94,"Proposed fix for https://github.com/qupath/qupath/issues/1586. @alanocallaghan @Rylern please test this and let me know what you think, I don't use symlinks much... Ideal tests should involve a range of file types, including images and .qpdata, via drag & drop and opened in other ways. In particular, the original report related to an image that involves multiple files (.vsi). I don't know of good .vsi examples are public, but .ndpis is similar-ish: https://downloads.openmicroscopy.org/images/Hamamatsu-NDPI/manuel/. Then you have 3 .ndpi files that *could* be opened independently, but if you open the .ndpis then the other files should act as different channels. The trouble for me is that it won't work on an Apple Silicon Mac due to Bio-Formats - it needs an Intel build.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1620
https://github.com/qupath/qupath/pull/1620:171,Testability,test,tests,171,"Proposed fix for https://github.com/qupath/qupath/issues/1586. @alanocallaghan @Rylern please test this and let me know what you think, I don't use symlinks much... Ideal tests should involve a range of file types, including images and .qpdata, via drag & drop and opened in other ways. In particular, the original report related to an image that involves multiple files (.vsi). I don't know of good .vsi examples are public, but .ndpis is similar-ish: https://downloads.openmicroscopy.org/images/Hamamatsu-NDPI/manuel/. Then you have 3 .ndpi files that *could* be opened independently, but if you open the .ndpis then the other files should act as different channels. The trouble for me is that it won't work on an Apple Silicon Mac due to Bio-Formats - it needs an Intel build.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1620
https://github.com/qupath/qupath/pull/1621:166,Deployability,update,updated,166,"This enable `ObjectMerger` and `OverlapFixer` to implement the same interface, and means they can easily be applied sequentially. Then the `PixelProcessor` class was updated to support an `ObjectProcessor` to handle detections made across tiles, rather than an `ObjectMerger` - since that gives more flexibility in dealing with the output.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1621
https://github.com/qupath/qupath/pull/1621:68,Integrability,interface,interface,68,"This enable `ObjectMerger` and `OverlapFixer` to implement the same interface, and means they can easily be applied sequentially. Then the `PixelProcessor` class was updated to support an `ObjectProcessor` to handle detections made across tiles, rather than an `ObjectMerger` - since that gives more flexibility in dealing with the output.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1621
https://github.com/qupath/qupath/pull/1621:216,Safety,detect,detections,216,"This enable `ObjectMerger` and `OverlapFixer` to implement the same interface, and means they can easily be applied sequentially. Then the `PixelProcessor` class was updated to support an `ObjectProcessor` to handle detections made across tiles, rather than an `ObjectMerger` - since that gives more flexibility in dealing with the output.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1621
https://github.com/qupath/qupath/pull/1623:613,Deployability,toggle,toggle,613,"Possibly controversial, possibly very welcome... Usually, the annotation line thickness remains constant at all zoom levels - whereas the detection line thickness increases and decreases when zooming in and out. This is partly to avoid having thick detection lines when zoomed out, and partly for performance reasons: we cache detections rendered at different resolutions. *However*, detections *are* painted 'live' (like annotations) when zooming in beyond full resolution. I find this can be annoying at times, because the default detection line thickness of 2 can be too much - and obscures details. I need to toggle detections on and off to see the pixels that overlap with the border, or else go to the preferences to reduce the line for some images... then go back to increase the line for the next images. So this PR causes detections to be painted more like annotations when upsampling. The result is that lines narrow to become subpixel when zooming in, and that it is possible to more accurately judge where the detection boundary really lies. Screenshots below, but they aren't the best examples - and it's better to play around with the behavior using different images to form an opinion as to whether this is better, worse, or pretty neutral. ## Previous. ![older-rendering](https://github.com/user-attachments/assets/4e637414-6e6a-46c3-9044-bb51db67fa6d). ## With this PR. ![new-rendering](https://github.com/user-attachments/assets/0fd890bc-76d2-4aff-885b-5d25580d0114)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1623
https://github.com/qupath/qupath/pull/1623:723,Energy Efficiency,reduce,reduce,723,"Possibly controversial, possibly very welcome... Usually, the annotation line thickness remains constant at all zoom levels - whereas the detection line thickness increases and decreases when zooming in and out. This is partly to avoid having thick detection lines when zoomed out, and partly for performance reasons: we cache detections rendered at different resolutions. *However*, detections *are* painted 'live' (like annotations) when zooming in beyond full resolution. I find this can be annoying at times, because the default detection line thickness of 2 can be too much - and obscures details. I need to toggle detections on and off to see the pixels that overlap with the border, or else go to the preferences to reduce the line for some images... then go back to increase the line for the next images. So this PR causes detections to be painted more like annotations when upsampling. The result is that lines narrow to become subpixel when zooming in, and that it is possible to more accurately judge where the detection boundary really lies. Screenshots below, but they aren't the best examples - and it's better to play around with the behavior using different images to form an opinion as to whether this is better, worse, or pretty neutral. ## Previous. ![older-rendering](https://github.com/user-attachments/assets/4e637414-6e6a-46c3-9044-bb51db67fa6d). ## With this PR. ![new-rendering](https://github.com/user-attachments/assets/0fd890bc-76d2-4aff-885b-5d25580d0114)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1623
https://github.com/qupath/qupath/pull/1623:297,Performance,perform,performance,297,"Possibly controversial, possibly very welcome... Usually, the annotation line thickness remains constant at all zoom levels - whereas the detection line thickness increases and decreases when zooming in and out. This is partly to avoid having thick detection lines when zoomed out, and partly for performance reasons: we cache detections rendered at different resolutions. *However*, detections *are* painted 'live' (like annotations) when zooming in beyond full resolution. I find this can be annoying at times, because the default detection line thickness of 2 can be too much - and obscures details. I need to toggle detections on and off to see the pixels that overlap with the border, or else go to the preferences to reduce the line for some images... then go back to increase the line for the next images. So this PR causes detections to be painted more like annotations when upsampling. The result is that lines narrow to become subpixel when zooming in, and that it is possible to more accurately judge where the detection boundary really lies. Screenshots below, but they aren't the best examples - and it's better to play around with the behavior using different images to form an opinion as to whether this is better, worse, or pretty neutral. ## Previous. ![older-rendering](https://github.com/user-attachments/assets/4e637414-6e6a-46c3-9044-bb51db67fa6d). ## With this PR. ![new-rendering](https://github.com/user-attachments/assets/0fd890bc-76d2-4aff-885b-5d25580d0114)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1623
https://github.com/qupath/qupath/pull/1623:321,Performance,cache,cache,321,"Possibly controversial, possibly very welcome... Usually, the annotation line thickness remains constant at all zoom levels - whereas the detection line thickness increases and decreases when zooming in and out. This is partly to avoid having thick detection lines when zoomed out, and partly for performance reasons: we cache detections rendered at different resolutions. *However*, detections *are* painted 'live' (like annotations) when zooming in beyond full resolution. I find this can be annoying at times, because the default detection line thickness of 2 can be too much - and obscures details. I need to toggle detections on and off to see the pixels that overlap with the border, or else go to the preferences to reduce the line for some images... then go back to increase the line for the next images. So this PR causes detections to be painted more like annotations when upsampling. The result is that lines narrow to become subpixel when zooming in, and that it is possible to more accurately judge where the detection boundary really lies. Screenshots below, but they aren't the best examples - and it's better to play around with the behavior using different images to form an opinion as to whether this is better, worse, or pretty neutral. ## Previous. ![older-rendering](https://github.com/user-attachments/assets/4e637414-6e6a-46c3-9044-bb51db67fa6d). ## With this PR. ![new-rendering](https://github.com/user-attachments/assets/0fd890bc-76d2-4aff-885b-5d25580d0114)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1623
https://github.com/qupath/qupath/pull/1623:138,Safety,detect,detection,138,"Possibly controversial, possibly very welcome... Usually, the annotation line thickness remains constant at all zoom levels - whereas the detection line thickness increases and decreases when zooming in and out. This is partly to avoid having thick detection lines when zoomed out, and partly for performance reasons: we cache detections rendered at different resolutions. *However*, detections *are* painted 'live' (like annotations) when zooming in beyond full resolution. I find this can be annoying at times, because the default detection line thickness of 2 can be too much - and obscures details. I need to toggle detections on and off to see the pixels that overlap with the border, or else go to the preferences to reduce the line for some images... then go back to increase the line for the next images. So this PR causes detections to be painted more like annotations when upsampling. The result is that lines narrow to become subpixel when zooming in, and that it is possible to more accurately judge where the detection boundary really lies. Screenshots below, but they aren't the best examples - and it's better to play around with the behavior using different images to form an opinion as to whether this is better, worse, or pretty neutral. ## Previous. ![older-rendering](https://github.com/user-attachments/assets/4e637414-6e6a-46c3-9044-bb51db67fa6d). ## With this PR. ![new-rendering](https://github.com/user-attachments/assets/0fd890bc-76d2-4aff-885b-5d25580d0114)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1623
https://github.com/qupath/qupath/pull/1623:230,Safety,avoid,avoid,230,"Possibly controversial, possibly very welcome... Usually, the annotation line thickness remains constant at all zoom levels - whereas the detection line thickness increases and decreases when zooming in and out. This is partly to avoid having thick detection lines when zoomed out, and partly for performance reasons: we cache detections rendered at different resolutions. *However*, detections *are* painted 'live' (like annotations) when zooming in beyond full resolution. I find this can be annoying at times, because the default detection line thickness of 2 can be too much - and obscures details. I need to toggle detections on and off to see the pixels that overlap with the border, or else go to the preferences to reduce the line for some images... then go back to increase the line for the next images. So this PR causes detections to be painted more like annotations when upsampling. The result is that lines narrow to become subpixel when zooming in, and that it is possible to more accurately judge where the detection boundary really lies. Screenshots below, but they aren't the best examples - and it's better to play around with the behavior using different images to form an opinion as to whether this is better, worse, or pretty neutral. ## Previous. ![older-rendering](https://github.com/user-attachments/assets/4e637414-6e6a-46c3-9044-bb51db67fa6d). ## With this PR. ![new-rendering](https://github.com/user-attachments/assets/0fd890bc-76d2-4aff-885b-5d25580d0114)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1623
https://github.com/qupath/qupath/pull/1623:249,Safety,detect,detection,249,"Possibly controversial, possibly very welcome... Usually, the annotation line thickness remains constant at all zoom levels - whereas the detection line thickness increases and decreases when zooming in and out. This is partly to avoid having thick detection lines when zoomed out, and partly for performance reasons: we cache detections rendered at different resolutions. *However*, detections *are* painted 'live' (like annotations) when zooming in beyond full resolution. I find this can be annoying at times, because the default detection line thickness of 2 can be too much - and obscures details. I need to toggle detections on and off to see the pixels that overlap with the border, or else go to the preferences to reduce the line for some images... then go back to increase the line for the next images. So this PR causes detections to be painted more like annotations when upsampling. The result is that lines narrow to become subpixel when zooming in, and that it is possible to more accurately judge where the detection boundary really lies. Screenshots below, but they aren't the best examples - and it's better to play around with the behavior using different images to form an opinion as to whether this is better, worse, or pretty neutral. ## Previous. ![older-rendering](https://github.com/user-attachments/assets/4e637414-6e6a-46c3-9044-bb51db67fa6d). ## With this PR. ![new-rendering](https://github.com/user-attachments/assets/0fd890bc-76d2-4aff-885b-5d25580d0114)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1623
https://github.com/qupath/qupath/pull/1623:327,Safety,detect,detections,327,"Possibly controversial, possibly very welcome... Usually, the annotation line thickness remains constant at all zoom levels - whereas the detection line thickness increases and decreases when zooming in and out. This is partly to avoid having thick detection lines when zoomed out, and partly for performance reasons: we cache detections rendered at different resolutions. *However*, detections *are* painted 'live' (like annotations) when zooming in beyond full resolution. I find this can be annoying at times, because the default detection line thickness of 2 can be too much - and obscures details. I need to toggle detections on and off to see the pixels that overlap with the border, or else go to the preferences to reduce the line for some images... then go back to increase the line for the next images. So this PR causes detections to be painted more like annotations when upsampling. The result is that lines narrow to become subpixel when zooming in, and that it is possible to more accurately judge where the detection boundary really lies. Screenshots below, but they aren't the best examples - and it's better to play around with the behavior using different images to form an opinion as to whether this is better, worse, or pretty neutral. ## Previous. ![older-rendering](https://github.com/user-attachments/assets/4e637414-6e6a-46c3-9044-bb51db67fa6d). ## With this PR. ![new-rendering](https://github.com/user-attachments/assets/0fd890bc-76d2-4aff-885b-5d25580d0114)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1623
https://github.com/qupath/qupath/pull/1623:384,Safety,detect,detections,384,"Possibly controversial, possibly very welcome... Usually, the annotation line thickness remains constant at all zoom levels - whereas the detection line thickness increases and decreases when zooming in and out. This is partly to avoid having thick detection lines when zoomed out, and partly for performance reasons: we cache detections rendered at different resolutions. *However*, detections *are* painted 'live' (like annotations) when zooming in beyond full resolution. I find this can be annoying at times, because the default detection line thickness of 2 can be too much - and obscures details. I need to toggle detections on and off to see the pixels that overlap with the border, or else go to the preferences to reduce the line for some images... then go back to increase the line for the next images. So this PR causes detections to be painted more like annotations when upsampling. The result is that lines narrow to become subpixel when zooming in, and that it is possible to more accurately judge where the detection boundary really lies. Screenshots below, but they aren't the best examples - and it's better to play around with the behavior using different images to form an opinion as to whether this is better, worse, or pretty neutral. ## Previous. ![older-rendering](https://github.com/user-attachments/assets/4e637414-6e6a-46c3-9044-bb51db67fa6d). ## With this PR. ![new-rendering](https://github.com/user-attachments/assets/0fd890bc-76d2-4aff-885b-5d25580d0114)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1623
https://github.com/qupath/qupath/pull/1623:533,Safety,detect,detection,533,"Possibly controversial, possibly very welcome... Usually, the annotation line thickness remains constant at all zoom levels - whereas the detection line thickness increases and decreases when zooming in and out. This is partly to avoid having thick detection lines when zoomed out, and partly for performance reasons: we cache detections rendered at different resolutions. *However*, detections *are* painted 'live' (like annotations) when zooming in beyond full resolution. I find this can be annoying at times, because the default detection line thickness of 2 can be too much - and obscures details. I need to toggle detections on and off to see the pixels that overlap with the border, or else go to the preferences to reduce the line for some images... then go back to increase the line for the next images. So this PR causes detections to be painted more like annotations when upsampling. The result is that lines narrow to become subpixel when zooming in, and that it is possible to more accurately judge where the detection boundary really lies. Screenshots below, but they aren't the best examples - and it's better to play around with the behavior using different images to form an opinion as to whether this is better, worse, or pretty neutral. ## Previous. ![older-rendering](https://github.com/user-attachments/assets/4e637414-6e6a-46c3-9044-bb51db67fa6d). ## With this PR. ![new-rendering](https://github.com/user-attachments/assets/0fd890bc-76d2-4aff-885b-5d25580d0114)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1623
https://github.com/qupath/qupath/pull/1623:620,Safety,detect,detections,620,"Possibly controversial, possibly very welcome... Usually, the annotation line thickness remains constant at all zoom levels - whereas the detection line thickness increases and decreases when zooming in and out. This is partly to avoid having thick detection lines when zoomed out, and partly for performance reasons: we cache detections rendered at different resolutions. *However*, detections *are* painted 'live' (like annotations) when zooming in beyond full resolution. I find this can be annoying at times, because the default detection line thickness of 2 can be too much - and obscures details. I need to toggle detections on and off to see the pixels that overlap with the border, or else go to the preferences to reduce the line for some images... then go back to increase the line for the next images. So this PR causes detections to be painted more like annotations when upsampling. The result is that lines narrow to become subpixel when zooming in, and that it is possible to more accurately judge where the detection boundary really lies. Screenshots below, but they aren't the best examples - and it's better to play around with the behavior using different images to form an opinion as to whether this is better, worse, or pretty neutral. ## Previous. ![older-rendering](https://github.com/user-attachments/assets/4e637414-6e6a-46c3-9044-bb51db67fa6d). ## With this PR. ![new-rendering](https://github.com/user-attachments/assets/0fd890bc-76d2-4aff-885b-5d25580d0114)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1623
https://github.com/qupath/qupath/pull/1623:831,Safety,detect,detections,831,"Possibly controversial, possibly very welcome... Usually, the annotation line thickness remains constant at all zoom levels - whereas the detection line thickness increases and decreases when zooming in and out. This is partly to avoid having thick detection lines when zoomed out, and partly for performance reasons: we cache detections rendered at different resolutions. *However*, detections *are* painted 'live' (like annotations) when zooming in beyond full resolution. I find this can be annoying at times, because the default detection line thickness of 2 can be too much - and obscures details. I need to toggle detections on and off to see the pixels that overlap with the border, or else go to the preferences to reduce the line for some images... then go back to increase the line for the next images. So this PR causes detections to be painted more like annotations when upsampling. The result is that lines narrow to become subpixel when zooming in, and that it is possible to more accurately judge where the detection boundary really lies. Screenshots below, but they aren't the best examples - and it's better to play around with the behavior using different images to form an opinion as to whether this is better, worse, or pretty neutral. ## Previous. ![older-rendering](https://github.com/user-attachments/assets/4e637414-6e6a-46c3-9044-bb51db67fa6d). ## With this PR. ![new-rendering](https://github.com/user-attachments/assets/0fd890bc-76d2-4aff-885b-5d25580d0114)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1623
https://github.com/qupath/qupath/pull/1623:1022,Safety,detect,detection,1022,"Possibly controversial, possibly very welcome... Usually, the annotation line thickness remains constant at all zoom levels - whereas the detection line thickness increases and decreases when zooming in and out. This is partly to avoid having thick detection lines when zoomed out, and partly for performance reasons: we cache detections rendered at different resolutions. *However*, detections *are* painted 'live' (like annotations) when zooming in beyond full resolution. I find this can be annoying at times, because the default detection line thickness of 2 can be too much - and obscures details. I need to toggle detections on and off to see the pixels that overlap with the border, or else go to the preferences to reduce the line for some images... then go back to increase the line for the next images. So this PR causes detections to be painted more like annotations when upsampling. The result is that lines narrow to become subpixel when zooming in, and that it is possible to more accurately judge where the detection boundary really lies. Screenshots below, but they aren't the best examples - and it's better to play around with the behavior using different images to form an opinion as to whether this is better, worse, or pretty neutral. ## Previous. ![older-rendering](https://github.com/user-attachments/assets/4e637414-6e6a-46c3-9044-bb51db67fa6d). ## With this PR. ![new-rendering](https://github.com/user-attachments/assets/0fd890bc-76d2-4aff-885b-5d25580d0114)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1623
https://github.com/qupath/qupath/pull/1624:68,Deployability,install,installed,68,- Fix QuPath version compatibility logging when extensions can't be installed; - Support `GeneralTools.isAppleSilicon()`; - Update the welcome message,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1624
https://github.com/qupath/qupath/pull/1624:124,Deployability,Update,Update,124,- Fix QuPath version compatibility logging when extensions can't be installed; - Support `GeneralTools.isAppleSilicon()`; - Update the welcome message,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1624
https://github.com/qupath/qupath/pull/1624:143,Integrability,message,message,143,- Fix QuPath version compatibility logging when extensions can't be installed; - Support `GeneralTools.isAppleSilicon()`; - Update the welcome message,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1624
https://github.com/qupath/qupath/pull/1624:35,Testability,log,logging,35,- Fix QuPath version compatibility logging when extensions can't be installed; - Support `GeneralTools.isAppleSilicon()`; - Update the welcome message,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1624
https://github.com/qupath/qupath/pull/1625:8,Testability,test,test,8,"Edit: a test is failing on Windows. I'm looking at it now. This PR adds support for writing OME Zarr images with the `convert-ome` command line command (which was only creating OME TIFF files until now). The OME Zarr writer lacked some features to fulfill the requirements of `convert-ome`, so it has been slightly improved. An example of such features is about considering only a subset of the existing z-stacks (or timepoints) of the input image. I didn't want to code this inside the Zarr writer because it's not specific to Zarr files, so I created a new `ImageServer` called `SlicedImageServer`. It acts like a `CroppedImageServer`, but on the z and t axis. This PR also adds tests for the `convert-ome` command, the zarr writer, and the `SlicedImageServer`.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1625
https://github.com/qupath/qupath/pull/1625:681,Testability,test,tests,681,"Edit: a test is failing on Windows. I'm looking at it now. This PR adds support for writing OME Zarr images with the `convert-ome` command line command (which was only creating OME TIFF files until now). The OME Zarr writer lacked some features to fulfill the requirements of `convert-ome`, so it has been slightly improved. An example of such features is about considering only a subset of the existing z-stacks (or timepoints) of the input image. I didn't want to code this inside the Zarr writer because it's not specific to Zarr files, so I created a new `ImageServer` called `SlicedImageServer`. It acts like a `CroppedImageServer`, but on the z and t axis. This PR also adds tests for the `convert-ome` command, the zarr writer, and the `SlicedImageServer`.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1625
https://github.com/qupath/qupath/pull/1626:13,Deployability,update,update,13,"Attempted to update ControlsFX to 11.2.1, but it had some very weird `CheckComboBox` behavior (returning null checked items).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1626
https://github.com/qupath/qupath/issues/1628:293,Availability,Down,Download,293,"## Bug report. ### Describe the bug; Parsing timepoint metadata from images can be tricky, but currently QuPath seems worse than it needs to be. Values provided by ImageJ or Bio-Formats servers seem wrong, or can even through exceptions. ### To Reproduce; Steps to reproduce the behavior:; 1. Download the [`mitosis.tif` sample image from ImageJ](https://imagej.net/ij/images/); 2. Create a project; 3. Import the image, using either ImageJ or Bio-Formats as the provider; 4. Run the following script. ```groovy; def server = getCurrentServer(). for (int t = 0; t < server.nTimepoints(); t++) {; println server.getMetadata().getTimepoint(2) ; }; ```. With Bio-Formats, I get that the timepoints are all `0`.; With ImageJ, I get that they are `NaN`. However if I open the image in Fiji I can confirm that both ImageJ and Bio-Formats *can* read the time information, so the bug is definitely on QuPath's side. ### Expected behavior; Timepoint information is available (and meaningful) wherever possible. ### Desktop (please complete the following information):; - OS: All; - QuPath Version: v0.5.1 (and earlier). ### Additional context; A warning is logged that Bio-Formats' timepoint parsing isn't reliable... because I didn't understand how it worked when writing that code originally. It probably hasn't matter because QuPath isn't used with time series data very much.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1628
https://github.com/qupath/qupath/issues/1628:956,Availability,avail,available,956,"## Bug report. ### Describe the bug; Parsing timepoint metadata from images can be tricky, but currently QuPath seems worse than it needs to be. Values provided by ImageJ or Bio-Formats servers seem wrong, or can even through exceptions. ### To Reproduce; Steps to reproduce the behavior:; 1. Download the [`mitosis.tif` sample image from ImageJ](https://imagej.net/ij/images/); 2. Create a project; 3. Import the image, using either ImageJ or Bio-Formats as the provider; 4. Run the following script. ```groovy; def server = getCurrentServer(). for (int t = 0; t < server.nTimepoints(); t++) {; println server.getMetadata().getTimepoint(2) ; }; ```. With Bio-Formats, I get that the timepoints are all `0`.; With ImageJ, I get that they are `NaN`. However if I open the image in Fiji I can confirm that both ImageJ and Bio-Formats *can* read the time information, so the bug is definitely on QuPath's side. ### Expected behavior; Timepoint information is available (and meaningful) wherever possible. ### Desktop (please complete the following information):; - OS: All; - QuPath Version: v0.5.1 (and earlier). ### Additional context; A warning is logged that Bio-Formats' timepoint parsing isn't reliable... because I didn't understand how it worked when writing that code originally. It probably hasn't matter because QuPath isn't used with time series data very much.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1628
https://github.com/qupath/qupath/issues/1628:1197,Availability,reliab,reliable,1197,"## Bug report. ### Describe the bug; Parsing timepoint metadata from images can be tricky, but currently QuPath seems worse than it needs to be. Values provided by ImageJ or Bio-Formats servers seem wrong, or can even through exceptions. ### To Reproduce; Steps to reproduce the behavior:; 1. Download the [`mitosis.tif` sample image from ImageJ](https://imagej.net/ij/images/); 2. Create a project; 3. Import the image, using either ImageJ or Bio-Formats as the provider; 4. Run the following script. ```groovy; def server = getCurrentServer(). for (int t = 0; t < server.nTimepoints(); t++) {; println server.getMetadata().getTimepoint(2) ; }; ```. With Bio-Formats, I get that the timepoints are all `0`.; With ImageJ, I get that they are `NaN`. However if I open the image in Fiji I can confirm that both ImageJ and Bio-Formats *can* read the time information, so the bug is definitely on QuPath's side. ### Expected behavior; Timepoint information is available (and meaningful) wherever possible. ### Desktop (please complete the following information):; - OS: All; - QuPath Version: v0.5.1 (and earlier). ### Additional context; A warning is logged that Bio-Formats' timepoint parsing isn't reliable... because I didn't understand how it worked when writing that code originally. It probably hasn't matter because QuPath isn't used with time series data very much.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1628
https://github.com/qupath/qupath/issues/1628:1148,Testability,log,logged,1148,"## Bug report. ### Describe the bug; Parsing timepoint metadata from images can be tricky, but currently QuPath seems worse than it needs to be. Values provided by ImageJ or Bio-Formats servers seem wrong, or can even through exceptions. ### To Reproduce; Steps to reproduce the behavior:; 1. Download the [`mitosis.tif` sample image from ImageJ](https://imagej.net/ij/images/); 2. Create a project; 3. Import the image, using either ImageJ or Bio-Formats as the provider; 4. Run the following script. ```groovy; def server = getCurrentServer(). for (int t = 0; t < server.nTimepoints(); t++) {; println server.getMetadata().getTimepoint(2) ; }; ```. With Bio-Formats, I get that the timepoints are all `0`.; With ImageJ, I get that they are `NaN`. However if I open the image in Fiji I can confirm that both ImageJ and Bio-Formats *can* read the time information, so the bug is definitely on QuPath's side. ### Expected behavior; Timepoint information is available (and meaningful) wherever possible. ### Desktop (please complete the following information):; - OS: All; - QuPath Version: v0.5.1 (and earlier). ### Additional context; A warning is logged that Bio-Formats' timepoint parsing isn't reliable... because I didn't understand how it worked when writing that code originally. It probably hasn't matter because QuPath isn't used with time series data very much.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1628
https://github.com/qupath/qupath/issues/1635:209,Availability,error,error,209,"Hi,. Thanks for this new exciting version.; I was trying to compare InstaSeg results to StarDist results. InstaSeg is working nicely but the StarDist scripts (from Extensions>StarDist) fail with the following error.; I tried both H&E and Fluorescence scripts. (I set the model path). ```; ERROR: 'org.locationtech.jts.geom.Geometry qupath.lib.roi.GeometryTools.createRectangle(double, double, double, double)'; java.lang.NoSuchMethodError: 'org.locationtech.jts.geom.Geometry qupath.lib.roi.GeometryTools.createRectangle(double, double, double, double)'; at qupath.ext.stardist.StarDist2D.lambda$detectObjects$10(StarDist2D.java:940); at java.base/java.util.stream.ReferencePipeline$2$1.accept(Unknown Source); at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(Unknown Source); at java.base/java.util.stream.AbstractPipeline.copyInto(Unknown Source); at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source); at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(Unknown Source); at java.base/java.util.stream.AbstractPipeline.evaluate(Unknown Source); at java.base/java.util.stream.ReferencePipeline.collect(Unknown Source); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:941); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:886); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$6(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:859); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$5(StarDist2D.java:812); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:812); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:48); at org.codehaus.groovy.jsr223.GroovyScriptEngine",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1635
https://github.com/qupath/qupath/issues/1635:289,Availability,ERROR,ERROR,289,"Hi,. Thanks for this new exciting version.; I was trying to compare InstaSeg results to StarDist results. InstaSeg is working nicely but the StarDist scripts (from Extensions>StarDist) fail with the following error.; I tried both H&E and Fluorescence scripts. (I set the model path). ```; ERROR: 'org.locationtech.jts.geom.Geometry qupath.lib.roi.GeometryTools.createRectangle(double, double, double, double)'; java.lang.NoSuchMethodError: 'org.locationtech.jts.geom.Geometry qupath.lib.roi.GeometryTools.createRectangle(double, double, double, double)'; at qupath.ext.stardist.StarDist2D.lambda$detectObjects$10(StarDist2D.java:940); at java.base/java.util.stream.ReferencePipeline$2$1.accept(Unknown Source); at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(Unknown Source); at java.base/java.util.stream.AbstractPipeline.copyInto(Unknown Source); at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source); at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(Unknown Source); at java.base/java.util.stream.AbstractPipeline.evaluate(Unknown Source); at java.base/java.util.stream.ReferencePipeline.collect(Unknown Source); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:941); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:886); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$6(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:859); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$5(StarDist2D.java:812); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:812); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:48); at org.codehaus.groovy.jsr223.GroovyScriptEngine",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1635
https://github.com/qupath/qupath/issues/1635:982,Energy Efficiency,Reduce,ReduceOps,982,"Hi,. Thanks for this new exciting version.; I was trying to compare InstaSeg results to StarDist results. InstaSeg is working nicely but the StarDist scripts (from Extensions>StarDist) fail with the following error.; I tried both H&E and Fluorescence scripts. (I set the model path). ```; ERROR: 'org.locationtech.jts.geom.Geometry qupath.lib.roi.GeometryTools.createRectangle(double, double, double, double)'; java.lang.NoSuchMethodError: 'org.locationtech.jts.geom.Geometry qupath.lib.roi.GeometryTools.createRectangle(double, double, double, double)'; at qupath.ext.stardist.StarDist2D.lambda$detectObjects$10(StarDist2D.java:940); at java.base/java.util.stream.ReferencePipeline$2$1.accept(Unknown Source); at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(Unknown Source); at java.base/java.util.stream.AbstractPipeline.copyInto(Unknown Source); at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source); at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(Unknown Source); at java.base/java.util.stream.AbstractPipeline.evaluate(Unknown Source); at java.base/java.util.stream.ReferencePipeline.collect(Unknown Source); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:941); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:886); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$6(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:859); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$5(StarDist2D.java:812); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:812); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:48); at org.codehaus.groovy.jsr223.GroovyScriptEngine",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1635
https://github.com/qupath/qupath/issues/1635:992,Energy Efficiency,Reduce,ReduceOp,992,"Hi,. Thanks for this new exciting version.; I was trying to compare InstaSeg results to StarDist results. InstaSeg is working nicely but the StarDist scripts (from Extensions>StarDist) fail with the following error.; I tried both H&E and Fluorescence scripts. (I set the model path). ```; ERROR: 'org.locationtech.jts.geom.Geometry qupath.lib.roi.GeometryTools.createRectangle(double, double, double, double)'; java.lang.NoSuchMethodError: 'org.locationtech.jts.geom.Geometry qupath.lib.roi.GeometryTools.createRectangle(double, double, double, double)'; at qupath.ext.stardist.StarDist2D.lambda$detectObjects$10(StarDist2D.java:940); at java.base/java.util.stream.ReferencePipeline$2$1.accept(Unknown Source); at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(Unknown Source); at java.base/java.util.stream.AbstractPipeline.copyInto(Unknown Source); at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source); at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(Unknown Source); at java.base/java.util.stream.AbstractPipeline.evaluate(Unknown Source); at java.base/java.util.stream.ReferencePipeline.collect(Unknown Source); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:941); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:886); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$6(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:859); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$5(StarDist2D.java:812); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:812); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:48); at org.codehaus.groovy.jsr223.GroovyScriptEngine",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1635
https://github.com/qupath/qupath/issues/1635:919,Integrability,wrap,wrapAndCopyInto,919,"Hi,. Thanks for this new exciting version.; I was trying to compare InstaSeg results to StarDist results. InstaSeg is working nicely but the StarDist scripts (from Extensions>StarDist) fail with the following error.; I tried both H&E and Fluorescence scripts. (I set the model path). ```; ERROR: 'org.locationtech.jts.geom.Geometry qupath.lib.roi.GeometryTools.createRectangle(double, double, double, double)'; java.lang.NoSuchMethodError: 'org.locationtech.jts.geom.Geometry qupath.lib.roi.GeometryTools.createRectangle(double, double, double, double)'; at qupath.ext.stardist.StarDist2D.lambda$detectObjects$10(StarDist2D.java:940); at java.base/java.util.stream.ReferencePipeline$2$1.accept(Unknown Source); at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(Unknown Source); at java.base/java.util.stream.AbstractPipeline.copyInto(Unknown Source); at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source); at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(Unknown Source); at java.base/java.util.stream.AbstractPipeline.evaluate(Unknown Source); at java.base/java.util.stream.ReferencePipeline.collect(Unknown Source); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:941); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:886); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$6(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:859); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$5(StarDist2D.java:812); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:812); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:48); at org.codehaus.groovy.jsr223.GroovyScriptEngine",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1635
https://github.com/qupath/qupath/issues/1635:2441,Performance,concurren,concurrent,2441,rce); at java.base/java.util.stream.AbstractPipeline.copyInto(Unknown Source); at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source); at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(Unknown Source); at java.base/java.util.stream.AbstractPipeline.evaluate(Unknown Source); at java.base/java.util.stream.ReferencePipeline.collect(Unknown Source); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:941); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:886); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$6(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:859); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$5(StarDist2D.java:812); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:812); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:48); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:331); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:161); at qupath.lib.gui.scripting.languages.DefaultScriptLanguage.execute(DefaultScriptLanguage.java:234); at qupath.lib.gui.scripting.DefaultScriptEditor.executeScript(DefaultScriptEditor.java:1179); at qupath.lib.gui.scripting.DefaultScriptEditor$3.run(DefaultScriptEditor.java:1545); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source). ```. Best; Ofra,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1635
https://github.com/qupath/qupath/issues/1635:2523,Performance,concurren,concurrent,2523,rce); at java.base/java.util.stream.AbstractPipeline.copyInto(Unknown Source); at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source); at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(Unknown Source); at java.base/java.util.stream.AbstractPipeline.evaluate(Unknown Source); at java.base/java.util.stream.ReferencePipeline.collect(Unknown Source); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:941); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:886); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$6(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:859); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$5(StarDist2D.java:812); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:812); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:48); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:331); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:161); at qupath.lib.gui.scripting.languages.DefaultScriptLanguage.execute(DefaultScriptLanguage.java:234); at qupath.lib.gui.scripting.DefaultScriptEditor.executeScript(DefaultScriptEditor.java:1179); at qupath.lib.gui.scripting.DefaultScriptEditor$3.run(DefaultScriptEditor.java:1545); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source). ```. Best; Ofra,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1635
https://github.com/qupath/qupath/issues/1635:2589,Performance,concurren,concurrent,2589,rce); at java.base/java.util.stream.AbstractPipeline.copyInto(Unknown Source); at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source); at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(Unknown Source); at java.base/java.util.stream.AbstractPipeline.evaluate(Unknown Source); at java.base/java.util.stream.ReferencePipeline.collect(Unknown Source); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:941); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:886); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$6(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:859); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$5(StarDist2D.java:812); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:812); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:48); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:331); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:161); at qupath.lib.gui.scripting.languages.DefaultScriptLanguage.execute(DefaultScriptLanguage.java:234); at qupath.lib.gui.scripting.DefaultScriptEditor.executeScript(DefaultScriptEditor.java:1179); at qupath.lib.gui.scripting.DefaultScriptEditor$3.run(DefaultScriptEditor.java:1545); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source). ```. Best; Ofra,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1635
https://github.com/qupath/qupath/issues/1635:2669,Performance,concurren,concurrent,2669,rce); at java.base/java.util.stream.AbstractPipeline.copyInto(Unknown Source); at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source); at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(Unknown Source); at java.base/java.util.stream.AbstractPipeline.evaluate(Unknown Source); at java.base/java.util.stream.ReferencePipeline.collect(Unknown Source); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:941); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:886); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$6(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:859); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$5(StarDist2D.java:812); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:812); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:48); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:331); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:161); at qupath.lib.gui.scripting.languages.DefaultScriptLanguage.execute(DefaultScriptLanguage.java:234); at qupath.lib.gui.scripting.DefaultScriptEditor.executeScript(DefaultScriptEditor.java:1179); at qupath.lib.gui.scripting.DefaultScriptEditor$3.run(DefaultScriptEditor.java:1545); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source). ```. Best; Ofra,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1635
https://github.com/qupath/qupath/issues/1635:596,Safety,detect,detectObjects,596,"Hi,. Thanks for this new exciting version.; I was trying to compare InstaSeg results to StarDist results. InstaSeg is working nicely but the StarDist scripts (from Extensions>StarDist) fail with the following error.; I tried both H&E and Fluorescence scripts. (I set the model path). ```; ERROR: 'org.locationtech.jts.geom.Geometry qupath.lib.roi.GeometryTools.createRectangle(double, double, double, double)'; java.lang.NoSuchMethodError: 'org.locationtech.jts.geom.Geometry qupath.lib.roi.GeometryTools.createRectangle(double, double, double, double)'; at qupath.ext.stardist.StarDist2D.lambda$detectObjects$10(StarDist2D.java:940); at java.base/java.util.stream.ReferencePipeline$2$1.accept(Unknown Source); at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(Unknown Source); at java.base/java.util.stream.AbstractPipeline.copyInto(Unknown Source); at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source); at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(Unknown Source); at java.base/java.util.stream.AbstractPipeline.evaluate(Unknown Source); at java.base/java.util.stream.ReferencePipeline.collect(Unknown Source); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:941); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:886); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$6(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:859); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$5(StarDist2D.java:812); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:812); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:48); at org.codehaus.groovy.jsr223.GroovyScriptEngine",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1635
https://github.com/qupath/qupath/issues/1635:1217,Safety,detect,detectObjects,1217," H&E and Fluorescence scripts. (I set the model path). ```; ERROR: 'org.locationtech.jts.geom.Geometry qupath.lib.roi.GeometryTools.createRectangle(double, double, double, double)'; java.lang.NoSuchMethodError: 'org.locationtech.jts.geom.Geometry qupath.lib.roi.GeometryTools.createRectangle(double, double, double, double)'; at qupath.ext.stardist.StarDist2D.lambda$detectObjects$10(StarDist2D.java:940); at java.base/java.util.stream.ReferencePipeline$2$1.accept(Unknown Source); at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(Unknown Source); at java.base/java.util.stream.AbstractPipeline.copyInto(Unknown Source); at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source); at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(Unknown Source); at java.base/java.util.stream.AbstractPipeline.evaluate(Unknown Source); at java.base/java.util.stream.ReferencePipeline.collect(Unknown Source); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:941); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:886); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$6(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:859); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$5(StarDist2D.java:812); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:812); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:48); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:331); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:161); at qupath.lib.gui.scripting.languages.DefaultScriptLanguage.execute(DefaultScriptLanguage.jav",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1635
https://github.com/qupath/qupath/issues/1635:1287,Safety,detect,detectObjectsImpl,1287,"locationtech.jts.geom.Geometry qupath.lib.roi.GeometryTools.createRectangle(double, double, double, double)'; java.lang.NoSuchMethodError: 'org.locationtech.jts.geom.Geometry qupath.lib.roi.GeometryTools.createRectangle(double, double, double, double)'; at qupath.ext.stardist.StarDist2D.lambda$detectObjects$10(StarDist2D.java:940); at java.base/java.util.stream.ReferencePipeline$2$1.accept(Unknown Source); at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(Unknown Source); at java.base/java.util.stream.AbstractPipeline.copyInto(Unknown Source); at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source); at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(Unknown Source); at java.base/java.util.stream.AbstractPipeline.evaluate(Unknown Source); at java.base/java.util.stream.ReferencePipeline.collect(Unknown Source); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:941); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:886); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$6(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:859); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$5(StarDist2D.java:812); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:812); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:48); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:331); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:161); at qupath.lib.gui.scripting.languages.DefaultScriptLanguage.execute(DefaultScriptLanguage.java:234); at qupath.lib.gui.scripting.DefaultScriptEditor.executeScript(De",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1635
https://github.com/qupath/qupath/issues/1635:1368,Safety,detect,detectObjects,1368,"ouble, double, double, double)'; java.lang.NoSuchMethodError: 'org.locationtech.jts.geom.Geometry qupath.lib.roi.GeometryTools.createRectangle(double, double, double, double)'; at qupath.ext.stardist.StarDist2D.lambda$detectObjects$10(StarDist2D.java:940); at java.base/java.util.stream.ReferencePipeline$2$1.accept(Unknown Source); at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(Unknown Source); at java.base/java.util.stream.AbstractPipeline.copyInto(Unknown Source); at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source); at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(Unknown Source); at java.base/java.util.stream.AbstractPipeline.evaluate(Unknown Source); at java.base/java.util.stream.ReferencePipeline.collect(Unknown Source); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:941); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:886); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$6(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:859); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$5(StarDist2D.java:812); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:812); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:48); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:331); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:161); at qupath.lib.gui.scripting.languages.DefaultScriptLanguage.execute(DefaultScriptLanguage.java:234); at qupath.lib.gui.scripting.DefaultScriptEditor.executeScript(DefaultScriptEditor.java:1179); at qupath.lib.gui.scripting.DefaultScriptEdito",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1635
https://github.com/qupath/qupath/issues/1635:1506,Safety,detect,detectObjects,1506,"le(double, double, double, double)'; at qupath.ext.stardist.StarDist2D.lambda$detectObjects$10(StarDist2D.java:940); at java.base/java.util.stream.ReferencePipeline$2$1.accept(Unknown Source); at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(Unknown Source); at java.base/java.util.stream.AbstractPipeline.copyInto(Unknown Source); at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source); at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(Unknown Source); at java.base/java.util.stream.AbstractPipeline.evaluate(Unknown Source); at java.base/java.util.stream.ReferencePipeline.collect(Unknown Source); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:941); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:886); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$6(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:859); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$5(StarDist2D.java:812); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:812); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:48); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:331); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:161); at qupath.lib.gui.scripting.languages.DefaultScriptLanguage.execute(DefaultScriptLanguage.java:234); at qupath.lib.gui.scripting.DefaultScriptEditor.executeScript(DefaultScriptEditor.java:1179); at qupath.lib.gui.scripting.DefaultScriptEditor$3.run(DefaultScriptEditor.java:1545); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.u",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1635
https://github.com/qupath/qupath/issues/1635:1576,Safety,detect,detectObjectsImpl,1576,ambda$detectObjects$10(StarDist2D.java:940); at java.base/java.util.stream.ReferencePipeline$2$1.accept(Unknown Source); at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(Unknown Source); at java.base/java.util.stream.AbstractPipeline.copyInto(Unknown Source); at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source); at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(Unknown Source); at java.base/java.util.stream.AbstractPipeline.evaluate(Unknown Source); at java.base/java.util.stream.ReferencePipeline.collect(Unknown Source); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:941); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:886); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$6(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:859); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$5(StarDist2D.java:812); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:812); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:48); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:331); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:161); at qupath.lib.gui.scripting.languages.DefaultScriptLanguage.execute(DefaultScriptLanguage.java:234); at qupath.lib.gui.scripting.DefaultScriptEditor.executeScript(DefaultScriptEditor.java:1179); at qupath.lib.gui.scripting.DefaultScriptEditor$3.run(DefaultScriptEditor.java:1545); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.co,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1635
https://github.com/qupath/qupath/issues/1635:1657,Safety,detect,detectObjects,1657,ferencePipeline$2$1.accept(Unknown Source); at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(Unknown Source); at java.base/java.util.stream.AbstractPipeline.copyInto(Unknown Source); at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source); at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(Unknown Source); at java.base/java.util.stream.AbstractPipeline.evaluate(Unknown Source); at java.base/java.util.stream.ReferencePipeline.collect(Unknown Source); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:941); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:886); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$6(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:859); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$5(StarDist2D.java:812); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:812); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:48); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:331); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:161); at qupath.lib.gui.scripting.languages.DefaultScriptLanguage.execute(DefaultScriptLanguage.java:234); at qupath.lib.gui.scripting.DefaultScriptEditor.executeScript(DefaultScriptEditor.java:1179); at qupath.lib.gui.scripting.DefaultScriptEditor$3.run(DefaultScriptEditor.java:1545); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.uti,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1635
https://github.com/qupath/qupath/issues/1635:1795,Safety,detect,detectObjects,1795,rce); at java.base/java.util.stream.AbstractPipeline.copyInto(Unknown Source); at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source); at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(Unknown Source); at java.base/java.util.stream.AbstractPipeline.evaluate(Unknown Source); at java.base/java.util.stream.ReferencePipeline.collect(Unknown Source); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:941); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:886); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$6(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:823); at qupath.ext.stardist.StarDist2D.detectObjectsImpl(StarDist2D.java:859); at qupath.ext.stardist.StarDist2D.lambda$detectObjects$5(StarDist2D.java:812); at qupath.ext.stardist.StarDist2D.runInPool(StarDist2D.java:849); at qupath.ext.stardist.StarDist2D.detectObjects(StarDist2D.java:812); at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321); at QuPathScript.run(QuPathScript:48); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:331); at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:161); at qupath.lib.gui.scripting.languages.DefaultScriptLanguage.execute(DefaultScriptLanguage.java:234); at qupath.lib.gui.scripting.DefaultScriptEditor.executeScript(DefaultScriptEditor.java:1179); at qupath.lib.gui.scripting.DefaultScriptEditor$3.run(DefaultScriptEditor.java:1545); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source). ```. Best; Ofra,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1635
https://github.com/qupath/qupath/issues/1636:966,Availability,down,downloadPyTorch,966,"I cannot make pytorch work. I tried also with a conda env but nothing works. Even if I just select CPU in Instantseg, it tries to load the cuda version. Problem is that it detects cuda 12.1 so maybe it does not even want to try to load the CPU version?. `Failed to load PyTorch native library; ai.djl.engine.EngineException: Failed to load PyTorch native library; 	at ai.djl.pytorch.engine.PtEngine.newInstance(PtEngine.java:90); 	at ai.djl.pytorch.engine.PtEngineProvider.getEngine(PtEngineProvider.java:41); 	at ai.djl.engine.Engine.getEngine(Engine.java:190); 	at qupath.ext.instanseg.core.PytorchManager.lambda$getEngineOnline$0(PytorchManager.java:28); 	at qupath.ext.instanseg.core.PytorchManager.callWithTempProperty(PytorchManager.java:114); 	at qupath.ext.instanseg.core.PytorchManager.callOnline(PytorchManager.java:106); 	at qupath.ext.instanseg.core.PytorchManager.getEngineOnline(PytorchManager.java:28); 	at qupath.ext.instanseg.ui.InstanSegController.downloadPyTorch(InstanSegController.java:826); 	at qupath.ext.instanseg.ui.InstanSegController.ensurePyTorchAvailable(InstanSegController.java:815); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.scan(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source); Caused by: java.lang.UnsatisfiedLinkError: C:\Users\username\.djl.ai\pytorch\2.3.1-cu121-win-x86_64\cudnn_cnn_infer64_8.dll: The specified procedure could not be found; 	at java.base/jdk.internal.loader.NativeLibraries.load(Native Method); 	at java.base/jdk.internal.loader.NativeLibraries$NativeLibraryImpl.open(Unknown Source); 	",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636
https://github.com/qupath/qupath/issues/1636:130,Performance,load,load,130,"I cannot make pytorch work. I tried also with a conda env but nothing works. Even if I just select CPU in Instantseg, it tries to load the cuda version. Problem is that it detects cuda 12.1 so maybe it does not even want to try to load the CPU version?. `Failed to load PyTorch native library; ai.djl.engine.EngineException: Failed to load PyTorch native library; 	at ai.djl.pytorch.engine.PtEngine.newInstance(PtEngine.java:90); 	at ai.djl.pytorch.engine.PtEngineProvider.getEngine(PtEngineProvider.java:41); 	at ai.djl.engine.Engine.getEngine(Engine.java:190); 	at qupath.ext.instanseg.core.PytorchManager.lambda$getEngineOnline$0(PytorchManager.java:28); 	at qupath.ext.instanseg.core.PytorchManager.callWithTempProperty(PytorchManager.java:114); 	at qupath.ext.instanseg.core.PytorchManager.callOnline(PytorchManager.java:106); 	at qupath.ext.instanseg.core.PytorchManager.getEngineOnline(PytorchManager.java:28); 	at qupath.ext.instanseg.ui.InstanSegController.downloadPyTorch(InstanSegController.java:826); 	at qupath.ext.instanseg.ui.InstanSegController.ensurePyTorchAvailable(InstanSegController.java:815); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.scan(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source); Caused by: java.lang.UnsatisfiedLinkError: C:\Users\username\.djl.ai\pytorch\2.3.1-cu121-win-x86_64\cudnn_cnn_infer64_8.dll: The specified procedure could not be found; 	at java.base/jdk.internal.loader.NativeLibraries.load(Native Method); 	at java.base/jdk.internal.loader.NativeLibraries$NativeLibraryImpl.open(Unknown Source); 	",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636
https://github.com/qupath/qupath/issues/1636:231,Performance,load,load,231,"I cannot make pytorch work. I tried also with a conda env but nothing works. Even if I just select CPU in Instantseg, it tries to load the cuda version. Problem is that it detects cuda 12.1 so maybe it does not even want to try to load the CPU version?. `Failed to load PyTorch native library; ai.djl.engine.EngineException: Failed to load PyTorch native library; 	at ai.djl.pytorch.engine.PtEngine.newInstance(PtEngine.java:90); 	at ai.djl.pytorch.engine.PtEngineProvider.getEngine(PtEngineProvider.java:41); 	at ai.djl.engine.Engine.getEngine(Engine.java:190); 	at qupath.ext.instanseg.core.PytorchManager.lambda$getEngineOnline$0(PytorchManager.java:28); 	at qupath.ext.instanseg.core.PytorchManager.callWithTempProperty(PytorchManager.java:114); 	at qupath.ext.instanseg.core.PytorchManager.callOnline(PytorchManager.java:106); 	at qupath.ext.instanseg.core.PytorchManager.getEngineOnline(PytorchManager.java:28); 	at qupath.ext.instanseg.ui.InstanSegController.downloadPyTorch(InstanSegController.java:826); 	at qupath.ext.instanseg.ui.InstanSegController.ensurePyTorchAvailable(InstanSegController.java:815); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.scan(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source); Caused by: java.lang.UnsatisfiedLinkError: C:\Users\username\.djl.ai\pytorch\2.3.1-cu121-win-x86_64\cudnn_cnn_infer64_8.dll: The specified procedure could not be found; 	at java.base/jdk.internal.loader.NativeLibraries.load(Native Method); 	at java.base/jdk.internal.loader.NativeLibraries$NativeLibraryImpl.open(Unknown Source); 	",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636
https://github.com/qupath/qupath/issues/1636:265,Performance,load,load,265,"I cannot make pytorch work. I tried also with a conda env but nothing works. Even if I just select CPU in Instantseg, it tries to load the cuda version. Problem is that it detects cuda 12.1 so maybe it does not even want to try to load the CPU version?. `Failed to load PyTorch native library; ai.djl.engine.EngineException: Failed to load PyTorch native library; 	at ai.djl.pytorch.engine.PtEngine.newInstance(PtEngine.java:90); 	at ai.djl.pytorch.engine.PtEngineProvider.getEngine(PtEngineProvider.java:41); 	at ai.djl.engine.Engine.getEngine(Engine.java:190); 	at qupath.ext.instanseg.core.PytorchManager.lambda$getEngineOnline$0(PytorchManager.java:28); 	at qupath.ext.instanseg.core.PytorchManager.callWithTempProperty(PytorchManager.java:114); 	at qupath.ext.instanseg.core.PytorchManager.callOnline(PytorchManager.java:106); 	at qupath.ext.instanseg.core.PytorchManager.getEngineOnline(PytorchManager.java:28); 	at qupath.ext.instanseg.ui.InstanSegController.downloadPyTorch(InstanSegController.java:826); 	at qupath.ext.instanseg.ui.InstanSegController.ensurePyTorchAvailable(InstanSegController.java:815); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.scan(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source); Caused by: java.lang.UnsatisfiedLinkError: C:\Users\username\.djl.ai\pytorch\2.3.1-cu121-win-x86_64\cudnn_cnn_infer64_8.dll: The specified procedure could not be found; 	at java.base/jdk.internal.loader.NativeLibraries.load(Native Method); 	at java.base/jdk.internal.loader.NativeLibraries$NativeLibraryImpl.open(Unknown Source); 	",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636
https://github.com/qupath/qupath/issues/1636:335,Performance,load,load,335,"I cannot make pytorch work. I tried also with a conda env but nothing works. Even if I just select CPU in Instantseg, it tries to load the cuda version. Problem is that it detects cuda 12.1 so maybe it does not even want to try to load the CPU version?. `Failed to load PyTorch native library; ai.djl.engine.EngineException: Failed to load PyTorch native library; 	at ai.djl.pytorch.engine.PtEngine.newInstance(PtEngine.java:90); 	at ai.djl.pytorch.engine.PtEngineProvider.getEngine(PtEngineProvider.java:41); 	at ai.djl.engine.Engine.getEngine(Engine.java:190); 	at qupath.ext.instanseg.core.PytorchManager.lambda$getEngineOnline$0(PytorchManager.java:28); 	at qupath.ext.instanseg.core.PytorchManager.callWithTempProperty(PytorchManager.java:114); 	at qupath.ext.instanseg.core.PytorchManager.callOnline(PytorchManager.java:106); 	at qupath.ext.instanseg.core.PytorchManager.getEngineOnline(PytorchManager.java:28); 	at qupath.ext.instanseg.ui.InstanSegController.downloadPyTorch(InstanSegController.java:826); 	at qupath.ext.instanseg.ui.InstanSegController.ensurePyTorchAvailable(InstanSegController.java:815); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.scan(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source); Caused by: java.lang.UnsatisfiedLinkError: C:\Users\username\.djl.ai\pytorch\2.3.1-cu121-win-x86_64\cudnn_cnn_infer64_8.dll: The specified procedure could not be found; 	at java.base/jdk.internal.loader.NativeLibraries.load(Native Method); 	at java.base/jdk.internal.loader.NativeLibraries$NativeLibraryImpl.open(Unknown Source); 	",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636
https://github.com/qupath/qupath/issues/1636:1139,Performance,concurren,concurrent,1139,version. Problem is that it detects cuda 12.1 so maybe it does not even want to try to load the CPU version?. `Failed to load PyTorch native library; ai.djl.engine.EngineException: Failed to load PyTorch native library; 	at ai.djl.pytorch.engine.PtEngine.newInstance(PtEngine.java:90); 	at ai.djl.pytorch.engine.PtEngineProvider.getEngine(PtEngineProvider.java:41); 	at ai.djl.engine.Engine.getEngine(Engine.java:190); 	at qupath.ext.instanseg.core.PytorchManager.lambda$getEngineOnline$0(PytorchManager.java:28); 	at qupath.ext.instanseg.core.PytorchManager.callWithTempProperty(PytorchManager.java:114); 	at qupath.ext.instanseg.core.PytorchManager.callOnline(PytorchManager.java:106); 	at qupath.ext.instanseg.core.PytorchManager.getEngineOnline(PytorchManager.java:28); 	at qupath.ext.instanseg.ui.InstanSegController.downloadPyTorch(InstanSegController.java:826); 	at qupath.ext.instanseg.ui.InstanSegController.ensurePyTorchAvailable(InstanSegController.java:815); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.scan(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source); Caused by: java.lang.UnsatisfiedLinkError: C:\Users\username\.djl.ai\pytorch\2.3.1-cu121-win-x86_64\cudnn_cnn_infer64_8.dll: The specified procedure could not be found; 	at java.base/jdk.internal.loader.NativeLibraries.load(Native Method); 	at java.base/jdk.internal.loader.NativeLibraries$NativeLibraryImpl.open(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unkn,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636
https://github.com/qupath/qupath/issues/1636:1225,Performance,concurren,concurrent,1225, load the CPU version?. `Failed to load PyTorch native library; ai.djl.engine.EngineException: Failed to load PyTorch native library; 	at ai.djl.pytorch.engine.PtEngine.newInstance(PtEngine.java:90); 	at ai.djl.pytorch.engine.PtEngineProvider.getEngine(PtEngineProvider.java:41); 	at ai.djl.engine.Engine.getEngine(Engine.java:190); 	at qupath.ext.instanseg.core.PytorchManager.lambda$getEngineOnline$0(PytorchManager.java:28); 	at qupath.ext.instanseg.core.PytorchManager.callWithTempProperty(PytorchManager.java:114); 	at qupath.ext.instanseg.core.PytorchManager.callOnline(PytorchManager.java:106); 	at qupath.ext.instanseg.core.PytorchManager.getEngineOnline(PytorchManager.java:28); 	at qupath.ext.instanseg.ui.InstanSegController.downloadPyTorch(InstanSegController.java:826); 	at qupath.ext.instanseg.ui.InstanSegController.ensurePyTorchAvailable(InstanSegController.java:815); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.scan(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source); Caused by: java.lang.UnsatisfiedLinkError: C:\Users\username\.djl.ai\pytorch\2.3.1-cu121-win-x86_64\cudnn_cnn_infer64_8.dll: The specified procedure could not be found; 	at java.base/jdk.internal.loader.NativeLibraries.load(Native Method); 	at java.base/jdk.internal.loader.NativeLibraries$NativeLibraryImpl.open(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/java.lang.ClassLoader.loadLibrary(Unknown Source); 	at java,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636
https://github.com/qupath/qupath/issues/1636:1312,Performance,concurren,concurrent,1312,eption: Failed to load PyTorch native library; 	at ai.djl.pytorch.engine.PtEngine.newInstance(PtEngine.java:90); 	at ai.djl.pytorch.engine.PtEngineProvider.getEngine(PtEngineProvider.java:41); 	at ai.djl.engine.Engine.getEngine(Engine.java:190); 	at qupath.ext.instanseg.core.PytorchManager.lambda$getEngineOnline$0(PytorchManager.java:28); 	at qupath.ext.instanseg.core.PytorchManager.callWithTempProperty(PytorchManager.java:114); 	at qupath.ext.instanseg.core.PytorchManager.callOnline(PytorchManager.java:106); 	at qupath.ext.instanseg.core.PytorchManager.getEngineOnline(PytorchManager.java:28); 	at qupath.ext.instanseg.ui.InstanSegController.downloadPyTorch(InstanSegController.java:826); 	at qupath.ext.instanseg.ui.InstanSegController.ensurePyTorchAvailable(InstanSegController.java:815); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.scan(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source); Caused by: java.lang.UnsatisfiedLinkError: C:\Users\username\.djl.ai\pytorch\2.3.1-cu121-win-x86_64\cudnn_cnn_infer64_8.dll: The specified procedure could not be found; 	at java.base/jdk.internal.loader.NativeLibraries.load(Native Method); 	at java.base/jdk.internal.loader.NativeLibraries$NativeLibraryImpl.open(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/java.lang.ClassLoader.loadLibrary(Unknown Source); 	at java.base/java.lang.Runtime.load0(Unknown Source); 	at java.base/java.lang.System.load(Unkn,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636
https://github.com/qupath/qupath/issues/1636:1384,Performance,concurren,concurrent,1384,.PtEngine.newInstance(PtEngine.java:90); 	at ai.djl.pytorch.engine.PtEngineProvider.getEngine(PtEngineProvider.java:41); 	at ai.djl.engine.Engine.getEngine(Engine.java:190); 	at qupath.ext.instanseg.core.PytorchManager.lambda$getEngineOnline$0(PytorchManager.java:28); 	at qupath.ext.instanseg.core.PytorchManager.callWithTempProperty(PytorchManager.java:114); 	at qupath.ext.instanseg.core.PytorchManager.callOnline(PytorchManager.java:106); 	at qupath.ext.instanseg.core.PytorchManager.getEngineOnline(PytorchManager.java:28); 	at qupath.ext.instanseg.ui.InstanSegController.downloadPyTorch(InstanSegController.java:826); 	at qupath.ext.instanseg.ui.InstanSegController.ensurePyTorchAvailable(InstanSegController.java:815); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.scan(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source); Caused by: java.lang.UnsatisfiedLinkError: C:\Users\username\.djl.ai\pytorch\2.3.1-cu121-win-x86_64\cudnn_cnn_infer64_8.dll: The specified procedure could not be found; 	at java.base/jdk.internal.loader.NativeLibraries.load(Native Method); 	at java.base/jdk.internal.loader.NativeLibraries$NativeLibraryImpl.open(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/java.lang.ClassLoader.loadLibrary(Unknown Source); 	at java.base/java.lang.Runtime.load0(Unknown Source); 	at java.base/java.lang.System.load(Unknown Source); 	at ai.djl.pytorch.jni.LibUtils.loadNativeLibrary(LibUtils.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636
https://github.com/qupath/qupath/issues/1636:1472,Performance,concurren,concurrent,1472,ngine(PtEngineProvider.java:41); 	at ai.djl.engine.Engine.getEngine(Engine.java:190); 	at qupath.ext.instanseg.core.PytorchManager.lambda$getEngineOnline$0(PytorchManager.java:28); 	at qupath.ext.instanseg.core.PytorchManager.callWithTempProperty(PytorchManager.java:114); 	at qupath.ext.instanseg.core.PytorchManager.callOnline(PytorchManager.java:106); 	at qupath.ext.instanseg.core.PytorchManager.getEngineOnline(PytorchManager.java:28); 	at qupath.ext.instanseg.ui.InstanSegController.downloadPyTorch(InstanSegController.java:826); 	at qupath.ext.instanseg.ui.InstanSegController.ensurePyTorchAvailable(InstanSegController.java:815); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.scan(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source); Caused by: java.lang.UnsatisfiedLinkError: C:\Users\username\.djl.ai\pytorch\2.3.1-cu121-win-x86_64\cudnn_cnn_infer64_8.dll: The specified procedure could not be found; 	at java.base/jdk.internal.loader.NativeLibraries.load(Native Method); 	at java.base/jdk.internal.loader.NativeLibraries$NativeLibraryImpl.open(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/java.lang.ClassLoader.loadLibrary(Unknown Source); 	at java.base/java.lang.Runtime.load0(Unknown Source); 	at java.base/java.lang.System.load(Unknown Source); 	at ai.djl.pytorch.jni.LibUtils.loadNativeLibrary(LibUtils.java:379); 	at ai.djl.pytorch.jni.LibUtils.loadLibTorch(LibUtils.java:176); 	at ai.djl.p,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636
https://github.com/qupath/qupath/issues/1636:1542,Performance,concurren,concurrent,1542,gine.java:190); 	at qupath.ext.instanseg.core.PytorchManager.lambda$getEngineOnline$0(PytorchManager.java:28); 	at qupath.ext.instanseg.core.PytorchManager.callWithTempProperty(PytorchManager.java:114); 	at qupath.ext.instanseg.core.PytorchManager.callOnline(PytorchManager.java:106); 	at qupath.ext.instanseg.core.PytorchManager.getEngineOnline(PytorchManager.java:28); 	at qupath.ext.instanseg.ui.InstanSegController.downloadPyTorch(InstanSegController.java:826); 	at qupath.ext.instanseg.ui.InstanSegController.ensurePyTorchAvailable(InstanSegController.java:815); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.scan(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source); Caused by: java.lang.UnsatisfiedLinkError: C:\Users\username\.djl.ai\pytorch\2.3.1-cu121-win-x86_64\cudnn_cnn_infer64_8.dll: The specified procedure could not be found; 	at java.base/jdk.internal.loader.NativeLibraries.load(Native Method); 	at java.base/jdk.internal.loader.NativeLibraries$NativeLibraryImpl.open(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/java.lang.ClassLoader.loadLibrary(Unknown Source); 	at java.base/java.lang.Runtime.load0(Unknown Source); 	at java.base/java.lang.System.load(Unknown Source); 	at ai.djl.pytorch.jni.LibUtils.loadNativeLibrary(LibUtils.java:379); 	at ai.djl.pytorch.jni.LibUtils.loadLibTorch(LibUtils.java:176); 	at ai.djl.pytorch.jni.LibUtils.loadLibrary(LibUtils.java:82); 	at ai.djl.pytorch.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636
https://github.com/qupath/qupath/issues/1636:1617,Performance,concurren,concurrent,1617,lambda$getEngineOnline$0(PytorchManager.java:28); 	at qupath.ext.instanseg.core.PytorchManager.callWithTempProperty(PytorchManager.java:114); 	at qupath.ext.instanseg.core.PytorchManager.callOnline(PytorchManager.java:106); 	at qupath.ext.instanseg.core.PytorchManager.getEngineOnline(PytorchManager.java:28); 	at qupath.ext.instanseg.ui.InstanSegController.downloadPyTorch(InstanSegController.java:826); 	at qupath.ext.instanseg.ui.InstanSegController.ensurePyTorchAvailable(InstanSegController.java:815); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.scan(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source); Caused by: java.lang.UnsatisfiedLinkError: C:\Users\username\.djl.ai\pytorch\2.3.1-cu121-win-x86_64\cudnn_cnn_infer64_8.dll: The specified procedure could not be found; 	at java.base/jdk.internal.loader.NativeLibraries.load(Native Method); 	at java.base/jdk.internal.loader.NativeLibraries$NativeLibraryImpl.open(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/java.lang.ClassLoader.loadLibrary(Unknown Source); 	at java.base/java.lang.Runtime.load0(Unknown Source); 	at java.base/java.lang.System.load(Unknown Source); 	at ai.djl.pytorch.jni.LibUtils.loadNativeLibrary(LibUtils.java:379); 	at ai.djl.pytorch.jni.LibUtils.loadLibTorch(LibUtils.java:176); 	at ai.djl.pytorch.jni.LibUtils.loadLibrary(LibUtils.java:82); 	at ai.djl.pytorch.engine.PtEngine.newInstance(PtEngine.java:53); 	... 15 more`,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636
https://github.com/qupath/qupath/issues/1636:1866,Performance,load,loader,1866,lambda$getEngineOnline$0(PytorchManager.java:28); 	at qupath.ext.instanseg.core.PytorchManager.callWithTempProperty(PytorchManager.java:114); 	at qupath.ext.instanseg.core.PytorchManager.callOnline(PytorchManager.java:106); 	at qupath.ext.instanseg.core.PytorchManager.getEngineOnline(PytorchManager.java:28); 	at qupath.ext.instanseg.ui.InstanSegController.downloadPyTorch(InstanSegController.java:826); 	at qupath.ext.instanseg.ui.InstanSegController.ensurePyTorchAvailable(InstanSegController.java:815); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.scan(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source); Caused by: java.lang.UnsatisfiedLinkError: C:\Users\username\.djl.ai\pytorch\2.3.1-cu121-win-x86_64\cudnn_cnn_infer64_8.dll: The specified procedure could not be found; 	at java.base/jdk.internal.loader.NativeLibraries.load(Native Method); 	at java.base/jdk.internal.loader.NativeLibraries$NativeLibraryImpl.open(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/java.lang.ClassLoader.loadLibrary(Unknown Source); 	at java.base/java.lang.Runtime.load0(Unknown Source); 	at java.base/java.lang.System.load(Unknown Source); 	at ai.djl.pytorch.jni.LibUtils.loadNativeLibrary(LibUtils.java:379); 	at ai.djl.pytorch.jni.LibUtils.loadLibTorch(LibUtils.java:176); 	at ai.djl.pytorch.jni.LibUtils.loadLibrary(LibUtils.java:82); 	at ai.djl.pytorch.engine.PtEngine.newInstance(PtEngine.java:53); 	... 15 more`,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636
https://github.com/qupath/qupath/issues/1636:1889,Performance,load,load,1889,lambda$getEngineOnline$0(PytorchManager.java:28); 	at qupath.ext.instanseg.core.PytorchManager.callWithTempProperty(PytorchManager.java:114); 	at qupath.ext.instanseg.core.PytorchManager.callOnline(PytorchManager.java:106); 	at qupath.ext.instanseg.core.PytorchManager.getEngineOnline(PytorchManager.java:28); 	at qupath.ext.instanseg.ui.InstanSegController.downloadPyTorch(InstanSegController.java:826); 	at qupath.ext.instanseg.ui.InstanSegController.ensurePyTorchAvailable(InstanSegController.java:815); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.scan(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source); Caused by: java.lang.UnsatisfiedLinkError: C:\Users\username\.djl.ai\pytorch\2.3.1-cu121-win-x86_64\cudnn_cnn_infer64_8.dll: The specified procedure could not be found; 	at java.base/jdk.internal.loader.NativeLibraries.load(Native Method); 	at java.base/jdk.internal.loader.NativeLibraries$NativeLibraryImpl.open(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/java.lang.ClassLoader.loadLibrary(Unknown Source); 	at java.base/java.lang.Runtime.load0(Unknown Source); 	at java.base/java.lang.System.load(Unknown Source); 	at ai.djl.pytorch.jni.LibUtils.loadNativeLibrary(LibUtils.java:379); 	at ai.djl.pytorch.jni.LibUtils.loadLibTorch(LibUtils.java:176); 	at ai.djl.pytorch.jni.LibUtils.loadLibrary(LibUtils.java:82); 	at ai.djl.pytorch.engine.PtEngine.newInstance(PtEngine.java:53); 	... 15 more`,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636
https://github.com/qupath/qupath/issues/1636:1937,Performance,load,loader,1937,lambda$getEngineOnline$0(PytorchManager.java:28); 	at qupath.ext.instanseg.core.PytorchManager.callWithTempProperty(PytorchManager.java:114); 	at qupath.ext.instanseg.core.PytorchManager.callOnline(PytorchManager.java:106); 	at qupath.ext.instanseg.core.PytorchManager.getEngineOnline(PytorchManager.java:28); 	at qupath.ext.instanseg.ui.InstanSegController.downloadPyTorch(InstanSegController.java:826); 	at qupath.ext.instanseg.ui.InstanSegController.ensurePyTorchAvailable(InstanSegController.java:815); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.scan(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source); Caused by: java.lang.UnsatisfiedLinkError: C:\Users\username\.djl.ai\pytorch\2.3.1-cu121-win-x86_64\cudnn_cnn_infer64_8.dll: The specified procedure could not be found; 	at java.base/jdk.internal.loader.NativeLibraries.load(Native Method); 	at java.base/jdk.internal.loader.NativeLibraries$NativeLibraryImpl.open(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/java.lang.ClassLoader.loadLibrary(Unknown Source); 	at java.base/java.lang.Runtime.load0(Unknown Source); 	at java.base/java.lang.System.load(Unknown Source); 	at ai.djl.pytorch.jni.LibUtils.loadNativeLibrary(LibUtils.java:379); 	at ai.djl.pytorch.jni.LibUtils.loadLibTorch(LibUtils.java:176); 	at ai.djl.pytorch.jni.LibUtils.loadLibrary(LibUtils.java:82); 	at ai.djl.pytorch.engine.PtEngine.newInstance(PtEngine.java:53); 	... 15 more`,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636
https://github.com/qupath/qupath/issues/1636:2027,Performance,load,loader,2027,lambda$getEngineOnline$0(PytorchManager.java:28); 	at qupath.ext.instanseg.core.PytorchManager.callWithTempProperty(PytorchManager.java:114); 	at qupath.ext.instanseg.core.PytorchManager.callOnline(PytorchManager.java:106); 	at qupath.ext.instanseg.core.PytorchManager.getEngineOnline(PytorchManager.java:28); 	at qupath.ext.instanseg.ui.InstanSegController.downloadPyTorch(InstanSegController.java:826); 	at qupath.ext.instanseg.ui.InstanSegController.ensurePyTorchAvailable(InstanSegController.java:815); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.scan(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source); Caused by: java.lang.UnsatisfiedLinkError: C:\Users\username\.djl.ai\pytorch\2.3.1-cu121-win-x86_64\cudnn_cnn_infer64_8.dll: The specified procedure could not be found; 	at java.base/jdk.internal.loader.NativeLibraries.load(Native Method); 	at java.base/jdk.internal.loader.NativeLibraries$NativeLibraryImpl.open(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/java.lang.ClassLoader.loadLibrary(Unknown Source); 	at java.base/java.lang.Runtime.load0(Unknown Source); 	at java.base/java.lang.System.load(Unknown Source); 	at ai.djl.pytorch.jni.LibUtils.loadNativeLibrary(LibUtils.java:379); 	at ai.djl.pytorch.jni.LibUtils.loadLibTorch(LibUtils.java:176); 	at ai.djl.pytorch.jni.LibUtils.loadLibrary(LibUtils.java:82); 	at ai.djl.pytorch.engine.PtEngine.newInstance(PtEngine.java:53); 	... 15 more`,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636
https://github.com/qupath/qupath/issues/1636:2050,Performance,load,loadLibrary,2050,lambda$getEngineOnline$0(PytorchManager.java:28); 	at qupath.ext.instanseg.core.PytorchManager.callWithTempProperty(PytorchManager.java:114); 	at qupath.ext.instanseg.core.PytorchManager.callOnline(PytorchManager.java:106); 	at qupath.ext.instanseg.core.PytorchManager.getEngineOnline(PytorchManager.java:28); 	at qupath.ext.instanseg.ui.InstanSegController.downloadPyTorch(InstanSegController.java:826); 	at qupath.ext.instanseg.ui.InstanSegController.ensurePyTorchAvailable(InstanSegController.java:815); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.scan(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source); Caused by: java.lang.UnsatisfiedLinkError: C:\Users\username\.djl.ai\pytorch\2.3.1-cu121-win-x86_64\cudnn_cnn_infer64_8.dll: The specified procedure could not be found; 	at java.base/jdk.internal.loader.NativeLibraries.load(Native Method); 	at java.base/jdk.internal.loader.NativeLibraries$NativeLibraryImpl.open(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/java.lang.ClassLoader.loadLibrary(Unknown Source); 	at java.base/java.lang.Runtime.load0(Unknown Source); 	at java.base/java.lang.System.load(Unknown Source); 	at ai.djl.pytorch.jni.LibUtils.loadNativeLibrary(LibUtils.java:379); 	at ai.djl.pytorch.jni.LibUtils.loadLibTorch(LibUtils.java:176); 	at ai.djl.pytorch.jni.LibUtils.loadLibrary(LibUtils.java:82); 	at ai.djl.pytorch.engine.PtEngine.newInstance(PtEngine.java:53); 	... 15 more`,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636
https://github.com/qupath/qupath/issues/1636:2106,Performance,load,loader,2106,lambda$getEngineOnline$0(PytorchManager.java:28); 	at qupath.ext.instanseg.core.PytorchManager.callWithTempProperty(PytorchManager.java:114); 	at qupath.ext.instanseg.core.PytorchManager.callOnline(PytorchManager.java:106); 	at qupath.ext.instanseg.core.PytorchManager.getEngineOnline(PytorchManager.java:28); 	at qupath.ext.instanseg.ui.InstanSegController.downloadPyTorch(InstanSegController.java:826); 	at qupath.ext.instanseg.ui.InstanSegController.ensurePyTorchAvailable(InstanSegController.java:815); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.scan(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source); Caused by: java.lang.UnsatisfiedLinkError: C:\Users\username\.djl.ai\pytorch\2.3.1-cu121-win-x86_64\cudnn_cnn_infer64_8.dll: The specified procedure could not be found; 	at java.base/jdk.internal.loader.NativeLibraries.load(Native Method); 	at java.base/jdk.internal.loader.NativeLibraries$NativeLibraryImpl.open(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/java.lang.ClassLoader.loadLibrary(Unknown Source); 	at java.base/java.lang.Runtime.load0(Unknown Source); 	at java.base/java.lang.System.load(Unknown Source); 	at ai.djl.pytorch.jni.LibUtils.loadNativeLibrary(LibUtils.java:379); 	at ai.djl.pytorch.jni.LibUtils.loadLibTorch(LibUtils.java:176); 	at ai.djl.pytorch.jni.LibUtils.loadLibrary(LibUtils.java:82); 	at ai.djl.pytorch.engine.PtEngine.newInstance(PtEngine.java:53); 	... 15 more`,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636
https://github.com/qupath/qupath/issues/1636:2129,Performance,load,loadLibrary,2129,lambda$getEngineOnline$0(PytorchManager.java:28); 	at qupath.ext.instanseg.core.PytorchManager.callWithTempProperty(PytorchManager.java:114); 	at qupath.ext.instanseg.core.PytorchManager.callOnline(PytorchManager.java:106); 	at qupath.ext.instanseg.core.PytorchManager.getEngineOnline(PytorchManager.java:28); 	at qupath.ext.instanseg.ui.InstanSegController.downloadPyTorch(InstanSegController.java:826); 	at qupath.ext.instanseg.ui.InstanSegController.ensurePyTorchAvailable(InstanSegController.java:815); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.scan(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source); Caused by: java.lang.UnsatisfiedLinkError: C:\Users\username\.djl.ai\pytorch\2.3.1-cu121-win-x86_64\cudnn_cnn_infer64_8.dll: The specified procedure could not be found; 	at java.base/jdk.internal.loader.NativeLibraries.load(Native Method); 	at java.base/jdk.internal.loader.NativeLibraries$NativeLibraryImpl.open(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/java.lang.ClassLoader.loadLibrary(Unknown Source); 	at java.base/java.lang.Runtime.load0(Unknown Source); 	at java.base/java.lang.System.load(Unknown Source); 	at ai.djl.pytorch.jni.LibUtils.loadNativeLibrary(LibUtils.java:379); 	at ai.djl.pytorch.jni.LibUtils.loadLibTorch(LibUtils.java:176); 	at ai.djl.pytorch.jni.LibUtils.loadLibrary(LibUtils.java:82); 	at ai.djl.pytorch.engine.PtEngine.newInstance(PtEngine.java:53); 	... 15 more`,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636
https://github.com/qupath/qupath/issues/1636:2194,Performance,load,loadLibrary,2194,lambda$getEngineOnline$0(PytorchManager.java:28); 	at qupath.ext.instanseg.core.PytorchManager.callWithTempProperty(PytorchManager.java:114); 	at qupath.ext.instanseg.core.PytorchManager.callOnline(PytorchManager.java:106); 	at qupath.ext.instanseg.core.PytorchManager.getEngineOnline(PytorchManager.java:28); 	at qupath.ext.instanseg.ui.InstanSegController.downloadPyTorch(InstanSegController.java:826); 	at qupath.ext.instanseg.ui.InstanSegController.ensurePyTorchAvailable(InstanSegController.java:815); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.scan(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source); Caused by: java.lang.UnsatisfiedLinkError: C:\Users\username\.djl.ai\pytorch\2.3.1-cu121-win-x86_64\cudnn_cnn_infer64_8.dll: The specified procedure could not be found; 	at java.base/jdk.internal.loader.NativeLibraries.load(Native Method); 	at java.base/jdk.internal.loader.NativeLibraries$NativeLibraryImpl.open(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/java.lang.ClassLoader.loadLibrary(Unknown Source); 	at java.base/java.lang.Runtime.load0(Unknown Source); 	at java.base/java.lang.System.load(Unknown Source); 	at ai.djl.pytorch.jni.LibUtils.loadNativeLibrary(LibUtils.java:379); 	at ai.djl.pytorch.jni.LibUtils.loadLibTorch(LibUtils.java:176); 	at ai.djl.pytorch.jni.LibUtils.loadLibrary(LibUtils.java:82); 	at ai.djl.pytorch.engine.PtEngine.newInstance(PtEngine.java:53); 	... 15 more`,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636
https://github.com/qupath/qupath/issues/1636:2309,Performance,load,load,2309,lambda$getEngineOnline$0(PytorchManager.java:28); 	at qupath.ext.instanseg.core.PytorchManager.callWithTempProperty(PytorchManager.java:114); 	at qupath.ext.instanseg.core.PytorchManager.callOnline(PytorchManager.java:106); 	at qupath.ext.instanseg.core.PytorchManager.getEngineOnline(PytorchManager.java:28); 	at qupath.ext.instanseg.ui.InstanSegController.downloadPyTorch(InstanSegController.java:826); 	at qupath.ext.instanseg.ui.InstanSegController.ensurePyTorchAvailable(InstanSegController.java:815); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.scan(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source); Caused by: java.lang.UnsatisfiedLinkError: C:\Users\username\.djl.ai\pytorch\2.3.1-cu121-win-x86_64\cudnn_cnn_infer64_8.dll: The specified procedure could not be found; 	at java.base/jdk.internal.loader.NativeLibraries.load(Native Method); 	at java.base/jdk.internal.loader.NativeLibraries$NativeLibraryImpl.open(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/java.lang.ClassLoader.loadLibrary(Unknown Source); 	at java.base/java.lang.Runtime.load0(Unknown Source); 	at java.base/java.lang.System.load(Unknown Source); 	at ai.djl.pytorch.jni.LibUtils.loadNativeLibrary(LibUtils.java:379); 	at ai.djl.pytorch.jni.LibUtils.loadLibTorch(LibUtils.java:176); 	at ai.djl.pytorch.jni.LibUtils.loadLibrary(LibUtils.java:82); 	at ai.djl.pytorch.engine.PtEngine.newInstance(PtEngine.java:53); 	... 15 more`,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636
https://github.com/qupath/qupath/issues/1636:2363,Performance,load,loadNativeLibrary,2363,lambda$getEngineOnline$0(PytorchManager.java:28); 	at qupath.ext.instanseg.core.PytorchManager.callWithTempProperty(PytorchManager.java:114); 	at qupath.ext.instanseg.core.PytorchManager.callOnline(PytorchManager.java:106); 	at qupath.ext.instanseg.core.PytorchManager.getEngineOnline(PytorchManager.java:28); 	at qupath.ext.instanseg.ui.InstanSegController.downloadPyTorch(InstanSegController.java:826); 	at qupath.ext.instanseg.ui.InstanSegController.ensurePyTorchAvailable(InstanSegController.java:815); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.scan(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source); Caused by: java.lang.UnsatisfiedLinkError: C:\Users\username\.djl.ai\pytorch\2.3.1-cu121-win-x86_64\cudnn_cnn_infer64_8.dll: The specified procedure could not be found; 	at java.base/jdk.internal.loader.NativeLibraries.load(Native Method); 	at java.base/jdk.internal.loader.NativeLibraries$NativeLibraryImpl.open(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/java.lang.ClassLoader.loadLibrary(Unknown Source); 	at java.base/java.lang.Runtime.load0(Unknown Source); 	at java.base/java.lang.System.load(Unknown Source); 	at ai.djl.pytorch.jni.LibUtils.loadNativeLibrary(LibUtils.java:379); 	at ai.djl.pytorch.jni.LibUtils.loadLibTorch(LibUtils.java:176); 	at ai.djl.pytorch.jni.LibUtils.loadLibrary(LibUtils.java:82); 	at ai.djl.pytorch.engine.PtEngine.newInstance(PtEngine.java:53); 	... 15 more`,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636
https://github.com/qupath/qupath/issues/1636:2433,Performance,load,loadLibTorch,2433,lambda$getEngineOnline$0(PytorchManager.java:28); 	at qupath.ext.instanseg.core.PytorchManager.callWithTempProperty(PytorchManager.java:114); 	at qupath.ext.instanseg.core.PytorchManager.callOnline(PytorchManager.java:106); 	at qupath.ext.instanseg.core.PytorchManager.getEngineOnline(PytorchManager.java:28); 	at qupath.ext.instanseg.ui.InstanSegController.downloadPyTorch(InstanSegController.java:826); 	at qupath.ext.instanseg.ui.InstanSegController.ensurePyTorchAvailable(InstanSegController.java:815); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.scan(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source); Caused by: java.lang.UnsatisfiedLinkError: C:\Users\username\.djl.ai\pytorch\2.3.1-cu121-win-x86_64\cudnn_cnn_infer64_8.dll: The specified procedure could not be found; 	at java.base/jdk.internal.loader.NativeLibraries.load(Native Method); 	at java.base/jdk.internal.loader.NativeLibraries$NativeLibraryImpl.open(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/java.lang.ClassLoader.loadLibrary(Unknown Source); 	at java.base/java.lang.Runtime.load0(Unknown Source); 	at java.base/java.lang.System.load(Unknown Source); 	at ai.djl.pytorch.jni.LibUtils.loadNativeLibrary(LibUtils.java:379); 	at ai.djl.pytorch.jni.LibUtils.loadLibTorch(LibUtils.java:176); 	at ai.djl.pytorch.jni.LibUtils.loadLibrary(LibUtils.java:82); 	at ai.djl.pytorch.engine.PtEngine.newInstance(PtEngine.java:53); 	... 15 more`,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636
https://github.com/qupath/qupath/issues/1636:2498,Performance,load,loadLibrary,2498,lambda$getEngineOnline$0(PytorchManager.java:28); 	at qupath.ext.instanseg.core.PytorchManager.callWithTempProperty(PytorchManager.java:114); 	at qupath.ext.instanseg.core.PytorchManager.callOnline(PytorchManager.java:106); 	at qupath.ext.instanseg.core.PytorchManager.getEngineOnline(PytorchManager.java:28); 	at qupath.ext.instanseg.ui.InstanSegController.downloadPyTorch(InstanSegController.java:826); 	at qupath.ext.instanseg.ui.InstanSegController.ensurePyTorchAvailable(InstanSegController.java:815); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.scan(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source); Caused by: java.lang.UnsatisfiedLinkError: C:\Users\username\.djl.ai\pytorch\2.3.1-cu121-win-x86_64\cudnn_cnn_infer64_8.dll: The specified procedure could not be found; 	at java.base/jdk.internal.loader.NativeLibraries.load(Native Method); 	at java.base/jdk.internal.loader.NativeLibraries$NativeLibraryImpl.open(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/jdk.internal.loader.NativeLibraries.loadLibrary(Unknown Source); 	at java.base/java.lang.ClassLoader.loadLibrary(Unknown Source); 	at java.base/java.lang.Runtime.load0(Unknown Source); 	at java.base/java.lang.System.load(Unknown Source); 	at ai.djl.pytorch.jni.LibUtils.loadNativeLibrary(LibUtils.java:379); 	at ai.djl.pytorch.jni.LibUtils.loadLibTorch(LibUtils.java:176); 	at ai.djl.pytorch.jni.LibUtils.loadLibrary(LibUtils.java:82); 	at ai.djl.pytorch.engine.PtEngine.newInstance(PtEngine.java:53); 	... 15 more`,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636
https://github.com/qupath/qupath/issues/1636:172,Safety,detect,detects,172,"I cannot make pytorch work. I tried also with a conda env but nothing works. Even if I just select CPU in Instantseg, it tries to load the cuda version. Problem is that it detects cuda 12.1 so maybe it does not even want to try to load the CPU version?. `Failed to load PyTorch native library; ai.djl.engine.EngineException: Failed to load PyTorch native library; 	at ai.djl.pytorch.engine.PtEngine.newInstance(PtEngine.java:90); 	at ai.djl.pytorch.engine.PtEngineProvider.getEngine(PtEngineProvider.java:41); 	at ai.djl.engine.Engine.getEngine(Engine.java:190); 	at qupath.ext.instanseg.core.PytorchManager.lambda$getEngineOnline$0(PytorchManager.java:28); 	at qupath.ext.instanseg.core.PytorchManager.callWithTempProperty(PytorchManager.java:114); 	at qupath.ext.instanseg.core.PytorchManager.callOnline(PytorchManager.java:106); 	at qupath.ext.instanseg.core.PytorchManager.getEngineOnline(PytorchManager.java:28); 	at qupath.ext.instanseg.ui.InstanSegController.downloadPyTorch(InstanSegController.java:826); 	at qupath.ext.instanseg.ui.InstanSegController.ensurePyTorchAvailable(InstanSegController.java:815); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source); 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.scan(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source); 	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source); Caused by: java.lang.UnsatisfiedLinkError: C:\Users\username\.djl.ai\pytorch\2.3.1-cu121-win-x86_64\cudnn_cnn_infer64_8.dll: The specified procedure could not be found; 	at java.base/jdk.internal.loader.NativeLibraries.load(Native Method); 	at java.base/jdk.internal.loader.NativeLibraries$NativeLibraryImpl.open(Unknown Source); 	",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636
https://github.com/qupath/qupath/pull/1638:264,Usability,usab,usable,264,First steps to handle remote OME-Zarr. See https://forum.image.sc/t/qupath-0-6-0rc1-unable-to-read-remote-ome-zarr-by-url/101605 for details. This currently 'works' for https://uk1s3.embassy.ebi.ac.uk/idr/zarr/v0.4/idr0073A/9798462.zarr but is too slow to be very usable.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1638
https://github.com/qupath/qupath/pull/1639:231,Availability,mask,mask,231,"Addresses https://github.com/qupath/qupath-extension-instanseg/issues/88. It feels awkward to use a static `WeakHashMap` but it seems the easiest way to solve the performance issue without complicating the API with more methods to mask objects (taking `Geometry` or `PreparedGeometry`). With this change, the original problematic image becomes bound by the inference speed rather than the geometry operations - as it should be.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1639
https://github.com/qupath/qupath/pull/1639:163,Performance,perform,performance,163,"Addresses https://github.com/qupath/qupath-extension-instanseg/issues/88. It feels awkward to use a static `WeakHashMap` but it seems the easiest way to solve the performance issue without complicating the API with more methods to mask objects (taking `Geometry` or `PreparedGeometry`). With this change, the original problematic image becomes bound by the inference speed rather than the geometry operations - as it should be.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1639
https://github.com/qupath/qupath/issues/1640:95,Deployability,Install,Installed,95,"Hi,. I spend a few hours to get the Deep Java Library, PyTorch to work. And I did not succeed. Installed Cuda 11.8 and cudnn 11.x. Made a python env with mamba, created the launcher. Changed my System Path. And finaly it seemed to work. But:. ai.djl.pytorch.jni.LibUtils - No matching cuda flavor for win-x86_64 found: cu118. Looked at all forums and searched the internet. I am sorry to say, but I give up. There is just no way to get this running easily it seems. So no InstanSeg and other Deep Learning models that depend on this Deep Java Library for me. . There just must be a way to make it work more easily. Maybe just use the python version (like BIOP/Cellpose does). In that case you depend on a single python environment!. Best, Ron",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1640
https://github.com/qupath/qupath/issues/1640:518,Integrability,depend,depend,518,"Hi,. I spend a few hours to get the Deep Java Library, PyTorch to work. And I did not succeed. Installed Cuda 11.8 and cudnn 11.x. Made a python env with mamba, created the launcher. Changed my System Path. And finaly it seemed to work. But:. ai.djl.pytorch.jni.LibUtils - No matching cuda flavor for win-x86_64 found: cu118. Looked at all forums and searched the internet. I am sorry to say, but I give up. There is just no way to get this running easily it seems. So no InstanSeg and other Deep Learning models that depend on this Deep Java Library for me. . There just must be a way to make it work more easily. Maybe just use the python version (like BIOP/Cellpose does). In that case you depend on a single python environment!. Best, Ron",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1640
https://github.com/qupath/qupath/issues/1640:693,Integrability,depend,depend,693,"Hi,. I spend a few hours to get the Deep Java Library, PyTorch to work. And I did not succeed. Installed Cuda 11.8 and cudnn 11.x. Made a python env with mamba, created the launcher. Changed my System Path. And finaly it seemed to work. But:. ai.djl.pytorch.jni.LibUtils - No matching cuda flavor for win-x86_64 found: cu118. Looked at all forums and searched the internet. I am sorry to say, but I give up. There is just no way to get this running easily it seems. So no InstanSeg and other Deep Learning models that depend on this Deep Java Library for me. . There just must be a way to make it work more easily. Maybe just use the python version (like BIOP/Cellpose does). In that case you depend on a single python environment!. Best, Ron",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1640
https://github.com/qupath/qupath/issues/1640:497,Usability,Learn,Learning,497,"Hi,. I spend a few hours to get the Deep Java Library, PyTorch to work. And I did not succeed. Installed Cuda 11.8 and cudnn 11.x. Made a python env with mamba, created the launcher. Changed my System Path. And finaly it seemed to work. But:. ai.djl.pytorch.jni.LibUtils - No matching cuda flavor for win-x86_64 found: cu118. Looked at all forums and searched the internet. I am sorry to say, but I give up. There is just no way to get this running easily it seems. So no InstanSeg and other Deep Learning models that depend on this Deep Java Library for me. . There just must be a way to make it work more easily. Maybe just use the python version (like BIOP/Cellpose does). In that case you depend on a single python environment!. Best, Ron",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1640
https://github.com/qupath/qupath/pull/1641:32,Testability,Test,TestConvertCommand,32,"* Cleaned up images created by `TestConvertCommand`.; * In `ConvertCommand`, deleted existing output directories whenever `—overwrite` is specified.; * Created `image.zarr/OME/METADATA.ome.xml` in Zarr writer. This allows to save the entire QuPath metadata of images.; * Added tests for the Zarr writer.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1641
https://github.com/qupath/qupath/pull/1641:277,Testability,test,tests,277,"* Cleaned up images created by `TestConvertCommand`.; * In `ConvertCommand`, deleted existing output directories whenever `—overwrite` is specified.; * Created `image.zarr/OME/METADATA.ome.xml` in Zarr writer. This allows to save the entire QuPath metadata of images.; * Added tests for the Zarr writer.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1641
https://github.com/qupath/qupath/pull/1643:1165,Safety,avoid,avoid,1165,"Tests were failing when Gradle was run using Java 17 on Windows, e.g.; ```; org.opentest4j.AssertionFailedError: expected: <µm> but was: <Âµm>; 	at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151); 	at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132); 	at app//org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:197); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:182); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:177); 	at app//org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:1145); 	at app//qupath.lib.images.writers.ome.zarr.TestOMEXMLCreator.Check_Pixel_Height_Unit(TestOMEXMLCreator.java:216); 	at java.base@21.0.4/java.lang.reflect.Method.invoke(Method.java:580); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); ```. I'm not convinced this is the right way to address it, and it shouldn't matter in practice since QuPath now assumes Java 21 (where UTF-8 is the default), but it helps avoid exceptions for users building with Gradle launched using an earlier Java version - which should be possible.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1643
https://github.com/qupath/qupath/pull/1643:0,Testability,Test,Tests,0,"Tests were failing when Gradle was run using Java 17 on Windows, e.g.; ```; org.opentest4j.AssertionFailedError: expected: <µm> but was: <Âµm>; 	at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151); 	at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132); 	at app//org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:197); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:182); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:177); 	at app//org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:1145); 	at app//qupath.lib.images.writers.ome.zarr.TestOMEXMLCreator.Check_Pixel_Height_Unit(TestOMEXMLCreator.java:216); 	at java.base@21.0.4/java.lang.reflect.Method.invoke(Method.java:580); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); ```. I'm not convinced this is the right way to address it, and it shouldn't matter in practice since QuPath now assumes Java 21 (where UTF-8 is the default), but it helps avoid exceptions for users building with Gradle launched using an earlier Java version - which should be possible.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1643
https://github.com/qupath/qupath/pull/1643:91,Testability,Assert,AssertionFailedError,91,"Tests were failing when Gradle was run using Java 17 on Windows, e.g.; ```; org.opentest4j.AssertionFailedError: expected: <µm> but was: <Âµm>; 	at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151); 	at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132); 	at app//org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:197); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:182); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:177); 	at app//org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:1145); 	at app//qupath.lib.images.writers.ome.zarr.TestOMEXMLCreator.Check_Pixel_Height_Unit(TestOMEXMLCreator.java:216); 	at java.base@21.0.4/java.lang.reflect.Method.invoke(Method.java:580); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); ```. I'm not convinced this is the right way to address it, and it shouldn't matter in practice since QuPath now assumes Java 21 (where UTF-8 is the default), but it helps avoid exceptions for users building with Gradle launched using an earlier Java version - which should be possible.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1643
https://github.com/qupath/qupath/pull/1643:175,Testability,Assert,AssertionFailureBuilder,175,"Tests were failing when Gradle was run using Java 17 on Windows, e.g.; ```; org.opentest4j.AssertionFailedError: expected: <µm> but was: <Âµm>; 	at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151); 	at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132); 	at app//org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:197); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:182); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:177); 	at app//org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:1145); 	at app//qupath.lib.images.writers.ome.zarr.TestOMEXMLCreator.Check_Pixel_Height_Unit(TestOMEXMLCreator.java:216); 	at java.base@21.0.4/java.lang.reflect.Method.invoke(Method.java:580); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); ```. I'm not convinced this is the right way to address it, and it shouldn't matter in practice since QuPath now assumes Java 21 (where UTF-8 is the default), but it helps avoid exceptions for users building with Gradle launched using an earlier Java version - which should be possible.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1643
https://github.com/qupath/qupath/pull/1643:205,Testability,Assert,AssertionFailureBuilder,205,"Tests were failing when Gradle was run using Java 17 on Windows, e.g.; ```; org.opentest4j.AssertionFailedError: expected: <µm> but was: <Âµm>; 	at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151); 	at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132); 	at app//org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:197); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:182); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:177); 	at app//org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:1145); 	at app//qupath.lib.images.writers.ome.zarr.TestOMEXMLCreator.Check_Pixel_Height_Unit(TestOMEXMLCreator.java:216); 	at java.base@21.0.4/java.lang.reflect.Method.invoke(Method.java:580); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); ```. I'm not convinced this is the right way to address it, and it shouldn't matter in practice since QuPath now assumes Java 21 (where UTF-8 is the default), but it helps avoid exceptions for users building with Gradle launched using an earlier Java version - which should be possible.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1643
https://github.com/qupath/qupath/pull/1643:271,Testability,Assert,AssertionFailureBuilder,271,"Tests were failing when Gradle was run using Java 17 on Windows, e.g.; ```; org.opentest4j.AssertionFailedError: expected: <µm> but was: <Âµm>; 	at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151); 	at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132); 	at app//org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:197); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:182); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:177); 	at app//org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:1145); 	at app//qupath.lib.images.writers.ome.zarr.TestOMEXMLCreator.Check_Pixel_Height_Unit(TestOMEXMLCreator.java:216); 	at java.base@21.0.4/java.lang.reflect.Method.invoke(Method.java:580); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); ```. I'm not convinced this is the right way to address it, and it shouldn't matter in practice since QuPath now assumes Java 21 (where UTF-8 is the default), but it helps avoid exceptions for users building with Gradle launched using an earlier Java version - which should be possible.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1643
https://github.com/qupath/qupath/pull/1643:309,Testability,Assert,AssertionFailureBuilder,309,"Tests were failing when Gradle was run using Java 17 on Windows, e.g.; ```; org.opentest4j.AssertionFailedError: expected: <µm> but was: <Âµm>; 	at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151); 	at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132); 	at app//org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:197); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:182); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:177); 	at app//org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:1145); 	at app//qupath.lib.images.writers.ome.zarr.TestOMEXMLCreator.Check_Pixel_Height_Unit(TestOMEXMLCreator.java:216); 	at java.base@21.0.4/java.lang.reflect.Method.invoke(Method.java:580); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); ```. I'm not convinced this is the right way to address it, and it shouldn't matter in practice since QuPath now assumes Java 21 (where UTF-8 is the default), but it helps avoid exceptions for users building with Gradle launched using an earlier Java version - which should be possible.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1643
https://github.com/qupath/qupath/pull/1643:375,Testability,Assert,AssertEquals,375,"Tests were failing when Gradle was run using Java 17 on Windows, e.g.; ```; org.opentest4j.AssertionFailedError: expected: <µm> but was: <Âµm>; 	at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151); 	at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132); 	at app//org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:197); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:182); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:177); 	at app//org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:1145); 	at app//qupath.lib.images.writers.ome.zarr.TestOMEXMLCreator.Check_Pixel_Height_Unit(TestOMEXMLCreator.java:216); 	at java.base@21.0.4/java.lang.reflect.Method.invoke(Method.java:580); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); ```. I'm not convinced this is the right way to address it, and it shouldn't matter in practice since QuPath now assumes Java 21 (where UTF-8 is the default), but it helps avoid exceptions for users building with Gradle launched using an earlier Java version - which should be possible.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1643
https://github.com/qupath/qupath/pull/1643:401,Testability,Assert,AssertEquals,401,"Tests were failing when Gradle was run using Java 17 on Windows, e.g.; ```; org.opentest4j.AssertionFailedError: expected: <µm> but was: <Âµm>; 	at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151); 	at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132); 	at app//org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:197); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:182); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:177); 	at app//org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:1145); 	at app//qupath.lib.images.writers.ome.zarr.TestOMEXMLCreator.Check_Pixel_Height_Unit(TestOMEXMLCreator.java:216); 	at java.base@21.0.4/java.lang.reflect.Method.invoke(Method.java:580); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); ```. I'm not convinced this is the right way to address it, and it shouldn't matter in practice since QuPath now assumes Java 21 (where UTF-8 is the default), but it helps avoid exceptions for users building with Gradle launched using an earlier Java version - which should be possible.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1643
https://github.com/qupath/qupath/pull/1643:456,Testability,Assert,AssertEquals,456,"Tests were failing when Gradle was run using Java 17 on Windows, e.g.; ```; org.opentest4j.AssertionFailedError: expected: <µm> but was: <Âµm>; 	at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151); 	at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132); 	at app//org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:197); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:182); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:177); 	at app//org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:1145); 	at app//qupath.lib.images.writers.ome.zarr.TestOMEXMLCreator.Check_Pixel_Height_Unit(TestOMEXMLCreator.java:216); 	at java.base@21.0.4/java.lang.reflect.Method.invoke(Method.java:580); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); ```. I'm not convinced this is the right way to address it, and it shouldn't matter in practice since QuPath now assumes Java 21 (where UTF-8 is the default), but it helps avoid exceptions for users building with Gradle launched using an earlier Java version - which should be possible.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1643
https://github.com/qupath/qupath/pull/1643:469,Testability,assert,assertEquals,469,"Tests were failing when Gradle was run using Java 17 on Windows, e.g.; ```; org.opentest4j.AssertionFailedError: expected: <µm> but was: <Âµm>; 	at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151); 	at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132); 	at app//org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:197); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:182); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:177); 	at app//org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:1145); 	at app//qupath.lib.images.writers.ome.zarr.TestOMEXMLCreator.Check_Pixel_Height_Unit(TestOMEXMLCreator.java:216); 	at java.base@21.0.4/java.lang.reflect.Method.invoke(Method.java:580); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); ```. I'm not convinced this is the right way to address it, and it shouldn't matter in practice since QuPath now assumes Java 21 (where UTF-8 is the default), but it helps avoid exceptions for users building with Gradle launched using an earlier Java version - which should be possible.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1643
https://github.com/qupath/qupath/pull/1643:482,Testability,Assert,AssertEquals,482,"Tests were failing when Gradle was run using Java 17 on Windows, e.g.; ```; org.opentest4j.AssertionFailedError: expected: <µm> but was: <Âµm>; 	at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151); 	at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132); 	at app//org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:197); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:182); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:177); 	at app//org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:1145); 	at app//qupath.lib.images.writers.ome.zarr.TestOMEXMLCreator.Check_Pixel_Height_Unit(TestOMEXMLCreator.java:216); 	at java.base@21.0.4/java.lang.reflect.Method.invoke(Method.java:580); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); ```. I'm not convinced this is the right way to address it, and it shouldn't matter in practice since QuPath now assumes Java 21 (where UTF-8 is the default), but it helps avoid exceptions for users building with Gradle launched using an earlier Java version - which should be possible.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1643
https://github.com/qupath/qupath/pull/1643:537,Testability,Assert,AssertEquals,537,"Tests were failing when Gradle was run using Java 17 on Windows, e.g.; ```; org.opentest4j.AssertionFailedError: expected: <µm> but was: <Âµm>; 	at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151); 	at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132); 	at app//org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:197); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:182); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:177); 	at app//org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:1145); 	at app//qupath.lib.images.writers.ome.zarr.TestOMEXMLCreator.Check_Pixel_Height_Unit(TestOMEXMLCreator.java:216); 	at java.base@21.0.4/java.lang.reflect.Method.invoke(Method.java:580); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); ```. I'm not convinced this is the right way to address it, and it shouldn't matter in practice since QuPath now assumes Java 21 (where UTF-8 is the default), but it helps avoid exceptions for users building with Gradle launched using an earlier Java version - which should be possible.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1643
https://github.com/qupath/qupath/pull/1643:550,Testability,assert,assertEquals,550,"Tests were failing when Gradle was run using Java 17 on Windows, e.g.; ```; org.opentest4j.AssertionFailedError: expected: <µm> but was: <Âµm>; 	at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151); 	at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132); 	at app//org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:197); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:182); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:177); 	at app//org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:1145); 	at app//qupath.lib.images.writers.ome.zarr.TestOMEXMLCreator.Check_Pixel_Height_Unit(TestOMEXMLCreator.java:216); 	at java.base@21.0.4/java.lang.reflect.Method.invoke(Method.java:580); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); ```. I'm not convinced this is the right way to address it, and it shouldn't matter in practice since QuPath now assumes Java 21 (where UTF-8 is the default), but it helps avoid exceptions for users building with Gradle launched using an earlier Java version - which should be possible.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1643
https://github.com/qupath/qupath/pull/1643:563,Testability,Assert,AssertEquals,563,"Tests were failing when Gradle was run using Java 17 on Windows, e.g.; ```; org.opentest4j.AssertionFailedError: expected: <µm> but was: <Âµm>; 	at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151); 	at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132); 	at app//org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:197); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:182); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:177); 	at app//org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:1145); 	at app//qupath.lib.images.writers.ome.zarr.TestOMEXMLCreator.Check_Pixel_Height_Unit(TestOMEXMLCreator.java:216); 	at java.base@21.0.4/java.lang.reflect.Method.invoke(Method.java:580); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); ```. I'm not convinced this is the right way to address it, and it shouldn't matter in practice since QuPath now assumes Java 21 (where UTF-8 is the default), but it helps avoid exceptions for users building with Gradle launched using an earlier Java version - which should be possible.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1643
https://github.com/qupath/qupath/pull/1643:618,Testability,Assert,Assertions,618,"Tests were failing when Gradle was run using Java 17 on Windows, e.g.; ```; org.opentest4j.AssertionFailedError: expected: <µm> but was: <Âµm>; 	at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151); 	at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132); 	at app//org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:197); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:182); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:177); 	at app//org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:1145); 	at app//qupath.lib.images.writers.ome.zarr.TestOMEXMLCreator.Check_Pixel_Height_Unit(TestOMEXMLCreator.java:216); 	at java.base@21.0.4/java.lang.reflect.Method.invoke(Method.java:580); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); ```. I'm not convinced this is the right way to address it, and it shouldn't matter in practice since QuPath now assumes Java 21 (where UTF-8 is the default), but it helps avoid exceptions for users building with Gradle launched using an earlier Java version - which should be possible.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1643
https://github.com/qupath/qupath/pull/1643:629,Testability,assert,assertEquals,629,"Tests were failing when Gradle was run using Java 17 on Windows, e.g.; ```; org.opentest4j.AssertionFailedError: expected: <µm> but was: <Âµm>; 	at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151); 	at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132); 	at app//org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:197); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:182); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:177); 	at app//org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:1145); 	at app//qupath.lib.images.writers.ome.zarr.TestOMEXMLCreator.Check_Pixel_Height_Unit(TestOMEXMLCreator.java:216); 	at java.base@21.0.4/java.lang.reflect.Method.invoke(Method.java:580); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); ```. I'm not convinced this is the right way to address it, and it shouldn't matter in practice since QuPath now assumes Java 21 (where UTF-8 is the default), but it helps avoid exceptions for users building with Gradle launched using an earlier Java version - which should be possible.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1643
https://github.com/qupath/qupath/pull/1643:642,Testability,Assert,Assertions,642,"Tests were failing when Gradle was run using Java 17 on Windows, e.g.; ```; org.opentest4j.AssertionFailedError: expected: <µm> but was: <Âµm>; 	at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151); 	at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132); 	at app//org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:197); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:182); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:177); 	at app//org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:1145); 	at app//qupath.lib.images.writers.ome.zarr.TestOMEXMLCreator.Check_Pixel_Height_Unit(TestOMEXMLCreator.java:216); 	at java.base@21.0.4/java.lang.reflect.Method.invoke(Method.java:580); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); ```. I'm not convinced this is the right way to address it, and it shouldn't matter in practice since QuPath now assumes Java 21 (where UTF-8 is the default), but it helps avoid exceptions for users building with Gradle launched using an earlier Java version - which should be possible.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1643
https://github.com/qupath/qupath/pull/1643:709,Testability,Test,TestOMEXMLCreator,709,"Tests were failing when Gradle was run using Java 17 on Windows, e.g.; ```; org.opentest4j.AssertionFailedError: expected: <µm> but was: <Âµm>; 	at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151); 	at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132); 	at app//org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:197); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:182); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:177); 	at app//org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:1145); 	at app//qupath.lib.images.writers.ome.zarr.TestOMEXMLCreator.Check_Pixel_Height_Unit(TestOMEXMLCreator.java:216); 	at java.base@21.0.4/java.lang.reflect.Method.invoke(Method.java:580); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); ```. I'm not convinced this is the right way to address it, and it shouldn't matter in practice since QuPath now assumes Java 21 (where UTF-8 is the default), but it helps avoid exceptions for users building with Gradle launched using an earlier Java version - which should be possible.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1643
https://github.com/qupath/qupath/pull/1643:751,Testability,Test,TestOMEXMLCreator,751,"Tests were failing when Gradle was run using Java 17 on Windows, e.g.; ```; org.opentest4j.AssertionFailedError: expected: <µm> but was: <Âµm>; 	at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151); 	at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132); 	at app//org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:197); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:182); 	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:177); 	at app//org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:1145); 	at app//qupath.lib.images.writers.ome.zarr.TestOMEXMLCreator.Check_Pixel_Height_Unit(TestOMEXMLCreator.java:216); 	at java.base@21.0.4/java.lang.reflect.Method.invoke(Method.java:580); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); 	at java.base@21.0.4/java.util.ArrayList.forEach(ArrayList.java:1596); ```. I'm not convinced this is the right way to address it, and it shouldn't matter in practice since QuPath now assumes Java 21 (where UTF-8 is the default), but it helps avoid exceptions for users building with Gradle launched using an earlier Java version - which should be possible.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1643
https://github.com/qupath/qupath/pull/1645:802,Availability,down,downloads,802,"**TLDR**: the default tile size of the BioFormatsImageServer is too low, which makes reading remote Zarr too slow. This PR fixes that. Zarr images are slow to read. This is more visible for remote images. For example, the image https://uk1s3.embassy.ebi.ac.uk/idr/zarr/v0.4/idr0073A/9798462.zarr takes way more time to open in QuPath than when using [vizarr](https://hms-dbmi.github.io/vizarr/?source=https://uk1s3.embassy.ebi.ac.uk/idr/zarr/v0.4/idr0073A/9798462.zarr). Zarr images are divided into chunks, where each chunk contains pixel values in a dedicated file. When using [HTTP Toolkit](https://httptoolkit.com/) when opening a remote Zarr image in QuPath, we see that the underlying BioFormats readers make several web requests to the same chunk. With the example image mentioned above, QuPath downloads each chunk around 8 times, which is useless. This means that when opening the image through QuPath, around 320 web requests are made, while there should only be around 40 requests. The reason is because of the tile size. The tile size should correspond to the chunk size, but it's not always the case. Before this PR, the tile size corresponded to the chunk size of the lowest resolution. For example with the image above, the tile size was 164 * 128 pixels (which corresponds to the chunk size of the lowest resolution image), but the chunk size of the full resolution image is 1024 * 1024 pixels. This means that to read one chunk of the full resolution image, QuPath will make several readings, and each reading will download the entire chunk of 1024*1024 pixels, thus the same file will be downloaded several times. Therefore, to fix the issue, we must fix the tile size. The tile size is determined from the BioFormats reader's `getOptimalTileWidth()` and `getOptimalTileHeight()` functions. By default, they return the chunk size of the lowest resolution image. I found a workaround to get the chunk size of the full resolution image: we must set the resolution to 0 (full resolution",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1645
https://github.com/qupath/qupath/pull/1645:1532,Availability,down,download,1532,"n in QuPath than when using [vizarr](https://hms-dbmi.github.io/vizarr/?source=https://uk1s3.embassy.ebi.ac.uk/idr/zarr/v0.4/idr0073A/9798462.zarr). Zarr images are divided into chunks, where each chunk contains pixel values in a dedicated file. When using [HTTP Toolkit](https://httptoolkit.com/) when opening a remote Zarr image in QuPath, we see that the underlying BioFormats readers make several web requests to the same chunk. With the example image mentioned above, QuPath downloads each chunk around 8 times, which is useless. This means that when opening the image through QuPath, around 320 web requests are made, while there should only be around 40 requests. The reason is because of the tile size. The tile size should correspond to the chunk size, but it's not always the case. Before this PR, the tile size corresponded to the chunk size of the lowest resolution. For example with the image above, the tile size was 164 * 128 pixels (which corresponds to the chunk size of the lowest resolution image), but the chunk size of the full resolution image is 1024 * 1024 pixels. This means that to read one chunk of the full resolution image, QuPath will make several readings, and each reading will download the entire chunk of 1024*1024 pixels, thus the same file will be downloaded several times. Therefore, to fix the issue, we must fix the tile size. The tile size is determined from the BioFormats reader's `getOptimalTileWidth()` and `getOptimalTileHeight()` functions. By default, they return the chunk size of the lowest resolution image. I found a workaround to get the chunk size of the full resolution image: we must set the resolution to 0 (full resolution) with the Zarr reader. After that, `getOptimalTileWidth()` and `getOptimalTileHeight()` return the chunk size of the full resolution image. This PR is only implementing this. To see that it works, you can start HTTP Toolkit, open the sample image with QuPath, and compare the number of requests with and without this PR.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1645
https://github.com/qupath/qupath/pull/1645:1606,Availability,down,downloaded,1606,"n in QuPath than when using [vizarr](https://hms-dbmi.github.io/vizarr/?source=https://uk1s3.embassy.ebi.ac.uk/idr/zarr/v0.4/idr0073A/9798462.zarr). Zarr images are divided into chunks, where each chunk contains pixel values in a dedicated file. When using [HTTP Toolkit](https://httptoolkit.com/) when opening a remote Zarr image in QuPath, we see that the underlying BioFormats readers make several web requests to the same chunk. With the example image mentioned above, QuPath downloads each chunk around 8 times, which is useless. This means that when opening the image through QuPath, around 320 web requests are made, while there should only be around 40 requests. The reason is because of the tile size. The tile size should correspond to the chunk size, but it's not always the case. Before this PR, the tile size corresponded to the chunk size of the lowest resolution. For example with the image above, the tile size was 164 * 128 pixels (which corresponds to the chunk size of the lowest resolution image), but the chunk size of the full resolution image is 1024 * 1024 pixels. This means that to read one chunk of the full resolution image, QuPath will make several readings, and each reading will download the entire chunk of 1024*1024 pixels, thus the same file will be downloaded several times. Therefore, to fix the issue, we must fix the tile size. The tile size is determined from the BioFormats reader's `getOptimalTileWidth()` and `getOptimalTileHeight()` functions. By default, they return the chunk size of the lowest resolution image. I found a workaround to get the chunk size of the full resolution image: we must set the resolution to 0 (full resolution) with the Zarr reader. After that, `getOptimalTileWidth()` and `getOptimalTileHeight()` return the chunk size of the full resolution image. This PR is only implementing this. To see that it works, you can start HTTP Toolkit, open the sample image with QuPath, and compare the number of requests with and without this PR.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1645
https://github.com/qupath/qupath/issues/1646:270,Energy Efficiency,monitor,monitor,270,"I am using the portable version QuPath-v0.5.0-Windows, on a 64bit Windows machine. In a project with several images (each between 1.5 and 2GB), when I open one image then open a new image, the RAM used from 1st image stays and is not ""freed"". When looking at the Memory monitor of QUpath, if I press ""clear tile cache"", it will decrease the ""Used memory"", but the ""total memory"" stays the same. So basically, even when clearing tile cache, the RAM is taken up is growing little by little at a point where I have to close Qupath and restart. I don't think that this is an expected behavior. ; Also if just going back and forth between the same 2 images, loading is faster if tiled are created (normal) but it will increases the number of cached tiles and increases total RAM (but at some point not anymore, which is even more strange). . Reclaim memory also does not completely free the RAM.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1646
https://github.com/qupath/qupath/issues/1646:15,Modifiability,portab,portable,15,"I am using the portable version QuPath-v0.5.0-Windows, on a 64bit Windows machine. In a project with several images (each between 1.5 and 2GB), when I open one image then open a new image, the RAM used from 1st image stays and is not ""freed"". When looking at the Memory monitor of QUpath, if I press ""clear tile cache"", it will decrease the ""Used memory"", but the ""total memory"" stays the same. So basically, even when clearing tile cache, the RAM is taken up is growing little by little at a point where I have to close Qupath and restart. I don't think that this is an expected behavior. ; Also if just going back and forth between the same 2 images, loading is faster if tiled are created (normal) but it will increases the number of cached tiles and increases total RAM (but at some point not anymore, which is even more strange). . Reclaim memory also does not completely free the RAM.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1646
https://github.com/qupath/qupath/issues/1646:312,Performance,cache,cache,312,"I am using the portable version QuPath-v0.5.0-Windows, on a 64bit Windows machine. In a project with several images (each between 1.5 and 2GB), when I open one image then open a new image, the RAM used from 1st image stays and is not ""freed"". When looking at the Memory monitor of QUpath, if I press ""clear tile cache"", it will decrease the ""Used memory"", but the ""total memory"" stays the same. So basically, even when clearing tile cache, the RAM is taken up is growing little by little at a point where I have to close Qupath and restart. I don't think that this is an expected behavior. ; Also if just going back and forth between the same 2 images, loading is faster if tiled are created (normal) but it will increases the number of cached tiles and increases total RAM (but at some point not anymore, which is even more strange). . Reclaim memory also does not completely free the RAM.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1646
https://github.com/qupath/qupath/issues/1646:433,Performance,cache,cache,433,"I am using the portable version QuPath-v0.5.0-Windows, on a 64bit Windows machine. In a project with several images (each between 1.5 and 2GB), when I open one image then open a new image, the RAM used from 1st image stays and is not ""freed"". When looking at the Memory monitor of QUpath, if I press ""clear tile cache"", it will decrease the ""Used memory"", but the ""total memory"" stays the same. So basically, even when clearing tile cache, the RAM is taken up is growing little by little at a point where I have to close Qupath and restart. I don't think that this is an expected behavior. ; Also if just going back and forth between the same 2 images, loading is faster if tiled are created (normal) but it will increases the number of cached tiles and increases total RAM (but at some point not anymore, which is even more strange). . Reclaim memory also does not completely free the RAM.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1646
https://github.com/qupath/qupath/issues/1646:653,Performance,load,loading,653,"I am using the portable version QuPath-v0.5.0-Windows, on a 64bit Windows machine. In a project with several images (each between 1.5 and 2GB), when I open one image then open a new image, the RAM used from 1st image stays and is not ""freed"". When looking at the Memory monitor of QUpath, if I press ""clear tile cache"", it will decrease the ""Used memory"", but the ""total memory"" stays the same. So basically, even when clearing tile cache, the RAM is taken up is growing little by little at a point where I have to close Qupath and restart. I don't think that this is an expected behavior. ; Also if just going back and forth between the same 2 images, loading is faster if tiled are created (normal) but it will increases the number of cached tiles and increases total RAM (but at some point not anymore, which is even more strange). . Reclaim memory also does not completely free the RAM.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1646
https://github.com/qupath/qupath/issues/1646:737,Performance,cache,cached,737,"I am using the portable version QuPath-v0.5.0-Windows, on a 64bit Windows machine. In a project with several images (each between 1.5 and 2GB), when I open one image then open a new image, the RAM used from 1st image stays and is not ""freed"". When looking at the Memory monitor of QUpath, if I press ""clear tile cache"", it will decrease the ""Used memory"", but the ""total memory"" stays the same. So basically, even when clearing tile cache, the RAM is taken up is growing little by little at a point where I have to close Qupath and restart. I don't think that this is an expected behavior. ; Also if just going back and forth between the same 2 images, loading is faster if tiled are created (normal) but it will increases the number of cached tiles and increases total RAM (but at some point not anymore, which is even more strange). . Reclaim memory also does not completely free the RAM.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1646
https://github.com/qupath/qupath/issues/1646:301,Usability,clear,clear,301,"I am using the portable version QuPath-v0.5.0-Windows, on a 64bit Windows machine. In a project with several images (each between 1.5 and 2GB), when I open one image then open a new image, the RAM used from 1st image stays and is not ""freed"". When looking at the Memory monitor of QUpath, if I press ""clear tile cache"", it will decrease the ""Used memory"", but the ""total memory"" stays the same. So basically, even when clearing tile cache, the RAM is taken up is growing little by little at a point where I have to close Qupath and restart. I don't think that this is an expected behavior. ; Also if just going back and forth between the same 2 images, loading is faster if tiled are created (normal) but it will increases the number of cached tiles and increases total RAM (but at some point not anymore, which is even more strange). . Reclaim memory also does not completely free the RAM.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1646
https://github.com/qupath/qupath/issues/1646:419,Usability,clear,clearing,419,"I am using the portable version QuPath-v0.5.0-Windows, on a 64bit Windows machine. In a project with several images (each between 1.5 and 2GB), when I open one image then open a new image, the RAM used from 1st image stays and is not ""freed"". When looking at the Memory monitor of QUpath, if I press ""clear tile cache"", it will decrease the ""Used memory"", but the ""total memory"" stays the same. So basically, even when clearing tile cache, the RAM is taken up is growing little by little at a point where I have to close Qupath and restart. I don't think that this is an expected behavior. ; Also if just going back and forth between the same 2 images, loading is faster if tiled are created (normal) but it will increases the number of cached tiles and increases total RAM (but at some point not anymore, which is even more strange). . Reclaim memory also does not completely free the RAM.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1646
https://github.com/qupath/qupath/pull/1649:52,Integrability,interface,interface,52,Added a command to write a Zarr image from the user interface,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1649
https://github.com/qupath/qupath/pull/1650:193,Deployability,update,updated,193,"This makes it possible to have more informative messages during processing, so that the user knows what is happening along the way (e.g. 'Detecting', 'Processing', 'Measuring'). PixelProcessor updated to use this to record the number of tiles being processed.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1650
https://github.com/qupath/qupath/pull/1650:48,Integrability,message,messages,48,"This makes it possible to have more informative messages during processing, so that the user knows what is happening along the way (e.g. 'Detecting', 'Processing', 'Measuring'). PixelProcessor updated to use this to record the number of tiles being processed.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1650
https://github.com/qupath/qupath/pull/1650:138,Safety,Detect,Detecting,138,"This makes it possible to have more informative messages during processing, so that the user knows what is happening along the way (e.g. 'Detecting', 'Processing', 'Measuring'). PixelProcessor updated to use this to record the number of tiles being processed.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1650
https://github.com/qupath/qupath/issues/1652:397,Deployability,install,installation,397,"## Bug report. ### Describe the bug; Because of some [JavaFX WebView awkwardness](https://github.com/qupath/qupath/issues/1497), we stop merging all the QuPath javadocs into a single jar, in favor of trying to bundle all the relevant jars with the app. Unfortunately, for v0.6.0-rc1 and v0.6.0-rc2 lots of jars are missing. ### To Reproduce; Steps to reproduce the behavior:; 1. Go to your QuPath installation; 2. Look inside `app/docs`; 3. Ask yourself ""Is that all there is?""; 4. Answer yourself ""Yes, but there really should be others"". ### Expected behavior; Javadoc jars for all the main QuPath classes are included. ### Desktop (please complete the following information):; - OS: All (presumably; confirmed on macOS and Windows); - QuPath Version: v0.6.0-rc1, v0.6.0-rc2",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1652
https://github.com/qupath/qupath/issues/1657:1134,Deployability,update,update,1134,"## Bug report. ### Describe the bug; Somewhere between a bug report and enhancement request... The ability to view classifications and names in the grid view is very handy https://github.com/qupath/qupath/pull/1588. The trouble is that, for TMA cores, sorting by name gives `A-1`, `A-10`, `A-11`, `A-2`... which is kinda right, but not what the user likely wants. ### To Reproduce; Steps to reproduce the behavior:; 1. Create a TMA grid with 10 or more columns; 2. Run _Measure → Grid views... → Show TMA core grid view_. ### Expected behavior; Cores are ordered using numbers in a 'smarter' way. ### Desktop (please complete the following information):; - OS: All; - QuPath Version: 0.6.0-SNAPSHOT. ### Additional context; `GeneralTools` has a method that is sort of relevant [here](https://github.com/qupath/qupath/blob/e15df73ff60ef167eac82237586caf1f2e81ceab/qupath-core/src/main/java/qupath/lib/common/GeneralTools.java#L910). It feels like something an existing dependency library might have, but I haven't found it yet. > *Extra thing: when setting the classification of a TMA core *after* the grid is shown, the color doesn't update in the thumbnail image.*",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1657
https://github.com/qupath/qupath/issues/1657:968,Integrability,depend,dependency,968,"## Bug report. ### Describe the bug; Somewhere between a bug report and enhancement request... The ability to view classifications and names in the grid view is very handy https://github.com/qupath/qupath/pull/1588. The trouble is that, for TMA cores, sorting by name gives `A-1`, `A-10`, `A-11`, `A-2`... which is kinda right, but not what the user likely wants. ### To Reproduce; Steps to reproduce the behavior:; 1. Create a TMA grid with 10 or more columns; 2. Run _Measure → Grid views... → Show TMA core grid view_. ### Expected behavior; Cores are ordered using numbers in a 'smarter' way. ### Desktop (please complete the following information):; - OS: All; - QuPath Version: 0.6.0-SNAPSHOT. ### Additional context; `GeneralTools` has a method that is sort of relevant [here](https://github.com/qupath/qupath/blob/e15df73ff60ef167eac82237586caf1f2e81ceab/qupath-core/src/main/java/qupath/lib/common/GeneralTools.java#L910). It feels like something an existing dependency library might have, but I haven't found it yet. > *Extra thing: when setting the classification of a TMA core *after* the grid is shown, the color doesn't update in the thumbnail image.*",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1657
https://github.com/qupath/qupath/issues/1657:72,Modifiability,enhance,enhancement,72,"## Bug report. ### Describe the bug; Somewhere between a bug report and enhancement request... The ability to view classifications and names in the grid view is very handy https://github.com/qupath/qupath/pull/1588. The trouble is that, for TMA cores, sorting by name gives `A-1`, `A-10`, `A-11`, `A-2`... which is kinda right, but not what the user likely wants. ### To Reproduce; Steps to reproduce the behavior:; 1. Create a TMA grid with 10 or more columns; 2. Run _Measure → Grid views... → Show TMA core grid view_. ### Expected behavior; Cores are ordered using numbers in a 'smarter' way. ### Desktop (please complete the following information):; - OS: All; - QuPath Version: 0.6.0-SNAPSHOT. ### Additional context; `GeneralTools` has a method that is sort of relevant [here](https://github.com/qupath/qupath/blob/e15df73ff60ef167eac82237586caf1f2e81ceab/qupath-core/src/main/java/qupath/lib/common/GeneralTools.java#L910). It feels like something an existing dependency library might have, but I haven't found it yet. > *Extra thing: when setting the classification of a TMA core *after* the grid is shown, the color doesn't update in the thumbnail image.*",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1657
https://github.com/qupath/qupath/pull/1659:155,Energy Efficiency,reduce,reduce,155,"Proposed support changing channel names for RGB images. Changing colors is still not allowed, because a packed (A)RGB representation is used. This aims to reduce the inconvenience of QuPath sometimes creating an RGB representation for fluorescence images where it would be desirable to use different channel names. See https://github.com/qupath/qupath-extension-omero/issues/25",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1659
https://github.com/qupath/qupath/issues/1660:353,Usability,feedback,feedback-on-qupath-,353,"## Bug report. ### Describe the bug; After https://github.com/qupath/qupath/pull/1524 (I think) it's no longer possible to close the script editor without closing scripts. This was flagged as a potential annoyance at https://github.com/qupath/qupath/pull/1524#issuecomment-2133544271 and then reported as an actual annoyance at https://forum.image.sc/t/feedback-on-qupath-v0-6-0-rc2/103187/3?u=petebankhead. ### To Reproduce; Steps to reproduce the behavior:; 1. Open a script editor in v0.6.0-rc2; 2. Type something, anything; 3. Try to close the script editor window; 4. See it isn't possible to close the window without saving the script; 5. Reopen the script editor - the script is gone. ### Expected behavior; Not sure. . v0.5.x and before permitted the script editor to be closed without requesting the user to save anything.; The trouble with that was that people could easily lose edited scripts without being prompted to save changes. Two possible options:; 1. Provide an option to hide the script editor without closing scripts - _but still prompt to save changes when QuPath is being closed_; 2. Keep current behaviour, but retain the last script when reopening the script editor window. The first option is perhaps the most useful, since the second would only permit retaining one script at a time - and multiple scripts may be open. ### Desktop (please complete the following information):; - OS: All; - QuPath Version: v0.6.0-rc2",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1660
https://github.com/qupath/qupath/issues/1661:117,Usability,feedback,feedback-on-qupath-,117,"## Feature request. ### Is your feature request related to a problem? Please describe.; See https://forum.image.sc/t/feedback-on-qupath-v0-6-0-rc2/103187/5. > One cool thing, in a next version, would to have in the Annotations panel a filter in the Measurements window (just as the one above in classifications list), because there are so many measurements (cell, nucleus, membrane, cytoplasm in all channel), that one have to scroll a lot to get the desired measurement.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1661
https://github.com/qupath/qupath/pull/1664:103,Safety,detect,detections,103,"This is a very provisional proof-of-concept showing how the measurement mapper could support more than detections. Note that it doesn't handle *dynamic* measurements. So if you want to use annotation shapes (for example), then it's necessary to use 'Analyze → Calculate features → Add shape features' first.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1664
https://github.com/qupath/qupath/pull/1668:63,Deployability,update,updated,63,"Avoid showing the URI dialog if all missing image paths can be updated using relative links, and the links are all within the existing project directory. This can help make projects more self-contained.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1668
https://github.com/qupath/qupath/pull/1668:0,Safety,Avoid,Avoid,0,"Avoid showing the URI dialog if all missing image paths can be updated using relative links, and the links are all within the existing project directory. This can help make projects more self-contained.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1668
https://github.com/qupath/qupath/pull/1669:672,Energy Efficiency,Green,Green,672,"This revises the approach in https://github.com/qupath/qupath/pull/1659 in the latest attempt to fix https://github.com/qupath/qupath-extension-omero/issues/25. ## Purpose. With this PR, RGB images that are set to have the type 'Fluorescence' now behave much more similarly to non-RGB images, and it is possible to set both channel names and colors. However all the other image type options remain, e.g. Brightfield H&E. If one of these is selected, then all channel name/color customisations are ignored - and the image behaves as a regular RGB. ## Risks & assumptions; * Querying channel names & colors for an RGB `ImageServer` is no longer guaranteed to return `Red`, `Green` or `Blue`; * Custom channel names for an RGB `ImageServer` are also not guaranteed to be represented in the viewer; rather, this only occurs if the image type is `Fluorescence`; * This does *not* provide a way to convert a BGR image to RGB from the perspective of any analysis. `ImageServer.readRegion()` requests should still return the same packed int (A)RGB image as before - the main difference is how things are rendered in the viewer.; * A pixel classifier that is trained on an image with custom RGB channel names will only work on an image with the same custom channel names*. > *-Caveat: this can give unexpected results if a pixel classifier is applied to two RGB images exist in a project, and one has different channel names. Then, if the classifier is applied successfully to one image, it can *appear* to work on the second image because cached tiles are used - so the mismatched channel names are not identified. ## Example. Example using the ImageJ 'Fluorescent Cells' image, flattened to RGB. ### Image type set to 'Fluorescence', channels adjusted; ![RGB-fluorescence](https://github.com/user-attachments/assets/d1118dc8-a661-4129-a0ec-9fab28550a31). ### Same image with type set to 'Other'; ![RGB-Other](https://github.com/user-attachments/assets/8e44ada9-33e5-4b54-8f0b-695c5849edfb)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1669
https://github.com/qupath/qupath/pull/1669:1531,Performance,cache,cached,1531,"This revises the approach in https://github.com/qupath/qupath/pull/1659 in the latest attempt to fix https://github.com/qupath/qupath-extension-omero/issues/25. ## Purpose. With this PR, RGB images that are set to have the type 'Fluorescence' now behave much more similarly to non-RGB images, and it is possible to set both channel names and colors. However all the other image type options remain, e.g. Brightfield H&E. If one of these is selected, then all channel name/color customisations are ignored - and the image behaves as a regular RGB. ## Risks & assumptions; * Querying channel names & colors for an RGB `ImageServer` is no longer guaranteed to return `Red`, `Green` or `Blue`; * Custom channel names for an RGB `ImageServer` are also not guaranteed to be represented in the viewer; rather, this only occurs if the image type is `Fluorescence`; * This does *not* provide a way to convert a BGR image to RGB from the perspective of any analysis. `ImageServer.readRegion()` requests should still return the same packed int (A)RGB image as before - the main difference is how things are rendered in the viewer.; * A pixel classifier that is trained on an image with custom RGB channel names will only work on an image with the same custom channel names*. > *-Caveat: this can give unexpected results if a pixel classifier is applied to two RGB images exist in a project, and one has different channel names. Then, if the classifier is applied successfully to one image, it can *appear* to work on the second image because cached tiles are used - so the mismatched channel names are not identified. ## Example. Example using the ImageJ 'Fluorescent Cells' image, flattened to RGB. ### Image type set to 'Fluorescence', channels adjusted; ![RGB-fluorescence](https://github.com/user-attachments/assets/d1118dc8-a661-4129-a0ec-9fab28550a31). ### Same image with type set to 'Other'; ![RGB-Other](https://github.com/user-attachments/assets/8e44ada9-33e5-4b54-8f0b-695c5849edfb)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1669
https://github.com/qupath/qupath/pull/1669:550,Safety,Risk,Risks,550,"This revises the approach in https://github.com/qupath/qupath/pull/1659 in the latest attempt to fix https://github.com/qupath/qupath-extension-omero/issues/25. ## Purpose. With this PR, RGB images that are set to have the type 'Fluorescence' now behave much more similarly to non-RGB images, and it is possible to set both channel names and colors. However all the other image type options remain, e.g. Brightfield H&E. If one of these is selected, then all channel name/color customisations are ignored - and the image behaves as a regular RGB. ## Risks & assumptions; * Querying channel names & colors for an RGB `ImageServer` is no longer guaranteed to return `Red`, `Green` or `Blue`; * Custom channel names for an RGB `ImageServer` are also not guaranteed to be represented in the viewer; rather, this only occurs if the image type is `Fluorescence`; * This does *not* provide a way to convert a BGR image to RGB from the perspective of any analysis. `ImageServer.readRegion()` requests should still return the same packed int (A)RGB image as before - the main difference is how things are rendered in the viewer.; * A pixel classifier that is trained on an image with custom RGB channel names will only work on an image with the same custom channel names*. > *-Caveat: this can give unexpected results if a pixel classifier is applied to two RGB images exist in a project, and one has different channel names. Then, if the classifier is applied successfully to one image, it can *appear* to work on the second image because cached tiles are used - so the mismatched channel names are not identified. ## Example. Example using the ImageJ 'Fluorescent Cells' image, flattened to RGB. ### Image type set to 'Fluorescence', channels adjusted; ![RGB-fluorescence](https://github.com/user-attachments/assets/d1118dc8-a661-4129-a0ec-9fab28550a31). ### Same image with type set to 'Other'; ![RGB-Other](https://github.com/user-attachments/assets/8e44ada9-33e5-4b54-8f0b-695c5849edfb)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1669
https://github.com/qupath/qupath/issues/1672:119,Availability,down,download,119,"Hi:. The latest release of the QuPath v0.5.1:. [QuPath-v0.5.1-Mac-arm64.pkg](https://github.com/qupath/qupath/releases/download/v0.5.1/QuPath-v0.5.1-Mac-arm64.pkg); [QuPath-v0.5.1-Mac-x64.pkg](https://github.com/qupath/qupath/releases/download/v0.5.1/QuPath-v0.5.1-Mac-x64.pkg). The issue with Mac applications that use ad-hoc signatures is that, while they provide a code signing digest (or cdhash) allowing macOS to verify whether the app or component has been altered, they don't verify the identity of the developer. This means that macOS can detect if the code has changed but has no way to confirm who signed the code or if it comes from a trusted source. Key concerns with ad-hoc signatures include:. No Developer Identity Verification: Ad-hoc signatures don’t provide information about the developer’s identity, unlike certificates from Apple, which are linked to verified developer accounts. This can pose security risks as it’s harder to establish trust in the source of the code. Limited Use Cases: Ad-hoc signing is typically used for specific scenarios, such as:; Unsigned code running on Apple Silicon, where macOS requires all code to be signed, even if it’s just ad-hoc.; Web Apps on macOS 14 Sonoma, where the code isn't distributed via traditional app distribution methods. Security Risks: Since there is no certification authority involved in ad-hoc signing, it is easier for malicious or unauthorized code to be signed ad-hoc and executed, which could expose the system to potential vulnerabilities. I would recommend moving away from ad-hoc certificates and following the Apple Developer guidelines on application creation & distribution. For example, here is a free GUI application called ""Apparency"" that will help explain issues and test your applications.; https://mothersruin.com/software/Apparency/. ![image](https://github.com/user-attachments/assets/d69830e4-e271-430a-987c-c58b1b708481); ![image](https://github.com/user-attachments/assets/4a03b7ba-c911-486b-91de-2d86d0e",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:235,Availability,down,download,235,"Hi:. The latest release of the QuPath v0.5.1:. [QuPath-v0.5.1-Mac-arm64.pkg](https://github.com/qupath/qupath/releases/download/v0.5.1/QuPath-v0.5.1-Mac-arm64.pkg); [QuPath-v0.5.1-Mac-x64.pkg](https://github.com/qupath/qupath/releases/download/v0.5.1/QuPath-v0.5.1-Mac-x64.pkg). The issue with Mac applications that use ad-hoc signatures is that, while they provide a code signing digest (or cdhash) allowing macOS to verify whether the app or component has been altered, they don't verify the identity of the developer. This means that macOS can detect if the code has changed but has no way to confirm who signed the code or if it comes from a trusted source. Key concerns with ad-hoc signatures include:. No Developer Identity Verification: Ad-hoc signatures don’t provide information about the developer’s identity, unlike certificates from Apple, which are linked to verified developer accounts. This can pose security risks as it’s harder to establish trust in the source of the code. Limited Use Cases: Ad-hoc signing is typically used for specific scenarios, such as:; Unsigned code running on Apple Silicon, where macOS requires all code to be signed, even if it’s just ad-hoc.; Web Apps on macOS 14 Sonoma, where the code isn't distributed via traditional app distribution methods. Security Risks: Since there is no certification authority involved in ad-hoc signing, it is easier for malicious or unauthorized code to be signed ad-hoc and executed, which could expose the system to potential vulnerabilities. I would recommend moving away from ad-hoc certificates and following the Apple Developer guidelines on application creation & distribution. For example, here is a free GUI application called ""Apparency"" that will help explain issues and test your applications.; https://mothersruin.com/software/Apparency/. ![image](https://github.com/user-attachments/assets/d69830e4-e271-430a-987c-c58b1b708481); ![image](https://github.com/user-attachments/assets/4a03b7ba-c911-486b-91de-2d86d0e",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:16,Deployability,release,release,16,"Hi:. The latest release of the QuPath v0.5.1:. [QuPath-v0.5.1-Mac-arm64.pkg](https://github.com/qupath/qupath/releases/download/v0.5.1/QuPath-v0.5.1-Mac-arm64.pkg); [QuPath-v0.5.1-Mac-x64.pkg](https://github.com/qupath/qupath/releases/download/v0.5.1/QuPath-v0.5.1-Mac-x64.pkg). The issue with Mac applications that use ad-hoc signatures is that, while they provide a code signing digest (or cdhash) allowing macOS to verify whether the app or component has been altered, they don't verify the identity of the developer. This means that macOS can detect if the code has changed but has no way to confirm who signed the code or if it comes from a trusted source. Key concerns with ad-hoc signatures include:. No Developer Identity Verification: Ad-hoc signatures don’t provide information about the developer’s identity, unlike certificates from Apple, which are linked to verified developer accounts. This can pose security risks as it’s harder to establish trust in the source of the code. Limited Use Cases: Ad-hoc signing is typically used for specific scenarios, such as:; Unsigned code running on Apple Silicon, where macOS requires all code to be signed, even if it’s just ad-hoc.; Web Apps on macOS 14 Sonoma, where the code isn't distributed via traditional app distribution methods. Security Risks: Since there is no certification authority involved in ad-hoc signing, it is easier for malicious or unauthorized code to be signed ad-hoc and executed, which could expose the system to potential vulnerabilities. I would recommend moving away from ad-hoc certificates and following the Apple Developer guidelines on application creation & distribution. For example, here is a free GUI application called ""Apparency"" that will help explain issues and test your applications.; https://mothersruin.com/software/Apparency/. ![image](https://github.com/user-attachments/assets/d69830e4-e271-430a-987c-c58b1b708481); ![image](https://github.com/user-attachments/assets/4a03b7ba-c911-486b-91de-2d86d0e",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:110,Deployability,release,releases,110,"Hi:. The latest release of the QuPath v0.5.1:. [QuPath-v0.5.1-Mac-arm64.pkg](https://github.com/qupath/qupath/releases/download/v0.5.1/QuPath-v0.5.1-Mac-arm64.pkg); [QuPath-v0.5.1-Mac-x64.pkg](https://github.com/qupath/qupath/releases/download/v0.5.1/QuPath-v0.5.1-Mac-x64.pkg). The issue with Mac applications that use ad-hoc signatures is that, while they provide a code signing digest (or cdhash) allowing macOS to verify whether the app or component has been altered, they don't verify the identity of the developer. This means that macOS can detect if the code has changed but has no way to confirm who signed the code or if it comes from a trusted source. Key concerns with ad-hoc signatures include:. No Developer Identity Verification: Ad-hoc signatures don’t provide information about the developer’s identity, unlike certificates from Apple, which are linked to verified developer accounts. This can pose security risks as it’s harder to establish trust in the source of the code. Limited Use Cases: Ad-hoc signing is typically used for specific scenarios, such as:; Unsigned code running on Apple Silicon, where macOS requires all code to be signed, even if it’s just ad-hoc.; Web Apps on macOS 14 Sonoma, where the code isn't distributed via traditional app distribution methods. Security Risks: Since there is no certification authority involved in ad-hoc signing, it is easier for malicious or unauthorized code to be signed ad-hoc and executed, which could expose the system to potential vulnerabilities. I would recommend moving away from ad-hoc certificates and following the Apple Developer guidelines on application creation & distribution. For example, here is a free GUI application called ""Apparency"" that will help explain issues and test your applications.; https://mothersruin.com/software/Apparency/. ![image](https://github.com/user-attachments/assets/d69830e4-e271-430a-987c-c58b1b708481); ![image](https://github.com/user-attachments/assets/4a03b7ba-c911-486b-91de-2d86d0e",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:226,Deployability,release,releases,226,"Hi:. The latest release of the QuPath v0.5.1:. [QuPath-v0.5.1-Mac-arm64.pkg](https://github.com/qupath/qupath/releases/download/v0.5.1/QuPath-v0.5.1-Mac-arm64.pkg); [QuPath-v0.5.1-Mac-x64.pkg](https://github.com/qupath/qupath/releases/download/v0.5.1/QuPath-v0.5.1-Mac-x64.pkg). The issue with Mac applications that use ad-hoc signatures is that, while they provide a code signing digest (or cdhash) allowing macOS to verify whether the app or component has been altered, they don't verify the identity of the developer. This means that macOS can detect if the code has changed but has no way to confirm who signed the code or if it comes from a trusted source. Key concerns with ad-hoc signatures include:. No Developer Identity Verification: Ad-hoc signatures don’t provide information about the developer’s identity, unlike certificates from Apple, which are linked to verified developer accounts. This can pose security risks as it’s harder to establish trust in the source of the code. Limited Use Cases: Ad-hoc signing is typically used for specific scenarios, such as:; Unsigned code running on Apple Silicon, where macOS requires all code to be signed, even if it’s just ad-hoc.; Web Apps on macOS 14 Sonoma, where the code isn't distributed via traditional app distribution methods. Security Risks: Since there is no certification authority involved in ad-hoc signing, it is easier for malicious or unauthorized code to be signed ad-hoc and executed, which could expose the system to potential vulnerabilities. I would recommend moving away from ad-hoc certificates and following the Apple Developer guidelines on application creation & distribution. For example, here is a free GUI application called ""Apparency"" that will help explain issues and test your applications.; https://mothersruin.com/software/Apparency/. ![image](https://github.com/user-attachments/assets/d69830e4-e271-430a-987c-c58b1b708481); ![image](https://github.com/user-attachments/assets/4a03b7ba-c911-486b-91de-2d86d0e",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:3801,Deployability,install,installer,3801,"es related to Gatekeeper on macOS. Gatekeeper is a security feature designed to ensure that only trusted software runs on a user's Mac, and the post focuses on helping developers troubleshoot and resolve issues that may arise in this context.; The post identifies four common Gatekeeper problems that developers may encounter:. 1. App blocked by a dangling load command path.; 2. Broken code signature.; 3. Lack of notarization.; 4. Command-line tool blocked by Gatekeeper. For each of these issues, the post provides detailed steps and guidance on how developers can resolve them. The emphasis is on the importance of passing Gatekeeper checks to maintain customer trust and avoid potential loss of customers.; Key points covered in the post include:. • Verification of Code Signature: Developers are advised to use the codesign tool to verify that their code is signed correctly. The post provides examples of command-line usage to check for issues such as missing or invalid sealed resources.; • Notarization Issues: Gatekeeper requires that apps be notarized, and the post guides developers on how to identify and resolve notarization problems. It includes information on checking system logs for specific entries related to notarization issues.; • Hash Mismatch: In cases where there's a hash mismatch, the post provides guidance based on the file type (e.g., zip archive, signed disk image, installer package) and recommends specific actions to address the problem.; • Command-line Tool Blocking Bug: A known bug in macOS is acknowledged, where double-clicking a command-line tool in Finder may lead to it being blocked by Gatekeeper. Workarounds, such as embedding the tool in an application or using an installer package, are suggested. Throughout the post, there are references to Apple's documentation and resources related to code signing and notarization, providing developers with additional information for a deeper understanding. https://forums.developer.apple.com/forums/thread/706379",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:4115,Deployability,install,installer,4115,"es related to Gatekeeper on macOS. Gatekeeper is a security feature designed to ensure that only trusted software runs on a user's Mac, and the post focuses on helping developers troubleshoot and resolve issues that may arise in this context.; The post identifies four common Gatekeeper problems that developers may encounter:. 1. App blocked by a dangling load command path.; 2. Broken code signature.; 3. Lack of notarization.; 4. Command-line tool blocked by Gatekeeper. For each of these issues, the post provides detailed steps and guidance on how developers can resolve them. The emphasis is on the importance of passing Gatekeeper checks to maintain customer trust and avoid potential loss of customers.; Key points covered in the post include:. • Verification of Code Signature: Developers are advised to use the codesign tool to verify that their code is signed correctly. The post provides examples of command-line usage to check for issues such as missing or invalid sealed resources.; • Notarization Issues: Gatekeeper requires that apps be notarized, and the post guides developers on how to identify and resolve notarization problems. It includes information on checking system logs for specific entries related to notarization issues.; • Hash Mismatch: In cases where there's a hash mismatch, the post provides guidance based on the file type (e.g., zip archive, signed disk image, installer package) and recommends specific actions to address the problem.; • Command-line Tool Blocking Bug: A known bug in macOS is acknowledged, where double-clicking a command-line tool in Finder may lead to it being blocked by Gatekeeper. Workarounds, such as embedding the tool in an application or using an installer package, are suggested. Throughout the post, there are references to Apple's documentation and resources related to code signing and notarization, providing developers with additional information for a deeper understanding. https://forums.developer.apple.com/forums/thread/706379",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:2761,Performance,load,load,2761," test your applications.; https://mothersruin.com/software/Apparency/. ![image](https://github.com/user-attachments/assets/d69830e4-e271-430a-987c-c58b1b708481); ![image](https://github.com/user-attachments/assets/4a03b7ba-c911-486b-91de-2d86d0eefc2c). I thought this post from Quinn “The Eskimo!” @ Developer Technical Support @ Apple would be good to share with your Mac development team:. Resolving Gatekeeper Problems | Apple Developer Forums:. The post titled ""Resolving Gatekeeper Problems"" on the Apple Developer Forums, written by Quinn ""The Eskimo!"" from Developer Technical Support at Apple is a comprehensive guide addressing common issues related to Gatekeeper on macOS. Gatekeeper is a security feature designed to ensure that only trusted software runs on a user's Mac, and the post focuses on helping developers troubleshoot and resolve issues that may arise in this context.; The post identifies four common Gatekeeper problems that developers may encounter:. 1. App blocked by a dangling load command path.; 2. Broken code signature.; 3. Lack of notarization.; 4. Command-line tool blocked by Gatekeeper. For each of these issues, the post provides detailed steps and guidance on how developers can resolve them. The emphasis is on the importance of passing Gatekeeper checks to maintain customer trust and avoid potential loss of customers.; Key points covered in the post include:. • Verification of Code Signature: Developers are advised to use the codesign tool to verify that their code is signed correctly. The post provides examples of command-line usage to check for issues such as missing or invalid sealed resources.; • Notarization Issues: Gatekeeper requires that apps be notarized, and the post guides developers on how to identify and resolve notarization problems. It includes information on checking system logs for specific entries related to notarization issues.; • Hash Mismatch: In cases where there's a hash mismatch, the post provides guidance based on the file ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:547,Safety,detect,detect,547,"Hi:. The latest release of the QuPath v0.5.1:. [QuPath-v0.5.1-Mac-arm64.pkg](https://github.com/qupath/qupath/releases/download/v0.5.1/QuPath-v0.5.1-Mac-arm64.pkg); [QuPath-v0.5.1-Mac-x64.pkg](https://github.com/qupath/qupath/releases/download/v0.5.1/QuPath-v0.5.1-Mac-x64.pkg). The issue with Mac applications that use ad-hoc signatures is that, while they provide a code signing digest (or cdhash) allowing macOS to verify whether the app or component has been altered, they don't verify the identity of the developer. This means that macOS can detect if the code has changed but has no way to confirm who signed the code or if it comes from a trusted source. Key concerns with ad-hoc signatures include:. No Developer Identity Verification: Ad-hoc signatures don’t provide information about the developer’s identity, unlike certificates from Apple, which are linked to verified developer accounts. This can pose security risks as it’s harder to establish trust in the source of the code. Limited Use Cases: Ad-hoc signing is typically used for specific scenarios, such as:; Unsigned code running on Apple Silicon, where macOS requires all code to be signed, even if it’s just ad-hoc.; Web Apps on macOS 14 Sonoma, where the code isn't distributed via traditional app distribution methods. Security Risks: Since there is no certification authority involved in ad-hoc signing, it is easier for malicious or unauthorized code to be signed ad-hoc and executed, which could expose the system to potential vulnerabilities. I would recommend moving away from ad-hoc certificates and following the Apple Developer guidelines on application creation & distribution. For example, here is a free GUI application called ""Apparency"" that will help explain issues and test your applications.; https://mothersruin.com/software/Apparency/. ![image](https://github.com/user-attachments/assets/d69830e4-e271-430a-987c-c58b1b708481); ![image](https://github.com/user-attachments/assets/4a03b7ba-c911-486b-91de-2d86d0e",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:924,Safety,risk,risks,924,"Hi:. The latest release of the QuPath v0.5.1:. [QuPath-v0.5.1-Mac-arm64.pkg](https://github.com/qupath/qupath/releases/download/v0.5.1/QuPath-v0.5.1-Mac-arm64.pkg); [QuPath-v0.5.1-Mac-x64.pkg](https://github.com/qupath/qupath/releases/download/v0.5.1/QuPath-v0.5.1-Mac-x64.pkg). The issue with Mac applications that use ad-hoc signatures is that, while they provide a code signing digest (or cdhash) allowing macOS to verify whether the app or component has been altered, they don't verify the identity of the developer. This means that macOS can detect if the code has changed but has no way to confirm who signed the code or if it comes from a trusted source. Key concerns with ad-hoc signatures include:. No Developer Identity Verification: Ad-hoc signatures don’t provide information about the developer’s identity, unlike certificates from Apple, which are linked to verified developer accounts. This can pose security risks as it’s harder to establish trust in the source of the code. Limited Use Cases: Ad-hoc signing is typically used for specific scenarios, such as:; Unsigned code running on Apple Silicon, where macOS requires all code to be signed, even if it’s just ad-hoc.; Web Apps on macOS 14 Sonoma, where the code isn't distributed via traditional app distribution methods. Security Risks: Since there is no certification authority involved in ad-hoc signing, it is easier for malicious or unauthorized code to be signed ad-hoc and executed, which could expose the system to potential vulnerabilities. I would recommend moving away from ad-hoc certificates and following the Apple Developer guidelines on application creation & distribution. For example, here is a free GUI application called ""Apparency"" that will help explain issues and test your applications.; https://mothersruin.com/software/Apparency/. ![image](https://github.com/user-attachments/assets/d69830e4-e271-430a-987c-c58b1b708481); ![image](https://github.com/user-attachments/assets/4a03b7ba-c911-486b-91de-2d86d0e",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:1301,Safety,Risk,Risks,1301,"ing macOS to verify whether the app or component has been altered, they don't verify the identity of the developer. This means that macOS can detect if the code has changed but has no way to confirm who signed the code or if it comes from a trusted source. Key concerns with ad-hoc signatures include:. No Developer Identity Verification: Ad-hoc signatures don’t provide information about the developer’s identity, unlike certificates from Apple, which are linked to verified developer accounts. This can pose security risks as it’s harder to establish trust in the source of the code. Limited Use Cases: Ad-hoc signing is typically used for specific scenarios, such as:; Unsigned code running on Apple Silicon, where macOS requires all code to be signed, even if it’s just ad-hoc.; Web Apps on macOS 14 Sonoma, where the code isn't distributed via traditional app distribution methods. Security Risks: Since there is no certification authority involved in ad-hoc signing, it is easier for malicious or unauthorized code to be signed ad-hoc and executed, which could expose the system to potential vulnerabilities. I would recommend moving away from ad-hoc certificates and following the Apple Developer guidelines on application creation & distribution. For example, here is a free GUI application called ""Apparency"" that will help explain issues and test your applications.; https://mothersruin.com/software/Apparency/. ![image](https://github.com/user-attachments/assets/d69830e4-e271-430a-987c-c58b1b708481); ![image](https://github.com/user-attachments/assets/4a03b7ba-c911-486b-91de-2d86d0eefc2c). I thought this post from Quinn “The Eskimo!” @ Developer Technical Support @ Apple would be good to share with your Mac development team:. Resolving Gatekeeper Problems | Apple Developer Forums:. The post titled ""Resolving Gatekeeper Problems"" on the Apple Developer Forums, written by Quinn ""The Eskimo!"" from Developer Technical Support at Apple is a comprehensive guide addressing common issue",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:3080,Safety,avoid,avoid,3080,"mo!” @ Developer Technical Support @ Apple would be good to share with your Mac development team:. Resolving Gatekeeper Problems | Apple Developer Forums:. The post titled ""Resolving Gatekeeper Problems"" on the Apple Developer Forums, written by Quinn ""The Eskimo!"" from Developer Technical Support at Apple is a comprehensive guide addressing common issues related to Gatekeeper on macOS. Gatekeeper is a security feature designed to ensure that only trusted software runs on a user's Mac, and the post focuses on helping developers troubleshoot and resolve issues that may arise in this context.; The post identifies four common Gatekeeper problems that developers may encounter:. 1. App blocked by a dangling load command path.; 2. Broken code signature.; 3. Lack of notarization.; 4. Command-line tool blocked by Gatekeeper. For each of these issues, the post provides detailed steps and guidance on how developers can resolve them. The emphasis is on the importance of passing Gatekeeper checks to maintain customer trust and avoid potential loss of customers.; Key points covered in the post include:. • Verification of Code Signature: Developers are advised to use the codesign tool to verify that their code is signed correctly. The post provides examples of command-line usage to check for issues such as missing or invalid sealed resources.; • Notarization Issues: Gatekeeper requires that apps be notarized, and the post guides developers on how to identify and resolve notarization problems. It includes information on checking system logs for specific entries related to notarization issues.; • Hash Mismatch: In cases where there's a hash mismatch, the post provides guidance based on the file type (e.g., zip archive, signed disk image, installer package) and recommends specific actions to address the problem.; • Command-line Tool Blocking Bug: A known bug in macOS is acknowledged, where double-clicking a command-line tool in Finder may lead to it being blocked by Gatekeeper. Worka",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:827,Security,certificate,certificates,827,"Hi:. The latest release of the QuPath v0.5.1:. [QuPath-v0.5.1-Mac-arm64.pkg](https://github.com/qupath/qupath/releases/download/v0.5.1/QuPath-v0.5.1-Mac-arm64.pkg); [QuPath-v0.5.1-Mac-x64.pkg](https://github.com/qupath/qupath/releases/download/v0.5.1/QuPath-v0.5.1-Mac-x64.pkg). The issue with Mac applications that use ad-hoc signatures is that, while they provide a code signing digest (or cdhash) allowing macOS to verify whether the app or component has been altered, they don't verify the identity of the developer. This means that macOS can detect if the code has changed but has no way to confirm who signed the code or if it comes from a trusted source. Key concerns with ad-hoc signatures include:. No Developer Identity Verification: Ad-hoc signatures don’t provide information about the developer’s identity, unlike certificates from Apple, which are linked to verified developer accounts. This can pose security risks as it’s harder to establish trust in the source of the code. Limited Use Cases: Ad-hoc signing is typically used for specific scenarios, such as:; Unsigned code running on Apple Silicon, where macOS requires all code to be signed, even if it’s just ad-hoc.; Web Apps on macOS 14 Sonoma, where the code isn't distributed via traditional app distribution methods. Security Risks: Since there is no certification authority involved in ad-hoc signing, it is easier for malicious or unauthorized code to be signed ad-hoc and executed, which could expose the system to potential vulnerabilities. I would recommend moving away from ad-hoc certificates and following the Apple Developer guidelines on application creation & distribution. For example, here is a free GUI application called ""Apparency"" that will help explain issues and test your applications.; https://mothersruin.com/software/Apparency/. ![image](https://github.com/user-attachments/assets/d69830e4-e271-430a-987c-c58b1b708481); ![image](https://github.com/user-attachments/assets/4a03b7ba-c911-486b-91de-2d86d0e",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:915,Security,secur,security,915,"Hi:. The latest release of the QuPath v0.5.1:. [QuPath-v0.5.1-Mac-arm64.pkg](https://github.com/qupath/qupath/releases/download/v0.5.1/QuPath-v0.5.1-Mac-arm64.pkg); [QuPath-v0.5.1-Mac-x64.pkg](https://github.com/qupath/qupath/releases/download/v0.5.1/QuPath-v0.5.1-Mac-x64.pkg). The issue with Mac applications that use ad-hoc signatures is that, while they provide a code signing digest (or cdhash) allowing macOS to verify whether the app or component has been altered, they don't verify the identity of the developer. This means that macOS can detect if the code has changed but has no way to confirm who signed the code or if it comes from a trusted source. Key concerns with ad-hoc signatures include:. No Developer Identity Verification: Ad-hoc signatures don’t provide information about the developer’s identity, unlike certificates from Apple, which are linked to verified developer accounts. This can pose security risks as it’s harder to establish trust in the source of the code. Limited Use Cases: Ad-hoc signing is typically used for specific scenarios, such as:; Unsigned code running on Apple Silicon, where macOS requires all code to be signed, even if it’s just ad-hoc.; Web Apps on macOS 14 Sonoma, where the code isn't distributed via traditional app distribution methods. Security Risks: Since there is no certification authority involved in ad-hoc signing, it is easier for malicious or unauthorized code to be signed ad-hoc and executed, which could expose the system to potential vulnerabilities. I would recommend moving away from ad-hoc certificates and following the Apple Developer guidelines on application creation & distribution. For example, here is a free GUI application called ""Apparency"" that will help explain issues and test your applications.; https://mothersruin.com/software/Apparency/. ![image](https://github.com/user-attachments/assets/d69830e4-e271-430a-987c-c58b1b708481); ![image](https://github.com/user-attachments/assets/4a03b7ba-c911-486b-91de-2d86d0e",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:1292,Security,Secur,Security,1292,"ing macOS to verify whether the app or component has been altered, they don't verify the identity of the developer. This means that macOS can detect if the code has changed but has no way to confirm who signed the code or if it comes from a trusted source. Key concerns with ad-hoc signatures include:. No Developer Identity Verification: Ad-hoc signatures don’t provide information about the developer’s identity, unlike certificates from Apple, which are linked to verified developer accounts. This can pose security risks as it’s harder to establish trust in the source of the code. Limited Use Cases: Ad-hoc signing is typically used for specific scenarios, such as:; Unsigned code running on Apple Silicon, where macOS requires all code to be signed, even if it’s just ad-hoc.; Web Apps on macOS 14 Sonoma, where the code isn't distributed via traditional app distribution methods. Security Risks: Since there is no certification authority involved in ad-hoc signing, it is easier for malicious or unauthorized code to be signed ad-hoc and executed, which could expose the system to potential vulnerabilities. I would recommend moving away from ad-hoc certificates and following the Apple Developer guidelines on application creation & distribution. For example, here is a free GUI application called ""Apparency"" that will help explain issues and test your applications.; https://mothersruin.com/software/Apparency/. ![image](https://github.com/user-attachments/assets/d69830e4-e271-430a-987c-c58b1b708481); ![image](https://github.com/user-attachments/assets/4a03b7ba-c911-486b-91de-2d86d0eefc2c). I thought this post from Quinn “The Eskimo!” @ Developer Technical Support @ Apple would be good to share with your Mac development team:. Resolving Gatekeeper Problems | Apple Developer Forums:. The post titled ""Resolving Gatekeeper Problems"" on the Apple Developer Forums, written by Quinn ""The Eskimo!"" from Developer Technical Support at Apple is a comprehensive guide addressing common issue",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:1472,Security,expose,expose,1472,"ing macOS to verify whether the app or component has been altered, they don't verify the identity of the developer. This means that macOS can detect if the code has changed but has no way to confirm who signed the code or if it comes from a trusted source. Key concerns with ad-hoc signatures include:. No Developer Identity Verification: Ad-hoc signatures don’t provide information about the developer’s identity, unlike certificates from Apple, which are linked to verified developer accounts. This can pose security risks as it’s harder to establish trust in the source of the code. Limited Use Cases: Ad-hoc signing is typically used for specific scenarios, such as:; Unsigned code running on Apple Silicon, where macOS requires all code to be signed, even if it’s just ad-hoc.; Web Apps on macOS 14 Sonoma, where the code isn't distributed via traditional app distribution methods. Security Risks: Since there is no certification authority involved in ad-hoc signing, it is easier for malicious or unauthorized code to be signed ad-hoc and executed, which could expose the system to potential vulnerabilities. I would recommend moving away from ad-hoc certificates and following the Apple Developer guidelines on application creation & distribution. For example, here is a free GUI application called ""Apparency"" that will help explain issues and test your applications.; https://mothersruin.com/software/Apparency/. ![image](https://github.com/user-attachments/assets/d69830e4-e271-430a-987c-c58b1b708481); ![image](https://github.com/user-attachments/assets/4a03b7ba-c911-486b-91de-2d86d0eefc2c). I thought this post from Quinn “The Eskimo!” @ Developer Technical Support @ Apple would be good to share with your Mac development team:. Resolving Gatekeeper Problems | Apple Developer Forums:. The post titled ""Resolving Gatekeeper Problems"" on the Apple Developer Forums, written by Quinn ""The Eskimo!"" from Developer Technical Support at Apple is a comprehensive guide addressing common issue",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:1562,Security,certificate,certificates,1562,"way to confirm who signed the code or if it comes from a trusted source. Key concerns with ad-hoc signatures include:. No Developer Identity Verification: Ad-hoc signatures don’t provide information about the developer’s identity, unlike certificates from Apple, which are linked to verified developer accounts. This can pose security risks as it’s harder to establish trust in the source of the code. Limited Use Cases: Ad-hoc signing is typically used for specific scenarios, such as:; Unsigned code running on Apple Silicon, where macOS requires all code to be signed, even if it’s just ad-hoc.; Web Apps on macOS 14 Sonoma, where the code isn't distributed via traditional app distribution methods. Security Risks: Since there is no certification authority involved in ad-hoc signing, it is easier for malicious or unauthorized code to be signed ad-hoc and executed, which could expose the system to potential vulnerabilities. I would recommend moving away from ad-hoc certificates and following the Apple Developer guidelines on application creation & distribution. For example, here is a free GUI application called ""Apparency"" that will help explain issues and test your applications.; https://mothersruin.com/software/Apparency/. ![image](https://github.com/user-attachments/assets/d69830e4-e271-430a-987c-c58b1b708481); ![image](https://github.com/user-attachments/assets/4a03b7ba-c911-486b-91de-2d86d0eefc2c). I thought this post from Quinn “The Eskimo!” @ Developer Technical Support @ Apple would be good to share with your Mac development team:. Resolving Gatekeeper Problems | Apple Developer Forums:. The post titled ""Resolving Gatekeeper Problems"" on the Apple Developer Forums, written by Quinn ""The Eskimo!"" from Developer Technical Support at Apple is a comprehensive guide addressing common issues related to Gatekeeper on macOS. Gatekeeper is a security feature designed to ensure that only trusted software runs on a user's Mac, and the post focuses on helping developers troubl",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:2455,Security,secur,security,2455,"ng away from ad-hoc certificates and following the Apple Developer guidelines on application creation & distribution. For example, here is a free GUI application called ""Apparency"" that will help explain issues and test your applications.; https://mothersruin.com/software/Apparency/. ![image](https://github.com/user-attachments/assets/d69830e4-e271-430a-987c-c58b1b708481); ![image](https://github.com/user-attachments/assets/4a03b7ba-c911-486b-91de-2d86d0eefc2c). I thought this post from Quinn “The Eskimo!” @ Developer Technical Support @ Apple would be good to share with your Mac development team:. Resolving Gatekeeper Problems | Apple Developer Forums:. The post titled ""Resolving Gatekeeper Problems"" on the Apple Developer Forums, written by Quinn ""The Eskimo!"" from Developer Technical Support at Apple is a comprehensive guide addressing common issues related to Gatekeeper on macOS. Gatekeeper is a security feature designed to ensure that only trusted software runs on a user's Mac, and the post focuses on helping developers troubleshoot and resolve issues that may arise in this context.; The post identifies four common Gatekeeper problems that developers may encounter:. 1. App blocked by a dangling load command path.; 2. Broken code signature.; 3. Lack of notarization.; 4. Command-line tool blocked by Gatekeeper. For each of these issues, the post provides detailed steps and guidance on how developers can resolve them. The emphasis is on the importance of passing Gatekeeper checks to maintain customer trust and avoid potential loss of customers.; Key points covered in the post include:. • Verification of Code Signature: Developers are advised to use the codesign tool to verify that their code is signed correctly. The post provides examples of command-line usage to check for issues such as missing or invalid sealed resources.; • Notarization Issues: Gatekeeper requires that apps be notarized, and the post guides developers on how to identify and resolve notarization",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:3657,Security,Hash,Hash,3657,"es related to Gatekeeper on macOS. Gatekeeper is a security feature designed to ensure that only trusted software runs on a user's Mac, and the post focuses on helping developers troubleshoot and resolve issues that may arise in this context.; The post identifies four common Gatekeeper problems that developers may encounter:. 1. App blocked by a dangling load command path.; 2. Broken code signature.; 3. Lack of notarization.; 4. Command-line tool blocked by Gatekeeper. For each of these issues, the post provides detailed steps and guidance on how developers can resolve them. The emphasis is on the importance of passing Gatekeeper checks to maintain customer trust and avoid potential loss of customers.; Key points covered in the post include:. • Verification of Code Signature: Developers are advised to use the codesign tool to verify that their code is signed correctly. The post provides examples of command-line usage to check for issues such as missing or invalid sealed resources.; • Notarization Issues: Gatekeeper requires that apps be notarized, and the post guides developers on how to identify and resolve notarization problems. It includes information on checking system logs for specific entries related to notarization issues.; • Hash Mismatch: In cases where there's a hash mismatch, the post provides guidance based on the file type (e.g., zip archive, signed disk image, installer package) and recommends specific actions to address the problem.; • Command-line Tool Blocking Bug: A known bug in macOS is acknowledged, where double-clicking a command-line tool in Finder may lead to it being blocked by Gatekeeper. Workarounds, such as embedding the tool in an application or using an installer package, are suggested. Throughout the post, there are references to Apple's documentation and resources related to code signing and notarization, providing developers with additional information for a deeper understanding. https://forums.developer.apple.com/forums/thread/706379",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:3697,Security,hash,hash,3697,"es related to Gatekeeper on macOS. Gatekeeper is a security feature designed to ensure that only trusted software runs on a user's Mac, and the post focuses on helping developers troubleshoot and resolve issues that may arise in this context.; The post identifies four common Gatekeeper problems that developers may encounter:. 1. App blocked by a dangling load command path.; 2. Broken code signature.; 3. Lack of notarization.; 4. Command-line tool blocked by Gatekeeper. For each of these issues, the post provides detailed steps and guidance on how developers can resolve them. The emphasis is on the importance of passing Gatekeeper checks to maintain customer trust and avoid potential loss of customers.; Key points covered in the post include:. • Verification of Code Signature: Developers are advised to use the codesign tool to verify that their code is signed correctly. The post provides examples of command-line usage to check for issues such as missing or invalid sealed resources.; • Notarization Issues: Gatekeeper requires that apps be notarized, and the post guides developers on how to identify and resolve notarization problems. It includes information on checking system logs for specific entries related to notarization issues.; • Hash Mismatch: In cases where there's a hash mismatch, the post provides guidance based on the file type (e.g., zip archive, signed disk image, installer package) and recommends specific actions to address the problem.; • Command-line Tool Blocking Bug: A known bug in macOS is acknowledged, where double-clicking a command-line tool in Finder may lead to it being blocked by Gatekeeper. Workarounds, such as embedding the tool in an application or using an installer package, are suggested. Throughout the post, there are references to Apple's documentation and resources related to code signing and notarization, providing developers with additional information for a deeper understanding. https://forums.developer.apple.com/forums/thread/706379",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:1757,Testability,test,test,1757,"r Identity Verification: Ad-hoc signatures don’t provide information about the developer’s identity, unlike certificates from Apple, which are linked to verified developer accounts. This can pose security risks as it’s harder to establish trust in the source of the code. Limited Use Cases: Ad-hoc signing is typically used for specific scenarios, such as:; Unsigned code running on Apple Silicon, where macOS requires all code to be signed, even if it’s just ad-hoc.; Web Apps on macOS 14 Sonoma, where the code isn't distributed via traditional app distribution methods. Security Risks: Since there is no certification authority involved in ad-hoc signing, it is easier for malicious or unauthorized code to be signed ad-hoc and executed, which could expose the system to potential vulnerabilities. I would recommend moving away from ad-hoc certificates and following the Apple Developer guidelines on application creation & distribution. For example, here is a free GUI application called ""Apparency"" that will help explain issues and test your applications.; https://mothersruin.com/software/Apparency/. ![image](https://github.com/user-attachments/assets/d69830e4-e271-430a-987c-c58b1b708481); ![image](https://github.com/user-attachments/assets/4a03b7ba-c911-486b-91de-2d86d0eefc2c). I thought this post from Quinn “The Eskimo!” @ Developer Technical Support @ Apple would be good to share with your Mac development team:. Resolving Gatekeeper Problems | Apple Developer Forums:. The post titled ""Resolving Gatekeeper Problems"" on the Apple Developer Forums, written by Quinn ""The Eskimo!"" from Developer Technical Support at Apple is a comprehensive guide addressing common issues related to Gatekeeper on macOS. Gatekeeper is a security feature designed to ensure that only trusted software runs on a user's Mac, and the post focuses on helping developers troubleshoot and resolve issues that may arise in this context.; The post identifies four common Gatekeeper problems that developers may ",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:3596,Testability,log,logs,3596,"es related to Gatekeeper on macOS. Gatekeeper is a security feature designed to ensure that only trusted software runs on a user's Mac, and the post focuses on helping developers troubleshoot and resolve issues that may arise in this context.; The post identifies four common Gatekeeper problems that developers may encounter:. 1. App blocked by a dangling load command path.; 2. Broken code signature.; 3. Lack of notarization.; 4. Command-line tool blocked by Gatekeeper. For each of these issues, the post provides detailed steps and guidance on how developers can resolve them. The emphasis is on the importance of passing Gatekeeper checks to maintain customer trust and avoid potential loss of customers.; Key points covered in the post include:. • Verification of Code Signature: Developers are advised to use the codesign tool to verify that their code is signed correctly. The post provides examples of command-line usage to check for issues such as missing or invalid sealed resources.; • Notarization Issues: Gatekeeper requires that apps be notarized, and the post guides developers on how to identify and resolve notarization problems. It includes information on checking system logs for specific entries related to notarization issues.; • Hash Mismatch: In cases where there's a hash mismatch, the post provides guidance based on the file type (e.g., zip archive, signed disk image, installer package) and recommends specific actions to address the problem.; • Command-line Tool Blocking Bug: A known bug in macOS is acknowledged, where double-clicking a command-line tool in Finder may lead to it being blocked by Gatekeeper. Workarounds, such as embedding the tool in an application or using an installer package, are suggested. Throughout the post, there are references to Apple's documentation and resources related to code signing and notarization, providing developers with additional information for a deeper understanding. https://forums.developer.apple.com/forums/thread/706379",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:1609,Usability,guid,guidelines,1609,"way to confirm who signed the code or if it comes from a trusted source. Key concerns with ad-hoc signatures include:. No Developer Identity Verification: Ad-hoc signatures don’t provide information about the developer’s identity, unlike certificates from Apple, which are linked to verified developer accounts. This can pose security risks as it’s harder to establish trust in the source of the code. Limited Use Cases: Ad-hoc signing is typically used for specific scenarios, such as:; Unsigned code running on Apple Silicon, where macOS requires all code to be signed, even if it’s just ad-hoc.; Web Apps on macOS 14 Sonoma, where the code isn't distributed via traditional app distribution methods. Security Risks: Since there is no certification authority involved in ad-hoc signing, it is easier for malicious or unauthorized code to be signed ad-hoc and executed, which could expose the system to potential vulnerabilities. I would recommend moving away from ad-hoc certificates and following the Apple Developer guidelines on application creation & distribution. For example, here is a free GUI application called ""Apparency"" that will help explain issues and test your applications.; https://mothersruin.com/software/Apparency/. ![image](https://github.com/user-attachments/assets/d69830e4-e271-430a-987c-c58b1b708481); ![image](https://github.com/user-attachments/assets/4a03b7ba-c911-486b-91de-2d86d0eefc2c). I thought this post from Quinn “The Eskimo!” @ Developer Technical Support @ Apple would be good to share with your Mac development team:. Resolving Gatekeeper Problems | Apple Developer Forums:. The post titled ""Resolving Gatekeeper Problems"" on the Apple Developer Forums, written by Quinn ""The Eskimo!"" from Developer Technical Support at Apple is a comprehensive guide addressing common issues related to Gatekeeper on macOS. Gatekeeper is a security feature designed to ensure that only trusted software runs on a user's Mac, and the post focuses on helping developers troubl",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:2376,Usability,guid,guide,2376,"s no certification authority involved in ad-hoc signing, it is easier for malicious or unauthorized code to be signed ad-hoc and executed, which could expose the system to potential vulnerabilities. I would recommend moving away from ad-hoc certificates and following the Apple Developer guidelines on application creation & distribution. For example, here is a free GUI application called ""Apparency"" that will help explain issues and test your applications.; https://mothersruin.com/software/Apparency/. ![image](https://github.com/user-attachments/assets/d69830e4-e271-430a-987c-c58b1b708481); ![image](https://github.com/user-attachments/assets/4a03b7ba-c911-486b-91de-2d86d0eefc2c). I thought this post from Quinn “The Eskimo!” @ Developer Technical Support @ Apple would be good to share with your Mac development team:. Resolving Gatekeeper Problems | Apple Developer Forums:. The post titled ""Resolving Gatekeeper Problems"" on the Apple Developer Forums, written by Quinn ""The Eskimo!"" from Developer Technical Support at Apple is a comprehensive guide addressing common issues related to Gatekeeper on macOS. Gatekeeper is a security feature designed to ensure that only trusted software runs on a user's Mac, and the post focuses on helping developers troubleshoot and resolve issues that may arise in this context.; The post identifies four common Gatekeeper problems that developers may encounter:. 1. App blocked by a dangling load command path.; 2. Broken code signature.; 3. Lack of notarization.; 4. Command-line tool blocked by Gatekeeper. For each of these issues, the post provides detailed steps and guidance on how developers can resolve them. The emphasis is on the importance of passing Gatekeeper checks to maintain customer trust and avoid potential loss of customers.; Key points covered in the post include:. • Verification of Code Signature: Developers are advised to use the codesign tool to verify that their code is signed correctly. The post provides examples of comma",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:2941,Usability,guid,guidance,2941,"s://github.com/user-attachments/assets/4a03b7ba-c911-486b-91de-2d86d0eefc2c). I thought this post from Quinn “The Eskimo!” @ Developer Technical Support @ Apple would be good to share with your Mac development team:. Resolving Gatekeeper Problems | Apple Developer Forums:. The post titled ""Resolving Gatekeeper Problems"" on the Apple Developer Forums, written by Quinn ""The Eskimo!"" from Developer Technical Support at Apple is a comprehensive guide addressing common issues related to Gatekeeper on macOS. Gatekeeper is a security feature designed to ensure that only trusted software runs on a user's Mac, and the post focuses on helping developers troubleshoot and resolve issues that may arise in this context.; The post identifies four common Gatekeeper problems that developers may encounter:. 1. App blocked by a dangling load command path.; 2. Broken code signature.; 3. Lack of notarization.; 4. Command-line tool blocked by Gatekeeper. For each of these issues, the post provides detailed steps and guidance on how developers can resolve them. The emphasis is on the importance of passing Gatekeeper checks to maintain customer trust and avoid potential loss of customers.; Key points covered in the post include:. • Verification of Code Signature: Developers are advised to use the codesign tool to verify that their code is signed correctly. The post provides examples of command-line usage to check for issues such as missing or invalid sealed resources.; • Notarization Issues: Gatekeeper requires that apps be notarized, and the post guides developers on how to identify and resolve notarization problems. It includes information on checking system logs for specific entries related to notarization issues.; • Hash Mismatch: In cases where there's a hash mismatch, the post provides guidance based on the file type (e.g., zip archive, signed disk image, installer package) and recommends specific actions to address the problem.; • Command-line Tool Blocking Bug: A known bug in macOS",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:3481,Usability,guid,guides,3481,"es related to Gatekeeper on macOS. Gatekeeper is a security feature designed to ensure that only trusted software runs on a user's Mac, and the post focuses on helping developers troubleshoot and resolve issues that may arise in this context.; The post identifies four common Gatekeeper problems that developers may encounter:. 1. App blocked by a dangling load command path.; 2. Broken code signature.; 3. Lack of notarization.; 4. Command-line tool blocked by Gatekeeper. For each of these issues, the post provides detailed steps and guidance on how developers can resolve them. The emphasis is on the importance of passing Gatekeeper checks to maintain customer trust and avoid potential loss of customers.; Key points covered in the post include:. • Verification of Code Signature: Developers are advised to use the codesign tool to verify that their code is signed correctly. The post provides examples of command-line usage to check for issues such as missing or invalid sealed resources.; • Notarization Issues: Gatekeeper requires that apps be notarized, and the post guides developers on how to identify and resolve notarization problems. It includes information on checking system logs for specific entries related to notarization issues.; • Hash Mismatch: In cases where there's a hash mismatch, the post provides guidance based on the file type (e.g., zip archive, signed disk image, installer package) and recommends specific actions to address the problem.; • Command-line Tool Blocking Bug: A known bug in macOS is acknowledged, where double-clicking a command-line tool in Finder may lead to it being blocked by Gatekeeper. Workarounds, such as embedding the tool in an application or using an installer package, are suggested. Throughout the post, there are references to Apple's documentation and resources related to code signing and notarization, providing developers with additional information for a deeper understanding. https://forums.developer.apple.com/forums/thread/706379",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1672:3730,Usability,guid,guidance,3730,"es related to Gatekeeper on macOS. Gatekeeper is a security feature designed to ensure that only trusted software runs on a user's Mac, and the post focuses on helping developers troubleshoot and resolve issues that may arise in this context.; The post identifies four common Gatekeeper problems that developers may encounter:. 1. App blocked by a dangling load command path.; 2. Broken code signature.; 3. Lack of notarization.; 4. Command-line tool blocked by Gatekeeper. For each of these issues, the post provides detailed steps and guidance on how developers can resolve them. The emphasis is on the importance of passing Gatekeeper checks to maintain customer trust and avoid potential loss of customers.; Key points covered in the post include:. • Verification of Code Signature: Developers are advised to use the codesign tool to verify that their code is signed correctly. The post provides examples of command-line usage to check for issues such as missing or invalid sealed resources.; • Notarization Issues: Gatekeeper requires that apps be notarized, and the post guides developers on how to identify and resolve notarization problems. It includes information on checking system logs for specific entries related to notarization issues.; • Hash Mismatch: In cases where there's a hash mismatch, the post provides guidance based on the file type (e.g., zip archive, signed disk image, installer package) and recommends specific actions to address the problem.; • Command-line Tool Blocking Bug: A known bug in macOS is acknowledged, where double-clicking a command-line tool in Finder may lead to it being blocked by Gatekeeper. Workarounds, such as embedding the tool in an application or using an installer package, are suggested. Throughout the post, there are references to Apple's documentation and resources related to code signing and notarization, providing developers with additional information for a deeper understanding. https://forums.developer.apple.com/forums/thread/706379",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/pull/1673:299,Availability,avail,available,299,"We can only apply one CSS stylesheet to WebViews - which is used by the `WebViews` class to bind to dark mode changes. Therefore we need to add any interesting custom formatting to those shared stylesheets. This PR then adds some provisional support for nicer blockquote formatting, so that this is available elsewhere if needed (note that it's subject to change when someone who is better at css looks at it).",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1673
https://github.com/qupath/qupath/issues/1674:85,Availability,mask,mask,85,"## Bug report. ### Describe the bug; When using complicated 'polygon' ROIs, a binary mask in QuPath can differ _a lot_ from a binary mask generated in ImageJ. This means that code or scripts using ImageJ for processing could potentially give unexpected results, if a mask is generated on the ImageJ side. Some observations:; * The QuPath mask *is* consistent with what is shown in QuPath's viewer, and the ImageJ mask *is* consistent with ImageJ's behavior - so neither needs to be 'wrong'.; * A potential explanation is the winding rule: ImageJ uses [`WIND_EVEN_ODD`](https://github.com/imagej/ImageJ/blob/7d8d18b0dd78582cbc7ebf3cde745d5a8ac32007/ij/gui/ShapeRoi.java#L355), while QuPath doesn't appear to specify a rule - and Java's default is [`WIND_NON_ZERO`](https://docs.oracle.com/en/java/javase/21/docs/api/java.desktop/java/awt/geom/Path2D.Double.html#%3Cinit%3E()).; * The problem affects `PolygonROIs` with self-intersections, which would be invalid in the JTS sense.; * The issue goes away if the `PolygonROI` is converted to a `GeometryROI` (which usually happens from any automatically-generated ROIs, just not for ones created interactively with the polygon tool in the viewer). ### To Reproduce; You can import the following GeoJSON:. ```groovy; {; ""type"": ""Feature"",; ""id"": ""528308d5-bb0a-46c9-9906-3812f9edfd58"",; ""geometry"": {; ""type"": ""MultiPolygon"",; ""coordinates"": [; [; [; [30276.88, 45038.84],; [30376.29, 45337.05],; [31072.12, 45784.38],; [32314.67, 46231.69],; [33756.03, 46579.61],; [35147.68, 46828.12],; [36738.15, 47076.63],; [38328.62, 47374.84],; [39521.46, 47722.75],; [40465.8, 48020.96],; [41310.74, 48368.88],; [42056.27, 48766.5],; [42752.1, 49114.41],; [43597.04, 49512.03],; [44541.37, 49859.94],; [45485.71, 50058.75],; [45827.24, 50105.32],; [45535.41, 49313.22],; [45535.41, 48418.58],; [46082.14, 47523.95],; [47274.98, 46679.01],; [48815.75, 45883.78],; [50207.41, 45287.35],; [51052.34, 44790.33],; [51400.26, 44392.71],; [51449.96, 44144.21],; [51052.34,",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1674
https://github.com/qupath/qupath/issues/1674:133,Availability,mask,mask,133,"## Bug report. ### Describe the bug; When using complicated 'polygon' ROIs, a binary mask in QuPath can differ _a lot_ from a binary mask generated in ImageJ. This means that code or scripts using ImageJ for processing could potentially give unexpected results, if a mask is generated on the ImageJ side. Some observations:; * The QuPath mask *is* consistent with what is shown in QuPath's viewer, and the ImageJ mask *is* consistent with ImageJ's behavior - so neither needs to be 'wrong'.; * A potential explanation is the winding rule: ImageJ uses [`WIND_EVEN_ODD`](https://github.com/imagej/ImageJ/blob/7d8d18b0dd78582cbc7ebf3cde745d5a8ac32007/ij/gui/ShapeRoi.java#L355), while QuPath doesn't appear to specify a rule - and Java's default is [`WIND_NON_ZERO`](https://docs.oracle.com/en/java/javase/21/docs/api/java.desktop/java/awt/geom/Path2D.Double.html#%3Cinit%3E()).; * The problem affects `PolygonROIs` with self-intersections, which would be invalid in the JTS sense.; * The issue goes away if the `PolygonROI` is converted to a `GeometryROI` (which usually happens from any automatically-generated ROIs, just not for ones created interactively with the polygon tool in the viewer). ### To Reproduce; You can import the following GeoJSON:. ```groovy; {; ""type"": ""Feature"",; ""id"": ""528308d5-bb0a-46c9-9906-3812f9edfd58"",; ""geometry"": {; ""type"": ""MultiPolygon"",; ""coordinates"": [; [; [; [30276.88, 45038.84],; [30376.29, 45337.05],; [31072.12, 45784.38],; [32314.67, 46231.69],; [33756.03, 46579.61],; [35147.68, 46828.12],; [36738.15, 47076.63],; [38328.62, 47374.84],; [39521.46, 47722.75],; [40465.8, 48020.96],; [41310.74, 48368.88],; [42056.27, 48766.5],; [42752.1, 49114.41],; [43597.04, 49512.03],; [44541.37, 49859.94],; [45485.71, 50058.75],; [45827.24, 50105.32],; [45535.41, 49313.22],; [45535.41, 48418.58],; [46082.14, 47523.95],; [47274.98, 46679.01],; [48815.75, 45883.78],; [50207.41, 45287.35],; [51052.34, 44790.33],; [51400.26, 44392.71],; [51449.96, 44144.21],; [51052.34,",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1674
https://github.com/qupath/qupath/issues/1674:267,Availability,mask,mask,267,"## Bug report. ### Describe the bug; When using complicated 'polygon' ROIs, a binary mask in QuPath can differ _a lot_ from a binary mask generated in ImageJ. This means that code or scripts using ImageJ for processing could potentially give unexpected results, if a mask is generated on the ImageJ side. Some observations:; * The QuPath mask *is* consistent with what is shown in QuPath's viewer, and the ImageJ mask *is* consistent with ImageJ's behavior - so neither needs to be 'wrong'.; * A potential explanation is the winding rule: ImageJ uses [`WIND_EVEN_ODD`](https://github.com/imagej/ImageJ/blob/7d8d18b0dd78582cbc7ebf3cde745d5a8ac32007/ij/gui/ShapeRoi.java#L355), while QuPath doesn't appear to specify a rule - and Java's default is [`WIND_NON_ZERO`](https://docs.oracle.com/en/java/javase/21/docs/api/java.desktop/java/awt/geom/Path2D.Double.html#%3Cinit%3E()).; * The problem affects `PolygonROIs` with self-intersections, which would be invalid in the JTS sense.; * The issue goes away if the `PolygonROI` is converted to a `GeometryROI` (which usually happens from any automatically-generated ROIs, just not for ones created interactively with the polygon tool in the viewer). ### To Reproduce; You can import the following GeoJSON:. ```groovy; {; ""type"": ""Feature"",; ""id"": ""528308d5-bb0a-46c9-9906-3812f9edfd58"",; ""geometry"": {; ""type"": ""MultiPolygon"",; ""coordinates"": [; [; [; [30276.88, 45038.84],; [30376.29, 45337.05],; [31072.12, 45784.38],; [32314.67, 46231.69],; [33756.03, 46579.61],; [35147.68, 46828.12],; [36738.15, 47076.63],; [38328.62, 47374.84],; [39521.46, 47722.75],; [40465.8, 48020.96],; [41310.74, 48368.88],; [42056.27, 48766.5],; [42752.1, 49114.41],; [43597.04, 49512.03],; [44541.37, 49859.94],; [45485.71, 50058.75],; [45827.24, 50105.32],; [45535.41, 49313.22],; [45535.41, 48418.58],; [46082.14, 47523.95],; [47274.98, 46679.01],; [48815.75, 45883.78],; [50207.41, 45287.35],; [51052.34, 44790.33],; [51400.26, 44392.71],; [51449.96, 44144.21],; [51052.34,",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1674
https://github.com/qupath/qupath/issues/1674:338,Availability,mask,mask,338,"## Bug report. ### Describe the bug; When using complicated 'polygon' ROIs, a binary mask in QuPath can differ _a lot_ from a binary mask generated in ImageJ. This means that code or scripts using ImageJ for processing could potentially give unexpected results, if a mask is generated on the ImageJ side. Some observations:; * The QuPath mask *is* consistent with what is shown in QuPath's viewer, and the ImageJ mask *is* consistent with ImageJ's behavior - so neither needs to be 'wrong'.; * A potential explanation is the winding rule: ImageJ uses [`WIND_EVEN_ODD`](https://github.com/imagej/ImageJ/blob/7d8d18b0dd78582cbc7ebf3cde745d5a8ac32007/ij/gui/ShapeRoi.java#L355), while QuPath doesn't appear to specify a rule - and Java's default is [`WIND_NON_ZERO`](https://docs.oracle.com/en/java/javase/21/docs/api/java.desktop/java/awt/geom/Path2D.Double.html#%3Cinit%3E()).; * The problem affects `PolygonROIs` with self-intersections, which would be invalid in the JTS sense.; * The issue goes away if the `PolygonROI` is converted to a `GeometryROI` (which usually happens from any automatically-generated ROIs, just not for ones created interactively with the polygon tool in the viewer). ### To Reproduce; You can import the following GeoJSON:. ```groovy; {; ""type"": ""Feature"",; ""id"": ""528308d5-bb0a-46c9-9906-3812f9edfd58"",; ""geometry"": {; ""type"": ""MultiPolygon"",; ""coordinates"": [; [; [; [30276.88, 45038.84],; [30376.29, 45337.05],; [31072.12, 45784.38],; [32314.67, 46231.69],; [33756.03, 46579.61],; [35147.68, 46828.12],; [36738.15, 47076.63],; [38328.62, 47374.84],; [39521.46, 47722.75],; [40465.8, 48020.96],; [41310.74, 48368.88],; [42056.27, 48766.5],; [42752.1, 49114.41],; [43597.04, 49512.03],; [44541.37, 49859.94],; [45485.71, 50058.75],; [45827.24, 50105.32],; [45535.41, 49313.22],; [45535.41, 48418.58],; [46082.14, 47523.95],; [47274.98, 46679.01],; [48815.75, 45883.78],; [50207.41, 45287.35],; [51052.34, 44790.33],; [51400.26, 44392.71],; [51449.96, 44144.21],; [51052.34,",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1674
https://github.com/qupath/qupath/issues/1674:413,Availability,mask,mask,413,"## Bug report. ### Describe the bug; When using complicated 'polygon' ROIs, a binary mask in QuPath can differ _a lot_ from a binary mask generated in ImageJ. This means that code or scripts using ImageJ for processing could potentially give unexpected results, if a mask is generated on the ImageJ side. Some observations:; * The QuPath mask *is* consistent with what is shown in QuPath's viewer, and the ImageJ mask *is* consistent with ImageJ's behavior - so neither needs to be 'wrong'.; * A potential explanation is the winding rule: ImageJ uses [`WIND_EVEN_ODD`](https://github.com/imagej/ImageJ/blob/7d8d18b0dd78582cbc7ebf3cde745d5a8ac32007/ij/gui/ShapeRoi.java#L355), while QuPath doesn't appear to specify a rule - and Java's default is [`WIND_NON_ZERO`](https://docs.oracle.com/en/java/javase/21/docs/api/java.desktop/java/awt/geom/Path2D.Double.html#%3Cinit%3E()).; * The problem affects `PolygonROIs` with self-intersections, which would be invalid in the JTS sense.; * The issue goes away if the `PolygonROI` is converted to a `GeometryROI` (which usually happens from any automatically-generated ROIs, just not for ones created interactively with the polygon tool in the viewer). ### To Reproduce; You can import the following GeoJSON:. ```groovy; {; ""type"": ""Feature"",; ""id"": ""528308d5-bb0a-46c9-9906-3812f9edfd58"",; ""geometry"": {; ""type"": ""MultiPolygon"",; ""coordinates"": [; [; [; [30276.88, 45038.84],; [30376.29, 45337.05],; [31072.12, 45784.38],; [32314.67, 46231.69],; [33756.03, 46579.61],; [35147.68, 46828.12],; [36738.15, 47076.63],; [38328.62, 47374.84],; [39521.46, 47722.75],; [40465.8, 48020.96],; [41310.74, 48368.88],; [42056.27, 48766.5],; [42752.1, 49114.41],; [43597.04, 49512.03],; [44541.37, 49859.94],; [45485.71, 50058.75],; [45827.24, 50105.32],; [45535.41, 49313.22],; [45535.41, 48418.58],; [46082.14, 47523.95],; [47274.98, 46679.01],; [48815.75, 45883.78],; [50207.41, 45287.35],; [51052.34, 44790.33],; [51400.26, 44392.71],; [51449.96, 44144.21],; [51052.34,",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1674
https://github.com/qupath/qupath/issues/1674:6451,Availability,mask,mask,6451,".71, 25406.53],; [68746.27, 25903.55],; [65515.64, 26698.79],; [63629.79, 27496.64]; ]; ],; [; [; [66332.49, 38226.36],; [67901.34, 39472.21],; [69193.59, 40714.77],; [70137.93, 41758.51],; [70883.46, 42653.14],; [71239.44, 43151.51],; [74809.92, 43746.59],; [77493.84, 44243.61],; [79879.53, 44591.52],; [81619.1, 44740.63],; [82712.55, 44740.63],; [83358.68, 44641.23],; [83706.59, 44392.71],; [83905.4, 43945.4],; [83855.7, 43050.76],; [83358.68, 41609.4],; [82265.23, 39919.53],; [80426.26, 38130.26],; [77891.45, 36589.49],; [74809.92, 35545.75],; [71529.59, 35098.43],; [69094.19, 35396.64],; [67454.02, 36191.88],; [66509.68, 37384.73],; [66332.49, 38226.36]; ]; ]; ]; },; ""properties"": {; ""objectType"": ""annotation"",; ""measurements"": {; ""Area µm^2"": 3.5567575437333584E7,; ""Length µm"": 62782.89619349399,; ""Solidity"": 0.5638625874807928,; ""Max diameter µm"": 12192.853113808404,; ""Min diameter µm"": 7673.144125811996; }; }; }; ```. The following script creates a mask the 'QuPath' way:; ```groovy; def roi = getSelectedROI(); def mask = BufferedImageTools.createROIMask(roi, 10); new ij.ImagePlus(""Mask"", mask).show(); ```. You can generate an 'ImageJ' mask using _Extensions → ImageJ → Send region to ImageJ_ and then _Edit > Selection > Create Mask_. ### Expected behavior; When sending a QuPath ROI to ImageJ, any masks generated in either application should be identical - or at least very similar. This might be achieved by converting complicated `PolygonROI` instances into `GeometryROIs`. ### Screenshots; #### In QuPath; <img width=""903"" alt=""QuPath mask"" src=""https://github.com/user-attachments/assets/5ebd2fc7-12ef-4cec-8928-115fece9fe4e"">. #### In ImageJ; <img width=""903"" alt=""ImageJ mask"" src=""https://github.com/user-attachments/assets/0af83a44-d1d0-4cc9-b706-0d337eec2769"">. ### Desktop (please complete the following information):; - OS: All; - QuPath Version: 0.5.1 (presumably earlier versions too). ### Additional context; ImageJ's choice of winding rule may well be more se",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1674
https://github.com/qupath/qupath/issues/1674:6518,Availability,mask,mask,6518,".71, 25406.53],; [68746.27, 25903.55],; [65515.64, 26698.79],; [63629.79, 27496.64]; ]; ],; [; [; [66332.49, 38226.36],; [67901.34, 39472.21],; [69193.59, 40714.77],; [70137.93, 41758.51],; [70883.46, 42653.14],; [71239.44, 43151.51],; [74809.92, 43746.59],; [77493.84, 44243.61],; [79879.53, 44591.52],; [81619.1, 44740.63],; [82712.55, 44740.63],; [83358.68, 44641.23],; [83706.59, 44392.71],; [83905.4, 43945.4],; [83855.7, 43050.76],; [83358.68, 41609.4],; [82265.23, 39919.53],; [80426.26, 38130.26],; [77891.45, 36589.49],; [74809.92, 35545.75],; [71529.59, 35098.43],; [69094.19, 35396.64],; [67454.02, 36191.88],; [66509.68, 37384.73],; [66332.49, 38226.36]; ]; ]; ]; },; ""properties"": {; ""objectType"": ""annotation"",; ""measurements"": {; ""Area µm^2"": 3.5567575437333584E7,; ""Length µm"": 62782.89619349399,; ""Solidity"": 0.5638625874807928,; ""Max diameter µm"": 12192.853113808404,; ""Min diameter µm"": 7673.144125811996; }; }; }; ```. The following script creates a mask the 'QuPath' way:; ```groovy; def roi = getSelectedROI(); def mask = BufferedImageTools.createROIMask(roi, 10); new ij.ImagePlus(""Mask"", mask).show(); ```. You can generate an 'ImageJ' mask using _Extensions → ImageJ → Send region to ImageJ_ and then _Edit > Selection > Create Mask_. ### Expected behavior; When sending a QuPath ROI to ImageJ, any masks generated in either application should be identical - or at least very similar. This might be achieved by converting complicated `PolygonROI` instances into `GeometryROIs`. ### Screenshots; #### In QuPath; <img width=""903"" alt=""QuPath mask"" src=""https://github.com/user-attachments/assets/5ebd2fc7-12ef-4cec-8928-115fece9fe4e"">. #### In ImageJ; <img width=""903"" alt=""ImageJ mask"" src=""https://github.com/user-attachments/assets/0af83a44-d1d0-4cc9-b706-0d337eec2769"">. ### Desktop (please complete the following information):; - OS: All; - QuPath Version: 0.5.1 (presumably earlier versions too). ### Additional context; ImageJ's choice of winding rule may well be more se",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1674
https://github.com/qupath/qupath/issues/1674:6586,Availability,Mask,Mask,6586,"9, 38226.36],; [67901.34, 39472.21],; [69193.59, 40714.77],; [70137.93, 41758.51],; [70883.46, 42653.14],; [71239.44, 43151.51],; [74809.92, 43746.59],; [77493.84, 44243.61],; [79879.53, 44591.52],; [81619.1, 44740.63],; [82712.55, 44740.63],; [83358.68, 44641.23],; [83706.59, 44392.71],; [83905.4, 43945.4],; [83855.7, 43050.76],; [83358.68, 41609.4],; [82265.23, 39919.53],; [80426.26, 38130.26],; [77891.45, 36589.49],; [74809.92, 35545.75],; [71529.59, 35098.43],; [69094.19, 35396.64],; [67454.02, 36191.88],; [66509.68, 37384.73],; [66332.49, 38226.36]; ]; ]; ]; },; ""properties"": {; ""objectType"": ""annotation"",; ""measurements"": {; ""Area µm^2"": 3.5567575437333584E7,; ""Length µm"": 62782.89619349399,; ""Solidity"": 0.5638625874807928,; ""Max diameter µm"": 12192.853113808404,; ""Min diameter µm"": 7673.144125811996; }; }; }; ```. The following script creates a mask the 'QuPath' way:; ```groovy; def roi = getSelectedROI(); def mask = BufferedImageTools.createROIMask(roi, 10); new ij.ImagePlus(""Mask"", mask).show(); ```. You can generate an 'ImageJ' mask using _Extensions → ImageJ → Send region to ImageJ_ and then _Edit > Selection > Create Mask_. ### Expected behavior; When sending a QuPath ROI to ImageJ, any masks generated in either application should be identical - or at least very similar. This might be achieved by converting complicated `PolygonROI` instances into `GeometryROIs`. ### Screenshots; #### In QuPath; <img width=""903"" alt=""QuPath mask"" src=""https://github.com/user-attachments/assets/5ebd2fc7-12ef-4cec-8928-115fece9fe4e"">. #### In ImageJ; <img width=""903"" alt=""ImageJ mask"" src=""https://github.com/user-attachments/assets/0af83a44-d1d0-4cc9-b706-0d337eec2769"">. ### Desktop (please complete the following information):; - OS: All; - QuPath Version: 0.5.1 (presumably earlier versions too). ### Additional context; ImageJ's choice of winding rule may well be more sensible - but it is not something we should change in QuPath too quickly. This clearly *could* be a seriou",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1674
https://github.com/qupath/qupath/issues/1674:6593,Availability,mask,mask,6593,"9, 38226.36],; [67901.34, 39472.21],; [69193.59, 40714.77],; [70137.93, 41758.51],; [70883.46, 42653.14],; [71239.44, 43151.51],; [74809.92, 43746.59],; [77493.84, 44243.61],; [79879.53, 44591.52],; [81619.1, 44740.63],; [82712.55, 44740.63],; [83358.68, 44641.23],; [83706.59, 44392.71],; [83905.4, 43945.4],; [83855.7, 43050.76],; [83358.68, 41609.4],; [82265.23, 39919.53],; [80426.26, 38130.26],; [77891.45, 36589.49],; [74809.92, 35545.75],; [71529.59, 35098.43],; [69094.19, 35396.64],; [67454.02, 36191.88],; [66509.68, 37384.73],; [66332.49, 38226.36]; ]; ]; ]; },; ""properties"": {; ""objectType"": ""annotation"",; ""measurements"": {; ""Area µm^2"": 3.5567575437333584E7,; ""Length µm"": 62782.89619349399,; ""Solidity"": 0.5638625874807928,; ""Max diameter µm"": 12192.853113808404,; ""Min diameter µm"": 7673.144125811996; }; }; }; ```. The following script creates a mask the 'QuPath' way:; ```groovy; def roi = getSelectedROI(); def mask = BufferedImageTools.createROIMask(roi, 10); new ij.ImagePlus(""Mask"", mask).show(); ```. You can generate an 'ImageJ' mask using _Extensions → ImageJ → Send region to ImageJ_ and then _Edit > Selection > Create Mask_. ### Expected behavior; When sending a QuPath ROI to ImageJ, any masks generated in either application should be identical - or at least very similar. This might be achieved by converting complicated `PolygonROI` instances into `GeometryROIs`. ### Screenshots; #### In QuPath; <img width=""903"" alt=""QuPath mask"" src=""https://github.com/user-attachments/assets/5ebd2fc7-12ef-4cec-8928-115fece9fe4e"">. #### In ImageJ; <img width=""903"" alt=""ImageJ mask"" src=""https://github.com/user-attachments/assets/0af83a44-d1d0-4cc9-b706-0d337eec2769"">. ### Desktop (please complete the following information):; - OS: All; - QuPath Version: 0.5.1 (presumably earlier versions too). ### Additional context; ImageJ's choice of winding rule may well be more sensible - but it is not something we should change in QuPath too quickly. This clearly *could* be a seriou",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1674
https://github.com/qupath/qupath/issues/1674:6641,Availability,mask,mask,6641,"83.46, 42653.14],; [71239.44, 43151.51],; [74809.92, 43746.59],; [77493.84, 44243.61],; [79879.53, 44591.52],; [81619.1, 44740.63],; [82712.55, 44740.63],; [83358.68, 44641.23],; [83706.59, 44392.71],; [83905.4, 43945.4],; [83855.7, 43050.76],; [83358.68, 41609.4],; [82265.23, 39919.53],; [80426.26, 38130.26],; [77891.45, 36589.49],; [74809.92, 35545.75],; [71529.59, 35098.43],; [69094.19, 35396.64],; [67454.02, 36191.88],; [66509.68, 37384.73],; [66332.49, 38226.36]; ]; ]; ]; },; ""properties"": {; ""objectType"": ""annotation"",; ""measurements"": {; ""Area µm^2"": 3.5567575437333584E7,; ""Length µm"": 62782.89619349399,; ""Solidity"": 0.5638625874807928,; ""Max diameter µm"": 12192.853113808404,; ""Min diameter µm"": 7673.144125811996; }; }; }; ```. The following script creates a mask the 'QuPath' way:; ```groovy; def roi = getSelectedROI(); def mask = BufferedImageTools.createROIMask(roi, 10); new ij.ImagePlus(""Mask"", mask).show(); ```. You can generate an 'ImageJ' mask using _Extensions → ImageJ → Send region to ImageJ_ and then _Edit > Selection > Create Mask_. ### Expected behavior; When sending a QuPath ROI to ImageJ, any masks generated in either application should be identical - or at least very similar. This might be achieved by converting complicated `PolygonROI` instances into `GeometryROIs`. ### Screenshots; #### In QuPath; <img width=""903"" alt=""QuPath mask"" src=""https://github.com/user-attachments/assets/5ebd2fc7-12ef-4cec-8928-115fece9fe4e"">. #### In ImageJ; <img width=""903"" alt=""ImageJ mask"" src=""https://github.com/user-attachments/assets/0af83a44-d1d0-4cc9-b706-0d337eec2769"">. ### Desktop (please complete the following information):; - OS: All; - QuPath Version: 0.5.1 (presumably earlier versions too). ### Additional context; ImageJ's choice of winding rule may well be more sensible - but it is not something we should change in QuPath too quickly. This clearly *could* be a serious problem for some workflows, but I struggle to think of a time when it is likely to have",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1674
https://github.com/qupath/qupath/issues/1674:6805,Availability,mask,masks,6805,"55, 44740.63],; [83358.68, 44641.23],; [83706.59, 44392.71],; [83905.4, 43945.4],; [83855.7, 43050.76],; [83358.68, 41609.4],; [82265.23, 39919.53],; [80426.26, 38130.26],; [77891.45, 36589.49],; [74809.92, 35545.75],; [71529.59, 35098.43],; [69094.19, 35396.64],; [67454.02, 36191.88],; [66509.68, 37384.73],; [66332.49, 38226.36]; ]; ]; ]; },; ""properties"": {; ""objectType"": ""annotation"",; ""measurements"": {; ""Area µm^2"": 3.5567575437333584E7,; ""Length µm"": 62782.89619349399,; ""Solidity"": 0.5638625874807928,; ""Max diameter µm"": 12192.853113808404,; ""Min diameter µm"": 7673.144125811996; }; }; }; ```. The following script creates a mask the 'QuPath' way:; ```groovy; def roi = getSelectedROI(); def mask = BufferedImageTools.createROIMask(roi, 10); new ij.ImagePlus(""Mask"", mask).show(); ```. You can generate an 'ImageJ' mask using _Extensions → ImageJ → Send region to ImageJ_ and then _Edit > Selection > Create Mask_. ### Expected behavior; When sending a QuPath ROI to ImageJ, any masks generated in either application should be identical - or at least very similar. This might be achieved by converting complicated `PolygonROI` instances into `GeometryROIs`. ### Screenshots; #### In QuPath; <img width=""903"" alt=""QuPath mask"" src=""https://github.com/user-attachments/assets/5ebd2fc7-12ef-4cec-8928-115fece9fe4e"">. #### In ImageJ; <img width=""903"" alt=""ImageJ mask"" src=""https://github.com/user-attachments/assets/0af83a44-d1d0-4cc9-b706-0d337eec2769"">. ### Desktop (please complete the following information):; - OS: All; - QuPath Version: 0.5.1 (presumably earlier versions too). ### Additional context; ImageJ's choice of winding rule may well be more sensible - but it is not something we should change in QuPath too quickly. This clearly *could* be a serious problem for some workflows, but I struggle to think of a time when it is likely to have been a problem in reality. It is only likely to impact `PolygonROIs` with self-intersections. While these can be drawn in the viewer, inte",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1674
https://github.com/qupath/qupath/issues/1674:7046,Availability,mask,mask,7046,".75],; [71529.59, 35098.43],; [69094.19, 35396.64],; [67454.02, 36191.88],; [66509.68, 37384.73],; [66332.49, 38226.36]; ]; ]; ]; },; ""properties"": {; ""objectType"": ""annotation"",; ""measurements"": {; ""Area µm^2"": 3.5567575437333584E7,; ""Length µm"": 62782.89619349399,; ""Solidity"": 0.5638625874807928,; ""Max diameter µm"": 12192.853113808404,; ""Min diameter µm"": 7673.144125811996; }; }; }; ```. The following script creates a mask the 'QuPath' way:; ```groovy; def roi = getSelectedROI(); def mask = BufferedImageTools.createROIMask(roi, 10); new ij.ImagePlus(""Mask"", mask).show(); ```. You can generate an 'ImageJ' mask using _Extensions → ImageJ → Send region to ImageJ_ and then _Edit > Selection > Create Mask_. ### Expected behavior; When sending a QuPath ROI to ImageJ, any masks generated in either application should be identical - or at least very similar. This might be achieved by converting complicated `PolygonROI` instances into `GeometryROIs`. ### Screenshots; #### In QuPath; <img width=""903"" alt=""QuPath mask"" src=""https://github.com/user-attachments/assets/5ebd2fc7-12ef-4cec-8928-115fece9fe4e"">. #### In ImageJ; <img width=""903"" alt=""ImageJ mask"" src=""https://github.com/user-attachments/assets/0af83a44-d1d0-4cc9-b706-0d337eec2769"">. ### Desktop (please complete the following information):; - OS: All; - QuPath Version: 0.5.1 (presumably earlier versions too). ### Additional context; ImageJ's choice of winding rule may well be more sensible - but it is not something we should change in QuPath too quickly. This clearly *could* be a serious problem for some workflows, but I struggle to think of a time when it is likely to have been a problem in reality. It is only likely to impact `PolygonROIs` with self-intersections. While these can be drawn in the viewer, internally QuPath will typically convert these to be `GeometryROIs` - and these seem to behave ok. Note that ImageJ's mask generation is in general a bit more sophisticated than QuPaths (see [here](https://github.com/",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1674
https://github.com/qupath/qupath/issues/1674:7185,Availability,mask,mask,7185,"{; ""objectType"": ""annotation"",; ""measurements"": {; ""Area µm^2"": 3.5567575437333584E7,; ""Length µm"": 62782.89619349399,; ""Solidity"": 0.5638625874807928,; ""Max diameter µm"": 12192.853113808404,; ""Min diameter µm"": 7673.144125811996; }; }; }; ```. The following script creates a mask the 'QuPath' way:; ```groovy; def roi = getSelectedROI(); def mask = BufferedImageTools.createROIMask(roi, 10); new ij.ImagePlus(""Mask"", mask).show(); ```. You can generate an 'ImageJ' mask using _Extensions → ImageJ → Send region to ImageJ_ and then _Edit > Selection > Create Mask_. ### Expected behavior; When sending a QuPath ROI to ImageJ, any masks generated in either application should be identical - or at least very similar. This might be achieved by converting complicated `PolygonROI` instances into `GeometryROIs`. ### Screenshots; #### In QuPath; <img width=""903"" alt=""QuPath mask"" src=""https://github.com/user-attachments/assets/5ebd2fc7-12ef-4cec-8928-115fece9fe4e"">. #### In ImageJ; <img width=""903"" alt=""ImageJ mask"" src=""https://github.com/user-attachments/assets/0af83a44-d1d0-4cc9-b706-0d337eec2769"">. ### Desktop (please complete the following information):; - OS: All; - QuPath Version: 0.5.1 (presumably earlier versions too). ### Additional context; ImageJ's choice of winding rule may well be more sensible - but it is not something we should change in QuPath too quickly. This clearly *could* be a serious problem for some workflows, but I struggle to think of a time when it is likely to have been a problem in reality. It is only likely to impact `PolygonROIs` with self-intersections. While these can be drawn in the viewer, internally QuPath will typically convert these to be `GeometryROIs` - and these seem to behave ok. Note that ImageJ's mask generation is in general a bit more sophisticated than QuPaths (see [here](https://github.com/imagej/ImageJ/blob/7d8d18b0dd78582cbc7ebf3cde745d5a8ac32007/ij/gui/ShapeRoi.java#L1024)), which is something that warrants investigation in the fut",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1674
https://github.com/qupath/qupath/issues/1674:7929,Availability,mask,mask,7929,"pe"": ""annotation"",; ""measurements"": {; ""Area µm^2"": 3.5567575437333584E7,; ""Length µm"": 62782.89619349399,; ""Solidity"": 0.5638625874807928,; ""Max diameter µm"": 12192.853113808404,; ""Min diameter µm"": 7673.144125811996; }; }; }; ```. The following script creates a mask the 'QuPath' way:; ```groovy; def roi = getSelectedROI(); def mask = BufferedImageTools.createROIMask(roi, 10); new ij.ImagePlus(""Mask"", mask).show(); ```. You can generate an 'ImageJ' mask using _Extensions → ImageJ → Send region to ImageJ_ and then _Edit > Selection > Create Mask_. ### Expected behavior; When sending a QuPath ROI to ImageJ, any masks generated in either application should be identical - or at least very similar. This might be achieved by converting complicated `PolygonROI` instances into `GeometryROIs`. ### Screenshots; #### In QuPath; <img width=""903"" alt=""QuPath mask"" src=""https://github.com/user-attachments/assets/5ebd2fc7-12ef-4cec-8928-115fece9fe4e"">. #### In ImageJ; <img width=""903"" alt=""ImageJ mask"" src=""https://github.com/user-attachments/assets/0af83a44-d1d0-4cc9-b706-0d337eec2769"">. ### Desktop (please complete the following information):; - OS: All; - QuPath Version: 0.5.1 (presumably earlier versions too). ### Additional context; ImageJ's choice of winding rule may well be more sensible - but it is not something we should change in QuPath too quickly. This clearly *could* be a serious problem for some workflows, but I struggle to think of a time when it is likely to have been a problem in reality. It is only likely to impact `PolygonROIs` with self-intersections. While these can be drawn in the viewer, internally QuPath will typically convert these to be `GeometryROIs` - and these seem to behave ok. Note that ImageJ's mask generation is in general a bit more sophisticated than QuPaths (see [here](https://github.com/imagej/ImageJ/blob/7d8d18b0dd78582cbc7ebf3cde745d5a8ac32007/ij/gui/ShapeRoi.java#L1024)), which is something that warrants investigation in the future as well.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1674
https://github.com/qupath/qupath/issues/1674:7560,Usability,clear,clearly,7560,"pe"": ""annotation"",; ""measurements"": {; ""Area µm^2"": 3.5567575437333584E7,; ""Length µm"": 62782.89619349399,; ""Solidity"": 0.5638625874807928,; ""Max diameter µm"": 12192.853113808404,; ""Min diameter µm"": 7673.144125811996; }; }; }; ```. The following script creates a mask the 'QuPath' way:; ```groovy; def roi = getSelectedROI(); def mask = BufferedImageTools.createROIMask(roi, 10); new ij.ImagePlus(""Mask"", mask).show(); ```. You can generate an 'ImageJ' mask using _Extensions → ImageJ → Send region to ImageJ_ and then _Edit > Selection > Create Mask_. ### Expected behavior; When sending a QuPath ROI to ImageJ, any masks generated in either application should be identical - or at least very similar. This might be achieved by converting complicated `PolygonROI` instances into `GeometryROIs`. ### Screenshots; #### In QuPath; <img width=""903"" alt=""QuPath mask"" src=""https://github.com/user-attachments/assets/5ebd2fc7-12ef-4cec-8928-115fece9fe4e"">. #### In ImageJ; <img width=""903"" alt=""ImageJ mask"" src=""https://github.com/user-attachments/assets/0af83a44-d1d0-4cc9-b706-0d337eec2769"">. ### Desktop (please complete the following information):; - OS: All; - QuPath Version: 0.5.1 (presumably earlier versions too). ### Additional context; ImageJ's choice of winding rule may well be more sensible - but it is not something we should change in QuPath too quickly. This clearly *could* be a serious problem for some workflows, but I struggle to think of a time when it is likely to have been a problem in reality. It is only likely to impact `PolygonROIs` with self-intersections. While these can be drawn in the viewer, internally QuPath will typically convert these to be `GeometryROIs` - and these seem to behave ok. Note that ImageJ's mask generation is in general a bit more sophisticated than QuPaths (see [here](https://github.com/imagej/ImageJ/blob/7d8d18b0dd78582cbc7ebf3cde745d5a8ac32007/ij/gui/ShapeRoi.java#L1024)), which is something that warrants investigation in the future as well.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1674
https://github.com/qupath/qupath/pull/1676:334,Availability,avail,available,334,"* Fix https://github.com/qupath/qupath/issues/1674; * Make the preferences persistent when sending a region to ImageJ]; * Add ""Non-rectangles only"" as an option when sending ROIs to ImageJ, since rectangles tend to correspond to the entire image region... and do more harm than good.; * Use Roi group names for classifications, where available; * Rename setting the plugins directory to 'Set local ImageJ directory' - because it's needed also for LUTs as well. > Note that setting the Roi group logs an error if the ImageJ directory isn't set, because it makes a request for the Glasbey LUT that can't be fulfilled.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1676
https://github.com/qupath/qupath/pull/1676:503,Availability,error,error,503,"* Fix https://github.com/qupath/qupath/issues/1674; * Make the preferences persistent when sending a region to ImageJ]; * Add ""Non-rectangles only"" as an option when sending ROIs to ImageJ, since rectangles tend to correspond to the entire image region... and do more harm than good.; * Use Roi group names for classifications, where available; * Rename setting the plugins directory to 'Set local ImageJ directory' - because it's needed also for LUTs as well. > Note that setting the Roi group logs an error if the ImageJ directory isn't set, because it makes a request for the Glasbey LUT that can't be fulfilled.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1676
https://github.com/qupath/qupath/pull/1676:366,Modifiability,plugin,plugins,366,"* Fix https://github.com/qupath/qupath/issues/1674; * Make the preferences persistent when sending a region to ImageJ]; * Add ""Non-rectangles only"" as an option when sending ROIs to ImageJ, since rectangles tend to correspond to the entire image region... and do more harm than good.; * Use Roi group names for classifications, where available; * Rename setting the plugins directory to 'Set local ImageJ directory' - because it's needed also for LUTs as well. > Note that setting the Roi group logs an error if the ImageJ directory isn't set, because it makes a request for the Glasbey LUT that can't be fulfilled.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1676
https://github.com/qupath/qupath/pull/1676:495,Testability,log,logs,495,"* Fix https://github.com/qupath/qupath/issues/1674; * Make the preferences persistent when sending a region to ImageJ]; * Add ""Non-rectangles only"" as an option when sending ROIs to ImageJ, since rectangles tend to correspond to the entire image region... and do more harm than good.; * Use Roi group names for classifications, where available; * Rename setting the plugins directory to 'Set local ImageJ directory' - because it's needed also for LUTs as well. > Note that setting the Roi group logs an error if the ImageJ directory isn't set, because it makes a request for the Glasbey LUT that can't be fulfilled.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1676
https://github.com/qupath/qupath/pull/1679:29,Integrability,depend,dependencies,29,Seeing if this works... some dependencies in between caused failing tests when run headlessly.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1679
https://github.com/qupath/qupath/pull/1679:68,Testability,test,tests,68,Seeing if this works... some dependencies in between caused failing tests when run headlessly.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1679
https://github.com/qupath/qupath/pull/1680:145,Deployability,release,releases,145,"Detections could sometimes not appear in the viewer.; This was caused by an overly-enthusiastic attempted optimization, introduced in v0.6.0 pre-releases.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1680
https://github.com/qupath/qupath/pull/1680:106,Performance,optimiz,optimization,106,"Detections could sometimes not appear in the viewer.; This was caused by an overly-enthusiastic attempted optimization, introduced in v0.6.0 pre-releases.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1680
https://github.com/qupath/qupath/pull/1680:0,Safety,Detect,Detections,0,"Detections could sometimes not appear in the viewer.; This was caused by an overly-enthusiastic attempted optimization, introduced in v0.6.0 pre-releases.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1680
https://github.com/qupath/qupath/pull/1681:95,Usability,simpl,simplified,95,Improve rendering of complex ROIs with many small pieces at low resolution. The viewer creates simplified shapes for faster rendering at low resolution by discarding vertices.; However this can result in regions corresponding to a few pieces becoming triangles... and looking incongruously 'pointy'. This PR takes a simple approach of not simplifying any distinct polygons with few vertices - including when these are part of larger multipolygons. ## Before PR; ![CMU-1 (previous)](https://github.com/user-attachments/assets/d4af75a0-756d-47dd-956f-ed0f97fc65aa). ## With PR; ![CMU-1 (New)](https://github.com/user-attachments/assets/63657ad3-2e04-41e0-9d40-6b2319bf305a),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1681
https://github.com/qupath/qupath/pull/1681:316,Usability,simpl,simple,316,Improve rendering of complex ROIs with many small pieces at low resolution. The viewer creates simplified shapes for faster rendering at low resolution by discarding vertices.; However this can result in regions corresponding to a few pieces becoming triangles... and looking incongruously 'pointy'. This PR takes a simple approach of not simplifying any distinct polygons with few vertices - including when these are part of larger multipolygons. ## Before PR; ![CMU-1 (previous)](https://github.com/user-attachments/assets/d4af75a0-756d-47dd-956f-ed0f97fc65aa). ## With PR; ![CMU-1 (New)](https://github.com/user-attachments/assets/63657ad3-2e04-41e0-9d40-6b2319bf305a),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1681
https://github.com/qupath/qupath/pull/1681:339,Usability,simpl,simplifying,339,Improve rendering of complex ROIs with many small pieces at low resolution. The viewer creates simplified shapes for faster rendering at low resolution by discarding vertices.; However this can result in regions corresponding to a few pieces becoming triangles... and looking incongruously 'pointy'. This PR takes a simple approach of not simplifying any distinct polygons with few vertices - including when these are part of larger multipolygons. ## Before PR; ![CMU-1 (previous)](https://github.com/user-attachments/assets/d4af75a0-756d-47dd-956f-ed0f97fc65aa). ## With PR; ![CMU-1 (New)](https://github.com/user-attachments/assets/63657ad3-2e04-41e0-9d40-6b2319bf305a),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1681
https://github.com/qupath/qupath/pull/1682:522,Availability,down,downsample,522,"This replaces the *ImageJ macro runner*. Both can be seen in this screenshot - the old on the left, the new on the right:. ![imagej-macro-runner](https://github.com/user-attachments/assets/851d4ef3-b6cd-423a-bf30-8df12e9de672). Improvements include:; * Syntax highlighting; * Autocomplete with built-in macro functions when pressing `Ctrl+space`; * Better control over which objects are sent for processing; * Better control over resolution, with 3 different methods to control the size of images sent to ImageJ (not just downsample); * Better control over parallelization; * Option to select channels to send; * Built-in examples of potentially-useful macros; * Support for `Roi` groups, which map to QuPath classifications; * Scriptability; macros can be stored in the command history and run later through Groovy scripts; * Ability to run Groovy scripts instead of macros; * These are different from Groovy scripts run through the script editor; they are specifically written to work on an `ImagePlus` obtained from ImageJ via a call to `IJ.getImage()`; * New `IJProcessing` and `IJFilters` classes make it easier to process images obtained this way; * Properties are set in the `ImagePlus` based on the QuPath image type so it's possible to determine a sensible value of `darkBackground` or `lightBackground` in macros or scripts; * Better maintainability through the use of fxml and externalised strings; * Available by the 'ImageJ' toolbar button, not only the menus. This required a *lot* of changes, so there is a reasonable chance things have broken elsewhere... including with the regular script editor (which needed changed to make it possible to generate a script editor control elsewhere). But I think it remains functional... Some limitations:; * It's not possible to control via a script which objects or Rois are sent to ImageJ with an `OverlayOptions` object; * The previous macro runner didn't do this perfectly either - see https://github.com/qupath/qupath/issues/1522 ); * It's not",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1682
https://github.com/qupath/qupath/pull/1682:1412,Availability,Avail,Available,1412,"x highlighting; * Autocomplete with built-in macro functions when pressing `Ctrl+space`; * Better control over which objects are sent for processing; * Better control over resolution, with 3 different methods to control the size of images sent to ImageJ (not just downsample); * Better control over parallelization; * Option to select channels to send; * Built-in examples of potentially-useful macros; * Support for `Roi` groups, which map to QuPath classifications; * Scriptability; macros can be stored in the command history and run later through Groovy scripts; * Ability to run Groovy scripts instead of macros; * These are different from Groovy scripts run through the script editor; they are specifically written to work on an `ImagePlus` obtained from ImageJ via a call to `IJ.getImage()`; * New `IJProcessing` and `IJFilters` classes make it easier to process images obtained this way; * Properties are set in the `ImagePlus` based on the QuPath image type so it's possible to determine a sensible value of `darkBackground` or `lightBackground` in macros or scripts; * Better maintainability through the use of fxml and externalised strings; * Available by the 'ImageJ' toolbar button, not only the menus. This required a *lot* of changes, so there is a reasonable chance things have broken elsewhere... including with the regular script editor (which needed changed to make it possible to generate a script editor control elsewhere). But I think it remains functional... Some limitations:; * It's not possible to control via a script which objects or Rois are sent to ImageJ with an `OverlayOptions` object; * The previous macro runner didn't do this perfectly either - see https://github.com/qupath/qupath/issues/1522 ); * It's not currently possible to send back measurements with objects added to an overlay; * Only 'original' channels can be sent through the user interface, not color deconvolved channels (although scripting gives more options); * The scripting language can't be set e",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1682
https://github.com/qupath/qupath/pull/1682:2137,Integrability,interface,interface,2137,"; * Better control over which objects are sent for processing; * Better control over resolution, with 3 different methods to control the size of images sent to ImageJ (not just downsample); * Better control over parallelization; * Option to select channels to send; * Built-in examples of potentially-useful macros; * Support for `Roi` groups, which map to QuPath classifications; * Scriptability; macros can be stored in the command history and run later through Groovy scripts; * Ability to run Groovy scripts instead of macros; * These are different from Groovy scripts run through the script editor; they are specifically written to work on an `ImagePlus` obtained from ImageJ via a call to `IJ.getImage()`; * New `IJProcessing` and `IJFilters` classes make it easier to process images obtained this way; * Properties are set in the `ImagePlus` based on the QuPath image type so it's possible to determine a sensible value of `darkBackground` or `lightBackground` in macros or scripts; * Better maintainability through the use of fxml and externalised strings; * Available by the 'ImageJ' toolbar button, not only the menus. This required a *lot* of changes, so there is a reasonable chance things have broken elsewhere... including with the regular script editor (which needed changed to make it possible to generate a script editor control elsewhere). But I think it remains functional... Some limitations:; * It's not possible to control via a script which objects or Rois are sent to ImageJ with an `OverlayOptions` object; * The previous macro runner didn't do this perfectly either - see https://github.com/qupath/qupath/issues/1522 ); * It's not currently possible to send back measurements with objects added to an overlay; * Only 'original' channels can be sent through the user interface, not color deconvolved channels (although scripting gives more options); * The scripting language can't be set explicitly; for Groovy, ensure that `IJ.getImage()` or `import [something]` is included",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1682
https://github.com/qupath/qupath/pull/1682:1344,Modifiability,maintainab,maintainability,1344,"x highlighting; * Autocomplete with built-in macro functions when pressing `Ctrl+space`; * Better control over which objects are sent for processing; * Better control over resolution, with 3 different methods to control the size of images sent to ImageJ (not just downsample); * Better control over parallelization; * Option to select channels to send; * Built-in examples of potentially-useful macros; * Support for `Roi` groups, which map to QuPath classifications; * Scriptability; macros can be stored in the command history and run later through Groovy scripts; * Ability to run Groovy scripts instead of macros; * These are different from Groovy scripts run through the script editor; they are specifically written to work on an `ImagePlus` obtained from ImageJ via a call to `IJ.getImage()`; * New `IJProcessing` and `IJFilters` classes make it easier to process images obtained this way; * Properties are set in the `ImagePlus` based on the QuPath image type so it's possible to determine a sensible value of `darkBackground` or `lightBackground` in macros or scripts; * Better maintainability through the use of fxml and externalised strings; * Available by the 'ImageJ' toolbar button, not only the menus. This required a *lot* of changes, so there is a reasonable chance things have broken elsewhere... including with the regular script editor (which needed changed to make it possible to generate a script editor control elsewhere). But I think it remains functional... Some limitations:; * It's not possible to control via a script which objects or Rois are sent to ImageJ with an `OverlayOptions` object; * The previous macro runner didn't do this perfectly either - see https://github.com/qupath/qupath/issues/1522 ); * It's not currently possible to send back measurements with objects added to an overlay; * Only 'original' channels can be sent through the user interface, not color deconvolved channels (although scripting gives more options); * The scripting language can't be set e",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1682
https://github.com/qupath/qupath/pull/1683:104,Deployability,release,release,104,It's a mystery what worked (if anything) but this tries to include the javadoc jars missing in the past release candidates.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1683
https://github.com/qupath/qupath/pull/1684:381,Deployability,update,updated,381,"Rename `ImagePlusProperties` to `IJProperties` and expand to store relevant object-related things within the properties of a `Roi`. Then use these when converting objects. This also changes the `ImageJScriptRunner` in a few signficant ways:; - it is much faster when run with lots of small objects; - if a Roi is sent to the macro and comes back again, the corresponding object is updated - not replaced. Also more examples added.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1684
https://github.com/qupath/qupath/pull/1687:2,Deployability,Update,Update,2,"- Update training extension (rename tour, remove from toolbar); - Ensure ImageJ sample macros appear before Groovy scripts; - Reduce max image size for ImageJ script runner; - Adjust default options in script runner; - Add a Groovy script example; - Link docs to the 'latest' (not v0.5)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1687
https://github.com/qupath/qupath/pull/1687:126,Energy Efficiency,Reduce,Reduce,126,"- Update training extension (rename tour, remove from toolbar); - Ensure ImageJ sample macros appear before Groovy scripts; - Reduce max image size for ImageJ script runner; - Adjust default options in script runner; - Add a Groovy script example; - Link docs to the 'latest' (not v0.5)",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1687
https://github.com/qupath/qupath/pull/1690:5,Deployability,update,update,5,Also update commonmark to 0.24.0,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1690
https://github.com/qupath/qupath/issues/1691:1031,Availability,down,down,1031,"## IMPORTANT!. This section is **only** for bug reports, which **must** follow the template below. Please post any other questions to the official QuPath forum at https://forum.image.sc/tags/qupath. If in doubt, use [image.sc](https://forum.image.sc/tags/qupath). This helps us keep things organized. ## Before we begin... Before submitting your bug report, please check the following:. * [ ] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [ ] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [ ] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [ ] I've checked for existing GitHub issues describing the same problem. ## Bug report. ### Describe the bug; A clear and concise description of what the bug is. ### To Reproduce; Steps to reproduce the behavior:; 1. Go to '...'; 2. Click on '....'; 3. Scroll down to '....'; 4. See error. ### Expected behavior; A clear and concise description of what you expected to happen. ### Screenshots; If applicable, add screenshots to help explain your problem. ### Desktop (please complete the following information):; - OS: [e.g. Windows, macOS, Ubuntu...]; - QuPath Version: [e.g. 0.2.2]. ### Additional context; Add any other context about the problem here.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1691
https://github.com/qupath/qupath/issues/1691:1054,Availability,error,error,1054,"## IMPORTANT!. This section is **only** for bug reports, which **must** follow the template below. Please post any other questions to the official QuPath forum at https://forum.image.sc/tags/qupath. If in doubt, use [image.sc](https://forum.image.sc/tags/qupath). This helps us keep things organized. ## Before we begin... Before submitting your bug report, please check the following:. * [ ] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [ ] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [ ] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [ ] I've checked for existing GitHub issues describing the same problem. ## Bug report. ### Describe the bug; A clear and concise description of what the bug is. ### To Reproduce; Steps to reproduce the behavior:; 1. Go to '...'; 2. Click on '....'; 3. Scroll down to '....'; 4. See error. ### Expected behavior; A clear and concise description of what you expected to happen. ### Screenshots; If applicable, add screenshots to help explain your problem. ### Desktop (please complete the following information):; - OS: [e.g. Windows, macOS, Ubuntu...]; - QuPath Version: [e.g. 0.2.2]. ### Additional context; Add any other context about the problem here.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1691
https://github.com/qupath/qupath/issues/1691:564,Deployability,release,release,564,"## IMPORTANT!. This section is **only** for bug reports, which **must** follow the template below. Please post any other questions to the official QuPath forum at https://forum.image.sc/tags/qupath. If in doubt, use [image.sc](https://forum.image.sc/tags/qupath). This helps us keep things organized. ## Before we begin... Before submitting your bug report, please check the following:. * [ ] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [ ] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [ ] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [ ] I've checked for existing GitHub issues describing the same problem. ## Bug report. ### Describe the bug; A clear and concise description of what the bug is. ### To Reproduce; Steps to reproduce the behavior:; 1. Go to '...'; 2. Click on '....'; 3. Scroll down to '....'; 4. See error. ### Expected behavior; A clear and concise description of what you expected to happen. ### Screenshots; If applicable, add screenshots to help explain your problem. ### Desktop (please complete the following information):; - OS: [e.g. Windows, macOS, Ubuntu...]; - QuPath Version: [e.g. 0.2.2]. ### Additional context; Add any other context about the problem here.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1691
https://github.com/qupath/qupath/issues/1691:760,Deployability,release,release,760,"## IMPORTANT!. This section is **only** for bug reports, which **must** follow the template below. Please post any other questions to the official QuPath forum at https://forum.image.sc/tags/qupath. If in doubt, use [image.sc](https://forum.image.sc/tags/qupath). This helps us keep things organized. ## Before we begin... Before submitting your bug report, please check the following:. * [ ] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [ ] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [ ] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [ ] I've checked for existing GitHub issues describing the same problem. ## Bug report. ### Describe the bug; A clear and concise description of what the bug is. ### To Reproduce; Steps to reproduce the behavior:; 1. Go to '...'; 2. Click on '....'; 3. Scroll down to '....'; 4. See error. ### Expected behavior; A clear and concise description of what you expected to happen. ### Screenshots; If applicable, add screenshots to help explain your problem. ### Desktop (please complete the following information):; - OS: [e.g. Windows, macOS, Ubuntu...]; - QuPath Version: [e.g. 0.2.2]. ### Additional context; Add any other context about the problem here.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1691
https://github.com/qupath/qupath/issues/1691:883,Usability,clear,clear,883,"## IMPORTANT!. This section is **only** for bug reports, which **must** follow the template below. Please post any other questions to the official QuPath forum at https://forum.image.sc/tags/qupath. If in doubt, use [image.sc](https://forum.image.sc/tags/qupath). This helps us keep things organized. ## Before we begin... Before submitting your bug report, please check the following:. * [ ] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [ ] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [ ] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [ ] I've checked for existing GitHub issues describing the same problem. ## Bug report. ### Describe the bug; A clear and concise description of what the bug is. ### To Reproduce; Steps to reproduce the behavior:; 1. Go to '...'; 2. Click on '....'; 3. Scroll down to '....'; 4. See error. ### Expected behavior; A clear and concise description of what you expected to happen. ### Screenshots; If applicable, add screenshots to help explain your problem. ### Desktop (please complete the following information):; - OS: [e.g. Windows, macOS, Ubuntu...]; - QuPath Version: [e.g. 0.2.2]. ### Additional context; Add any other context about the problem here.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1691
https://github.com/qupath/qupath/issues/1691:1086,Usability,clear,clear,1086,"## IMPORTANT!. This section is **only** for bug reports, which **must** follow the template below. Please post any other questions to the official QuPath forum at https://forum.image.sc/tags/qupath. If in doubt, use [image.sc](https://forum.image.sc/tags/qupath). This helps us keep things organized. ## Before we begin... Before submitting your bug report, please check the following:. * [ ] I've definitely found a bug (it you're not sure, please use [image.sc](https://forum.image.sc/tags/qupath) instead); * [ ] I've checked https://qupath.github.io for a new release that might already have fixed the issue; * [ ] I've checked the [Changelog](https://github.com/qupath/qupath/blob/master/CHANGELOG.md) to see if the bug has already been fixed in the next release; * [ ] I've checked for existing GitHub issues describing the same problem. ## Bug report. ### Describe the bug; A clear and concise description of what the bug is. ### To Reproduce; Steps to reproduce the behavior:; 1. Go to '...'; 2. Click on '....'; 3. Scroll down to '....'; 4. See error. ### Expected behavior; A clear and concise description of what you expected to happen. ### Screenshots; If applicable, add screenshots to help explain your problem. ### Desktop (please complete the following information):; - OS: [e.g. Windows, macOS, Ubuntu...]; - QuPath Version: [e.g. 0.2.2]. ### Additional context; Add any other context about the problem here.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1691
https://github.com/qupath/qupath/issues/1692:481,Availability,avail,available,481,"## Bug report. ### Describe the bug; The script editor in v0.6.0-rc3 has lost a nice feature of automatically indenting within code blocks and adding closing parentheses. ### Expected behavior; See https://forum.image.sc/t/feedback-on-qupath-v0-6-0-rc2/103187/30 for details. ### Desktop (please complete the following information):; - OS: All; - QuPath Version: v0.6.0-rc3. ### Additional context; I'm pretty sure I introduced this when refactoring to make a 'mini' script editor available to the ImageJ script runner, shortly before I2K.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1692
https://github.com/qupath/qupath/issues/1692:438,Modifiability,refactor,refactoring,438,"## Bug report. ### Describe the bug; The script editor in v0.6.0-rc3 has lost a nice feature of automatically indenting within code blocks and adding closing parentheses. ### Expected behavior; See https://forum.image.sc/t/feedback-on-qupath-v0-6-0-rc2/103187/30 for details. ### Desktop (please complete the following information):; - OS: All; - QuPath Version: v0.6.0-rc3. ### Additional context; I'm pretty sure I introduced this when refactoring to make a 'mini' script editor available to the ImageJ script runner, shortly before I2K.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1692
https://github.com/qupath/qupath/issues/1692:223,Usability,feedback,feedback-on-qupath-,223,"## Bug report. ### Describe the bug; The script editor in v0.6.0-rc3 has lost a nice feature of automatically indenting within code blocks and adding closing parentheses. ### Expected behavior; See https://forum.image.sc/t/feedback-on-qupath-v0-6-0-rc2/103187/30 for details. ### Desktop (please complete the following information):; - OS: All; - QuPath Version: v0.6.0-rc3. ### Additional context; I'm pretty sure I introduced this when refactoring to make a 'mini' script editor available to the ImageJ script runner, shortly before I2K.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1692
https://github.com/qupath/qupath/pull/1694:128,Deployability,install,installer,128,"For some reason, when running `gradlew jpackage` you get the full set of qupath javadocs, but with `gradlew jpackage -P package=installer`, you get just a small subset. However you can bodge around this by explicitly asking for all the javadocs as part of the same call; it'll still copy the directory. Temporarily address #1652; won't consider it closed until jpackage contains all javadoc jars by default.",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1694
https://github.com/qupath/qupath/pull/3:0,Deployability,Update,Updates,0,Updates to 0.0.2,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/3
https://github.com/qupath/qupath/pull/4:0,Deployability,Update,Update,0,Update to v0.0.3,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/4
https://github.com/qupath/qupath/issues/7:22,Performance,perform,performance,22,"Delaunay overlay poor performance, cannot be hidden",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/7
https://github.com/qupath/qupath/issues/12:77,Security,access,accessed,77,"Bio-Formats Extension (0.0.4) does not show up in Extensions menu, cannot be accessed",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/12
https://github.com/qupath/qupath/issues/14:5,Safety,detect,detection,5,Cell detection only partially supports fluorescence images,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/14
https://github.com/qupath/qupath/issues/16:36,Safety,detect,detections,36,Require ability to sub-classify any detections according to intensity,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/16
https://github.com/qupath/qupath/pull/21:0,Deployability,Update,Update,0,Update to v0.0.6,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/21
https://github.com/qupath/qupath/issues/22:0,Performance,Perform,Performance,0,Performance issues related to logging,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/22
https://github.com/qupath/qupath/issues/22:30,Testability,log,logging,30,Performance issues related to logging,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/22
https://github.com/qupath/qupath/issues/23:32,Deployability,update,updated,32,Image reading issues on macOS - updated OpenSlide binaries required,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/23
https://github.com/qupath/qupath/pull/30:15,Deployability,release,release,15,v0.1.0 - first release,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/30
https://github.com/qupath/qupath/pull/33:0,Deployability,Update,Updated,0,Updated OpenSlide for macOS,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/33
https://github.com/qupath/qupath/issues/35:7,Availability,error,error,7,Qupath error when changing view on a czi slide,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/35
https://github.com/qupath/qupath/issues/45:50,Availability,down,down,50,TMA in CZI format - with 120 scenes brings QuPath down to crash,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/45
https://github.com/qupath/qupath/issues/46:0,Performance,Optimiz,Optimiziation,0,"Optimiziation of Positive Cell detection - example Ki67, in H DAB",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/46
https://github.com/qupath/qupath/issues/46:31,Safety,detect,detection,31,"Optimiziation of Positive Cell detection - example Ki67, in H DAB",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/46
https://github.com/qupath/qupath/issues/48:4,Safety,detect,detection,4,TMA detection in CZI format fails also in WSI format with only 1 scene,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/48
https://github.com/qupath/qupath/issues/52:15,Safety,detect,detection,15,Different cell detection result categories.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/52
https://github.com/qupath/qupath/issues/53:14,Safety,detect,detection,14,Simple tissue detection for TMA does not work,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/53
https://github.com/qupath/qupath/issues/53:0,Usability,Simpl,Simple,0,Simple tissue detection for TMA does not work,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/53
https://github.com/qupath/qupath/issues/55:16,Availability,error,error,16,Java heap space error,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/55
https://github.com/qupath/qupath/issues/58:0,Performance,Load,Loading,0,Loading saved project/data,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/58
https://github.com/qupath/qupath/issues/60:5,Safety,detect,detection,5,Cell detection and tissue detection not compatible at same level of hierarchy,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/60
https://github.com/qupath/qupath/issues/60:26,Safety,detect,detection,26,Cell detection and tissue detection not compatible at same level of hierarchy,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/60
https://github.com/qupath/qupath/issues/63:50,Safety,detect,detection,50,"""No features selected!"" when attempting to create detection classifier",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/63
https://github.com/qupath/qupath/issues/64:14,Safety,detect,detection,14,Positive cell detection,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/64
https://github.com/qupath/qupath/issues/69:15,Availability,Error,Error,15,Cell Detection Error On Large TIF File,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/69
https://github.com/qupath/qupath/issues/69:5,Safety,Detect,Detection,5,Cell Detection Error On Large TIF File,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/69
https://github.com/qupath/qupath/issues/75:0,Usability,Undo,Undo,0,Undo function,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/75
https://github.com/qupath/qupath/issues/76:18,Integrability,Depend,Dependencies,18,3rd Party Library Dependencies in Scripts,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/76
https://github.com/qupath/qupath/issues/80:17,Modifiability,variab,variability,17,"""Cell detection"" variability between tiles",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/80
https://github.com/qupath/qupath/issues/80:6,Safety,detect,detection,6,"""Cell detection"" variability between tiles",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/80
https://github.com/qupath/qupath/issues/82:14,Safety,detect,detection,14,"simple tissue detection cannot be trimmed by ""Alt+Brush"" - bug",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/82
https://github.com/qupath/qupath/issues/82:0,Usability,simpl,simple,0,"simple tissue detection cannot be trimmed by ""Alt+Brush"" - bug",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/82
https://github.com/qupath/qupath/issues/83:7,Safety,detect,detect,7,How to detect nuclei with different staining,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/83
https://github.com/qupath/qupath/issues/87:12,Availability,error,error,12,Compilation error on Eclipse,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/87
https://github.com/qupath/qupath/issues/90:62,Safety,detect,detection,62,Enter coordinates for ROI rectangle and file name to run cell detection from command line,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/90
https://github.com/qupath/qupath/issues/91:11,Modifiability,plugin,plugins,11,Set ImageJ plugins directory - failing,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/91
https://github.com/qupath/qupath/issues/110:15,Safety,detect,detection,15,Multi ROI cell detection fails randomly,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/110
https://github.com/qupath/qupath/issues/111:55,Safety,detect,detection,55,"Positive Pixel count does not work after simple tissue detection if checkbox ""single annotation"" is deactivated",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/111
https://github.com/qupath/qupath/issues/111:41,Usability,simpl,simple,41,"Positive Pixel count does not work after simple tissue detection if checkbox ""single annotation"" is deactivated",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/111
https://github.com/qupath/qupath/issues/112:20,Safety,detect,detections,20,Multi positive cell detections fails + Quapath data file doesn't open + does not save cell counting,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/112
https://github.com/qupath/qupath/issues/119:25,Safety,detect,detection,25,Fast-red subcellular ISH detection,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/119
https://github.com/qupath/qupath/issues/123:0,Deployability,Integrat,Integrating,0,Integrating QuPath & CellProfiler,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/123
https://github.com/qupath/qupath/issues/123:0,Integrability,Integrat,Integrating,0,Integrating QuPath & CellProfiler,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/123
https://github.com/qupath/qupath/issues/124:14,Safety,detect,detection,14,simple tissue detection on ndpi and tiffs generates artefacts in image corners,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/124
https://github.com/qupath/qupath/issues/124:0,Usability,simpl,simple,0,simple tissue detection on ndpi and tiffs generates artefacts in image corners,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/124
https://github.com/qupath/qupath/issues/139:0,Availability,Error,Error,0,Error when clicking automate in menu bar,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/139
https://github.com/qupath/qupath/issues/142:41,Availability,error,error,41,Issue can be deleted - it was a handling error,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/142
https://github.com/qupath/qupath/issues/146:12,Safety,detect,detection,12,Subcellular detection - expand to 4 categories?,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/146
https://github.com/qupath/qupath/issues/147:58,Safety,detect,detections,58,Merge annotations - afterwards QuPath does not count Cell detections anymore,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/147
https://github.com/qupath/qupath/issues/148:14,Safety,detect,detection,14,Positive cell detection on multiple annotations,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/148
https://github.com/qupath/qupath/issues/153:22,Availability,error,error,22,severe cell detection error - hard to reproduce,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/153
https://github.com/qupath/qupath/issues/153:12,Safety,detect,detection,12,severe cell detection error - hard to reproduce,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/153
https://github.com/qupath/qupath/issues/159:20,Safety,detect,detection,20,Getting area out of detection objects,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/159
https://github.com/qupath/qupath/issues/160:19,Availability,error,error,19,loading classifier error,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/160
https://github.com/qupath/qupath/issues/160:0,Performance,load,loading,0,loading classifier error,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/160
https://github.com/qupath/qupath/issues/164:19,Performance,perform,performed,19,Measurement is not performed over 3 channels,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/164
https://github.com/qupath/qupath/issues/166:35,Availability,mask,masks,35,Export annotations as segmentation masks,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/166
https://github.com/qupath/qupath/issues/168:0,Availability,Error,Error,0,Error opening Vektra QPTIFF file,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/168
https://github.com/qupath/qupath/issues/174:5,Safety,Detect,Detection,5,Cell Detection Failing and Corrupting Data Files,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/174
https://github.com/qupath/qupath/issues/175:47,Energy Efficiency,adapt,adapted,47,Maximum Memory (GB) in QuPath Setup can not be adapted,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/175
https://github.com/qupath/qupath/issues/175:47,Modifiability,adapt,adapted,47,Maximum Memory (GB) in QuPath Setup can not be adapted,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/175
https://github.com/qupath/qupath/issues/184:11,Availability,error,error,11,.scn files error,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/184
https://github.com/qupath/qupath/issues/188:37,Availability,down,down,37,touch gestures: zooms when moving up/down,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/188
https://github.com/qupath/qupath/issues/205:8,Safety,Detect,Detection,8,Mitosis Detection/Counting,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/205
https://github.com/qupath/qupath/issues/214:10,Safety,Detect,Detection,10,Exporting Detection Centroids,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/214
https://github.com/qupath/qupath/issues/222:26,Safety,detect,detections,26,Superpixel annoations and detections,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/222
https://github.com/qupath/qupath/issues/225:4,Safety,detect,detection,4,Get detection measurements per annotation,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/225
https://github.com/qupath/qupath/issues/226:14,Safety,detect,detection,14,Positive cell detection setup parameters,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/226
https://github.com/qupath/qupath/issues/231:31,Safety,detect,detected,31,Elongated nuclei not correctly detected,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/231
https://github.com/qupath/qupath/issues/234:7,Safety,Detect,Detection,7,Export Detection Measurements per Annotation,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/234
https://github.com/qupath/qupath/issues/236:8,Safety,detect,detection,8,IQR for detection measurements?,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/236
https://github.com/qupath/qupath/issues/238:31,Availability,error,error,31,Cannot import class XmlSlurper error at Windows,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/238
https://github.com/qupath/qupath/issues/248:14,Safety,Detect,Detection,14,Simple Tissue Detection within an annotation,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/248
https://github.com/qupath/qupath/issues/248:0,Usability,Simpl,Simple,0,Simple Tissue Detection within an annotation,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/248
https://github.com/qupath/qupath/issues/251:10,Safety,Detect,Detection,10,Exporting Detection as a labeled image,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/251
https://github.com/qupath/qupath/issues/253:18,Performance,load,load,18,Is it possible to load a custom external jar or .class binary?,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/253
https://github.com/qupath/qupath/issues/259:25,Safety,detect,detections,25,convert annotations into detections. Counting in the annotations TAB is wrong,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/259
https://github.com/qupath/qupath/issues/260:60,Usability,usab,usable,60,"If system command call QuPath, Bioformats Extension was not usable",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/260
https://github.com/qupath/qupath/issues/270:8,Deployability,install,installing,8,Problem installing qupath v0.1.3,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/270
https://github.com/qupath/qupath/issues/274:0,Energy Efficiency,Reduce,Reduce,0,Reduce annotations,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/274
https://github.com/qupath/qupath/issues/286:15,Availability,error,error,15,"script compile error: runs via GUI OK, but failed via command line",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/286
https://github.com/qupath/qupath/issues/290:17,Performance,load,load,17,QuPath 0.2 Can't load saved classifiers,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/290
https://github.com/qupath/qupath/issues/294:16,Safety,detect,detect,16,qupath fails to detect cells across entire TMA,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/294
https://github.com/qupath/qupath/issues/299:23,Safety,detect,detection,23,"export mean values of ""detection measurement"" results by class",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/299
https://github.com/qupath/qupath/issues/303:14,Deployability,install,installation,14,Newbie asking installation of Qupath packages,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/303
https://github.com/qupath/qupath/issues/304:12,Safety,detect,detection,12,Subcellular detection for all 3 BF channels,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/304
https://github.com/qupath/qupath/issues/305:5,Safety,detect,detection,5,Cell detection does not work probably because of high DAB background. Help me please?,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/305
https://github.com/qupath/qupath/issues/310:26,Integrability,depend,depends,26,Deletion of child objects depends on order of selection,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/310
https://github.com/qupath/qupath/pull/324:12,Modifiability,plugin,plugin,12,Added maven plugin,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/324
https://github.com/qupath/qupath/issues/327:22,Safety,Detect,Detection,22,Feature request: Cell Detection nuclear channel mini-viewer,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/327
https://github.com/qupath/qupath/issues/328:17,Safety,detect,detection,17,Subcellular spot detection not working in ubuntu ?,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/328
https://github.com/qupath/qupath/issues/330:0,Availability,Error,Error,0,Error with opening image,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/330
https://github.com/qupath/qupath/issues/336:37,Integrability,depend,depend,37,Can't close windows (QuPath seems to depend on window manager),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/336
https://github.com/qupath/qupath/issues/343:88,Performance,load,loading,88,"When running in script mode, runClassifier appears to retrain the classifier instead of loading",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/343
https://github.com/qupath/qupath/issues/349:0,Availability,Error,Error,0,Error when opening script editor,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/349
https://github.com/qupath/qupath/issues/360:0,Availability,Error,Error,0,Error loading training objects,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/360
https://github.com/qupath/qupath/issues/360:6,Performance,load,loading,6,Error loading training objects,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/360
https://github.com/qupath/qupath/issues/363:12,Availability,error,error,12,Compilation error,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/363
https://github.com/qupath/qupath/issues/364:0,Safety,Predict,Predict,0,Predict tumor percentage,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/364
https://github.com/qupath/qupath/issues/372:0,Availability,Error,Error,0,Error when labelling with pen,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/372
https://github.com/qupath/qupath/issues/387:0,Availability,Error,Error,0,Error with opening VSI files,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/387
https://github.com/qupath/qupath/issues/391:11,Modifiability,Portab,Portable,11,[wishlist] Portable version,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/391
https://github.com/qupath/qupath/issues/393:45,Availability,error,error,45,RAM not cleared before opening next file --> error after opening a few files,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/393
https://github.com/qupath/qupath/issues/393:8,Usability,clear,cleared,8,RAM not cleared before opening next file --> error after opening a few files,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/393
https://github.com/qupath/qupath/issues/399:6,Performance,load,load,6,Can't load qdata,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/399
https://github.com/qupath/qupath/issues/402:6,Performance,load,load,6,Can't load a detection classifier,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/402
https://github.com/qupath/qupath/issues/402:13,Safety,detect,detection,13,Can't load a detection classifier,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/402
https://github.com/qupath/qupath/issues/403:31,Performance,load,loading,31,Unable to create objects after loading Simple thresholder.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/403
https://github.com/qupath/qupath/issues/403:39,Usability,Simpl,Simple,39,Unable to create objects after loading Simple thresholder.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/403
https://github.com/qupath/qupath/issues/405:0,Safety,Detect,Detection,0,Detection Centroid Distance interacts awkwardly with multiplexing,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/405
https://github.com/qupath/qupath/issues/406:10,Performance,load,load,10,Unable to load object classifier,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/406
https://github.com/qupath/qupath/issues/407:61,Deployability,release,releases,61,Incorrect changelog link on https://github.com/qupath/qupath/releases/tag/v0.2.0-m9,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/407
https://github.com/qupath/qupath/issues/410:0,Performance,Load,Loaded,0,Loaded Points objects are unclassified,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/410
https://github.com/qupath/qupath/issues/411:10,Performance,load,loading,10,Warn when loading a classifier if features are missing,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/411
https://github.com/qupath/qupath/issues/412:17,Performance,perform,performance,17,Point annotation performance,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/412
https://github.com/qupath/qupath/pull/414:0,Deployability,Update,Update,0,"Update Bio-Formats, script editor",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/414
https://github.com/qupath/qupath/pull/415:0,Deployability,Update,Updated,0,"Updated dependencies, PointIO",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/415
https://github.com/qupath/qupath/pull/415:8,Integrability,depend,dependencies,8,"Updated dependencies, PointIO",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/415
https://github.com/qupath/qupath/pull/418:0,Deployability,Update,Update,0,"Update to JDK 14, performance fixes",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/418
https://github.com/qupath/qupath/pull/418:18,Performance,perform,performance,18,"Update to JDK 14, performance fixes",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/418
https://github.com/qupath/qupath/pull/419:37,Deployability,update,updated,37,"Bug fixed, performance improvements, updated javadocs",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/419
https://github.com/qupath/qupath/pull/419:11,Performance,perform,performance,11,"Bug fixed, performance improvements, updated javadocs",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/419
https://github.com/qupath/qupath/issues/422:78,Deployability,install,installation,78,"Click on ""Automate"" Button gives ""QuPath exception"" every time even after new installation",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/422
https://github.com/qupath/qupath/pull/423:23,Integrability,message,message,23,Fixed duplicate logger message,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/423
https://github.com/qupath/qupath/pull/423:16,Testability,log,logger,16,Fixed duplicate logger message,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/423
https://github.com/qupath/qupath/pull/424:23,Modifiability,refactor,refactoring,23,"Show annotation names, refactoring and DelaunayTools",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/424
https://github.com/qupath/qupath/issues/426:18,Deployability,install,installing,18,having problem in installing qupath in my mac,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/426
https://github.com/qupath/qupath/pull/428:6,Modifiability,refactor,refactoring,6,"Minor refactoring, improved dialogs and javadocs",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/428
https://github.com/qupath/qupath/issues/429:0,Availability,Error,Error,0,Error converting AreaROI to Geometry: Invalid number of points in LinearRing (found 3 - must be 0 or >= 4),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/429
https://github.com/qupath/qupath/pull/439:25,Integrability,interface,interface,25,Implemented command line interface (picocli),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/439
https://github.com/qupath/qupath/issues/440:13,Performance,latency,latency,13,High initial latency before image starts moving using the pan tool,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/440
https://github.com/qupath/qupath/pull/441:6,Modifiability,refactor,refactoring,6,Major refactoring for v0.2.0,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/441
https://github.com/qupath/qupath/pull/443:31,Deployability,update,update,31,"More refactoring, javadocs and update to JUnit 5",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/443
https://github.com/qupath/qupath/pull/443:5,Modifiability,refactor,refactoring,5,"More refactoring, javadocs and update to JUnit 5",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/443
https://github.com/qupath/qupath/pull/446:26,Testability,log,logging,26,"Implemented CLI, improved logging support",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/446
https://github.com/qupath/qupath/issues/454:29,Performance,load,loading,29,Silent crash upon start when loading a broken extension,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/454
https://github.com/qupath/qupath/issues/459:5,Safety,detect,detection,5,Cell detection over tiled regions fails on some images,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/459
https://github.com/qupath/qupath/pull/473:0,Availability,Recover,Recover,0,Recover from NPE if colormap requested with a color missing,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/473
https://github.com/qupath/qupath/pull/473:0,Safety,Recover,Recover,0,Recover from NPE if colormap requested with a color missing,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/473
https://github.com/qupath/qupath/pull/480:11,Deployability,update,updates,11,Classifier updates,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/480
https://github.com/qupath/qupath/pull/485:0,Availability,Error,Error,0,Error handling & keep connection alive,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/485
https://github.com/qupath/qupath/pull/485:33,Availability,alive,alive,33,Error handling & keep connection alive,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/485
https://github.com/qupath/qupath/pull/487:16,Integrability,message,message,16,Fixed empty log message,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/487
https://github.com/qupath/qupath/pull/487:12,Testability,log,log,12,Fixed empty log message,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/487
https://github.com/qupath/qupath/pull/488:45,Deployability,update,update,45,Reclaim memory more quickly with TensorFlow; update changelog,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/488
https://github.com/qupath/qupath/issues/493:0,Performance,Load,Load,0,Load training in object classifier -> QuPath crashes,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/493
https://github.com/qupath/qupath/issues/495:48,Availability,down,down,48,Feature request: Make number entry fields w. up-down arrows react to mouse wheel events,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/495
https://github.com/qupath/qupath/issues/502:24,Deployability,update,updated,24,m12 - Field of view now updated when selecting annotations,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/502
https://github.com/qupath/qupath/issues/503:6,Availability,Error,Error,6,m12 - Error dialog(s) appear when closing QuPath after work with pixel classifiers,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/503
https://github.com/qupath/qupath/issues/510:7,Performance,load,load,7,Cannot load project if classes.json is missing,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/510
https://github.com/qupath/qupath/issues/512:25,Security,access,accessible,25,Files in project are not accessible anymore after software has an abnormal shutdown,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/512
https://github.com/qupath/qupath/issues/513:13,Performance,load,load,13,CLI does not load image,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/513
https://github.com/qupath/qupath/issues/514:35,Availability,error,errors,35,'Interface can't be instantiated!' errors when running from the command line,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/514
https://github.com/qupath/qupath/issues/514:1,Integrability,Interface,Interface,1,'Interface can't be instantiated!' errors when running from the command line,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/514
https://github.com/qupath/qupath/pull/520:29,Energy Efficiency,adapt,adapters,29,Improve registration of type adapters,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/520
https://github.com/qupath/qupath/pull/520:29,Integrability,adapter,adapters,29,Improve registration of type adapters,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/520
https://github.com/qupath/qupath/pull/520:29,Modifiability,adapt,adapters,29,Improve registration of type adapters,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/520
https://github.com/qupath/qupath/issues/528:45,Deployability,update,update,45,Image server using affine Transform does not update pixel size,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/528
https://github.com/qupath/qupath/pull/535:24,Deployability,update,update,24,"Resolve TMA grid limit, update changelog",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/535
https://github.com/qupath/qupath/pull/537:31,Integrability,message,message,31,Avoid UnsafeReflectionAccessor message,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/537
https://github.com/qupath/qupath/pull/537:0,Safety,Avoid,Avoid,0,Avoid UnsafeReflectionAccessor message,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/537
https://github.com/qupath/qupath/pull/537:6,Safety,Unsafe,UnsafeReflectionAccessor,6,Avoid UnsafeReflectionAccessor message,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/537
https://github.com/qupath/qupath/issues/538:28,Availability,Mask,Mask,28,Problem in Exporting Binary Mask,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/538
https://github.com/qupath/qupath/pull/539:0,Deployability,Update,Update,0,Update StarDist constrain options,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/539
https://github.com/qupath/qupath/issues/540:64,Safety,detect,detections,64,'Resolve hierarchy' does not work correctly for TMA images with detections,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/540
https://github.com/qupath/qupath/pull/541:54,Safety,detect,detections,54,Fix 'Resolve hierarchy' for images with TMA cores and detections,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/541
https://github.com/qupath/qupath/issues/546:0,Deployability,install,install,0,install qupath 0.2.1 on ubuntu 20.04,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/546
https://github.com/qupath/qupath/pull/555:0,Deployability,Update,Update,0,Update to Bio-Formats 6.5.1,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/555
https://github.com/qupath/qupath/pull/556:4,Availability,error,errors,4,Fix errors in Delaunay triangulation cluster features,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/556
https://github.com/qupath/qupath/pull/562:36,Testability,log,logging,36,Minor fixes for GeoJSON support and logging,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/562
https://github.com/qupath/qupath/issues/564:61,Safety,detect,detections,61,Resolve hierarchy is very slow for some TMA images with many detections,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/564
https://github.com/qupath/qupath/pull/565:16,Performance,cache,cache,16,Avoid resetting cache too often when inserting detections,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/565
https://github.com/qupath/qupath/pull/565:0,Safety,Avoid,Avoid,0,Avoid resetting cache too often when inserting detections,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/565
https://github.com/qupath/qupath/pull/565:47,Safety,detect,detections,47,Avoid resetting cache too often when inserting detections,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/565
https://github.com/qupath/qupath/pull/569:40,Performance,load,loaded,40,Enable projects without past URIs to be loaded,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/569
https://github.com/qupath/qupath/pull/575:0,Deployability,Update,Update,0,Update issue templates,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/575
https://github.com/qupath/qupath/issues/576:7,Deployability,deploy,deploy,7,Can we deploy qupath instance on cloud and access it from web url?,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/576
https://github.com/qupath/qupath/issues/576:43,Security,access,access,43,Can we deploy qupath instance on cloud and access it from web url?,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/576
https://github.com/qupath/qupath/pull/577:0,Deployability,Update,Update,0,Update version number for v0.2.2,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/577
https://github.com/qupath/qupath/pull/580:0,Deployability,Update,Update,0,Update TensorFlow dependency,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/580
https://github.com/qupath/qupath/pull/580:18,Integrability,depend,dependency,18,Update TensorFlow dependency,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/580
https://github.com/qupath/qupath/pull/581:0,Deployability,Update,Update,0,Update TensorFlow dependency,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/581
https://github.com/qupath/qupath/pull/581:18,Integrability,depend,dependency,18,Update TensorFlow dependency,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/581
https://github.com/qupath/qupath/pull/588:8,Availability,reliab,reliability,8,Improve reliability of cell expansion code,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/588
https://github.com/qupath/qupath/pull/600:6,Performance,load,loading,6,Fixed loading OMERO image data bug (#598),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/600
https://github.com/qupath/qupath/issues/607:0,Availability,Error,Error,0,Error Opening Image,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/607
https://github.com/qupath/qupath/issues/609:11,Integrability,message,message,11,CLI's help message does not match ScriptCommand behaviour,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/609
https://github.com/qupath/qupath/issues/611:15,Safety,Detect,Detection,15,Positive Pixel Detection,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/611
https://github.com/qupath/qupath/issues/614:7,Deployability,release,release,7,stable release 0.2.3 linux installation path,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/614
https://github.com/qupath/qupath/issues/614:27,Deployability,install,installation,27,stable release 0.2.3 linux installation path,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/614
https://github.com/qupath/qupath/issues/627:31,Performance,load,load,31,"compressed, tiled TIFFs do not load on macOS Catalina",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/627
https://github.com/qupath/qupath/issues/628:0,Deployability,Install,Install,0,"Install on Ubuntu 20.04, image artifacts in slide pane",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/628
https://github.com/qupath/qupath/pull/636:14,Availability,error,error,14,Added info to error message for left quotes,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/636
https://github.com/qupath/qupath/pull/636:20,Integrability,message,message,20,Added info to error message for left quotes,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/636
https://github.com/qupath/qupath/issues/638:41,Integrability,Synchroniz,Synchronize,41,Duplicate shortcut for 'Selection mode'/'Synchronize viewers',MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/638
https://github.com/qupath/qupath/issues/657:7,Safety,detect,detection,7,Tissue detection using structure information,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/657
https://github.com/qupath/qupath/issues/664:0,Availability,Error,Error,0,Error displayed when manifest can't be found in ShowInstalledExtensionsCommand,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/664
https://github.com/qupath/qupath/pull/665:15,Deployability,integrat,integration,15,Intel OpenVINO integration,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/665
https://github.com/qupath/qupath/pull/665:15,Integrability,integrat,integration,15,Intel OpenVINO integration,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/665
https://github.com/qupath/qupath/pull/668:27,Availability,down,downsample,27,Set focus on magnification/downsample textfield,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/668
https://github.com/qupath/qupath/pull/672:0,Deployability,Update,Update,0,Update README.md,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/672
https://github.com/qupath/qupath/pull/673:0,Deployability,Update,Update,0,Update dependencies and changelog,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/673
https://github.com/qupath/qupath/pull/673:7,Integrability,depend,dependencies,7,Update dependencies and changelog,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/673
https://github.com/qupath/qupath/pull/675:0,Deployability,Update,Update,0,Update JavaCPP and OpenCV,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/675
https://github.com/qupath/qupath/pull/681:14,Deployability,update,updates,14,Minor fixes & updates,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/681
https://github.com/qupath/qupath/pull/685:0,Deployability,Update,Update,0,Update build.gradle for Java 16,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/685
https://github.com/qupath/qupath/issues/686:0,Availability,Error,Error,0,Error in Measurement with StarDist script with RGB fluorescence images,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/686
https://github.com/qupath/qupath/pull/687:6,Testability,test,tests,6,Added tests in core,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/687
https://github.com/qupath/qupath/pull/694:4,Testability,test,test,4,Fix test for GeneralTools.toPath,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/694
https://github.com/qupath/qupath/issues/696:0,Safety,Detect,Detect,0,Detect centroid distances 2D doesn't work on different planes of a z-stack,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/696
https://github.com/qupath/qupath/issues/701:12,Safety,detect,detections,12,Subcellular detections don't work for z-stacks or with missing pixel sizes,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/701
https://github.com/qupath/qupath/issues/702:14,Performance,load,load,14,QuPath cannot load large pyramid TIFFs,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/702
https://github.com/qupath/qupath/pull/703:0,Deployability,Update,Update,0,"Update changelog, minor OMERO-related fixes",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/703
https://github.com/qupath/qupath/pull/706:0,Deployability,Update,Updates,0,Updates towards v0.3,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/706
https://github.com/qupath/qupath/pull/707:6,Testability,test,tests,6,Added tests,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/707
https://github.com/qupath/qupath/pull/709:12,Deployability,update,updates,12,Minor OMERO updates,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/709
https://github.com/qupath/qupath/pull/710:0,Deployability,Update,Update,0,"Update to Gradle 7, fix pixel classifier colormaps being locked",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/710
https://github.com/qupath/qupath/pull/711:6,Testability,test,tests,6,Added tests,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/711
https://github.com/qupath/qupath/pull/724:5,Integrability,depend,dependencies,5,"Bump dependencies, fix AbstractImageRegionStore",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/724
https://github.com/qupath/qupath/pull/730:8,Availability,error,errors,8,Log any errors occurring in a script,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/730
https://github.com/qupath/qupath/pull/730:0,Testability,Log,Log,0,Log any errors occurring in a script,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/730
https://github.com/qupath/qupath/pull/731:18,Availability,robust,robustness,18,Improve PathClass robustness,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/731
https://github.com/qupath/qupath/pull/732:8,Availability,error,errors,8,Log any errors occurring in a script,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/732
https://github.com/qupath/qupath/pull/732:0,Testability,Log,Log,0,Log any errors occurring in a script,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/732
https://github.com/qupath/qupath/pull/735:16,Usability,UX,UX,16,Minor fixes and UX improvements,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/735
https://github.com/qupath/qupath/pull/743:0,Deployability,Update,Updated,0,Updated changelog,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/743
https://github.com/qupath/qupath/pull/750:9,Integrability,synchroniz,synchronization,9,Improved synchronization on PathObject,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/750
https://github.com/qupath/qupath/pull/755:21,Availability,error,error,21,Fixed boundary check error,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/755
https://github.com/qupath/qupath/pull/756:19,Performance,cache,cached,19,Handle cases where cached Mat may be null,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/756
https://github.com/qupath/qupath/pull/760:0,Deployability,Update,Update,0,Update OpenCV classifiers to use default name,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/760
https://github.com/qupath/qupath/pull/761:0,Deployability,Update,Update,0,Update image names in both project & server metadata,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/761
https://github.com/qupath/qupath/pull/764:0,Deployability,Update,Update,0,Update dependencies,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/764
https://github.com/qupath/qupath/pull/764:7,Integrability,depend,dependencies,7,Update dependencies,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/764
https://github.com/qupath/qupath/pull/767:24,Availability,error,errors,24,Reduce impact of tiling errors when processing large regions,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/767
https://github.com/qupath/qupath/pull/767:0,Energy Efficiency,Reduce,Reduce,0,Reduce impact of tiling errors when processing large regions,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/767
https://github.com/qupath/qupath/pull/768:6,Testability,log,logging,6,Allow logging level to be specified through preferences,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/768
https://github.com/qupath/qupath/pull/771:30,Availability,error,errors,30,Fix 'Create objects' rounding errors,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/771
https://github.com/qupath/qupath/pull/773:0,Deployability,Update,Update,0,Update for v0.3.0-rc1,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/773
https://github.com/qupath/qupath/pull/781:14,Performance,concurren,concurrency,14,Much improved concurrency & memory use,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/781
https://github.com/qupath/qupath/pull/782:40,Modifiability,plugin,plugins,40,Improve tiling performance when running plugins,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/782
https://github.com/qupath/qupath/pull/782:15,Performance,perform,performance,15,Improve tiling performance when running plugins,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/782
https://github.com/qupath/qupath/pull/787:19,Deployability,update,updates,19,LabeledImageServer updates,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/787
https://github.com/qupath/qupath/issues/788:42,Safety,detect,detection,42,Num clusters is always 0 with subcellular detection,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/788
https://github.com/qupath/qupath/pull/792:43,Safety,detect,detection,43,Fix bug in cluster counts with subcellular detection,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/792
https://github.com/qupath/qupath/pull/793:13,Deployability,update,updates,13,Stain vector updates,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/793
https://github.com/qupath/qupath/pull/798:0,Deployability,Update,Update,0,Update JavaCPP dependencies (and more),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/798
https://github.com/qupath/qupath/pull/798:15,Integrability,depend,dependencies,15,Update JavaCPP dependencies (and more),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/798
https://github.com/qupath/qupath/pull/802:23,Availability,avail,available,23,Use cuda by default if available,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/802
https://github.com/qupath/qupath/pull/803:35,Deployability,update,updates,35,Improve logging while checking for updates,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/803
https://github.com/qupath/qupath/pull/803:8,Testability,log,logging,8,Improve logging while checking for updates,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/803
https://github.com/qupath/qupath/pull/807:0,Deployability,Update,Update,0,Update Gson and Bio-Formats,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/807
https://github.com/qupath/qupath/pull/808:34,Deployability,update,updates,34,ImageOps and pixel classification updates,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/808
https://github.com/qupath/qupath/pull/809:0,Usability,Simpl,Simplify,0,Simplify DnnModel use with ImageOps,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/809
https://github.com/qupath/qupath/pull/810:33,Availability,error,error,33,"Bump JTS to v1.18.2, fix javadoc error",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/810
https://github.com/qupath/qupath/pull/813:0,Deployability,Update,Update,0,"Update javadoc links, including in jpackage build",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/813
https://github.com/qupath/qupath/pull/814:18,Deployability,patch,patch,18,Enable fixed-size patch export with `TileExporter`,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/814
https://github.com/qupath/qupath/pull/815:0,Deployability,Update,Update,0,Update version to v0.3.0,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/815
https://github.com/qupath/qupath/issues/816:0,Safety,Redund,Redundancy,0,Redundancy in if-else condition of ImageWriteTools.java,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/816
https://github.com/qupath/qupath/pull/817:0,Deployability,Update,Update,0,Update version to v0.3.1-SNAPSHOT,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/817
https://github.com/qupath/qupath/issues/819:23,Deployability,update,update,23,Location text does not update when navigating with keyboard,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/819
https://github.com/qupath/qupath/pull/823:0,Deployability,Update,Update,0,Update location text when navigating with keyboard,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/823
https://github.com/qupath/qupath/pull/827:0,Performance,Optimiz,Optimize,0,Optimize NormalizePercentileOp by histogram calculation,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/827
https://github.com/qupath/qupath/issues/828:14,Safety,Detect,Detection,14,Positive Cell Detection misses sections,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/828
https://github.com/qupath/qupath/pull/830:6,Modifiability,enhance,enhancement,6,Small enhancement that enables Delete or backspace key in the AnnotationPane,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/830
https://github.com/qupath/qupath/issues/831:51,Performance,load,load,51,Qpath 0.3.0 freeze when using object classifier or load 1.5G model of old classifier,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/831
https://github.com/qupath/qupath/issues/832:7,Deployability,install,installation,7,QuPath installation fails on Mac OS X,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/832
https://github.com/qupath/qupath/issues/834:6,Availability,error,error,6,Qpath error in opening JPEG file,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/834
https://github.com/qupath/qupath/pull/837:44,Modifiability,plugin,plugin,44,Revert to creating new PathPlugin each time plugin is launched,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/837
https://github.com/qupath/qupath/pull/842:0,Modifiability,Refactor,Refactored,0,Refactored ProjectBrowser,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/842
https://github.com/qupath/qupath/pull/844:0,Integrability,Synchroniz,Synchronize,0,Synchronize channel colors to ImageDisplay when opening,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/844
https://github.com/qupath/qupath/pull/849:0,Deployability,Update,Update,0,"Update gradle wrapper, JavaFX, build scripts",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/849
https://github.com/qupath/qupath/pull/849:14,Integrability,wrap,wrapper,14,"Update gradle wrapper, JavaFX, build scripts",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/849
https://github.com/qupath/qupath/issues/852:15,Performance,load,loaded,15,Extensions are loaded after reading image data in CLI,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/852
https://github.com/qupath/qupath/pull/853:0,Performance,Load,Load,0,Load extensions before reading image data in CLI,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/853
https://github.com/qupath/qupath/pull/854:0,Safety,Avoid,Avoid,0,Avoid exceptions when calling simple Dialogs without UI,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/854
https://github.com/qupath/qupath/pull/854:30,Usability,simpl,simple,30,Avoid exceptions when calling simple Dialogs without UI,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/854
https://github.com/qupath/qupath/pull/855:0,Deployability,Update,Update,0,Update changelog,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/855
https://github.com/qupath/qupath/issues/856:45,Availability,error,errors,45,Spurious 'Physical memory usage is too high' errors when training a pixel classifier,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/856
https://github.com/qupath/qupath/issues/858:17,Testability,log,logic,17,OMEPyramidWriter logic for bigtiff can fail for image pyramids,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/858
https://github.com/qupath/qupath/pull/862:0,Energy Efficiency,Reduce,Reduce,0,Reduce unnecessary tile reads in AbstractImageServer,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/862
https://github.com/qupath/qupath/issues/866:35,Deployability,install,installation,35,QuPath 0.3.0 unreadable text after installation,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/866
https://github.com/qupath/qupath/pull/867:0,Deployability,Update,Update,0,Update multithreading support in BioFormatsImageServer,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/867
https://github.com/qupath/qupath/pull/868:0,Deployability,Update,Update,0,Update logback and gradle wrapper,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/868
https://github.com/qupath/qupath/pull/868:26,Integrability,wrap,wrapper,26,Update logback and gradle wrapper,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/868
https://github.com/qupath/qupath/pull/868:7,Testability,log,logback,7,Update logback and gradle wrapper,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/868
https://github.com/qupath/qupath/issues/872:0,Availability,Error,Error,0,Error exists when open a tiff file,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/872
https://github.com/qupath/qupath/pull/873:11,Deployability,update,updates,11,Dependency updates,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/873
https://github.com/qupath/qupath/pull/873:0,Integrability,Depend,Dependency,0,Dependency updates,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/873
https://github.com/qupath/qupath/pull/877:0,Deployability,Update,Update,0,Update version number for v0.3.1 release,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/877
https://github.com/qupath/qupath/pull/877:33,Deployability,release,release,33,Update version number for v0.3.1 release,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/877
https://github.com/qupath/qupath/issues/878:5,Safety,detect,detection,5,Cell detection using 'Hematoxylin' always assumes it is the first stain,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/878
https://github.com/qupath/qupath/issues/880:24,Availability,error,error,24,Uninformative / by zero error when setting stain vectors on empty images,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/880
https://github.com/qupath/qupath/pull/882:0,Availability,Down,Downgrade,0,Downgrade to use Bio-Formats 6.7.0,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/882
https://github.com/qupath/qupath/pull/883:59,Availability,avail,available,59,Sync 'Create single measurement classifier' combo boxes to available classes,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/883
https://github.com/qupath/qupath/pull/884:25,Safety,detect,detection,25,Support hematoxylin cell detection where it is not the first stain,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/884
https://github.com/qupath/qupath/pull/885:26,Availability,error,error,26,Avoid confusing / by zero error when auto-setting image type fails,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/885
https://github.com/qupath/qupath/pull/885:0,Safety,Avoid,Avoid,0,Avoid confusing / by zero error when auto-setting image type fails,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/885
https://github.com/qupath/qupath/pull/888:0,Deployability,Update,Update,0,Update version number for v0.3.2 release,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/888
https://github.com/qupath/qupath/pull/888:33,Deployability,release,release,33,Update version number for v0.3.2 release,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/888
https://github.com/qupath/qupath/pull/892:9,Usability,UX,UX,9,Improved UX in Find command,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/892
https://github.com/qupath/qupath/pull/897:0,Performance,Cache,Cache,0,Cache RGB image with BufferedImageOverlay,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/897
https://github.com/qupath/qupath/pull/899:14,Integrability,message,message,14,Fixed warning message for missing features,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/899
https://github.com/qupath/qupath/issues/904:20,Performance,cache,cached,20,Tiles are not being cached in v0.3.2 for ome.tiff images but are in v0.3.0,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/904
https://github.com/qupath/qupath/pull/910:11,Deployability,update,updates,11,Dependency updates,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/910
https://github.com/qupath/qupath/pull/910:0,Integrability,Depend,Dependency,0,Dependency updates,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/910
https://github.com/qupath/qupath/pull/911:0,Deployability,Update,Update,0,Update changelog,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/911
https://github.com/qupath/qupath/pull/913:0,Deployability,Update,Update,0,Update dependencies,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/913
https://github.com/qupath/qupath/pull/913:7,Integrability,depend,dependencies,7,Update dependencies,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/913
https://github.com/qupath/qupath/issues/914:25,Performance,load,loaded,25,Extension jars cannot be loaded when processing a project from the command line,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/914
https://github.com/qupath/qupath/issues/915:34,Availability,error,error,34,Removing >255 measurements throws error when reproducing from workflow script,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/915
https://github.com/qupath/qupath/pull/917:14,Modifiability,refactor,refactoring,14,Script Editor refactoring,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/917
https://github.com/qupath/qupath/pull/920:30,Deployability,update,update,30,"Minor fixes to javadocs, gson update",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/920
https://github.com/qupath/qupath/pull/921:9,Testability,log,logic,9,Simplify logic for checking extensions inside zip files,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/921
https://github.com/qupath/qupath/pull/921:0,Usability,Simpl,Simplify,0,Simplify logic for checking extensions inside zip files,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/921
https://github.com/qupath/qupath/pull/923:0,Safety,Avoid,Avoid,0,Avoid updating annotation color unnecessarily,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/923
https://github.com/qupath/qupath/pull/925:0,Safety,Avoid,Avoid,0,Avoid showing incompatible image types,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/925
https://github.com/qupath/qupath/pull/931:6,Modifiability,refactor,refactoring,6,Major refactoring of Script Editor,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/931
https://github.com/qupath/qupath/pull/936:16,Performance,perform,performance,16,Improve repaint performance for non-8-bit images,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/936
https://github.com/qupath/qupath/pull/939:20,Deployability,update,updates,20,Minor script editor updates,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/939
https://github.com/qupath/qupath/pull/946:0,Deployability,Update,Update,0,Update dependencies,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/946
https://github.com/qupath/qupath/pull/946:7,Integrability,depend,dependencies,7,Update dependencies,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/946
https://github.com/qupath/qupath/issues/949:0,Deployability,Install,Installing,0,Installing QuPath on CentOS 7,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/949
https://github.com/qupath/qupath/issues/950:16,Modifiability,plugin,plugin,16,Failed to apply plugin class 'org.gradle.api.plugins.JavaPlugin'. gradle-plugins-7.4.2.jar (No such file or directory),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/950
https://github.com/qupath/qupath/issues/950:45,Modifiability,plugin,plugins,45,Failed to apply plugin class 'org.gradle.api.plugins.JavaPlugin'. gradle-plugins-7.4.2.jar (No such file or directory),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/950
https://github.com/qupath/qupath/issues/950:73,Modifiability,plugin,plugins-,73,Failed to apply plugin class 'org.gradle.api.plugins.JavaPlugin'. gradle-plugins-7.4.2.jar (No such file or directory),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/950
https://github.com/qupath/qupath/issues/957:5,Availability,error,errors,5,Many errors logged when using Bio-Formats memoization with Java 17,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/957
https://github.com/qupath/qupath/issues/957:12,Testability,log,logged,12,Many errors logged when using Bio-Formats memoization with Java 17,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/957
https://github.com/qupath/qupath/issues/961:19,Integrability,depend,dependency,19,Remove OpenCV as a dependency for qupath-core,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/961
https://github.com/qupath/qupath/pull/971:36,Availability,avail,available,36,"Improve PathPrefs, Locale support & available PathClasses",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/971
https://github.com/qupath/qupath/issues/973:6,Security,access,access,6,Can't access WSI levels in MACOS Monterey 12.4,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/973
https://github.com/qupath/qupath/pull/975:26,Testability,Test,TestBufferedImageTools,26,"Fix resizing bug, improve TestBufferedImageTools",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/975
https://github.com/qupath/qupath/pull/977:0,Deployability,Update,Update,0,Update to Bio-Formats 6.10.0,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/977
https://github.com/qupath/qupath/pull/978:31,Integrability,depend,dependency,31,Remove OpenCV as a qupath-core dependency,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/978
https://github.com/qupath/qupath/issues/990:55,Availability,error,error,55,Uncaught exceptions can fill the screen with duplicate error notifications,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/990
https://github.com/qupath/qupath/pull/992:18,Availability,robust,robustness,18,Improve CellTools robustness,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/992
https://github.com/qupath/qupath/issues/993:24,Availability,mask,masks,24,Feature request: Export masks without a color lookup table,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/993
https://github.com/qupath/qupath/issues/994:7,Safety,detect,detection,7,QuPath detection cytoplasm Inclusions,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/994
https://github.com/qupath/qupath/issues/997:48,Performance,load,load,48,Huron Microscopy BioFormat TIF Image - Unabe to load,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/997
https://github.com/qupath/qupath/pull/998:4,Deployability,update,update,4,JTS update & related fixes,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/998
https://github.com/qupath/qupath/pull/999:0,Deployability,Update,Update,0,Update dependencies,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/999
https://github.com/qupath/qupath/pull/999:7,Integrability,depend,dependencies,7,Update dependencies,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/999
https://github.com/qupath/qupath/issues/1006:37,Availability,avail,available,37,'Normalized OD colors' should not be available for RGB fluorescence images,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1006
https://github.com/qupath/qupath/pull/1008:8,Performance,perform,performance,8,Improve performance writing planar ome-tiffs,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1008
https://github.com/qupath/qupath/pull/1017:0,Deployability,Update,Update,0,Update gradle-wrapper.properties,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1017
https://github.com/qupath/qupath/pull/1017:14,Integrability,wrap,wrapper,14,Update gradle-wrapper.properties,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1017
https://github.com/qupath/qupath/issues/1021:0,Usability,clear,clearDetections,0,clearDetections() does not reset TMA isEditable to true,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1021
https://github.com/qupath/qupath/issues/1022:30,Safety,detect,detection,30,"It isn't possible to run cell detection on channels with "" in the name",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1022
https://github.com/qupath/qupath/issues/1027:24,Security,hash,hash,24,Please consider posting hash information for .msi and standalone .exe,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027
https://github.com/qupath/qupath/pull/1028:0,Deployability,Update,Update,0,Update issue templates,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1028
https://github.com/qupath/qupath/issues/1033:12,Safety,detect,detections,12,Distance of detections to border of parent annotation,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1033
https://github.com/qupath/qupath/issues/1034:12,Deployability,update,update,12,.VSI Format update,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1034
https://github.com/qupath/qupath/pull/1038:0,Deployability,Update,Update,0,Update dependencies,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1038
https://github.com/qupath/qupath/pull/1038:7,Integrability,depend,dependencies,7,Update dependencies,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1038
https://github.com/qupath/qupath/issues/1040:50,Modifiability,plugin,plugin,50,Memory accumulation when using intensity features plugin for many annotations,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1040
https://github.com/qupath/qupath/pull/1053:8,Deployability,update,updatePlane,8,Add ROI.updatePlane(plane) method,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1053
https://github.com/qupath/qupath/pull/1054:20,Usability,responsiv,responsiveness,20,Improve drag & drop responsiveness,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1054
https://github.com/qupath/qupath/pull/1056:0,Deployability,Update,Update,0,Update dark.css,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1056
https://github.com/qupath/qupath/pull/1058:0,Deployability,Update,Update,0,Update dependencies,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1058
https://github.com/qupath/qupath/pull/1058:7,Integrability,depend,dependencies,7,Update dependencies,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1058
https://github.com/qupath/qupath/pull/1059:0,Deployability,Update,Update,0,Update dark mode styling,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1059
https://github.com/qupath/qupath/pull/1061:0,Deployability,Update,Update,0,Update dark.css,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1061
https://github.com/qupath/qupath/pull/1066:0,Deployability,Update,Update,0,Update scripting_styles.css,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1066
https://github.com/qupath/qupath/issues/1067:7,Availability,down,down,7,QuPath down list problems,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1067
https://github.com/qupath/qupath/issues/1069:50,Availability,down,downsample,50,Object connections cause moderate viewer lag when downsample factor is less than 1,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1069
https://github.com/qupath/qupath/pull/1070:28,Performance,perform,performance,28,Improve connection painting performance,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1070
https://github.com/qupath/qupath/pull/1073:0,Deployability,Update,Update,0,Update dependencies and readme,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1073
https://github.com/qupath/qupath/pull/1073:7,Integrability,depend,dependencies,7,Update dependencies and readme,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1073
https://github.com/qupath/qupath/pull/1076:37,Performance,perform,performance,37,Improve pixel classifier measurement performance,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1076
https://github.com/qupath/qupath/pull/1080:25,Testability,log,log,25,Use styling for the main log,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1080
https://github.com/qupath/qupath/issues/1085:42,Usability,intuit,intuitive,42,Replace MeasurementList with Map for more intuitive scripting,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1085
https://github.com/qupath/qupath/pull/1089:0,Deployability,Update,Updated,0,Updated PathObject setting/getting colors,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1089
https://github.com/qupath/qupath/pull/1098:5,Safety,detect,detection,5,Cell detection background,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1098
https://github.com/qupath/qupath/pull/1101:8,Deployability,update,updates,8,Javadoc updates,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1101
https://github.com/qupath/qupath/pull/1107:0,Deployability,Update,Update,0,Update to JavaCPP 1.5.8,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1107
https://github.com/qupath/qupath/issues/1108:22,Deployability,install,installing,22,Security Concern when installing QuPath using .msi,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108
https://github.com/qupath/qupath/issues/1108:0,Security,Secur,Security,0,Security Concern when installing QuPath using .msi,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108
https://github.com/qupath/qupath/pull/1109:0,Deployability,Update,Update,0,Update method names in PathObjectHierarchy,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1109
https://github.com/qupath/qupath/pull/1110:0,Deployability,Update,Update,0,Update build.gradle,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1110
https://github.com/qupath/qupath/pull/1111:0,Deployability,Update,Update,0,Update PathObject method names,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1111
https://github.com/qupath/qupath/issues/1114:0,Deployability,Update,Update,0,Update 'Unique ID' to 'Case ID' for TMA cores,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1114
https://github.com/qupath/qupath/pull/1122:33,Integrability,synchroniz,synchronizing,33,Correct for viewer rotation when synchronizing,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1122
https://github.com/qupath/qupath/pull/1124:17,Integrability,message,message,17,Improved startup message dialog,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1124
https://github.com/qupath/qupath/pull/1127:24,Usability,undo,undockable,24,Make analysis pane tabs undockable,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1127
https://github.com/qupath/qupath/pull/1128:0,Usability,Simpl,Simplify,0,Simplify setting accelerators for menu items,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1128
https://github.com/qupath/qupath/pull/1131:0,Deployability,Update,Update,0,Update dependencies & changelog,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1131
https://github.com/qupath/qupath/pull/1131:7,Integrability,depend,dependencies,7,Update dependencies & changelog,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1131
https://github.com/qupath/qupath/pull/1142:0,Deployability,Update,Update,0,Update dependencies,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1142
https://github.com/qupath/qupath/pull/1142:7,Integrability,depend,dependencies,7,Update dependencies,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1142
https://github.com/qupath/qupath/pull/1145:59,Integrability,depend,dependent,59,"In recent projects menu, added paths tooltips and fixed OS dependent separators",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1145
https://github.com/qupath/qupath/pull/1152:0,Deployability,Update,Update,0,Update GitHub actions,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1152
https://github.com/qupath/qupath/issues/1154:10,Performance,load,load,10,Long(ish) load times for QuPath project containing multiplexed images,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154
https://github.com/qupath/qupath/pull/1156:10,Deployability,Patch,PatchClassifierParams,10,Introduce PatchClassifierParams,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1156
https://github.com/qupath/qupath/pull/1158:0,Deployability,Update,Update,0,Update version catalog,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1158
https://github.com/qupath/qupath/pull/1159:26,Deployability,update,updates,26,Seemingly inconsequential updates,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1159
https://github.com/qupath/qupath/pull/1164:0,Deployability,Update,Update,0,Update licenses,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1164
https://github.com/qupath/qupath/pull/1165:16,Deployability,update,updates,16,Fixes and build updates,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1165
https://github.com/qupath/qupath/pull/1166:27,Modifiability,config,config,27,Make it easier to find the config file,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1166
https://github.com/qupath/qupath/pull/1168:0,Deployability,Update,Update,0,Update djl version,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1168
https://github.com/qupath/qupath/pull/1171:0,Deployability,Update,Update,0,Update bioformats & readme,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1171
https://github.com/qupath/qupath/pull/1172:0,Deployability,Update,Update,0,Update version,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1172
https://github.com/qupath/qupath/issues/1182:47,Performance,Concurren,ConcurrentModificationException,47,Counting object descendants sometimes causes a ConcurrentModificationException,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1182
https://github.com/qupath/qupath/issues/1191:28,Deployability,update,updates,28,Exception when checking for updates,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1191
https://github.com/qupath/qupath/pull/1193:4,Performance,concurren,concurrent,4,Fix concurrent exception with object descendants,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1193
https://github.com/qupath/qupath/pull/1194:4,Deployability,update,update,4,Fix update check bug,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1194
https://github.com/qupath/qupath/pull/1198:0,Deployability,Update,Update,0,Update version to v0.4.1,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1198
https://github.com/qupath/qupath/issues/1203:60,Deployability,update,update,60,Setting the default object color in the preferences doesn't update the toolbar icons in v0.4.1,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1203
https://github.com/qupath/qupath/pull/1204:0,Deployability,Update,Update,0,Update snapshot version,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1204
https://github.com/qupath/qupath/issues/1211:23,Performance,load,loaded,23,Extensions jars aren't loaded for batch scripts from the command line,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1211
https://github.com/qupath/qupath/pull/1216:0,Deployability,Update,Update,0,Update version for v0.4.2,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1216
https://github.com/qupath/qupath/issues/1217:54,Safety,detect,detections,54,Opening the same image in multiple viewers results in detections being wrongly shown in both,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1217
https://github.com/qupath/qupath/pull/1219:0,Modifiability,Refactor,Refactoring,0,Refactoring the UI,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1219
https://github.com/qupath/qupath/issues/1220:1,Integrability,Synchroniz,Synchronize,1,'Synchronize viewers' ignores z and t positions,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1220
https://github.com/qupath/qupath/issues/1228:22,Integrability,Message,Message,22,macOS Ventura 13.2 -> Message QuPath is damaged,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1228
https://github.com/qupath/qupath/pull/1230:0,Deployability,Update,Update,0,Update (most of the) UI immediately on locale change,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1230
https://github.com/qupath/qupath/pull/1235:23,Testability,test,test,23,Add ParameterList json test,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1235
https://github.com/qupath/qupath/pull/1237:0,Deployability,Update,Update,0,"Update dependencies, reinstate memoization",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1237
https://github.com/qupath/qupath/pull/1237:7,Integrability,depend,dependencies,7,"Update dependencies, reinstate memoization",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1237
https://github.com/qupath/qupath/pull/1238:0,Deployability,Update,Update,0,Update version number for v0.4.3,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1238
https://github.com/qupath/qupath/issues/1239:9,Availability,mask,masks,9,Circular masks for intensity/tile features may be shifted by 1 pixel,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1239
https://github.com/qupath/qupath/pull/1243:35,Performance,load,loading,35,"Improve preference support, enable loading .properties from user directory",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1243
https://github.com/qupath/qupath/issues/1245:43,Energy Efficiency,Green,Green,43,"Using existing channel names (e.g. 'Red', 'Green', 'Blue') for color deconvolution can confuse brightness/contrast settings",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1245
https://github.com/qupath/qupath/issues/1246:20,Deployability,update,update,20,Slide label doesn't update as expected when changing the image,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1246
https://github.com/qupath/qupath/pull/1255:7,Deployability,update,update,7,JavaFX update and fixes,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1255
https://github.com/qupath/qupath/issues/1260:35,Availability,avail,available,35,Use default extension path if it's available,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1260
https://github.com/qupath/qupath/issues/1264:22,Availability,error,error,22,Groovy to JSON script error,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1264
https://github.com/qupath/qupath/pull/1266:17,Modifiability,refactor,refactoring,17,Some quite major refactoring,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1266
https://github.com/qupath/qupath/issues/1269:8,Safety,detect,detection,8,"""create detection classifier"" function not found in QP version0.4",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1269
https://github.com/qupath/qupath/pull/1274:36,Deployability,release,release,36,Committing to v0.5.0 being the next release,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1274
https://github.com/qupath/qupath/pull/1279:22,Availability,down,downsamplefactor,22,Add changelistener to downsamplefactor,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1279
https://github.com/qupath/qupath/pull/1284:0,Deployability,Update,Update,0,Update PreferencePane.java,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1284
https://github.com/qupath/qupath/pull/1299:0,Deployability,Update,Update,0,Update dependencies,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1299
https://github.com/qupath/qupath/pull/1299:7,Integrability,depend,dependencies,7,Update dependencies,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1299
https://github.com/qupath/qupath/pull/1302:17,Integrability,synchroniz,synchronize,17,Handle z & t in 'synchronize viewers',MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1302
https://github.com/qupath/qupath/pull/1305:14,Testability,log,log,14,Introduce new log viewer,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1305
https://github.com/qupath/qupath/pull/1307:17,Deployability,release,release,17,Potential v0.4.4 release,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1307
https://github.com/qupath/qupath/pull/1308:0,Usability,Simpl,Simplify,0,Simplify preference handling,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1308
https://github.com/qupath/qupath/issues/1313:16,Safety,detect,detections,16,Annotations and detections deleted from saved project when switching between images,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1313
https://github.com/qupath/qupath/pull/1315:23,Deployability,update,updates,23,"Toolbar, Menu and icon updates",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1315
https://github.com/qupath/qupath/pull/1316:0,Deployability,Update,Update,0,Update ViewTrackerControlPane.java,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1316
https://github.com/qupath/qupath/pull/1319:8,Availability,mask,masked,8,Extract masked pixels,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1319
https://github.com/qupath/qupath/issues/1322:21,Performance,perform,performance,21,Pixel classification performance issues with batch processing,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322
https://github.com/qupath/qupath/pull/1332:0,Energy Efficiency,Reduce,Reduce,0,"Reduce memory use, improve pixel classification measurement performance",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1332
https://github.com/qupath/qupath/pull/1332:60,Performance,perform,performance,60,"Reduce memory use, improve pixel classification measurement performance",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1332
https://github.com/qupath/qupath/pull/1333:4,Testability,log,log,4,Set log viewer min size,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1333
https://github.com/qupath/qupath/pull/1336:13,Integrability,message,messages,13,Support info messages / badges,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1336
https://github.com/qupath/qupath/pull/1339:27,Safety,avoid,avoid,27,Set min logviewer width to avoid clipping,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339
https://github.com/qupath/qupath/pull/1339:8,Testability,log,logviewer,8,Set min logviewer width to avoid clipping,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339
https://github.com/qupath/qupath/pull/1341:4,Availability,error,error,4,Add error badge to log toolbar button,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1341
https://github.com/qupath/qupath/pull/1341:19,Testability,log,log,19,Add error badge to log toolbar button,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1341
https://github.com/qupath/qupath/pull/1345:0,Safety,Avoid,Avoid,0,Avoid importing invisible TMA grids,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1345
https://github.com/qupath/qupath/pull/1350:0,Modifiability,Extend,Extend,0,Extend tiler to support different alignments.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1350
https://github.com/qupath/qupath/pull/1352:0,Usability,Simpl,Simple,0,Simple barchart with selection,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1352
https://github.com/qupath/qupath/pull/1360:6,Modifiability,Plugin,PluginRunner,6,Swap `PluginRunner` with `TaskRunner`,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1360
https://github.com/qupath/qupath/pull/1361:0,Deployability,Update,Update,0,Update README.md,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1361
https://github.com/qupath/qupath/pull/1362:10,Availability,error,error,10,Show only error count since log visible,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1362
https://github.com/qupath/qupath/pull/1362:28,Testability,log,log,28,Show only error count since log visible,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1362
https://github.com/qupath/qupath/pull/1364:18,Modifiability,plugin,plugin,18,Use javafx-gradle-plugin v0.1.0,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1364
https://github.com/qupath/qupath/pull/1365:5,Integrability,depend,dependencies,5,Bump dependencies,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1365
https://github.com/qupath/qupath/pull/1366:22,Deployability,install,installers,22,Make both rpm and deb installers for linux builds,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1366
https://github.com/qupath/qupath/pull/1368:20,Modifiability,plugin,plugin,20,Add gradle checksum plugin,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1368
https://github.com/qupath/qupath/pull/1368:11,Security,checksum,checksum,11,Add gradle checksum plugin,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1368
https://github.com/qupath/qupath/pull/1369:0,Deployability,Update,Update,0,"Update gradle wrapper, checksums",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1369
https://github.com/qupath/qupath/pull/1369:14,Integrability,wrap,wrapper,14,"Update gradle wrapper, checksums",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1369
https://github.com/qupath/qupath/pull/1369:23,Security,checksum,checksums,23,"Update gradle wrapper, checksums",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1369
https://github.com/qupath/qupath/pull/1370:0,Safety,Avoid,Avoid,0,Avoid pref-related warnings on startup,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1370
https://github.com/qupath/qupath/pull/1372:0,Deployability,Update,Updates,0,Updates for Mac permissions trouble,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1372
https://github.com/qupath/qupath/pull/1373:0,Deployability,Update,Update,0,Update jpackage-mac.yml,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1373
https://github.com/qupath/qupath/pull/1374:0,Deployability,Update,Update,0,Update jpackage-mac.yml,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1374
https://github.com/qupath/qupath/pull/1376:25,Availability,down,downgrade,25,"Reverting macOS changes, downgrade JavaFX",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1376
https://github.com/qupath/qupath/pull/1380:0,Deployability,Update,Update,0,Update versions & changelog,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1380
https://github.com/qupath/qupath/pull/1381:0,Deployability,Update,Update,0,Update version and changelog,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1381
https://github.com/qupath/qupath/pull/1383:40,Usability,simpl,simplify,40,"Fix B/C settings for multiple channels, simplify build.gradle",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1383
https://github.com/qupath/qupath/pull/1384:0,Deployability,Update,Update,0,"Update build script, changelog",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1384
https://github.com/qupath/qupath/pull/1389:0,Deployability,Update,Update,0,Update dependencies,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1389
https://github.com/qupath/qupath/pull/1389:7,Integrability,depend,dependencies,7,Update dependencies,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1389
https://github.com/qupath/qupath/pull/1393:0,Deployability,Update,Update,0,Update version for rc2,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1393
https://github.com/qupath/qupath/pull/1396:14,Deployability,release,release,14,Use openslide release,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1396
https://github.com/qupath/qupath/pull/1399:0,Deployability,Update,Update,0,Update richtextfx,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1399
https://github.com/qupath/qupath/pull/1404:0,Energy Efficiency,Reduce,Reduce,0,Reduce synchronization in AbstractImageRegionStore,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1404
https://github.com/qupath/qupath/pull/1404:7,Integrability,synchroniz,synchronization,7,Reduce synchronization in AbstractImageRegionStore,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1404
https://github.com/qupath/qupath/pull/1410:0,Integrability,Synchroniz,Synchronize,0,Synchronize gridded areas,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1410
https://github.com/qupath/qupath/pull/1416:8,Availability,error,error,8,Improve error messages on import,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1416
https://github.com/qupath/qupath/pull/1416:14,Integrability,message,messages,14,Improve error messages on import,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1416
https://github.com/qupath/qupath/pull/1417:26,Integrability,message,message,26,Bio-Formats Apple Silicon message,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1417
https://github.com/qupath/qupath/pull/1422:0,Usability,Simpl,Simplify,0,Simplify DnnModel implementation,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1422
https://github.com/qupath/qupath/pull/1423:0,Deployability,Update,Update,0,Update IconFactory.java,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1423
https://github.com/qupath/qupath/pull/1424:6,Deployability,update,updates,6,Build updates,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1424
https://github.com/qupath/qupath/pull/1425:0,Deployability,Update,Update,0,"Update versions, license year",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1425
https://github.com/qupath/qupath/pull/1426:11,Testability,test,test,11,Fix gradle test deprecation,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1426
https://github.com/qupath/qupath/pull/1428:0,Availability,Down,Downgrade,0,Downgrade DJL to 0.24.0,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1428
https://github.com/qupath/qupath/pull/1431:0,Deployability,Update,Update,0,Update libs.versions.toml,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1431
https://github.com/qupath/qupath/pull/1435:0,Deployability,Update,Update,0,Update docs paths,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1435
https://github.com/qupath/qupath/issues/1441:58,Availability,avail,available,58,Exception when opening script if the last directory isn't available,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1441
https://github.com/qupath/qupath/issues/1443:55,Availability,error,errors,55,Full image annotation for Sparse training image throws errors for detections,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1443:66,Safety,detect,detections,66,Full image annotation for Sparse training image throws errors for detections,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443
https://github.com/qupath/qupath/issues/1444:0,Performance,Concurren,ConcurrentModificationException,0,ConcurrentModificationException when working with measurements,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444
https://github.com/qupath/qupath/pull/1447:17,Performance,load,loading,17,Change openslide loading behaviour,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1447
https://github.com/qupath/qupath/pull/1449:16,Performance,load,load,16,Support to save/load files to/from sshfs-win volumes,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1449
https://github.com/qupath/qupath/issues/1450:41,Integrability,message,message,41,Add keyboard shortcut info to tool hover message,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1450
https://github.com/qupath/qupath/issues/1451:27,Availability,failure,failure,27,convert-ome returns 0 upon failure,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1451
https://github.com/qupath/qupath/issues/1454:23,Availability,avail,available,23,'Sum' measurement only available for Nucleus in Cell detection,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1454
https://github.com/qupath/qupath/issues/1454:53,Safety,detect,detection,53,'Sum' measurement only available for Nucleus in Cell detection,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1454
https://github.com/qupath/qupath/issues/1458:29,Availability,avail,available,29,M1 github actions runner now available,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1458
https://github.com/qupath/qupath/issues/1459:45,Deployability,update,update,45,Brightness/Contrast histogram doesn't always update when switching between similar images,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1459
https://github.com/qupath/qupath/pull/1460:0,Deployability,Update,Update,0,Update jpackage.yml for mac aarch64,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1460
https://github.com/qupath/qupath/pull/1464:0,Deployability,Update,Update,0,Update jpackage.yml to create all artifacts and draft a release,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1464
https://github.com/qupath/qupath/pull/1464:56,Deployability,release,release,56,Update jpackage.yml to create all artifacts and draft a release,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1464
https://github.com/qupath/qupath/pull/1466:6,Integrability,synchroniz,synchronization,6,Added synchronization to NumericMeasurementList,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1466
https://github.com/qupath/qupath/issues/1472:64,Availability,avail,available,64,Grid views don't show objects by default if no measurements are available,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1472
https://github.com/qupath/qupath/pull/1477:0,Deployability,Update,Update,0,Update CHANGELOG.md for v0.5.1,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1477
https://github.com/qupath/qupath/pull/1481:0,Deployability,Update,Update,0,Update qupath-fxtras,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1481
https://github.com/qupath/qupath/pull/1482:30,Deployability,update,update,30,Fix ImageDisplay json channel update bug,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1482
https://github.com/qupath/qupath/pull/1484:0,Deployability,Update,Update,0,Update version for v0.5.1,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1484
https://github.com/qupath/qupath/issues/1487:0,Usability,Undo,Undo,0,Undo/Redo unexpected behavior after importing from file,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1487
https://github.com/qupath/qupath/pull/1488:51,Safety,avoid,avoid,51,add option to ProjectImageEntry.readImageData() to avoid accessing the file image,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488
https://github.com/qupath/qupath/pull/1488:57,Security,access,accessing,57,add option to ProjectImageEntry.readImageData() to avoid accessing the file image,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488
https://github.com/qupath/qupath/pull/1489:5,Performance,load,load,5,Lazy-load ImageServer from ImageData,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489
https://github.com/qupath/qupath/issues/1490:0,Deployability,Update,Update,0,Update log viewer version,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1490
https://github.com/qupath/qupath/issues/1490:7,Testability,log,log,7,Update log viewer version,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1490
https://github.com/qupath/qupath/issues/1491:61,Performance,Load,Loading,61,"QuPath Viewer Hangs on Ubuntu 22.04 Due to OpenSlide Library Loading Issue When Opening .tiff Images""",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1491
https://github.com/qupath/qupath/issues/1494:0,Integrability,Wrap,WrappedBufferedImageServer,0,WrappedBufferedImageServer converts images to 8-bit unnecessarily,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1494
https://github.com/qupath/qupath/pull/1495:4,Integrability,Wrap,WrappedBufferedImageServer,4,Fix WrappedBufferedImageServer bug,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1495
https://github.com/qupath/qupath/pull/1496:0,Deployability,Update,Update,0,Update dependencies,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1496
https://github.com/qupath/qupath/pull/1496:7,Integrability,depend,dependencies,7,Update dependencies,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1496
https://github.com/qupath/qupath/issues/1498:13,Availability,down,down,13,Channel drop-down box right click,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1498
https://github.com/qupath/qupath/issues/1499:55,Deployability,update,update,55,Brightness/Contrast 'Apply to similar images' fails to update settings immediately across viewers,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1499
https://github.com/qupath/qupath/issues/1501:40,Safety,Detect,Detection,40,Rename Object Classification submenu to Detection Classification,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501
https://github.com/qupath/qupath/pull/1505:0,Testability,Log,Log,0,Log openslide exception,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1505
https://github.com/qupath/qupath/pull/1506:0,Deployability,Update,Update,0,Update dependencies & changelog,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1506
https://github.com/qupath/qupath/pull/1506:7,Integrability,depend,dependencies,7,Update dependencies & changelog,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1506
https://github.com/qupath/qupath/pull/1509:4,Testability,log,logviewer,4,Use logviewer and qupath-fxtras snapshots,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1509
https://github.com/qupath/qupath/pull/1510:0,Usability,UX,UX,0,UX - Export measurements resizable UI,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1510
https://github.com/qupath/qupath/pull/1512:0,Usability,UX,UX,0,UX - Classifier image select resizable UI,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1512
https://github.com/qupath/qupath/pull/1513:17,Integrability,depend,dependencies,17,Embed Javadoc of dependencies in application,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1513
https://github.com/qupath/qupath/pull/1514:0,Deployability,Update,Update,0,Update PixelProcessorUtils.java,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1514
https://github.com/qupath/qupath/pull/1518:16,Integrability,depend,dependency,16,Remove run task dependency on getJavadocs,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1518
https://github.com/qupath/qupath/pull/1520:23,Performance,perform,performance,23,Improve ContourTracing performance,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1520
https://github.com/qupath/qupath/pull/1521:7,Availability,down,downsample,7,Ensure downsample is set to finite value,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1521
https://github.com/qupath/qupath/pull/1524:46,Integrability,interface,interface,46,"Add ""prompt to close"" method to script editor interface",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1524
https://github.com/qupath/qupath/issues/1527:36,Availability,down,downsampled,36,Black row or column appears on some downsampled images,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1527
https://github.com/qupath/qupath/pull/1528:18,Availability,down,downsampled,18,Decreased size of downsampled image,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1528
https://github.com/qupath/qupath/pull/1529:0,Deployability,Update,Update,0,"Update dependencies, add DJL model zoo",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1529
https://github.com/qupath/qupath/pull/1529:7,Integrability,depend,dependencies,7,"Update dependencies, add DJL model zoo",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1529
https://github.com/qupath/qupath/pull/1531:23,Availability,down,downsampled,23,Fix black columns with downsampled images,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1531
https://github.com/qupath/qupath/pull/1534:0,Deployability,Update,Update,0,Update RoiEditor constrain to image,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1534
https://github.com/qupath/qupath/issues/1536:19,Deployability,install,install,19,Is there anyway to install Qupath by scoop?,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1536
https://github.com/qupath/qupath/pull/1540:8,Testability,log,log,8,Support log histograms with measurement tables,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1540
https://github.com/qupath/qupath/issues/1541:26,Security,validat,validate,26,ParameterPanelFX does not validate text field input,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1541
https://github.com/qupath/qupath/issues/1545:5,Safety,detect,detection,5,"cell detection always segments white areas instead of colored areas,why?",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1545
https://github.com/qupath/qupath/issues/1550:0,Safety,Detect,Detection,0,Detection Centroid Distances does not work across detection types (Detections vs Cells),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550
https://github.com/qupath/qupath/issues/1550:50,Safety,detect,detection,50,Detection Centroid Distances does not work across detection types (Detections vs Cells),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550
https://github.com/qupath/qupath/issues/1550:67,Safety,Detect,Detections,67,Detection Centroid Distances does not work across detection types (Detections vs Cells),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550
https://github.com/qupath/qupath/pull/1555:0,Deployability,Update,Update,0,Update dependencies,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1555
https://github.com/qupath/qupath/pull/1555:7,Integrability,depend,dependencies,7,Update dependencies,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1555
https://github.com/qupath/qupath/pull/1560:5,Modifiability,plugin,plugin,5,Make plugin panes only appear once,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1560
https://github.com/qupath/qupath/pull/1563:20,Security,access,access,20,Improved methods to access objects from PathObjectHierarchy,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563
https://github.com/qupath/qupath/pull/1569:11,Deployability,update,updates,11,Dependency updates,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1569
https://github.com/qupath/qupath/pull/1569:0,Integrability,Depend,Dependency,0,Dependency updates,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1569
https://github.com/qupath/qupath/pull/1570:11,Testability,test,tests,11,Split unit tests,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1570
https://github.com/qupath/qupath/pull/1576:0,Testability,Log,Log,0,Log less eagerly in DnnModel,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1576
https://github.com/qupath/qupath/pull/1579:13,Performance,load,loading,13,Avoid server loading during DefaultProject.saveImageData() if it was never loaded before,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1579
https://github.com/qupath/qupath/pull/1579:75,Performance,load,loaded,75,Avoid server loading during DefaultProject.saveImageData() if it was never loaded before,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1579
https://github.com/qupath/qupath/pull/1579:0,Safety,Avoid,Avoid,0,Avoid server loading during DefaultProject.saveImageData() if it was never loaded before,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1579
https://github.com/qupath/qupath/pull/1585:0,Usability,Simpl,Simplify,0,Simplify PathIO,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1585
https://github.com/qupath/qupath/pull/1589:0,Deployability,Update,Update,0,Update dependencies,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1589
https://github.com/qupath/qupath/pull/1589:7,Integrability,depend,dependencies,7,Update dependencies,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1589
https://github.com/qupath/qupath/issues/1591:36,Safety,safe,safe,36,MeasurementList is not fully thread-safe,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1591
https://github.com/qupath/qupath/pull/1593:26,Usability,simpl,simplify,26,Streamline PathObject and simplify working with classifications,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1593
https://github.com/qupath/qupath/pull/1596:0,Deployability,Update,Update,0,Update DelaunayTools.java,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1596
https://github.com/qupath/qupath/pull/1603:0,Deployability,Update,Update,0,Update to Java 21,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1603
https://github.com/qupath/qupath/issues/1605:0,Modifiability,Extend,Extended,0,Extended Validation Code Signing Certificate,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1605
https://github.com/qupath/qupath/issues/1605:9,Security,Validat,Validation,9,Extended Validation Code Signing Certificate,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1605
https://github.com/qupath/qupath/issues/1605:33,Security,Certificate,Certificate,33,Extended Validation Code Signing Certificate,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1605
https://github.com/qupath/qupath/issues/1606:34,Safety,detect,detected,34,Out-of-bounds tiles can result in detected cells being in the wrong place,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1606
https://github.com/qupath/qupath/pull/1607:23,Safety,detect,detection,23,Fix out-of-bounds cell detection,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1607
https://github.com/qupath/qupath/pull/1608:27,Deployability,update,update,27,"Fix minor bugs, warnings & update gradlew",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1608
https://github.com/qupath/qupath/pull/1616:0,Deployability,Update,Update,0,"Update Guava, JTS",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1616
https://github.com/qupath/qupath/pull/1621:26,Integrability,interface,interface,26,Introduce ObjectProcessor interface,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1621
https://github.com/qupath/qupath/pull/1623:7,Safety,detect,detection,7,Change detection line thickness when upsampling,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1623
https://github.com/qupath/qupath/pull/1626:0,Deployability,Upgrade,Upgrade,0,"Upgrade gradle, dependences",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1626
https://github.com/qupath/qupath/pull/1626:16,Integrability,depend,dependences,16,"Upgrade gradle, dependences",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1626
https://github.com/qupath/qupath/issues/1628:25,Availability,avail,available,25,Timepoint data is rarely available (or correct),MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1628
https://github.com/qupath/qupath/pull/1630:0,Deployability,Update,Update,0,Update ConvertCommand,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1630
https://github.com/qupath/qupath/pull/1632:0,Deployability,Update,Update,0,Update for rc1,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1632
https://github.com/qupath/qupath/pull/1633:0,Deployability,Update,Update,0,"Update extensions, exclude transitive",MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1633
https://github.com/qupath/qupath/issues/1634:8,Availability,avail,available,8,No CUDA available in instantseg,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1634
https://github.com/qupath/qupath/pull/1639:16,Availability,mask,masking,16,Speed up object masking,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1639
https://github.com/qupath/qupath/pull/1642:0,Deployability,Update,Update,0,Update to DJL v0.30.0,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1642
https://github.com/qupath/qupath/pull/1643:7,Testability,test,tests,7,Ensure tests use UTF-8,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1643
https://github.com/qupath/qupath/issues/1644:40,Security,access,access,40,Shorten Classifications menu for easier access,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1644
https://github.com/qupath/qupath/pull/1650:8,Integrability,message,message,8,Support message for TaskRunner,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1650
https://github.com/qupath/qupath/issues/1652:37,Deployability,install,installations,37,Javadoc jars are missing from QuPath installations,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1652
https://github.com/qupath/qupath/pull/1656:11,Deployability,update,updates,11,Dependency updates,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1656
https://github.com/qupath/qupath/pull/1656:0,Integrability,Depend,Dependency,0,Dependency updates,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1656
https://github.com/qupath/qupath/pull/1668:5,Deployability,update,update,5,Auto-update URIs for self-contained projects,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1668
https://github.com/qupath/qupath/issues/1672:38,Security,Certificate,Certificate,38,macOS Applications Signed with Ad-Hoc Certificate,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1672
https://github.com/qupath/qupath/issues/1674:46,Availability,mask,masks,46,Complicated 'Polygon' ROIs can give different masks in ImageJ & QuPath,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1674
https://github.com/qupath/qupath/pull/1676:23,Deployability,integrat,integration,23,Improvements to ImageJ integration,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1676
https://github.com/qupath/qupath/pull/1676:23,Integrability,integrat,integration,23,Improvements to ImageJ integration,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1676
https://github.com/qupath/qupath/pull/1679:0,Deployability,Update,Update,0,Update ImageJ,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1679
https://github.com/qupath/qupath/pull/1680:23,Safety,detect,detection,23,ImageJ cleanup & fix a detection display bug,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1680
https://github.com/qupath/qupath/pull/1681:15,Usability,simpl,simplification,15,Improved point simplification in viewer,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1681
https://github.com/qupath/qupath/pull/1685:0,Deployability,Update,Update,0,Update IconFactory.java,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1685
https://github.com/qupath/qupath/pull/1690:0,Deployability,Update,Update,0,Update to Bio-Formats 8.0.0,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1690
https://github.com/qupath/qupath/issues/1691:41,Availability,error,errors,41,Version 0.4.4 has pixel classifier shows errors and does not process the annotations in the image.,MatchSource.ISSUE,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1691
