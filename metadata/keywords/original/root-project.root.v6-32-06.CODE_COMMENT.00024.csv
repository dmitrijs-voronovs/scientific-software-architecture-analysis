id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:23,Safety,safe,safe,23,"// Note that it is not safe to speculate into a malloc'd region because; // malloc may return null.; // For GEPs, determine if the indexing lands within the allocated object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:194,Security,access,accessed,194,"// As we recursed through GEPs to get here, we've incrementally checked; // that each step advanced by a multiple of the alignment. If our base is; // properly aligned, then the original offset accessed must also be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:9,Modifiability,refactor,refactor,9,/// TODO refactor this function to be able to search independently for; /// Dereferencability and Alignment requirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:73,Security,access,accessing,73,"// TODO: It may be okay to round to align, but that would imply that; // accessing slightly out of bounds was legal, and we're currently; // inconsistent about that. For the moment, be conservative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:194,Security,access,accessed,194,"// As we recursed through GEPs to get here, we've incrementally; // checked that each step advanced by a multiple of the alignment. If; // our base is properly aligned, then the original offset accessed; // must also be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:24,Performance,scalab,scalable,24,"// For unsized types or scalable vectors we don't know exactly how many bytes; // are dereferenced, so bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:198,Modifiability,variab,variable,198,"// When dereferenceability information is provided by a dereferenceable; // attribute, we know exactly how many bytes are dereferenceable. If we can; // determine the exact offset to the attributed variable, we can use that; // information here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:277,Performance,load,load,277,"/// Test if A and B will obviously have the same value.; ///; /// This includes recognizing that %t0 and %t1 will have the same; /// value in code like this:; /// \code; /// %t0 = getelementptr \@a, 0, 3; /// store i32 0, i32* %t0; /// %t1 = getelementptr \@a, 0, 3; /// %t2 = load i32* %t1; /// \endcode; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:4,Testability,Test,Test,4,"/// Test if A and B will obviously have the same value.; ///; /// This includes recognizing that %t0 and %t1 will have the same; /// value in code like this:; /// \code; /// %t0 = getelementptr \@a, 0, 3; /// store i32 0, i32* %t0; /// %t1 = getelementptr \@a, 0, 3; /// %t2 = load i32* %t1; /// \endcode; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:3,Testability,Test,Test,3,// Test if the values are trivially equivalent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:3,Testability,Test,Test,3,"// Test if the values come from identical arithmetic instructions.; // Use isIdenticalToWhenDefined instead of isIdenticalTo because; // this function is only used when one address use dominates the; // other, which means that they'll always either have the same; // value or one of them will have an undefined value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:88,Safety,safe,safe,88,"// If given a uniform (i.e. non-varying) address, see if we can prove the; // access is safe within the loop w/o needing predication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:78,Security,access,access,78,"// If given a uniform (i.e. non-varying) address, see if we can prove the; // access is safe within the loop w/o needing predication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:50,Security,access,access,50,"// Otherwise, check to see if we have a repeating access pattern where we can; // prove that all accesses are well aligned and dereferenceable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:97,Security,access,accesses,97,"// Otherwise, check to see if we have a repeating access pattern where we can; // prove that all accesses are well aligned and dereferenceable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:28,Security,access,accesses,28,// TODO: Handle overlapping accesses.; // We should be computing AccessSize as (TC - 1) * Step + EltSize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:65,Security,Access,AccessSize,65,// TODO: Handle overlapping accesses.; // We should be computing AccessSize as (TC - 1) * Step + EltSize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:21,Security,access,access,21,"// Compute the total access size for access patterns with unit stride and; // patterns with gaps. For patterns with unit stride, Step and EltSize are the; // same.; // For patterns with gaps (i.e. non unit stride), we are; // accessing EltSize bytes at every Step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:37,Security,access,access,37,"// Compute the total access size for access patterns with unit stride and; // patterns with gaps. For patterns with unit stride, Step and EltSize are the; // same.; // For patterns with gaps (i.e. non unit stride), we are; // accessing EltSize bytes at every Step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:226,Security,access,accessing,226,"// Compute the total access size for access patterns with unit stride and; // patterns with gaps. For patterns with unit stride, Step and EltSize are the; // same.; // For patterns with gaps (i.e. non unit stride), we are; // accessing EltSize bytes at every Step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:60,Security,access,access,60,"// For the moment, restrict ourselves to the case where the access size is a; // multiple of the requested alignment and the base is aligned.; // TODO: generalize if a case found which warrants",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:25,Performance,load,load,25,"/// Check if executing a load of this pointer value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do; /// a quick local scan of the basic block containing \c ScanFrom, to determine; /// if the address is already accessed.; ///; /// This uses the pointee type to determine how many bytes need to be safe to; /// load from the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:120,Performance,perform,performs,120,"/// Check if executing a load of this pointer value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do; /// a quick local scan of the basic block containing \c ScanFrom, to determine; /// if the address is already accessed.; ///; /// This uses the pointee type to determine how many bytes need to be safe to; /// load from the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:195,Performance,load,load,195,"/// Check if executing a load of this pointer value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do; /// a quick local scan of the basic block containing \c ScanFrom, to determine; /// if the address is already accessed.; ///; /// This uses the pointee type to determine how many bytes need to be safe to; /// load from the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:270,Performance,load,load,270,"/// Check if executing a load of this pointer value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do; /// a quick local scan of the basic block containing \c ScanFrom, to determine; /// if the address is already accessed.; ///; /// This uses the pointee type to determine how many bytes need to be safe to; /// load from the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:519,Performance,load,load,519,"/// Check if executing a load of this pointer value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do; /// a quick local scan of the basic block containing \c ScanFrom, to determine; /// if the address is already accessed.; ///; /// This uses the pointee type to determine how many bytes need to be safe to; /// load from the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:187,Safety,safe,safe,187,"/// Check if executing a load of this pointer value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do; /// a quick local scan of the basic block containing \c ScanFrom, to determine; /// if the address is already accessed.; ///; /// This uses the pointee type to determine how many bytes need to be safe to; /// load from the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:262,Safety,safe,safe,262,"/// Check if executing a load of this pointer value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do; /// a quick local scan of the basic block containing \c ScanFrom, to determine; /// if the address is already accessed.; ///; /// This uses the pointee type to determine how many bytes need to be safe to; /// load from the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:506,Safety,safe,safe,506,"/// Check if executing a load of this pointer value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do; /// a quick local scan of the basic block containing \c ScanFrom, to determine; /// if the address is already accessed.; ///; /// This uses the pointee type to determine how many bytes need to be safe to; /// load from the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:420,Security,access,accessed,420,"/// Check if executing a load of this pointer value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do; /// a quick local scan of the basic block containing \c ScanFrom, to determine; /// if the address is already accessed.; ///; /// This uses the pointee type to determine how many bytes need to be safe to; /// load from the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:135,Performance,load,loaded,135,"// Otherwise, be a little bit aggressive by scanning the local block where we; // want to check to see if the pointer is already being loaded or stored; // from/to. If so, the previous load or store would have already trapped,; // so there is no harm doing an extra load (also, CSE will later eliminate; // the load entirely).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:185,Performance,load,load,185,"// Otherwise, be a little bit aggressive by scanning the local block where we; // want to check to see if the pointer is already being loaded or stored; // from/to. If so, the previous load or store would have already trapped,; // so there is no harm doing an extra load (also, CSE will later eliminate; // the load entirely).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:266,Performance,load,load,266,"// Otherwise, be a little bit aggressive by scanning the local block where we; // want to check to see if the pointer is already being loaded or stored; // from/to. If so, the previous load or store would have already trapped,; // so there is no harm doing an extra load (also, CSE will later eliminate; // the load entirely).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:311,Performance,load,load,311,"// Otherwise, be a little bit aggressive by scanning the local block where we; // want to check to see if the pointer is already being loaded or stored; // from/to. If so, the previous load or store would have already trapped,; // so there is no harm doing an extra load (also, CSE will later eliminate; // the load entirely).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:19,Performance,load,loads,19,"// Ignore volatile loads. The execution of a volatile load cannot; // be used to prove an address is backed by regular memory; it can,; // for example, point to an MMIO register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:54,Performance,load,load,54,"// Ignore volatile loads. The execution of a volatile load cannot; // be used to prove an address is backed by regular memory; it can,; // for example, point to an MMIO register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:43,Performance,load,loads,43,// Ignore volatile stores (see comment for loads).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:252,Availability,redundant,redundant,252,"/// DefMaxInstsToScan - the default number of maximum instructions; /// to scan in the block, used by FindAvailableLoadedValue().; /// FindAvailableLoadedValue() was introduced in r60148, to improve jump; /// threading in part by eliminating partially redundant loads.; /// At that point, the value of MaxInstsToScan was already set to '6'; /// without documented explanation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:262,Performance,load,loads,262,"/// DefMaxInstsToScan - the default number of maximum instructions; /// to scan in the block, used by FindAvailableLoadedValue().; /// FindAvailableLoadedValue() was introduced in r60148, to improve jump; /// threading in part by eliminating partially redundant loads.; /// At that point, the value of MaxInstsToScan was already set to '6'; /// without documented explanation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:252,Safety,redund,redundant,252,"/// DefMaxInstsToScan - the default number of maximum instructions; /// to scan in the block, used by FindAvailableLoadedValue().; /// FindAvailableLoadedValue() was introduced in r60148, to improve jump; /// threading in part by eliminating partially redundant loads.; /// At that point, the value of MaxInstsToScan was already set to '6'; /// without documented explanation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:13,Performance,load,load,13,// Don't CSE load that is volatile or anything stronger than unordered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:16,Performance,load,load,16,"// Check if the load and the store have the same base, constant offsets and; // non-overlapping access ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:96,Security,access,access,96,"// Check if the load and the store have the same base, constant offsets and; // non-overlapping access ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:49,Availability,avail,available,49,"// If this is a load of Ptr, the loaded value is available.; // (This is true even if the load is volatile or atomic, although; // those cases are unlikely.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:16,Performance,load,load,16,"// If this is a load of Ptr, the loaded value is available.; // (This is true even if the load is volatile or atomic, although; // those cases are unlikely.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:33,Performance,load,loaded,33,"// If this is a load of Ptr, the loaded value is available.; // (This is true even if the load is volatile or atomic, although; // those cases are unlikely.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:90,Performance,load,load,90,"// If this is a load of Ptr, the loaded value is available.; // (This is true even if the load is volatile or atomic, although; // those cases are unlikely.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:48,Availability,avail,available,48,"// If this is a store through Ptr, the value is available!; // (This is true even if the store is volatile or atomic, although; // those cases are unlikely.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:52,Performance,load,load,52,// Don't forward from (non-atomic) memset to atomic load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:51,Testability,test,test,51,// Restore ScanFrom to expected value in case next test succeeds,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:17,Availability,avail,available,17,"// When AA isn't available, but if the load and the store have the same; // base, constant offsets and non-overlapping access ranges, ignore the; // store. This is a simple form of alias analysis that is used by the; // inliner. FIXME: use BasicAA if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:39,Performance,load,load,39,"// When AA isn't available, but if the load and the store have the same; // base, constant offsets and non-overlapping access ranges, ignore the; // store. This is a simple form of alias analysis that is used by the; // inliner. FIXME: use BasicAA if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:119,Security,access,access,119,"// When AA isn't available, but if the load and the store have the same; // base, constant offsets and non-overlapping access ranges, ignore the; // store. This is a simple form of alias analysis that is used by the; // inliner. FIXME: use BasicAA if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:166,Usability,simpl,simple,166,"// When AA isn't available, but if the load and the store have the same; // base, constant offsets and non-overlapping access ranges, ignore the; // store. This is a simple form of alias analysis that is used by the; // inliner. FIXME: use BasicAA if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:72,Performance,load,loaded,72,"// If we have alias analysis and it says the store won't modify the; // loaded value, ignore the store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:60,Performance,load,load,60,"// If alias analysis claims that it really won't modify the load,; // ignore it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:18,Availability,avail,available,18,"// Try to find an available value first, and delay expensive alias analysis; // queries until later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:18,Availability,avail,available,18,"// If we found an available value, ensure that the instructions in between; // did not modify the memory location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Local.cpp:32,Performance,perform,perform,32,"//===- Local.cpp - Functions to perform local transformations -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform various local transformations to the; // program.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Local.cpp:408,Performance,perform,perform,408,"//===- Local.cpp - Functions to perform local transformations -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform various local transformations to the; // program.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:422,Integrability,depend,dependence,422,"//===- LoopAccessAnalysis.cpp - Loop Access Analysis Implementation --------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The implementation for the loop memory dependence that was originally; // developed for the loop vectorizer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:37,Security,Access,Access,37,"//===- LoopAccessAnalysis.cpp - Loop Access Analysis Implementation --------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The implementation for the loop memory dependence that was originally; // developed for the loop vectorizer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:15,Integrability,depend,dependences,15,/// We collect dependences up to this threshold.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:80,Security,access,accesses,80,/// This enables versioning on the strides of symbolically striding memory; /// accesses in code like the following.; /// for (i = 0; i < N; ++i); /// A[i * Stride1] += B[i * Stride2] ...; ///; /// Will be roughly translated to; /// if (Stride1 == 1 && Stride2 == 1) {; /// for (i = 0; i < N; i+=4); /// A[i:i+3] += ...; /// } else; /// ...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:20,Performance,load,load,20,/// Enable store-to-load forwarding conflict detection. This option can; /// be disabled for correctness testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:45,Safety,detect,detection,45,/// Enable store-to-load forwarding conflict detection. This option can; /// be disabled for correctness testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:105,Testability,test,testing,105,/// Enable store-to-load forwarding conflict detection. This option can; /// be disabled for correctness testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:14,Testability,assert,assert,14,// Note: This assert is both overly strong and overly weak. The actual; // invariant here is that StrideSCEV should be loop invariant. The only; // such invariant strides we happen to speculate right now are unknowns; // and thus this is a reasonable proxy of the actual invariant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:45,Security,access,access,45,"/// Calculate Start and End points of memory access.; /// Let's assume A is the first access and B is a memory access on N-th loop; /// iteration. Then B is calculated as:; /// B = A + Step*N .; /// Step value may be positive or negative.; /// N is a calculated back-edge taken count:; /// N = (TripCount > 0) ? RoundDown(TripCount -1 , VF) : 0; /// Start and End points are calculated in the following way:; /// Start = UMIN(A, B) ; End = UMAX(A, B) + SizeOfElt,; /// where SizeOfElt is the size of single memory access in bytes.; ///; /// There is no conflict when the intervals are disjoint:; /// NoConflict = (P2.Start >= P1.End) || (P1.Start >= P2.End)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:86,Security,access,access,86,"/// Calculate Start and End points of memory access.; /// Let's assume A is the first access and B is a memory access on N-th loop; /// iteration. Then B is calculated as:; /// B = A + Step*N .; /// Step value may be positive or negative.; /// N is a calculated back-edge taken count:; /// N = (TripCount > 0) ? RoundDown(TripCount -1 , VF) : 0; /// Start and End points are calculated in the following way:; /// Start = UMIN(A, B) ; End = UMAX(A, B) + SizeOfElt,; /// where SizeOfElt is the size of single memory access in bytes.; ///; /// There is no conflict when the intervals are disjoint:; /// NoConflict = (P2.Start >= P1.End) || (P1.Start >= P2.End)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:111,Security,access,access,111,"/// Calculate Start and End points of memory access.; /// Let's assume A is the first access and B is a memory access on N-th loop; /// iteration. Then B is calculated as:; /// B = A + Step*N .; /// Step value may be positive or negative.; /// N is a calculated back-edge taken count:; /// N = (TripCount > 0) ? RoundDown(TripCount -1 , VF) : 0; /// Start and End points are calculated in the following way:; /// Start = UMIN(A, B) ; End = UMAX(A, B) + SizeOfElt,; /// where SizeOfElt is the size of single memory access in bytes.; ///; /// There is no conflict when the intervals are disjoint:; /// NoConflict = (P2.Start >= P1.End) || (P1.Start >= P2.End)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:514,Security,access,access,514,"/// Calculate Start and End points of memory access.; /// Let's assume A is the first access and B is a memory access on N-th loop; /// iteration. Then B is calculated as:; /// B = A + Step*N .; /// Step value may be positive or negative.; /// N is a calculated back-edge taken count:; /// N = (TripCount > 0) ? RoundDown(TripCount -1 , VF) : 0; /// Start and End points are calculated in the following way:; /// Start = UMIN(A, B) ; End = UMAX(A, B) + SizeOfElt,; /// where SizeOfElt is the size of single memory access in bytes.; ///; /// There is no conflict when the intervals are disjoint:; /// NoConflict = (P2.Start >= P1.End) || (P1.Start >= P2.End)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:148,Integrability,depend,depending,148,"// If either group contains multiple different pointers, bail out.; // TODO: Support multiple pointers by using the minimum or maximum pointer,; // depending on src & sink.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:24,Security,access,accessed,24,"// If either pointer is accessed multiple times, there may not be a clear; // src/sink relation. Bail out for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:68,Usability,clear,clear,68,"// If either pointer is accessed multiple times, there may not be a clear; // src/sink relation. Bail out for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:18,Security,access,accessed,18,"// If the sink is accessed before src, swap src/sink.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:139,Modifiability,extend,extended,139,// Only matching constant steps matching the AllocSize are supported at the; // moment. This simplifies the difference computation. Can be extended in the; // future.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:93,Usability,simpl,simplifies,93,// Only matching constant steps matching the AllocSize are supported at the; // moment. This simplifies the difference computation. Can be extended in the; // future.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:17,Availability,down,down,17,"// When counting down, the dependence distance needs to be swapped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:27,Integrability,depend,dependence,27,"// When counting down, the dependence distance needs to be swapped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:116,Safety,avoid,avoid,116,"// If the start values for both Src and Sink also vary according to an outer; // loop, then it's probably better to avoid creating diff checks because; // they may not be hoisted. We should instead let llvm::addRuntimeChecks; // do the expanded full range overlap checks, which can be hoisted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:3,Deployability,Update,Update,3,// Update the low bound expression if we've found a new min value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:3,Deployability,Update,Update,3,// Update the high bound expression if we've found a new max value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:767,Deployability,update,update,767,"// We build the groups from dependency candidates equivalence classes; // because:; // - We know that pointers in the same equivalence class share; // the same underlying object and therefore there is a chance; // that we can compare pointers; // - We wouldn't be able to merge two pointers for which we need; // to emit a memcheck. The classes in DepCands are already; // conveniently built such that no two pointers in the same; // class need checking against each other.; // We use the following (greedy) algorithm to construct the groups; // For every pointer in the equivalence class:; // For each existing group:; // - if the difference between this pointer and the min/max bounds; // of the group is a constant, then make the pointer part of the; // group and update the min/max bounds of that group as required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:28,Integrability,depend,dependency,28,"// We build the groups from dependency candidates equivalence classes; // because:; // - We know that pointers in the same equivalence class share; // the same underlying object and therefore there is a chance; // that we can compare pointers; // - We wouldn't be able to merge two pointers for which we need; // to emit a memcheck. The classes in DepCands are already; // conveniently built such that no two pointers in the same; // class need checking against each other.; // We use the following (greedy) algorithm to construct the groups; // For every pointer in the equivalence class:; // For each existing group:; // - if the difference between this pointer and the min/max bounds; // of the group is a constant, then make the pointer part of the; // group and update the min/max bounds of that group as required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:560,Integrability,depend,dependence,560,"// If we need to check two pointers to the same underlying object; // with a non-constant difference, we shouldn't perform any pointer; // grouping with those pointers. This is because we can easily get; // into cases where the resulting check would return false, even when; // the accesses are safe.; //; // The following example shows this:; // for (i = 0; i < 1000; ++i); // a[5000 + i * m] = a[i] + a[i + 9000]; //; // Here grouping gives a check of (5000, 5000 + 1000 * m) against; // (0, 10000) which is always false. However, if m is 1, there is no; // dependence. Not grouping the checks for a[i] and a[i + 9000] allows; // us to perform an accurate check in this case.; //; // The above case requires that we have an UnknownDependence between; // accesses to the same underlying object. This cannot happen unless; // FoundNonConstantDistanceDependence is set, and therefore UseDependencies; // is also false. In this case we will use the fallback path and create; // separate checking groups for all pointers.; // If we don't have the dependency partitions, construct a new; // checking pointer group for each pointer. This is also required; // for correctness, because in this case we can have checking between; // pointers to the same underlying object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:1044,Integrability,depend,dependency,1044,"// If we need to check two pointers to the same underlying object; // with a non-constant difference, we shouldn't perform any pointer; // grouping with those pointers. This is because we can easily get; // into cases where the resulting check would return false, even when; // the accesses are safe.; //; // The following example shows this:; // for (i = 0; i < 1000; ++i); // a[5000 + i * m] = a[i] + a[i + 9000]; //; // Here grouping gives a check of (5000, 5000 + 1000 * m) against; // (0, 10000) which is always false. However, if m is 1, there is no; // dependence. Not grouping the checks for a[i] and a[i + 9000] allows; // us to perform an accurate check in this case.; //; // The above case requires that we have an UnknownDependence between; // accesses to the same underlying object. This cannot happen unless; // FoundNonConstantDistanceDependence is set, and therefore UseDependencies; // is also false. In this case we will use the fallback path and create; // separate checking groups for all pointers.; // If we don't have the dependency partitions, construct a new; // checking pointer group for each pointer. This is also required; // for correctness, because in this case we can have checking between; // pointers to the same underlying object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:115,Performance,perform,perform,115,"// If we need to check two pointers to the same underlying object; // with a non-constant difference, we shouldn't perform any pointer; // grouping with those pointers. This is because we can easily get; // into cases where the resulting check would return false, even when; // the accesses are safe.; //; // The following example shows this:; // for (i = 0; i < 1000; ++i); // a[5000 + i * m] = a[i] + a[i + 9000]; //; // Here grouping gives a check of (5000, 5000 + 1000 * m) against; // (0, 10000) which is always false. However, if m is 1, there is no; // dependence. Not grouping the checks for a[i] and a[i + 9000] allows; // us to perform an accurate check in this case.; //; // The above case requires that we have an UnknownDependence between; // accesses to the same underlying object. This cannot happen unless; // FoundNonConstantDistanceDependence is set, and therefore UseDependencies; // is also false. In this case we will use the fallback path and create; // separate checking groups for all pointers.; // If we don't have the dependency partitions, construct a new; // checking pointer group for each pointer. This is also required; // for correctness, because in this case we can have checking between; // pointers to the same underlying object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:638,Performance,perform,perform,638,"// If we need to check two pointers to the same underlying object; // with a non-constant difference, we shouldn't perform any pointer; // grouping with those pointers. This is because we can easily get; // into cases where the resulting check would return false, even when; // the accesses are safe.; //; // The following example shows this:; // for (i = 0; i < 1000; ++i); // a[5000 + i * m] = a[i] + a[i + 9000]; //; // Here grouping gives a check of (5000, 5000 + 1000 * m) against; // (0, 10000) which is always false. However, if m is 1, there is no; // dependence. Not grouping the checks for a[i] and a[i + 9000] allows; // us to perform an accurate check in this case.; //; // The above case requires that we have an UnknownDependence between; // accesses to the same underlying object. This cannot happen unless; // FoundNonConstantDistanceDependence is set, and therefore UseDependencies; // is also false. In this case we will use the fallback path and create; // separate checking groups for all pointers.; // If we don't have the dependency partitions, construct a new; // checking pointer group for each pointer. This is also required; // for correctness, because in this case we can have checking between; // pointers to the same underlying object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:295,Safety,safe,safe,295,"// If we need to check two pointers to the same underlying object; // with a non-constant difference, we shouldn't perform any pointer; // grouping with those pointers. This is because we can easily get; // into cases where the resulting check would return false, even when; // the accesses are safe.; //; // The following example shows this:; // for (i = 0; i < 1000; ++i); // a[5000 + i * m] = a[i] + a[i + 9000]; //; // Here grouping gives a check of (5000, 5000 + 1000 * m) against; // (0, 10000) which is always false. However, if m is 1, there is no; // dependence. Not grouping the checks for a[i] and a[i + 9000] allows; // us to perform an accurate check in this case.; //; // The above case requires that we have an UnknownDependence between; // accesses to the same underlying object. This cannot happen unless; // FoundNonConstantDistanceDependence is set, and therefore UseDependencies; // is also false. In this case we will use the fallback path and create; // separate checking groups for all pointers.; // If we don't have the dependency partitions, construct a new; // checking pointer group for each pointer. This is also required; // for correctness, because in this case we can have checking between; // pointers to the same underlying object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:282,Security,access,accesses,282,"// If we need to check two pointers to the same underlying object; // with a non-constant difference, we shouldn't perform any pointer; // grouping with those pointers. This is because we can easily get; // into cases where the resulting check would return false, even when; // the accesses are safe.; //; // The following example shows this:; // for (i = 0; i < 1000; ++i); // a[5000 + i * m] = a[i] + a[i + 9000]; //; // Here grouping gives a check of (5000, 5000 + 1000 * m) against; // (0, 10000) which is always false. However, if m is 1, there is no; // dependence. Not grouping the checks for a[i] and a[i + 9000] allows; // us to perform an accurate check in this case.; //; // The above case requires that we have an UnknownDependence between; // accesses to the same underlying object. This cannot happen unless; // FoundNonConstantDistanceDependence is set, and therefore UseDependencies; // is also false. In this case we will use the fallback path and create; // separate checking groups for all pointers.; // If we don't have the dependency partitions, construct a new; // checking pointer group for each pointer. This is also required; // for correctness, because in this case we can have checking between; // pointers to the same underlying object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:756,Security,access,accesses,756,"// If we need to check two pointers to the same underlying object; // with a non-constant difference, we shouldn't perform any pointer; // grouping with those pointers. This is because we can easily get; // into cases where the resulting check would return false, even when; // the accesses are safe.; //; // The following example shows this:; // for (i = 0; i < 1000; ++i); // a[5000 + i * m] = a[i] + a[i + 9000]; //; // Here grouping gives a check of (5000, 5000 + 1000 * m) against; // (0, 10000) which is always false. However, if m is 1, there is no; // dependence. Not grouping the checks for a[i] and a[i + 9000] allows; // us to perform an accurate check in this case.; //; // The above case requires that we have an UnknownDependence between; // accesses to the same underlying object. This cannot happen unless; // FoundNonConstantDistanceDependence is set, and therefore UseDependencies; // is also false. In this case we will use the fallback path and create; // separate checking groups for all pointers.; // If we don't have the dependency partitions, construct a new; // checking pointer group for each pointer. This is also required; // for correctness, because in this case we can have checking between; // pointers to the same underlying object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:138,Security,access,accesses,138,"// Go through all equivalence classes, get the ""pointer check groups""; // and add them to the overall solution. We use the order in which accesses; // appear in 'Pointers' to enforce determinism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:204,Integrability,depend,dependent,204,"// Because DepCands is constructed by visiting accesses in the order in; // which they appear in alias sets (which is deterministic) and the; // iteration order within an equivalence class member is only dependent on; // the order in which unions and insertions are performed on the; // equivalence class, the iteration order is deterministic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:266,Performance,perform,performed,266,"// Because DepCands is constructed by visiting accesses in the order in; // which they appear in alias sets (which is deterministic) and the; // iteration order within an equivalence class member is only dependent on; // the order in which unions and insertions are performed on the; // equivalence class, the iteration order is deterministic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:47,Security,access,accesses,47,"// Because DepCands is constructed by visiting accesses in the order in; // which they appear in alias sets (which is deterministic) and the; // iteration order within an equivalence class member is only dependent on; // the order in which unions and insertions are performed on the; // equivalence class, the iteration order is deterministic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:9,Performance,perform,perform,9,"// Don't perform more than a certain amount of comparisons.; // This should limit the cost of grouping the pointers to something; // reasonable. If we do end up hitting this threshold, the algorithm; // will create separate groups for all remaining pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:53,Integrability,depend,dependency,53,// Only need to check pointers between two different dependency sets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:130,Integrability,depend,dependence,130,/// Analyses memory accesses in a loop.; ///; /// Checks whether run time pointer checks are needed and builds sets for data; /// dependence checking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:20,Security,access,accesses,20,/// Analyses memory accesses in a loop.; ///; /// Checks whether run time pointer checks are needed and builds sets for data; /// dependence checking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:18,Security,access,access,18,/// Read or write access location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:19,Integrability,depend,dependences,19,// We're analyzing dependences across loop iterations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:15,Performance,load,load,15,/// Register a load and whether it is only read from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:202,Integrability,depend,dependence,202,"/// Check if we can emit a run-time no-alias check for \p Access.; ///; /// Returns true if we can emit a run-time no alias check for \p Access.; /// If we can check this access, this also adds it to a dependence set and; /// adds a run-time to check for it to \p RtCheck. If \p Assume is true,; /// we will attempt to use additional run-time checks in order to get; /// the bounds of the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:58,Security,Access,Access,58,"/// Check if we can emit a run-time no-alias check for \p Access.; ///; /// Returns true if we can emit a run-time no alias check for \p Access.; /// If we can check this access, this also adds it to a dependence set and; /// adds a run-time to check for it to \p RtCheck. If \p Assume is true,; /// we will attempt to use additional run-time checks in order to get; /// the bounds of the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:137,Security,Access,Access,137,"/// Check if we can emit a run-time no-alias check for \p Access.; ///; /// Returns true if we can emit a run-time no alias check for \p Access.; /// If we can check this access, this also adds it to a dependence set and; /// adds a run-time to check for it to \p RtCheck. If \p Assume is true,; /// we will attempt to use additional run-time checks in order to get; /// the bounds of the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:171,Security,access,access,171,"/// Check if we can emit a run-time no-alias check for \p Access.; ///; /// Returns true if we can emit a run-time no alias check for \p Access.; /// If we can check this access, this also adds it to a dependence set and; /// adds a run-time to check for it to \p RtCheck. If \p Assume is true,; /// we will attempt to use additional run-time checks in order to get; /// the bounds of the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:95,Integrability,depend,dependent,95,"/// Goes over all memory accesses, checks whether a RT check is needed; /// and builds sets of dependent accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:25,Security,access,accesses,25,"/// Goes over all memory accesses, checks whether a RT check is needed; /// and builds sets of dependent accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:105,Security,access,accesses,105,"/// Goes over all memory accesses, checks whether a RT check is needed; /// and builds sets of dependent accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:82,Integrability,depend,dependency,82,/// Initial processing of memory accesses determined that we need to; /// perform dependency checking.; ///; /// Note that this can later be cleared if we retry memcheck analysis without; /// dependency checking (i.e. FoundNonConstantDistanceDependence).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:192,Integrability,depend,dependency,192,/// Initial processing of memory accesses determined that we need to; /// perform dependency checking.; ///; /// Note that this can later be cleared if we retry memcheck analysis without; /// dependency checking (i.e. FoundNonConstantDistanceDependence).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:74,Performance,perform,perform,74,/// Initial processing of memory accesses determined that we need to; /// perform dependency checking.; ///; /// Note that this can later be cleared if we retry memcheck analysis without; /// dependency checking (i.e. FoundNonConstantDistanceDependence).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:33,Security,access,accesses,33,/// Initial processing of memory accesses determined that we need to; /// perform dependency checking.; ///; /// Note that this can later be cleared if we retry memcheck analysis without; /// dependency checking (i.e. FoundNonConstantDistanceDependence).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:141,Usability,clear,cleared,141,/// Initial processing of memory accesses determined that we need to; /// perform dependency checking.; ///; /// Note that this can later be cleared if we retry memcheck analysis without; /// dependency checking (i.e. FoundNonConstantDistanceDependence).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:23,Integrability,depend,dependence,23,/// We decided that no dependence analysis would be used. Reset the state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:52,Security,access,accesses,52,"/// Adjust the MemoryLocation so that it represents accesses to this; /// location across all iterations, rather than a single one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:7,Security,access,accessed,7,"// The accessed location varies within the loop, but remains within the; // underlying object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:19,Usability,simpl,simplicity,19,"// For the sake of simplicity, drop the whole scope list if any scope is; // iteration-local.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:105,Integrability,depend,dependency,105,/// Go over all memory access and check whether runtime pointer checks; /// are needed and build sets of dependency check candidates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:23,Security,access,access,23,/// Go over all memory access and check whether runtime pointer checks; /// are needed and build sets of dependency check candidates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:15,Security,access,accesses,15,/// Map of all accesses. Values are the types used to access memory pointed to; /// by the pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:54,Security,access,access,54,/// Map of all accesses. Values are the types used to access memory pointed to; /// by the pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:41,Integrability,depend,dependence,41,/// List of accesses that need a further dependence check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:12,Security,access,accesses,12,/// List of accesses that need a further dependence check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:42,Security,access,access,42,/// An alias set tracker to partition the access set by underlying object and; //intrinsic property (such as TBAA metadata).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:24,Integrability,depend,dependent,24,"/// Sets of potentially dependent accesses - members of one set share an; /// underlying pointer. The set ""CheckDeps"" identfies which sets really need a; /// dependence check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:158,Integrability,depend,dependence,158,"/// Sets of potentially dependent accesses - members of one set share an; /// underlying pointer. The set ""CheckDeps"" identfies which sets really need a; /// dependence check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:34,Security,access,accesses,34,"/// Sets of potentially dependent accesses - members of one set share an; /// underlying pointer. The set ""CheckDeps"" identfies which sets really need a; /// dependence check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:263,Integrability,depend,dependency,263,"/// Initial processing of memory accesses determined that we may need; /// to add memchecks. Perform the analysis to determine the necessary checks.; ///; /// Note that, this is different from isDependencyCheckNeeded. When we retry; /// memcheck analysis without dependency checking; /// (i.e. FoundNonConstantDistanceDependence), isDependencyCheckNeeded is; /// cleared while this remains set if we have potentially dependent accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:417,Integrability,depend,dependent,417,"/// Initial processing of memory accesses determined that we may need; /// to add memchecks. Perform the analysis to determine the necessary checks.; ///; /// Note that, this is different from isDependencyCheckNeeded. When we retry; /// memcheck analysis without dependency checking; /// (i.e. FoundNonConstantDistanceDependence), isDependencyCheckNeeded is; /// cleared while this remains set if we have potentially dependent accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:93,Performance,Perform,Perform,93,"/// Initial processing of memory accesses determined that we may need; /// to add memchecks. Perform the analysis to determine the necessary checks.; ///; /// Note that, this is different from isDependencyCheckNeeded. When we retry; /// memcheck analysis without dependency checking; /// (i.e. FoundNonConstantDistanceDependence), isDependencyCheckNeeded is; /// cleared while this remains set if we have potentially dependent accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:33,Security,access,accesses,33,"/// Initial processing of memory accesses determined that we may need; /// to add memchecks. Perform the analysis to determine the necessary checks.; ///; /// Note that, this is different from isDependencyCheckNeeded. When we retry; /// memcheck analysis without dependency checking; /// (i.e. FoundNonConstantDistanceDependence), isDependencyCheckNeeded is; /// cleared while this remains set if we have potentially dependent accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:427,Security,access,accesses,427,"/// Initial processing of memory accesses determined that we may need; /// to add memchecks. Perform the analysis to determine the necessary checks.; ///; /// Note that, this is different from isDependencyCheckNeeded. When we retry; /// memcheck analysis without dependency checking; /// (i.e. FoundNonConstantDistanceDependence), isDependencyCheckNeeded is; /// cleared while this remains set if we have potentially dependent accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:363,Usability,clear,cleared,363,"/// Initial processing of memory accesses determined that we may need; /// to add memchecks. Perform the analysis to determine the necessary checks.; ///; /// Note that, this is different from isDependencyCheckNeeded. When we retry; /// memcheck analysis without dependency checking; /// (i.e. FoundNonConstantDistanceDependence), isDependencyCheckNeeded is; /// cleared while this remains set if we have potentially dependent accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:43,Integrability,wrap,wrap,43,/// Check whether a pointer address cannot wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:112,Security,access,accesses,112,// SCEV does not look through non-header PHIs inside the loop. Such phis; // can be analyzed by adding separate accesses for each incoming pointer; // value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:357,Integrability,depend,depends,357,"// Walk back through the IR for a pointer, looking for a select like the; // following:; //; // %offset = select i1 %cmp, i64 %a, i64 %b; // %addr = getelementptr double, double* %base, i64 %offset; // %ld = load double, double* %addr, align 8; //; // We won't be able to form a single SCEVAddRecExpr from this since the; // address for each loop iteration depends on %cmp. We could potentially; // produce multiple valid SCEVAddRecExprs, though, and check all of them for; // memory safety/aliasing if needed.; //; // If we encounter some IR we don't yet handle, or something obviously fine; // like a constant, then we just add the SCEV for that term to the list passed; // in by the caller. If we have a node that may potentially yield a valid; // SCEVAddRecExpr then we decompose it into parts and build the SCEV terms; // ourselves before adding to the list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:208,Performance,load,load,208,"// Walk back through the IR for a pointer, looking for a select like the; // following:; //; // %offset = select i1 %cmp, i64 %a, i64 %b; // %addr = getelementptr double, double* %base, i64 %offset; // %ld = load double, double* %addr, align 8; //; // We won't be able to form a single SCEVAddRecExpr from this since the; // address for each loop iteration depends on %cmp. We could potentially; // produce multiple valid SCEVAddRecExprs, though, and check all of them for; // memory safety/aliasing if needed.; //; // If we encounter some IR we don't yet handle, or something obviously fine; // like a constant, then we just add the SCEV for that term to the list passed; // in by the caller. If we have a node that may potentially yield a valid; // SCEVAddRecExpr then we decompose it into parts and build the SCEV terms; // ourselves before adding to the list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:484,Safety,safe,safety,484,"// Walk back through the IR for a pointer, looking for a select like the; // following:; //; // %offset = select i1 %cmp, i64 %a, i64 %b; // %addr = getelementptr double, double* %base, i64 %offset; // %ld = load double, double* %addr, align 8; //; // We won't be able to form a single SCEVAddRecExpr from this since the; // address for each loop iteration depends on %cmp. We could potentially; // produce multiple valid SCEVAddRecExprs, though, and check all of them for; // memory safety/aliasing if needed.; //; // If we encounter some IR we don't yet handle, or something obviously fine; // like a constant, then we just add the SCEV for that term to the list passed; // in by the caller. If we have a node that may potentially yield a valid; // SCEVAddRecExpr then we decompose it into parts and build the SCEV terms; // ourselves before adding to the list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:36,Modifiability,extend,extend,36,// Find the pointer type we need to extend to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:31,Integrability,depend,dependency,31,// When we run after a failing dependency check we have to make sure; // we don't have wrapping pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:87,Integrability,wrap,wrapping,87,// When we run after a failing dependency check we have to make sure; // we don't have wrapping pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:8,Integrability,wrap,wrap,8,// Skip wrap checking when translating pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:67,Integrability,wrap,wrap,67,"// If there's only one option for Ptr, look it up after bounds and wrap; // checking, because assumptions might have been added to PSE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:17,Integrability,depend,dependence,17,// The id of the dependence set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:27,Integrability,depend,dependence,27,// Each access has its own dependence set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:8,Security,access,access,8,// Each access has its own dependence set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:33,Security,access,access,33,// We assign a consecutive id to access from different alias sets.; // Accesses between different groups doesn't need to be checked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:71,Security,Access,Accesses,71,// We assign a consecutive id to access from different alias sets.; // Accesses between different groups doesn't need to be checked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:53,Integrability,depend,dependence,53,// We assign consecutive id to access from different dependence sets.; // Accesses within the same set don't need a runtime check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:31,Security,access,access,31,// We assign consecutive id to access from different dependence sets.; // Accesses within the same set don't need a runtime check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:74,Security,Access,Accesses,74,// We assign consecutive id to access from different dependence sets.; // Accesses within the same set don't need a runtime check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:40,Security,access,accesses,40,"// First, count how many write and read accesses are in the alias set. Also; // collect MemAccessInfos for later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:353,Integrability,depend,dependence,353,"// Note that this function computes CanDoRT and MayNeedRTCheck; // independently. For example CanDoRT=false, MayNeedRTCheck=false means that; // we have a pointer for which we couldn't find the bounds but we don't; // actually need to emit any checks so it does not matter.; //; // We need runtime checks for this alias set, if there are at least 2; // dependence sets (in which case RunningDepId > 2) or if we need to re-try; // any bound checks (because in that case the number of dependence sets is; // incomplete).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:483,Integrability,depend,dependence,483,"// Note that this function computes CanDoRT and MayNeedRTCheck; // independently. For example CanDoRT=false, MayNeedRTCheck=false means that; // we have a pointer for which we couldn't find the bounds but we don't; // actually need to emit any checks so it does not matter.; //; // We need runtime checks for this alias set, if there are at least 2; // dependence sets (in which case RunningDepId > 2) or if we need to re-try; // any bound checks (because in that case the number of dependence sets is; // incomplete).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:14,Performance,perform,perform,14,"// We need to perform run-time alias checks, but some pointers had bounds; // that couldn't be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:43,Security,access,accesses,43,"// Reset the CanDoSetRt flag and retry all accesses that have failed.; // We know that we need these checks, so we can now be more aggressive; // and add further checks if required (overflow checks).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:53,Integrability,depend,dependency,53,// Only need to check pointers between two different dependency sets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:130,Integrability,depend,dependence,130,"// We process the set twice: first we process read-write pointers, last we; // process read-only pointers. This allows us to skip dependence tests for; // read-only pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:141,Testability,test,tests,141,"// We process the set twice: first we process read-write pointers, last we; // process read-only pointers. This allows us to skip dependence tests for; // read-only pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:195,Integrability,depend,dependencies,195,"// The AliasSetTracker has nicely partitioned our pointers by metadata; // compatibility and potential for underlying-object overlap. As a result, we; // only need to check for potential pointer dependencies within each alias; // set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:27,Security,access,access,27,// Map of pointers to last access encountered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:10,Security,access,access,10,// Set of access to check after all writes have been processed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:23,Security,access,access,23,"// For a single memory access in AliasSetTracker, Accesses may contain; // both read and write, and they both need to be handled for CheckDeps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:50,Security,Access,Accesses,50,"// For a single memory access in AliasSetTracker, Accesses may contain; // both read and write, and they both need to be handled for CheckDeps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:31,Security,access,access,31,"// If we're using the deferred access set, then it contains only; // reads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:259,Integrability,depend,dependence,259,"// If this is a write - check other reads and writes for conflicts. If; // this is a read only check other writes for conflicts (but only if; // there is no other write to the ptr - this is an optimization to; // catch ""a[i] = a[i] + "" without having to do a dependence check).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:193,Performance,optimiz,optimization,193,"// If this is a write - check other reads and writes for conflicts. If; // this is a read only check other writes for conflicts (but only if; // there is no other write to the ptr - this is an optimization to; // catch ""a[i] = a[i] + "" without having to do a dependence check).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:60,Integrability,wrap,wrapping,60,"/// Return true if an AddRec pointer \p Ptr is unsigned non-wrapping,; /// i.e. monotonically increasing/decreasing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:47,Integrability,wrap,wrapping,47,// Scalar evolution does not propagate the non-wrapping flags to values that; // are derived from a non-wrapping induction variable because non-wrapping; // could be flow-sensitive.; //; // Look through the potentially overflowing instruction to try to prove; // non-wrapping for the *specific* value of Ptr.; // The arithmetic implied by an inbounds GEP can't overflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:104,Integrability,wrap,wrapping,104,// Scalar evolution does not propagate the non-wrapping flags to values that; // are derived from a non-wrapping induction variable because non-wrapping; // could be flow-sensitive.; //; // Look through the potentially overflowing instruction to try to prove; // non-wrapping for the *specific* value of Ptr.; // The arithmetic implied by an inbounds GEP can't overflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:144,Integrability,wrap,wrapping,144,// Scalar evolution does not propagate the non-wrapping flags to values that; // are derived from a non-wrapping induction variable because non-wrapping; // could be flow-sensitive.; //; // Look through the potentially overflowing instruction to try to prove; // non-wrapping for the *specific* value of Ptr.; // The arithmetic implied by an inbounds GEP can't overflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:267,Integrability,wrap,wrapping,267,// Scalar evolution does not propagate the non-wrapping flags to values that; // are derived from a non-wrapping induction variable because non-wrapping; // could be flow-sensitive.; //; // Look through the potentially overflowing instruction to try to prove; // non-wrapping for the *specific* value of Ptr.; // The arithmetic implied by an inbounds GEP can't overflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:123,Modifiability,variab,variable,123,// Scalar evolution does not propagate the non-wrapping flags to values that; // are derived from a non-wrapping induction variable because non-wrapping; // could be flow-sensitive.; //; // Look through the potentially overflowing instruction to try to prove; // non-wrapping for the *specific* value of Ptr.; // The arithmetic implied by an inbounds GEP can't overflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:41,Integrability,wrap,wrapping,41,// The index in GEP is signed. It is non-wrapping if it's derived from a NSW; // AddRec using a NSW operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:22,Security,access,access,22,/// Check whether the access through \p Ptr has a constant stride.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:7,Security,access,access,7,// The access function must stride over the innermost loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:11,Security,access,access,11,// Strided access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:36,Integrability,wrap,wrap,36,"// The address calculation must not wrap. Otherwise, a dependence could be; // inverted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:55,Integrability,depend,dependence,55,"// The address calculation must not wrap. Otherwise, a dependence could be; // inverted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:76,Integrability,wrap,wrap,76,"// An inbounds getelementptr that is a AddRec with a unit stride; // cannot wrap per definition. If it did, the result would be poison; // and any memory access dependent on it would be immediate UB; // when executed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:161,Integrability,depend,dependent,161,"// An inbounds getelementptr that is a AddRec with a unit stride; // cannot wrap per definition. If it did, the result would be poison; // and any memory access dependent on it would be immediate UB; // when executed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:154,Security,access,access,154,"// An inbounds getelementptr that is a AddRec with a unit stride; // cannot wrap per definition. If it did, the result would be poison; // and any memory access dependent on it would be immediate UB; // when executed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:127,Integrability,wrap,wrap,127,"// If the null pointer is undefined, then a access sequence which would; // otherwise access it can be assumed not to unsigned wrap. Note that this; // assumes the object in memory is aligned to the natural alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:44,Security,access,access,44,"// If the null pointer is undefined, then a access sequence which would; // otherwise access it can be assumed not to unsigned wrap. Note that this; // assumes the object in memory is aligned to the natural alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:86,Security,access,access,86,"// If the null pointer is undefined, then a access sequence which would; // otherwise access it can be assumed not to unsigned wrap. Note that this; // assumes the object in memory is aligned to the natural alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:143,Integrability,depend,dependences,143,// If loads occur at a distance that is not a multiple of a feasible vector; // factor store-load forwarding does not take place.; // Positive dependences might cause troubles because vectorizing them might; // prevent store-load forwarding making vectorized code run a lot slower.; // a[i] = a[i-3] ^ a[i-8];; // The stores to a[i:i+1] don't align with the stores to a[i-3:i-2] and; // hence on your typical architecture store-load forwarding does not take; // place. Vectorizing in such cases does not make sense.; // Store-load forwarding distance.; // After this many iterations store-to-load forwarding conflicts should not; // cause any slowdowns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:6,Performance,load,loads,6,// If loads occur at a distance that is not a multiple of a feasible vector; // factor store-load forwarding does not take place.; // Positive dependences might cause troubles because vectorizing them might; // prevent store-load forwarding making vectorized code run a lot slower.; // a[i] = a[i-3] ^ a[i-8];; // The stores to a[i:i+1] don't align with the stores to a[i-3:i-2] and; // hence on your typical architecture store-load forwarding does not take; // place. Vectorizing in such cases does not make sense.; // Store-load forwarding distance.; // After this many iterations store-to-load forwarding conflicts should not; // cause any slowdowns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:93,Performance,load,load,93,// If loads occur at a distance that is not a multiple of a feasible vector; // factor store-load forwarding does not take place.; // Positive dependences might cause troubles because vectorizing them might; // prevent store-load forwarding making vectorized code run a lot slower.; // a[i] = a[i-3] ^ a[i-8];; // The stores to a[i:i+1] don't align with the stores to a[i-3:i-2] and; // hence on your typical architecture store-load forwarding does not take; // place. Vectorizing in such cases does not make sense.; // Store-load forwarding distance.; // After this many iterations store-to-load forwarding conflicts should not; // cause any slowdowns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:225,Performance,load,load,225,// If loads occur at a distance that is not a multiple of a feasible vector; // factor store-load forwarding does not take place.; // Positive dependences might cause troubles because vectorizing them might; // prevent store-load forwarding making vectorized code run a lot slower.; // a[i] = a[i-3] ^ a[i-8];; // The stores to a[i:i+1] don't align with the stores to a[i-3:i-2] and; // hence on your typical architecture store-load forwarding does not take; // place. Vectorizing in such cases does not make sense.; // Store-load forwarding distance.; // After this many iterations store-to-load forwarding conflicts should not; // cause any slowdowns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:428,Performance,load,load,428,// If loads occur at a distance that is not a multiple of a feasible vector; // factor store-load forwarding does not take place.; // Positive dependences might cause troubles because vectorizing them might; // prevent store-load forwarding making vectorized code run a lot slower.; // a[i] = a[i-3] ^ a[i-8];; // The stores to a[i:i+1] don't align with the stores to a[i-3:i-2] and; // hence on your typical architecture store-load forwarding does not take; // place. Vectorizing in such cases does not make sense.; // Store-load forwarding distance.; // After this many iterations store-to-load forwarding conflicts should not; // cause any slowdowns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:526,Performance,load,load,526,// If loads occur at a distance that is not a multiple of a feasible vector; // factor store-load forwarding does not take place.; // Positive dependences might cause troubles because vectorizing them might; // prevent store-load forwarding making vectorized code run a lot slower.; // a[i] = a[i-3] ^ a[i-8];; // The stores to a[i:i+1] don't align with the stores to a[i-3:i-2] and; // hence on your typical architecture store-load forwarding does not take; // place. Vectorizing in such cases does not make sense.; // Store-load forwarding distance.; // After this many iterations store-to-load forwarding conflicts should not; // cause any slowdowns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:592,Performance,load,load,592,// If loads occur at a distance that is not a multiple of a feasible vector; // factor store-load forwarding does not take place.; // Positive dependences might cause troubles because vectorizing them might; // prevent store-load forwarding making vectorized code run a lot slower.; // a[i] = a[i-3] ^ a[i-8];; // The stores to a[i:i+1] don't align with the stores to a[i-3:i-2] and; // hence on your typical architecture store-load forwarding does not take; // place. Vectorizing in such cases does not make sense.; // Store-load forwarding distance.; // After this many iterations store-to-load forwarding conflicts should not; // cause any slowdowns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:50,Performance,load,load,50,// Compute the smallest VF at which the store and load would be misaligned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:63,Performance,load,load,63,// If the number of vector iteration between the store and the load are; // small we could incur conflicts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:12,Integrability,depend,dependence-distance,12,"/// Given a dependence-distance \p Dist between two; /// memory accesses, that have the same stride whose absolute value is given; /// in \p Stride, and that have the same type size \p TypeByteSize,; /// in a loop whose takenCount is \p BackedgeTakenCount, check if it is; /// possible to prove statically that the dependence distance is larger; /// than the range that the accesses will travel through the execution of; /// the loop. If so, return true; false otherwise. This is useful for; /// example in loops such as the following (PR31098):; /// for (i = 0; i < D; ++i) {; /// = out[i];; /// out[i+D] =; /// }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:315,Integrability,depend,dependence,315,"/// Given a dependence-distance \p Dist between two; /// memory accesses, that have the same stride whose absolute value is given; /// in \p Stride, and that have the same type size \p TypeByteSize,; /// in a loop whose takenCount is \p BackedgeTakenCount, check if it is; /// possible to prove statically that the dependence distance is larger; /// than the range that the accesses will travel through the execution of; /// the loop. If so, return true; false otherwise. This is useful for; /// example in loops such as the following (PR31098):; /// for (i = 0; i < D; ++i) {; /// = out[i];; /// out[i+D] =; /// }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:64,Security,access,accesses,64,"/// Given a dependence-distance \p Dist between two; /// memory accesses, that have the same stride whose absolute value is given; /// in \p Stride, and that have the same type size \p TypeByteSize,; /// in a loop whose takenCount is \p BackedgeTakenCount, check if it is; /// possible to prove statically that the dependence distance is larger; /// than the range that the accesses will travel through the execution of; /// the loop. If so, return true; false otherwise. This is useful for; /// example in loops such as the following (PR31098):; /// for (i = 0; i < D; ++i) {; /// = out[i];; /// out[i+D] =; /// }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:374,Security,access,accesses,374,"/// Given a dependence-distance \p Dist between two; /// memory accesses, that have the same stride whose absolute value is given; /// in \p Stride, and that have the same type size \p TypeByteSize,; /// in a loop whose takenCount is \p BackedgeTakenCount, check if it is; /// possible to prove statically that the dependence distance is larger; /// than the range that the accesses will travel through the execution of; /// the loop. If so, return true; false otherwise. This is useful for; /// example in loops such as the following (PR31098):; /// for (i = 0; i < D; ++i) {; /// = out[i];; /// out[i+D] =; /// }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:160,Integrability,depend,dependence,160,"// If we can prove that; // (**) |Dist| > BackedgeTakenCount * Step; // where Step is the absolute stride of the memory accesses in bytes,; // then there is no dependence.; //; // Rationale:; // We basically want to check if the absolute distance (|Dist/Step|); // is >= the loop iteration count (or > BackedgeTakenCount).; // This is equivalent to the Strong SIV Test (Practical Dependence Testing,; // Section 4.2.1); Note, that for vectorization it is sufficient to prove; // that the dependence distance is >= VF; This is checked elsewhere.; // But in some cases we can prune dependence distances early, and; // even before selecting the VF, and without a runtime test, by comparing; // the distance against the loop iteration count. Since the vectorized code; // will be executed only if LoopCount >= VF, proving distance >= LoopCount; // also guarantees that distance >= VF.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:380,Integrability,Depend,Dependence,380,"// If we can prove that; // (**) |Dist| > BackedgeTakenCount * Step; // where Step is the absolute stride of the memory accesses in bytes,; // then there is no dependence.; //; // Rationale:; // We basically want to check if the absolute distance (|Dist/Step|); // is >= the loop iteration count (or > BackedgeTakenCount).; // This is equivalent to the Strong SIV Test (Practical Dependence Testing,; // Section 4.2.1); Note, that for vectorization it is sufficient to prove; // that the dependence distance is >= VF; This is checked elsewhere.; // But in some cases we can prune dependence distances early, and; // even before selecting the VF, and without a runtime test, by comparing; // the distance against the loop iteration count. Since the vectorized code; // will be executed only if LoopCount >= VF, proving distance >= LoopCount; // also guarantees that distance >= VF.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:488,Integrability,depend,dependence,488,"// If we can prove that; // (**) |Dist| > BackedgeTakenCount * Step; // where Step is the absolute stride of the memory accesses in bytes,; // then there is no dependence.; //; // Rationale:; // We basically want to check if the absolute distance (|Dist/Step|); // is >= the loop iteration count (or > BackedgeTakenCount).; // This is equivalent to the Strong SIV Test (Practical Dependence Testing,; // Section 4.2.1); Note, that for vectorization it is sufficient to prove; // that the dependence distance is >= VF; This is checked elsewhere.; // But in some cases we can prune dependence distances early, and; // even before selecting the VF, and without a runtime test, by comparing; // the distance against the loop iteration count. Since the vectorized code; // will be executed only if LoopCount >= VF, proving distance >= LoopCount; // also guarantees that distance >= VF.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:580,Integrability,depend,dependence,580,"// If we can prove that; // (**) |Dist| > BackedgeTakenCount * Step; // where Step is the absolute stride of the memory accesses in bytes,; // then there is no dependence.; //; // Rationale:; // We basically want to check if the absolute distance (|Dist/Step|); // is >= the loop iteration count (or > BackedgeTakenCount).; // This is equivalent to the Strong SIV Test (Practical Dependence Testing,; // Section 4.2.1); Note, that for vectorization it is sufficient to prove; // that the dependence distance is >= VF; This is checked elsewhere.; // But in some cases we can prune dependence distances early, and; // even before selecting the VF, and without a runtime test, by comparing; // the distance against the loop iteration count. Since the vectorized code; // will be executed only if LoopCount >= VF, proving distance >= LoopCount; // also guarantees that distance >= VF.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:120,Security,access,accesses,120,"// If we can prove that; // (**) |Dist| > BackedgeTakenCount * Step; // where Step is the absolute stride of the memory accesses in bytes,; // then there is no dependence.; //; // Rationale:; // We basically want to check if the absolute distance (|Dist/Step|); // is >= the loop iteration count (or > BackedgeTakenCount).; // This is equivalent to the Strong SIV Test (Practical Dependence Testing,; // Section 4.2.1); Note, that for vectorization it is sufficient to prove; // that the dependence distance is >= VF; This is checked elsewhere.; // But in some cases we can prune dependence distances early, and; // even before selecting the VF, and without a runtime test, by comparing; // the distance against the loop iteration count. Since the vectorized code; // will be executed only if LoopCount >= VF, proving distance >= LoopCount; // also guarantees that distance >= VF.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:364,Testability,Test,Test,364,"// If we can prove that; // (**) |Dist| > BackedgeTakenCount * Step; // where Step is the absolute stride of the memory accesses in bytes,; // then there is no dependence.; //; // Rationale:; // We basically want to check if the absolute distance (|Dist/Step|); // is >= the loop iteration count (or > BackedgeTakenCount).; // This is equivalent to the Strong SIV Test (Practical Dependence Testing,; // Section 4.2.1); Note, that for vectorization it is sufficient to prove; // that the dependence distance is >= VF; This is checked elsewhere.; // But in some cases we can prune dependence distances early, and; // even before selecting the VF, and without a runtime test, by comparing; // the distance against the loop iteration count. Since the vectorized code; // will be executed only if LoopCount >= VF, proving distance >= LoopCount; // also guarantees that distance >= VF.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:391,Testability,Test,Testing,391,"// If we can prove that; // (**) |Dist| > BackedgeTakenCount * Step; // where Step is the absolute stride of the memory accesses in bytes,; // then there is no dependence.; //; // Rationale:; // We basically want to check if the absolute distance (|Dist/Step|); // is >= the loop iteration count (or > BackedgeTakenCount).; // This is equivalent to the Strong SIV Test (Practical Dependence Testing,; // Section 4.2.1); Note, that for vectorization it is sufficient to prove; // that the dependence distance is >= VF; This is checked elsewhere.; // But in some cases we can prune dependence distances early, and; // even before selecting the VF, and without a runtime test, by comparing; // the distance against the loop iteration count. Since the vectorized code; // will be executed only if LoopCount >= VF, proving distance >= LoopCount; // also guarantees that distance >= VF.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:668,Testability,test,test,668,"// If we can prove that; // (**) |Dist| > BackedgeTakenCount * Step; // where Step is the absolute stride of the memory accesses in bytes,; // then there is no dependence.; //; // Rationale:; // We basically want to check if the absolute distance (|Dist/Step|); // is >= the loop iteration count (or > BackedgeTakenCount).; // This is equivalent to the Strong SIV Test (Practical Dependence Testing,; // Section 4.2.1); Note, that for vectorization it is sufficient to prove; // that the dependence distance is >= VF; This is checked elsewhere.; // But in some cases we can prune dependence distances early, and; // even before selecting the VF, and without a runtime test, by comparing; // the distance against the loop iteration count. Since the vectorized code; // will be executed only if LoopCount >= VF, proving distance >= LoopCount; // also guarantees that distance >= VF.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:7,Integrability,depend,dependence,7,"// The dependence distance can be positive/negative, so we sign extend Dist;; // The multiplication of the absolute stride in bytes and the; // backedgeTakenCount is non-negative, so we zero extend Product.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:64,Modifiability,extend,extend,64,"// The dependence distance can be positive/negative, so we sign extend Dist;; // The multiplication of the absolute stride in bytes and the; // backedgeTakenCount is non-negative, so we zero extend Product.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:191,Modifiability,extend,extend,191,"// The dependence distance can be positive/negative, so we sign extend Dist;; // The multiplication of the absolute stride in bytes and the; // backedgeTakenCount is non-negative, so we zero extend Product.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:14,Integrability,depend,dependence,14,/// Check the dependence for two accesses with the same stride \p Stride.; /// \p Distance is the positive distance and \p TypeByteSize is type size in; /// bytes.; ///; /// \returns true if they are independent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:33,Security,access,accesses,33,/// Check the dependence for two accesses with the same stride \p Stride.; /// \p Distance is the positive distance and \p TypeByteSize is type size in; /// bytes.; ///; /// \returns true if they are independent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:6,Integrability,depend,dependence,6,"// No dependence if the scaled distance is not multiple of the stride.; // E.g.; // for (i = 0; i < 1024 ; i += 4); // A[i+2] = A[i] + 1;; //; // Two accesses in memory (scaled distance is 2, stride is 4):; // | A[0] | | | | A[4] | | | |; // | | | A[2] | | | | A[6] | |; //; // E.g.; // for (i = 0; i < 1024 ; i += 3); // A[i+4] = A[i] + 1;; //; // Two accesses in memory (scaled distance is 4, stride is 3):; // | A[0] | | | A[3] | | | A[6] | | |; // | | | | | A[4] | | | A[7] | |",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:150,Security,access,accesses,150,"// No dependence if the scaled distance is not multiple of the stride.; // E.g.; // for (i = 0; i < 1024 ; i += 4); // A[i+2] = A[i] + 1;; //; // Two accesses in memory (scaled distance is 2, stride is 4):; // | A[0] | | | | A[4] | | | |; // | | | A[2] | | | | A[6] | |; //; // E.g.; // for (i = 0; i < 1024 ; i += 3); // A[i+4] = A[i] + 1;; //; // Two accesses in memory (scaled distance is 4, stride is 3):; // | A[0] | | | A[3] | | | A[6] | | |; // | | | | | A[4] | | | A[7] | |",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:353,Security,access,accesses,353,"// No dependence if the scaled distance is not multiple of the stride.; // E.g.; // for (i = 0; i < 1024 ; i += 4); // A[i+2] = A[i] + 1;; //; // Two accesses in memory (scaled distance is 2, stride is 4):; // | A[0] | | | | A[4] | | | |; // | | | A[2] | | | | A[6] | |; //; // E.g.; // for (i = 0; i < 1024 ; i += 3); // A[i+4] = A[i] + 1;; //; // Two accesses in memory (scaled distance is 4, stride is 3):; // | A[0] | | | A[3] | | | A[6] | | |; // | | | | | A[4] | | | A[7] | |",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:276,Deployability,A/B,A/BPtr,276,"// Get the dependence distance, stride, type size in whether i is a write for; // the dependence between A and B. Returns a DepType, if we can prove there's; // no dependence or the analysis fails. Outlined to lambda to limit he scope; // of various temporary variables, like A/BPtr, StrideA/BPtr and others.; // Returns either the dependence result, if it could already be determined, or a; // tuple with (Distance, Stride, TypeSize, AIsWrite, BIsWrite).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:11,Integrability,depend,dependence,11,"// Get the dependence distance, stride, type size in whether i is a write for; // the dependence between A and B. Returns a DepType, if we can prove there's; // no dependence or the analysis fails. Outlined to lambda to limit he scope; // of various temporary variables, like A/BPtr, StrideA/BPtr and others.; // Returns either the dependence result, if it could already be determined, or a; // tuple with (Distance, Stride, TypeSize, AIsWrite, BIsWrite).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:86,Integrability,depend,dependence,86,"// Get the dependence distance, stride, type size in whether i is a write for; // the dependence between A and B. Returns a DepType, if we can prove there's; // no dependence or the analysis fails. Outlined to lambda to limit he scope; // of various temporary variables, like A/BPtr, StrideA/BPtr and others.; // Returns either the dependence result, if it could already be determined, or a; // tuple with (Distance, Stride, TypeSize, AIsWrite, BIsWrite).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:164,Integrability,depend,dependence,164,"// Get the dependence distance, stride, type size in whether i is a write for; // the dependence between A and B. Returns a DepType, if we can prove there's; // no dependence or the analysis fails. Outlined to lambda to limit he scope; // of various temporary variables, like A/BPtr, StrideA/BPtr and others.; // Returns either the dependence result, if it could already be determined, or a; // tuple with (Distance, Stride, TypeSize, AIsWrite, BIsWrite).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:332,Integrability,depend,dependence,332,"// Get the dependence distance, stride, type size in whether i is a write for; // the dependence between A and B. Returns a DepType, if we can prove there's; // no dependence or the analysis fails. Outlined to lambda to limit he scope; // of various temporary variables, like A/BPtr, StrideA/BPtr and others.; // Returns either the dependence result, if it could already be determined, or a; // tuple with (Distance, Stride, TypeSize, AIsWrite, BIsWrite).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:260,Modifiability,variab,variables,260,"// Get the dependence distance, stride, type size in whether i is a write for; // the dependence between A and B. Returns a DepType, if we can prove there's; // no dependence or the analysis fails. Outlined to lambda to limit he scope; // of various temporary variables, like A/BPtr, StrideA/BPtr and others.; // Returns either the dependence result, if it could already be determined, or a; // tuple with (Distance, Stride, TypeSize, AIsWrite, BIsWrite).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:82,Integrability,depend,dependence,82,"// If the induction step is negative we have to invert source and sink of the; // dependence when measuring the distance between them. We should not swap; // AIsWrite with BIsWrite, as their uses expect them in program order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:9,Security,access,accesses,9,// Needs accesses where the addresses of the accessed underlying objects do; // not change within the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:45,Security,access,accessed,45,// Needs accesses where the addresses of the accessed underlying objects do; // not change within the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:137,Integrability,wrap,wrap,137,"// Need accesses with constant stride. We don't want to vectorize; // ""A[B[i]] += ..."" and similar code or pointer arithmetic that could wrap; // in the address space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:8,Security,access,accesses,8,"// Need accesses with constant stride. We don't want to vectorize; // ""A[B[i]] += ..."" and similar code or pointer arithmetic that could wrap; // in the address space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:11,Integrability,depend,dependence,11,"// Get the dependence distance, stride, type size and what access writes for; // the dependence between A and B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:85,Integrability,depend,dependence,85,"// Get the dependence distance, stride, type size and what access writes for; // the dependence between A and B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:59,Security,access,access,59,"// Get the dependence distance, stride, type size and what access writes for; // the dependence between A and B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:28,Security,access,accesses,28,// Attempt to prove strided accesses independent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:40,Integrability,depend,dependencies,40,// Negative distances are not plausible dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:23,Deployability,update,update,23,"// There is no need to update MaxSafeVectorWidthInBits after call to; // couldPreventStoreLoadForward, even if it changed MinDepDistBytes,; // since a forward dependency will allow vectorization using any width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:159,Integrability,depend,dependency,159,"// There is no need to update MaxSafeVectorWidthInBits after call to; // couldPreventStoreLoadForward, even if it changed MinDepDistBytes,; // since a forward dependency will allow vectorization using any width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:1103,Safety,safe,safe,1103,"// It's not vectorizable if the distance is smaller than the minimum distance; // needed for a vectroized/unrolled version. Vectorizing one iteration in; // front needs TypeByteSize * Stride. Vectorizing the last iteration needs; // TypeByteSize (No need to plus the last gap distance).; //; // E.g. Assume one char is 1 byte in memory and one int is 4 bytes.; // foo(int *A) {; // int *B = (int *)((char *)A + 14);; // for (i = 0 ; i < 1024 ; i += 2); // B[i] = A[i] + 1;; // }; //; // Two accesses in memory (stride is 2):; // | A[0] | | A[2] | | A[4] | | A[6] | |; // | B[0] | | B[2] | | B[4] |; //; // Distance needs for vectorizing iterations except the last iteration:; // 4 * 2 * (MinNumIter - 1). Distance needs for the last iteration: 4.; // So the minimum distance needed is: 4 * 2 * (MinNumIter - 1) + 4.; //; // If MinNumIter is 2, it is vectorizable as the minimum distance needed is; // 12, which is less than distance.; //; // If MinNumIter is 4 (Say if a user forces the vectorization factor to be 4),; // the minimum distance needed is 28, which is greater than distance. It is; // not safe to do vectorization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:491,Security,access,accesses,491,"// It's not vectorizable if the distance is smaller than the minimum distance; // needed for a vectroized/unrolled version. Vectorizing one iteration in; // front needs TypeByteSize * Stride. Vectorizing the last iteration needs; // TypeByteSize (No need to plus the last gap distance).; //; // E.g. Assume one char is 1 byte in memory and one int is 4 bytes.; // foo(int *A) {; // int *B = (int *)((char *)A + 14);; // for (i = 0 ; i < 1024 ; i += 2); // B[i] = A[i] + 1;; // }; //; // Two accesses in memory (stride is 2):; // | A[0] | | A[2] | | A[4] | | A[6] | |; // | B[0] | | B[2] | | B[4] |; //; // Distance needs for vectorizing iterations except the last iteration:; // 4 * 2 * (MinNumIter - 1). Distance needs for the last iteration: 4.; // So the minimum distance needed is: 4 * 2 * (MinNumIter - 1) + 4.; //; // If MinNumIter is 2, it is vectorizable as the minimum distance needed is; // 12, which is less than distance.; //; // If MinNumIter is 4 (Say if a user forces the vectorization factor to be 4),; // the minimum distance needed is 28, which is greater than distance. It is; // not safe to do vectorization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:66,Integrability,depend,dependence,66,// Unsafe if the minimum distance needed is greater than smallest dependence; // distance distance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:3,Safety,Unsafe,Unsafe,3,// Unsafe if the minimum distance needed is greater than smallest dependence; // distance distance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:506,Integrability,depend,dependence,506,"// Positive distance bigger than max vectorization factor.; // FIXME: Should use max factor instead of max distance in bytes, which could; // not handle different types.; // E.g. Assume one char is 1 byte in memory and one int is 4 bytes.; // void foo (int *A, char *B) {; // for (unsigned i = 0; i < 1024; i++) {; // A[i+2] = A[i] + 1;; // B[i+2] = B[i] + 1;; // }; // }; //; // This case is currently unsafe according to the max safe distance. If we; // analyze the two accesses on array B, the max safe dependence distance; // is 2. Then we analyze the accesses on array A, the minimum distance needed; // is 8, which is less than 2 and forbidden vectorization, But actually; // both A and B could be vectorized by 2 iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:403,Safety,unsafe,unsafe,403,"// Positive distance bigger than max vectorization factor.; // FIXME: Should use max factor instead of max distance in bytes, which could; // not handle different types.; // E.g. Assume one char is 1 byte in memory and one int is 4 bytes.; // void foo (int *A, char *B) {; // for (unsigned i = 0; i < 1024; i++) {; // A[i+2] = A[i] + 1;; // B[i+2] = B[i] + 1;; // }; // }; //; // This case is currently unsafe according to the max safe distance. If we; // analyze the two accesses on array B, the max safe dependence distance; // is 2. Then we analyze the accesses on array A, the minimum distance needed; // is 8, which is less than 2 and forbidden vectorization, But actually; // both A and B could be vectorized by 2 iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:431,Safety,safe,safe,431,"// Positive distance bigger than max vectorization factor.; // FIXME: Should use max factor instead of max distance in bytes, which could; // not handle different types.; // E.g. Assume one char is 1 byte in memory and one int is 4 bytes.; // void foo (int *A, char *B) {; // for (unsigned i = 0; i < 1024; i++) {; // A[i+2] = A[i] + 1;; // B[i+2] = B[i] + 1;; // }; // }; //; // This case is currently unsafe according to the max safe distance. If we; // analyze the two accesses on array B, the max safe dependence distance; // is 2. Then we analyze the accesses on array A, the minimum distance needed; // is 8, which is less than 2 and forbidden vectorization, But actually; // both A and B could be vectorized by 2 iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:501,Safety,safe,safe,501,"// Positive distance bigger than max vectorization factor.; // FIXME: Should use max factor instead of max distance in bytes, which could; // not handle different types.; // E.g. Assume one char is 1 byte in memory and one int is 4 bytes.; // void foo (int *A, char *B) {; // for (unsigned i = 0; i < 1024; i++) {; // A[i+2] = A[i] + 1;; // B[i+2] = B[i] + 1;; // }; // }; //; // This case is currently unsafe according to the max safe distance. If we; // analyze the two accesses on array B, the max safe dependence distance; // is 2. Then we analyze the accesses on array A, the minimum distance needed; // is 8, which is less than 2 and forbidden vectorization, But actually; // both A and B could be vectorized by 2 iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:472,Security,access,accesses,472,"// Positive distance bigger than max vectorization factor.; // FIXME: Should use max factor instead of max distance in bytes, which could; // not handle different types.; // E.g. Assume one char is 1 byte in memory and one int is 4 bytes.; // void foo (int *A, char *B) {; // for (unsigned i = 0; i < 1024; i++) {; // A[i+2] = A[i] + 1;; // B[i+2] = B[i] + 1;; // }; // }; //; // This case is currently unsafe according to the max safe distance. If we; // analyze the two accesses on array B, the max safe dependence distance; // is 2. Then we analyze the accesses on array A, the minimum distance needed; // is 8, which is less than 2 and forbidden vectorization, But actually; // both A and B could be vectorized by 2 iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:556,Security,access,accesses,556,"// Positive distance bigger than max vectorization factor.; // FIXME: Should use max factor instead of max distance in bytes, which could; // not handle different types.; // E.g. Assume one char is 1 byte in memory and one int is 4 bytes.; // void foo (int *A, char *B) {; // for (unsigned i = 0; i < 1024; i++) {; // A[i+2] = A[i] + 1;; // B[i+2] = B[i] + 1;; // }; // }; //; // This case is currently unsafe according to the max safe distance. If we; // analyze the two accesses on array B, the max safe dependence distance; // is 2. Then we analyze the accesses on array A, the minimum distance needed; // is 8, which is less than 2 and forbidden vectorization, But actually; // both A and B could be vectorized by 2 iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:31,Deployability,update,update,31,// Sanity check that we didn't update MinDepDistBytes when calling; // couldPreventStoreLoadForward,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:3,Safety,Sanity check,Sanity check,3,// Sanity check that we didn't update MinDepDistBytes when calling; // couldPreventStoreLoadForward,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:6,Deployability,update,update,6,// An update to MinDepDistBytes requires an update to MaxSafeVectorWidthInBits; // since there is a backwards dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:44,Deployability,update,update,44,// An update to MinDepDistBytes requires an update to MaxSafeVectorWidthInBits; // since there is a backwards dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:110,Integrability,depend,dependency,110,// An update to MinDepDistBytes requires an update to MaxSafeVectorWidthInBits; // since there is a backwards dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:27,Security,access,access,27,// Get the relevant memory access set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:9,Security,access,accesses,9,// Check accesses within this set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:15,Security,access,access,15,// Check every access pair.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:9,Performance,load,loads,9,"// Check loads only against next equivalent class, but stores also against; // other stores in the same equivalence class - to the same address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:15,Security,access,accessing,15,// Check every accessing instruction pair in program order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:12,Security,access,accesses,12,"// Scan all accesses of another equivalence class, but only the next; // accesses of the same equivalent class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:73,Security,access,accesses,73,"// Scan all accesses of another equivalence class, but only the next; // accesses of the same equivalent class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:10,Integrability,depend,dependences,10,// Gather dependences unless we accumulated MaxDependences; // dependences. In that case return as soon as we find the first; // unsafe dependence. This puts a limit on this quadratic; // algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:63,Integrability,depend,dependences,63,// Gather dependences unless we accumulated MaxDependences; // dependences. In that case return as soon as we find the first; // unsafe dependence. This puts a limit on this quadratic; // algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:136,Integrability,depend,dependence,136,// Gather dependences unless we accumulated MaxDependences; // dependences. In that case return as soon as we find the first; // unsafe dependence. This puts a limit on this quadratic; // algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:129,Safety,unsafe,unsafe,129,// Gather dependences unless we accumulated MaxDependences; // dependences. In that case return as soon as we find the first; // unsafe dependence. This puts a limit on this quadratic; // algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:13,Performance,Load,Load,13,// Holds the Load and Store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:27,Security,access,accesses,27,// Holds all the different accesses in the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:33,Performance,load,loads,33,// Scan the BB and collect legal loads and stores. Also detect any; // convergent instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:56,Safety,detect,detect,56,// Scan the BB and collect legal loads and stores. Also detect any; // convergent instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:3,Safety,Avoid,Avoid,3,// Avoid hitting recordAnalysis multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:171,Safety,safe,safe,171,"// Many math library functions read the rounding mode. We will only; // vectorize a loop if it contains known function calls that don't set; // the flag. Therefore, it is safe to ignore this read from memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:16,Performance,load,load,16,"// If this is a load, save it. If this instruction can read from memory; // but is not a load, then we quit. Notice that we don't handle function; // calls that read or write.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:89,Performance,load,load,89,"// If this is a load, save it. If this instruction can read from memory; // but is not a load, then we quit. Notice that we don't handle function; // calls that read or write.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:66,Safety,safe,safely,66,"// If the function has an explicit vectorized counterpart, we can safely; // assume that it can be vectorized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:30,Safety,Abort,Abort,30,// Save 'store' instructions. Abort if other instructions write to memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:39,Performance,load,loads,39,"// Now we have two lists that hold the loads and the stores.; // Next, we find the pointers that they use.; // Check if we see any stores. If there are no stores, then we don't; // care if the pointers are *restrict*.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:128,Security,access,accessed,128,"// Holds the analyzed pointers. We don't want to call getUnderlyingObjects; // multiple times on the same object. If the ptr is accessed twice, once; // for read and once for write, it will only appear once (on the write; // list). This is okay, since we are going to check for conflicts between; // writes and between reads and writes, but not between reads and reads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:42,Integrability,depend,dependency,42,"// The TBAA metadata could have a control dependency on the predication; // condition, so we cannot rely on it when determining whether or not we; // need runtime pointer checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:29,Integrability,depend,dependency,29,// See if there is an unsafe dependency between a load to a uniform address and; // store to the same uniform address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:50,Performance,load,load,50,// See if there is an unsafe dependency between a load to a uniform address and; // store to the same uniform address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:22,Safety,unsafe,unsafe,22,// See if there is an unsafe dependency between a load to a uniform address and; // store to the same uniform address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:42,Integrability,depend,dependency,42,"// The TBAA metadata could have a control dependency on the predication; // condition, so we cannot rely on it when determining whether or not we; // need runtime pointer checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:112,Safety,safe,safe,112,// If we write (or read-write) to a single destination and there are no; // other reads in this loop then is it safe to vectorize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:9,Integrability,depend,dependence,9,// Build dependence sets and check whether we need a runtime pointer bounds; // check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:13,Integrability,depend,dependency,13,// Clear the dependency checks. We assume they are not needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:3,Usability,Clear,Clear,3,// Clear the dependency checks. We assume they are not needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:32,Integrability,depend,dependence,32,// Emit remark for first unsafe dependence,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:25,Safety,unsafe,unsafe,25,// Emit remark for first unsafe dependence,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:32,Security,access,access,32,"/// Get the stride of a pointer access in a loop. Looks for symbolic; /// strides ""a[i*stride]"". Returns the symbolic stride, or null otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:27,Security,access,access,27,// The size of the pointer access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:25,Security,access,access,25,// Strip off the size of access multiplication if we are still analyzing the; // pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:317,Security,expose,exposes,317,"// Note: getStrideFromPointer is a *profitability* heuristic. We; // could broaden the scope of values returned here - to anything; // which happens to be loop invariant and contributes to the; // computation of an interesting IV - but we chose not to as we; // don't have a cost model here, and broadening the scope exposes; // far too many unprofitable cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:768,Availability,avail,available,768,"// Avoid adding the ""Stride == 1"" predicate when we know that; // Stride >= Trip-Count. Such a predicate will effectively optimize a single; // or zero iteration loop, as Trip-Count <= Stride == 1.; //; // TODO: We are currently not making a very informed decision on when it is; // beneficial to apply stride versioning. It might make more sense that the; // users of this analysis (such as the vectorizer) will trigger it, based on; // their specific cost considerations; For example, in cases where stride; // versioning does not help resolving memory accesses/dependences, the; // vectorizer should evaluate the cost of the runtime test, and the benefit; // of various possible stride specializations, considering the alternatives; // of using gather/scatters (if available).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:564,Integrability,depend,dependences,564,"// Avoid adding the ""Stride == 1"" predicate when we know that; // Stride >= Trip-Count. Such a predicate will effectively optimize a single; // or zero iteration loop, as Trip-Count <= Stride == 1.; //; // TODO: We are currently not making a very informed decision on when it is; // beneficial to apply stride versioning. It might make more sense that the; // users of this analysis (such as the vectorizer) will trigger it, based on; // their specific cost considerations; For example, in cases where stride; // versioning does not help resolving memory accesses/dependences, the; // vectorizer should evaluate the cost of the runtime test, and the benefit; // of various possible stride specializations, considering the alternatives; // of using gather/scatters (if available).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:122,Performance,optimiz,optimize,122,"// Avoid adding the ""Stride == 1"" predicate when we know that; // Stride >= Trip-Count. Such a predicate will effectively optimize a single; // or zero iteration loop, as Trip-Count <= Stride == 1.; //; // TODO: We are currently not making a very informed decision on when it is; // beneficial to apply stride versioning. It might make more sense that the; // users of this analysis (such as the vectorizer) will trigger it, based on; // their specific cost considerations; For example, in cases where stride; // versioning does not help resolving memory accesses/dependences, the; // vectorizer should evaluate the cost of the runtime test, and the benefit; // of various possible stride specializations, considering the alternatives; // of using gather/scatters (if available).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:3,Safety,Avoid,Avoid,3,"// Avoid adding the ""Stride == 1"" predicate when we know that; // Stride >= Trip-Count. Such a predicate will effectively optimize a single; // or zero iteration loop, as Trip-Count <= Stride == 1.; //; // TODO: We are currently not making a very informed decision on when it is; // beneficial to apply stride versioning. It might make more sense that the; // users of this analysis (such as the vectorizer) will trigger it, based on; // their specific cost considerations; For example, in cases where stride; // versioning does not help resolving memory accesses/dependences, the; // vectorizer should evaluate the cost of the runtime test, and the benefit; // of various possible stride specializations, considering the alternatives; // of using gather/scatters (if available).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:555,Security,access,accesses,555,"// Avoid adding the ""Stride == 1"" predicate when we know that; // Stride >= Trip-Count. Such a predicate will effectively optimize a single; // or zero iteration loop, as Trip-Count <= Stride == 1.; //; // TODO: We are currently not making a very informed decision on when it is; // beneficial to apply stride versioning. It might make more sense that the; // users of this analysis (such as the vectorizer) will trigger it, based on; // their specific cost considerations; For example, in cases where stride; // versioning does not help resolving memory accesses/dependences, the; // vectorizer should evaluate the cost of the runtime test, and the benefit; // of various possible stride specializations, considering the alternatives; // of using gather/scatters (if available).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:636,Testability,test,test,636,"// Avoid adding the ""Stride == 1"" predicate when we know that; // Stride >= Trip-Count. Such a predicate will effectively optimize a single; // or zero iteration loop, as Trip-Count <= Stride == 1.; //; // TODO: We are currently not making a very informed decision on when it is; // beneficial to apply stride versioning. It might make more sense that the; // users of this analysis (such as the vectorizer) will trigger it, based on; // their specific cost considerations; For example, in cases where stride; // versioning does not help resolving memory accesses/dependences, the; // vectorizer should evaluate the cost of the runtime test, and the benefit; // of various possible stride specializations, considering the alternatives; // of using gather/scatters (if available).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:122,Modifiability,extend,extend,122,"// Match the types so we can compare the stride and the BETakenCount.; // The Stride can be positive/negative, so we sign extend Stride;; // The backedgeTakenCount is non-negative, so we zero extend BETakenCount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:192,Modifiability,extend,extend,192,"// Match the types so we can compare the stride and the BETakenCount.; // The Stride can be positive/negative, so we sign extend Stride;; // The backedgeTakenCount is non-negative, so we zero extend BETakenCount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:20,Security,access,accesses,20,// List the pair of accesses need run-time checks to prove independence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:33,Integrability,depend,depend,33,// Check whether the analyses we depend on became invalid for any reason.; // Skip checking TargetLibraryAnalysis as it is immutable and can't become; // invalid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:337,Integrability,depend,dependencies,337,"// If this proxy or the loop info is going to be invalidated, we also need; // to clear all the keys coming from that analysis. We also completely blow; // away the loop analyses if any of the standard analyses provided by the; // loop pass manager go away so that loop analyses can freely use these; // without worrying about declaring dependencies on them etc.; // FIXME: It isn't clear if this is the right tradeoff. We could instead make; // loop analyses declare any dependencies on these and use the more general; // invalidation logic below to act on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:472,Integrability,depend,dependencies,472,"// If this proxy or the loop info is going to be invalidated, we also need; // to clear all the keys coming from that analysis. We also completely blow; // away the loop analyses if any of the standard analyses provided by the; // loop pass manager go away so that loop analyses can freely use these; // without worrying about declaring dependencies on them etc.; // FIXME: It isn't clear if this is the right tradeoff. We could instead make; // loop analyses declare any dependencies on these and use the more general; // invalidation logic below to act on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:536,Testability,log,logic,536,"// If this proxy or the loop info is going to be invalidated, we also need; // to clear all the keys coming from that analysis. We also completely blow; // away the loop analyses if any of the standard analyses provided by the; // loop pass manager go away so that loop analyses can freely use these; // without worrying about declaring dependencies on them etc.; // FIXME: It isn't clear if this is the right tradeoff. We could instead make; // loop analyses declare any dependencies on these and use the more general; // invalidation logic below to act on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:82,Usability,clear,clear,82,"// If this proxy or the loop info is going to be invalidated, we also need; // to clear all the keys coming from that analysis. We also completely blow; // away the loop analyses if any of the standard analyses provided by the; // loop pass manager go away so that loop analyses can freely use these; // without worrying about declaring dependencies on them etc.; // FIXME: It isn't clear if this is the right tradeoff. We could instead make; // loop analyses declare any dependencies on these and use the more general; // invalidation logic below to act on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:383,Usability,clear,clear,383,"// If this proxy or the loop info is going to be invalidated, we also need; // to clear all the keys coming from that analysis. We also completely blow; // away the loop analyses if any of the standard analyses provided by the; // loop pass manager go away so that loop analyses can freely use these; // without worrying about declaring dependencies on them etc.; // FIXME: It isn't clear if this is the right tradeoff. We could instead make; // loop analyses declare any dependencies on these and use the more general; // invalidation logic below to act on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:166,Performance,cache,cache,166,"// Note that the LoopInfo may be stale at this point, however the loop; // objects themselves remain the only viable keys that could be in the; // analysis manager's cache. So we just walk the keys and forcibly clear; // those results. Note that the order doesn't matter here as this will just; // directly destroy the results without calling methods on them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:211,Usability,clear,clear,211,"// Note that the LoopInfo may be stale at this point, however the loop; // objects themselves remain the only viable keys that could be in the; // analysis manager's cache. So we just walk the keys and forcibly clear; // those results. Note that the order doesn't matter here as this will just; // directly destroy the results without calling methods on them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:175,Availability,reliab,reliably,175,// We also need to null out the inner AM so that when the object gets; // destroyed as invalid we don't try to clear the inner AM again. At that; // point we won't be able to reliably walk the loops for this function and; // only clear results associated with those loops the way we do here.; // FIXME: Making InnerAM null at this point isn't very nice. Most analyses; // try to remain valid during invalidation. Maybe we should add an; // `IsClean` flag?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:111,Usability,clear,clear,111,// We also need to null out the inner AM so that when the object gets; // destroyed as invalid we don't try to clear the inner AM again. At that; // point we won't be able to reliably walk the loops for this function and; // only clear results associated with those loops the way we do here.; // FIXME: Making InnerAM null at this point isn't very nice. Most analyses; // try to remain valid during invalidation. Maybe we should add an; // `IsClean` flag?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:230,Usability,clear,clear,230,// We also need to null out the inner AM so that when the object gets; // destroyed as invalid we don't try to clear the inner AM again. At that; // point we won't be able to reliably walk the loops for this function and; // only clear results associated with those loops the way we do here.; // FIXME: Making InnerAM null at this point isn't very nice. Most analyses; // try to remain valid during invalidation. Maybe we should add an; // `IsClean` flag?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:60,Performance,cache,cached,60,"// Since we have a valid LoopInfo we can actually leave the cached results in; // the analysis manager associated with the Loop keys, but we need to; // propagate any necessary invalidation logic into them. We'd like to; // invalidate things in roughly the same order as they were put into the; // cache and so we walk the preorder list in reverse to form a valid; // postorder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:298,Performance,cache,cache,298,"// Since we have a valid LoopInfo we can actually leave the cached results in; // the analysis manager associated with the Loop keys, but we need to; // propagate any necessary invalidation logic into them. We'd like to; // invalidate things in roughly the same order as they were put into the; // cache and so we walk the preorder list in reverse to form a valid; // postorder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:190,Testability,log,logic,190,"// Since we have a valid LoopInfo we can actually leave the cached results in; // the analysis manager associated with the Loop keys, but we need to; // propagate any necessary invalidation logic into them. We'd like to; // invalidate things in roughly the same order as they were put into the; // cache and so we walk the preorder list in reverse to form a valid; // postorder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:36,Performance,Cache,Cache,36,"//===- LoopCacheAnalysis.cpp - Loop Cache Analysis -------------------------==//; //; // The LLVM Compiler Infrastructure; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the implementation for the loop cache analysis.; /// The implementation is largely based on the following paper:; ///; /// Compiler Optimizations for Improving Data Locality; /// By: Steve Carr, Katherine S. McKinley, Chau-Wen Tseng; /// http://www.cs.utexas.edu/users/mckinley/papers/asplos-1994.pdf; ///; /// The general approach taken to estimate the number of cache lines used by the; /// memory references in an inner loop is:; /// 1. Partition memory references that exhibit temporal or spacial reuse; /// into reference groups.; /// 2. For each loop L in the a loop nest LN:; /// a. Compute the cost of the reference group; /// b. Compute the loop cost by summing up the reference groups costs; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:487,Performance,cache,cache,487,"//===- LoopCacheAnalysis.cpp - Loop Cache Analysis -------------------------==//; //; // The LLVM Compiler Infrastructure; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the implementation for the loop cache analysis.; /// The implementation is largely based on the following paper:; ///; /// Compiler Optimizations for Improving Data Locality; /// By: Steve Carr, Katherine S. McKinley, Chau-Wen Tseng; /// http://www.cs.utexas.edu/users/mckinley/papers/asplos-1994.pdf; ///; /// The general approach taken to estimate the number of cache lines used by the; /// memory references in an inner loop is:; /// 1. Partition memory references that exhibit temporal or spacial reuse; /// into reference groups.; /// 2. For each loop L in the a loop nest LN:; /// a. Compute the cost of the reference group; /// b. Compute the loop cost by summing up the reference groups costs; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:587,Performance,Optimiz,Optimizations,587,"//===- LoopCacheAnalysis.cpp - Loop Cache Analysis -------------------------==//; //; // The LLVM Compiler Infrastructure; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the implementation for the loop cache analysis.; /// The implementation is largely based on the following paper:; ///; /// Compiler Optimizations for Improving Data Locality; /// By: Steve Carr, Katherine S. McKinley, Chau-Wen Tseng; /// http://www.cs.utexas.edu/users/mckinley/papers/asplos-1994.pdf; ///; /// The general approach taken to estimate the number of cache lines used by the; /// memory references in an inner loop is:; /// 1. Partition memory references that exhibit temporal or spacial reuse; /// into reference groups.; /// 2. For each loop L in the a loop nest LN:; /// a. Compute the cost of the reference group; /// b. Compute the loop cost by summing up the reference groups costs; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:819,Performance,cache,cache,819,"//===- LoopCacheAnalysis.cpp - Loop Cache Analysis -------------------------==//; //; // The LLVM Compiler Infrastructure; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the implementation for the loop cache analysis.; /// The implementation is largely based on the following paper:; ///; /// Compiler Optimizations for Improving Data Locality; /// By: Steve Carr, Katherine S. McKinley, Chau-Wen Tseng; /// http://www.cs.utexas.edu/users/mckinley/papers/asplos-1994.pdf; ///; /// The general approach taken to estimate the number of cache lines used by the; /// memory references in an inner loop is:; /// 1. Partition memory references that exhibit temporal or spacial reuse; /// into reference groups.; /// 2. For each loop L in the a loop nest LN:; /// a. Compute the cost of the reference group; /// b. Compute the loop cost by summing up the reference groups costs; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:188,Modifiability,config,configurable,188,"// In this analysis two array references are considered to exhibit temporal; // reuse if they access either the same memory location, or a memory location; // with distance smaller than a configurable threshold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:94,Security,access,access,94,"// In this analysis two array references are considered to exhibit temporal; // reuse if they access either the same memory location, or a memory location; // with distance smaller than a configurable threshold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:68,Performance,cache,cache,68,// the difference between the last subscripts must be less than the cache line; // size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:13,Integrability,depend,dependence,13,// Check the dependence distance at every loop level. There is temporal reuse; // if the distance at the given loop's depth is small (|d| <= MaxDistance) and; // it is zero at every other loop level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:167,Security,access,accessing,167,"// If the indexed reference is not 'consecutive' the cost is proportional to; // the trip count and the depth of the dimension which the subject loop; // subscript is accessing. We try to estimate this by multiplying the cost; // by the trip counts of loops corresponding to the inner dimensions. For; // example, given the indexed reference 'A[i][j][k]', and assuming the; // i-loop is in the innermost position, the cost would be equal to the; // iterations of the i-loop multiplied by iterations of the j-loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:67,Security,access,access,67,// Attempt to determine whether we have a single dimensional array access.; // before giving up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:20,Security,access,accessed,20,"// The array may be accessed in reverse, for example:; // for (i = N; i > 0; i--); // A[i] = 0;; // In this case, reconstruct the access function using the absolute value; // of the step recurrence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:130,Security,access,access,130,"// The array may be accessed in reverse, for example:; // for (i = N; i > 0; i--); // A[i] = 0;; // In this case, reconstruct the access function using the absolute value; // of the step recurrence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:98,Modifiability,variab,variable,98,// The indexed reference is loop invariant if none of the coefficients use; // the loop induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:99,Modifiability,variab,variable,99,// The indexed reference is 'consecutive' if the only coefficient that uses; // the loop induction variable is the last one...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:45,Performance,cache,cache,45,// ...and the access stride is less than the cache line size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:14,Security,access,access,14,// ...and the access stride is less than the cache line size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:299,Modifiability,extend,extended,299,"// FIXME: This assumes that all values are signed integers which may; // be incorrect in unusual codes and incorrectly use sext instead of zext.; // for (uint32_t i = 0; i < 512; ++i) {; // uint8_t trunc = i;; // A[trunc] = 42;; // }; // This consecutively iterates twice over A. If `trunc` is sign-extended,; // we would conclude that this may iterate backwards over the array.; // However, LoopCacheAnalysis is heuristic anyway and transformations must; // not result in wrong optimizations if the heuristic was incorrect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:479,Performance,optimiz,optimizations,479,"// FIXME: This assumes that all values are signed integers which may; // be incorrect in unusual codes and incorrectly use sext instead of zext.; // for (uint32_t i = 0; i < 512; ++i) {; // uint8_t trunc = i;; // A[trunc] = 42;; // }; // This consecutively iterates twice over A. If `trunc` is sign-extended,; // we would conclude that this may iterate backwards over the array.; // However, LoopCacheAnalysis is heuristic anyway and transformations must; // not result in wrong optimizations if the heuristic was incorrect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:85,Performance,Cache,CacheCost,85,//===----------------------------------------------------------------------===//; // CacheCost implementation; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:351,Integrability,depend,depending,351,"// FIXME: Both positive and negative access functions will be placed; // into the same reference group, resulting in a bi-directional array; // access such as:; // for (i = N; i > 0; i--); // A[i] = A[N - i];; // having the same cost calculation as a single dimention access pattern; // for (i = 0; i < N; i++); // A[i] = A[i];; // when in actuality, depending on the array size, the first example; // should have a cost closer to 2x the second due to the two cache; // access per iteration from opposite ends of the array",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:460,Performance,cache,cache,460,"// FIXME: Both positive and negative access functions will be placed; // into the same reference group, resulting in a bi-directional array; // access such as:; // for (i = N; i > 0; i--); // A[i] = A[N - i];; // having the same cost calculation as a single dimention access pattern; // for (i = 0; i < N; i++); // A[i] = A[i];; // when in actuality, depending on the array size, the first example; // should have a cost closer to 2x the second due to the two cache; // access per iteration from opposite ends of the array",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:37,Security,access,access,37,"// FIXME: Both positive and negative access functions will be placed; // into the same reference group, resulting in a bi-directional array; // access such as:; // for (i = N; i > 0; i--); // A[i] = A[N - i];; // having the same cost calculation as a single dimention access pattern; // for (i = 0; i < N; i++); // A[i] = A[i];; // when in actuality, depending on the array size, the first example; // should have a cost closer to 2x the second due to the two cache; // access per iteration from opposite ends of the array",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:144,Security,access,access,144,"// FIXME: Both positive and negative access functions will be placed; // into the same reference group, resulting in a bi-directional array; // access such as:; // for (i = N; i > 0; i--); // A[i] = A[N - i];; // having the same cost calculation as a single dimention access pattern; // for (i = 0; i < N; i++); // A[i] = A[i];; // when in actuality, depending on the array size, the first example; // should have a cost closer to 2x the second due to the two cache; // access per iteration from opposite ends of the array",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:268,Security,access,access,268,"// FIXME: Both positive and negative access functions will be placed; // into the same reference group, resulting in a bi-directional array; // access such as:; // for (i = N; i > 0; i--); // A[i] = A[N - i];; // having the same cost calculation as a single dimention access pattern; // for (i = 0; i < N; i++); // A[i] = A[i];; // when in actuality, depending on the array size, the first example; // should have a cost closer to 2x the second due to the two cache; // access per iteration from opposite ends of the array",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:470,Security,access,access,470,"// FIXME: Both positive and negative access functions will be placed; // into the same reference group, resulting in a bi-directional array; // access such as:; // for (i = N; i > 0; i--); // A[i] = A[N - i];; // having the same cost calculation as a single dimention access pattern; // for (i = 0; i < N; i++); // A[i] = A[i];; // when in actuality, depending on the array size, the first example; // should have a cost closer to 2x the second due to the two cache; // access per iteration from opposite ends of the array",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:3,Testability,Test,Test,3,// Test if the value is already loop-invariant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:131,Integrability,depend,dependent,131,// There is possibility of hoisting this instruction above some arbitrary; // condition. Any metadata defined on it can be control dependent on this; // condition. Conservatively strip it here so that we don't give any wrong; // information to the optimizer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:248,Performance,optimiz,optimizer,248,// There is possibility of hoisting this instruction above some arbitrary; // condition. Any metadata defined on it can be control dependent on this; // condition. Conservatively strip it here so that we don't give any wrong; // information to the optimizer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:49,Modifiability,variab,variable,49,/// Return the final value of the loop induction variable if found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:74,Performance,optimiz,optimizations,74,"// Tokens can't be used in PHI nodes and live-out tokens prevent loop; // optimizations, so for the purposes of considered LCSSA form, we; // can ignore them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:3,Integrability,Rout,Routines,3,// Routines that reform the loop CFG and split edges often fail on indirectbr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:7,Performance,scalab,scalable,7,// For scalable 'contains' check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:158,Integrability,depend,dependencies,158,"// The loop branch contains the parallel loop metadata. In order to ensure; // that any parallel-loop-unaware optimization pass hasn't added loop-carried; // dependencies (thus converted the loop back to a sequential loop), check; // that all the memory instructions in the loop belong to an access group that; // is parallel to this loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:110,Performance,optimiz,optimization,110,"// The loop branch contains the parallel loop metadata. In order to ensure; // that any parallel-loop-unaware optimization pass hasn't added loop-carried; // dependencies (thus converted the loop back to a sequential loop), check; // that all the memory instructions in the loop belong to an access group that; // is parallel to this loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:292,Security,access,access,292,"// The loop branch contains the parallel loop metadata. In order to ensure; // that any parallel-loop-unaware optimization pass hasn't added loop-carried; // dependencies (thus converted the loop back to a sequential loop), check; // that all the memory instructions in the loop belong to an access group that; // is parallel to this loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:256,Integrability,rout,routine,256,// The memory instruction can refer to the loop identifier metadata; // directly or indirectly through another list metadata (in case of; // nested parallel loops). The loop identifier metadata refers to; // itself so we can check both cases with the same routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:32,Deployability,Update,Update,32,"// end anonymous namespace; /// Update the parent loop for all blocks that are directly contained within the; /// original ""unloop"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:3,Performance,Perform,Perform,3,"// Perform a post order CFG traversal of all blocks within this loop,; // propagating the nearest loop from successors to predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:97,Performance,cache,cached,97,// Each irreducible loop within the unloop induces a round of iteration using; // the DFS result cached by Traversal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:4,Deployability,Update,Update,4,/// Update the parent loop for all subloops directly nested within unloop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:218,Deployability,update,update,218,"/// Return the nearest parent loop among this block's successors. If a successor; /// is a subloop header, consider its parent to be the nearest parent of the; /// subloop's exits.; ///; /// For subloop blocks, simply update SubloopParents and return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:211,Usability,simpl,simply,211,"/// Return the nearest parent loop among this block's successors. If a successor; /// is a subloop header, consider its parent to be the nearest parent of the; /// subloop's exits.; ///; /// For subloop blocks, simply update SubloopParents and return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:54,Usability,simpl,simplify,54,// First handle the special case of no parent loop to simplify the algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:3,Deployability,Update,Update,3,// Update the parent loop for all blocks within the loop. Blocks within; // subloops will not change parents.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:19,Safety,avoid,avoid,19,"// Add metadata to avoid reapplying a transformation, such as; // llvm.loop.unroll.disable and llvm.loop.isvectorized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:203,Performance,perform,perform,203,"// LoopInfoWrapperPass is a FunctionPass, but verifying every loop in the; // function each time verifyAnalysis is called is very expensive. The; // -verify-loop-info option can enable this. In order to perform some; // checking by default, LoopPass has been taught to call verifyLoop manually; // during loop pass sequences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp:170,Modifiability,variab,variable,170,"// Determine whether instructions in a basic block are one of:; // - the inner loop guard comparison; // - the outer loop latch comparison; // - the outer loop induction variable increment; // - a phi node, a cast or a branch",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp:82,Safety,unsafe,unsafe,82,// Check the code surrounding the inner loop for instructions that are deemed; // unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp:82,Safety,unsafe,unsafe,82,// Check the code surrounding the inner loop for instructions that are deemed; // unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp:22,Safety,avoid,avoid,22,// Visited is used to avoid running into an infinite loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:441,Performance,optimiz,optimization,441,"//===- LoopPass.cpp - Loop Pass and Loop Pass Manager ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements LoopPass and LPPassManager. All loop optimization; // and transformation passes are derived from LoopPass. LPPassManager is; // responsible for managing LoopPasses.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:50,Performance,queue,queue,50,// Insert loop into loop nest (LoopInfo) and loop queue (LQ).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:26,Performance,queue,queue,26,// Insert L into the loop queue after the parent loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:45,Performance,queue,queue,45,"// If this loop appears elsewhere within the queue, we also need to remove it; // there. However, we have to be careful to not remove the back of the queue; // as that is assumed to match the current loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:150,Performance,queue,queue,150,"// If this loop appears elsewhere within the queue, we also need to remove it; // there. However, we have to be careful to not remove the back of the queue; // as that is assumed to match the current loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:43,Performance,queue,queue,43,// Add this loop back onto the back of the queue to preserve our invariants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:36,Energy Efficiency,schedul,scheduled,36,"/// run - Execute all of the passes scheduled for execution. Keep track of; /// whether any of the passes modifies the function, and if so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:11,Modifiability,inherit,inherited,11,// Collect inherited analysis from Module level pass manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:21,Performance,queue,queue,21,"// Populate the loop queue in reverse program order. There is no clear need to; // process sibling loops in either forward or reverse order. There may be some; // advantage in deleting uses in a later loop before optimizing the; // definitions in an earlier loop. If we find a clear reason to process in; // forward order, then a forward variant of LoopPassManager should be created.; //; // Note that LoopInfo::iterator visits loops in reverse program; // order. Here, reverse_iterator gives us a forward order, and the LoopQueue; // reverses the order a third time by popping from the back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:213,Performance,optimiz,optimizing,213,"// Populate the loop queue in reverse program order. There is no clear need to; // process sibling loops in either forward or reverse order. There may be some; // advantage in deleting uses in a later loop before optimizing the; // definitions in an earlier loop. If we find a clear reason to process in; // forward order, then a forward variant of LoopPassManager should be created.; //; // Note that LoopInfo::iterator visits loops in reverse program; // order. Here, reverse_iterator gives us a forward order, and the LoopQueue; // reverses the order a third time by popping from the back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:65,Usability,clear,clear,65,"// Populate the loop queue in reverse program order. There is no clear need to; // process sibling loops in either forward or reverse order. There may be some; // advantage in deleting uses in a later loop before optimizing the; // definitions in an earlier loop. If we find a clear reason to process in; // forward order, then a forward variant of LoopPassManager should be created.; //; // Note that LoopInfo::iterator visits loops in reverse program; // order. Here, reverse_iterator gives us a forward order, and the LoopQueue; // reverses the order a third time by popping from the back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:277,Usability,clear,clear,277,"// Populate the loop queue in reverse program order. There is no clear need to; // process sibling loops in either forward or reverse order. There may be some; // advantage in deleting uses in a later loop before optimizing the; // definitions in an earlier loop. If we find a clear reason to process in; // forward order, then a forward variant of LoopPassManager should be created.; //; // Note that LoopInfo::iterator visits loops in reverse program; // order. Here, reverse_iterator gives us a forward order, and the LoopQueue; // reverses the order a third time by popping from the back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:3,Deployability,Update,Update,3,"// Update the size of the function, emit a remark, and update the; // size of the module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:55,Deployability,update,update,55,"// Update the size of the function, emit a remark, and update the; // size of the module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:28,Deployability,release,release,28,"// If the loop was deleted, release all the loop passes. This frees up; // some memory, and avoids trouble with the pass manager trying to call; // verifyAnalysis on them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:92,Safety,avoid,avoids,92,"// If the loop was deleted, release all the loop passes. This frees up; // some memory, and avoids trouble with the pass manager trying to call; // verifyAnalysis on them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:21,Performance,queue,queue,21,// Pop the loop from queue after running all passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:72,Availability,avail,available,72,"// Check if this pass is suitable for the current LPPassManager, if; // available. This pass P is not suitable for a LPPassManager if P; // is not preserving higher level analysis info used by other; // LPPassManager passes. In such case, pop LPPassManager from the; // stack. This will force assignPassManager() to create new; // LPPassManger as expected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:17,Performance,Optimiz,OptimizeNone,17,// Check for the OptimizeNone attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:42,Performance,queue,queue,42,// FIXME: Delete loop from pass manager's queue?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:563,Performance,optimiz,optimizations,563,"//===- LoopUnrollAnalyzer.cpp - Unrolling Effect Estimation -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements UnrolledInstAnalyzer class. It's used for predicting; // potential effects that loop unrolling might have, such as enabling constant; // propagation and other optimizations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:446,Safety,predict,predicting,446,"//===- LoopUnrollAnalyzer.cpp - Unrolling Effect Estimation -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements UnrolledInstAnalyzer class. It's used for predicting; // potential effects that loop unrolling might have, such as enabling constant; // propagation and other optimizations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:11,Usability,simpl,simplify,11,"/// Try to simplify instruction \param I using its SCEV expression.; ///; /// The idea is that some AddRec expressions become constants, which then; /// could trigger folding of other instructions. However, that only happens; /// for expressions whose start value is also constant, which isn't always the; /// case. In another common and important case the start value is just some; /// address (i.e. SCEVUnknown) - in this case we compute the offset and save; /// it along with the base address instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:11,Usability,simpl,simplify,11,"/// Try to simplify binary operator I.; ///; /// TODO: Probably it's worth to hoist the code for estimating the; /// simplifications effects to a separate class, since we have a very similar; /// code in InlineCost already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:117,Usability,simpl,simplifications,117,"/// Try to simplify binary operator I.; ///; /// TODO: Probably it's worth to hoist the code for estimating the; /// simplifications effects to a separate class, since we have a very similar; /// code in InlineCost already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:16,Performance,load,load,16,/// Try to fold load I.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:28,Performance,load,loads,28,// We're only interested in loads that can be completely folded to a; // constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:26,Performance,load,load,26,"// We might have a vector load from an array. FIXME: for now we just bail; // out in this case, but we should be able to resolve and simplify such; // loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:151,Performance,load,loads,151,"// We might have a vector load from an array. FIXME: for now we just bail; // out in this case, but we should be able to resolve and simplify such; // loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:133,Usability,simpl,simplify,133,"// We might have a vector load from an array. FIXME: for now we just bail; // out in this case, but we should be able to resolve and simplify such; // loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:91,Performance,perform,perform,91,"// FIXME: For now we conservatively ignore out of bound accesses, but; // we're allowed to perform the optimization in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:103,Performance,optimiz,optimization,103,"// FIXME: For now we conservatively ignore out of bound accesses, but; // we're allowed to perform the optimization in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:56,Security,access,accesses,56,"// FIXME: For now we conservatively ignore out of bound accesses, but; // we're allowed to perform the optimization in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:91,Performance,perform,perform,91,"// FIXME: For now we conservatively ignore out of bound accesses, but; // we're allowed to perform the optimization in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:103,Performance,optimiz,optimization,103,"// FIXME: For now we conservatively ignore out of bound accesses, but; // we're allowed to perform the optimization in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:56,Security,access,accesses,56,"// FIXME: For now we conservatively ignore out of bound accesses, but; // we're allowed to perform the optimization in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:11,Usability,simpl,simplify,11,/// Try to simplify cast instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:36,Usability,Simpl,SimplifiedValues,36,"// The cast can be invalid, because SimplifiedValues contains results of SCEV; // analysis, which operates on integers (and, e.g., might convert i8* null to; // i32 0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:11,Usability,simpl,simplify,11,/// Try to simplify cmp instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:23,Usability,simpl,simplified,23,// First try to handle simplified comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:451,Energy Efficiency,allocate,allocate,451,"//===- MemoryBuiltins.cpp - Identify calls to memory builtins -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions identifies calls to builtin functions that allocate; // or free memory.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:3,Energy Efficiency,allocate,allocates,3,// allocates; never returns null,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:3,Energy Efficiency,allocate,allocates,3,// allocates; may return null,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:74,Usability,Simpl,SimplifyLibCalls,74,"// clang-format off; // FIXME: certain users need more information. E.g., SimplifyLibCalls needs to; // know which functions are nounwind, noalias, nocapture parameters, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:9,Performance,perform,perform,9,"// Don't perform a slow TLI lookup, if this function doesn't return a pointer; // and thus can't be an allocation function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:34,Availability,avail,available,34,// Make sure that the function is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:54,Energy Efficiency,allocate,allocated,54,"// Because allocsize only tells us how many bytes are allocated, we're not; // really allowed to assume anything, so we use MallocLike.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:73,Energy Efficiency,allocate,allocates,73,"/// Tests if a value is a call or invoke to a library function that; /// allocates or reallocates memory (either malloc, calloc, realloc, or strdup; /// like).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:4,Testability,Test,Tests,4,"/// Tests if a value is a call or invoke to a library function that; /// allocates or reallocates memory (either malloc, calloc, realloc, or strdup; /// like).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:73,Energy Efficiency,allocate,allocates,73,/// Tests if a value is a call or invoke to a library function that; /// allocates memory via new.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:4,Testability,Test,Tests,4,/// Tests if a value is a call or invoke to a library function that; /// allocates memory via new.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:73,Energy Efficiency,allocate,allocates,73,/// Tests if a value is a call or invoke to a library function that; /// allocates memory similar to malloc or calloc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:4,Testability,Test,Tests,4,/// Tests if a value is a call or invoke to a library function that; /// allocates memory similar to malloc or calloc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:73,Energy Efficiency,allocate,allocates,73,"/// Tests if a value is a call or invoke to a library function that; /// allocates memory (either malloc, calloc, or strdup like).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:4,Testability,Test,Tests,4,"/// Tests if a value is a call or invoke to a library function that; /// allocates memory (either malloc, calloc, or strdup like).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:4,Testability,Test,Tests,4,"/// Tests if a functions is a call or invoke to a library function that; /// reallocates memory (e.g., realloc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:32,Integrability,depend,dependent,32,"// Note: Removability is highly dependent on the source language. For; // example, recent C++ requires direct calls to the global allocation; // [basic.stc.dynamic.allocation] to be observable unless part of a new; // expression [expr.new paragraph 13].; // Historically we've treated the C family allocation routines and operator; // new as removable",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:309,Integrability,rout,routines,309,"// Note: Removability is highly dependent on the source language. For; // example, recent C++ requires direct calls to the global allocation; // [basic.stc.dynamic.allocation] to be observable unless part of a new; // expression [expr.new paragraph 13].; // Historically we've treated the C family allocation routines and operator; // new as removable",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:279,Integrability,depend,depending,279,"/// When we're compiling N-bit code, and the user uses parameters that are; /// greater than N bits (e.g. uint64_t on a 32-bit build), we can run into; /// trouble with APInt size issues. This function handles resizing + overflow; /// checks for us. Check and zext or trunc \p I depending on IntTyBits and; /// I's value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:92,Performance,perform,performed,92,"// Get the index type for this address space, results and intermediate; // computations are performed at that width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:249,Modifiability,variab,variables,249,"/// Compute the size of the object pointed by Ptr. Returns true and the; /// object size in Size if successful, and false otherwise.; /// If RoundToAlign is true, then Size is rounded up to the alignment of; /// allocas, byval arguments, and global variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:46,Availability,failure,failure,46,// FIXME: Does it make sense to just return a failure value if the size won't; // fit in the output and `!MustSucceed`?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:62,Security,access,access,62,"// If we've outside the end of the object, then we can always access; // exactly 0 bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:3,Performance,Cache,Cache,3,"// Cache the result for later visits. If we happened to visit this during; // the above recursion, we would consider it unknown until now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:10,Availability,error,error,10,// Is the error status of posix_memalign correctly checked? If not it; // would be incorrect to assume it succeeds and load doesn't see the; // previous value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:119,Performance,load,load,119,// Is the error status of posix_memalign correctly checked? If not it; // would be incorrect to assume it succeeds and load doesn't see the; // previous value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:167,Integrability,depend,dependency,167,"// Erase everything that was computed in this iteration from the cache, so; // that no dangling references are left behind. We could be a bit smarter if; // we kept a dependency graph. It's probably not worth the complexity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:65,Performance,cache,cache,65,"// Erase everything that was computed in this iteration from the cache, so; // that no dangling references are left behind. We could be a bit smarter if; // we kept a dependency graph. It's probably not worth the complexity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:40,Performance,cache,cached,40,// non-computable results can be safely cached,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:33,Safety,safe,safely,33,// non-computable results can be safely cached,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:9,Performance,cache,cache,9,// Check cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:15,Performance,Cache,CacheIt,15,// Don't reuse CacheIt since it may be invalid at this point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:28,Performance,cache,cache,28,// Insert right away in the cache to handle recursive PHIs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:503,Integrability,depend,depends,503,"//===- MemoryDependenceAnalysis.cpp - Mem Deps Implementation -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements an analysis that determines, for a given memory; // operation, what preceding memory operations it depends on. It builds on; // alias analysis information, and tries to provide a lazy, caching interface to; // a common kind of alias information query.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:597,Integrability,interface,interface,597,"//===- MemoryDependenceAnalysis.cpp - Mem Deps Implementation -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements an analysis that determines, for a given memory; // operation, what preceding memory operations it depends on. It builds on; // alias analysis information, and tries to provide a lazy, caching interface to; // a common kind of alias information query.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:41,Integrability,depend,dependencies,41,/// Private helper for finding the local dependencies of a call site.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:49,Integrability,depend,dependencies,49,"// Walk backwards through the block, looking for dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:32,Integrability,depend,dependences,32,// Debug intrinsics don't cause dependences and should not affect Limit,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:100,Testability,test,testcases,100,// Limit the amount of scanning we do so we don't end up with quadratic; // running time on extreme testcases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:51,Security,access,accessed,51,"// If this inst is a memory op, get the pointer it accessed",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:5,Usability,simpl,simple,5,// A simple instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:86,Availability,redundant,redundant,86,"// If the two calls are the same, return Inst as a Def, so that; // Call can be found redundant and eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:86,Safety,redund,redundant,86,"// If the two calls are the same, return Inst as a Def, so that; // Call can be found redundant and eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:122,Integrability,depend,dependency,122,// If we could not obtain a pointer for the instruction and the instruction; // touches memory then assume that this is a dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:6,Integrability,depend,dependence,6,"// No dependence found. If this is the entry block of the function, it is; // unknown, otherwise it is non-local.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:29,Integrability,depend,dependency,29,"// Non-local invariant group dependency indicates there is non local Def; // (it only returns nonLocal if it finds nonLocal def), which is better than; // local clobber and everything else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:90,Availability,down,down,90,// Take the ptr operand after all casts and geps 0. This way we can search; // cast graph down only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:15,Safety,safe,safe,15,"// It's is not safe to walk the use list of global value, because function; // passes aren't allowed to look outside their functions.; // FIXME: this could be fixed by filtering instructions from outside; // of current function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:3,Performance,Queue,Queue,3,// Queue to process all pointers that are equivalent to load operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:56,Performance,load,load,56,// Queue to process all pointers that are equivalent to load operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:51,Performance,queue,queue,51,// Bitcast or gep with zeros are using Ptr. Add to queue to check it's; // users. U = bitcast Ptr,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:13,Performance,load,load,13,// If we hit load/store with the same invariant.group metadata (and the; // same pointer operand) we can assume that value pointed by pointer; // operand didn't change.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:71,Integrability,depend,dependency,71,"// Def(U) can't be returned here because it is non-local. If local; // dependency won't be found then return nonLocal counting that the; // user will call getNonLocalPointerDependency, which will return cached; // result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:203,Performance,cache,cached,203,"// Def(U) can't be returned here because it is non-local. If local; // dependency won't be found then return nonLocal counting that the; // user will call getNonLocalPointerDependency, which will return cached; // result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:248,Performance,load,loaded,248,// Check if SI that may alias with MemLoc can be safely skipped. This is; // possible in case if SI can only must alias or no alias with MemLoc (no; // partial overlapping possible) and it writes the same value that MemLoc; // contains now (it was loaded before this store and was not modified in; // between).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:49,Safety,safe,safely,49,// Check if SI that may alias with MemLoc can be safely skipped. This is; // possible in case if SI can only must alias or no alias with MemLoc (no; // partial overlapping possible) and it writes the same value that MemLoc; // contains now (it was loaded before this store and was not modified in; // between).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:479,Deployability,release,release,479,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:677,Deployability,release,release,677,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:861,Deployability,release,release,861,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:1354,Deployability,release,release,1354,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:890,Integrability,synchroniz,synchronization,890,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:732,Performance,load,load,732,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:1128,Performance,load,load,1128,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:1279,Performance,optimiz,optimization,1279,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:1450,Performance,load,load,1450,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:750,Safety,unsafe,unsafe,750,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:1268,Safety,detect,detect,1268,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:34,Security,access,accesses,34,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:198,Security,access,access,198,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:522,Security,access,access,522,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:1409,Security,access,accesses,1409,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:313,Testability,test,testing,313,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:1678,Testability,log,logic,1678,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:171,Usability,simpl,simple,171,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:259,Usability,simpl,simple,259,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:603,Usability,intuit,intuition,603,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:42,Performance,Load,Load,42,"// True for volatile instruction.; // For Load/Store return true if atomic ordering is stronger than AO,; // for other instruction just true if it can read or write to memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:55,Integrability,depend,dependencies,55,"// Walk backwards through the basic block, looking for dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:44,Integrability,depend,dependencies,44,// Debug intrinsics don't (and can't) cause dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:100,Testability,test,testcases,100,// Limit the amount of scanning we do so we don't end up with quadratic; // running time on extreme testcases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:10,Integrability,depend,depend,10,// Values depend on loads if the pointers are must aliased. This means; // that a load depends on another must aliased load from the same value.; // One exception is atomic loads: a value can depend on an atomic load that; // it does not alias with when this atomic load indicates that another; // thread may be accessing the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:87,Integrability,depend,depends,87,// Values depend on loads if the pointers are must aliased. This means; // that a load depends on another must aliased load from the same value.; // One exception is atomic loads: a value can depend on an atomic load that; // it does not alias with when this atomic load indicates that another; // thread may be accessing the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:192,Integrability,depend,depend,192,// Values depend on loads if the pointers are must aliased. This means; // that a load depends on another must aliased load from the same value.; // One exception is atomic loads: a value can depend on an atomic load that; // it does not alias with when this atomic load indicates that another; // thread may be accessing the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:20,Performance,load,loads,20,// Values depend on loads if the pointers are must aliased. This means; // that a load depends on another must aliased load from the same value.; // One exception is atomic loads: a value can depend on an atomic load that; // it does not alias with when this atomic load indicates that another; // thread may be accessing the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:82,Performance,load,load,82,// Values depend on loads if the pointers are must aliased. This means; // that a load depends on another must aliased load from the same value.; // One exception is atomic loads: a value can depend on an atomic load that; // it does not alias with when this atomic load indicates that another; // thread may be accessing the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:119,Performance,load,load,119,// Values depend on loads if the pointers are must aliased. This means; // that a load depends on another must aliased load from the same value.; // One exception is atomic loads: a value can depend on an atomic load that; // it does not alias with when this atomic load indicates that another; // thread may be accessing the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:173,Performance,load,loads,173,// Values depend on loads if the pointers are must aliased. This means; // that a load depends on another must aliased load from the same value.; // One exception is atomic loads: a value can depend on an atomic load that; // it does not alias with when this atomic load indicates that another; // thread may be accessing the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:212,Performance,load,load,212,// Values depend on loads if the pointers are must aliased. This means; // that a load depends on another must aliased load from the same value.; // One exception is atomic loads: a value can depend on an atomic load that; // it does not alias with when this atomic load indicates that another; // thread may be accessing the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:266,Performance,load,load,266,// Values depend on loads if the pointers are must aliased. This means; // that a load depends on another must aliased load from the same value.; // One exception is atomic loads: a value can depend on an atomic load that; // it does not alias with when this atomic load indicates that another; // thread may be accessing the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:312,Security,access,accessing,312,// Values depend on loads if the pointers are must aliased. This means; // that a load depends on another must aliased load from the same value.; // One exception is atomic loads: a value can depend on an atomic load that; // it does not alias with when this atomic load indicates that another; // thread may be accessing the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:143,Safety,safe,safely,143,"// While volatile access cannot be eliminated, they do not have to clobber; // non-aliasing locations, as normal accesses, for example, can be safely; // reordered with volatile accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:18,Security,access,access,18,"// While volatile access cannot be eliminated, they do not have to clobber; // non-aliasing locations, as normal accesses, for example, can be safely; // reordered with volatile accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:113,Security,access,accesses,113,"// While volatile access cannot be eliminated, they do not have to clobber; // non-aliasing locations, as normal accesses, for example, can be safely; // reordered with volatile accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:178,Security,access,accesses,178,"// While volatile access cannot be eliminated, they do not have to clobber; // non-aliasing locations, as normal accesses, for example, can be safely; // reordered with volatile accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:10,Performance,load,loads,10,// Atomic loads have complications involved.; // A Monotonic (or higher) load is OK if the query inst is itself not; // atomic.; // FIXME: This is overly conservative.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:73,Performance,load,load,73,// Atomic loads have complications involved.; // A Monotonic (or higher) load is OK if the query inst is itself not; // atomic.; // FIXME: This is overly conservative.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:16,Performance,load,loads,16,// Must aliased loads are defs of each other.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:32,Integrability,depend,depend,32,// Random may-alias loads don't depend on each other without a; // dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:67,Integrability,depend,dependence,67,// Random may-alias loads don't depend on each other without a; // dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:20,Performance,load,loads,20,// Random may-alias loads don't depend on each other without a; // dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:22,Performance,load,loads,22,// Stores don't alias loads from read-only memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:10,Integrability,depend,depend,10,// Stores depend on may/must aliased loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:37,Performance,load,loads,37,// Stores depend on may/must aliased loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:146,Deployability,release,release,146,"// Ok, if we are here the guard above guarantee us that; // QueryInst is a non-atomic or unordered load/store.; // SI is atomic with monotonic or release semantic (seq_cst for store; // is actually a release semantic plus total order over other seq_cst; // instructions, as soon as QueryInst is not seq_cst we can consider it; // as simple release semantic).; // Monotonic and Release semantic allows re-ordering before store; // so we are safe to go further and check the aliasing. It will prohibit; // re-ordering in case locations are may or must alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:200,Deployability,release,release,200,"// Ok, if we are here the guard above guarantee us that; // QueryInst is a non-atomic or unordered load/store.; // SI is atomic with monotonic or release semantic (seq_cst for store; // is actually a release semantic plus total order over other seq_cst; // instructions, as soon as QueryInst is not seq_cst we can consider it; // as simple release semantic).; // Monotonic and Release semantic allows re-ordering before store; // so we are safe to go further and check the aliasing. It will prohibit; // re-ordering in case locations are may or must alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:340,Deployability,release,release,340,"// Ok, if we are here the guard above guarantee us that; // QueryInst is a non-atomic or unordered load/store.; // SI is atomic with monotonic or release semantic (seq_cst for store; // is actually a release semantic plus total order over other seq_cst; // instructions, as soon as QueryInst is not seq_cst we can consider it; // as simple release semantic).; // Monotonic and Release semantic allows re-ordering before store; // so we are safe to go further and check the aliasing. It will prohibit; // re-ordering in case locations are may or must alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:377,Deployability,Release,Release,377,"// Ok, if we are here the guard above guarantee us that; // QueryInst is a non-atomic or unordered load/store.; // SI is atomic with monotonic or release semantic (seq_cst for store; // is actually a release semantic plus total order over other seq_cst; // instructions, as soon as QueryInst is not seq_cst we can consider it; // as simple release semantic).; // Monotonic and Release semantic allows re-ordering before store; // so we are safe to go further and check the aliasing. It will prohibit; // re-ordering in case locations are may or must alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:99,Performance,load,load,99,"// Ok, if we are here the guard above guarantee us that; // QueryInst is a non-atomic or unordered load/store.; // SI is atomic with monotonic or release semantic (seq_cst for store; // is actually a release semantic plus total order over other seq_cst; // instructions, as soon as QueryInst is not seq_cst we can consider it; // as simple release semantic).; // Monotonic and Release semantic allows re-ordering before store; // so we are safe to go further and check the aliasing. It will prohibit; // re-ordering in case locations are may or must alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:440,Safety,safe,safe,440,"// Ok, if we are here the guard above guarantee us that; // QueryInst is a non-atomic or unordered load/store.; // SI is atomic with monotonic or release semantic (seq_cst for store; // is actually a release semantic plus total order over other seq_cst; // instructions, as soon as QueryInst is not seq_cst we can consider it; // as simple release semantic).; // Monotonic and Release semantic allows re-ordering before store; // so we are safe to go further and check the aliasing. It will prohibit; // re-ordering in case locations are may or must alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:333,Usability,simpl,simple,333,"// Ok, if we are here the guard above guarantee us that; // QueryInst is a non-atomic or unordered load/store.; // SI is atomic with monotonic or release semantic (seq_cst for store; // is actually a release semantic plus total order over other seq_cst; // instructions, as soon as QueryInst is not seq_cst we can consider it; // as simple release semantic).; // Monotonic and Release semantic allows re-ordering before store; // so we are safe to go further and check the aliasing. It will prohibit; // re-ordering in case locations are may or must alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:18,Security,access,access,18,"// While volatile access cannot be eliminated, they do not have to clobber; // non-aliasing locations, as normal accesses can for example be reordered; // with volatile accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:113,Security,access,accesses,113,"// While volatile access cannot be eliminated, they do not have to clobber; // non-aliasing locations, as normal accesses can for example be reordered; // with volatile accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:169,Security,access,accesses,169,"// While volatile access cannot be eliminated, they do not have to clobber; // non-aliasing locations, as normal accesses can for example be reordered; // with volatile accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:136,Integrability,depend,dependence,136,"// If this is an allocation, and if we know that the accessed pointer is to; // the allocation, return Def. This means that there is no dependence and; // the access can be optimized based on that. For example, a load could; // turn into undef. Note that we can bypass the allocation itself when; // looking for a clobber in many cases; that's an alias property and is; // handled by BasicAA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:173,Performance,optimiz,optimized,173,"// If this is an allocation, and if we know that the accessed pointer is to; // the allocation, return Def. This means that there is no dependence and; // the access can be optimized based on that. For example, a load could; // turn into undef. Note that we can bypass the allocation itself when; // looking for a clobber in many cases; that's an alias property and is; // handled by BasicAA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:213,Performance,load,load,213,"// If this is an allocation, and if we know that the accessed pointer is to; // the allocation, return Def. This means that there is no dependence and; // the access can be optimized based on that. For example, a load could; // turn into undef. Note that we can bypass the allocation itself when; // looking for a clobber in many cases; that's an alias property and is; // handled by BasicAA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:53,Security,access,accessed,53,"// If this is an allocation, and if we know that the accessed pointer is to; // the allocation, return Def. This means that there is no dependence and; // the access can be optimized based on that. For example, a load could; // turn into undef. Note that we can bypass the allocation itself when; // looking for a clobber in many cases; that's an alias property and is; // handled by BasicAA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:159,Security,access,access,159,"// If this is an allocation, and if we know that the accessed pointer is to; // the allocation, return Def. This means that there is no dependence and; // the access can be optimized based on that. For example, a load could; // turn into undef. Note that we can bypass the allocation itself when; // looking for a clobber in many cases; that's an alias property and is; // handled by BasicAA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:77,Integrability,depend,dependency,77,"// If we found a select instruction for MemLoc pointer, return it as Def; // dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:5,Deployability,release,release,5,"// A release fence requires that all stores complete before it, but does; // not prevent the reordering of following loads or stores 'before' the; // fence. As a result, we look past it when finding a dependency for; // loads. DSE uses this to find preceding stores to delete and thus we; // can't bypass the fence if the query instruction is a store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:201,Integrability,depend,dependency,201,"// A release fence requires that all stores complete before it, but does; // not prevent the reordering of following loads or stores 'before' the; // fence. As a result, we look past it when finding a dependency for; // loads. DSE uses this to find preceding stores to delete and thus we; // can't bypass the fence if the query instruction is a store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:117,Performance,load,loads,117,"// A release fence requires that all stores complete before it, but does; // not prevent the reordering of following loads or stores 'before' the; // fence. As a result, we look past it when finding a dependency for; // loads. DSE uses this to find preceding stores to delete and thus we; // can't bypass the fence if the query instruction is a store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:220,Performance,load,loads,220,"// A release fence requires that all stores complete before it, but does; // not prevent the reordering of following loads or stores 'before' the; // fence. As a result, we look past it when finding a dependency for; // loads. DSE uses this to find preceding stores to delete and thus we; // can't bypass the fence if the query instruction is a store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:76,Performance,load,load,76,"// If the call is known to never store to the pointer, and if this is a; // load query, we can safely ignore it (scan past it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:95,Safety,safe,safely,95,"// If the call is known to never store to the pointer, and if this is a; // load query, we can safely ignore it (scan past it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:35,Integrability,depend,dependence,35,"// Otherwise, there is a potential dependence. Return a clobber.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:6,Integrability,depend,dependence,6,"// No dependence found. If this is the entry block of the function, it is; // unknown, otherwise it is non-local.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:15,Performance,cache,cached,15,// Check for a cached result,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:68,Integrability,depend,depends,68,"// If the cached entry is non-dirty, just return it. Note that this depends; // on MemDepResult's default constructing to 'dirty'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:10,Performance,cache,cached,10,"// If the cached entry is non-dirty, just return it. Note that this depends; // on MemDepResult's default constructing to 'dirty'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:6,Integrability,depend,dependence,6,"// No dependence found. If this is the entry block of the function, it is; // unknown, otherwise it is non-local.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:64,Performance,cache,cache,64,/// This method is used when -debug is specified to verify that cache arrays; /// are properly kept sorted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:64,Performance,cache,cached,64,"// This is the set of blocks that need to be recomputed. In the cached case,; // this can happen due to instructions being deleted etc. In the uncached; // case, this starts out as the set of predecessors we care about.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:19,Performance,cache,cache,19,"// Okay, we have a cache entry. If we know it is not dirty, just return it; // with no computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:12,Performance,cache,cache,12,// Sort the cache so that we can do fast binary search lookups below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:41,Deployability,update,update,41,// Iterate while we still have blocks to update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:83,Performance,cache,cache,83,"// Do a binary search to see if we already have an entry for this block in; // the cache set. If so, find it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:43,Deployability,update,update,43,"// Otherwise, remember this slot so we can update the value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:38,Integrability,depend,dependency,38,// Find out if this block has a local dependency for QueryInst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:6,Integrability,depend,dependence,6,"// No dependence found. If this is the entry block of the function, it is; // a clobber, otherwise it is unknown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:42,Deployability,update,update,42,"// If we had a dirty entry for the block, update it. Otherwise, just add; // a new entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:22,Integrability,depend,dependency,22,"// If the block has a dependency (i.e. it isn't completely transparent to; // the value), remember the association!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:73,Deployability,update,update,73,// Keep the ReverseNonLocalDeps map up to date so we can efficiently; // update this when we remove instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:57,Energy Efficiency,efficient,efficiently,57,// Keep the ReverseNonLocalDeps map up to date so we can efficiently; // update this when we remove instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:51,Performance,load,load,51,"// If the block *is* completely transparent to the load, we need to check; // the predecessors of this block. Add them to our worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:21,Performance,cache,cached,21,// Check if there is cached Def with invariant.group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:8,Integrability,rout,routine,8,"// This routine does not expect to deal with volatile instructions.; // Doing so would require piping through the QueryInst all the way through.; // TODO: volatiles can't be elided, but they can be reordered with other; // non-volatile accesses.; // We currently give up on any instruction which is ordered, but we do handle; // atomic instructions which are unordered.; // TODO: Handle ordered instructions",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:236,Security,access,accesses,236,"// This routine does not expect to deal with volatile instructions.; // Doing so would require piping through the QueryInst all the way through.; // TODO: volatiles can't be elided, but they can be reordered with other; // non-volatile accesses.; // We currently give up on any instruction which is ordered, but we do handle; // atomic instructions which are unordered.; // TODO: Handle ordered instructions",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:168,Availability,avail,available,168,"/// Compute the memdep value for BB with Pointer/PointeeSize using either; /// cached information in Cache or by doing a lookup (which may use dirty cache; /// info if available).; ///; /// If we do a lookup, add the result to the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:79,Performance,cache,cached,79,"/// Compute the memdep value for BB with Pointer/PointeeSize using either; /// cached information in Cache or by doing a lookup (which may use dirty cache; /// info if available).; ///; /// If we do a lookup, add the result to the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:101,Performance,Cache,Cache,101,"/// Compute the memdep value for BB with Pointer/PointeeSize using either; /// cached information in Cache or by doing a lookup (which may use dirty cache; /// info if available).; ///; /// If we do a lookup, add the result to the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:149,Performance,cache,cache,149,"/// Compute the memdep value for BB with Pointer/PointeeSize using either; /// cached information in Cache or by doing a lookup (which may use dirty cache; /// info if available).; ///; /// If we do a lookup, add the result to the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:231,Performance,cache,cache,231,"/// Compute the memdep value for BB with Pointer/PointeeSize using either; /// cached information in Cache or by doing a lookup (which may use dirty cache; /// info if available).; ///; /// If we do a lookup, add the result to the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:83,Performance,cache,cache,83,"// Do a binary search to see if we already have an entry for this block in; // the cache set. If so, find it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:60,Integrability,depend,dependency,60,// Use cached result for invariant load only if there is no dependency for non; // invariant load. In this case invariant load can not have any dependency as; // well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:144,Integrability,depend,dependency,144,// Use cached result for invariant load only if there is no dependency for non; // invariant load. In this case invariant load can not have any dependency as; // well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:7,Performance,cache,cached,7,// Use cached result for invariant load only if there is no dependency for non; // invariant load. In this case invariant load can not have any dependency as; // well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:35,Performance,load,load,35,// Use cached result for invariant load only if there is no dependency for non; // invariant load. In this case invariant load can not have any dependency as; // well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:93,Performance,load,load,93,// Use cached result for invariant load only if there is no dependency for non; // invariant load. In this case invariant load can not have any dependency as; // well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:122,Performance,load,load,122,// Use cached result for invariant load only if there is no dependency for non; // invariant load. In this case invariant load can not have any dependency as; // well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:84,Integrability,depend,dependency,84,"// If we have a cached entry, and it is non-dirty, use it as the value for; // this dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:16,Performance,cache,cached,16,"// If we have a cached entry, and it is non-dirty, use it as the value for; // this dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:64,Performance,cache,cache,64,"// Otherwise, we have to scan for the value. If we have a dirty cache; // entry, start scanning from its position, otherwise we scan from the end; // of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:48,Deployability,update,update,48,"// Eliminating the dirty entry from 'Cache', so update the reverse info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:37,Performance,Cache,Cache,37,"// Eliminating the dirty entry from 'Cache', so update the reverse info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:26,Integrability,depend,dependency,26,// Scan the block for the dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:9,Performance,cache,cache,9,// Don't cache results for invariant load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:37,Performance,load,load,37,// Don't cache results for invariant load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:42,Deployability,update,update,42,"// If we had a dirty entry for the block, update it. Otherwise, just add; // a new entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:22,Integrability,depend,dependency,22,"// If the block has a dependency (i.e. it isn't completely transparent to; // the value), remember the reverse association because we just added it; // to Cache!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:155,Performance,Cache,Cache,155,"// If the block has a dependency (i.e. it isn't completely transparent to; // the value), remember the reverse association because we just added it; // to Cache!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:76,Deployability,update,update,76,// Keep the ReverseNonLocalPtrDeps map up to date so we can efficiently; // update MemDep when we remove instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:60,Energy Efficiency,efficient,efficiently,60,// Keep the ReverseNonLocalPtrDeps map up to date so we can efficiently; // update MemDep when we remove instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:29,Performance,cache,cache,29,"/// Sort the NonLocalDepInfo cache, given a certain number of elements in the; /// array that are already properly ordered.; ///; /// This is optimized for the case when only a few entries are added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:142,Performance,optimiz,optimized,142,"/// Sort the NonLocalDepInfo cache, given a certain number of elements in the; /// array that are already properly ordered.; ///; /// This is optimized for the case when only a few entries are added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:14,Integrability,depend,dependency,14,"/// Perform a dependency query based on pointer/pointeesize starting at the end; /// of StartBB.; ///; /// Add any clobber/def results to the results vector and keep track of which; /// blocks are visited in 'Visited'.; ///; /// This has special behavior for the first block queries (when SkipFirstBlock; /// is true). In this special case, it ignores the contents of the specified; /// block and starts returning dependence info for its predecessors.; ///; /// This function returns true on success, or false to indicate that it could; /// not compute dependence information for some reason. This should be treated; /// as a clobber dependence on the first instruction in the predecessor block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:414,Integrability,depend,dependence,414,"/// Perform a dependency query based on pointer/pointeesize starting at the end; /// of StartBB.; ///; /// Add any clobber/def results to the results vector and keep track of which; /// blocks are visited in 'Visited'.; ///; /// This has special behavior for the first block queries (when SkipFirstBlock; /// is true). In this special case, it ignores the contents of the specified; /// block and starts returning dependence info for its predecessors.; ///; /// This function returns true on success, or false to indicate that it could; /// not compute dependence information for some reason. This should be treated; /// as a clobber dependence on the first instruction in the predecessor block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:553,Integrability,depend,dependence,553,"/// Perform a dependency query based on pointer/pointeesize starting at the end; /// of StartBB.; ///; /// Add any clobber/def results to the results vector and keep track of which; /// blocks are visited in 'Visited'.; ///; /// This has special behavior for the first block queries (when SkipFirstBlock; /// is true). In this special case, it ignores the contents of the specified; /// block and starts returning dependence info for its predecessors.; ///; /// This function returns true on success, or false to indicate that it could; /// not compute dependence information for some reason. This should be treated; /// as a clobber dependence on the first instruction in the predecessor block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:634,Integrability,depend,dependence,634,"/// Perform a dependency query based on pointer/pointeesize starting at the end; /// of StartBB.; ///; /// Add any clobber/def results to the results vector and keep track of which; /// blocks are visited in 'Visited'.; ///; /// This has special behavior for the first block queries (when SkipFirstBlock; /// is true). In this special case, it ignores the contents of the specified; /// block and starts returning dependence info for its predecessors.; ///; /// This function returns true on success, or false to indicate that it could; /// not compute dependence information for some reason. This should be treated; /// as a clobber dependence on the first instruction in the predecessor block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:4,Performance,Perform,Perform,4,"/// Perform a dependency query based on pointer/pointeesize starting at the end; /// of StartBB.; ///; /// Add any clobber/def results to the results vector and keep track of which; /// blocks are visited in 'Visited'.; ///; /// This has special behavior for the first block queries (when SkipFirstBlock; /// is true). In this special case, it ignores the contents of the specified; /// block and starts returning dependence info for its predecessors.; ///; /// This function returns true on success, or false to indicate that it could; /// not compute dependence information for some reason. This should be treated; /// as a clobber dependence on the first instruction in the predecessor block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:15,Performance,cache,cached,15,// Look up the cached info for Pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:79,Performance,Cache,CacheKey,79,"// Set up a temporary NLPI value. If the map doesn't yet have an entry for; // CacheKey, this value will be inserted as the associated value. Otherwise,; // it'll be ignored, and we'll have to check to see if the cached size and; // aa tags are consistent with the current query.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:213,Performance,cache,cached,213,"// Set up a temporary NLPI value. If the map doesn't yet have an entry for; // CacheKey, this value will be inserted as the associated value. Otherwise,; // it'll be ignored, and we'll have to check to see if the cached size and; // aa tags are consistent with the current query.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:20,Performance,Cache,CacheKey,20,"// Get the NLPI for CacheKey, inserting one into the map if it doesn't; // already have one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:24,Performance,cache,cache,24,"// If we already have a cache entry for this CacheKey, we may need to do some; // work to reconcile the cache entry and the current query.; // Invariant loads don't participate in caching. Thus no need to reconcile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:45,Performance,Cache,CacheKey,45,"// If we already have a cache entry for this CacheKey, we may need to do some; // work to reconcile the cache entry and the current query.; // Invariant loads don't participate in caching. Thus no need to reconcile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:104,Performance,cache,cache,104,"// If we already have a cache entry for this CacheKey, we may need to do some; // work to reconcile the cache entry and the current query.; // Invariant loads don't participate in caching. Thus no need to reconcile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:153,Performance,load,loads,153,"// If we already have a cache entry for this CacheKey, we may need to do some; // work to reconcile the cache entry and the current query.; // Invariant loads don't participate in caching. Thus no need to reconcile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:40,Performance,cache,cached,40,// The query's Size is greater than the cached one. Throw out the; // cached data and proceed with the query at the greater size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:70,Performance,cache,cached,70,// The query's Size is greater than the cached one. Throw out the; // cached data and proceed with the query at the greater size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:7,Performance,cache,cache,7,// The cache is cleared (in the above line) so we will have lost; // information about blocks we have already visited. We therefore must; // assume that the cache information is incomplete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:157,Performance,cache,cache,157,// The cache is cleared (in the above line) so we will have lost; // information about blocks we have already visited. We therefore must; // assume that the cache information is incomplete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:16,Usability,clear,cleared,16,// The cache is cleared (in the above line) so we will have lost; // information about blocks we have already visited. We therefore must; // assume that the cache information is incomplete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:38,Performance,cache,cached,38,// This query's Size is less than the cached one. Conservatively restart; // the query using the greater size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:51,Performance,cache,cached,51,"// If the query's AATags are inconsistent with the cached one,; // conservatively throw out the cached data and restart the query with; // no tag if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:96,Performance,cache,cached,96,"// If the query's AATags are inconsistent with the cached one,; // conservatively throw out the cached data and restart the query with; // no tag if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:7,Performance,cache,cache,7,// The cache is cleared (in the above line) so we will have lost; // information about blocks we have already visited. We therefore must; // assume that the cache information is incomplete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:157,Performance,cache,cache,157,// The cache is cleared (in the above line) so we will have lost; // information about blocks we have already visited. We therefore must; // assume that the cache information is incomplete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:16,Usability,clear,cleared,16,// The cache is cleared (in the above line) so we will have lost; // information about blocks we have already visited. We therefore must; // assume that the cache information is incomplete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:20,Performance,cache,cached,20,"// If we have valid cached information for exactly the block we are; // investigating, just return it with no recomputation.; // Don't use cached information for invariant loads since it is valid for; // non-invariant loads only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:139,Performance,cache,cached,139,"// If we have valid cached information for exactly the block we are; // investigating, just return it with no recomputation.; // Don't use cached information for invariant loads since it is valid for; // non-invariant loads only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:172,Performance,load,loads,172,"// If we have valid cached information for exactly the block we are; // investigating, just return it with no recomputation.; // Don't use cached information for invariant loads since it is valid for; // non-invariant loads only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:218,Performance,load,loads,218,"// If we have valid cached information for exactly the block we are; // investigating, just return it with no recomputation.; // Don't use cached information for invariant loads since it is valid for; // non-invariant loads only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:19,Performance,cache,cached,19,"// We have a fully cached result for this query then we can just return the; // cached results and populate the visited set. However, we have to verify; // that we don't already have conflicting results for these blocks. Check; // to ensure that if a block in the results set is in the visited set that; // it was for the same pointer query.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:80,Performance,cache,cached,80,"// We have a fully cached result for this query then we can just return the; // cached results and populate the visited set. However, we have to verify; // that we don't already have conflicting results for these blocks. Check; // to ensure that if a block in the results set is in the visited set that; // it was for the same pointer query.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:150,Performance,cache,cached,150,"// We have a pointer mismatch in a block. Just return false, saying; // that something was clobbered in this result. We could also do a; // non-fully cached query, but there is little point in doing this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:366,Deployability,update,update,366,"// Otherwise, either this is a new block, a block with an invalid cache; // pointer or one that we're about to invalidate by putting more info into; // it than its valid cache info. If empty and not explicitly indicated as; // incomplete, the result will be valid cache info, otherwise it isn't.; //; // Invariant loads don't affect cache in any way thus no need to update; // CacheInfo as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:66,Performance,cache,cache,66,"// Otherwise, either this is a new block, a block with an invalid cache; // pointer or one that we're about to invalidate by putting more info into; // it than its valid cache info. If empty and not explicitly indicated as; // incomplete, the result will be valid cache info, otherwise it isn't.; //; // Invariant loads don't affect cache in any way thus no need to update; // CacheInfo as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:170,Performance,cache,cache,170,"// Otherwise, either this is a new block, a block with an invalid cache; // pointer or one that we're about to invalidate by putting more info into; // it than its valid cache info. If empty and not explicitly indicated as; // incomplete, the result will be valid cache info, otherwise it isn't.; //; // Invariant loads don't affect cache in any way thus no need to update; // CacheInfo as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:264,Performance,cache,cache,264,"// Otherwise, either this is a new block, a block with an invalid cache; // pointer or one that we're about to invalidate by putting more info into; // it than its valid cache info. If empty and not explicitly indicated as; // incomplete, the result will be valid cache info, otherwise it isn't.; //; // Invariant loads don't affect cache in any way thus no need to update; // CacheInfo as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:314,Performance,load,loads,314,"// Otherwise, either this is a new block, a block with an invalid cache; // pointer or one that we're about to invalidate by putting more info into; // it than its valid cache info. If empty and not explicitly indicated as; // incomplete, the result will be valid cache info, otherwise it isn't.; //; // Invariant loads don't affect cache in any way thus no need to update; // CacheInfo as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:333,Performance,cache,cache,333,"// Otherwise, either this is a new block, a block with an invalid cache; // pointer or one that we're about to invalidate by putting more info into; // it than its valid cache info. If empty and not explicitly indicated as; // incomplete, the result will be valid cache info, otherwise it isn't.; //; // Invariant loads don't affect cache in any way thus no need to update; // CacheInfo as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:377,Performance,Cache,CacheInfo,377,"// Otherwise, either this is a new block, a block with an invalid cache; // pointer or one that we're about to invalidate by putting more info into; // it than its valid cache info. If empty and not explicitly indicated as; // incomplete, the result will be valid cache info, otherwise it isn't.; //; // Invariant loads don't affect cache in any way thus no need to update; // CacheInfo as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:65,Performance,cache,cached,65,"// Keep track of the entries that we know are sorted. Previously cached; // entries will all be sorted. The entries we add we only sort on demand (we; // don't insert every element into its sorted position). We know that we; // won't get any reuse from currently inserted values, because we don't; // revisit blocks after we insert info for them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:102,Integrability,rout,routines,102,// Sort it now (if needed) so that recursive invocations of; // getNonLocalPointerDepFromBB and other routines that could reuse the; // cache value will only see properly sorted cache arrays.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:136,Performance,cache,cache,136,// Sort it now (if needed) so that recursive invocations of; // getNonLocalPointerDepFromBB and other routines that could reuse the; // cache value will only see properly sorted cache arrays.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:178,Performance,cache,cache,178,// Sort it now (if needed) so that recursive invocations of; // getNonLocalPointerDepFromBB and other routines that could reuse the; // cache value will only see properly sorted cache arrays.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:27,Performance,Cache,Cache,27,"// Since we bail out, the ""Cache"" set won't contain all of the; // results for the query. This is ok (we can still use it to accelerate; // specific block queries) but we can't do the fastpath ""return all; // results from the set"". Clear out the indicator for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:232,Usability,Clear,Clear,232,"// Since we bail out, the ""Cache"" set won't contain all of the; // results for the query. This is ok (we can still use it to accelerate; // specific block queries) but we can't do the fastpath ""return all; // results from the set"". Clear out the indicator for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:15,Integrability,depend,dependency,15,// Analyze the dependency of *Pointer in FromBB. See if we already have; // been here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:11,Integrability,depend,dependency,11,"// Get the dependency info for Pointer in BB. If we have cached; // information, we will use it, otherwise we compute it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:57,Performance,cache,cached,57,"// Get the dependency info for Pointer in BB. If we have cached; // information, we will use it, otherwise we compute it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:109,Availability,failure,failure,109,"// If we have seen this block before, but it was with a different; // pointer then we have a phi translation failure and we have to treat; // this as a clobber.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:255,Integrability,rout,routines,255,"// We may have added values to the cache list before this PHI translation.; // If so, we haven't done anything to ensure that the cache remains sorted.; // Sort it now (if needed) so that recursive invocations of; // getNonLocalPointerDepFromBB and other routines that could reuse the cache; // value will only see properly sorted cache arrays.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:35,Performance,cache,cache,35,"// We may have added values to the cache list before this PHI translation.; // If so, we haven't done anything to ensure that the cache remains sorted.; // Sort it now (if needed) so that recursive invocations of; // getNonLocalPointerDepFromBB and other routines that could reuse the cache; // value will only see properly sorted cache arrays.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:130,Performance,cache,cache,130,"// We may have added values to the cache list before this PHI translation.; // If so, we haven't done anything to ensure that the cache remains sorted.; // Sort it now (if needed) so that recursive invocations of; // getNonLocalPointerDepFromBB and other routines that could reuse the cache; // value will only see properly sorted cache arrays.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:285,Performance,cache,cache,285,"// We may have added values to the cache list before this PHI translation.; // If so, we haven't done anything to ensure that the cache remains sorted.; // Sort it now (if needed) so that recursive invocations of; // getNonLocalPointerDepFromBB and other routines that could reuse the cache; // value will only see properly sorted cache arrays.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:331,Performance,cache,cache,331,"// We may have added values to the cache list before this PHI translation.; // If so, we haven't done anything to ensure that the cache remains sorted.; // Sort it now (if needed) so that recursive invocations of; // getNonLocalPointerDepFromBB and other routines that could reuse the cache; // value will only see properly sorted cache arrays.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:122,Availability,failure,failure,122,"// Check to see if we have already visited this pred block with another; // pointer. If so, we can't do this lookup. This failure can occur; // with PHI translation when a critical edge exists and the PHI node in; // the successor translates to a pointer value different than the; // pointer the block was first analyzed with.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:169,Availability,failure,failure,169,"// Otherwise, the block was previously analyzed with a different; // pointer. We can't represent the result of this case, so we just; // treat this as a phi translation failure.; // Make sure to clean up the Visited map before continuing on to; // PredTranslationFailure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:69,Safety,avoid,avoid,69,// Actually process results here; this need to be a separate loop to avoid; // calling getNonLocalPointerDepFromBB for blocks we don't want to return; // any results for. (getNonLocalPointerDepFromBB will modify our; // datastructures in ways the code after the PredTranslationFailure label; // doesn't expect.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:44,Availability,avail,available,44,"// If PHI translation was unable to find an available pointer in this; // predecessor, then we have to assume that the pointer is clobbered in; // that predecessor. We can still do PRE of the load, which would insert; // a computation of the pointer in this predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:192,Performance,load,load,192,"// If PHI translation was unable to find an available pointer in this; // predecessor, then we have to assume that the pointer is clobbered in; // that predecessor. We can still do PRE of the load, which would insert; // a computation of the pointer in this predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:310,Performance,cache,cached,310,"// FIXME: it is entirely possible that PHI translating will end up with; // the same value. Consider PHI translating something like:; // X = phi [x, bb1], [y, bb2]. PHI translating for bb1 doesn't *need*; // to recurse here, pedantically speaking.; // If getNonLocalPointerDepFromBB fails here, that means the cached; // result conflicted with the Visited list; we have to conservatively; // assume it is unknown, but this also does not block PRE of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:454,Performance,load,load,454,"// FIXME: it is entirely possible that PHI translating will end up with; // the same value. Consider PHI translating something like:; // X = phi [x, bb1], [y, bb2]. PHI translating for bb1 doesn't *need*; // to recurse here, pedantically speaking.; // If getNonLocalPointerDepFromBB fails here, that means the cached; // result conflicted with the Visited list; we have to conservatively; // assume it is unknown, but this also does not block PRE of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:34,Availability,failure,failure,34,"// Since we had a phi translation failure, the cache for CacheKey won't; // include all of the entries that we need to immediately satisfy future; // queries. Mark this in NonLocalPointerDeps by setting the; // BBSkipFirstBlockPair pointer to null. This requires reuse of the; // cached value to do more work but not miss the phi trans failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:336,Availability,failure,failure,336,"// Since we had a phi translation failure, the cache for CacheKey won't; // include all of the entries that we need to immediately satisfy future; // queries. Mark this in NonLocalPointerDeps by setting the; // BBSkipFirstBlockPair pointer to null. This requires reuse of the; // cached value to do more work but not miss the phi trans failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:47,Performance,cache,cache,47,"// Since we had a phi translation failure, the cache for CacheKey won't; // include all of the entries that we need to immediately satisfy future; // queries. Mark this in NonLocalPointerDeps by setting the; // BBSkipFirstBlockPair pointer to null. This requires reuse of the; // cached value to do more work but not miss the phi trans failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:57,Performance,Cache,CacheKey,57,"// Since we had a phi translation failure, the cache for CacheKey won't; // include all of the entries that we need to immediately satisfy future; // queries. Mark this in NonLocalPointerDeps by setting the; // BBSkipFirstBlockPair pointer to null. This requires reuse of the; // cached value to do more work but not miss the phi trans failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:280,Performance,cache,cached,280,"// Since we had a phi translation failure, the cache for CacheKey won't; // include all of the entries that we need to immediately satisfy future; // queries. Mark this in NonLocalPointerDeps by setting the; // BBSkipFirstBlockPair pointer to null. This requires reuse of the; // cached value to do more work but not miss the phi trans failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:15,Performance,Cache,CacheInfo,15,// Refresh the CacheInfo/Cache pointer so that it isn't invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:25,Performance,Cache,Cache,25,// Refresh the CacheInfo/Cache pointer so that it isn't invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:38,Performance,Cache,Cache,38,"// Since we did phi translation, the ""Cache"" set won't contain all of the; // results for the query. This is ok (we can still use it to accelerate; // specific block queries) but we can't do the fastpath ""return all; // results from the set"" Clear out the indicator for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:242,Usability,Clear,Clear,242,"// Since we did phi translation, the ""Cache"" set won't contain all of the; // results for the query. This is ok (we can still use it to accelerate; // specific block queries) but we can't do the fastpath ""return all; // results from the set"" Clear out the indicator for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:26,Availability,failure,failure,26,"// The following code is ""failure""; we can't produce a sane translation; // for the given block. It assumes that we haven't modified any of; // our datastructures while processing the current block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:15,Performance,Cache,CacheInfo,15,// Refresh the CacheInfo/Cache pointer if it got invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:25,Performance,Cache,Cache,25,// Refresh the CacheInfo/Cache pointer if it got invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:41,Performance,Cache,Cache,41,"// Since we failed phi translation, the ""Cache"" set won't contain all of the; // results for the query. This is ok (we can still use it to accelerate; // specific block queries) but we can't do the fastpath ""return all; // results from the set"". Clear out the indicator for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:246,Usability,Clear,Clear,246,"// Since we failed phi translation, the ""Cache"" set won't contain all of the; // results for the query. This is ok (we can still use it to accelerate; // specific block queries) but we can't do the fastpath ""return all; // results from the set"". Clear out the indicator for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:61,Deployability,update,update,61,// Results of invariant loads are not cached thus no need to update cached; // information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:24,Performance,load,loads,24,// Results of invariant loads are not cached thus no need to update cached; // information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:38,Performance,cache,cached,38,// Results of invariant loads are not cached thus no need to update cached; // information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:68,Performance,cache,cached,68,// Results of invariant loads are not cached thus no need to update cached; // information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:31,Integrability,depend,dependence,31,// Go ahead and report unknown dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:55,Performance,cache,cache,55,"// Okay, we're done now. If we added new values to the cache, re-sort it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:19,Performance,Cache,CachedNonLocalPointerInfo,19,"/// If P exists in CachedNonLocalPointerInfo or NonLocalDefsCache, remove it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:25,Performance,cache,cache,25,// Most of the time this cache is empty.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:48,Deployability,update,update,48,"// Eliminating the dirty entry from 'Cache', so update the reverse info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:37,Performance,Cache,Cache,37,"// Eliminating the dirty entry from 'Cache', so update the reverse info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:9,Performance,load,load,9,// Flush load info for the pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:30,Integrability,depend,dependencies,30,"// Walk through the Non-local dependencies, removing this one as the value; // for any cached queries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:87,Performance,cache,cached,87,"// Walk through the Non-local dependencies, removing this one as the value; // for any cached queries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:29,Integrability,depend,dependence,29,"// If we have a cached local dependence query for this instruction, remove it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:16,Performance,cache,cached,16,"// If we have a cached local dependence query for this instruction, remove it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:21,Integrability,depend,dependency,21,// Remove this local dependency info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:25,Integrability,depend,dependencies,25,"// If we have any cached dependencies on this instruction, remove; // them.; // If the instruction is a pointer, remove it from both the load info and the; // store info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:18,Performance,cache,cached,18,"// If we have any cached dependencies on this instruction, remove; // them.; // If the instruction is a pointer, remove it from both the load info and the; // store info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:137,Performance,load,load,137,"// If we have any cached dependencies on this instruction, remove; // them.; // If the instruction is a pointer, remove it from both the load info and the; // store info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:71,Performance,load,load,71,"// Otherwise, if the instructions is in the map directly, it must be a load.; // Remove it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:36,Integrability,depend,depend,36,// Loop over all of the things that depend on the instruction we're removing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:57,Integrability,depend,depending,57,// RemInst can't be the terminator if it has local stuff depending on it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:41,Integrability,depend,depend,41,// Make sure to remember that new things depend on NewDepInst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:51,Safety,avoid,avoid,51,"// Add new reverse deps after scanning the set, to avoid invalidating the; // 'ReverseDeps' reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:51,Safety,avoid,avoid,51,"// Add new reverse deps after scanning the set, to avoid invalidating 'Set'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:7,Performance,cache,cache,7,// The cache is not valid for any specific block anymore.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:3,Deployability,Update,Update,3,// Update any entries for RemInst to use the instruction after it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:131,Testability,assert,asserting,131,/// Verify that the specified instruction does not occur in our internal data; /// structures.; ///; /// This function verifies by asserting in debug builds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:33,Integrability,depend,depend,33,// Check whether the analyses we depend on became invalid for any reason.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryLocation.cpp:159,Safety,abort,aborts,159,"// memset_chk writes at most Len bytes, memcpy_chk reads/writes at most; // Len bytes. They may read/write less, if Len exceeds the specified max; // size and aborts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryLocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryLocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:27,Security,access,access,27,// Upper bound on lifetime access density (accesses per byte per lifetime sec); // for marking an allocation cold.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:43,Security,access,accesses,43,// Upper bound on lifetime access density (accesses per byte per lifetime sec); // for marking an allocation cold.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:119,Safety,avoid,avoid,119,// Lower bound on lifetime to mark an allocation cold (in addition to accesses; // per byte per sec above). This is to avoid pessimizing short lived objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:70,Security,access,accesses,70,// Lower bound on lifetime to mark an allocation cold (in addition to accesses; // per byte per sec above). This is to avoid pessimizing short lived objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:35,Security,access,accesses,35,// Lower bound on average lifetime accesses density (total life time access; // density / alloc count) for marking an allocation hot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:69,Security,access,access,69,// Lower bound on average lifetime accesses density (total life time access; // density / alloc count) for marking an allocation hot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:7,Security,access,access,7,"// The access densities are multiplied by 100 to hold 2 decimal places of; // precision, so need to divide by 100.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:7,Security,access,access,7,"// The access densities are multiplied by 100 to hold 2 decimal places of; // precision, so need to divide by 100.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:44,Deployability,update,update,44,"// If this is the first stack frame, add or update alloc node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:3,Deployability,Update,Update,3,// Update existing caller node if it exists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:160,Usability,simpl,simpler,160,// Recursive helper to trim contexts and create metadata nodes.; // Caller should have pushed Node's loc to MIBCallStack. Doing this in the; // caller makes it simpler to handle the many early returns in this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:365,Performance,optimiz,optimizer,365,"/// Our current alias analysis API differentiates heavily between calls and; /// non-calls, and functions called on one usually assert on the other.; /// This class encapsulates the distinction to simplify other code that wants; /// ""Memory affecting instructions and related data"" to use as a key.; /// For example, this class is used as a densemap key in the use optimizer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:128,Testability,assert,assert,128,"/// Our current alias analysis API differentiates heavily between calls and; /// non-calls, and functions called on one usually assert on the other.; /// This class encapsulates the distinction to simplify other code that wants; /// ""Memory affecting instructions and related data"" to use as a key.; /// For example, this class is used as a densemap key in the use optimizer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:197,Usability,simpl,simplify,197,"/// Our current alias analysis API differentiates heavily between calls and; /// non-calls, and functions called on one usually assert on the other.; /// This class encapsulates the distinction to simplify other code that wants; /// ""Memory affecting instructions and related data"" to use as a key.; /// For example, this class is used as a densemap key in the use optimizer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:78,Performance,optimiz,optimizers,78,"// Otherwise, volatile doesn't matter here. From the language reference:; // 'optimizers may change the order of volatile operations relative to; // non-volatile operations.'""; // If a load is seq_cst, it cannot be moved above other loads. If its ordering; // is weaker, it can be moved above other loads. We just need to be sure that; // MayClobber isn't an acquire load, because loads can't be moved above; // acquire loads.; //; // Note that this explicitly *does* allow the free reordering of monotonic (or; // weaker) loads of the same address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:185,Performance,load,load,185,"// Otherwise, volatile doesn't matter here. From the language reference:; // 'optimizers may change the order of volatile operations relative to; // non-volatile operations.'""; // If a load is seq_cst, it cannot be moved above other loads. If its ordering; // is weaker, it can be moved above other loads. We just need to be sure that; // MayClobber isn't an acquire load, because loads can't be moved above; // acquire loads.; //; // Note that this explicitly *does* allow the free reordering of monotonic (or; // weaker) loads of the same address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:233,Performance,load,loads,233,"// Otherwise, volatile doesn't matter here. From the language reference:; // 'optimizers may change the order of volatile operations relative to; // non-volatile operations.'""; // If a load is seq_cst, it cannot be moved above other loads. If its ordering; // is weaker, it can be moved above other loads. We just need to be sure that; // MayClobber isn't an acquire load, because loads can't be moved above; // acquire loads.; //; // Note that this explicitly *does* allow the free reordering of monotonic (or; // weaker) loads of the same address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:299,Performance,load,loads,299,"// Otherwise, volatile doesn't matter here. From the language reference:; // 'optimizers may change the order of volatile operations relative to; // non-volatile operations.'""; // If a load is seq_cst, it cannot be moved above other loads. If its ordering; // is weaker, it can be moved above other loads. We just need to be sure that; // MayClobber isn't an acquire load, because loads can't be moved above; // acquire loads.; //; // Note that this explicitly *does* allow the free reordering of monotonic (or; // weaker) loads of the same address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:367,Performance,load,load,367,"// Otherwise, volatile doesn't matter here. From the language reference:; // 'optimizers may change the order of volatile operations relative to; // non-volatile operations.'""; // If a load is seq_cst, it cannot be moved above other loads. If its ordering; // is weaker, it can be moved above other loads. We just need to be sure that; // MayClobber isn't an acquire load, because loads can't be moved above; // acquire loads.; //; // Note that this explicitly *does* allow the free reordering of monotonic (or; // weaker) loads of the same address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:381,Performance,load,loads,381,"// Otherwise, volatile doesn't matter here. From the language reference:; // 'optimizers may change the order of volatile operations relative to; // non-volatile operations.'""; // If a load is seq_cst, it cannot be moved above other loads. If its ordering; // is weaker, it can be moved above other loads. We just need to be sure that; // MayClobber isn't an acquire load, because loads can't be moved above; // acquire loads.; //; // Note that this explicitly *does* allow the free reordering of monotonic (or; // weaker) loads of the same address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:420,Performance,load,loads,420,"// Otherwise, volatile doesn't matter here. From the language reference:; // 'optimizers may change the order of volatile operations relative to; // non-volatile operations.'""; // If a load is seq_cst, it cannot be moved above other loads. If its ordering; // is weaker, it can be moved above other loads. We just need to be sure that; // MayClobber isn't an acquire load, because loads can't be moved above; // acquire loads.; //; // Note that this explicitly *does* allow the free reordering of monotonic (or; // weaker) loads of the same address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:523,Performance,load,loads,523,"// Otherwise, volatile doesn't matter here. From the language reference:; // 'optimizers may change the order of volatile operations relative to; // non-volatile operations.'""; // If a load is seq_cst, it cannot be moved above other loads. If its ordering; // is weaker, it can be moved above other loads. We just need to be sure that; // MayClobber isn't an acquire load, because loads can't be moved above; // acquire loads.; //; // Note that this explicitly *does* allow the free reordering of monotonic (or; // weaker) loads of the same address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:57,Testability,test,test,57,"// The MemoryAccess we actually got called with, used to test local domination",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:40,Performance,load,loads,40,"// If the memory can't be changed, then loads of the memory can't be; // clobbered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:229,Performance,cache,cache,229,"/// Verifies that `Start` is clobbered by `ClobberAt`, and that nothing; /// inbetween `Start` and `ClobberAt` can clobbers `Start`.; ///; /// This is meant to be as simple and self-contained as possible. Because it; /// uses no cache, etc., it can be relatively expensive.; ///; /// \param Start The MemoryAccess that we want to walk from.; /// \param ClobberAt A clobber for Start.; /// \param StartLoc The MemoryLocation for Start.; /// \param MSSA The MemorySSA instance that Start and ClobberAt belong to.; /// \param Query The UpwardsMemoryQuery we used for our search.; /// \param AA The AliasAnalysis we used for our search.; /// \param AllowImpreciseClobber Always false, unless we do relaxed verify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:166,Usability,simpl,simple,166,"/// Verifies that `Start` is clobbered by `ClobberAt`, and that nothing; /// inbetween `Start` and `ClobberAt` can clobbers `Start`.; ///; /// This is meant to be as simple and self-contained as possible. Because it; /// uses no cache, etc., it can be relatively expensive.; ///; /// \param Start The MemoryAccess that we want to walk from.; /// \param ClobberAt A clobber for Start.; /// \param StartLoc The MemoryLocation for Start.; /// \param MSSA The MemorySSA instance that Start and ClobberAt belong to.; /// \param Query The UpwardsMemoryQuery we used for our search.; /// \param AA The AliasAnalysis we used for our search.; /// \param AllowImpreciseClobber Always false, unless we do relaxed verify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:84,Usability,learn,learn,84,// All we care about is that nothing from Start to ClobberAt clobbers Start.; // We learn nothing from revisiting nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:38,Performance,optimiz,optimization,38,"// If the verify is done following an optimization, it's possible that; // ClobberAt was a conservative clobbering, that we can now infer is not a; // true clobbering access. Don't fail the verify if that's the case.; // We do have accesses that claim they're optimized, but could be optimized; // further. Updating all these can be expensive, so allow it for now (FIXME).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:260,Performance,optimiz,optimized,260,"// If the verify is done following an optimization, it's possible that; // ClobberAt was a conservative clobbering, that we can now infer is not a; // true clobbering access. Don't fail the verify if that's the case.; // We do have accesses that claim they're optimized, but could be optimized; // further. Updating all these can be expensive, so allow it for now (FIXME).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:284,Performance,optimiz,optimized,284,"// If the verify is done following an optimization, it's possible that; // ClobberAt was a conservative clobbering, that we can now infer is not a; // true clobbering access. Don't fail the verify if that's the case.; // We do have accesses that claim they're optimized, but could be optimized; // further. Updating all these can be expensive, so allow it for now (FIXME).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:167,Security,access,access,167,"// If the verify is done following an optimization, it's possible that; // ClobberAt was a conservative clobbering, that we can now infer is not a; // true clobbering access. Don't fail the verify if that's the case.; // We do have accesses that claim they're optimized, but could be optimized; // further. Updating all these can be expensive, so allow it for now (FIXME).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:232,Security,access,accesses,232,"// If the verify is done following an optimization, it's possible that; // ClobberAt was a conservative clobbering, that we can now infer is not a; // true clobbering access. Don't fail the verify if that's the case.; // We do have accesses that claim they're optimized, but could be optimized; // further. Updating all these can be expensive, so allow it for now (FIXME).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:69,Integrability,wrap,wrapped,69,"/// Our algorithm for walking (and trying to optimize) clobbers, all wrapped up; /// in one class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:45,Performance,optimiz,optimize,45,"/// Our algorithm for walking (and trying to optimize) clobbers, all wrapped up; /// in one class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:7,Performance,optimiz,optimization,7,// Phi optimization bookkeeping:; // List of DefPath to process during the current phi optimization walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:87,Performance,optimiz,optimization,87,// Phi optimization bookkeeping:; // List of DefPath to process during the current phi optimization walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:20,Security,Access,Access,20,"// List of visited <Access, Location> pairs; we can skip paths already; // visited with the same memory location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:59,Performance,optimiz,optimized,59,/// Find the nearest def or phi that `From` can legally be optimized to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:91,Deployability,update,update,91,/// Walk to the next Phi or Clobber in the def chain starting at Desc.Last.; /// This will update Desc.Last as it walks. It will (optionally) also stop at; /// StopAt.; ///; /// This does not test for whether StopAt is a clobber,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:192,Testability,test,test,192,/// Walk to the next Phi or Clobber in the def chain starting at Desc.Last.; /// This will update Desc.Last as it walks. It will (optionally) also stop at; /// StopAt.; ///; /// This does not test for whether StopAt is a clobber,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:200,Performance,cache,cache,200,"/// Represents a search that terminated after finding a clobber. This clobber; /// may or may not be present in the path of defs from LastNode..SearchStart,; /// since it may have been retrieved from cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:37,Performance,optimiz,optimizing,37,"/// Get an access that keeps us from optimizing to the given phi.; ///; /// PausedSearches is an array of indices into the Paths array. Its incoming; /// value is the indices of searches that stopped at the last phi optimization; /// target. It's left in an unspecified state.; ///; /// If this returns std::nullopt, NewPaused is a vector of searches that; /// terminated at StopWhere. Otherwise, NewPaused is left in an unspecified; /// state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:216,Performance,optimiz,optimization,216,"/// Get an access that keeps us from optimizing to the given phi.; ///; /// PausedSearches is an array of indices into the Paths array. Its incoming; /// value is the indices of searches that stopped at the last phi optimization; /// target. It's left in an unspecified state.; ///; /// If this returns std::nullopt, NewPaused is a vector of searches that; /// terminated at StopWhere. Otherwise, NewPaused is left in an unspecified; /// state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:11,Security,access,access,11,"/// Get an access that keeps us from optimizing to the given phi.; ///; /// PausedSearches is an array of indices into the Paths array. Its incoming; /// value is the indices of searches that stopped at the last phi optimization; /// target. It's left in an unspecified state.; ///; /// If this returns std::nullopt, NewPaused is a vector of searches that; /// terminated at StopWhere. Otherwise, NewPaused is left in an unspecified; /// state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:76,Usability,Pause,PausedSearches,76,"/// Get an access that keeps us from optimizing to the given phi.; ///; /// PausedSearches is an array of indices into the Paths array. Its incoming; /// value is the indices of searches that stopped at the last phi optimization; /// target. It's left in an unspecified state.; ///; /// If this returns std::nullopt, NewPaused is a vector of searches that; /// terminated at StopWhere. Otherwise, NewPaused is left in an unspecified; /// state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:79,Usability,Pause,PausedSearches,79,"// BFS vs DFS really doesn't make a difference here, so just do a DFS with; // PausedSearches as our stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:472,Availability,down,down,472,"// If we've already visited this path with this MemoryLocation, we don't; // need to do so again.; //; // NOTE: That we just drop these paths on the ground makes caching; // behavior sporadic. e.g. given a diamond:; // A; // B C; // D; //; // ...If we walk D, B, A, C, we'll only cache the result of phi; // optimization for A, B, and D; C will be skipped because it dies here.; // This arguably isn't the worst thing ever, since:; // - We generally query things in a top-down order, so if we got below D; // without needing cache entries for {C, MemLoc}, then chances are; // that those cache entries would end up ultimately unused.; // - We still cache things for A, so C only needs to walk up a bit.; // If this behavior becomes problematic, we can fix without a ton of extra; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:280,Performance,cache,cache,280,"// If we've already visited this path with this MemoryLocation, we don't; // need to do so again.; //; // NOTE: That we just drop these paths on the ground makes caching; // behavior sporadic. e.g. given a diamond:; // A; // B C; // D; //; // ...If we walk D, B, A, C, we'll only cache the result of phi; // optimization for A, B, and D; C will be skipped because it dies here.; // This arguably isn't the worst thing ever, since:; // - We generally query things in a top-down order, so if we got below D; // without needing cache entries for {C, MemLoc}, then chances are; // that those cache entries would end up ultimately unused.; // - We still cache things for A, so C only needs to walk up a bit.; // If this behavior becomes problematic, we can fix without a ton of extra; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:308,Performance,optimiz,optimization,308,"// If we've already visited this path with this MemoryLocation, we don't; // need to do so again.; //; // NOTE: That we just drop these paths on the ground makes caching; // behavior sporadic. e.g. given a diamond:; // A; // B C; // D; //; // ...If we walk D, B, A, C, we'll only cache the result of phi; // optimization for A, B, and D; C will be skipped because it dies here.; // This arguably isn't the worst thing ever, since:; // - We generally query things in a top-down order, so if we got below D; // without needing cache entries for {C, MemLoc}, then chances are; // that those cache entries would end up ultimately unused.; // - We still cache things for A, so C only needs to walk up a bit.; // If this behavior becomes problematic, we can fix without a ton of extra; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:525,Performance,cache,cache,525,"// If we've already visited this path with this MemoryLocation, we don't; // need to do so again.; //; // NOTE: That we just drop these paths on the ground makes caching; // behavior sporadic. e.g. given a diamond:; // A; // B C; // D; //; // ...If we walk D, B, A, C, we'll only cache the result of phi; // optimization for A, B, and D; C will be skipped because it dies here.; // This arguably isn't the worst thing ever, since:; // - We generally query things in a top-down order, so if we got below D; // without needing cache entries for {C, MemLoc}, then chances are; // that those cache entries would end up ultimately unused.; // - We still cache things for A, so C only needs to walk up a bit.; // If this behavior becomes problematic, we can fix without a ton of extra; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:588,Performance,cache,cache,588,"// If we've already visited this path with this MemoryLocation, we don't; // need to do so again.; //; // NOTE: That we just drop these paths on the ground makes caching; // behavior sporadic. e.g. given a diamond:; // A; // B C; // D; //; // ...If we walk D, B, A, C, we'll only cache the result of phi; // optimization for A, B, and D; C will be skipped because it dies here.; // This arguably isn't the worst thing ever, since:; // - We generally query things in a top-down order, so if we got below D; // without needing cache entries for {C, MemLoc}, then chances are; // that those cache entries would end up ultimately unused.; // - We still cache things for A, so C only needs to walk up a bit.; // If this behavior becomes problematic, we can fix without a ton of extra; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:649,Performance,cache,cache,649,"// If we've already visited this path with this MemoryLocation, we don't; // need to do so again.; //; // NOTE: That we just drop these paths on the ground makes caching; // behavior sporadic. e.g. given a diamond:; // A; // B C; // D; //; // ...If we walk D, B, A, C, we'll only cache the result of phi; // optimization for A, B, and D; C will be skipped because it dies here.; // This arguably isn't the worst thing ever, since:; // - We generally query things in a top-down order, so if we got below D; // without needing cache entries for {C, MemLoc}, then chances are; // that those cache entries would end up ultimately unused.; // - We still cache things for A, so C only needs to walk up a bit.; // If this behavior becomes problematic, we can fix without a ton of extra; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:75,Availability,failure,failure,75,"// If this wasn't a cache hit, we hit a clobber when walking. That's a; // failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:20,Performance,cache,cache,20,"// If this wasn't a cache hit, we hit a clobber when walking. That's a; // failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:48,Performance,optimiz,optimize,48,"// Otherwise, it's a valid thing to potentially optimize to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:34,Performance,cache,cache,34,"/// The paths that we can legally cache back from, but that aren't; /// necessarily the result of the Phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:106,Performance,optimiz,optimization,106,"/// The paths that we can legally cache back from, but that aren't; /// necessarily the result of the Phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:7,Testability,assert,assert,7,// The assert looks nicer if we don't need to do &N,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:11,Performance,optimiz,optimize,11,"/// Try to optimize a phi as best as we can. Returns a SmallVector of Paths; /// that act as legal clobbers. Note that this won't return *all* clobbers.; ///; /// Phi optimization algorithm tl;dr:; /// - Find the earliest def/phi, A, we can optimize to; /// - Find if all paths from the starting memory access ultimately reach A; /// - If not, optimization isn't possible.; /// - Otherwise, walk from A to another clobber or phi, A'.; /// - If A' is a def, we're done.; /// - If A' is a phi, try to optimize it.; ///; /// A path is a series of {MemoryAccess, MemoryLocation} pairs. A path; /// terminates when a MemoryAccess that clobbers said MemoryLocation is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:167,Performance,optimiz,optimization,167,"/// Try to optimize a phi as best as we can. Returns a SmallVector of Paths; /// that act as legal clobbers. Note that this won't return *all* clobbers.; ///; /// Phi optimization algorithm tl;dr:; /// - Find the earliest def/phi, A, we can optimize to; /// - Find if all paths from the starting memory access ultimately reach A; /// - If not, optimization isn't possible.; /// - Otherwise, walk from A to another clobber or phi, A'.; /// - If A' is a def, we're done.; /// - If A' is a phi, try to optimize it.; ///; /// A path is a series of {MemoryAccess, MemoryLocation} pairs. A path; /// terminates when a MemoryAccess that clobbers said MemoryLocation is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:241,Performance,optimiz,optimize,241,"/// Try to optimize a phi as best as we can. Returns a SmallVector of Paths; /// that act as legal clobbers. Note that this won't return *all* clobbers.; ///; /// Phi optimization algorithm tl;dr:; /// - Find the earliest def/phi, A, we can optimize to; /// - Find if all paths from the starting memory access ultimately reach A; /// - If not, optimization isn't possible.; /// - Otherwise, walk from A to another clobber or phi, A'.; /// - If A' is a def, we're done.; /// - If A' is a phi, try to optimize it.; ///; /// A path is a series of {MemoryAccess, MemoryLocation} pairs. A path; /// terminates when a MemoryAccess that clobbers said MemoryLocation is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:344,Performance,optimiz,optimization,344,"/// Try to optimize a phi as best as we can. Returns a SmallVector of Paths; /// that act as legal clobbers. Note that this won't return *all* clobbers.; ///; /// Phi optimization algorithm tl;dr:; /// - Find the earliest def/phi, A, we can optimize to; /// - Find if all paths from the starting memory access ultimately reach A; /// - If not, optimization isn't possible.; /// - Otherwise, walk from A to another clobber or phi, A'.; /// - If A' is a def, we're done.; /// - If A' is a phi, try to optimize it.; ///; /// A path is a series of {MemoryAccess, MemoryLocation} pairs. A path; /// terminates when a MemoryAccess that clobbers said MemoryLocation is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:499,Performance,optimiz,optimize,499,"/// Try to optimize a phi as best as we can. Returns a SmallVector of Paths; /// that act as legal clobbers. Note that this won't return *all* clobbers.; ///; /// Phi optimization algorithm tl;dr:; /// - Find the earliest def/phi, A, we can optimize to; /// - Find if all paths from the starting memory access ultimately reach A; /// - If not, optimization isn't possible.; /// - Otherwise, walk from A to another clobber or phi, A'.; /// - If A' is a def, we're done.; /// - If A' is a phi, try to optimize it.; ///; /// A path is a series of {MemoryAccess, MemoryLocation} pairs. A path; /// terminates when a MemoryAccess that clobbers said MemoryLocation is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:303,Security,access,access,303,"/// Try to optimize a phi as best as we can. Returns a SmallVector of Paths; /// that act as legal clobbers. Note that this won't return *all* clobbers.; ///; /// Phi optimization algorithm tl;dr:; /// - Find the earliest def/phi, A, we can optimize to; /// - Find if all paths from the starting memory access ultimately reach A; /// - If not, optimization isn't possible.; /// - Otherwise, walk from A to another clobber or phi, A'.; /// - If A' is a def, we're done.; /// - If A' is a phi, try to optimize it.; ///; /// A path is a series of {MemoryAccess, MemoryLocation} pairs. A path; /// terminates when a MemoryAccess that clobbers said MemoryLocation is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:27,Performance,optimiz,optimization,27,"// Stores how many ""valid"" optimization nodes we had prior to calling; // addSearches/getBlockingAccess. Necessary for caching if we had a blocker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:75,Performance,optimiz,optimization,75,"// If a TerminatedPath doesn't dominate Target, then it wasn't a legal; // optimization for the prior phi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:31,Availability,reliab,reliably,31,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:477,Availability,reliab,reliably,477,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:40,Performance,cache,cache,40,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:146,Performance,optimiz,optimize,146,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:204,Performance,cache,cache,204,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:265,Performance,cache,cache,265,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:386,Performance,optimiz,optimization,386,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:412,Performance,cache,cache,412,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:486,Performance,cache,cache,486,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:856,Performance,cache,cache,856,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:899,Performance,cache,cache,899,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:1082,Performance,cache,cache,1082,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:1120,Performance,cache,cached,1120,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:1251,Performance,optimiz,optimization,1251,"// Two things:; // A. We can't reliably cache all of NewPaused back. Consider a case; // where we have two paths in NewPaused; one of which can't optimize; // above this phi, whereas the other can. If we cache the second path; // back, we'll end up with suboptimal cache entries. We can handle; // cases like this a bit better when we either try to find all; // clobbers that block phi optimization, or when our cache starts; // supporting unfinished searches.; // B. We can't reliably cache TerminatedPaths back here without doing; // extra checks; consider a case like:; // T; // / \; // D C; // \ /; // S; // Where T is our target, C is a node with a clobber on it, D is a; // diamond (with a clobber *only* on the left or right node, N), and; // S is our start. Say we walk to D, through the node opposite N; // (read: ignoring the clobber), and see a cache entry in the top; // node of D. That cache entry gets put into TerminatedPaths. We then; // walk up to C (N is later in our worklist), find the clobber, and; // quit. If we append TerminatedPaths to OtherClobbers, we'll cache; // the bottom part of D to the cached clobber, ignoring the clobber; // in N. Again, this problem goes away if we start tracking all; // blockers for a given phi optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:100,Performance,cache,cache,100,"// If there's nothing left to search, then all paths led to valid clobbers; // that we got from our cache; pick the nearest to the start, and allow; // the rest to be cached back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:167,Performance,cache,cached,167,"// If there's nothing left to search, then all paths led to valid clobbers; // that we got from our cache; pick the nearest to the start, and allow; // the rest to be cached back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:74,Performance,optimiz,optimize,74,"// If any of the terminated paths don't dominate the phi we'll try to; // optimize, we need to figure out what they are and quit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:51,Performance,optimiz,optimizing,51,"/// Finds the nearest clobber for the given query, optimizing phis if; /// possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:142,Performance,cache,cache,142,"// This walker pretends uses don't exist. If we're handed one, silently grab; // its def. (This has the nice side-effect of ensuring we never cache uses)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:54,Performance,optimiz,optimization,54,// Fast path for the overly-common case (no crazy phi optimization; // necessary),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:237,Deployability,update,updated,237,"// Third argument (bool), defines whether the clobber search should skip the; // original queried access. If true, there will be a follow-up query searching; // for a clobber access past ""self"". Note that the Optimized access is not; // updated if a new clobber is found by this SkipSelf search. If this; // additional query becomes heavily used we may decide to cache the result.; // Walker instantiations will decide how to set the SkipSelf bool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:209,Performance,Optimiz,Optimized,209,"// Third argument (bool), defines whether the clobber search should skip the; // original queried access. If true, there will be a follow-up query searching; // for a clobber access past ""self"". Note that the Optimized access is not; // updated if a new clobber is found by this SkipSelf search. If this; // additional query becomes heavily used we may decide to cache the result.; // Walker instantiations will decide how to set the SkipSelf bool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:363,Performance,cache,cache,363,"// Third argument (bool), defines whether the clobber search should skip the; // original queried access. If true, there will be a follow-up query searching; // for a clobber access past ""self"". Note that the Optimized access is not; // updated if a new clobber is found by this SkipSelf search. If this; // additional query becomes heavily used we may decide to cache the result.; // Walker instantiations will decide how to set the SkipSelf bool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:98,Security,access,access,98,"// Third argument (bool), defines whether the clobber search should skip the; // original queried access. If true, there will be a follow-up query searching; // for a clobber access past ""self"". Note that the Optimized access is not; // updated if a new clobber is found by this SkipSelf search. If this; // additional query becomes heavily used we may decide to cache the result.; // Walker instantiations will decide how to set the SkipSelf bool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:175,Security,access,access,175,"// Third argument (bool), defines whether the clobber search should skip the; // original queried access. If true, there will be a follow-up query searching; // for a clobber access past ""self"". Note that the Optimized access is not; // updated if a new clobber is found by this SkipSelf search. If this; // additional query becomes heavily used we may decide to cache the result.; // Walker instantiations will decide how to set the SkipSelf bool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:219,Security,access,access,219,"// Third argument (bool), defines whether the clobber search should skip the; // original queried access. If true, there will be a follow-up query searching; // for a clobber access past ""self"". Note that the Optimized access is not; // updated if a new clobber is found by this SkipSelf search. If this; // additional query becomes heavily used we may decide to cache the result.; // Walker instantiations will decide how to set the SkipSelf bool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:57,Security,access,accesses,57,"/// A MemorySSAWalker that does AA walks to disambiguate accesses. It no; /// longer does caching on its own, but the name has been retained for the; /// moment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:22,Security,access,accessible,22,// This method is not accessible outside of this file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:108,Security,access,accesses,108,"/// This is the standard SSA renaming algorithm.; ///; /// We walk the dominator tree in preorder, renaming accesses, and then filling; /// in phi nodes in our successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:35,Security,access,accesses,35,"/// This handles unreachable block accesses by deleting phi nodes in; /// unreachable blocks, and marking all other unreachable MemoryAccess's as; /// being uses of the live on entry definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:242,Energy Efficiency,reduce,reduce,242,"// Build MemorySSA using a batch alias analysis. This reuses the internal; // state that AA collects during an alias()/getModRefInfo() call. This is; // safe because there are no CFG changes while building MemorySSA and can; // significantly reduce the time spent by the compiler in AA, because we will; // make queries about all the instructions in the Function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:153,Safety,safe,safe,153,"// Build MemorySSA using a batch alias analysis. This reuses the internal; // state that AA collects during an alias()/getModRefInfo() call. This is; // safe because there are no CFG changes while building MemorySSA and can; // significantly reduce the time spent by the compiler in AA, because we will; // make queries about all the instructions in the Function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:298,Availability,down,down,298,"/// This class is a batch walker of all MemoryUse's in the program, and points; /// their defining access at the thing that actually clobbers them. Because it; /// is a batch walker that touches everything, it does not operate like the; /// other walkers. This walker is basically performing a top-down SSA renaming; /// pass, where the version stack is used as the cache. This enables it to be; /// significantly more time and memory efficient than using the regular walker,; /// which is walking bottom-up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:435,Energy Efficiency,efficient,efficient,435,"/// This class is a batch walker of all MemoryUse's in the program, and points; /// their defining access at the thing that actually clobbers them. Because it; /// is a batch walker that touches everything, it does not operate like the; /// other walkers. This walker is basically performing a top-down SSA renaming; /// pass, where the version stack is used as the cache. This enables it to be; /// significantly more time and memory efficient than using the regular walker,; /// which is walking bottom-up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:281,Performance,perform,performing,281,"/// This class is a batch walker of all MemoryUse's in the program, and points; /// their defining access at the thing that actually clobbers them. Because it; /// is a batch walker that touches everything, it does not operate like the; /// other walkers. This walker is basically performing a top-down SSA renaming; /// pass, where the version stack is used as the cache. This enables it to be; /// significantly more time and memory efficient than using the regular walker,; /// which is walking bottom-up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:366,Performance,cache,cache,366,"/// This class is a batch walker of all MemoryUse's in the program, and points; /// their defining access at the thing that actually clobbers them. Because it; /// is a batch walker that touches everything, it does not operate like the; /// other walkers. This walker is basically performing a top-down SSA renaming; /// pass, where the version stack is used as the cache. This enables it to be; /// significantly more time and memory efficient than using the regular walker,; /// which is walking bottom-up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:99,Security,access,access,99,"/// This class is a batch walker of all MemoryUse's in the program, and points; /// their defining access at the thing that actually clobbers them. Because it; /// is a batch walker that touches everything, it does not operate like the; /// other walkers. This walker is basically performing a top-down SSA renaming; /// pass, where the version stack is used as the cache. This enables it to be; /// significantly more time and memory efficient than using the regular walker,; /// which is walking bottom-up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:138,Integrability,depend,depends,138,"// This is the lower bound of places on the stack to check. It is equal to; // the place the last stack walk ended.; // Note: Correctness depends on this being initialized to 0, which densemap; // does",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:27,Performance,Optimiz,Optimize,27,"// end namespace llvm; /// Optimize the uses in a given block This is basically the SSA renaming; /// algorithm, with one caveat: We are able to use a single stack for all; /// MemoryUses. This is because the set of *possible* reaching MemoryDefs is; /// the same for every MemoryUse. The *actual* clobbering MemoryDef is just; /// going to be some position in that stack of possible ones.; ///; /// We track the stack positions that each MemoryLocation needs; /// to check, and last ended at. This is because we only want to check the; /// things that changed since last time. The same MemoryLocation should; /// get clobbered by the same store (getModRefInfo does not use invariantness or; /// things like this, and if they start, we can modify MemoryLocOrCall to; /// include relevant data)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:10,Security,access,accesses,10,"/// If no accesses, nothing to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:502,Performance,optimiz,optimization,502,"// If the lower bound was in something that no longer dominates us, we; // have to reset it.; // We can't simply track stack size, because the stack may have had; // pushes/pops in the meantime.; // XXX: This is non-optimal, but only is slower cases with heavily; // branching dominator trees. To get the optimal number of queries would; // be to make lowerbound and lastkill a per-loc stack, and pop it until; // the top of that stack dominates us. This does not seem worth it ATM.; // A much cheaper optimization would be to always explore the deepest; // branch of the dominator tree first. This will guarantee this resets on; // the smallest set of blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:106,Usability,simpl,simply,106,"// If the lower bound was in something that no longer dominates us, we; // have to reset it.; // We can't simply track stack size, because the stack may have had; // pushes/pops in the meantime.; // XXX: This is non-optimal, but only is slower cases with heavily; // branching dominator trees. To get the optimal number of queries would; // be to make lowerbound and lastkill a per-loc stack, and pop it until; // the top of that stack dominates us. This does not seem worth it ATM.; // A much cheaper optimization would be to always explore the deepest; // branch of the dominator tree first. This will guarantee this resets on; // the smallest set of blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:142,Deployability,update,updates,142,"// For phis, use the walker, see where we ended up, go there.; // The invariant.group handling in MemorySSA is ad-hoc and doesn't; // support updates, so don't use it to optimize uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:170,Performance,optimiz,optimize,170,"// For phis, use the walker, see where we ended up, go there.; // The invariant.group handling in MemorySSA is ad-hoc and doesn't; // support updates, so don't use it to optimize uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:4,Performance,Optimiz,Optimize,4,/// Optimize uses to point to their actual clobbering definitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:34,Availability,down,down,34,// We perform a non-recursive top-down dominator tree walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:6,Performance,perform,perform,6,// We perform a non-recursive top-down dominator tree walk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:16,Security,access,access,16,"// We create an access to represent ""live on entry"", for things like; // arguments or users of globals, where the memory they use is defined before; // the beginning of the function. We do not actually insert it into the IR.; // We do not define a live on exit for the immediate uses, and thus our; // semantics do *not* imply that something with no immediate uses can simply; // be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:369,Usability,simpl,simply,369,"// We create an access to represent ""live on entry"", for things like; // arguments or users of globals, where the memory they use is defined before; // the beginning of the function. We do not actually insert it into the IR.; // We do not define a live on exit for the immediate uses, and thus our; // semantics do *not* imply that something with no immediate uses can simply; // be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:31,Security,access,accesses,31,"// We maintain lists of memory accesses per-block, trading memory for time. We; // could just look up the memory access for every possible instruction in the; // stream.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:113,Security,access,access,113,"// We maintain lists of memory accesses per-block, trading memory for time. We; // could just look up the memory access for every possible instruction in the; // stream.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:86,Security,access,accesses,86,"// Go through each block, figure out where defs occur, and chain together all; // the accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:50,Integrability,rout,routines,50,"// This is a helper function used by the creation routines. It places NewAccess; // into the access and defs lists for a given basic block, at the given; // insertion point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:93,Security,access,access,93,"// This is a helper function used by the creation routines. It places NewAccess; // into the access and defs lists for a given basic block, at the given; // insertion point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:53,Performance,optimiz,optimized,53,"// Note that moving should implicitly invalidate the optimized state of a; // MemoryUse (and Phis can't be optimized). However, it doesn't do so for a; // MemoryDef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:107,Performance,optimiz,optimized,107,"// Note that moving should implicitly invalidate the optimized state of a; // MemoryUse (and Phis can't be optimized). However, it doesn't do so for a; // MemoryDef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:274,Deployability,update,updated,274,"// Move What before Where in the IR. The end result is that What will belong to; // the right lists and have the right Block set, but will not otherwise be; // correct. It will not have the right defining access, and if it is a def,; // things below it will not properly be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:205,Security,access,access,205,"// Move What before Where in the IR. The end result is that What will belong to; // the right lists and have the right Block set, but will not otherwise be; // correct. It will not have the right defining access, and if it is a def,; // things below it will not properly be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:3,Deployability,Update,Update,3,// Update lookup table entry,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:118,Performance,load,loads,118,// Return true if the instruction has ordering constraints.; // Note specifically that this only considers stores and loads; // because others are still considered ModRef by getModRefInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:41,Security,access,accesses,41,/// Helper function to create new memory accesses,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:190,Deployability,pipeline,pipeline,190,// The assume intrinsic has a control dependency which we model by claiming; // that it writes arbitrarily. Debuginfo intrinsics may be considered; // clobbers when we have a nonstandard AA pipeline. Ignore these fake memory; // dependencies here.; // FIXME: Replace this special casing with a more accurate modelling of; // assume's control dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:38,Integrability,depend,dependency,38,// The assume intrinsic has a control dependency which we model by claiming; // that it writes arbitrarily. Debuginfo intrinsics may be considered; // clobbers when we have a nonstandard AA pipeline. Ignore these fake memory; // dependencies here.; // FIXME: Replace this special casing with a more accurate modelling of; // assume's control dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:229,Integrability,depend,dependencies,229,// The assume intrinsic has a control dependency which we model by claiming; // that it writes arbitrarily. Debuginfo intrinsics may be considered; // clobbers when we have a nonstandard AA pipeline. Ignore these fake memory; // dependencies here.; // FIXME: Replace this special casing with a more accurate modelling of; // assume's control dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:342,Integrability,depend,dependency,342,// The assume intrinsic has a control dependency which we model by claiming; // that it writes arbitrarily. Debuginfo intrinsics may be considered; // clobbers when we have a nonstandard AA pipeline. Ignore these fake memory; // dependencies here.; // FIXME: Replace this special casing with a more accurate modelling of; // assume's control dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:26,Deployability,pipeline,pipelines,26,"// Using a nonstandard AA pipelines might leave us with unexpected modref; // results for I, so add a check to not model instructions that may not read; // from or write to memory. This is necessary for correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:34,Energy Efficiency,reduce,reduced,34,// Memory accesses should only be reduced and can not be increased since AA; // just might return better results as a result of some transformations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:10,Security,access,accesses,10,// Memory accesses should only be reduced and can not be increased since AA; // just might return better results as a result of some transformations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:35,Energy Efficiency,power,power,35,// New Access should not have more power than template access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:7,Security,Access,Access,7,// New Access should not have more power than template access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:55,Security,access,access,55,// New Access should not have more power than template access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:356,Performance,load,loads,356,"// The isOrdered check is used to ensure that volatiles end up as defs; // (atomics end up as ModRef right now anyway). Until we separate the; // ordering chain from the memory chain, this enables people to see at least; // some relative ordering to volatiles. Note that getClobberingMemoryAccess; // will still give an answer that bypasses other volatile loads. TODO:; // Separate memory aliasing and ordering into two different chains so that; // we can precisely represent both ""what memory will this read/write/is; // clobbered by"" and ""what instructions can I move this past"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:27,Performance,cache,cache,27,// Invalidate our walker's cache if necessary,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:242,Security,access,access,242,"/// Properly remove \p MA from all of MemorySSA's lists.; ///; /// Because of the way the intrusive list and use lists work, it is important to; /// do removal in the right order.; /// ShouldDelete defaults to true, and will cause the memory access to also be; /// deleted, not just removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:7,Security,access,access,7,"// The access list owns the reference, so we erase it from the non-owning list; // first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:82,Performance,cache,cached,82,"// Previously, the verification used to also verify that the clobberingAccess; // cached by MemorySSA is the same as the clobberingAccess found at a later; // query to AA. This does not hold true in general due to the current fragility; // of BasicAA which has arbitrary caps on the things it analyzes before giving; // up. As a result, transformations that are correct, will lead to BasicAA; // returning different Alias answers before and after that transformation.; // Invalidating MemorySSA is not an option, as the results in BasicAA can be so; // random, in the worst case we'd need to rebuild MemorySSA from scratch after; // every transformation, which defeats the purpose of using it. For such an; // example, see test4 added in D51960.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:187,Security,access,access,187,"// If Pred has no unreachable predecessors, get last def looking at; // IDoms. If, while walkings IDoms, any of these has an unreachable; // predecessor, then the incoming def can be any access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:171,Deployability,update,update,171,"// If Pred has unreachable predecessors, but has at least a Def, the; // incoming access can be the last Def in Pred, or it could have been; // optimized to LoE. After an update, though, the LoE may have been; // replaced by another access, so IncAcc may be any access.; // If Pred has unreachable predecessors and no Defs, incoming access; // should be LoE; However, after an update, it may be any access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:377,Deployability,update,update,377,"// If Pred has unreachable predecessors, but has at least a Def, the; // incoming access can be the last Def in Pred, or it could have been; // optimized to LoE. After an update, though, the LoE may have been; // replaced by another access, so IncAcc may be any access.; // If Pred has unreachable predecessors and no Defs, incoming access; // should be LoE; However, after an update, it may be any access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:144,Performance,optimiz,optimized,144,"// If Pred has unreachable predecessors, but has at least a Def, the; // incoming access can be the last Def in Pred, or it could have been; // optimized to LoE. After an update, though, the LoE may have been; // replaced by another access, so IncAcc may be any access.; // If Pred has unreachable predecessors and no Defs, incoming access; // should be LoE; However, after an update, it may be any access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:82,Security,access,access,82,"// If Pred has unreachable predecessors, but has at least a Def, the; // incoming access can be the last Def in Pred, or it could have been; // optimized to LoE. After an update, though, the LoE may have been; // replaced by another access, so IncAcc may be any access.; // If Pred has unreachable predecessors and no Defs, incoming access; // should be LoE; However, after an update, it may be any access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:233,Security,access,access,233,"// If Pred has unreachable predecessors, but has at least a Def, the; // incoming access can be the last Def in Pred, or it could have been; // optimized to LoE. After an update, though, the LoE may have been; // replaced by another access, so IncAcc may be any access.; // If Pred has unreachable predecessors and no Defs, incoming access; // should be LoE; However, after an update, it may be any access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:262,Security,access,access,262,"// If Pred has unreachable predecessors, but has at least a Def, the; // incoming access can be the last Def in Pred, or it could have been; // optimized to LoE. After an update, though, the LoE may have been; // replaced by another access, so IncAcc may be any access.; // If Pred has unreachable predecessors and no Defs, incoming access; // should be LoE; However, after an update, it may be any access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:333,Security,access,access,333,"// If Pred has unreachable predecessors, but has at least a Def, the; // incoming access can be the last Def in Pred, or it could have been; // optimized to LoE. After an update, though, the LoE may have been; // replaced by another access, so IncAcc may be any access.; // If Pred has unreachable predecessors and no Defs, incoming access; // should be LoE; However, after an update, it may be any access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:399,Security,access,access,399,"// If Pred has unreachable predecessors, but has at least a Def, the; // incoming access can be the last Def in Pred, or it could have been; // optimized to LoE. After an update, though, the LoE may have been; // replaced by another access, so IncAcc may be any access.; // If Pred has unreachable predecessors and no Defs, incoming access; // should be LoE; However, after an update, it may be any access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:280,Security,access,accesses,280,"/// Verify ordering: the order and existence of MemoryAccesses matches the; /// order and existence of memory affecting instructions.; /// Verify domination: each definition dominates all of its uses.; /// Verify def-uses: the immediate use information - walk all the memory; /// accesses and verifying that, for each use, it appears in the appropriate; /// def's use list",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:70,Security,access,access,70,"// Walk all the blocks, comparing what the lookups think and what the access; // lists think, as well as the order in the blocks vs the order in the access; // lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:149,Security,access,access,149,"// Walk all the blocks, comparing what the lookups think and what the access; // lists think, as well as the order in the blocks vs the order in the access; // lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:44,Security,access,accesses,44,"// Either we hit the assert, really have no accesses, or we have both; // accesses and an access list. Same with defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:74,Security,access,accesses,74,"// Either we hit the assert, really have no accesses, or we have both; // accesses and an access list. Same with defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:90,Security,access,access,90,"// Either we hit the assert, really have no accesses, or we have both; // accesses and an access list. Same with defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:21,Testability,assert,assert,21,"// Either we hit the assert, really have no accesses, or we have both; // accesses and an access list. Same with defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:4,Performance,Perform,Perform,4,"/// Perform a local numbering on blocks so that instruction ordering can be; /// determined in constant time.; /// TODO: We currently just number in order. If we numbered by N, we could; /// allow at least N-1 sequences of insertBefore or insertAfter (and at least; /// log2(N) sequences of mixed before and after) without needing to invalidate; /// the numbering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:30,Security,access,accesses,30,"/// Determine, for two memory accesses in the same block,; /// whether \p Dominator dominates \p Dominatee.; /// \returns True if \p Dominator dominates \p Dominatee.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:90,Security,access,access,90,"// When Dominatee is defined on function entry, it is not dominated by another; // memory access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:82,Security,access,access,82,"// When Dominator is defined on function entry, it dominates the other memory; // access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:53,Deployability,release,release,53,// Cannot completely remove virtual function even in release mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:158,Security,access,access,158,/// Walk the use-def chains starting at \p StartingAccess and find; /// the MemoryAccess that actually clobbers Loc.; ///; /// \returns our clobbering memory access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:60,Security,access,access,60,"// If location is undefined, conservatively return starting access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:56,Performance,perform,perform,56,"// Conservatively, fences are always clobbers, so don't perform the walk if; // we hit a fence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:136,Security,access,access,136,"// Unlike the other function, do not walk to the def of a def, because we are; // handed something we already believe is the clobbering access.; // We never set SkipSelf to true in Q in this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:148,Performance,load,loads,148,"// We consider bitcasts and zero GEPs to be the same pointer value. Start by; // stripping bitcasts and zero GEPs, then we will recursively look at loads; // and stores through bitcasts and zero GEPs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:12,Safety,safe,safe,12,// It's not safe to walk the use list of a global value because function; // passes aren't allowed to look outside their functions.; // FIXME: this could be fixed by filtering instructions from outside of; // current function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:3,Performance,Queue,Queue,3,// Queue to process all pointers that are equivalent to load operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:56,Performance,load,load,56,// Queue to process all pointers that are equivalent to load operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:214,Deployability,update,updates,214,"// FIXME: This loop is O(n^2) because dominates can be O(n) and in worst case; // we will see all the instructions. It may not matter in practice. If it; // does, we will have to support MemorySSA construction and updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:33,Performance,queue,queue,33,// Add bitcasts and zero GEPs to queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:15,Performance,load,load,15,"// If we hit a load/store with an invariant.group metadata and the same; // pointer operand, we can assume that value pointed to by the pointer; // operand didn't change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:25,Performance,optimiz,optimized,25,"// If this is an already optimized use or def, return the optimized result.; // Note: Currently, we store the optimized def result in a separate field,; // since we can't use the defining access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:58,Performance,optimiz,optimized,58,"// If this is an already optimized use or def, return the optimized result.; // Note: Currently, we store the optimized def result in a separate field,; // since we can't use the defining access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:110,Performance,optimiz,optimized,110,"// If this is an already optimized use or def, return the optimized result.; // Note: Currently, we store the optimized def result in a separate field,; // since we can't use the defining access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:188,Security,access,access,188,"// If this is an already optimized use or def, return the optimized result.; // Note: Currently, we store the optimized def result in a separate field,; // since we can't use the defining access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:42,Deployability,Update,Updater,42,"//===-- MemorySSAUpdater.cpp - Memory SSA Updater--------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------===//; //; // This file implements the MemorySSAUpdater class.; //; //===----------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:49,Energy Efficiency,Efficient,Efficient,49,"// This is the marker algorithm from ""Simple and Efficient Construction of; // Static Single Assignment Form""; // The simple, non-marker algorithm places phi nodes at any join; // Here, we place markers, and only place phi nodes if they end up necessary.; // They are only necessary if they break a cycle (IE we recursively visit; // ourselves again), or we discover, while getting the value of the operands,; // that there are two or more definitions needing to be merged.; // This still will leave non-minimal form in the case of irreducible control; // flow, where phi nodes may be in cycles with themselves, but unnecessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:38,Usability,Simpl,Simple,38,"// This is the marker algorithm from ""Simple and Efficient Construction of; // Static Single Assignment Form""; // The simple, non-marker algorithm places phi nodes at any join; // Here, we place markers, and only place phi nodes if they end up necessary.; // They are only necessary if they break a cycle (IE we recursively visit; // ourselves again), or we discover, while getting the value of the operands,; // that there are two or more definitions needing to be merged.; // This still will leave non-minimal form in the case of irreducible control; // flow, where phi nodes may be in cycles with themselves, but unnecessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:118,Usability,simpl,simple,118,"// This is the marker algorithm from ""Simple and Efficient Construction of; // Static Single Assignment Form""; // The simple, non-marker algorithm places phi nodes at any join; // Here, we place markers, and only place phi nodes if they end up necessary.; // They are only necessary if they break a cycle (IE we recursively visit; // ourselves again), or we discover, while getting the value of the operands,; // that there are two or more definitions needing to be merged.; // This still will leave non-minimal form in the case of irreducible control; // flow, where phi nodes may be in cycles with themselves, but unnecessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:15,Performance,cache,cache,15,"// First, do a cache lookup. Without this cache, certain CFG structures; // (like a series of if statements) take exponential time to visit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:42,Performance,cache,cache,42,"// First, do a cache lookup. Without this cache, certain CFG structures; // (like a series of if statements) take exponential time to visit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:29,Safety,detect,detect,29,// Mark us visited so we can detect a cycle,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:34,Safety,avoid,avoid,34,"// Now try to simplify the ops to avoid placing a phi.; // This may return null if we never created a phi yet, that's okay",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:14,Usability,simpl,simplify,14,"// Now try to simplify the ops to avoid placing a phi.; // This may return null if we never created a phi yet, that's okay",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:17,Safety,avoid,avoid,17,// See if we can avoid the phi by simplifying it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:34,Usability,simpl,simplifying,34,// See if we can avoid the phi by simplifying it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:18,Usability,simpl,simplify,18,"// If we couldn't simplify, we may have to create a phi",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:33,Modifiability,variab,variable,33,// Set ourselves up for the next variable by resetting visited state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:29,Security,access,access,29,"// This starts at the memory access, and goes backwards in the block to find the; // previous definition. If a definition is not found the block of the access,; // it continues globally, creating phi nodes to ensure we have a single; // definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:152,Security,access,access,152,"// This starts at the memory access, and goes backwards in the block to find the; // previous definition. If a definition is not found the block of the access,; // it continues globally, creating phi nodes to ensure we have a single; // definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:29,Security,access,access,29,"// This starts at the memory access, and goes backwards in the block to the find; // the previous definition. If the definition is not found in the block of the; // access, it returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:165,Security,access,access,165,"// This starts at the memory access, and goes backwards in the block to the find; // the previous definition. If the definition is not found in the block of the; // access, it returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:35,Security,access,access,35,"// Otherwise, have to walk the all access iterator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:3,Safety,Detect,Detect,3,// Detect equal or self arguments,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:421,Performance,optimiz,optimized,421,"// In cases without unreachable blocks, because uses do not create new; // may-defs, there are only two cases:; // 1. There was a def already below us, and therefore, we should not have; // created a phi node because it was already needed for the def.; //; // 2. There is no def below us, and therefore, there is no extra renaming work; // to do.; // In cases with unreachable blocks, where the unnecessary Phis were; // optimized out, adding the Use may re-insert those Phis. Hence, when; // inserting Uses outside of the MSSA creation process, and new Phis were; // added, rename all uses if we are asked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:75,Security,access,access,75,// Replace any operand with us an incoming block with the new defining; // access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:150,Deployability,update,update,150,"// A brief description of the algorithm:; // First, we compute what should define the new def, using the SSA; // construction algorithm.; // Then, we update the defs below us (and any new phi nodes) in the graph to; // point to the correct new defs, to ensure we only have one variable, and no; // disconnected stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:277,Modifiability,variab,variable,277,"// A brief description of the algorithm:; // First, we compute what should define the new def, using the SSA; // construction algorithm.; // Then, we update the defs below us (and any new phi nodes) in the graph to; // point to the correct new defs, to ensure we only have one variable, and no; // disconnected stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:71,Safety,avoid,avoid,71,// Leave the MemoryUses alone.; // Also make sure we skip ourselves to avoid self references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:36,Security,access,access,36,// and that def is now our defining access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:240,Deployability,update,update,240,"// If there was a local def before us, we must have the same effect it; // did. Because every may-def is the same, any phis/etc we would create, it; // would also have created. If there was no local def before us, we; // performed a global update, and have to search all successors and make; // sure we update the first def in each of them (following all paths until; // we hit the first def along each path). This may also insert phi nodes.; // TODO: There are other cases we can skip this work, such as when we have a; // single successor, and only used a straight line of single pred blocks; // backwards to find the def. To make that work, we'd have to track whether; // getDefRecursive only ever used the single predecessor case. These types; // of paths also only exist in between CFG simplifications.; // If this is the first def in the block and this insert is in an arbitrary; // place, compute IDF and place phis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:303,Deployability,update,update,303,"// If there was a local def before us, we must have the same effect it; // did. Because every may-def is the same, any phis/etc we would create, it; // would also have created. If there was no local def before us, we; // performed a global update, and have to search all successors and make; // sure we update the first def in each of them (following all paths until; // we hit the first def along each path). This may also insert phi nodes.; // TODO: There are other cases we can skip this work, such as when we have a; // single successor, and only used a straight line of single pred blocks; // backwards to find the def. To make that work, we'd have to track whether; // getDefRecursive only ever used the single predecessor case. These types; // of paths also only exist in between CFG simplifications.; // If this is the first def in the block and this insert is in an arbitrary; // place, compute IDF and place phis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:221,Performance,perform,performed,221,"// If there was a local def before us, we must have the same effect it; // did. Because every may-def is the same, any phis/etc we would create, it; // would also have created. If there was no local def before us, we; // performed a global update, and have to search all successors and make; // sure we update the first def in each of them (following all paths until; // we hit the first def along each path). This may also insert phi nodes.; // TODO: There are other cases we can skip this work, such as when we have a; // single successor, and only used a straight line of single pred blocks; // backwards to find the def. To make that work, we'd have to track whether; // getDefRecursive only ever used the single predecessor case. These types; // of paths also only exist in between CFG simplifications.; // If this is the first def in the block and this insert is in an arbitrary; // place, compute IDF and place phis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:791,Usability,simpl,simplifications,791,"// If there was a local def before us, we must have the same effect it; // did. Because every may-def is the same, any phis/etc we would create, it; // would also have created. If there was no local def before us, we; // performed a global update, and have to search all successors and make; // sure we update the first def in each of them (following all paths until; // we hit the first def along each path). This may also insert phi nodes.; // TODO: There are other cases we can skip this work, such as when we have a; // single successor, and only used a straight line of single pred blocks; // backwards to find the def. To make that work, we'd have to track whether; // getDefRecursive only ever used the single predecessor case. These types; // of paths also only exist in between CFG simplifications.; // If this is the first def in the block and this insert is in an arbitrary; // place, compute IDF and place phis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:245,Performance,optimiz,optimized,245,"// If this is the last Def in the block, we may need additional Phis.; // Compute IDF in all cases, as renaming needs to be done even when MD is; // not the last access, because it can introduce a new access past which a; // previous access was optimized; that access needs to be reoptimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:162,Security,access,access,162,"// If this is the last Def in the block, we may need additional Phis.; // Compute IDF in all cases, as renaming needs to be done even when MD is; // not the last access, because it can introduce a new access past which a; // previous access was optimized; that access needs to be reoptimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:201,Security,access,access,201,"// If this is the last Def in the block, we may need additional Phis.; // Compute IDF in all cases, as renaming needs to be done even when MD is; // not the last access, because it can introduce a new access past which a; // previous access was optimized; that access needs to be reoptimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:234,Security,access,access,234,"// If this is the last Def in the block, we may need additional Phis.; // Compute IDF in all cases, as renaming needs to be done even when MD is; // not the last access, because it can introduce a new access past which a; // previous access was optimized; that access needs to be reoptimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:261,Security,access,access,261,"// If this is the last Def in the block, we may need additional Phis.; // Compute IDF in all cases, as renaming needs to be done even when MD is; // not the last access, because it can introduce a new access past which a; // previous access was optimized; that access needs to be reoptimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:79,Performance,optimiz,optimized,79,"// Add the phis created into the IDF blocks to NonOptPhis, so they are not; // optimized out as trivial by the call to getPreviousDefFromEnd below.; // Once they are complete, all these Phis are added to the FixupList, and; // removed from NonOptPhis inside fixupDefs(). Existing Phis in IDF may; // need fixing as well, and potentially be trivial before this insertion,; // hence add all IDF Phis. See PR43044.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:3,Performance,Optimiz,Optimize,3,// Optimize potentially non-minimal phis added in this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:78,Performance,optimiz,optimized,78,"// Existing Phi blocks may need renaming too, if an access was previously; // optimized and the inserted Defs ""covers"" the Optimized value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:123,Performance,Optimiz,Optimized,123,"// Existing Phi blocks may need renaming too, if an access was previously; // optimized and the inserted Defs ""covers"" the Optimized value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:52,Security,access,access,52,"// Existing Phi blocks may need renaming too, if an access was previously; // optimized and the inserted Defs ""covers"" the Optimized value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:58,Performance,optimiz,optimize,58,"// The temporary Phi is being fixed, unmark it for not to optimize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:32,Availability,down,down,32,"// Otherwise, we need to search down through the CFG.; // For each of our successors, handle it directly if their is a phi, or; // place on the fixup worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:34,Security,access,access,34,"// We are now this def's defining access, make sure we actually dominate; // it",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:119,Integrability,depend,depending,119,"// This may insert new phi nodes, because we are not guaranteed the; // block we are processing has a single pred, and depending where the; // store was inserted, it may require phi nodes below it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:17,Usability,simpl,simplified,17,"// The clone was simplified, it's no longer a MemoryDef, look up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:458,Deployability,update,updateForClonedBlockIntoPred,458,"// Entry does not exist if the clone of the block did not clone all; // instructions. This occurs in LoopRotate when cloning instructions; // from the old header to the old preheader. The cloned instruction may; // also be a simplified Value, not an Instruction (see LoopRotate).; // Also in LoopRotate, even when it's an instruction, due to it being; // simplified, it may be a Use rather than a Def, so we cannot use MUD as; // template. Calls coming from updateForClonedBlockIntoPred, ensure this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:225,Usability,simpl,simplified,225,"// Entry does not exist if the clone of the block did not clone all; // instructions. This occurs in LoopRotate when cloning instructions; // from the old header to the old preheader. The cloned instruction may; // also be a simplified Value, not an Instruction (see LoopRotate).; // Also in LoopRotate, even when it's an instruction, due to it being; // simplified, it may be a Use rather than a Def, so we cannot use MUD as; // template. Calls coming from updateForClonedBlockIntoPred, ensure this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:355,Usability,simpl,simplified,355,"// Entry does not exist if the clone of the block did not clone all; // instructions. This occurs in LoopRotate when cloning instructions; // from the old header to the old preheader. The cloned instruction may; // also be a simplified Value, not an Instruction (see LoopRotate).; // Also in LoopRotate, even when it's an instruction, due to it being; // simplified, it may be a Use rather than a Def, so we cannot use MUD as; // template. Calls coming from updateForClonedBlockIntoPred, ensure this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:3,Deployability,Update,Update,3,// Update incoming edges into MPhi. Remove all but the incoming edge from; // Preheader. Add an edge from NewMPhi,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:3,Deployability,Update,Update,3,// Update Uses and Defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:475,Security,access,access,475,"// All defs/phis from outside BB that are used in BB, are valid uses in P1.; // Since those defs/phis must have dominated BB, and also dominate P1.; // Defs from BB being used in BB will be replaced with the cloned defs from; // VM. The uses of BB's Phi (if it exists) in BB will be replaced by the; // incoming def into the Phi from P1.; // Instructions cloned into the predecessor are in practice sometimes; // simplified, so disable the use of the template, and create an access from; // scratch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:413,Usability,simpl,simplified,413,"// All defs/phis from outside BB that are used in BB, are valid uses in P1.; // Since those defs/phis must have dominated BB, and also dominate P1.; // Defs from BB being used in BB will be replaced with the cloned defs from; // VM. The uses of BB's Phi (if it exists) in BB will be replaced by the; // incoming def into the Phi from P1.; // Instructions cloned into the predecessor are in practice sometimes; // simplified, so disable the use of the template, and create an access from; // scratch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:3,Deployability,Update,Update,3,// Update/insert phis in all successors of exit blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:13,Deployability,update,updates,13,"// Apply all updates, with the RevDeleteUpdates as PostCFGView.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:18,Deployability,update,update,18,"// Note: the MSSA update below doesn't distinguish between a GD with; // (RevDelete,false) and (Delete, true), but this matters for the DT; // updates above; for ""children"" purposes they are equivalent; but the; // updates themselves convey the desired update, used inside DT only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:143,Deployability,update,updates,143,"// Note: the MSSA update below doesn't distinguish between a GD with; // (RevDelete,false) and (Delete, true), but this matters for the DT; // updates above; for ""children"" purposes they are equivalent; but the; // updates themselves convey the desired update, used inside DT only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:215,Deployability,update,updates,215,"// Note: the MSSA update below doesn't distinguish between a GD with; // (RevDelete,false) and (Delete, true), but this matters for the DT; // updates above; for ""children"" purposes they are equivalent; but the; // updates themselves convey the desired update, used inside DT only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:253,Deployability,update,update,253,"// Note: the MSSA update below doesn't distinguish between a GD with; // (RevDelete,false) and (Delete, true), but this matters for the DT; // updates above; for ""children"" purposes they are equivalent; but the; // updates themselves convey the desired update, used inside DT only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:3,Deployability,Update,Update,3,// Update DT to redelete edges; this matches the real CFG so we can; // perform the standard update without a postview of the CFG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:93,Deployability,update,update,93,// Update DT to redelete edges; this matches the real CFG so we can; // perform the standard update without a postview of the CFG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:72,Performance,perform,perform,72,// Update DT to redelete edges; this matches the real CFG so we can; // perform the standard update without a postview of the CFG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:3,Deployability,Update,Update,3,// Update for deleted edges,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:57,Deployability,update,updated,57,"// Get recursive last Def, assuming well formed MSSA and updated DT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:4,Usability,Simpl,SimpleLoopUnswitch,4,"// [SimpleLoopUnswitch] If BB is a dead block, about to be deleted, its; // DT is invalidated. Return LoE as its last def. This will be added to; // MemoryPhi node, and later deleted when the block is deleted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:65,Performance,optimiz,optimized,65,// Get nearest IDom given a set of blocks.; // TODO: this can be optimized by starting the search at the node with the; // lowest level (highest in the tree).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:184,Deployability,Update,Updates,184,"// Map a BB to its predecessors: added + previously existing. To get a; // deterministic order, store predecessors as SetVectors. The order in each; // will be defined by the order in Updates (fixed) and the order given by; // children<> (also fixed). Since we further iterate over these ordered sets,; // we lose the information of multiple edges possibly existing between two; // blocks, so we'll keep and EdgeCount map for that.; // An alternate implementation could keep unordered set for the predecessors,; // traverse either Updates or children<> each time to get the deterministic; // order, and drop the usage of EdgeCount. This alternate approach would still; // require querying the maps for each predecessor, and children<> call has; // additional computation inside for creating the snapshot-graph predecessors.; // As such, we favor using a little additional storage and less compute time.; // This decision can be revisited if we find the alternative more favorable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:531,Deployability,Update,Updates,531,"// Map a BB to its predecessors: added + previously existing. To get a; // deterministic order, store predecessors as SetVectors. The order in each; // will be defined by the order in Updates (fixed) and the order given by; // children<> (also fixed). Since we further iterate over these ordered sets,; // we lose the information of multiple edges possibly existing between two; // blocks, so we'll keep and EdgeCount map for that.; // An alternate implementation could keep unordered set for the predecessors,; // traverse either Updates or children<> each time to get the deterministic; // order, and drop the usage of EdgeCount. This alternate approach would still; // require querying the maps for each predecessor, and children<> call has; // additional computation inside for creating the snapshot-graph predecessors.; // As such, we favor using a little additional storage and less compute time.; // This decision can be revisited if we find the alternative more favorable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:95,Deployability,Update,Updates,95,"// First create MemoryPhis in all blocks that don't have one. Create in the; // order found in Updates, not in PredMap, to get deterministic numbering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:292,Deployability,update,updated,292,"// TODO: if this becomes a bottleneck, we can save on GetLastDef calls by; // keeping this map before the loop. We can reuse already populated entries; // if an edge is added from the same predecessor to two different blocks,; // and this does happen in rotate. Note that the map needs to be updated; // when deleting non-necessary phis below, if the phi is in the map by; // replacing the value with DefP1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:27,Performance,bottleneck,bottleneck,27,"// TODO: if this becomes a bottleneck, we can save on GetLastDef calls by; // keeping this map before the loop. We can reuse already populated entries; // if an edge is added from the same predecessor to two different blocks,; // and this does happen in rotate. Note that the map needs to be updated; // when deleting non-necessary phis below, if the phi is in the map by; // replacing the value with DefP1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:3,Deployability,Update,Update,3,"// Update Phi with new values for new predecessors and old value for all; // other predecessors. Since AddedBlockSet and PrevBlockSet are ordered; // sets, the order of entries in NewPhi is deterministic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:8,Deployability,update,update,8,// Then update or insert their correct incoming values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:55,Availability,redundant,redundant,55,"// Update existing Phi.; // FIXME: some updates may be redundant, try to optimize and skip some.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:3,Deployability,Update,Update,3,"// Update existing Phi.; // FIXME: some updates may be redundant, try to optimize and skip some.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:40,Deployability,update,updates,40,"// Update existing Phi.; // FIXME: some updates may be redundant, try to optimize and skip some.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:73,Performance,optimiz,optimize,73,"// Update existing Phi.; // FIXME: some updates may be redundant, try to optimize and skip some.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:55,Safety,redund,redundant,55,"// Update existing Phi.; // FIXME: some updates may be redundant, try to optimize and skip some.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:161,Deployability,update,update,161,"// Now for all defs in BlocksWithDefsToReplace, if there are uses they no; // longer dominate, replace those with the closest dominating def.; // This will also update optimized accesses, as they're also uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:168,Performance,optimiz,optimized,168,"// Now for all defs in BlocksWithDefsToReplace, if there are uses they no; // longer dominate, replace those with the closest dominating def.; // This will also update optimized accesses, as they're also uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:178,Security,access,accesses,178,"// Now for all defs in BlocksWithDefsToReplace, if there are uses they no; // longer dominate, replace those with the closest dominating def.; // This will also update optimized accesses, as they're also uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:42,Performance,optimiz,optimized,42,// Mark MemoryPhi users of What not to be optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:43,Security,access,access,43,// Replace all our users with our defining access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:3,Usability,Clear,Clear,3,"// Clear dangling pointers. We added all MemoryPhi users, but not all; // of them are removed by fixupDefs().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:58,Deployability,update,update,58,// All accesses in To used to be in From. Move to end and update access lists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:7,Security,access,accesses,7,// All accesses in To used to be in From. Move to end and update access lists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:65,Security,access,access,65,// All accesses in To used to be in From. Move to end and update access lists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:10,Security,access,accesses,10,"// If all accesses were moved and only a trivial Phi remains, we try to remove; // that Phi. This is needed when From is going to be deleted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:298,Testability,assert,assert,298,"// Note that it is sufficient to know that all edges of the phi node have; // the same argument. If they do, by the definition of dominance frontiers; // (which we used to place this phi), that argument must dominate this phi,; // and thus, must dominate the phi's uses, and so we will not hit the assert; // below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:37,Security,access,access,37,// Re-point the uses at our defining access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:9,Performance,optimiz,optimized,9,"// Reset optimized on users of this store, and reset the uses.; // A few notes:; // 1. This is a slightly modified version of RAUW to avoid walking the; // uses twice here.; // 2. If we wanted to be complete, we would have to reset the optimized; // flags on users of phi nodes if doing the below makes a phi node have all; // the same arguments. Instead, we prefer users to removeMemoryAccess those; // phi nodes, because doing it here would be N^3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:236,Performance,optimiz,optimized,236,"// Reset optimized on users of this store, and reset the uses.; // A few notes:; // 1. This is a slightly modified version of RAUW to avoid walking the; // uses twice here.; // 2. If we wanted to be complete, we would have to reset the optimized; // flags on users of phi nodes if doing the below makes a phi node have all; // the same arguments. Instead, we prefer users to removeMemoryAccess those; // phi nodes, because doing it here would be N^3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:134,Safety,avoid,avoid,134,"// Reset optimized on users of this store, and reset the uses.; // A few notes:; // 1. This is a slightly modified version of RAUW to avoid walking the; // uses twice here.; // 2. If we wanted to be complete, we would have to reset the optimized; // flags on users of phi nodes if doing the below makes a phi node have all; // the same arguments. Instead, we prefer users to removeMemoryAccess those; // phi nodes, because doing it here would be N^3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:14,Performance,optimiz,optimize,14,// Optionally optimize Phi uses. This will recursively remove trivial phis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:30,Security,access,accesses,30,// Drop all references of all accesses in BB,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:27,Security,access,accesses,27,"// Next, delete all memory accesses in each block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:17,Security,access,accesses,17,// Remove memory accesses in BB for I and all following instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:95,Security,access,access,95,"// FIXME: If this becomes too expensive, iterate until the first instruction; // with a memory access, then iterate over MemoryAccesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:3,Deployability,Update,Update,3,// Update phis in BB's successors to remove BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:3,Performance,Optimiz,Optimize,3,// Optimize trivial phis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:536,Deployability,release,release,536,"//===- MLInlineAdvisor.cpp - machine learned InlineAdvisor ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the interface between the inliner and a learned model.; // It delegates model evaluation to either the AOT compiled model (the; // 'release' mode) or a runtime-loaded model (the 'development' case).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:408,Integrability,interface,interface,408,"//===- MLInlineAdvisor.cpp - machine learned InlineAdvisor ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the interface between the inliner and a learned model.; // It delegates model evaluation to either the AOT compiled model (the; // 'release' mode) or a runtime-loaded model (the 'development' case).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:564,Performance,load,loaded,564,"//===- MLInlineAdvisor.cpp - machine learned InlineAdvisor ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the interface between the inliner and a learned model.; // It delegates model evaluation to either the AOT compiled model (the; // 'release' mode) or a runtime-loaded model (the 'development' case).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:37,Usability,learn,learned,37,"//===- MLInlineAdvisor.cpp - machine learned InlineAdvisor ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the interface between the inliner and a learned model.; // It delegates model evaluation to either the AOT compiled model (the; // 'release' mode) or a runtime-loaded model (the 'development' case).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:444,Usability,learn,learned,444,"//===- MLInlineAdvisor.cpp - machine learned InlineAdvisor ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the interface between the inliner and a learned model.; // It delegates model evaluation to either the AOT compiled model (the; // 'release' mode) or a runtime-loaded model (the 'development' case).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:196,Deployability,pipeline,pipeline,196,"// Function passes executed between InlinerPass runs may have changed the; // module-wide features.; // The cgscc pass manager rules are such that:; // - if a pass leads to merging SCCs, then the pipeline is restarted on the; // merged SCC; // - if a pass leads to splitting the SCC, then we continue with one of the; // splits; // This means that the NodesInLastSCC is a superset (not strict) of the nodes; // that subsequent passes would have processed; // - in addition, if new Nodes were created by a pass (e.g. CoroSplit),; // they'd be adjacent to Nodes in the last SCC. So we just need to check the; // boundary of Nodes in NodesInLastSCC for Nodes we haven't seen. We don't; // care about the nature of the Edge (call or ref). `FunctionLevels`-wise, we; // record them at the same level as the original node (this is a choice, may; // need revisiting).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:16,Integrability,wrap,wrapped,16,// The Function wrapped by N could have been deleted since we last saw it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:79,Deployability,update,update,79,"// Keep track of the nodes and edges we last saw. Then, in onPassEntry,; // we update the node count and edge count from the subset of these nodes that; // survived.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:3,Deployability,Update,Update,3,"// Update the internal state of the advisor, and force invalidate feature; // analysis. Currently, we maintain minimal (and very simple) global state - the; // number of functions and the number of static calls. We also keep track of the; // total IR size in this module, to stop misbehaving policies at a certain bloat; // factor (SizeIncreaseThreshold)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:129,Usability,simpl,simple,129,"// Update the internal state of the advisor, and force invalidate feature; // analysis. Currently, we maintain minimal (and very simple) global state - the; // number of functions and the number of static calls. We also keep track of the; // total IR size in this module, to stop misbehaving policies at a certain bloat; // factor (SizeIncreaseThreshold)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:16,Deployability,update,update,16,"// We can delta-update module-wide features. We know the inlining only changed; // the caller, and maybe the callee (by deleting the latter).; // Nodes are simple to update.; // For edges, we 'forget' the edges that the caller and callee used to have; // before inlining, and add back what they currently have together.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:166,Deployability,update,update,166,"// We can delta-update module-wide features. We know the inlining only changed; // the caller, and maybe the callee (by deleting the latter).; // Nodes are simple to update.; // For edges, we 'forget' the edges that the caller and callee used to have; // before inlining, and add back what they currently have together.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:156,Usability,simpl,simple,156,"// We can delta-update module-wide features. We know the inlining only changed; // the caller, and maybe the callee (by deleting the latter).; // Nodes are simple to update.; // For edges, we 'forget' the edges that the caller and callee used to have; // before inlining, and add back what they currently have together.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:369,Modifiability,variab,variable,369,"// Walk through the operands of a given User via worklist iteration and populate; // the set of GlobalValue references encountered. Invoked either on an; // Instruction or a GlobalVariable (which walks its initializer).; // Return true if any of the operands contains blockaddress. This is important; // to know when computing summary for global var, because if global variable; // references basic block address we can't import it separately from function; // containing that basic block. For simplicity we currently don't import such; // global vars at all. When importing function we aren't interested if any; // instruction in it takes an address of any basic block, because instruction; // can only take an address of basic block located in the same function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:494,Usability,simpl,simplicity,494,"// Walk through the operands of a given User via worklist iteration and populate; // the set of GlobalValue references encountered. Invoked either on an; // Instruction or a GlobalVariable (which walks its initializer).; // Return true if any of the operands contains blockaddress. This is important; // to know when computing summary for global var, because if global variable; // references basic block address we can't import it separately from function; // containing that basic block. For simplicity we currently don't import such; // global vars at all. When importing function we aren't interested if any; // instruction in it takes an address of any basic block, because instruction; // can only take an address of basic block located in the same function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:31,Testability,test,test,31,"// Produce a summary from type.test intrinsics. We only summarize type.test; // intrinsics that are used other than by an llvm.assume intrinsic.; // Intrinsics that are assumed are relevant only to the devirtualization; // pass, not the type test lowering pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:71,Testability,test,test,71,"// Produce a summary from type.test intrinsics. We only summarize type.test; // intrinsics that are used other than by an llvm.assume intrinsic.; // Intrinsics that are assumed are relevant only to the devirtualization; // pass, not the type test lowering pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:242,Testability,test,test,242,"// Produce a summary from type.test intrinsics. We only summarize type.test; // intrinsics that are used other than by an llvm.assume intrinsic.; // Intrinsics that are assumed are relevant only to the devirtualization; // pass, not the type test lowering pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:56,Performance,load,load,56,// Any non-call uses of the result of llvm.type.checked.load will; // prevent us from optimizing away the llvm.type.test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:86,Performance,optimiz,optimizing,86,// Any non-call uses of the result of llvm.type.checked.load will; // prevent us from optimizing away the llvm.type.test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:116,Testability,test,test,116,// Any non-call uses of the result of llvm.type.checked.load will; // prevent us from optimizing away the llvm.type.test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:142,Modifiability,variab,variable,142,"// We don't allow inlining of function with indirect branch to blockaddress.; // If the blockaddress escapes the function, e.g., via a global variable,; // inlining may lead to an invalid cross-function reference. So we shouldn't; // import such function either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:151,Modifiability,variab,variable,151,"// Regular LTO module doesn't participate in ThinLTO import,; // so no reference from it can be read/writeonly, since this; // would require importing variable as local copy",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:39,Performance,load,load,39,// Postpone processing of non-volatile load instructions; // See comments below,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:362,Performance,load,load,362,// All references from second operand of store (destination address); // can be considered write-only if they're not referenced by any; // non-store instruction. References from first operand of store; // (stored value) can't be treated either as read- or as write-only; // so we add them to RefEdges as we do with all other instructions; // except non-volatile load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:297,Availability,error,errors,297,"// If F is imported, a local linkage ifunc (e.g. target_clones on a; // static function) called by F will be cloned. Since summaries don't; // track ifunc, we do not know implementation functions referenced by; // the ifunc resolver need to be promoted in the exporter, and we will; // get linker errors due to cloned declarations for implementation; // functions. As a simple fix, just mark F as not eligible for import.; // Non-local ifunc is not cloned and does not have the issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:370,Usability,simpl,simple,370,"// If F is imported, a local linkage ifunc (e.g. target_clones on a; // static function) called by F will be cloned. Since summaries don't; // track ifunc, we do not know implementation functions referenced by; // the ifunc resolver need to be promoted in the exporter, and we will; // get linker errors due to cloned declarations for implementation; // functions. As a simple fix, just mark F as not eligible for import.; // Non-local ifunc is not cloned and does not have the issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:34,Usability,simpl,simply,34,"// If this is a direct recursion, simply skip the duplicate; // entries. If this is mutual recursion, handling is left to; // the LTO link analysis client.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:79,Performance,load,loads,79,"// By now we processed all instructions in a function, except; // non-volatile loads and non-volatile value stores. Let's find; // ref edges for both of instruction sets",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:61,Performance,load,load,61,"// We can add some values to the Visited set when processing load; // instructions which are also used by stores in NonVolatileStores.; // For example this can happen if we have following code:; //; // store %Derived* @foo, %Derived** bitcast (%Base** @bar to %Derived**); // %42 = load %Derived*, %Derived** bitcast (%Base** @bar to %Derived**); //; // After processing loads we'll add bitcast to the Visited set, and if; // we use the same set while processing stores, we'll never see store; // to @bar and @bar will be mistakenly treated as readonly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:282,Performance,load,load,282,"// We can add some values to the Visited set when processing load; // instructions which are also used by stores in NonVolatileStores.; // For example this can happen if we have following code:; //; // store %Derived* @foo, %Derived** bitcast (%Base** @bar to %Derived**); // %42 = load %Derived*, %Derived** bitcast (%Base** @bar to %Derived**); //; // After processing loads we'll add bitcast to the Visited set, and if; // we use the same set while processing stores, we'll never see store; // to @bar and @bar will be mistakenly treated as readonly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:371,Performance,load,loads,371,"// We can add some values to the Visited set when processing load; // instructions which are also used by stores in NonVolatileStores.; // For example this can happen if we have following code:; //; // store %Derived* @foo, %Derived** bitcast (%Base** @bar to %Derived**); // %42 = load %Derived*, %Derived** bitcast (%Base** @bar to %Derived**); //; // After processing loads we'll add bitcast to the Visited set, and if; // we use the same set while processing stores, we'll never see store; // to @bar and @bar will be mistakenly treated as readonly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:57,Modifiability,variab,variable,57,// If both load and store instruction reference the same variable; // we won't be able to optimize it. Add all such reference edges; // to RefEdges set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:11,Performance,load,load,11,// If both load and store instruction reference the same variable; // we won't be able to optimize it. Add all such reference edges; // to RefEdges set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:90,Performance,optimiz,optimize,90,// If both load and store instruction reference the same variable; // we won't be able to optimize it. Add all such reference edges; // to RefEdges set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:131,Performance,optimiz,optimized,131,"// Explicit add hot edges to enforce importing for designated GUIDs for; // sample PGO, to enable the same inlines as the profiled optimized binary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:62,Usability,GUID,GUIDs,62,"// Explicit add hot edges to enforce importing for designated GUIDs for; // sample PGO, to enable the same inlines as the profiled optimized binary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:10,Modifiability,refactor,refactor,10,// FIXME: refactor this to use the same code that inliner is using.; // Don't try to import functions with noinline attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:3,Security,Validat,Validate,3,// Validate that the VTableFuncs list is ordered by offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:14,Modifiability,variab,variables,14,// Don't mark variables we won't be able to internalize as read/write-only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:29,Modifiability,variab,variables,29,"// Compute summaries for all variables defined in module, and save in the; // index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:51,Availability,alive,alive,51,"// Iterate through ifuncs, set their resolvers all alive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:35,Safety,safe,safety,35,// Iterate over header and compute safety info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:46,Safety,safe,safety,46,// Iterate over loop instructions and compute safety info.; // Skip header as it has been computed and stored in HeaderMayThrow.; // The first block in loopinfo.Blocks is guaranteed to be the header.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:94,Integrability,rout,routine,94,// Compute funclet colors if we might sink/hoist in a function with a funclet; // personality routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:34,Energy Efficiency,power,powerful,34,"// todo: this would be a lot more powerful if we used scev, but all the; // plumbing is currently missing to pass a pointer in from the pass; // Check for cmp (phi [x, preheader] ...), y where (pred x, y is known",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:227,Testability,test,test,227,"// TODO: If BB lies in an inner loop of CurLoop, this will traverse over all; // blocks of this inner loop, even those that are always executed AFTER the; // BB. It may make our analysis more conservative than it could be, see test; // @nested and @nested_no_throw in test/Analysis/MustExecute/loop-header.ll.; // We can ignore backedge of all loops containing BB to get a sligtly more; // optimistic result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:268,Testability,test,test,268,"// TODO: If BB lies in an inner loop of CurLoop, this will traverse over all; // blocks of this inner loop, even those that are always executed AFTER the; // BB. It may make our analysis more conservative than it could be, see test; // @nested and @nested_no_throw in test/Analysis/MustExecute/loop-header.ll.; // We can ignore backedge of all loops containing BB to get a sligtly more; // optimistic result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:183,Energy Efficiency,power,power,183,"// TODO: merge these two routines. For the moment, we display the best; // result obtained by *either* implementation. This is a bit unfair since no; // caller actually gets the full power at the moment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:25,Integrability,rout,routines,25,"// TODO: merge these two routines. For the moment, we display the best; // result obtained by *either* implementation. This is a bit unfair since no; // caller actually gets the full power at the moment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:98,Performance,cache,cache,98,"// TODO: Actually try to prove it is not.; // TODO: If maybeEndlessLoop is going to be expensive, cache it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:110,Performance,perform,perform,110,"// Try to determine a join block through the help of the post-dominance; // tree. If no tree was provided, we perform simple pattern matching for one; // block conditionals and one block loops only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:118,Usability,simpl,simple,118,"// Try to determine a join block through the help of the post-dominance; // tree. If no tree was provided, we perform simple pattern matching for one; // block conditionals and one block loops only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:105,Performance,perform,perform,105,"// Try to determine a join block through the help of the dominance tree. If no; // tree was provided, we perform simple pattern matching for one block; // conditionals only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:113,Usability,simpl,simple,113,"// Try to determine a join block through the help of the dominance tree. If no; // tree was provided, we perform simple pattern matching for one block; // conditionals only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:211,Availability,avail,available,211,"// Multiple successors mean we need to find the join point where control flow; // converges again. We use the findForwardJoinPoint helper function with; // information about the function and helper analyses, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:35,Usability,simpl,simply,35,// We did not enter a callee so we simply return the previous instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:233,Availability,avail,available,233,"// Finally, we have to handle the case where the program point is the first in; // a block but not in the function. We use the findBackwardJoinPoint helper; // function with information about the function and helper analyses, if; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/NoInferenceModelRunner.cpp:458,Testability,log,logs,458,"//===- NoInferenceModelRunner.cpp - noop ML model runner ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // A pseudo model runner. We use it to store feature values when collecting; // logs for the default policy, in 'development' mode, but never ask it to; // 'run'.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/NoInferenceModelRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/NoInferenceModelRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp:978,Integrability,depend,dependencies,978,"//===- ObjCARCAliasAnalysis.cpp - ObjC ARC Optimization -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines a simple ARC-aware AliasAnalysis using special knowledge; /// of Objective C to enhance other optimization passes which rely on the Alias; /// Analysis infrastructure.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; /// TODO: Theoretically we could check for dependencies between objc_* calls; /// and FMRB_OnlyAccessesArgumentPointees calls or other well-behaved calls.; ///; /// TODO: The calls here to AAResultBase member functions are all effectively; /// no-ops that just return a conservative result. The original intent was to; /// chain to another analysis for a recursive query, but this was lost in a; /// refactor. These should instead be rephrased in terms of queries to AAQI.AAR.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp:489,Modifiability,enhance,enhance,489,"//===- ObjCARCAliasAnalysis.cpp - ObjC ARC Optimization -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines a simple ARC-aware AliasAnalysis using special knowledge; /// of Objective C to enhance other optimization passes which rely on the Alias; /// Analysis infrastructure.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; /// TODO: Theoretically we could check for dependencies between objc_* calls; /// and FMRB_OnlyAccessesArgumentPointees calls or other well-behaved calls.; ///; /// TODO: The calls here to AAResultBase member functions are all effectively; /// no-ops that just return a conservative result. The original intent was to; /// chain to another analysis for a recursive query, but this was lost in a; /// refactor. These should instead be rephrased in terms of queries to AAQI.AAR.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp:1335,Modifiability,refactor,refactor,1335,"//===- ObjCARCAliasAnalysis.cpp - ObjC ARC Optimization -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines a simple ARC-aware AliasAnalysis using special knowledge; /// of Objective C to enhance other optimization passes which rely on the Alias; /// Analysis infrastructure.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; /// TODO: Theoretically we could check for dependencies between objc_* calls; /// and FMRB_OnlyAccessesArgumentPointees calls or other well-behaved calls.; ///; /// TODO: The calls here to AAResultBase member functions are all effectively; /// no-ops that just return a conservative result. The original intent was to; /// chain to another analysis for a recursive query, but this was lost in a; /// refactor. These should instead be rephrased in terms of queries to AAQI.AAR.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp:43,Performance,Optimiz,Optimization,43,"//===- ObjCARCAliasAnalysis.cpp - ObjC ARC Optimization -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines a simple ARC-aware AliasAnalysis using special knowledge; /// of Objective C to enhance other optimization passes which rely on the Alias; /// Analysis infrastructure.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; /// TODO: Theoretically we could check for dependencies between objc_* calls; /// and FMRB_OnlyAccessesArgumentPointees calls or other well-behaved calls.; ///; /// TODO: The calls here to AAResultBase member functions are all effectively; /// no-ops that just return a conservative result. The original intent was to; /// chain to another analysis for a recursive query, but this was lost in a; /// refactor. These should instead be rephrased in terms of queries to AAQI.AAR.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp:503,Performance,optimiz,optimization,503,"//===- ObjCARCAliasAnalysis.cpp - ObjC ARC Optimization -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines a simple ARC-aware AliasAnalysis using special knowledge; /// of Objective C to enhance other optimization passes which rely on the Alias; /// Analysis infrastructure.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; /// TODO: Theoretically we could check for dependencies between objc_* calls; /// and FMRB_OnlyAccessesArgumentPointees calls or other well-behaved calls.; ///; /// TODO: The calls here to AAResultBase member functions are all effectively; /// no-ops that just return a conservative result. The original intent was to; /// chain to another analysis for a recursive query, but this was lost in a; /// refactor. These should instead be rephrased in terms of queries to AAQI.AAR.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp:411,Usability,simpl,simple,411,"//===- ObjCARCAliasAnalysis.cpp - ObjC ARC Optimization -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines a simple ARC-aware AliasAnalysis using special knowledge; /// of Objective C to enhance other optimization passes which rely on the Alias; /// Analysis infrastructure.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; /// TODO: Theoretically we could check for dependencies between objc_* calls; /// and FMRB_OnlyAccessesArgumentPointees calls or other well-behaved calls.; ///; /// TODO: The calls here to AAResultBase member functions are all effectively; /// no-ops that just return a conservative result. The original intent was to; /// chain to another analysis for a recursive query, but this was lost in a; /// refactor. These should instead be rephrased in terms of queries to AAQI.AAR.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp:132,Deployability,update,updates,132,"// These functions don't access any memory visible to the compiler.; // Note that this doesn't include objc_retainBlock, because it updates; // pointers when it copies block data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp:25,Security,access,access,25,"// These functions don't access any memory visible to the compiler.; // Note that this doesn't include objc_retainBlock, because it updates; // pointers when it copies block data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAnalysisUtils.cpp:45,Performance,Optimiz,Optimizations,45,/// A handy option to enable/disable all ARC Optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAnalysisUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAnalysisUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:34,Performance,Optimiz,Optimization,34,"//===- ARCInstKind.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines several utility functions used by various ARC; /// optimizations which are IMHO too big to be in a header file.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:460,Performance,optimiz,optimizations,460,"//===- ARCInstKind.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines several utility functions used by various ARC; /// optimizations which are IMHO too big to be in a header file.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:62,Performance,optimiz,optimizer,62,// Ignore annotation calls. This is important to stop the; // optimizer from treating annotations as uses which would; // make the state of the pointers they are attempting to; // elucidate to be incorrect.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:117,Safety,safe,safety,117,"// We are conservative and even though intrinsics are unlikely to touch; // reference counts, we white list them for safety.; //; // TODO: Expand this into a covered switch. There is a lot more here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:354,Deployability,release,release,354,"// Any instruction other than bitcast and gep with a pointer operand have a; // use of an objc pointer. Bitcasts, GEPs, Selects, PHIs transfer a pointer; // to a subsequent use, rather than using it themselves, in this sense.; // As a short cut, several other opcodes are known to have no pointer; // operands of interest. And ret is never followed by a release, so it's; // not interesting to examine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:4,Testability,Test,Test,4,/// Test if the given class is a kind of user.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:4,Testability,Test,Test,4,/// Test if the given class is objc_retain or equivalent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:4,Testability,Test,Test,4,/// Test if the given class is objc_autorelease or equivalent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:4,Testability,Test,Test,4,/// Test if the given class represents instructions which return their; /// argument verbatim.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:4,Testability,Test,Test,4,/// Test if the given class represents instructions which do nothing if; /// passed a null pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:93,Modifiability,variab,variable,93,/// Test if the given class represents instructions which do nothing if; /// passed a global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:4,Testability,Test,Test,4,/// Test if the given class represents instructions which do nothing if; /// passed a global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:69,Safety,safe,safe,69,"/// Test if the given class represents instructions which are always safe; /// to mark with the ""tail"" keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:4,Testability,Test,Test,4,"/// Test if the given class represents instructions which are always safe; /// to mark with the ""tail"" keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:68,Safety,safe,safe,68,"/// Test if the given class represents instructions which are never safe; /// to mark with the ""tail"" keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:4,Testability,Test,Test,4,"/// Test if the given class represents instructions which are never safe; /// to mark with the ""tail"" keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:16,Safety,safe,safe,16,/// It is never safe to tail call objc_autorelease since by tail calling; /// objc_autorelease: fast autoreleasing causing our object to be potentially; /// reclaimed from the autorelease pool which violates the semantics of; /// __autoreleasing types in ARC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:69,Safety,safe,safe,69,/// Test if the given class represents instructions which are always safe; /// to mark with the nounwind attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:4,Testability,Test,Test,4,/// Test if the given class represents instructions which are always safe; /// to mark with the nounwind attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:159,Performance,optimiz,optimization,159,/// Test whether the given instruction can autorelease any pointer or cause an; /// autoreleasepool pop.; ///; /// This means that it *could* interrupt the RV optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:4,Testability,Test,Test,4,/// Test whether the given instruction can autorelease any pointer or cause an; /// autoreleasepool pop.; ///; /// This means that it *could* interrupt the RV optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:124,Deployability,release,releases,124,// The cases below are conservative.; // RetainBlock can result in user defined copy constructors being called; // implying releases may occur.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp:407,Integrability,interface,interfaces,407,"//===- OptimizationRemarkEmitter.cpp - Optimization Diagnostic --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp:501,Integrability,depend,dependent,501,"//===- OptimizationRemarkEmitter.cpp - Optimization Diagnostic --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp:586,Integrability,message,message,586,"//===- OptimizationRemarkEmitter.cpp - Optimization Diagnostic --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp:7,Performance,Optimiz,OptimizationRemarkEmitter,7,"//===- OptimizationRemarkEmitter.cpp - Optimization Diagnostic --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp:39,Performance,Optimiz,Optimization,39,"//===- OptimizationRemarkEmitter.cpp - Optimization Diagnostic --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp:383,Performance,Optimiz,Optimization,383,"//===- OptimizationRemarkEmitter.cpp - Optimization Diagnostic --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OverflowInstAnalysis.cpp:399,Integrability,rout,routines,399,"//==-- OverflowInstAnalysis.cpp - Utils to fold overflow insts ----*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file holds routines to help analyse overflow instructions; // and fold them into constants or other overflow instructions; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/OverflowInstAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OverflowInstAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:89,Security,Validat,Validate,89,// If it isn't in the InstInputs list it is a subexpr incorporated into the; // address. Validate that it is phi translatable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:3,Security,Validat,Validate,3,// Validate the operands of the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:135,Availability,error,errors,135,"/// verify - Check internal consistency of this data structure. If the; /// structure is valid, it returns true. If invalid, it prints errors and; /// returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:157,Safety,avoid,avoid,157,"/// isPotentiallyPHITranslatable - If this needs PHI translation, return true; /// if we have some hope of doing it. This should be used as a filter to; /// avoid calling PHITranslateValue in hopeless situations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:11,Availability,avail,available,11,// Find an available version of this cast.; // Try to simplify cast first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:54,Usability,simpl,simplify,54,// Find an available version of this cast.; // Try to simplify cast first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:79,Availability,avail,available,79,"// Otherwise we have to see if a casted version of the incoming pointer; // is available. If so, we can use it, otherwise we have to fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:3,Usability,Simpl,Simplify,3,"// Simplify the GEP to handle 'gep x, 0' -> x etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:35,Availability,avail,available,35,// Scan to see if we have this GEP available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:18,Usability,simpl,simplifies,18,// See if the add simplifies away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:9,Usability,simpl,simplified,9,"// If we simplified the operands, the LHS is no longer an input, but Res; // is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:38,Availability,avail,available,38,"// Otherwise, see if we have this add available somewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:263,Availability,failure,failure,263,"/// PHITranslateWithInsertion - PHI translate this value into the specified; /// predecessor block, inserting a computation of the value if it is; /// unavailable.; ///; /// All newly created instructions are added to the NewInsts list. This; /// returns null on failure.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:248,Availability,failure,failure,248,/// insertTranslatedSubExpr - Insert a computation of the PHI translated; /// version of 'V' for the edge PredBB->CurBB into the end of the PredBB; /// block. All newly created instructions are added to the NewInsts list.; /// This returns null on failure.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:50,Availability,avail,available,50,"// See if we have a version of this value already available and dominating; // PredBB. If so, there is no need to insert a new instance of it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:133,Availability,avail,available,133,"// FIXME: This code works, but it is unclear that we actually want to insert; // a big chain of computation in order to make a value available in a block.; // This needs to be evaluated carefully to consider its cost trade offs.; // PHI translate the LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp:24,Deployability,update,update,24,"// We could potentially update the cached values we have with the new value,; // but it's simpler to just treat the old value as invalidated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp:35,Performance,cache,cached,35,"// We could potentially update the cached values we have with the new value,; // but it's simpler to just treat the old value as invalidated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp:90,Usability,simpl,simpler,90,"// We could potentially update the cached values we have with the new value,; // but it's simpler to just treat the old value as invalidated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp:614,Energy Efficiency,reduce,reduce,614,"// The goal here is to find all of the non-phi values reachable from this phi,; // and to do the same for all of the phis reachable from this phi, as doing so; // is necessary anyway in order to get the values for this phi. We do this using; // Tarjan's algorithm with Nuutila's improvements to find the strongly connected; // components of the phi graph rooted in this phi:; // * All phis in a strongly connected component will have the same reachable; // non-phi values. The SCC may not be the maximal subgraph for that set of; // reachable values, but finding out that isn't really necessary (it would; // only reduce the amount of memory needed to store the values).; // * Tarjan's algorithm completes components in a bottom-up manner, i.e. it; // never completes a component before the components reachable from it have; // been completed. This means that when we complete a component we have; // everything we need to collect the values reachable from that component.; // * We collect both the non-phi values reachable from each SCC, as that's what; // we're ultimately interested in, and all of the reachable values, i.e.; // including phis, as that makes invalidateValue easier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp:108,Safety,predict,predictable,108,// Iterate through the phi nodes of the function rather than iterating through; // DepthMap in order to get predictable ordering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ProfileSummaryInfo.cpp:423,Security,access,access,423,"//===- ProfileSummaryInfo.cpp - Global profile summary information --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that provides access to the global profile summary; // information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ProfileSummaryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ProfileSummaryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ProfileSummaryInfo.cpp:239,Availability,avail,available,239,"// The profile summary metadata may be attached either by the frontend or by; // any backend passes (IR level instrumentation, for example). This method; // checks if the Summary is null and if so checks if the summary metadata is now; // available in the module and parses it to get the Summary object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ProfileSummaryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ProfileSummaryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ProfileSummaryInfo.cpp:190,Availability,avail,available,190,"/// Returns true if the function's entry is a cold. If it returns false, it; /// either means it is not cold or it is unknown whether it is cold or not (for; /// example, no profile data is available).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ProfileSummaryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ProfileSummaryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionInfo.cpp:36,Safety,detect,detection,36,"//===- RegionInfo.cpp - SESE region detection analysis --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Detects single entry single exit regions in the control flow graph.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/RegionInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionInfo.cpp:379,Safety,Detect,Detects,379,"//===- RegionInfo.cpp - SESE region detection analysis --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Detects single entry single exit regions in the control flow graph.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/RegionInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionInfo.cpp:18,Availability,avail,available,18,"// Create methods available outside of this file, to use them; // ""include/llvm/LinkAllPasses.h"". Otherwise the pass would be deleted by; // the link time optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/RegionInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionInfo.cpp:155,Performance,optimiz,optimization,155,"// Create methods available outside of this file, to use them; // ""include/llvm/LinkAllPasses.h"". Otherwise the pass would be deleted by; // the link time optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/RegionInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp:445,Performance,optimiz,optimization,445,"//===- RegionPass.cpp - Region Pass and Region Pass Manager ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements RegionPass and RGPassManager. All region optimization; // and transformation passes are derived from RegionPass. RGPassManager is; // responsible for managing RegionPasses.; // Most of this code has been COPIED from LoopPass.cpp; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp:36,Energy Efficiency,schedul,scheduled,36,"/// run - Execute all of the passes scheduled for execution. Keep track of; /// whether any of the passes modifies the function, and if so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp:11,Modifiability,inherit,inherited,11,// Collect inherited analysis from Module level pass manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp:23,Performance,queue,queue,23,// Pop the region from queue after running all passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp:196,Availability,avail,available,196,"//end anonymous namespace; //===----------------------------------------------------------------------===//; // RegionPass; // Check if this pass is suitable for the current RGPassManager, if; // available. This pass P is not suitable for a RGPassManager if P; // is not preserving higher level analysis info used by other; // RGPassManager passes. In such case, pop RGPassManager from the; // stack. This will force assignPassManager() to create new; // LPPassManger as expected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPrinter.cpp:119,Usability,simpl,simple,119,//===----------------------------------------------------------------------===//; /// onlySimpleRegion - Show only the simple regions in the RegionViewer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/RegionPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPrinter.cpp:68,Safety,safe,safely,68,"// The viewer and analysis passes do not modify anything, so we can safely; // remove the const qualifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/RegionPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ReplayInlineAdvisor.cpp:496,Performance,optimiz,optimization,496,"//===- ReplayInlineAdvisor.cpp - Replay InlineAdvisor ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements ReplayInlineAdvisor that replays inline decisions based; // on previous inline remarks from optimization remark log. This is a best; // effort approach useful for testing compiler/source changes while holding; // inlining steady.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ReplayInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ReplayInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ReplayInlineAdvisor.cpp:516,Testability,log,log,516,"//===- ReplayInlineAdvisor.cpp - Replay InlineAdvisor ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements ReplayInlineAdvisor that replays inline decisions based; // on previous inline remarks from optimization remark log. This is a best; // effort approach useful for testing compiler/source changes while holding; // inlining steady.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ReplayInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ReplayInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ReplayInlineAdvisor.cpp:567,Testability,test,testing,567,"//===- ReplayInlineAdvisor.cpp - Replay InlineAdvisor ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements ReplayInlineAdvisor that replays inline decisions based; // on previous inline remarks from optimization remark log. This is a best; // effort approach useful for testing compiler/source changes while holding; // inlining steady.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ReplayInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ReplayInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2382,Energy Efficiency,Efficient,Efficient,2382,"bclasses of the SCEV class.; // These classes are used to represent certain types of subexpressions that we; // can handle. We only create one SCEV of a particular shape, so; // pointer-comparisons for equality are legal.; //; // One important aspect of the SCEV objects is that they are never cyclic, even; // if there is a cycle in the dataflow for an expression (ie, a PHI node). If; // the PHI node is one of the idioms that we can represent (e.g., a polynomial; // recurrence) then we represent it directly as a recurrence node, otherwise we; // represent it as a SCEVUnknown node.; //; // In addition to being able to represent expressions of various types, we also; // have folders that are used to build the *canonical* representation for a; // particular expression. These folders are capable of using a variety of; // rewrite rules to simplify the expressions.; //; // Once the folders are defined, we can implement the more interesting; // higher-level code, such as the code that recognizes PHI nodes of various; // types, computes the execution count of a loop, etc.; //; // TODO: We should use these routines and value representations to implement; // dependence analysis!; //; //===----------------------------------------------------------------------===//; //; // There are several good references for the techniques used in this analysis.; //; // Chains of recurrences -- a method to expedite the evaluation; // of closed-form functions; // Olaf Bachmann, Paul S. Wang, Eugene V. Zima; //; // On computational properties of chains of recurrences; // Eugene V. Zima; //; // Symbolic Evaluation of Chains of Recurrences for Loop Optimization; // Robert A. van Engelen; //; // Efficient Symbolic Analysis for Optimizing Compilers; // Robert A. van Engelen; //; // Using the chains of recurrences algebra for data dependence testing and; // induction variable substitution; // MS Thesis, Johnie Birch; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1804,Integrability,rout,routines,1804,"bclasses of the SCEV class.; // These classes are used to represent certain types of subexpressions that we; // can handle. We only create one SCEV of a particular shape, so; // pointer-comparisons for equality are legal.; //; // One important aspect of the SCEV objects is that they are never cyclic, even; // if there is a cycle in the dataflow for an expression (ie, a PHI node). If; // the PHI node is one of the idioms that we can represent (e.g., a polynomial; // recurrence) then we represent it directly as a recurrence node, otherwise we; // represent it as a SCEVUnknown node.; //; // In addition to being able to represent expressions of various types, we also; // have folders that are used to build the *canonical* representation for a; // particular expression. These folders are capable of using a variety of; // rewrite rules to simplify the expressions.; //; // Once the folders are defined, we can implement the more interesting; // higher-level code, such as the code that recognizes PHI nodes of various; // types, computes the execution count of a loop, etc.; //; // TODO: We should use these routines and value representations to implement; // dependence analysis!; //; //===----------------------------------------------------------------------===//; //; // There are several good references for the techniques used in this analysis.; //; // Chains of recurrences -- a method to expedite the evaluation; // of closed-form functions; // Olaf Bachmann, Paul S. Wang, Eugene V. Zima; //; // On computational properties of chains of recurrences; // Eugene V. Zima; //; // Symbolic Evaluation of Chains of Recurrences for Loop Optimization; // Robert A. van Engelen; //; // Efficient Symbolic Analysis for Optimizing Compilers; // Robert A. van Engelen; //; // Using the chains of recurrences algebra for data dependence testing and; // induction variable substitution; // MS Thesis, Johnie Birch; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1856,Integrability,depend,dependence,1856,"bclasses of the SCEV class.; // These classes are used to represent certain types of subexpressions that we; // can handle. We only create one SCEV of a particular shape, so; // pointer-comparisons for equality are legal.; //; // One important aspect of the SCEV objects is that they are never cyclic, even; // if there is a cycle in the dataflow for an expression (ie, a PHI node). If; // the PHI node is one of the idioms that we can represent (e.g., a polynomial; // recurrence) then we represent it directly as a recurrence node, otherwise we; // represent it as a SCEVUnknown node.; //; // In addition to being able to represent expressions of various types, we also; // have folders that are used to build the *canonical* representation for a; // particular expression. These folders are capable of using a variety of; // rewrite rules to simplify the expressions.; //; // Once the folders are defined, we can implement the more interesting; // higher-level code, such as the code that recognizes PHI nodes of various; // types, computes the execution count of a loop, etc.; //; // TODO: We should use these routines and value representations to implement; // dependence analysis!; //; //===----------------------------------------------------------------------===//; //; // There are several good references for the techniques used in this analysis.; //; // Chains of recurrences -- a method to expedite the evaluation; // of closed-form functions; // Olaf Bachmann, Paul S. Wang, Eugene V. Zima; //; // On computational properties of chains of recurrences; // Eugene V. Zima; //; // Symbolic Evaluation of Chains of Recurrences for Loop Optimization; // Robert A. van Engelen; //; // Efficient Symbolic Analysis for Optimizing Compilers; // Robert A. van Engelen; //; // Using the chains of recurrences algebra for data dependence testing and; // induction variable substitution; // MS Thesis, Johnie Birch; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2518,Integrability,depend,dependence,2518,"bclasses of the SCEV class.; // These classes are used to represent certain types of subexpressions that we; // can handle. We only create one SCEV of a particular shape, so; // pointer-comparisons for equality are legal.; //; // One important aspect of the SCEV objects is that they are never cyclic, even; // if there is a cycle in the dataflow for an expression (ie, a PHI node). If; // the PHI node is one of the idioms that we can represent (e.g., a polynomial; // recurrence) then we represent it directly as a recurrence node, otherwise we; // represent it as a SCEVUnknown node.; //; // In addition to being able to represent expressions of various types, we also; // have folders that are used to build the *canonical* representation for a; // particular expression. These folders are capable of using a variety of; // rewrite rules to simplify the expressions.; //; // Once the folders are defined, we can implement the more interesting; // higher-level code, such as the code that recognizes PHI nodes of various; // types, computes the execution count of a loop, etc.; //; // TODO: We should use these routines and value representations to implement; // dependence analysis!; //; //===----------------------------------------------------------------------===//; //; // There are several good references for the techniques used in this analysis.; //; // Chains of recurrences -- a method to expedite the evaluation; // of closed-form functions; // Olaf Bachmann, Paul S. Wang, Eugene V. Zima; //; // On computational properties of chains of recurrences; // Eugene V. Zima; //; // Symbolic Evaluation of Chains of Recurrences for Loop Optimization; // Robert A. van Engelen; //; // Efficient Symbolic Analysis for Optimizing Compilers; // Robert A. van Engelen; //; // Using the chains of recurrences algebra for data dependence testing and; // induction variable substitution; // MS Thesis, Johnie Birch; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:537,Modifiability,variab,variables,537,"//===- ScalarEvolution.cpp - Scalar Evolution Analysis --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the implementation of the scalar evolution analysis; // engine, which is used primarily to analyze expressions involving induction; // variables in loops.; //; // There are several aspects to this library. First is the representation of; // scalar expressions, which are represented as subclasses of the SCEV class.; // These classes are used to represent certain types of subexpressions that we; // can handle. We only create one SCEV of a particular shape, so; // pointer-comparisons for equality are legal.; //; // One important aspect of the SCEV objects is that they are never cyclic, even; // if there is a cycle in the dataflow for an expression (ie, a PHI node). If; // the PHI node is one of the idioms that we can represent (e.g., a polynomial; // recurrence) then we represent it directly as a recurrence node, otherwise we; // represent it as a SCEVUnknown node.; //; // In addition to being able to represent expressions of various types, we also; // have folders that are used to build the *canonical* representation for a; // particular expression. These folders are capable of using a variety of; // rewrite rules to simplify the expressions.; //; // Once the folders are defined, we can implement the more interesting; // higher-level code, such as the code that recognizes PHI nodes of various; // types, computes the execution count of a loop, etc.; //; // TODO: We should use these routines and value representations to implement; // dependence analysis!; //; //===----------------------------------------------------------------------===//; //; // There are several good referen",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1518,Modifiability,rewrite,rewrite,1518," involving induction; // variables in loops.; //; // There are several aspects to this library. First is the representation of; // scalar expressions, which are represented as subclasses of the SCEV class.; // These classes are used to represent certain types of subexpressions that we; // can handle. We only create one SCEV of a particular shape, so; // pointer-comparisons for equality are legal.; //; // One important aspect of the SCEV objects is that they are never cyclic, even; // if there is a cycle in the dataflow for an expression (ie, a PHI node). If; // the PHI node is one of the idioms that we can represent (e.g., a polynomial; // recurrence) then we represent it directly as a recurrence node, otherwise we; // represent it as a SCEVUnknown node.; //; // In addition to being able to represent expressions of various types, we also; // have folders that are used to build the *canonical* representation for a; // particular expression. These folders are capable of using a variety of; // rewrite rules to simplify the expressions.; //; // Once the folders are defined, we can implement the more interesting; // higher-level code, such as the code that recognizes PHI nodes of various; // types, computes the execution count of a loop, etc.; //; // TODO: We should use these routines and value representations to implement; // dependence analysis!; //; //===----------------------------------------------------------------------===//; //; // There are several good references for the techniques used in this analysis.; //; // Chains of recurrences -- a method to expedite the evaluation; // of closed-form functions; // Olaf Bachmann, Paul S. Wang, Eugene V. Zima; //; // On computational properties of chains of recurrences; // Eugene V. Zima; //; // Symbolic Evaluation of Chains of Recurrences for Loop Optimization; // Robert A. van Engelen; //; // Efficient Symbolic Analysis for Optimizing Compilers; // Robert A. van Engelen; //; // Using the chains of recurrences algebra for ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2555,Modifiability,variab,variable,2555,"bclasses of the SCEV class.; // These classes are used to represent certain types of subexpressions that we; // can handle. We only create one SCEV of a particular shape, so; // pointer-comparisons for equality are legal.; //; // One important aspect of the SCEV objects is that they are never cyclic, even; // if there is a cycle in the dataflow for an expression (ie, a PHI node). If; // the PHI node is one of the idioms that we can represent (e.g., a polynomial; // recurrence) then we represent it directly as a recurrence node, otherwise we; // represent it as a SCEVUnknown node.; //; // In addition to being able to represent expressions of various types, we also; // have folders that are used to build the *canonical* representation for a; // particular expression. These folders are capable of using a variety of; // rewrite rules to simplify the expressions.; //; // Once the folders are defined, we can implement the more interesting; // higher-level code, such as the code that recognizes PHI nodes of various; // types, computes the execution count of a loop, etc.; //; // TODO: We should use these routines and value representations to implement; // dependence analysis!; //; //===----------------------------------------------------------------------===//; //; // There are several good references for the techniques used in this analysis.; //; // Chains of recurrences -- a method to expedite the evaluation; // of closed-form functions; // Olaf Bachmann, Paul S. Wang, Eugene V. Zima; //; // On computational properties of chains of recurrences; // Eugene V. Zima; //; // Symbolic Evaluation of Chains of Recurrences for Loop Optimization; // Robert A. van Engelen; //; // Efficient Symbolic Analysis for Optimizing Compilers; // Robert A. van Engelen; //; // Using the chains of recurrences algebra for data dependence testing and; // induction variable substitution; // MS Thesis, Johnie Birch; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2335,Performance,Optimiz,Optimization,2335,"bclasses of the SCEV class.; // These classes are used to represent certain types of subexpressions that we; // can handle. We only create one SCEV of a particular shape, so; // pointer-comparisons for equality are legal.; //; // One important aspect of the SCEV objects is that they are never cyclic, even; // if there is a cycle in the dataflow for an expression (ie, a PHI node). If; // the PHI node is one of the idioms that we can represent (e.g., a polynomial; // recurrence) then we represent it directly as a recurrence node, otherwise we; // represent it as a SCEVUnknown node.; //; // In addition to being able to represent expressions of various types, we also; // have folders that are used to build the *canonical* representation for a; // particular expression. These folders are capable of using a variety of; // rewrite rules to simplify the expressions.; //; // Once the folders are defined, we can implement the more interesting; // higher-level code, such as the code that recognizes PHI nodes of various; // types, computes the execution count of a loop, etc.; //; // TODO: We should use these routines and value representations to implement; // dependence analysis!; //; //===----------------------------------------------------------------------===//; //; // There are several good references for the techniques used in this analysis.; //; // Chains of recurrences -- a method to expedite the evaluation; // of closed-form functions; // Olaf Bachmann, Paul S. Wang, Eugene V. Zima; //; // On computational properties of chains of recurrences; // Eugene V. Zima; //; // Symbolic Evaluation of Chains of Recurrences for Loop Optimization; // Robert A. van Engelen; //; // Efficient Symbolic Analysis for Optimizing Compilers; // Robert A. van Engelen; //; // Using the chains of recurrences algebra for data dependence testing and; // induction variable substitution; // MS Thesis, Johnie Birch; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2414,Performance,Optimiz,Optimizing,2414,"bclasses of the SCEV class.; // These classes are used to represent certain types of subexpressions that we; // can handle. We only create one SCEV of a particular shape, so; // pointer-comparisons for equality are legal.; //; // One important aspect of the SCEV objects is that they are never cyclic, even; // if there is a cycle in the dataflow for an expression (ie, a PHI node). If; // the PHI node is one of the idioms that we can represent (e.g., a polynomial; // recurrence) then we represent it directly as a recurrence node, otherwise we; // represent it as a SCEVUnknown node.; //; // In addition to being able to represent expressions of various types, we also; // have folders that are used to build the *canonical* representation for a; // particular expression. These folders are capable of using a variety of; // rewrite rules to simplify the expressions.; //; // Once the folders are defined, we can implement the more interesting; // higher-level code, such as the code that recognizes PHI nodes of various; // types, computes the execution count of a loop, etc.; //; // TODO: We should use these routines and value representations to implement; // dependence analysis!; //; //===----------------------------------------------------------------------===//; //; // There are several good references for the techniques used in this analysis.; //; // Chains of recurrences -- a method to expedite the evaluation; // of closed-form functions; // Olaf Bachmann, Paul S. Wang, Eugene V. Zima; //; // On computational properties of chains of recurrences; // Eugene V. Zima; //; // Symbolic Evaluation of Chains of Recurrences for Loop Optimization; // Robert A. van Engelen; //; // Efficient Symbolic Analysis for Optimizing Compilers; // Robert A. van Engelen; //; // Using the chains of recurrences algebra for data dependence testing and; // induction variable substitution; // MS Thesis, Johnie Birch; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2529,Testability,test,testing,2529,"bclasses of the SCEV class.; // These classes are used to represent certain types of subexpressions that we; // can handle. We only create one SCEV of a particular shape, so; // pointer-comparisons for equality are legal.; //; // One important aspect of the SCEV objects is that they are never cyclic, even; // if there is a cycle in the dataflow for an expression (ie, a PHI node). If; // the PHI node is one of the idioms that we can represent (e.g., a polynomial; // recurrence) then we represent it directly as a recurrence node, otherwise we; // represent it as a SCEVUnknown node.; //; // In addition to being able to represent expressions of various types, we also; // have folders that are used to build the *canonical* representation for a; // particular expression. These folders are capable of using a variety of; // rewrite rules to simplify the expressions.; //; // Once the folders are defined, we can implement the more interesting; // higher-level code, such as the code that recognizes PHI nodes of various; // types, computes the execution count of a loop, etc.; //; // TODO: We should use these routines and value representations to implement; // dependence analysis!; //; //===----------------------------------------------------------------------===//; //; // There are several good references for the techniques used in this analysis.; //; // Chains of recurrences -- a method to expedite the evaluation; // of closed-form functions; // Olaf Bachmann, Paul S. Wang, Eugene V. Zima; //; // On computational properties of chains of recurrences; // Eugene V. Zima; //; // Symbolic Evaluation of Chains of Recurrences for Loop Optimization; // Robert A. van Engelen; //; // Efficient Symbolic Analysis for Optimizing Compilers; // Robert A. van Engelen; //; // Using the chains of recurrences algebra for data dependence testing and; // induction variable substitution; // MS Thesis, Johnie Birch; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1535,Usability,simpl,simplify,1535," involving induction; // variables in loops.; //; // There are several aspects to this library. First is the representation of; // scalar expressions, which are represented as subclasses of the SCEV class.; // These classes are used to represent certain types of subexpressions that we; // can handle. We only create one SCEV of a particular shape, so; // pointer-comparisons for equality are legal.; //; // One important aspect of the SCEV objects is that they are never cyclic, even; // if there is a cycle in the dataflow for an expression (ie, a PHI node). If; // the PHI node is one of the idioms that we can represent (e.g., a polynomial; // recurrence) then we represent it directly as a recurrence node, otherwise we; // represent it as a SCEVUnknown node.; //; // In addition to being able to represent expressions of various types, we also; // have folders that are used to build the *canonical* representation for a; // particular expression. These folders are capable of using a variety of; // rewrite rules to simplify the expressions.; //; // Once the folders are defined, we can implement the more interesting; // higher-level code, such as the code that recognizes PHI nodes of various; // types, computes the execution count of a loop, etc.; //; // TODO: We should use these routines and value representations to implement; // dependence analysis!; //; //===----------------------------------------------------------------------===//; //; // There are several good references for the techniques used in this analysis.; //; // Chains of recurrences -- a method to expedite the evaluation; // of closed-form functions; // Olaf Bachmann, Paul S. Wang, Eugene V. Zima; //; // On computational properties of chains of recurrences; // Eugene V. Zima; //; // Symbolic Evaluation of Chains of Recurrences for Loop Optimization; // Robert A. van Engelen; //; // Efficient Symbolic Analysis for Optimizing Compilers; // Robert A. van Engelen; //; // Using the chains of recurrences algebra for ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Usability,Clear,Clear,3,// Clear this SCEVUnknown from various maps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Deployability,Release,Release,3,// Release the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Usability,Clear,Clear,3,// Clear this SCEVUnknown from various maps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:483,Integrability,rout,routine,483,"//===----------------------------------------------------------------------===//; // SCEV Utilities; //===----------------------------------------------------------------------===//; /// Compare the two values \p LV and \p RV in terms of their ""complexity"" where; /// ""complexity"" is a partial (and somewhat ad-hoc) relation used to order; /// operands in SCEV expressions. \p EqCache is a set of pairs of values that; /// have been previously deemed to be ""equally complex"" by this routine. It is; /// intended to avoid exponential time complexity in cases like:; ///; /// %a = f(%x, %y); /// %b = f(%a, %a); /// %c = f(%b, %b); ///; /// %d = f(%x, %y); /// %e = f(%d, %d); /// %f = f(%e, %e); ///; /// CompareValueComplexity(%f, %c); ///; /// Since we do not continue running this routine on expression trees once we; /// have seen unequal values, there is no need to track them in the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:783,Integrability,rout,routine,783,"//===----------------------------------------------------------------------===//; // SCEV Utilities; //===----------------------------------------------------------------------===//; /// Compare the two values \p LV and \p RV in terms of their ""complexity"" where; /// ""complexity"" is a partial (and somewhat ad-hoc) relation used to order; /// operands in SCEV expressions. \p EqCache is a set of pairs of values that; /// have been previously deemed to be ""equally complex"" by this routine. It is; /// intended to avoid exponential time complexity in cases like:; ///; /// %a = f(%x, %y); /// %b = f(%a, %a); /// %c = f(%b, %b); ///; /// %d = f(%x, %y); /// %e = f(%d, %d); /// %f = f(%e, %e); ///; /// CompareValueComplexity(%f, %c); ///; /// Since we do not continue running this routine on expression trees once we; /// have seen unequal values, there is no need to track them in the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:888,Performance,cache,cache,888,"//===----------------------------------------------------------------------===//; // SCEV Utilities; //===----------------------------------------------------------------------===//; /// Compare the two values \p LV and \p RV in terms of their ""complexity"" where; /// ""complexity"" is a partial (and somewhat ad-hoc) relation used to order; /// operands in SCEV expressions. \p EqCache is a set of pairs of values that; /// have been previously deemed to be ""equally complex"" by this routine. It is; /// intended to avoid exponential time complexity in cases like:; ///; /// %a = f(%x, %y); /// %b = f(%a, %a); /// %c = f(%b, %b); ///; /// %d = f(%x, %y); /// %e = f(%d, %d); /// %f = f(%e, %e); ///; /// CompareValueComplexity(%f, %c); ///; /// Since we do not continue running this routine on expression trees once we; /// have seen unequal values, there is no need to track them in the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:515,Safety,avoid,avoid,515,"//===----------------------------------------------------------------------===//; // SCEV Utilities; //===----------------------------------------------------------------------===//; /// Compare the two values \p LV and \p RV in terms of their ""complexity"" where; /// ""complexity"" is a partial (and somewhat ad-hoc) relation used to order; /// operands in SCEV expressions. \p EqCache is a set of pairs of values that; /// have been previously deemed to be ""equally complex"" by this routine. It is; /// intended to avoid exponential time complexity in cases like:; ///; /// %a = f(%x, %y); /// %b = f(%a, %a); /// %c = f(%b, %b); ///; /// %d = f(%x, %y); /// %e = f(%d, %d); /// %f = f(%e, %e); ///; /// CompareValueComplexity(%f, %c); ///; /// Since we do not continue running this routine on expression trees once we; /// have seen unequal values, there is no need to track them in the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:172,Energy Efficiency,efficient,efficient,172,"// Return negative, zero, or positive, if LHS is less than, equal to, or greater; // than RHS, respectively. A three-way result allows recursive comparisons to be; // more efficient.; // If the max analysis depth was reached, return std::nullopt, assuming we do; // not know if they are equivalent for sure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:89,Safety,safe,safely,89,"// There is always a dominance between two recs that are used by one SCEV,; // so we can safely sort recs by loop header dominance. We require such; // order in getAddExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:141,Integrability,rout,routine,141,"/// Given a list of SCEV objects, order them by their complexity, and group; /// objects of the same complexity together by value. When this routine is; /// finished, we know that any duplicates in the vector are consecutive and that; /// complexity is monotonically increasing.; ///; /// Note that we go take special precautions to ensure that we get deterministic; /// results from this routine. In other words, we don't want the results of; /// this to depend on where the addresses of various SCEV objects happened to; /// land in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:389,Integrability,rout,routine,389,"/// Given a list of SCEV objects, order them by their complexity, and group; /// objects of the same complexity together by value. When this routine is; /// finished, we know that any duplicates in the vector are consecutive and that; /// complexity is monotonically increasing.; ///; /// Note that we go take special precautions to ensure that we get deterministic; /// results from this routine. In other words, we don't want the results of; /// this to depend on where the addresses of various SCEV objects happened to; /// land in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:456,Integrability,depend,depend,456,"/// Given a list of SCEV objects, order them by their complexity, and group; /// objects of the same complexity together by value. When this routine is; /// finished, we know that any duplicates in the vector are consecutive and that; /// complexity is monotonically increasing.; ///; /// Note that we go take special precautions to ensure that we get deterministic; /// results from this routine. In other words, we don't want the results of; /// this to depend on where the addresses of various SCEV objects happened to; /// land in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:63,Usability,simpl,simple,63,"// This is the common case, which also happens to be trivially simple.; // Special case it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:244,Integrability,depend,depend,244,"// Now that we are sorted by complexity, group elements of the same; // complexity. Note that this is, at worst, N^2, but the vector is likely to; // be extremely short in practice. Note that we take this approach because we; // do not want to depend on the addresses of the objects we are grouping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:85,Usability,Simpl,Simple,85,"//===----------------------------------------------------------------------===//; // Simple SCEV method implementations; //===----------------------------------------------------------------------===//; /// Compute BC(It, K). The result has width W. Assume, K > 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:28,Energy Efficiency,efficient,efficiently,28,// Handle the simplest case efficiently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:14,Usability,simpl,simplest,14,// Handle the simplest case efficiently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:827,Energy Efficiency,efficient,efficiently,827,"// We are using the following formula for BC(It, K):; //; // BC(It, K) = (It * (It - 1) * ... * (It - K + 1)) / K!; //; // Suppose, W is the bitwidth of the return value. We must be prepared for; // overflow. Hence, we must assure that the result of our computation is; // equal to the accurate one modulo 2^W. Unfortunately, division isn't; // safe in modular arithmetic.; //; // However, this code doesn't use exactly that formula; the formula it uses; // is something like the following, where T is the number of factors of 2 in; // K! (i.e. trailing zeros in the binary representation of K!), and ^ is; // exponentiation:; //; // BC(It, K) = (It * (It - 1) * ... * (It - K + 1)) / 2^T / (K! / 2^T); //; // This formula is trivially equivalent to the previous formula. However,; // this formula can be implemented much more efficiently. The trick is that; // K! / 2^T is odd, and exact division by an odd number *is* safe in modular; // arithmetic. To do exact division in modular arithmetic, all we have; // to do is multiply by the inverse. Therefore, this step can be done at; // width W.; //; // The next issue is how to safely do the division by 2^T. The way this; // is done is by doing the multiplication step at a width of at least W + T; // bits. This way, the bottom W+T bits of the product are accurate. Then,; // when we perform the division by 2^T (which is equivalent to a right shift; // by T), the bottom W bits are accurate. Extra bits are okay; they'll get; // truncated out after the division by 2^T.; //; // In comparison to just directly using the first formula, this technique; // is much more efficient; using the first formula requires W * K bits,; // but this formula less than W + K bits. Also, the first formula requires; // a division step, whereas this formula only requires multiplies and shifts.; //; // It doesn't matter whether the subtraction step is done in the calculation; // width or the input iteration count's width; if the subtraction overflows,; // the res",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1619,Energy Efficiency,efficient,efficient,1619,"ation:; //; // BC(It, K) = (It * (It - 1) * ... * (It - K + 1)) / 2^T / (K! / 2^T); //; // This formula is trivially equivalent to the previous formula. However,; // this formula can be implemented much more efficiently. The trick is that; // K! / 2^T is odd, and exact division by an odd number *is* safe in modular; // arithmetic. To do exact division in modular arithmetic, all we have; // to do is multiply by the inverse. Therefore, this step can be done at; // width W.; //; // The next issue is how to safely do the division by 2^T. The way this; // is done is by doing the multiplication step at a width of at least W + T; // bits. This way, the bottom W+T bits of the product are accurate. Then,; // when we perform the division by 2^T (which is equivalent to a right shift; // by T), the bottom W bits are accurate. Extra bits are okay; they'll get; // truncated out after the division by 2^T.; //; // In comparison to just directly using the first formula, this technique; // is much more efficient; using the first formula requires W * K bits,; // but this formula less than W + K bits. Also, the first formula requires; // a division step, whereas this formula only requires multiplies and shifts.; //; // It doesn't matter whether the subtraction step is done in the calculation; // width or the input iteration count's width; if the subtraction overflows,; // the result must be zero anyway. We prefer here to do it in the width of; // the induction variable because it helps a lot for certain cases; CodeGen; // isn't smart enough to ignore the overflow, which leads to much less; // efficient code if the width of the subtraction is wider than the native; // register width.; //; // (It's possible to not widen at all by pulling out factors of 2 before; // the multiplication; for example, K=2 can be calculated as; // It/2*(It+(It*INT_MIN/INT_MIN)+-1). However, it requires; // extra arithmetic, so it's not an obvious win, and it gets; // much more complicated for K > 3.); // Prote",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2219,Energy Efficiency,efficient,efficient,2219,"/ This formula is trivially equivalent to the previous formula. However,; // this formula can be implemented much more efficiently. The trick is that; // K! / 2^T is odd, and exact division by an odd number *is* safe in modular; // arithmetic. To do exact division in modular arithmetic, all we have; // to do is multiply by the inverse. Therefore, this step can be done at; // width W.; //; // The next issue is how to safely do the division by 2^T. The way this; // is done is by doing the multiplication step at a width of at least W + T; // bits. This way, the bottom W+T bits of the product are accurate. Then,; // when we perform the division by 2^T (which is equivalent to a right shift; // by T), the bottom W bits are accurate. Extra bits are okay; they'll get; // truncated out after the division by 2^T.; //; // In comparison to just directly using the first formula, this technique; // is much more efficient; using the first formula requires W * K bits,; // but this formula less than W + K bits. Also, the first formula requires; // a division step, whereas this formula only requires multiplies and shifts.; //; // It doesn't matter whether the subtraction step is done in the calculation; // width or the input iteration count's width; if the subtraction overflows,; // the result must be zero anyway. We prefer here to do it in the width of; // the induction variable because it helps a lot for certain cases; CodeGen; // isn't smart enough to ignore the overflow, which leads to much less; // efficient code if the width of the subtraction is wider than the native; // register width.; //; // (It's possible to not widen at all by pulling out factors of 2 before; // the multiplication; for example, K=2 can be calculated as; // It/2*(It+(It*INT_MIN/INT_MIN)+-1). However, it requires; // extra arithmetic, so it's not an obvious win, and it gets; // much more complicated for K > 3.); // Protection from insane SCEVs; this bound is conservative,; // but it probably doesn't matter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2084,Modifiability,variab,variable,2084,"/ This formula is trivially equivalent to the previous formula. However,; // this formula can be implemented much more efficiently. The trick is that; // K! / 2^T is odd, and exact division by an odd number *is* safe in modular; // arithmetic. To do exact division in modular arithmetic, all we have; // to do is multiply by the inverse. Therefore, this step can be done at; // width W.; //; // The next issue is how to safely do the division by 2^T. The way this; // is done is by doing the multiplication step at a width of at least W + T; // bits. This way, the bottom W+T bits of the product are accurate. Then,; // when we perform the division by 2^T (which is equivalent to a right shift; // by T), the bottom W bits are accurate. Extra bits are okay; they'll get; // truncated out after the division by 2^T.; //; // In comparison to just directly using the first formula, this technique; // is much more efficient; using the first formula requires W * K bits,; // but this formula less than W + K bits. Also, the first formula requires; // a division step, whereas this formula only requires multiplies and shifts.; //; // It doesn't matter whether the subtraction step is done in the calculation; // width or the input iteration count's width; if the subtraction overflows,; // the result must be zero anyway. We prefer here to do it in the width of; // the induction variable because it helps a lot for certain cases; CodeGen; // isn't smart enough to ignore the overflow, which leads to much less; // efficient code if the width of the subtraction is wider than the native; // register width.; //; // (It's possible to not widen at all by pulling out factors of 2 before; // the multiplication; for example, K=2 can be calculated as; // It/2*(It+(It*INT_MIN/INT_MIN)+-1). However, it requires; // extra arithmetic, so it's not an obvious win, and it gets; // much more complicated for K > 3.); // Protection from insane SCEVs; this bound is conservative,; // but it probably doesn't matter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1336,Performance,perform,perform,1336," However, this code doesn't use exactly that formula; the formula it uses; // is something like the following, where T is the number of factors of 2 in; // K! (i.e. trailing zeros in the binary representation of K!), and ^ is; // exponentiation:; //; // BC(It, K) = (It * (It - 1) * ... * (It - K + 1)) / 2^T / (K! / 2^T); //; // This formula is trivially equivalent to the previous formula. However,; // this formula can be implemented much more efficiently. The trick is that; // K! / 2^T is odd, and exact division by an odd number *is* safe in modular; // arithmetic. To do exact division in modular arithmetic, all we have; // to do is multiply by the inverse. Therefore, this step can be done at; // width W.; //; // The next issue is how to safely do the division by 2^T. The way this; // is done is by doing the multiplication step at a width of at least W + T; // bits. This way, the bottom W+T bits of the product are accurate. Then,; // when we perform the division by 2^T (which is equivalent to a right shift; // by T), the bottom W bits are accurate. Extra bits are okay; they'll get; // truncated out after the division by 2^T.; //; // In comparison to just directly using the first formula, this technique; // is much more efficient; using the first formula requires W * K bits,; // but this formula less than W + K bits. Also, the first formula requires; // a division step, whereas this formula only requires multiplies and shifts.; //; // It doesn't matter whether the subtraction step is done in the calculation; // width or the input iteration count's width; if the subtraction overflows,; // the result must be zero anyway. We prefer here to do it in the width of; // the induction variable because it helps a lot for certain cases; CodeGen; // isn't smart enough to ignore the overflow, which leads to much less; // efficient code if the width of the subtraction is wider than the native; // register width.; //; // (It's possible to not widen at all by pulling out factors of 2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:345,Safety,safe,safe,345,"// We are using the following formula for BC(It, K):; //; // BC(It, K) = (It * (It - 1) * ... * (It - K + 1)) / K!; //; // Suppose, W is the bitwidth of the return value. We must be prepared for; // overflow. Hence, we must assure that the result of our computation is; // equal to the accurate one modulo 2^W. Unfortunately, division isn't; // safe in modular arithmetic.; //; // However, this code doesn't use exactly that formula; the formula it uses; // is something like the following, where T is the number of factors of 2 in; // K! (i.e. trailing zeros in the binary representation of K!), and ^ is; // exponentiation:; //; // BC(It, K) = (It * (It - 1) * ... * (It - K + 1)) / 2^T / (K! / 2^T); //; // This formula is trivially equivalent to the previous formula. However,; // this formula can be implemented much more efficiently. The trick is that; // K! / 2^T is odd, and exact division by an odd number *is* safe in modular; // arithmetic. To do exact division in modular arithmetic, all we have; // to do is multiply by the inverse. Therefore, this step can be done at; // width W.; //; // The next issue is how to safely do the division by 2^T. The way this; // is done is by doing the multiplication step at a width of at least W + T; // bits. This way, the bottom W+T bits of the product are accurate. Then,; // when we perform the division by 2^T (which is equivalent to a right shift; // by T), the bottom W bits are accurate. Extra bits are okay; they'll get; // truncated out after the division by 2^T.; //; // In comparison to just directly using the first formula, this technique; // is much more efficient; using the first formula requires W * K bits,; // but this formula less than W + K bits. Also, the first formula requires; // a division step, whereas this formula only requires multiplies and shifts.; //; // It doesn't matter whether the subtraction step is done in the calculation; // width or the input iteration count's width; if the subtraction overflows,; // the res",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:920,Safety,safe,safe,920,"// We are using the following formula for BC(It, K):; //; // BC(It, K) = (It * (It - 1) * ... * (It - K + 1)) / K!; //; // Suppose, W is the bitwidth of the return value. We must be prepared for; // overflow. Hence, we must assure that the result of our computation is; // equal to the accurate one modulo 2^W. Unfortunately, division isn't; // safe in modular arithmetic.; //; // However, this code doesn't use exactly that formula; the formula it uses; // is something like the following, where T is the number of factors of 2 in; // K! (i.e. trailing zeros in the binary representation of K!), and ^ is; // exponentiation:; //; // BC(It, K) = (It * (It - 1) * ... * (It - K + 1)) / 2^T / (K! / 2^T); //; // This formula is trivially equivalent to the previous formula. However,; // this formula can be implemented much more efficiently. The trick is that; // K! / 2^T is odd, and exact division by an odd number *is* safe in modular; // arithmetic. To do exact division in modular arithmetic, all we have; // to do is multiply by the inverse. Therefore, this step can be done at; // width W.; //; // The next issue is how to safely do the division by 2^T. The way this; // is done is by doing the multiplication step at a width of at least W + T; // bits. This way, the bottom W+T bits of the product are accurate. Then,; // when we perform the division by 2^T (which is equivalent to a right shift; // by T), the bottom W bits are accurate. Extra bits are okay; they'll get; // truncated out after the division by 2^T.; //; // In comparison to just directly using the first formula, this technique; // is much more efficient; using the first formula requires W * K bits,; // but this formula less than W + K bits. Also, the first formula requires; // a division step, whereas this formula only requires multiplies and shifts.; //; // It doesn't matter whether the subtraction step is done in the calculation; // width or the input iteration count's width; if the subtraction overflows,; // the res",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1128,Safety,safe,safely,1128,"pose, W is the bitwidth of the return value. We must be prepared for; // overflow. Hence, we must assure that the result of our computation is; // equal to the accurate one modulo 2^W. Unfortunately, division isn't; // safe in modular arithmetic.; //; // However, this code doesn't use exactly that formula; the formula it uses; // is something like the following, where T is the number of factors of 2 in; // K! (i.e. trailing zeros in the binary representation of K!), and ^ is; // exponentiation:; //; // BC(It, K) = (It * (It - 1) * ... * (It - K + 1)) / 2^T / (K! / 2^T); //; // This formula is trivially equivalent to the previous formula. However,; // this formula can be implemented much more efficiently. The trick is that; // K! / 2^T is odd, and exact division by an odd number *is* safe in modular; // arithmetic. To do exact division in modular arithmetic, all we have; // to do is multiply by the inverse. Therefore, this step can be done at; // width W.; //; // The next issue is how to safely do the division by 2^T. The way this; // is done is by doing the multiplication step at a width of at least W + T; // bits. This way, the bottom W+T bits of the product are accurate. Then,; // when we perform the division by 2^T (which is equivalent to a right shift; // by T), the bottom W bits are accurate. Extra bits are okay; they'll get; // truncated out after the division by 2^T.; //; // In comparison to just directly using the first formula, this technique; // is much more efficient; using the first formula requires W * K bits,; // but this formula less than W + K bits. Also, the first formula requires; // a division step, whereas this formula only requires multiplies and shifts.; //; // It doesn't matter whether the subtraction step is done in the calculation; // width or the input iteration count's width; if the subtraction overflows,; // the result must be zero anyway. We prefer here to do it in the width of; // the induction variable because it helps a lot for certai",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:113,Safety,avoid,avoid,113,// Calculate K! / 2^T and T; we divide out the factors of two before; // multiplying for calculating K! / 2^T to avoid overflow.; // Other overflow doesn't matter because we only care about the bottom; // W bits of the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:89,Performance,perform,perform,89,// Calculate the multiplicative inverse of K! / 2^T;; // this multiplication factor will perform the exact division by; // K! / 2^T.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:94,Performance,perform,performed,94,// The computation is correct in the face of overflow provided that the; // multiplication is performed _after_ the evaluation of the binomial; // coefficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:65,Modifiability,rewrite,rewrites,65,"// We could be called with an integer-typed operands during SCEV rewrites.; // Since the operand is an integer already, just perform zext/trunc/self cast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:125,Performance,perform,perform,125,"// We could be called with an integer-typed operands during SCEV rewrites.; // Since the operand is an integer already, just perform zext/trunc/self cast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:22,Performance,optimiz,optimizations,22,// It isn't legal for optimizations to construct new ptrtoint expressions; // for non-integral pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:49,Energy Efficiency,reduce,reduce,49,"// If not, is this expression something we can't reduce any further?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Performance,Perform,Perform,3,"// Perform some basic constant folding. If the operand of the ptr2int cast; // is a null pointer, don't create a ptr2int SCEV expression (that will be; // left as-is), but produce a zero constant.; // NOTE: We could handle a more general case, but lack motivational cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:309,Availability,down,down,309,"// Otherwise, we've got some expression that is more complex than just a; // single SCEVUnknown. But we don't want to have a SCEVPtrToIntExpr of an; // arbitrary expression, we want to have SCEVPtrToIntExpr of an SCEVUnknown; // only, and the expressions must otherwise be integer-typed.; // So sink the cast down to the SCEVUnknown's.; /// The SCEVPtrToIntSinkingRewriter takes a scalar evolution expression,; /// which computes a pointer-typed value, and rewrites the whole expression; /// tree so that *all* the computations are done on integers, and the only; /// pointer-typed operands in the expression are SCEVUnknown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:457,Modifiability,rewrite,rewrites,457,"// Otherwise, we've got some expression that is more complex than just a; // single SCEVUnknown. But we don't want to have a SCEVPtrToIntExpr of an; // arbitrary expression, we want to have SCEVPtrToIntExpr of an SCEVUnknown; // only, and the expressions must otherwise be integer-typed.; // So sink the cast down to the SCEVUnknown's.; /// The SCEVPtrToIntSinkingRewriter takes a scalar evolution expression,; /// which computes a pointer-typed value, and rewrites the whole expression; /// tree so that *all* the computations are done on integers, and the only; /// pointer-typed operands in the expression are SCEVUnknown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:35,Availability,down,down,35,"// Else, recursively sink the cast down into it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:16,Performance,perform,perform,16,// And actually perform the cast sinking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:62,Performance,cache,cache,62,"// Although we checked in the beginning that ID is not in the cache, it is; // possible that during recursion and different modification ID was inserted; // into the cache. So if we find it, just return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:166,Performance,cache,cache,166,"// Although we checked in the beginning that ID is not in the cache, it is; // possible that during recursion and different modification ID was inserted; // into the cache. So if we find it, just return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:59,Integrability,Wrap,WrapType,59,"// Members present:; //; // static const SCEV::NoWrapFlags WrapType;; //; // static const ExtendOpTraitsBase::GetExtendExprTy GetExtendExpr;; //; // static const SCEV *getOverflowLimitForStep(const SCEV *Step,; // ICmpInst::Predicate *Pred,; // ScalarEvolution *SE);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:90,Modifiability,Extend,ExtendOpTraitsBase,90,"// Members present:; //; // static const SCEV::NoWrapFlags WrapType;; //; // static const ExtendOpTraitsBase::GetExtendExprTy GetExtendExpr;; //; // static const SCEV *getOverflowLimitForStep(const SCEV *Step,; // ICmpInst::Predicate *Pred,; // ScalarEvolution *SE);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:91,Integrability,wrap,wrap,91,"// end anonymous namespace; // The recurrence AR has been shown to have no signed/unsigned wrap or something; // close to it. Typically, if we can prove NSW/NUW for AR, then we can just as; // easily prove NSW/NUW for its preincrement or postincrement sibling. This; // allows normalizing a sign/zero extended AddRec as such: {sext/zext(Step +; // Start),+,Step} => {(Step + sext/zext(Start),+,Step} As a result, the; // expression ""Step + sext/zext(PreIncAR)"" is congruent with; // ""sext/zext(PostIncAR)""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:301,Modifiability,extend,extended,301,"// end anonymous namespace; // The recurrence AR has been shown to have no signed/unsigned wrap or something; // close to it. Typically, if we can prove NSW/NUW for AR, then we can just as; // easily prove NSW/NUW for its preincrement or postincrement sibling. This; // allows normalizing a sign/zero extended AddRec as such: {sext/zext(Step +; // Start),+,Step} => {(Step + sext/zext(Start),+,Step} As a result, the; // expression ""Step + sext/zext(PreIncAR)"" is congruent with; // ""sext/zext(PostIncAR)""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:15,Usability,simpl,simple,15,// Check for a simple looking step prior to loop entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:118,Performance,perform,perform,118,"// Create an AddExpr for ""PreStart"" after subtracting Step. Full SCEV; // subtraction is expensive. For this purpose, perform a quick and dirty; // difference, by checking for Step in the operand list. Note, that; // SA might have repeated ops, like %a + %a + ..., so only remove one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:17,Integrability,Wrap,WrapType,17,// Try to prove `WrapType` (SCEV::FlagNSW or SCEV::FlagNUW) on `PreStart` +; // `Step`:; // 1. NSW/NUW flags on the step increment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:55,Integrability,Wrap,WrapType,55,"// If we know `AR` == {`PreStart`+`Step`,+,`Step`} is `WrapType` (FlagNSW; // or FlagNUW) and that `PreStart` + `Step` is `WrapType` too, then; // `PreAR` == {`PreStart`,+,`Step`} is also `WrapType`. Cache this fact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:123,Integrability,Wrap,WrapType,123,"// If we know `AR` == {`PreStart`+`Step`,+,`Step`} is `WrapType` (FlagNSW; // or FlagNUW) and that `PreStart` + `Step` is `WrapType` too, then; // `PreAR` == {`PreStart`,+,`Step`} is also `WrapType`. Cache this fact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:189,Integrability,Wrap,WrapType,189,"// If we know `AR` == {`PreStart`+`Step`,+,`Step`} is `WrapType` (FlagNSW; // or FlagNUW) and that `PreStart` + `Step` is `WrapType` too, then; // `PreAR` == {`PreStart`,+,`Step`} is also `WrapType`. Cache this fact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:200,Performance,Cache,Cache,200,"// If we know `AR` == {`PreStart`+`Step`,+,`Step`} is `WrapType` (FlagNSW; // or FlagNUW) and that `PreStart` + `Step` is `WrapType` too, then; // `PreAR` == {`PreStart`,+,`Step`} is also `WrapType`. Cache this fact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:35,Modifiability,extend,extended,35,// Get the normalized zero or sign extended expression for this AddRec's Start.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:172,Integrability,wrap,wrap,172,"// Try to prove away overflow by looking at ""nearby"" add recurrences. A; // motivating example for this rule: if we know `{0,+,4}` is `ult` `-1` and it; // does not itself wrap then we can conclude that `{1,+,4}` is `nuw`.; //; // Formally:; //; // {S,+,X} == {S-T,+,X} + T; // => Ext({S,+,X}) == Ext({S-T,+,X} + T); //; // If ({S-T,+,X} + T) does not overflow ... (1); //; // RHS == Ext({S-T,+,X} + T) == Ext({S-T,+,X}) + Ext(T); //; // If {S-T,+,X} does not overflow ... (2); //; // RHS == Ext({S-T,+,X}) + Ext(T) == {Ext(S-T),+,Ext(X)} + Ext(T); // == {Ext(S-T)+Ext(T),+,Ext(X)}; //; // If (S-T)+T does not overflow ... (3); //; // RHS == {Ext(S-T)+Ext(T),+,Ext(X)} == {Ext(S-T+T),+,Ext(X)}; // == {Ext(S),+,Ext(X)} == LHS; //; // Thus, if (1), (2) and (3) are true for some T, then; // Ext({S,+,X}) == {Ext(S),+,Ext(X)}; //; // (3) is implied by (1) -- ""(S-T)+T does not overflow"" is simply ""({S-T,+,X}+T); // does not overflow"" restricted to the 0th iteration. Therefore we only need; // to check for (1) and (2).; //; // In the current context, S is `Start`, X is `Step`, Ext is `ExtendOpTy` and T; // is `Delta` (defined below).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1086,Modifiability,Extend,ExtendOpTy,1086,"// Try to prove away overflow by looking at ""nearby"" add recurrences. A; // motivating example for this rule: if we know `{0,+,4}` is `ult` `-1` and it; // does not itself wrap then we can conclude that `{1,+,4}` is `nuw`.; //; // Formally:; //; // {S,+,X} == {S-T,+,X} + T; // => Ext({S,+,X}) == Ext({S-T,+,X} + T); //; // If ({S-T,+,X} + T) does not overflow ... (1); //; // RHS == Ext({S-T,+,X} + T) == Ext({S-T,+,X}) + Ext(T); //; // If {S-T,+,X} does not overflow ... (2); //; // RHS == Ext({S-T,+,X}) + Ext(T) == {Ext(S-T),+,Ext(X)} + Ext(T); // == {Ext(S-T)+Ext(T),+,Ext(X)}; //; // If (S-T)+T does not overflow ... (3); //; // RHS == {Ext(S-T)+Ext(T),+,Ext(X)} == {Ext(S-T+T),+,Ext(X)}; // == {Ext(S),+,Ext(X)} == LHS; //; // Thus, if (1), (2) and (3) are true for some T, then; // Ext({S,+,X}) == {Ext(S),+,Ext(X)}; //; // (3) is implied by (1) -- ""(S-T)+T does not overflow"" is simply ""({S-T,+,X}+T); // does not overflow"" restricted to the 0th iteration. Therefore we only need; // to check for (1) and (2).; //; // In the current context, S is `Start`, X is `Step`, Ext is `ExtendOpTy` and T; // is `Delta` (defined below).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:888,Usability,simpl,simply,888,"// Try to prove away overflow by looking at ""nearby"" add recurrences. A; // motivating example for this rule: if we know `{0,+,4}` is `ult` `-1` and it; // does not itself wrap then we can conclude that `{1,+,4}` is `nuw`.; //; // Formally:; //; // {S,+,X} == {S-T,+,X} + T; // => Ext({S,+,X}) == Ext({S-T,+,X} + T); //; // If ({S-T,+,X} + T) does not overflow ... (1); //; // RHS == Ext({S-T,+,X} + T) == Ext({S-T,+,X}) + Ext(T); //; // If {S-T,+,X} does not overflow ... (2); //; // RHS == Ext({S-T,+,X}) + Ext(T) == {Ext(S-T),+,Ext(X)} + Ext(T); // == {Ext(S-T)+Ext(T),+,Ext(X)}; //; // If (S-T)+T does not overflow ... (3); //; // RHS == {Ext(S-T)+Ext(T),+,Ext(X)} == {Ext(S-T+T),+,Ext(X)}; // == {Ext(S),+,Ext(X)} == LHS; //; // Thus, if (1), (2) and (3) are true for some T, then; // Ext({S,+,X}) == {Ext(S),+,Ext(X)}; //; // (3) is implied by (1) -- ""(S-T)+T does not overflow"" is simply ""({S-T,+,X}+T); // does not overflow"" restricted to the 0th iteration. Therefore we only need; // to check for (1) and (2).; //; // In the current context, S is `Start`, X is `Step`, Ext is `ExtendOpTy` and T; // is `Delta` (defined below).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:136,Integrability,wrap,wrap,136,"// Finds an integer D for an expression (C + x + y + ...) such that the top; // level addition in (D + (C - D + x + y + ...)) would not wrap (signed or; // unsigned) and the number of trailing zeros of (C - D + x + y + ...) is; // maximized, where C is the \p ConstantTerm, x, y, ... are arbitrary SCEVs, and; // the (C + x + y + ...) expression is \p WholeAddExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:145,Integrability,wrap,wrap,145,// Set D to be as many least significant bits of C as possible while still; // guaranteeing that adding D to (C - D + x + y + ...) won't cause a wrap:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:128,Integrability,wrap,wrap,128,"// Finds an integer D for an affine AddRec expression {C,+,x} such that the top; // level addition in (D + {C-D,+,x}) would not wrap (signed or unsigned) and the; // number of trailing zeros of (C - D + x * n) is maximized, where C is the \p; // ConstantStart, x is an arbitrary \p Step, and n is the loop trip count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:104,Usability,simpl,simplify,104,"// It's possible the bits taken off by the truncate were all zero bits. If; // so, we should be able to simplify this further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:129,Modifiability,extend,extend,129,"// If the input value is a chrec scev, and we can prove that the value; // did not overflow the old, smaller, value, we can zero extend all of the; // operands (often constants). This allows analysis of something like; // this: for (unsigned char X = 0; X < 100; ++X) { int Y = X; }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:140,Usability,simpl,simply,140,"// Check whether the backedge-taken count is SCEVCouldNotCompute.; // Note that this serves two purposes: It filters out loops that are; // simply not analyzable, and it covers the case where this code is; // being called from within backedge-taken count analysis, such that; // attempting to ask for the backedge-taken count would likely result; // in infinite recursion. In the later case, the analysis code will; // cope with a conservative value, and it will take care to purge; // that value once it has finished.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Performance,Cache,Cache,3,"// Cache knowledge of AR NUW, which is propagated to this AddRec.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:101,Availability,down,down,101,"// Similar to above, only this time treat the step value as signed.; // This covers loops that count down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:99,Integrability,wrap,wrap,99,"// Cache knowledge of AR NW, which is propagated to this AddRec.; // Negative step causes unsigned wrap, but it still can't self-wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:129,Integrability,wrap,wrap,129,"// Cache knowledge of AR NW, which is propagated to this AddRec.; // Negative step causes unsigned wrap, but it still can't self-wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Performance,Cache,Cache,3,"// Cache knowledge of AR NW, which is propagated to this AddRec.; // Negative step causes unsigned wrap, but it still can't self-wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:372,Safety,avoid,avoid,372,"// Normally, in the cases we can prove no-overflow via a; // backedge guarding condition, we can also compute a backedge; // taken count for the loop. The exceptions are assumptions and; // guards present in the loop -- SCEV is not great at exploiting; // these to compute max backedge taken counts, but can still use; // these to prove lack of overflow. Use this fact to avoid; // doing extra work that may not pay off.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:47,Safety,avoid,avoid,47,"// Same as nuw case above - duplicated here to avoid a compile time; // issue. It's not clear that the order of checks does matter, but; // it's one of two issue possible causes for a change which was; // reverted. Be conservative for the moment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:88,Usability,clear,clear,88,"// Same as nuw case above - duplicated here to avoid a compile time; // issue. It's not clear that the order of checks does matter, but; // it's one of two issue possible causes for a change which was; // reverted. Be conservative for the moment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:31,Modifiability,extend,extend,31,"// For a negative step, we can extend the operands iff doing so only; // traverses values in the range zext([0,UINT_MAX]).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:99,Integrability,wrap,wrap,99,"// Cache knowledge of AR NW, which is propagated to this; // AddRec. Negative step causes unsigned wrap, but it; // still can't self-wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:133,Integrability,wrap,wrap,133,"// Cache knowledge of AR NW, which is propagated to this; // AddRec. Negative step causes unsigned wrap, but it; // still can't self-wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Performance,Cache,Cache,3,"// Cache knowledge of AR NW, which is propagated to this; // AddRec. Negative step causes unsigned wrap, but it; // still can't self-wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:127,Integrability,wrap,wrap,127,"// zext({C,+,Step}) --> (zext(D) + zext({C-D,+,Step}))<nuw><nsw>; // if D + (C - D + Step * n) could be proven to not unsigned wrap; // where D maximizes the number of trailing zeros of (C - D + Step * n)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:134,Integrability,wrap,wrap,134,"// zext(C + x + y + ...) --> (zext(D) + zext((C - D) + x + y + ...)); // if D + (C - D + x + y + ...) could be proven to not unsigned wrap; // where D maximizes the number of trailing zeros of (C - D + x + y + ...); //; // Often address arithmetics contain expressions like; // (zext (add (shl X, C1), C2)), for instance, (zext (5 + (4 * X))).; // This transformation is useful while proving that such expressions are; // equal or differ by a small constant amount, see LoadStoreVectorizer pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:470,Performance,Load,LoadStoreVectorizer,470,"// zext(C + x + y + ...) --> (zext(D) + zext((C - D) + x + y + ...)); // if D + (C - D + x + y + ...) could be proven to not unsigned wrap; // where D maximizes the number of trailing zeros of (C - D + x + y + ...); //; // Often address arithmetics contain expressions like; // (zext (add (shl X, C1), C2)), for instance, (zext (5 + (4 * X))).; // This transformation is useful while proving that such expressions are; // equal or differ by a small constant amount, see LoadStoreVectorizer pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:104,Usability,simpl,simplify,104,"// It's possible the bits taken off by the truncate were all sign bits. If; // so, we should be able to simplify this further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:132,Integrability,wrap,wrap,132,"// sext(C + x + y + ...) --> (sext(D) + sext((C - D) + x + y + ...)); // if D + (C - D + x + y + ...) could be proven to not signed wrap; // where D maximizes the number of trailing zeros of (C - D + x + y + ...); //; // For instance, this will bring two seemingly different expressions:; // 1 + sext(5 + 20 * %x + 24 * %y) and; // sext(6 + 20 * %x + 24 * %y); // to the same form:; // 2 + sext(4 + 20 * %x + 24 * %y)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:129,Modifiability,extend,extend,129,"// If the input value is a chrec scev, and we can prove that the value; // did not overflow the old, smaller, value, we can sign extend all of the; // operands (often constants). This allows analysis of something like; // this: for (signed char X = 0; X < 100; ++X) { int Y = X; }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:140,Usability,simpl,simply,140,"// Check whether the backedge-taken count is SCEVCouldNotCompute.; // Note that this serves two purposes: It filters out loops that are; // simply not analyzable, and it covers the case where this code is; // being called from within backedge-taken count analysis, such that; // attempting to ask for the backedge-taken count would likely result; // in infinite recursion. In the later case, the analysis code will; // cope with a conservative value, and it will take care to purge; // that value once it has finished.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Performance,Cache,Cache,3,"// Cache knowledge of AR NSW, which is propagated to this AddRec.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:9,Integrability,wrap,wraps,9,// If AR wraps around then; //; // abs(Step) * MaxBECount > unsigned-max(AR->getType()); // => SAdd != OperandExtendedAdd; //; // Thus (AR is not NW => SAdd != OperandExtendedAdd) <=>; // (SAdd == OperandExtendedAdd => AR is NW),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:47,Safety,avoid,avoid,47,"// Same as nsw case above - duplicated here to avoid a compile time; // issue. It's not clear that the order of checks does matter, but; // it's one of two issue possible causes for a change which was; // reverted. Be conservative for the moment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:88,Usability,clear,clear,88,"// Same as nsw case above - duplicated here to avoid a compile time; // issue. It's not clear that the order of checks does matter, but; // it's one of two issue possible causes for a change which was; // reverted. Be conservative for the moment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:125,Integrability,wrap,wrap,125,"// sext({C,+,Step}) --> (sext(D) + sext({C-D,+,Step}))<nuw><nsw>; // if D + (C - D + Step * n) could be proven to not signed wrap; // where D maximizes the number of trailing zeros of (C - D + Step * n)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:60,Usability,simpl,simplify,60,// If the input value is provably positive and we could not simplify; // away the sext build a zext instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:59,Modifiability,extend,extended,59,/// getAnyExtendExpr - Return a SCEV for the given operand extended with; /// unspecified bits out to the given type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:8,Modifiability,extend,extend,8,// Sign-extend negative constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:100,Deployability,update,update,100,"/// Process the given Ops list, which is a list of operands to be added under; /// the given scale, update the given map. This is a helper function for; /// getAddRecExpr. As an example of what it does, given a sequence of operands; /// that would form an add expression like this:; ///; /// m + n + 13 + (A * (o + p + (B * (q + m + 29)))) + r + (-1 * r); ///; /// where A and B are constants, update the map with these values:; ///; /// (m, 1+A*B), (n, 1), (o, A), (p, A), (q, A*B), (r, 0); ///; /// and add 13 + A*B*29 to AccumulatedConstant.; /// This will allow getAddRecExpr to produce this:; ///; /// 13+A*B*29 + n + (m * (1+A*B)) + ((o + p) * A) + (q * A*B); ///; /// This form often exposes folding opportunities that are hidden in; /// the original operand list.; ///; /// Return true iff it appears that any interesting folding opportunities; /// may be exposed. This helps getAddRecExpr short-circuit extra work in; /// the common case where no interesting opportunities are present, and; /// is also used as a check to avoid infinite recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:394,Deployability,update,update,394,"/// Process the given Ops list, which is a list of operands to be added under; /// the given scale, update the given map. This is a helper function for; /// getAddRecExpr. As an example of what it does, given a sequence of operands; /// that would form an add expression like this:; ///; /// m + n + 13 + (A * (o + p + (B * (q + m + 29)))) + r + (-1 * r); ///; /// where A and B are constants, update the map with these values:; ///; /// (m, 1+A*B), (n, 1), (o, A), (p, A), (q, A*B), (r, 0); ///; /// and add 13 + A*B*29 to AccumulatedConstant.; /// This will allow getAddRecExpr to produce this:; ///; /// 13+A*B*29 + n + (m * (1+A*B)) + ((o + p) * A) + (q * A*B); ///; /// This form often exposes folding opportunities that are hidden in; /// the original operand list.; ///; /// Return true iff it appears that any interesting folding opportunities; /// may be exposed. This helps getAddRecExpr short-circuit extra work in; /// the common case where no interesting opportunities are present, and; /// is also used as a check to avoid infinite recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1031,Safety,avoid,avoid,1031,"/// Process the given Ops list, which is a list of operands to be added under; /// the given scale, update the given map. This is a helper function for; /// getAddRecExpr. As an example of what it does, given a sequence of operands; /// that would form an add expression like this:; ///; /// m + n + 13 + (A * (o + p + (B * (q + m + 29)))) + r + (-1 * r); ///; /// where A and B are constants, update the map with these values:; ///; /// (m, 1+A*B), (n, 1), (o, A), (p, A), (q, A*B), (r, 0); ///; /// and add 13 + A*B*29 to AccumulatedConstant.; /// This will allow getAddRecExpr to produce this:; ///; /// 13+A*B*29 + n + (m * (1+A*B)) + ((o + p) * A) + (q * A*B); ///; /// This form often exposes folding opportunities that are hidden in; /// the original operand list.; ///; /// Return true iff it appears that any interesting folding opportunities; /// may be exposed. This helps getAddRecExpr short-circuit extra work in; /// the common case where no interesting opportunities are present, and; /// is also used as a check to avoid infinite recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:691,Security,expose,exposes,691,"/// Process the given Ops list, which is a list of operands to be added under; /// the given scale, update the given map. This is a helper function for; /// getAddRecExpr. As an example of what it does, given a sequence of operands; /// that would form an add expression like this:; ///; /// m + n + 13 + (A * (o + p + (B * (q + m + 29)))) + r + (-1 * r); ///; /// where A and B are constants, update the map with these values:; ///; /// (m, 1+A*B), (n, 1), (o, A), (p, A), (q, A*B), (r, 0); ///; /// and add 13 + A*B*29 to AccumulatedConstant.; /// This will allow getAddRecExpr to produce this:; ///; /// 13+A*B*29 + n + (m * (1+A*B)) + ((o + p) * A) + (q * A*B); ///; /// This form often exposes folding opportunities that are hidden in; /// the original operand list.; ///; /// Return true iff it appears that any interesting folding opportunities; /// may be exposed. This helps getAddRecExpr short-circuit extra work in; /// the common case where no interesting opportunities are present, and; /// is also used as a check to avoid infinite recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:864,Security,expose,exposed,864,"/// Process the given Ops list, which is a list of operands to be added under; /// the given scale, update the given map. This is a helper function for; /// getAddRecExpr. As an example of what it does, given a sequence of operands; /// that would form an add expression like this:; ///; /// m + n + 13 + (A * (o + p + (B * (q + m + 29)))) + r + (-1 * r); ///; /// where A and B are constants, update the map with these values:; ///; /// (m, 1+A*B), (n, 1), (o, A), (p, A), (q, A*B), (r, 0); ///; /// and add 13 + A*B*29 to AccumulatedConstant.; /// This will allow getAddRecExpr to produce this:; ///; /// 13+A*B*29 + n + (m * (1+A*B)) + ((o + p) * A) + (q * A*B); ///; /// This form often exposes folding opportunities that are hidden in; /// the original operand list.; ///; /// Return true iff it appears that any interesting folding opportunities; /// may be exposed. This helps getAddRecExpr short-circuit extra work in; /// the common case where no interesting opportunities are present, and; /// is also used as a check to avoid infinite recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:57,Deployability,Update,Update,57,// A multiplication of a constant with some other value. Update; // the map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:24,Deployability,Update,Update,24,// An ordinary operand. Update the map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:21,Availability,down,down,21,"// To avoid overflow down, we need to make sure that MIN + Magnitude <= LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:6,Safety,avoid,avoid,6,"// To avoid overflow down, we need to make sure that MIN + Magnitude <= LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:6,Safety,avoid,avoid,6,"// To avoid overflow up, we need to make sure that LHS <= MAX - Magnitude.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:102,Integrability,wrap,wrap,102,// We're trying to construct a SCEV of type `Type' with `Ops' as operands and; // `OldFlags' as can't-wrap behavior. Infer a more aggressive set of; // can't-overflow flags for the operation if possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:49,Usability,simpl,simpler,49,"/// Get a canonical add expression, or something simpler if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:289,Usability,simpl,simple,289,"// Check for truncates. If all the operands are truncated from the same; // type, see if factoring out the truncate would permit the result to be; // folded. eg., n*trunc(x) + m*trunc(y) --> trunc(trunc(m)*x + trunc(n)*y); // if the contents of the resulting outer trunc fold to something simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:28,Usability,simpl,simple,28,"// If it folds to something simple, use it. Otherwise, don't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:128,Integrability,wrap,wrapping,128,"// Check if we have an expression of the form ((X + C1) - C2), where C1 and; // C2 can be folded in a way that allows retaining wrapping flags of (X +; // C1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:176,Integrability,depend,depend,176,"// If the original flags and all inlined SCEVAddExprs are NUW, use the; // common NUW flag for expression after inlining. Other flags cannot be; // preserved, because they may depend on the original order of operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:153,Safety,avoid,avoid,153,"// Some interesting folding opportunity is present, so its worthwhile to; // re-generate the operands list. Group the operands by constant scale,; // to avoid multiplying by the same constant scale multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:24,Safety,safe,safe,24,"// It is not in general safe to propagate flags valid on an add within; // the addrec scope to one outside it. We must prove that the inner; // scope is guaranteed to execute if the outer one does to be able to; // safely propagate. We know the program is undefined if poison is; // produced on the inner scoped addrec. We also know that *for this use*; // the outer scoped add can't overflow (because of the flags we just; // computed for the inner scoped add) without the program being undefined.; // Proving that entry to the outer scope neccesitates entry to the inner; // scope, thus proves the program undefined if the flags would be violated; // in the outer scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:215,Safety,safe,safely,215,"// It is not in general safe to propagate flags valid on an add within; // the addrec scope to one outside it. We must prove that the inner; // scope is guaranteed to execute if the outer one does to be able to; // safely propagate. We know the program is undefined if poison is; // produced on the inner scoped addrec. We also know that *for this use*; // the outer scoped add can't overflow (because of the flags we just; // computed for the inner scoped add) without the program being undefined.; // Proving that entry to the outer scope neccesitates entry to the inner; // scope, thus proves the program undefined if the flags would be violated; // in the outer scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:137,Modifiability,variab,variable,137,"// Okay, if there weren't any loop invariants to be folded, check to see if; // there are multiple AddRec's with the same loop induction variable being; // added together. If so, we can fold them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:57,Integrability,wrap,wraparound,57,"// Step size has changed, so we cannot guarantee no self-wraparound.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:187,Usability,clear,cleared,187,"/// Compute the result of ""n choose k"", the binomial coefficient. If an; /// intermediate computation overflows, Overflow will be set and the return will; /// be garbage. Overflow is not cleared on absence of overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:269,Energy Efficiency,reduce,reduce,269,"// We use the multiplicative formula:; // n(n-1)(n-2)...(n-(k-1)) / k(k-1)(k-2)...1 .; // At each iteration, we take the n-th term of the numeral and divide by the; // (k-n)th term of the denominator. This division will always produce an; // integral result, and helps reduce the chance of overflow in the; // intermediate computations. However, we can still overflow even when the; // final result would fit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:54,Usability,simpl,simpler,54,"/// Get a canonical multiply expression, or something simpler if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:279,Availability,down,down,279,"// If any of Add's ops are Adds or Muls with a constant, apply this; // transformation as well.; //; // TODO: There are some cases where this transformation is not; // profitable; for example, Add = (C0 + X) * Y + Z. Maybe the scope of; // this transformation should be narrowed down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:45,Integrability,wrap,wrap,45,// Negation preserves a recurrence's no self-wrap property.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:137,Modifiability,variab,variable,137,"// Okay, if there weren't any loop invariants to be folded, check to see; // if there are multiple AddRec's with the same loop induction variable; // being multiplied together. If so, we can fold them.; // {A1,+,A2,+,...,+,An}<L> * {B1,+,B2,+,...,+,Bn}<L>; // = {x=1 in [ sum y=x..2x [ sum z=max(y-x, y-n)..min(x,n) [; // choose(x, 2x)*choose(2x-y, x-z)*A_{y-z}*B_z; // ]]],+,...up to x=2n}.; // Note that the arguments to choose() are always integers with values; // known at compile time, never SCEV objects.; //; // The implementation avoids pointless extra computations when the two; // addrec's are of different length (mathematically, it's equivalent to; // an infinite stream of zeros on the right).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:538,Safety,avoid,avoids,538,"// Okay, if there weren't any loop invariants to be folded, check to see; // if there are multiple AddRec's with the same loop induction variable; // being multiplied together. If so, we can fold them.; // {A1,+,A2,+,...,+,An}<L> * {B1,+,B2,+,...,+,Bn}<L>; // = {x=1 in [ sum y=x..2x [ sum z=max(y-x, y-n)..min(x,n) [; // choose(x, 2x)*choose(2x-y, x-z)*A_{y-z}*B_z; // ]]],+,...up to x=2n}.; // Note that the arguments to choose() are always integers with values; // known at compile time, never SCEV objects.; //; // The implementation avoids pointless extra computations when the two; // addrec's are of different length (mathematically, it's equivalent to; // an infinite stream of zeros on the right).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:36,Safety,avoid,avoid,36,// Limit max number of arguments to avoid creation of unreasonably big; // SCEVAddRecs with very complex operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:39,Energy Efficiency,power,power,39,"// X urem 1 --> 0; // If constant is a power of two, fold into a zext(trunc(LHS)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:63,Usability,simpl,simpler,63,"/// Get a canonical unsigned division expression, or something simpler if; /// possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:11,Energy Efficiency,power,power-of-two,11,"// For non-power-of-two values, effectively round the value up to the; // nearest power of two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:82,Energy Efficiency,power,power,82,"// For non-power-of-two values, effectively round the value up to the; // nearest power of two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:32,Safety,safe,safe,32,"// {X,+,N}/C --> {X/C,+,N/C} if safe and N/C can be folded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:92,Safety,Safe,Safe,92,"/// Get a canonical UDivExpr for a recurrence.; /// {X,+,N}/C => {Y,+,N}/C where Y=X-(X%N). Safe when C%N=0.; // We can currently only fold X%N if X is constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:71,Performance,cache,cached,71,"// Reset the ID to include the new LHS, and check if it is; // already cached.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:26,Safety,safe,safe,26,// (A*B)/C --> A*(B/C) if safe and B/C can be folded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:26,Safety,safe,safely,26,// Find an operand that's safely divisible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:4,Deployability,A/B,A/B,4,// (A/B)/C --> A/(B*C) if safe and B*C can be folded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:26,Safety,safe,safe,26,// (A/B)/C --> A/(B*C) if safe and B*C can be folded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:30,Safety,safe,safe,30,// (A+B)/C --> (A/C + B/C) if safe and A/C and B/C can be folded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:63,Usability,simpl,simpler,63,"/// Get a canonical unsigned division expression, or something simpler if; /// possible. There is no representation for an exact udiv in SCEV IR, but we; /// can attempt to remove factors from the LHS and RHS. We can't do this when; /// it's not exact because the udiv may be clearing bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:276,Usability,clear,clearing,276,"/// Get a canonical unsigned division expression, or something simpler if; /// possible. There is no representation for an exact udiv in SCEV IR, but we; /// can attempt to remove factors from the LHS and RHS. We can't do this when; /// it's not exact because the udiv may be clearing bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:61,Usability,Simpl,Simplify,61,/// Get an add recurrence expression for the specified loop. Simplify the; /// expression as much as possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:61,Usability,Simpl,Simplify,61,/// Get an add recurrence expression for the specified loop. Simplify the; /// expression as much as possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:333,Performance,cache,cached,333,"// It's tempting to want to call getConstantMaxBackedgeTakenCount count here and; // use that information to infer NUW and NSW flags. However, computing a; // BE count requires calling getAddRecExpr, so we may not yet have a; // meaningful BE count at this point (and if we don't, we'd be stuck; // with a SCEVCouldNotCompute as the cached BE count).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:91,Performance,perform,perform,91,// AddRecs require their operands be loop-invariant with respect to their; // loops. Don't perform this transformation if it would break this; // requirement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Deployability,Update,Update,3,// Update CurTy to the type of the field at Index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Deployability,Update,Update,3,// Update CurTy to its element type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:129,Usability,simpl,simplify,129,"// Check to see if one of the operands is of the same kind. If so, expand its; // operands onto our operand list, and recurse to simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:52,Safety,safe,safe,52,"// If the instruction cannot be poison, it's always safe to reuse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Safety,Avoid,Avoid,3,// Avoid walking large instruction graphs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:27,Usability,simpl,simplifications,27,// FIXME: there are *some* simplifications that we can do here.; // Keep only the first instance of an operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:129,Usability,simpl,simplify,129,"// Check to see if one of the operands is of the same kind. If so, expand its; // operands onto our operand list, and recurse to simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:148,Performance,optimiz,optimization,148,// We can bypass creating a target-independent constant expression and then; // folding it back into a ConstantInt. This is just a compile-time; // optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:346,Security,access,access,346,"//===----------------------------------------------------------------------===//; // Basic SCEV Analysis and PHI Idiom Recognition Code; //; /// Test if values of the given type are analyzable within the SCEV; /// framework. This primarily includes integer types, and it can optionally; /// include pointer types if the ScalarEvolution class has access to; /// target-specific information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:145,Testability,Test,Test,145,"//===----------------------------------------------------------------------===//; // Basic SCEV Analysis and PHI Idiom Recognition Code; //; /// Test if values of the given type are analyzable within the SCEV; /// framework. This primarily includes integer types, and it can optionally; /// include pointer types if the ScalarEvolution class has access to; /// target-specific information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:105,Testability,assert,assertion,105,"// If we subtract two pointers with different pointer bases, bail.; // Eventually, we're going to add an assertion to getMulExpr that we; // can't multiply by a pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:77,Integrability,wrap,wraps,77,"// Let M be the minimum representable signed value. Then (-1)*RHS; // signed-wraps if and only if RHS is M. That can happen even for; // a NSW subtraction because e.g. (-1)*M signed-wraps even though; // -1 - M does not. So to transfer NSW from LHS - RHS to LHS +; // (-1)*RHS, we need to prove that RHS != M.; //; // If LHS is non-negative and we know that LHS - RHS does not; // signed-wrap, then RHS cannot be M. So we can rule out signed-wrap; // either by proving that RHS > M or that LHS >= 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:182,Integrability,wrap,wraps,182,"// Let M be the minimum representable signed value. Then (-1)*RHS; // signed-wraps if and only if RHS is M. That can happen even for; // a NSW subtraction because e.g. (-1)*M signed-wraps even though; // -1 - M does not. So to transfer NSW from LHS - RHS to LHS +; // (-1)*RHS, we need to prove that RHS != M.; //; // If LHS is non-negative and we know that LHS - RHS does not; // signed-wrap, then RHS cannot be M. So we can rule out signed-wrap; // either by proving that RHS > M or that LHS >= 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:388,Integrability,wrap,wrap,388,"// Let M be the minimum representable signed value. Then (-1)*RHS; // signed-wraps if and only if RHS is M. That can happen even for; // a NSW subtraction because e.g. (-1)*M signed-wraps even though; // -1 - M does not. So to transfer NSW from LHS - RHS to LHS +; // (-1)*RHS, we need to prove that RHS != M.; //; // If LHS is non-negative and we know that LHS - RHS does not; // signed-wrap, then RHS cannot be M. So we can rule out signed-wrap; // either by proving that RHS > M or that LHS >= 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:442,Integrability,wrap,wrap,442,"// Let M be the minimum representable signed value. Then (-1)*RHS; // signed-wraps if and only if RHS is M. That can happen even for; // a NSW subtraction because e.g. (-1)*M signed-wraps even though; // -1 - M does not. So to transfer NSW from LHS - RHS to LHS +; // (-1)*RHS, we need to prove that RHS != M.; //; // If LHS is non-negative and we know that LHS - RHS does not; // signed-wrap, then RHS cannot be M. So we can rule out signed-wrap; // either by proving that RHS > M or that LHS >= 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Modifiability,Extend,Extend,3,// Extend all ops to max type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:205,Modifiability,rewrite,rewrite,205,"/// Takes SCEV S and Loop L. For each AddRec sub-expression, use its start; /// expression in case its Loop is L. If it is not L then; /// if IgnoreOtherLoops is true then use AddRec itself; /// otherwise rewrite cannot be done.; /// If SCEV contains non-invariant unknown SCEV rewrite cannot be done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:278,Modifiability,rewrite,rewrite,278,"/// Takes SCEV S and Loop L. For each AddRec sub-expression, use its start; /// expression in case its Loop is L. If it is not L then; /// if IgnoreOtherLoops is true then use AddRec itself; /// otherwise rewrite cannot be done.; /// If SCEV contains non-invariant unknown SCEV rewrite cannot be done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:216,Modifiability,rewrite,rewrite,216,"/// Takes SCEV S and Loop L. For each AddRec sub-expression, use its post; /// increment expression in case its Loop is L. If it is not L then; /// use AddRec itself.; /// If SCEV contains non-invariant unknown SCEV rewrite cannot be done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:140,Usability,simpl,simply,140,"// Check whether the backedge-taken count is SCEVCouldNotCompute.; // Note that this serves two purposes: It filters out loops that are; // simply not analyzable, and it covers the case where this code is; // being called from within backedge-taken count analysis, such that; // attempting to ask for the backedge-taken count would likely result; // in infinite recursion. In the later case, the analysis code will; // cope with a conservative value, and it will take care to purge; // that value once it has finished.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:372,Safety,avoid,avoid,372,"// Normally, in the cases we can prove no-overflow via a; // backedge guarding condition, we can also compute a backedge; // taken count for the loop. The exceptions are assumptions and; // guards present in the loop -- SCEV is not great at exploiting; // these to compute max backedge taken counts, but can still use; // these to prove lack of overflow. Use this fact to avoid; // doing extra work that may not pay off.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:87,Safety,safe,safe,87,"// If the backedge is guarded by a comparison with the pre-inc value the; // addrec is safe. Also, if the entry is guarded by a comparison with the; // start value and the backedge is guarded by a comparison with the post-inc; // value, the addrec is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:251,Safety,safe,safe,251,"// If the backedge is guarded by a comparison with the pre-inc value the; // addrec is safe. Also, if the entry is guarded by a comparison with the; // start value and the backedge is guarded by a comparison with the post-inc; // value, the addrec is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:140,Usability,simpl,simply,140,"// Check whether the backedge-taken count is SCEVCouldNotCompute.; // Note that this serves two purposes: It filters out loops that are; // simply not analyzable, and it covers the case where this code is; // being called from within backedge-taken count analysis, such that; // attempting to ask for the backedge-taken count would likely result; // in infinite recursion. In the later case, the analysis code will; // cope with a conservative value, and it will take care to purge; // that value once it has finished.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:372,Safety,avoid,avoid,372,"// Normally, in the cases we can prove no-overflow via a; // backedge guarding condition, we can also compute a backedge; // taken count for the loop. The exceptions are assumptions and; // guards present in the loop -- SCEV is not great at exploiting; // these to compute max backedge taken counts, but can still use; // these to prove lack of overflow. Use this fact to avoid; // doing extra work that may not pay off.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:87,Safety,safe,safe,87,"// If the backedge is guarded by a comparison with the pre-inc value the; // addrec is safe. Also, if the entry is guarded by a comparison with the; // start value and the backedge is guarded by a comparison with the post-inc; // value, the addrec is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:251,Safety,safe,safe,251,"// If the backedge is guarded by a comparison with the pre-inc value the; // addrec is safe. Also, if the entry is guarded by a comparison with the; // start value and the backedge is guarded by a comparison with the post-inc; // value, the addrec is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:95,Availability,failure,failure,95,"// end anonymous namespace; /// Try to map \p V into a BinaryOp, and return \c std::nullopt on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:137,Safety,avoid,avoid,137,"// Implementation detail: all the cleverness here should happen without; // creating new SCEV expressions -- our caller knowns tricks to avoid creating; // SCEV expressions when possible, and we should not break that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:8,Testability,log,logical,8,// Turn logical shift right of a constant into a unsigned divide.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:135,Deployability,update,updated,135,"/// Helper function to createAddRecFromPHIWithCasts. We have a phi; /// node whose symbolic (unknown) SCEV is \p SymbolicPHI, which is updated via; /// the loop backedge by a SCEVAddExpr, possibly also with a few casts on the; /// way. This function checks if \p Op, an operand of this SCEVAddExpr,; /// follows one of the following patterns:; /// Op == (SExt ix (Trunc iy (%SymbolicPHI) to ix) to iy); /// Op == (ZExt ix (Trunc iy (%SymbolicPHI) to ix) to iy); /// If the SCEV expression of \p Op conforms with one of the expected patterns; /// we return the type of the truncation operation, and indicate whether the; /// truncated type should be treated as signed/unsigned by setting; /// \p Signed to true/false, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:137,Testability,log,logic,137,"// The case where Op == SymbolicPHI (that is, with no type conversions on; // the way) is handled by the regular add recurrence creating logic and; // would have already been triggered in createAddRecForPHI. Reaching it here; // means that createAddRecFromPHI had failed for this PHI before (e.g.,; // because one of the other operands of the SCEVAddExpr updating this PHI is; // not invariant).; //; // Here we look for the case where Op = (ext(trunc(SymbolicPHI))), and in; // this case predicates that allow us to prove that Op == SymbolicPHI will; // be added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2095,Availability,redundant,redundant,2095,"analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be ignored by; // the cost model and to avoid vectorizing them (otherwise these casts,; // which are redundant under the runtime overflow checks, will be; // vectorized, which can be costly).; //; // 2) Support additional induction/PHISCEV patterns: We also want to support; // inductions where the sext-trunc / zext-trunc operations (partly) occur; // after the induction update operation (the induction increment):; //; // (Trunc iy (SExt/ZExt ix (%SymbolicPHI + InvariantAccum) to iy) to ix); // which correspond to a phi->add->trunc->sext/zext->phi update chain.; //; // (Trunc iy ((SExt/ZExt ix (%SymbolicPhi) to iy) + InvariantAccum) to ix); // which correspond to a phi->trunc->add->sext/zext->phi update chain.; //; // 3) Outline common code with createAddRecFromPHI to avoid duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:98,Deployability,update,updates,98,"// Analyze \p SymbolicPHI, a SCEV expression of a phi node, and check if the; // computation that updates the phi follows the following pattern:; // (SExt/ZExt ix (Trunc iy (%SymbolicPHI) to ix) to iy) + InvariantAccum; // which correspond to a phi->trunc->sext/zext->add->phi update chain.; // If so, try to see if it can be rewritten as an AddRecExpr under some; // Predicates. If successful, return them as a pair. Also cache the results; // of the analysis.; //; // Example usage scenario:; // Say the Rewriter is called for the following SCEV:; // 8 * ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // where:; // %X = phi i64 (%Start, %BEValue); // It will visitMul->visitAdd->visitSExt->visitTrunc->visitUnknown(%X),; // and call this function with %SymbolicPHI = %X.; //; // The analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be igno",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:277,Deployability,update,update,277,"// Analyze \p SymbolicPHI, a SCEV expression of a phi node, and check if the; // computation that updates the phi follows the following pattern:; // (SExt/ZExt ix (Trunc iy (%SymbolicPHI) to ix) to iy) + InvariantAccum; // which correspond to a phi->trunc->sext/zext->add->phi update chain.; // If so, try to see if it can be rewritten as an AddRecExpr under some; // Predicates. If successful, return them as a pair. Also cache the results; // of the analysis.; //; // Example usage scenario:; // Say the Rewriter is called for the following SCEV:; // 8 * ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // where:; // %X = phi i64 (%Start, %BEValue); // It will visitMul->visitAdd->visitSExt->visitTrunc->visitUnknown(%X),; // and call this function with %SymbolicPHI = %X.; //; // The analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be igno",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2367,Deployability,update,update,2367,"analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be ignored by; // the cost model and to avoid vectorizing them (otherwise these casts,; // which are redundant under the runtime overflow checks, will be; // vectorized, which can be costly).; //; // 2) Support additional induction/PHISCEV patterns: We also want to support; // inductions where the sext-trunc / zext-trunc operations (partly) occur; // after the induction update operation (the induction increment):; //; // (Trunc iy (SExt/ZExt ix (%SymbolicPHI + InvariantAccum) to iy) to ix); // which correspond to a phi->add->trunc->sext/zext->phi update chain.; //; // (Trunc iy ((SExt/ZExt ix (%SymbolicPhi) to iy) + InvariantAccum) to ix); // which correspond to a phi->trunc->add->sext/zext->phi update chain.; //; // 3) Outline common code with createAddRecFromPHI to avoid duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2547,Deployability,update,update,2547,"analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be ignored by; // the cost model and to avoid vectorizing them (otherwise these casts,; // which are redundant under the runtime overflow checks, will be; // vectorized, which can be costly).; //; // 2) Support additional induction/PHISCEV patterns: We also want to support; // inductions where the sext-trunc / zext-trunc operations (partly) occur; // after the induction update operation (the induction increment):; //; // (Trunc iy (SExt/ZExt ix (%SymbolicPHI + InvariantAccum) to iy) to ix); // which correspond to a phi->add->trunc->sext/zext->phi update chain.; //; // (Trunc iy ((SExt/ZExt ix (%SymbolicPhi) to iy) + InvariantAccum) to ix); // which correspond to a phi->trunc->add->sext/zext->phi update chain.; //; // 3) Outline common code with createAddRecFromPHI to avoid duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2699,Deployability,update,update,2699,"analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be ignored by; // the cost model and to avoid vectorizing them (otherwise these casts,; // which are redundant under the runtime overflow checks, will be; // vectorized, which can be costly).; //; // 2) Support additional induction/PHISCEV patterns: We also want to support; // inductions where the sext-trunc / zext-trunc operations (partly) occur; // after the induction update operation (the induction increment):; //; // (Trunc iy (SExt/ZExt ix (%SymbolicPHI + InvariantAccum) to iy) to ix); // which correspond to a phi->add->trunc->sext/zext->phi update chain.; //; // (Trunc iy ((SExt/ZExt ix (%SymbolicPhi) to iy) + InvariantAccum) to ix); // which correspond to a phi->trunc->add->sext/zext->phi update chain.; //; // 3) Outline common code with createAddRecFromPHI to avoid duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1159,Integrability,Wrap,WrapPred,1159,"lowing pattern:; // (SExt/ZExt ix (Trunc iy (%SymbolicPHI) to ix) to iy) + InvariantAccum; // which correspond to a phi->trunc->sext/zext->add->phi update chain.; // If so, try to see if it can be rewritten as an AddRecExpr under some; // Predicates. If successful, return them as a pair. Also cache the results; // of the analysis.; //; // Example usage scenario:; // Say the Rewriter is called for the following SCEV:; // 8 * ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // where:; // %X = phi i64 (%Start, %BEValue); // It will visitMul->visitAdd->visitSExt->visitTrunc->visitUnknown(%X),; // and call this function with %SymbolicPHI = %X.; //; // The analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be ignored by; // the cost model and to avoid vectorizing them (otherwise these casts,; // which are redundant under the runtime overflo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:506,Modifiability,Rewrite,Rewriter,506,"// Analyze \p SymbolicPHI, a SCEV expression of a phi node, and check if the; // computation that updates the phi follows the following pattern:; // (SExt/ZExt ix (Trunc iy (%SymbolicPHI) to ix) to iy) + InvariantAccum; // which correspond to a phi->trunc->sext/zext->add->phi update chain.; // If so, try to see if it can be rewritten as an AddRecExpr under some; // Predicates. If successful, return them as a pair. Also cache the results; // of the analysis.; //; // Example usage scenario:; // Say the Rewriter is called for the following SCEV:; // 8 * ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // where:; // %X = phi i64 (%Start, %BEValue); // It will visitMul->visitAdd->visitSExt->visitTrunc->visitUnknown(%X),; // and call this function with %SymbolicPHI = %X.; //; // The analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be igno",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1503,Modifiability,rewrite,rewrite,1503,"Trunc->visitUnknown(%X),; // and call this function with %SymbolicPHI = %X.; //; // The analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be ignored by; // the cost model and to avoid vectorizing them (otherwise these casts,; // which are redundant under the runtime overflow checks, will be; // vectorized, which can be costly).; //; // 2) Support additional induction/PHISCEV patterns: We also want to support; // inductions where the sext-trunc / zext-trunc operations (partly) occur; // after the induction update operation (the induction increment):; //; // (Trunc iy (SExt/ZExt ix (%SymbolicPHI + InvariantAccum) to iy) to ix); // which correspond to a phi->add->trunc->sext/zext->phi update chain.; //; // (Trunc iy ((SExt/ZExt ix (%SymbolicPhi) to iy) + InvariantAccum) to ix); // which correspond to a phi->trunc->add->sext/zext->phi upda",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1641,Modifiability,Extend,Extend,1641,"Trunc->visitUnknown(%X),; // and call this function with %SymbolicPHI = %X.; //; // The analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be ignored by; // the cost model and to avoid vectorizing them (otherwise these casts,; // which are redundant under the runtime overflow checks, will be; // vectorized, which can be costly).; //; // 2) Support additional induction/PHISCEV patterns: We also want to support; // inductions where the sext-trunc / zext-trunc operations (partly) occur; // after the induction update operation (the induction increment):; //; // (Trunc iy (SExt/ZExt ix (%SymbolicPHI + InvariantAccum) to iy) to ix); // which correspond to a phi->add->trunc->sext/zext->phi update chain.; //; // (Trunc iy ((SExt/ZExt ix (%SymbolicPhi) to iy) + InvariantAccum) to ix); // which correspond to a phi->trunc->add->sext/zext->phi upda",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:423,Performance,cache,cache,423,"// Analyze \p SymbolicPHI, a SCEV expression of a phi node, and check if the; // computation that updates the phi follows the following pattern:; // (SExt/ZExt ix (Trunc iy (%SymbolicPHI) to ix) to iy) + InvariantAccum; // which correspond to a phi->trunc->sext/zext->add->phi update chain.; // If so, try to see if it can be rewritten as an AddRecExpr under some; // Predicates. If successful, return them as a pair. Also cache the results; // of the analysis.; //; // Example usage scenario:; // Say the Rewriter is called for the following SCEV:; // 8 * ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // where:; // %X = phi i64 (%Start, %BEValue); // It will visitMul->visitAdd->visitSExt->visitTrunc->visitUnknown(%X),; // and call this function with %SymbolicPHI = %X.; //; // The analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be igno",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1519,Performance,cache,cached,1519,"Trunc->visitUnknown(%X),; // and call this function with %SymbolicPHI = %X.; //; // The analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be ignored by; // the cost model and to avoid vectorizing them (otherwise these casts,; // which are redundant under the runtime overflow checks, will be; // vectorized, which can be costly).; //; // 2) Support additional induction/PHISCEV patterns: We also want to support; // inductions where the sext-trunc / zext-trunc operations (partly) occur; // after the induction update operation (the induction increment):; //; // (Trunc iy (SExt/ZExt ix (%SymbolicPHI + InvariantAccum) to iy) to ix); // which correspond to a phi->add->trunc->sext/zext->phi update chain.; //; // (Trunc iy ((SExt/ZExt ix (%SymbolicPhi) to iy) + InvariantAccum) to ix); // which correspond to a phi->trunc->add->sext/zext->phi upda",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2034,Safety,avoid,avoid,2034,"analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be ignored by; // the cost model and to avoid vectorizing them (otherwise these casts,; // which are redundant under the runtime overflow checks, will be; // vectorized, which can be costly).; //; // 2) Support additional induction/PHISCEV patterns: We also want to support; // inductions where the sext-trunc / zext-trunc operations (partly) occur; // after the induction update operation (the induction increment):; //; // (Trunc iy (SExt/ZExt ix (%SymbolicPHI + InvariantAccum) to iy) to ix); // which correspond to a phi->add->trunc->sext/zext->phi update chain.; //; // (Trunc iy ((SExt/ZExt ix (%SymbolicPhi) to iy) + InvariantAccum) to ix); // which correspond to a phi->trunc->add->sext/zext->phi update chain.; //; // 3) Outline common code with createAddRecFromPHI to avoid duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2095,Safety,redund,redundant,2095,"analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be ignored by; // the cost model and to avoid vectorizing them (otherwise these casts,; // which are redundant under the runtime overflow checks, will be; // vectorized, which can be costly).; //; // 2) Support additional induction/PHISCEV patterns: We also want to support; // inductions where the sext-trunc / zext-trunc operations (partly) occur; // after the induction update operation (the induction increment):; //; // (Trunc iy (SExt/ZExt ix (%SymbolicPHI + InvariantAccum) to iy) to ix); // which correspond to a phi->add->trunc->sext/zext->phi update chain.; //; // (Trunc iy ((SExt/ZExt ix (%SymbolicPhi) to iy) + InvariantAccum) to ix); // which correspond to a phi->trunc->add->sext/zext->phi update chain.; //; // 3) Outline common code with createAddRecFromPHI to avoid duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2772,Safety,avoid,avoid,2772,"analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be ignored by; // the cost model and to avoid vectorizing them (otherwise these casts,; // which are redundant under the runtime overflow checks, will be; // vectorized, which can be costly).; //; // 2) Support additional induction/PHISCEV patterns: We also want to support; // inductions where the sext-trunc / zext-trunc operations (partly) occur; // after the induction update operation (the induction increment):; //; // (Trunc iy (SExt/ZExt ix (%SymbolicPHI + InvariantAccum) to iy) to ix); // which correspond to a phi->add->trunc->sext/zext->phi update chain.; //; // (Trunc iy ((SExt/ZExt ix (%SymbolicPhi) to iy) + InvariantAccum) to ix); // which correspond to a phi->trunc->add->sext/zext->phi update chain.; //; // 3) Outline common code with createAddRecFromPHI to avoid duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:211,Modifiability,variab,variable,211,"// If the value coming around the backedge is an add with the symbolic; // value we just inserted, possibly with casts that we can ignore under; // an appropriate runtime guard, then we found a simple induction variable!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:194,Usability,simpl,simple,194,"// If the value coming around the backedge is an add with the symbolic; // value we just inserted, possibly with casts that we can ignore under; // an appropriate runtime guard, then we found a simple induction variable!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:192,Integrability,Wrap,Wrap,192,"// *** Part2: Create the predicates; // Analysis was successful: we have a phi-with-cast pattern for which we; // can return an AddRec expression under the following predicates:; //; // P1: A Wrap predicate that guarantees that Trunc(Start) + i*Trunc(Accum); // fits within the truncated type (does not overflow) for i = 0 to n-1.; // P2: An Equal predicate that guarantees that; // Start = (Ext ix (Trunc iy (Start) to ix) to iy); // P3: An Equal predicate that guarantees that; // Accum = (Ext ix (Trunc iy (Accum) to ix) to iy); //; // As we next prove, the above predicates guarantee that:; // Start + i*Accum = (Ext ix (Trunc iy ( Start + i*Accum ) to ix) to iy); //; //; // More formally, we want to prove that:; // Expr(i+1) = Start + (i+1) * Accum; // = (Ext ix (Trunc iy (Expr(i)) to ix) to iy) + Accum; //; // Given that:; // 1) Expr(0) = Start; // 2) Expr(1) = Start + Accum; // = (Ext ix (Trunc iy (Start) to ix) to iy) + Accum :: from P2; // 3) Induction hypothesis (step i):; // Expr(i) = (Ext ix (Trunc iy (Expr(i-1)) to ix) to iy) + Accum; //; // Proof:; // Expr(i+1) =; // = Start + (i+1)*Accum; // = (Start + i*Accum) + Accum; // = Expr(i) + Accum; // = (Ext ix (Trunc iy (Expr(i-1)) to ix) to iy) + Accum + Accum; // :: from step i; //; // = (Ext ix (Trunc iy (Start + (i-1)*Accum) to ix) to iy) + Accum + Accum; //; // = (Ext ix (Trunc iy (Start + (i-1)*Accum) to ix) to iy); // + (Ext ix (Trunc iy (Accum) to ix) to iy); // + Accum :: from P3; //; // = (Ext ix (Trunc iy ((Start + (i-1)*Accum) + Accum) to ix) to iy); // + Accum :: from P1: Ext(x)+Ext(y)=>Ext(x+y); //; // = (Ext ix (Trunc iy (Start + i*Accum) to ix) to iy) + Accum; // = (Ext ix (Trunc iy (Expr(i)) to ix) to iy) + Accum; //; // By induction, the same applies to all iterations 1<=i<n:; //; // Create a truncated addrec for which we will add a no overflow check (P1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:282,Modifiability,extend,extended,282,"// Create the Equal Predicates P2,P3:; // It is possible that the predicates P2 and/or P3 are computable at; // compile time due to StartVal and/or Accum being constants.; // If either one is, then we can check that now and escape if either P2; // or P3 is false.; // Construct the extended SCEV: (Ext ix (Trunc iy (Expr) to ix) to iy); // for each of StartVal and Accum",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:14,Modifiability,Extend,ExtendedExpr,14,// Given:; // ExtendedExpr = (Ext ix (Trunc iy (Expr) to ix) to iy; // = getExtendedExpr(Expr); // Determine whether the predicate P: Expr == ExtendedExpr; // is known to be false at compile time,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:142,Modifiability,Extend,ExtendedExpr,142,// Given:; // ExtendedExpr = (Ext ix (Trunc iy (Expr) to ix) to iy; // = getExtendedExpr(Expr); // Determine whether the predicate P: Expr == ExtendedExpr; // is known to be false at compile time,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:135,Modifiability,rewrite,rewrite,135,// *** Part3: Predicates are ready. Now go ahead and create the new addrec in; // which the casts had been folded away. The caller can rewrite SymbolicPHI; // into NewAR if it will also add the runtime overflow checks specified in; // Predicates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:17,Performance,cache,cache,17,// Record in the cache that the analysis failed,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:57,Modifiability,Rewrite,Rewriter,57,"// FIXME: This utility is currently required because the Rewriter currently; // does not rewrite this expression:; // {0, +, (sext ix (trunc iy to ix) to iy)}; // into {0, +, %step},; // even when the following Equal predicate exists:; // ""%step == (sext ix (trunc iy to ix) to iy)"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:89,Modifiability,rewrite,rewrite,89,"// FIXME: This utility is currently required because the Rewriter currently; // does not rewrite this expression:; // {0, +, (sext ix (trunc iy to ix) to iy)}; // into {0, +, %step},; // even when the following Equal predicate exists:; // ""%step == (sext ix (trunc iy to ix) to iy)"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:56,Usability,simpl,simple,56,"/// A helper function for createAddRecFromPHI to handle simple cases.; ///; /// This function tries to find an AddRec expression for the simplest (yet most; /// common) cases: PN = PHI(Start, OP(Self, LoopInvariant)).; /// If it fails, createAddRecFromPHI will use a more general, but slow,; /// technique for finding the AddRec expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:137,Usability,simpl,simplest,137,"/// A helper function for createAddRecFromPHI to handle simple cases.; ///; /// This function tries to find an AddRec expression for the simplest (yet most; /// common) cases: PN = PHI(Start, OP(Self, LoopInvariant)).; /// If it fails, createAddRecFromPHI will use a more general, but slow,; /// technique for finding the AddRec expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:264,Modifiability,variab,variable,264,"// NOTE: If BEValue is loop invariant, we know that the PHI node just; // has a special value for the first iteration of the loop.; // If the value coming around the backedge is an add with the symbolic; // value we just inserted, then we found a simple induction variable!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:247,Usability,simpl,simple,247,"// NOTE: If BEValue is loop invariant, we know that the PHI node just; // has a special value for the first iteration of the loop.; // If the value coming around the backedge is an add with the symbolic; // value we just inserted, then we found a simple induction variable!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:85,Integrability,wrap,wrapped,85,"// If the increment is an inbounds GEP, then we know the address; // space cannot be wrapped around. We cannot make any guarantee; // about signed or unsigned overflow because pointers are; // unsigned but we may have a negative index from the base; // pointer. We can guarantee that no unsigned wrap occurs if the; // indices form a positive value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:296,Integrability,wrap,wrap,296,"// If the increment is an inbounds GEP, then we know the address; // space cannot be wrapped around. We cannot make any guarantee; // about signed or unsigned overflow because pointers are; // unsigned but we may have a negative index from the base; // pointer. We can guarantee that no unsigned wrap occurs if the; // indices form a positive value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:194,Usability,simpl,simpler,194,// Remove the temporary PHI node SCEV that has been inserted while intending; // to create an AddRecExpr for this PHI node. We can not keep this temporary; // as it will prevent later (possibly simpler) SCEV expressions to be added; // to the ValueExprMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:21,Usability,simpl,simple,21,// Try to match some simple smax or umax patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:341,Modifiability,variab,variable,341,"// i1 cond ? i1 x : i1 C --> C + (i1 cond ? (i1 x - i1 C) : i1 0); // --> C + (umin_seq cond, x - C); //; // i1 cond ? i1 C : i1 x --> C + (i1 cond ? i1 0 : (i1 x - i1 C)); // --> C + (i1 ~cond ? (i1 x - i1 C) : i1 0); // --> C + (umin_seq ~cond, x - C); // FIXME: while we can't legally model the case where both of the hands; // are fully variable, we only require that the *difference* is constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:29,Energy Efficiency,power,power,29,// Only multiples that are a power of 2 will hold after truncation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:19,Integrability,wrap,wrap,19,"// If there are no wrap guarentees, find the trailing zeros, which is the; // sum of trailing zeros for all its operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:131,Availability,avail,available,131,"// Match a simple recurrence of the form: <start, ShiftOp, Step>, and then; // use information about the trip count to improve our available range. Note; // that the trip count independent cases are already handled by known bits.; // WARNING: The definition of recurrence used here is subtly different than; // the one used by AddRec (and thus most of this file). Step is allowed to; // be arbitrarily loop varying here, where AddRec allows only loop invariant; // and other addrecs in the same loop (for non-affine addrecs). The code; // below intentionally handles the case where step is not loop invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:11,Usability,simpl,simple,11,"// Match a simple recurrence of the form: <start, ShiftOp, Step>, and then; // use information about the trip count to improve our available range. Note; // that the trip count independent cases are already handled by known bits.; // WARNING: The definition of recurrence used here is subtly different than; // the one used by AddRec (and thus most of this file). Step is allowed to; // be arbitrarily loop varying here, where AddRec allows only loop invariant; // and other addrecs in the same loop (for non-affine addrecs). The code; // below intentionally handles the case where step is not loop invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:108,Availability,avail,available,108,"// Make sure that no Phi input comes from an unreachable block. Otherwise,; // even the values that are not available in these blocks may come from them,; // and this leads to false-positive recurrence test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:202,Testability,test,test,202,"// Make sure that no Phi input comes from an unreachable block. Otherwise,; // even the values that are not available in these blocks may come from them,; // and this leads to false-positive recurrence test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:93,Security,expose,exposes,93,"// NOTE: This bailout should be an assert instead. However, asserting; // the condition here exposes a case where LoopFusion is querying SCEV; // with malformed loop information during the midst of the transform.; // There doesn't appear to be an obvious fix, so for the moment bailout; // until the caller issue can be fixed. PR49566 tracks the bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:35,Testability,assert,assert,35,"// NOTE: This bailout should be an assert instead. However, asserting; // the condition here exposes a case where LoopFusion is querying SCEV; // with malformed loop information during the midst of the transform.; // There doesn't appear to be an obvious fix, so for the moment bailout; // until the caller issue can be fixed. PR49566 tracks the bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:60,Testability,assert,asserting,60,"// NOTE: This bailout should be an assert instead. However, asserting; // the condition here exposes a case where LoopFusion is querying SCEV; // with malformed loop information during the midst of the transform.; // There doesn't appear to be an obvious fix, so for the moment bailout; // until the caller issue can be fixed. PR49566 tracks the bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:9,Modifiability,Extend,Extend,9,"// TODO: Extend to other opcodes such as mul, and div",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:20,Energy Efficiency,power,power,20,// TODO: Handle the power function forms some day.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:22,Usability,simpl,simply,22,// Analogous to lshr (simply not yet canonicalized),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:26,Integrability,wrap,wrap,26,"// If there's no unsigned wrap, the value will never be less than its; // initial value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:24,Integrability,wrap,wrap,24,"// If there's no signed wrap, and all the operands except initial value have; // the same sign or zero, the value won't ever be:; // 1: smaller than initial value if operands are non negative,; // 2: bigger than initial value if operands are non positive.; // For both cases, value can not cross signed min/max boundary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:38,Energy Efficiency,power,powerful,38,// Now try symbolic BE count and more powerful methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:192,Integrability,wrap,wrap-around,192,// This is correct even for INT_SMIN. Let's look at i8 to illustrate this:; // abs(INT_SMIN) = abs(-128) = abs(0x80) = -0x80 = 0x80 = 128.; // This equations hold true due to the well-defined wrap-around behavior of; // APInt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:97,Integrability,wrap,wrap,97,"// It's possible that the new minimum/maximum value will fall into the initial; // range (due to wrap around). This means that the expression can take any; // value in this bitwidth, and we have to return full range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:15,Safety,detect,detected,15,"// No overflow detected, return [StartLower, StartUpper + Offset + 1) range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:57,Integrability,wrap,wrap,57,"// Let's make sure that we can prove that we do not self-wrap during; // MaxBECount iterations. We need this because MaxBECount is a maximum; // iteration count estimate, and we might infer nw from some exit for which we; // do not know max exit count (or any other side reasoning).; // TODO: Turn into assert at some point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:303,Testability,assert,assert,303,"// Let's make sure that we can prove that we do not self-wrap during; // MaxBECount iterations. We need this because MaxBECount is a maximum; // iteration count estimate, and we might infer nw from some exit for which we; // do not know max exit count (or any other side reasoning).; // TODO: Turn into assert at some point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:33,Integrability,wrap,wrap,33,"// We know that there is no self-wrap. Let's take Start and End values and; // look at all intermediate values V1, V2, ..., Vn that IndVar takes during; // the iteration. They either lie inside the range [Min(Start, End),; // Max(Start, End)] or outside it:; //; // Case 1: RangeMin ... Start V1 ... VN End ... RangeMax;; // Case 2: RangeMin Vk ... V1 Start ... End Vn ... Vk + 1 RangeMax;; //; // No self wrap flag guarantees that the intermediate values cannot be BOTH; // outside and inside the range [Min(Start, End), Max(Start, End)]. Using that; // knowledge, let's try to prove that we are dealing with Case 1. It is so if; // Start <= End and step is positive, or Start >= End and step is negative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:406,Integrability,wrap,wrap,406,"// We know that there is no self-wrap. Let's take Start and End values and; // look at all intermediate values V1, V2, ..., Vn that IndVar takes during; // the iteration. They either lie inside the range [Min(Start, End),; // Max(Start, End)] or outside it:; //; // Case 1: RangeMin ... Start V1 ... VN End ... RangeMax;; // Case 2: RangeMin Vk ... V1 Start ... End Vn ... Vk + 1 RangeMax;; //; // No self wrap flag guarantees that the intermediate values cannot be BOTH; // outside and inside the range [Min(Start, End), Max(Start, End)]. Using that; // knowledge, let's try to prove that we are dealing with Case 1. It is so if; // Start <= End and step is positive, or Start >= End and step is negative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:37,Integrability,wrap,wrap,37,// Only deal with ranges that do not wrap (i.e. RangeMin < RangeMax).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:342,Availability,error,errors,342,"// NB! Calling ScalarEvolution::getConstant is fine, but we should not try to; // construct arbitrary general SCEV expressions here. This function is called; // from deep in the call stack, and calling getSCEV (on a sext instruction,; // say) can end up caching a suboptimal value.; // FIXME: without the explicit `this` receiver below, MSVC errors out with; // C2352 and C2512 (otherwise it isn't needed).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:65,Integrability,wrap,wrap,65,"// At this point we know that if I is executed, then it does not wrap; // according to at least one of NSW or NUW. If I is not executed, then we do; // not know if the calculation that I represents would wrap. Multiple; // instructions can map to the same SCEV. If we apply NSW or NUW from I to; // the SCEV, we must guarantee no wrapping for that SCEV also when it is; // derived from other instructions that map to the same SCEV. We cannot make; // that guarantee for cases where I is not executed. So we need to find a; // upper bound on the defining scope for the SCEV, and prove that I is; // executed every time we enter that scope. When the bounding scope is a; // loop (the common case), this is equivalent to proving I executes on every; // iteration of that loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:204,Integrability,wrap,wrap,204,"// At this point we know that if I is executed, then it does not wrap; // according to at least one of NSW or NUW. If I is not executed, then we do; // not know if the calculation that I represents would wrap. Multiple; // instructions can map to the same SCEV. If we apply NSW or NUW from I to; // the SCEV, we must guarantee no wrapping for that SCEV also when it is; // derived from other instructions that map to the same SCEV. We cannot make; // that guarantee for cases where I is not executed. So we need to find a; // upper bound on the defining scope for the SCEV, and prove that I is; // executed every time we enter that scope. When the bounding scope is a; // loop (the common case), this is equivalent to proving I executes on every; // iteration of that loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:330,Integrability,wrap,wrapping,330,"// At this point we know that if I is executed, then it does not wrap; // according to at least one of NSW or NUW. If I is not executed, then we do; // not know if the calculation that I represents would wrap. Multiple; // instructions can map to the same SCEV. If we apply NSW or NUW from I to; // the SCEV, we must guarantee no wrapping for that SCEV also when it is; // derived from other instructions that map to the same SCEV. We cannot make; // that guarantee for cases where I is not executed. So we need to find a; // upper bound on the defining scope for the SCEV, and prove that I is; // executed every time we enter that scope. When the bounding scope is a; // loop (the common case), this is equivalent to proving I executes on every; // iteration of that loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Performance,Queue,Queue,3,"// Queue CurV for SCEV creation, followed by its's operands which need to; // be constructed first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:215,Integrability,depend,depends,215,"// Don't attempt to analyze instructions in blocks that aren't; // reachable. Such instructions don't matter, and they aren't required; // to obey basic rules for definitions dominating uses which this; // analysis depends on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:120,Energy Efficiency,reduce,reduce,120,"// For additions and multiplications, traverse add/mul chains for which we; // can potentially create a single SCEV, to reduce the number of; // get{Add,Mul}Expr calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:38,Usability,simpl,simplified,38,// Check if U is a select that can be simplified to a SCEVUnknown.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:215,Integrability,depend,depends,215,"// Don't attempt to analyze instructions in blocks that aren't; // reachable. Such instructions don't matter, and they aren't required; // to obey basic rules for definitions dominating uses which this; // analysis depends on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:7,Usability,simpl,simple,7,"// The simple thing to do would be to just call getSCEV on both operands; // and call getAddExpr with the result. However if we're looking at a; // bunch of things all added together, this can be quite inefficient,; // because it leads to N-1 getAddExpr calls for N ultimate operands.; // Instead, gather up all the operands and make a single getAddExpr call.; // LLVM IR canonical form means we need only traverse the left operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:44,Availability,mask,masks,44,"// For an expression like x&255 that merely masks off the high bits,; // use zext(trunc(x)) as the SCEV expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:122,Availability,mask,mask,122,"// Instcombine's ShrinkDemandedConstant may strip bits out of; // constants, obscuring what would otherwise be a low-bits mask.; // Use computeKnownBits to compute what ShrinkDemandedConstant; // knew about to reconstruct a low-bits mask value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:233,Availability,mask,mask,233,"// Instcombine's ShrinkDemandedConstant may strip bits out of; // constants, obscuring what would otherwise be a low-bits mask.; // Use computeKnownBits to compute what ShrinkDemandedConstant; // knew about to reconstruct a low-bits mask value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:39,Usability,simpl,simplify,39,"// For an expression like (x * 8) & 8, simplify the multiply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:61,Availability,mask,mask,61,"// Model xor(and(x, C), C) as and(~x, C), if C is a low-bits mask.; // This is a variant of the check for xor with -1, and it handles; // the case where instcombine has trimmed non-demanded bits out; // of an xor with -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:22,Availability,mask,mask,22,"// If C is a low-bits mask, the zero extend is serving to; // mask off the high bits. Complement the operand and; // re-apply the zext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:62,Availability,mask,mask,62,"// If C is a low-bits mask, the zero extend is serving to; // mask off the high bits. Complement the operand and; // re-apply the zext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:37,Modifiability,extend,extend,37,"// If C is a low-bits mask, the zero extend is serving to; // mask off the high bits. Complement the operand and; // re-apply the zext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:80,Modifiability,extend,extend,80,"// If C is a single bit, it may be in the sign-bit position; // before the zero-extend. In this case, represent the xor; // using an add, which is equivalent, and re-apply the zext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:10,Safety,safe,safely,10,"// We can safely preserve the nuw flag in all cases. It's also safe to; // turn a nuw nsw shl into a nuw nsw mul. However, nsw in isolation; // requires special handling. It can be preserved as long as we're not; // left shifting by bitwidth - 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:63,Safety,safe,safe,63,"// We can safely preserve the nuw flag in all cases. It's also safe to; // turn a nuw nsw shl into a nuw nsw mul. However, nsw in isolation; // requires special handling. It can be preserved as long as we're not; // left shifting by bitwidth - 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:145,Usability,simpl,simpler,145,"// We can merge the two given cases into a single SCEV statement,; // incase n = m, the mul expression will be 2^0, so it gets resolved to; // a simpler case. The following code handles the two cases:; //; // 1) For a two-shift sext-inreg, i.e. n = m,; // use sext(trunc(x)) as the SCEV expression.; //; // 2) When n > m, use sext(mul(trunc(x), 2^(n-m)))) as the SCEV; // expression. We already checked that ShlAmt < BitWidth, so; // the multiplier, 1 << (ShlAmt - AShrAmt), fits into TruncTy as; // ShlAmt - AShrAmt < Amt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:265,Testability,log,logic,265,// The NSW flag of a subtract does not always survive the conversion to; // A + (-1)*B. By pushing sign extension onto its operands we are much; // more likely to preserve NSW and allow later AddRec optimisations.; //; // NOTE: This is effectively duplicating this logic from getSignExtend:; // sext((A + B + ...)<nsw>) --> (sext(A) + sext(B) + ...)<nsw>; // but by that point the NSW information has potentially been lost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:22,Modifiability,extend,extend,22,"// If we need to zero extend the backedge count, check if we can add one to; // it prior to zero extending without overflow. Provided this is safe, it; // allows better simplification of the +1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:97,Modifiability,extend,extending,97,"// If we need to zero extend the backedge count, check if we can add one to; // it prior to zero extending without overflow. Provided this is safe, it; // allows better simplification of the +1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:142,Safety,safe,safe,142,"// If we need to zero extend the backedge count, check if we can add one to; // it prior to zero extending without overflow. Provided this is safe, it; // allows better simplification of the +1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:169,Usability,simpl,simplification,169,"// If we need to zero extend the backedge count, check if we can add one to; // it prior to zero extending without overflow. Provided this is safe, it; // allows better simplification of the +1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:65,Integrability,wrap,wrap,65,// Get the total trip count from the count by adding 1. This may wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:94,Energy Efficiency,power,power,94,"// If a trip multiple is huge (>=2^32), the trip count is still divisible by; // the greatest power of 2 divisor less than 2^32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:423,Usability,simpl,simply,423,"/// Returns the largest constant divisor of the trip count of this loop as a; /// normal unsigned value, if possible. This means that the actual trip count is; /// always a multiple of the returned value (don't forget the trip count could; /// very well be zero as well!).; ///; /// Returns 1 if the trip count is unknown or not guaranteed to be the; /// multiple of a constant (which is also the case if the trip count is simply; /// constant, use getSmallConstantTripCount for that case), Will also return 1; /// if the trip count is very large (>= 2^32).; ///; /// As explained in the comments for getSmallConstantTripCount, this assumes; /// that control exits the loop via ExitingBlock.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:142,Deployability,update,update,142,"// Initially insert an invalid entry for this loop. If the insertion; // succeeds, proceed to actually compute a backedge-taken count and; // update the value. The temporary CouldNotCompute value tells SCEV; // code elsewhere that it shouldn't attempt to request a new; // backedge-taken count, which could result in infinite recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:33,Energy Efficiency,allocate,allocate,33,"// computeBackedgeTakenCount may allocate memory for its result. Inserting it; // into the BackedgeTakenCounts map transfers ownership. Otherwise, the result; // must be cleared in this scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:170,Usability,clear,cleared,170,"// computeBackedgeTakenCount may allocate memory for its result. Inserting it; // into the BackedgeTakenCounts map transfers ownership. Otherwise, the result; // must be cleared in this scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:23,Modifiability,evolve,evolved,23,// Invalidate constant-evolved loop header phis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:214,Deployability,update,updated,214,// This method is intended to forget all info about loops. It should; // invalidate caches as if the following happened:; // - The trip counts of all loops have changed arbitrarily; // - Every llvm::Value has been updated in place to produce a different; // result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:84,Performance,cache,caches,84,// This method is intended to forget all info about loops. It should; // invalidate caches as if the following happened:; // - The trip counts of all loops have changed arbitrarily; // - Every llvm::Value has been updated in place to produce a different; // result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:42,Modifiability,rewrite,rewrites,42,// Drop information about predicated SCEV rewrites for this loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:38,Safety,avoid,avoid,38,"// Forget all contained loops too, to avoid dangling entries in the; // ValuesAtScopes map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:8,Performance,perform,perform,8,// Also perform the normal invalidation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:80,Performance,cache,caches,80,"// Unless a specific value is passed to invalidation, completely clear both; // caches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:65,Usability,clear,clear,65,"// Unless a specific value is passed to invalidation, completely clear both; // caches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:46,Performance,cache,cached,46,"// Invalidate the block and loop dispositions cached for S. Dispositions of; // S's users may change if S's disposition changes (i.e. a user may change to; // loop-invariant, if S changes to loop invariant), so also invalidate; // dispositions of S's users recursively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:228,Testability,test,test,228,"/// Get the exact loop backedge taken count considering all loop exits. A; /// computable result can only be returned for loops with all exiting blocks; /// dominating the latch. howFarToZero assumes that the limit of each loop test; /// is never skipped. This is a valid assumption as long as the loop exits via; /// that test. For precise results, it is the caller's responsibility to specify; /// the relevant loop exiting block using getExact(ExitingBlock, SE).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:323,Testability,test,test,323,"/// Get the exact loop backedge taken count considering all loop exits. A; /// computable result can only be returned for loops with all exiting blocks; /// dominating the latch. howFarToZero assumes that the limit of each loop test; /// is never skipped. This is a valid assumption as long as the loop exits via; /// that test. For precise results, it is the caller's responsibility to specify; /// the relevant loop exiting block using getExact(ExitingBlock, SE).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:89,Usability,simpl,simply,89,"// All exiting blocks we have gathered dominate loop's latch, so exact trip; // count is simply a minimum out of all these calculated exit counts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate memory for BackedgeTakenInfo and copy the not-taken count of each; /// computable exit into a persistent ExitNotTakenInfo array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:74,Usability,Simpl,SimplifyCFG,74,"// Check for a constant condition. These are normally stripped out by; // SimplifyCFG, but ScalarEvolution may be used by a pass which wishes to; // preserve the CFG and is temporarily leaving constant conditions; // in place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:6,Availability,robust,robust,6,"// Be robust against unsimplified IR for the form ""op i1 X, NeutralElement""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:23,Integrability,depend,dependencies,23,// Try to evaluate any dependencies out of the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Usability,Simpl,Simplify,3,// Simplify the operands before analyzing them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:172,Integrability,wrap,wrap,172,"// If this loop must exit based on this condition (or execute undefined; // behaviour), and we can prove the test sequence produced must repeat; // the same values on self-wrap of the IV, then we can infer that IV; // doesn't self wrap because if it did, we'd have an infinite (undefined); // loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:231,Integrability,wrap,wrap,231,"// If this loop must exit based on this condition (or execute undefined; // behaviour), and we can prove the test sequence produced must repeat; // the same values on self-wrap of the IV, then we can infer that IV; // doesn't self wrap because if it did, we'd have an infinite (undefined); // loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:109,Testability,test,test,109,"// If this loop must exit based on this condition (or execute undefined; // behaviour), and we can prove the test sequence produced must repeat; // the same values on self-wrap of the IV, then we can infer that IV; // doesn't self wrap because if it did, we'd have an infinite (undefined); // loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:30,Performance,optimiz,optimization,30,"// The key rationale for this optimization is that for some kinds of shift; // recurrences, the value of the recurrence ""stabilizes"" to either 0 or -1; // within a finite number of iterations. If the condition guarding the; // backedge (in the sense that the backedge is taken if the condition is true); // is false for the value the shift recurrence stabilizes to, then we know; // that the backedge is taken only a finite number of times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:52,Modifiability,evolve,evolve,52,/// Determine whether this instruction can constant evolve within this loop; /// assuming its operands can all constant evolve.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:120,Modifiability,evolve,evolve,120,/// Determine whether this instruction can constant evolve within this loop; /// assuming its operands can all constant evolve.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:34,Availability,redundant,redundant,34,"// Convenient constant check, but redundant for recursive calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:34,Safety,redund,redundant,34,"// Convenient constant check, but redundant for recursive calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:34,Integrability,depend,depends,34,"// An instruction inside the loop depends on a value outside the loop that we; // weren't given a mapping for, or a value such as a call inside the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Deployability,Update,Update,3,// Update all the PHI nodes for the next iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:53,Integrability,interface,interface,53,"/// This builds up a Constant using the ConstantExpr interface. That way, we; /// will return Constants for objects which aren't represented by a; /// SCEVConstant, because SCEVConstant is restricted to ConstantInt.; /// Returns NULL if the SCEV isn't representable as a Constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:54,Performance,perform,performing,54,"// First, attempt to evaluate each operand.; // Avoid performing the look-up in the common case where the specified; // expression has no loop-variant portions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:48,Safety,Avoid,Avoid,48,"// First, attempt to evaluate each operand.; // Avoid performing the look-up in the common case where the specified; // expression has no loop-variant portions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:82,Modifiability,variab,variable,82,"// The addrec may be folded to a nonrecurrence, for example, if the; // induction variable is multiplied by zero after constant folding. Go; // ahead and return the folded value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:9,Performance,perform,performing,9,// Avoid performing the look-up in the common case where the specified; // expression has no loop-variant portions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Safety,Avoid,Avoid,3,// Avoid performing the look-up in the common case where the specified; // expression has no loop-variant portions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:26,Modifiability,evolve,evolved,26,"// If this instruction is evolved from a constant-evolving PHI, compute the; // exit value from the loop without using SCEVs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:107,Usability,simpl,simplified,107,// This trivial case can show up in some degenerate cases where; // the incoming IR has not yet been fully simplified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:92,Usability,simpl,simplify,92,"// 4. Compute the minimum unsigned root of the equation:; // I * (B / D) mod (N / D); // To simplify the computation, we factor out the divide by D:; // (I * B mod N) / D",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:369,Performance,optimiz,optimizations,369,"/// Helper function to truncate an optional APInt to a given BitWidth.; /// When solving addrec-related equations, it is preferable to return a value; /// that has the same bit width as the original addrec's coefficients. If the; /// solution fits in the original bit width, truncate it (except for i1).; /// Returning a value of a different bit width may inhibit some optimizations.; ///; /// In general, a solution to a quadratic equation generated from an addrec; /// may require BW+1 bits, where BW is the bit width of the addrec's; /// coefficients. The reason is that the coefficients of the quadratic; /// equation are BW+1 bits wide (to avoid truncation when converting from; /// the addrec to the equation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:645,Safety,avoid,avoid,645,"/// Helper function to truncate an optional APInt to a given BitWidth.; /// When solving addrec-related equations, it is preferable to return a value; /// that has the same bit width as the original addrec's coefficients. If the; /// solution fits in the original bit width, truncate it (except for i1).; /// Returning a value of a different bit width may inhibit some optimizations.; ///; /// In general, a solution to a quadratic equation generated from an addrec; /// may require BW+1 bits, where BW is the bit width of the addrec's; /// coefficients. The reason is that the coefficients of the quadratic; /// equation are BW+1 bits wide (to avoid truncation when converting from; /// the addrec to the equation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:52,Testability,test,test,52,"// This is only used for loops with a ""x != y"" exit test. The exit condition; // is now expressed as a single expression, V = x-y. So the exit test is; // effectively V != 0. We know and take advantage of the fact that this; // expression only being used in a comparison by zero context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:143,Testability,test,test,143,"// This is only used for loops with a ""x != y"" exit test. The exit condition; // is now expressed as a single expression, V = x-y. So the exit test is; // effectively V != 0. We know and take advantage of the fact that this; // expression only being used in a comparison by zero context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:44,Testability,test,tests,44,"// Try to make this an AddRec using runtime tests, in the first X; // iterations of this loop, where X is the SCEV expression found by the; // algorithm below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:218,Availability,down,down,218,"// For now we handle only constant steps.; //; // TODO: Handle a nonconstant Step given AddRec<NUW>. If the; // AddRec is NUW, then (in an unsigned sense) it cannot be counting up to wrap; // to 0, it must be counting down to equal 0. Consequently, N = Start / -Step.; // We have not yet seen any such cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:183,Integrability,wrap,wrap,183,"// For now we handle only constant steps.; //; // TODO: Handle a nonconstant Step given AddRec<NUW>. If the; // AddRec is NUW, then (in an unsigned sense) it cannot be counting up to wrap; // to 0, it must be counting down to equal 0. Consequently, N = Start / -Step.; // We have not yet seen any such cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:128,Availability,down,down,128,// For positive steps (counting up until unsigned overflow):; // N = -Start/Step (as unsigned); // For negative steps (counting down to zero):; // N = Start/-Step; // First compute the unsigned distance from zero in the direction of Step.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:38,Integrability,wrap,wraparound,38,"// Handle unitary steps, which cannot wraparound.; // 1*N = -Start; -1*N = Start (mod 2^BW), so:; // N = Distance (as unsigned)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:141,Safety,Detect,Detect,141,"// When a loop like ""for (int i = 0; i != n; ++i) { /* body */ }"" is rotated,; // we end up with a loop whose backedge-taken count is n - 1. Detect this; // case, and see if we can improve the bound.; //; // Explicitly handling this here is necessary because getUnsignedRange; // isn't context-sensitive; it doesn't know that we only care about the; // range inside the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:114,Integrability,wrap,wrap,114,"// If the condition controls loop exit (the loop exits only if the expression; // is true) and the addition is no-wrap we can use unsigned divide to; // compute the backedge count. In this case, the step may not divide the; // distance, but we don't care because if the condition is ""missed"" the loop; // will have undefined behavior due to wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:341,Integrability,wrap,wrapping,341,"// If the condition controls loop exit (the loop exits only if the expression; // is true) and the addition is no-wrap we can use unsigned divide to; // compute the backedge count. In this case, the step may not divide the; // distance, but we don't care because if the condition is ""missed"" the loop; // will have undefined behavior due to wrapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:58,Testability,test,testing,58,"/// SCEV structural equivalence is usually sufficient for testing whether two; /// expressions are equal, however for the purposes of looking for a condition; /// guarding a loop, it can be useful to be a little more general, since a; /// front-end may have replicated the controlling expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Usability,Simpl,Simplifies,3,// Simplifies ICMP to trivial true or false by turning it into '0 == 0' or; // '0 != 0'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:42,Integrability,message,messages,42,"// The ""Should have been caught earlier!"" messages refer to the fact; // that the ExactCR.isFullSet() or ExactCR.isEmptySet() check above; // should have fired on the corresponding cases, and canonicalized the; // check to trivial case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:14,Usability,simpl,simplifications,14,// TODO: More simplifications are possible here.; // Recursively simplify until we either hit a recursion limit or nothing; // changes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:65,Usability,simpl,simplify,65,// TODO: More simplifications are possible here.; // Recursively simplify until we either hit a recursion limit or nothing; // changes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:14,Availability,down,down,14,// Query push down for cases where the unsigned range is; // less than sufficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:104,Availability,avail,available,104,"// It is possible that init SCEV contains an invariant load but it does; // not dominate MDL and is not available at MDL loop entry, so we should; // check it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:55,Performance,load,load,55,"// It is possible that init SCEV contains an invariant load but it does; // not dominate MDL and is not available at MDL loop entry, so we should; // check it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:44,Usability,simpl,simple,44,// Otherwise see what can be done with some simple reasoning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:117,Integrability,depend,depend,117,"// A zero step value for LHS means the induction variable is essentially a; // loop invariant value. We don't really depend on the predicate actually; // flipping from false to true (for increasing predicates, and the other way; // around for decreasing predicates), all we care about is that *if* the; // predicate changes then it only changes from false to true.; //; // A zero step value in itself is not very useful, but there may be places; // where SCEV can prove X >= 0 but not prove X > 0, so it is helpful to be; // as general as possible.; // Only handle LE/LT/GE/GT predicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:49,Modifiability,variab,variable,49,"// A zero step value for LHS means the induction variable is essentially a; // loop invariant value. We don't really depend on the predicate actually; // flipping from false to true (for increasing predicates, and the other way; // around for decreasing predicates), all we care about is that *if* the; // predicate changes then it only changes from false to true.; //; // A zero step value in itself is not very useful, but there may be places; // where SCEV can prove X >= 0 but not prove X > 0, so it is helpful to be; // as general as possible.; // Only handle LE/LT/GE/GT predicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:26,Integrability,wrap,wrap,26,// Check that AR does not wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:136,Integrability,depend,dependent,136,"// If the predicate ""ArLHS `Pred` RHS"" monotonically increases from false to; // true as the loop iterates, and the backedge is control dependent on; // ""ArLHS `Pred` RHS"" == true then we can reason as follows:; //; // * if the predicate was false in the first iteration then the predicate; // is never evaluated again, since the loop exits without taking the; // backedge.; // * if the predicate was true in the first iteration then it will; // continue to be true for all future iterations since it is; // monotonically increasing.; //; // For both the above possibilities, we can replace the loop varying; // predicate with its value on the first iteration of the loop (which is; // loop invariant).; //; // A similar reasoning applies for a monotonically decreasing predicate, by; // replacing true with false and false with true in the above two bullets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:136,Integrability,wrap,wrap,136,"// Type mismatch here means that MaxIter is potentially larger than max; // unsigned value in start type, which mean we cannot prove no wrap for the; // indvar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:168,Integrability,wrap,wrap,168,"// Because step is +/- 1 and MaxIter has same type as Start (i.e. it does; // not exceed max unsigned value of this type), this effectively proves; // that there is no wrap during the iteration. To prove that there is no; // signed/unsigned wrap, we need to check that; // Start <= Last for step = 1 or Start >= Last for step = -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:241,Integrability,wrap,wrap,241,"// Because step is +/- 1 and MaxIter has same type as Start (i.e. it does; // not exceed max unsigned value of this type), this effectively proves; // that there is no wrap during the iteration. To prove that there is no; // signed/unsigned wrap, we need to check that; // Start <= Last for step = 1 or Start >= Last for step = -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:180,Energy Efficiency,power,powerful,180,"// If L >= 0 then I `ult` L <=> I >= 0 && I `slt` L; //; // To prove L >= 0 we use isKnownNonNegative whereas to prove I >= 0 we use; // isKnownPredicate. isKnownPredicate is more powerful, but also more; // expensive; and using isKnownNonNegative(RHS) is sufficient for most of the; // interesting cases seen in practice. We can consider ""upgrading"" L >= 0 to; // use isKnownPredicate later if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:34,Testability,Test,Test,34,/// isLoopBackedgeGuardedByCond - Test whether the backedge of the loop is; /// protected by a conditional between LHS and RHS. This is used to; /// to eliminate casts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:28,Availability,avail,available,28,// Both LHS and RHS must be available at loop entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:66,Safety,Avoid,Avoid,66,"// There's no clear preference between forms 3. and 4., try both. Avoid; // forming getNotSCEV of pointer values as the resulting subtract is; // not legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:14,Usability,clear,clear,14,"// There's no clear preference between forms 3. and 4., try both. Avoid; // forming getNotSCEV of pointer values as the resulting subtract is; // not legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:95,Integrability,wrap,wraps,95,"// Given (V >= Min && V != Min) we conclude V >= (Min + 1).; // This is true even if (Min + 1) wraps around -- in case of; // wraparound, (Min + 1) < Min, so (V >= Min => V >= (Min + 1)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:126,Integrability,wrap,wraparound,126,"// Given (V >= Min && V != Min) we conclude V >= (Min + 1).; // This is true even if (Min + 1) wraps around -- in case of; // wraparound, (Min + 1) < Min, so (V >= Min => V >= (Min + 1)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:6,Safety,avoid,avoid,6,// We avoid subtracting expressions here because this function is usually; // fairly deep in the call stack (i.e. is called many times).; // X - X = 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:46,Integrability,depend,dependencies,46,"// We'd like to let SCEV reason about control dependencies, so we constrain; // both the inequalities to be about add recurrences on the same loop. This; // way we can use isLoopEntryGuardedByCond later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:9,Safety,detect,detect,9,"// If we detect a loop of Phi nodes being processed by this method, for; // example:; //; // %a = phi i32 [ %some1, %preheader ], [ %b, %latch ]; // %b = phi i32 [ %some2, %preheader ], [ %a, %latch ]; //; // we don't want to deal with a case that complex, so return conservative; // answer false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:21,Availability,avail,available,21,// Check that RHS is available in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:111,Integrability,wrap,wrap,111,"// If both sides are affine addrecs for the same loop, with equal; // steps, and we know the recurrences don't wrap, then we only; // need to check the predicate on the starting values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:14,Safety,avoid,avoid,14,// We want to avoid hurting the compile time with analysis of too big trees.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:24,Energy Efficiency,reduce,reduce,24,"// For unsigned, try to reduce it to corresponding signed comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:14,Safety,avoid,avoid,14,"// We want to avoid creation of any new non-constant SCEV. Since we are; // going to compare the operands to RHS, we should be certain that we don't; // need any size extensions for this. So let's decline all cases when the; // sizes of types of LHS and RHS do not match.; // TODO: Maybe try to get RHS from sext to catch more cases?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:43,Performance,perform,perform,43,"// Rules for division.; // We are going to perform some comparisons with Denominator and its; // derivative expressions. In general case, creating a SCEV for it may; // lead to a complex analysis of the entire graph, and in particular it; // can request trip count recalculation for the same loop. This would; // cache as SCEVCouldNotCompute to avoid the infinite recursion. To avoid; // this, we only want to create SCEVs that are constants in this section.; // So we bail if Denominator is not a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:313,Performance,cache,cache,313,"// Rules for division.; // We are going to perform some comparisons with Denominator and its; // derivative expressions. In general case, creating a SCEV for it may; // lead to a complex analysis of the entire graph, and in particular it; // can request trip count recalculation for the same loop. This would; // cache as SCEVCouldNotCompute to avoid the infinite recursion. To avoid; // this, we only want to create SCEVs that are constants in this section.; // So we bail if Denominator is not a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:345,Safety,avoid,avoid,345,"// Rules for division.; // We are going to perform some comparisons with Denominator and its; // derivative expressions. In general case, creating a SCEV for it may; // lead to a complex analysis of the entire graph, and in particular it; // can request trip count recalculation for the same loop. This would; // cache as SCEVCouldNotCompute to avoid the infinite recursion. To avoid; // this, we only want to create SCEVs that are constants in this section.; // So we bail if Denominator is not a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:378,Safety,avoid,avoid,378,"// Rules for division.; // We are going to perform some comparisons with Denominator and its; // derivative expressions. In general case, creating a SCEV for it may; // lead to a complex analysis of the entire graph, and in particular it; // can request trip count recalculation for the same loop. This would; // cache as SCEVCouldNotCompute to avoid the infinite recursion. To avoid; // this, we only want to create SCEVs that are constants in this section.; // So we bail if Denominator is not a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:63,Modifiability,extend,extend,63,"// One of types is a pointer and another one is not. We cannot extend; // them properly to a wider type, so let us just reject this case.; // TODO: Usage of getEffectiveSCEVType for DTy, FRHSTy etc should help; // to avoid this check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:217,Safety,avoid,avoid,217,"// One of types is a pointer and another one is not. We cannot extend; // them properly to a wider type, so let us just reject this case.; // TODO: Usage of getEffectiveSCEVType for DTy, FRHSTy etc should help; // to avoid this check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:65,Availability,down,down,65,"// If our expression contained SCEVUnknown Phis, and we split it down and now; // need to prove something for them, try to prove the predicate for every; // possible incoming values of those Phis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:75,Energy Efficiency,reduce,reduce,75,// The restriction on `FoundRHS` be lifted easily -- it exists only to; // reduce the compile time impact of this optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:114,Performance,optimiz,optimization,114,// The restriction on `FoundRHS` be lifted easily -- it exists only to; // reduce the compile time impact of this optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:7,Testability,log,logic,7,"// The logic in this function assumes we can represent a positive stride.; // If we can't, the backedge-taken count must be zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:37,Security,audit,audited,37,"// This code below only been closely audited for negative strides in the; // unsigned comparison case, it may be correct for signed comparison, but; // that needs to be established.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:142,Safety,safe,safe,142,"// Although End can be a MAX expression we estimate MaxEnd considering only; // the case End = RHS of the loop termination condition. This is safe because; // in the other case (End - Start) is zero, leading to a zero maximum backedge; // taken count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:126,Integrability,wrap,wrap,126,"// Can we prove this loop *must* be UB if overflow of IV occurs?; // Reasoning goes as follows:; // * Suppose the IV did self wrap.; // * If Stride evenly divides the iteration space, then once wrap; // occurs, the loop must revisit the same values.; // * We know that RHS is invariant, and that none of those values; // caused this exit to be taken previously. Thus, this exit is; // dynamically dead.; // * If this is the sole exit, then a dead exit implies the loop; // must be infinite if there are no abnormal exits.; // * If the loop were infinite, then it must either not be mustprogress; // or have side effects. Otherwise, it must be UB.; // * It can't (by assumption), be UB so we have contradicted our; // premise and can conclude the IV did not in fact self-wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:194,Integrability,wrap,wrap,194,"// Can we prove this loop *must* be UB if overflow of IV occurs?; // Reasoning goes as follows:; // * Suppose the IV did self wrap.; // * If Stride evenly divides the iteration space, then once wrap; // occurs, the loop must revisit the same values.; // * We know that RHS is invariant, and that none of those values; // caused this exit to be taken previously. Thus, this exit is; // dynamically dead.; // * If this is the sole exit, then a dead exit implies the loop; // must be infinite if there are no abnormal exits.; // * If the loop were infinite, then it must either not be mustprogress; // or have side effects. Otherwise, it must be UB.; // * It can't (by assumption), be UB so we have contradicted our; // premise and can conclude the IV did not in fact self-wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:770,Integrability,wrap,wrap,770,"// Can we prove this loop *must* be UB if overflow of IV occurs?; // Reasoning goes as follows:; // * Suppose the IV did self wrap.; // * If Stride evenly divides the iteration space, then once wrap; // occurs, the loop must revisit the same values.; // * We know that RHS is invariant, and that none of those values; // caused this exit to be taken previously. Thus, this exit is; // dynamically dead.; // * If this is the sole exit, then a dead exit implies the loop; // must be infinite if there are no abnormal exits.; // * If the loop were infinite, then it must either not be mustprogress; // or have side effects. Otherwise, it must be UB.; // * It can't (by assumption), be UB so we have contradicted our; // premise and can conclude the IV did not in fact self-wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:41,Integrability,wrap,wrap,41,// We can use the comparison to infer no-wrap flags only if it fully; // controls the loop exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:102,Testability,log,logic,102,// We need the sequence defined by AR to strictly increase in the; // unsigned integer domain for the logic below to hold.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:44,Testability,test,tests,44,"// Try to make this an AddRec using runtime tests, in the first X; // iterations of this loop, where X is the SCEV expression found by the; // algorithm below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Safety,Avoid,Avoid,3,// Avoid weird loops,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Safety,Avoid,Avoid,3,// Avoid negative or zero stride values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:929,Energy Efficiency,reduce,reduces,929,"// We can compute the correct backedge taken count for loops with unknown; // strides if we can prove that the loop is not an infinite loop with side; // effects. Here's the loop structure we are trying to handle -; //; // i = start; // do {; // A[i] = i;; // i += s;; // } while (i < end);; //; // The backedge taken count for such loops is evaluated as -; // (max(end, start + stride) - start - 1) /u stride; //; // The additional preconditions that we need to check to prove correctness; // of the above formula is as follows -; //; // a) IV is either nuw or nsw depending upon signedness (indicated by the; // NoWrap flag).; // b) the loop is guaranteed to be finite (e.g. is mustprogress and has; // no side effects within the loop); // c) loop has a single static exit (with no abnormal exits); //; // Precondition a) implies that if the stride is negative, this is a single; // trip loop. The backedge taken count formula reduces to zero in this case.; //; // Precondition b) and c) combine to imply that if rhs is invariant in L,; // then a zero stride means the backedge can't be taken without executing; // undefined behavior.; //; // The positive stride case is the same as isKnownPositive(Stride) returning; // true (original behavior of the function).; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:566,Integrability,depend,depending,566,"// We can compute the correct backedge taken count for loops with unknown; // strides if we can prove that the loop is not an infinite loop with side; // effects. Here's the loop structure we are trying to handle -; //; // i = start; // do {; // A[i] = i;; // i += s;; // } while (i < end);; //; // The backedge taken count for such loops is evaluated as -; // (max(end, start + stride) - start - 1) /u stride; //; // The additional preconditions that we need to check to prove correctness; // of the above formula is as follows -; //; // a) IV is either nuw or nsw depending upon signedness (indicated by the; // NoWrap flag).; // b) the loop is guaranteed to be finite (e.g. is mustprogress and has; // no side effects within the loop); // c) loop has a single static exit (with no abnormal exits); //; // Precondition a) implies that if the stride is negative, this is a single; // trip loop. The backedge taken count formula reduces to zero in this case.; //; // Precondition b) and c) combine to imply that if rhs is invariant in L,; // then a zero stride means the backedge can't be taken without executing; // undefined behavior.; //; // The positive stride case is the same as isKnownPositive(Stride) returning; // true (original behavior of the function).; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:16,Integrability,wrap,wrap,16,"// From no-self-wrap, we need to then prove no-(un)signed-wrap. This; // follows trivially from the fact that every (un)signed-wrapped, but; // not self-wrapped value must be LT than the last value before; // (un)signed wrap. Since we know that last value didn't exit, nor; // will any smaller one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:58,Integrability,wrap,wrap,58,"// From no-self-wrap, we need to then prove no-(un)signed-wrap. This; // follows trivially from the fact that every (un)signed-wrapped, but; // not self-wrapped value must be LT than the last value before; // (un)signed wrap. Since we know that last value didn't exit, nor; // will any smaller one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:127,Integrability,wrap,wrapped,127,"// From no-self-wrap, we need to then prove no-(un)signed-wrap. This; // follows trivially from the fact that every (un)signed-wrapped, but; // not self-wrapped value must be LT than the last value before; // (un)signed wrap. Since we know that last value didn't exit, nor; // will any smaller one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:153,Integrability,wrap,wrapped,153,"// From no-self-wrap, we need to then prove no-(un)signed-wrap. This; // follows trivially from the fact that every (un)signed-wrapped, but; // not self-wrapped value must be LT than the last value before; // (un)signed wrap. Since we know that last value didn't exit, nor; // will any smaller one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:220,Integrability,wrap,wrap,220,"// From no-self-wrap, we need to then prove no-(un)signed-wrap. This; // follows trivially from the fact that every (un)signed-wrapped, but; // not self-wrapped value must be LT than the last value before; // (un)signed wrap. Since we know that last value didn't exit, nor; // will any smaller one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:192,Performance,optimiz,optimize,192,"// Avoid proven overflow cases: this will ensure that the backedge taken; // count will not generate any unsigned overflow. Relaxed no-overflow; // conditions exploit NoWrapFlags, allowing to optimize in presence of; // undefined behaviors like the case of C language.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Safety,Avoid,Avoid,3,"// Avoid proven overflow cases: this will ensure that the backedge taken; // count will not generate any unsigned overflow. Relaxed no-overflow; // conditions exploit NoWrapFlags, allowing to optimize in presence of; // undefined behaviors like the case of C language.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:505,Energy Efficiency,reduce,reduces,505,"// In this case, we can use a refined formula for computing backedge taken; // count. The general formula remains:; // ""End-Start /uceiling Stride"" where ""End = max(RHS,Start)""; // We want to use the alternate formula:; // ""((End - 1) - (Start - Stride)) /u Stride""; // Let's do a quick case analysis to show these are equivalent under; // our precondition that max(RHS,Start) > Start - Stride.; // * For RHS <= Start, the backedge-taken count must be zero.; // ""((End - 1) - (Start - Stride)) /u Stride"" reduces to; // ""((Start - 1) - (Start - Stride)) /u Stride"" which simplies to; // ""Stride - 1 /u Stride"" which is indeed zero for all non-zero values; // of Stride. For 0 stride, we've use umin(1,Stride) above, reducing; // this to the stride of 1 case.; // * For RHS >= Start, the backedge count must be ""RHS-Start /uceil Stride"".; // ""((End - 1) - (Start - Stride)) /u Stride"" reduces to; // ""((RHS - 1) - (Start - Stride)) /u Stride"" reassociates to; // ""((RHS - (Start - Stride) - 1) /u Stride"".; // Our preconditions trivially imply no overflow in that form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:884,Energy Efficiency,reduce,reduces,884,"// In this case, we can use a refined formula for computing backedge taken; // count. The general formula remains:; // ""End-Start /uceiling Stride"" where ""End = max(RHS,Start)""; // We want to use the alternate formula:; // ""((End - 1) - (Start - Stride)) /u Stride""; // Let's do a quick case analysis to show these are equivalent under; // our precondition that max(RHS,Start) > Start - Stride.; // * For RHS <= Start, the backedge-taken count must be zero.; // ""((End - 1) - (Start - Stride)) /u Stride"" reduces to; // ""((Start - 1) - (Start - Stride)) /u Stride"" which simplies to; // ""Stride - 1 /u Stride"" which is indeed zero for all non-zero values; // of Stride. For 0 stride, we've use umin(1,Stride) above, reducing; // this to the stride of 1 case.; // * For RHS >= Start, the backedge count must be ""RHS-Start /uceil Stride"".; // ""((End - 1) - (Start - Stride)) /u Stride"" reduces to; // ""((RHS - 1) - (Start - Stride)) /u Stride"" reassociates to; // ""((RHS - (Start - Stride) - 1) /u Stride"".; // Our preconditions trivially imply no overflow in that form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:571,Usability,simpl,simplies,571,"// In this case, we can use a refined formula for computing backedge taken; // count. The general formula remains:; // ""End-Start /uceiling Stride"" where ""End = max(RHS,Start)""; // We want to use the alternate formula:; // ""((End - 1) - (Start - Stride)) /u Stride""; // Let's do a quick case analysis to show these are equivalent under; // our precondition that max(RHS,Start) > Start - Stride.; // * For RHS <= Start, the backedge-taken count must be zero.; // ""((End - 1) - (Start - Stride)) /u Stride"" reduces to; // ""((Start - 1) - (Start - Stride)) /u Stride"" which simplies to; // ""Stride - 1 /u Stride"" which is indeed zero for all non-zero values; // of Stride. For 0 stride, we've use umin(1,Stride) above, reducing; // this to the stride of 1 case.; // * For RHS >= Start, the backedge count must be ""RHS-Start /uceil Stride"".; // ""((End - 1) - (Start - Stride)) /u Stride"" reduces to; // ""((RHS - 1) - (Start - Stride)) /u Stride"" reassociates to; // ""((RHS - (Start - Stride) - 1) /u Stride"".; // Our preconditions trivially imply no overflow in that form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:108,Modifiability,variab,variable,108,"// At this point, we know:; //; // 1. If IsSigned, Start <=s End; otherwise, Start <=u End; // 2. The index variable doesn't overflow.; //; // Therefore, we know N exists such that; // (Start + Stride * N) >= End, and computing ""(Start + Stride * N)""; // doesn't overflow.; //; // Using this information, try to prove whether the addition in; // ""(Start - End) + (Stride - 1)"" has unsigned overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:23,Energy Efficiency,power,power,23,"// Suppose Stride is a power of two, and Start/End are unsigned; // integers. Let UMAX be the largest representable unsigned; // integer.; //; // By the preconditions of this function, we know; // ""(Start + Stride * N) >= End"", and this doesn't overflow.; // As a formula:; //; // End <= (Start + Stride * N) <= UMAX; //; // Subtracting Start from all the terms:; //; // End - Start <= Stride * N <= UMAX - Start; //; // Since Start is unsigned, UMAX - Start <= UMAX. Therefore:; //; // End - Start <= Stride * N <= UMAX; //; // Stride * N is a multiple of Stride. Therefore,; //; // End - Start <= Stride * N <= UMAX - (UMAX mod Stride); //; // Since Stride is a power of two, UMAX + 1 is divisible by Stride.; // Therefore, UMAX mod Stride == Stride - 1. So we can write:; //; // End - Start <= Stride * N <= UMAX - Stride - 1; //; // Dropping the middle term:; //; // End - Start <= UMAX - Stride - 1; //; // Adding Stride - 1 to both sides:; //; // (End - Start) + (Stride - 1) <= UMAX; //; // In other words, the addition doesn't have unsigned overflow.; //; // A similar proof works if we treat Start/End as signed values.; // Just rewrite steps before ""End - Start <= Stride * N <= UMAX"" to; // use signed max instead of unsigned max. Note that we're trying; // to prove a lack of unsigned overflow in either case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:664,Energy Efficiency,power,power,664,"// Suppose Stride is a power of two, and Start/End are unsigned; // integers. Let UMAX be the largest representable unsigned; // integer.; //; // By the preconditions of this function, we know; // ""(Start + Stride * N) >= End"", and this doesn't overflow.; // As a formula:; //; // End <= (Start + Stride * N) <= UMAX; //; // Subtracting Start from all the terms:; //; // End - Start <= Stride * N <= UMAX - Start; //; // Since Start is unsigned, UMAX - Start <= UMAX. Therefore:; //; // End - Start <= Stride * N <= UMAX; //; // Stride * N is a multiple of Stride. Therefore,; //; // End - Start <= Stride * N <= UMAX - (UMAX mod Stride); //; // Since Stride is a power of two, UMAX + 1 is divisible by Stride.; // Therefore, UMAX mod Stride == Stride - 1. So we can write:; //; // End - Start <= Stride * N <= UMAX - Stride - 1; //; // Dropping the middle term:; //; // End - Start <= UMAX - Stride - 1; //; // Adding Stride - 1 to both sides:; //; // (End - Start) + (Stride - 1) <= UMAX; //; // In other words, the addition doesn't have unsigned overflow.; //; // A similar proof works if we treat Start/End as signed values.; // Just rewrite steps before ""End - Start <= Stride * N <= UMAX"" to; // use signed max instead of unsigned max. Note that we're trying; // to prove a lack of unsigned overflow in either case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1138,Modifiability,rewrite,rewrite,1138,"// Suppose Stride is a power of two, and Start/End are unsigned; // integers. Let UMAX be the largest representable unsigned; // integer.; //; // By the preconditions of this function, we know; // ""(Start + Stride * N) >= End"", and this doesn't overflow.; // As a formula:; //; // End <= (Start + Stride * N) <= UMAX; //; // Subtracting Start from all the terms:; //; // End - Start <= Stride * N <= UMAX - Start; //; // Since Start is unsigned, UMAX - Start <= UMAX. Therefore:; //; // End - Start <= Stride * N <= UMAX; //; // Stride * N is a multiple of Stride. Therefore,; //; // End - Start <= Stride * N <= UMAX - (UMAX mod Stride); //; // Since Stride is a power of two, UMAX + 1 is divisible by Stride.; // Therefore, UMAX mod Stride == Stride - 1. So we can write:; //; // End - Start <= Stride * N <= UMAX - Stride - 1; //; // Dropping the middle term:; //; // End - Start <= UMAX - Stride - 1; //; // Adding Stride - 1 to both sides:; //; // (End - Start) + (Stride - 1) <= UMAX; //; // In other words, the addition doesn't have unsigned overflow.; //; // A similar proof works if we treat Start/End as signed values.; // Just rewrite steps before ""End - Start <= Stride * N <= UMAX"" to; // use signed max instead of unsigned max. Note that we're trying; // to prove a lack of unsigned overflow in either case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:44,Testability,test,tests,44,"// Try to make this an AddRec using runtime tests, in the first X; // iterations of this loop, where X is the SCEV expression found by the; // algorithm below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Safety,Avoid,Avoid,3,// Avoid weird loops,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Safety,Avoid,Avoid,3,// Avoid negative or zero stride values,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:192,Performance,optimiz,optimize,192,"// Avoid proven overflow cases: this will ensure that the backedge taken count; // will not generate any unsigned overflow. Relaxed no-overflow conditions; // exploit NoWrapFlags, allowing to optimize in presence of undefined; // behaviors like the case of C language.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Safety,Avoid,Avoid,3,"// Avoid proven overflow cases: this will ensure that the backedge taken count; // will not generate any unsigned overflow. Relaxed no-overflow conditions; // exploit NoWrapFlags, allowing to optimize in presence of undefined; // behaviors like the case of C language.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:108,Safety,safe,safe,108,"// Although End can be a MIN expression we estimate MinEnd considering only; // the case End = RHS. This is safe because in the other case (Start - End); // is zero, leading to a zero maximum backedge taken count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:59,Usability,simpl,simplify,59,"// If the start is a non-zero constant, shift the range to simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:124,Integrability,wrap,wrap,124,"// Evaluate at the exit value. If we really did fall out of the valid; // range, then we computed our trip count, otherwise wrap around or other; // things must have happened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:226,Usability,simpl,simplification,226,"// There is a temptation to just call getAddExpr(this, getStepRecurrence(SE)),; // but in this case we cannot guarantee that the value returned will be an; // AddRec because SCEV does not have a fixed point where it stops; // simplification: it is legal to return ({rec1} + {rec2}). For example, it; // may happen if we reach arithmetic depth limit while simplifying. So we; // construct the returned value explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:355,Usability,simpl,simplifying,355,"// There is a temptation to just call getAddExpr(this, getStepRecurrence(SE)),; // but in this case we cannot guarantee that the value returned will be an; // AddRec because SCEV does not have a fixed point where it stops; // simplification: it is legal to return ({rec1} + {rec2}). For example, it; // may happen if we reach arithmetic depth limit while simplifying. So we; // construct the returned value explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:535,Energy Efficiency,efficient,efficient,535,"// To use guards for proving predicates, we need to scan every instruction in; // relevant basic blocks, and not just terminators. Doing this is a waste of; // time if the IR does not actually contain any calls to; // @llvm.experimental.guard, so do a quick check and remember this beforehand.; //; // This pessimizes the case where a pass that preserves ScalarEvolution wants; // to _add_ guards to the module when there weren't any before, and wants; // ScalarEvolution to optimize based on those guards. For now we prefer to be; // efficient in lieu of being smart in that rather obscure case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:475,Performance,optimiz,optimize,475,"// To use guards for proving predicates, we need to scan every instruction in; // relevant basic blocks, and not just terminators. Doing this is a waste of; // time if the IR does not actually contain any calls to; // @llvm.experimental.guard, so do a quick check and remember this beforehand.; //; // This pessimizes the case where a pass that preserves ScalarEvolution wants; // to _add_ guards to the module when there weren't any before, and wants; // ScalarEvolution to optimize based on those guards. For now we prefer to be; // efficient in lieu of being smart in that rather obscure case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:94,Deployability,release,release,94,"// Iterate through all the SCEVUnknown instances and call their; // destructors, so that they release their references to their values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:78,Testability,test,test,78,"// This uses a ""dominates"" query instead of ""properly dominates"" query; // to test for proper dominance too, because the instruction which; // produces the addrec's value is a PHI, and a PHI effectively properly; // dominates its entire containing block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:15,Performance,cache,cached,15,// Only verify cached BECounts. Computing new BECounts may change the; // results of subsequent SCEV uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:233,Testability,assert,assert,233,"// NB! This situation is legal, but is very suspicious -- whatever pass; // change the loop to make a trip count go from could not compute to; // computable or vice-versa *should have* invalidated SCEV. However, we; // choose not to assert here (for now) since we don't want false; // positives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:10,Security,integrity,integrity,10,// Verify integrity of SCEV users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:19,Integrability,depend,dependencies,19,// We do not store dependencies of constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:10,Security,integrity,integrity,10,// Verify integrity of ValuesAtScopes users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:10,Security,integrity,integrity,10,// Verify integrity of BECountUsers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:40,Performance,cache,cache,40,// Verify intergity of loop disposition cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:45,Performance,cache,cache,45,// Verify integrity of the block disposition cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:10,Security,integrity,integrity,10,// Verify integrity of the block disposition cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:34,Performance,cache,caches,34,// Verify FoldCache/FoldCacheUser caches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:285,Integrability,wrap,wrap,285,// Verify that ConstantMultipleCache computations are correct. We check that; // cached multiples and recomputed multiples are multiples of each other to; // verify correctness. It is possible that a recomputed multiple is different; // from the cached multiple due to strengthened no wrap flags or changes in; // KnownBits computations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:81,Performance,cache,cached,81,// Verify that ConstantMultipleCache computations are correct. We check that; // cached multiples and recomputed multiples are multiples of each other to; // verify correctness. It is possible that a recomputed multiple is different; // from the cached multiple due to strengthened no wrap flags or changes in; // KnownBits computations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:246,Performance,cache,cached,246,// Verify that ConstantMultipleCache computations are correct. We check that; // cached multiples and recomputed multiples are multiples of each other to; // verify correctness. It is possible that a recomputed multiple is different; // from the cached multiple due to strengthened no wrap flags or changes in; // KnownBits computations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:87,Integrability,depend,dependencies,87,// Invalidate the ScalarEvolution object whenever it isn't preserved or one; // of its dependencies is invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:119,Testability,test,tests,119,// For compatibility with opt's -analyze feature under legacy pass manager; // which was not ported to NPM. This keeps tests using; // update_analyze_test_checks.py working.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:4,Modifiability,Rewrite,Rewrites,4,"/// Rewrites \p S in the context of a loop L and the SCEV predication; /// infrastructure.; ///; /// If \p Pred is non-null, the SCEV expression is rewritten to respect the; /// equivalences present in \p Pred.; ///; /// If \p NewPreds is non-null, rewrite is free to add further predicates to; /// \p NewPreds such that the result will be an AddRecExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:249,Modifiability,rewrite,rewrite,249,"/// Rewrites \p S in the context of a loop L and the SCEV predication; /// infrastructure.; ///; /// If \p Pred is non-null, the SCEV expression is rewritten to respect the; /// equivalences present in \p Pred.; ///; /// If \p NewPreds is non-null, rewrite is free to add further predicates to; /// \p NewPreds such that the result will be an AddRecExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Integrability,Wrap,Wrap,3,// Wrap predicates from outer loops are not supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:10,Safety,safe,safely,10,// We can safely transfer the NSW flag as NSSW.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:75,Integrability,Wrap,WrapPredicate,75,"// If the increment is positive, the SCEV NUW flag will also imply the; // WrapPredicate NUSW flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:31,Performance,cache,cached,31,/// Union predicates don't get cached so create a dummy set ID for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:188,Integrability,depend,dependencies,188,"// We do not expect that forgetting cached data for SCEVConstants will ever; // open any prospects for sharpening or introduce any correctness issues,; // so we don't bother storing their dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:36,Performance,cache,cached,36,"// We do not expect that forgetting cached data for SCEVConstants will ever; // open any prospects for sharpening or introduce any correctness issues,; // so we don't bother storing their dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:37,Modifiability,Rewrite,Rewrite,37,// We found an entry but it's stale. Rewrite the stale entry; // according to the current predicate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:28,Integrability,wrap,wrapped,28,// If the generation number wrapped recompute everything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Usability,Clear,Clear,3,// Clear the statically implied flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:179,Energy Efficiency,power,power-of-,179,"// Match the mathematical pattern A - (A / B) * B, where A and B can be; // arbitrary expressions. Also match zext (trunc A to iB) to iY, which is used; // for URem with constant power-of-2 second operands.; // It's not always easy, as A and B can be folded (imagine A is X / 2, and B is; // 4, A / B becomes X / 8).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:87,Energy Efficiency,power,power-of-,87,"// Try to match 'zext (trunc A to iB) to iY', which is used; // for URem with constant power-of-2 second operands. Make sure the size of; // the operand A matches the size of the whole expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:6,Modifiability,rewrite,rewriter,6,/// A rewriter to replace SCEV expressions in Map with the corresponding entry; /// in the map. It skips AddRecExpr because we cannot guarantee that the; /// replacement is loop invariant in the loop of the AddRec.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:49,Integrability,wrap,wrap,49,"// WARNING: It is generally unsound to apply any wrap flags to the proposed; // replacement SCEV which isn't directly implied by the structure of that; // SCEV. In particular, using contextual facts to imply flags is *NOT*; // legal. See the scoping rules for flags in the header to understand why.; // If LHS is a constant, apply information to the other expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:34,Integrability,wrap,wrapping,34,"// Bail out, unless we have a non-wrapping, monotonic range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:116,Availability,down,down,116,"// Apply divisibilty by \p Divisor on MinMaxExpr with constant values,; // recursively. This is done by aligning up/down the constant value to the; // Divisor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:102,Modifiability,rewrite,rewrite,102,"// If we have LHS == 0, check if LHS is computing a property of some unknown; // SCEV %v which we can rewrite %v to express explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:37,Modifiability,rewrite,rewrite,37,"// If LHS is A % B, i.e. A % B == 0, rewrite A to (A /u B) * B to; // explicitly express that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:8,Modifiability,rewrite,rewrite,8,"// Puts rewrite rule \p From -> \p To into the rewrite map. Also if \p From; // and \p FromRewritten are the same (i.e. there has been no rewrite; // registered for \p From), then puts this value in the list of rewritten; // expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:47,Modifiability,rewrite,rewrite,47,"// Puts rewrite rule \p From -> \p To into the rewrite map. Also if \p From; // and \p FromRewritten are the same (i.e. there has been no rewrite; // registered for \p From), then puts this value in the list of rewritten; // expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:138,Modifiability,rewrite,rewrite,138,"// Puts rewrite rule \p From -> \p To into the rewrite map. Also if \p From; // and \p FromRewritten are the same (i.e. there has been no rewrite; // registered for \p From), then puts this value in the list of rewritten; // expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:89,Modifiability,rewrite,rewrite,89,// Checks whether \p S has already been rewritten. In that case returns the; // existing rewrite because we want to chain further rewrites onto the; // already rewritten value. Otherwise returns \p S.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:130,Modifiability,rewrite,rewrites,130,// Checks whether \p S has already been rewritten. In that case returns the; // existing rewrite because we want to chain further rewrites onto the; // already rewritten value. Otherwise returns \p S.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:475,Integrability,depend,depending,475,"// Collect rewrites for LHS and its transitive operands based on the; // condition.; // For min/max expressions, also apply the guard to its operands:; // 'min(a, b) >= c' -> '(a >= c) and (b >= c)',; // 'min(a, b) > c' -> '(a > c) and (b > c)',; // 'max(a, b) <= c' -> '(a <= c) and (b <= c)',; // 'max(a, b) < c' -> '(a < c) and (b < c)'.; // We cannot express strict predicates in SCEV, so instead we replace them; // with non-strict ones against plus or minus one of RHS depending on the; // predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:11,Modifiability,rewrite,rewrites,11,"// Collect rewrites for LHS and its transitive operands based on the; // condition.; // For min/max expressions, also apply the guard to its operands:; // 'min(a, b) >= c' -> '(a >= c) and (b >= c)',; // 'min(a, b) > c' -> '(a > c) and (b > c)',; // 'max(a, b) <= c' -> '(a <= c) and (b <= c)',; // 'max(a, b) < c' -> '(a < c) and (b < c)'.; // We cannot express strict predicates in SCEV, so instead we replace them; // with non-strict ones against plus or minus one of RHS depending on the; // predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:266,Testability,log,logic,266,"// Third, collect conditions from dominating branches. Starting at the loop; // predecessor, climb up the predecessor chain, as long as there are; // predecessors that can be found that have unique successors leading to the; // original header.; // TODO: share this logic with isLoopEntryGuardedByCond.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:213,Integrability,depend,dependency,213,"// Now apply the information from the collected conditions to RewriteMap.; // Conditions are processed in reverse order, so the earliest conditions is; // processed first. This ensures the SCEVs with the shortest dependency chains; // are constructed first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:62,Modifiability,Rewrite,RewriteMap,62,"// Now apply the information from the collected conditions to RewriteMap.; // Conditions are processed in reverse order, so the earliest conditions is; // processed first. This ensures the SCEVs with the shortest dependency chains; // are constructed first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:16,Modifiability,rewrite,rewrite,16,"// Now that all rewrite information is collect, rewrite the collected; // expressions with the information in the map. This applies information to; // sub-expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:48,Modifiability,rewrite,rewrite,48,"// Now that all rewrite information is collect, rewrite the collected; // expressions with the information in the map. This applies information to; // sub-expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp:577,Integrability,depend,dependence,577,"//===- ScalarEvolutionAliasAnalysis.cpp - SCEV-based Alias Analysis -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ScalarEvolutionAliasAnalysis pass, which implements a; // simple alias analysis implemented in terms of ScalarEvolution queries.; //; // This differs from traditional loop dependence analysis in that it tests; // for dependencies within a single iteration of a loop, rather than; // dependencies between different iterations.; //; // ScalarEvolution has a more complete understanding of pointer arithmetic; // than BasicAliasAnalysis' collection of ad-hoc analyses.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp:622,Integrability,depend,dependencies,622,"//===- ScalarEvolutionAliasAnalysis.cpp - SCEV-based Alias Analysis -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ScalarEvolutionAliasAnalysis pass, which implements a; // simple alias analysis implemented in terms of ScalarEvolution queries.; //; // This differs from traditional loop dependence analysis in that it tests; // for dependencies within a single iteration of a loop, rather than; // dependencies between different iterations.; //; // ScalarEvolution has a more complete understanding of pointer arithmetic; // than BasicAliasAnalysis' collection of ad-hoc analyses.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp:688,Integrability,depend,dependencies,688,"//===- ScalarEvolutionAliasAnalysis.cpp - SCEV-based Alias Analysis -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ScalarEvolutionAliasAnalysis pass, which implements a; // simple alias analysis implemented in terms of ScalarEvolution queries.; //; // This differs from traditional loop dependence analysis in that it tests; // for dependencies within a single iteration of a loop, rather than; // dependencies between different iterations.; //; // ScalarEvolution has a more complete understanding of pointer arithmetic; // than BasicAliasAnalysis' collection of ad-hoc analyses.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp:608,Testability,test,tests,608,"//===- ScalarEvolutionAliasAnalysis.cpp - SCEV-based Alias Analysis -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ScalarEvolutionAliasAnalysis pass, which implements a; // simple alias analysis implemented in terms of ScalarEvolution queries.; //; // This differs from traditional loop dependence analysis in that it tests; // for dependencies within a single iteration of a loop, rather than; // dependencies between different iterations.; //; // ScalarEvolution has a more complete understanding of pointer arithmetic; // than BasicAliasAnalysis' collection of ad-hoc analyses.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp:463,Usability,simpl,simple,463,"//===- ScalarEvolutionAliasAnalysis.cpp - SCEV-based Alias Analysis -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ScalarEvolutionAliasAnalysis pass, which implements a; // simple alias analysis implemented in terms of ScalarEvolution queries.; //; // This differs from traditional loop dependence analysis in that it tests; // for dependencies within a single iteration of a loop, rather than; // dependencies between different iterations.; //; // ScalarEvolution has a more complete understanding of pointer arithmetic; // than BasicAliasAnalysis' collection of ad-hoc analyses.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp:3,Testability,Test,Test,3,"// Test whether the difference is known to be great enough that memory of; // the given sizes don't overlap. This assumes that ASizeInt and BSizeInt; // are non-zero, which is special-cased above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp:121,Testability,test,test,121,"// Folding the subtraction while preserving range information can be tricky; // (because of INT_MIN, etc.); if the prior test failed, swap AS and BS; // and try again to see if things fold better that way.; // Compute the difference between the two pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp:3,Testability,Test,Test,3,"// Test whether the difference is known to be great enough that memory of; // the given sizes don't overlap. This assumes that ASizeInt and BSizeInt; // are non-zero, which is special-cased above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp:99,Integrability,depend,depends,99,"// If ScalarEvolution can find an underlying object, form a new query.; // The correctness of this depends on ScalarEvolution not recognizing; // inttoptr and ptrtoint operators.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp:118,Integrability,depend,depends,118,"// We don't care if this analysis itself is preserved, it has no state. But; // we need to check that the analyses it depends on have been.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp:38,Safety,avoid,avoid,38,// Check for the trivial case here to avoid having to check for it in the; // rest of the code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp:5,Usability,simpl,simple,5,// A simple case when N/1. The quotient is N.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp:30,Usability,simpl,simplify,30,// This SCEV does not seem to simplify: fail the division here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp:124,Usability,simpl,simplify,124,"// We generally do not know how to divide Expr by Denominator. We initialize; // the division to a ""cannot divide"" state to simplify the rest of the code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionNormalization.cpp:18,Performance,Perform,Perform,18,/// Denormalize - Perform the inverse transform on the expression with the; /// given loop set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionNormalization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionNormalization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionNormalization.cpp:180,Usability,clear,clear,180,"// Denormalization / ""partial increment"" is essentially the same as \c; // SCEVAddRecExpr::getPostIncExpr. Here we use an explicit loop to make the; // symmetry with Normalization clear.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionNormalization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionNormalization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp:1016,Performance,Load,Loads,1016,"//===- ScopedNoAliasAA.cpp - Scoped No-Alias Alias Analysis ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ScopedNoAlias alias-analysis pass, which implements; // metadata-based scoped no-alias support.; //; // Alias-analysis scopes are defined by an id (which can be a string or some; // other metadata node), a domain node, and an optional descriptive string.; // A domain is defined by an id (which can be a string or some other metadata; // node), and an optional descriptive string.; //; // !dom0 = metadata !{ metadata !""domain of foo()"" }; // !scope1 = metadata !{ metadata !scope1, metadata !dom0, metadata !""scope 1"" }; // !scope2 = metadata !{ metadata !scope2, metadata !dom0, metadata !""scope 2"" }; //; // Loads and stores can be tagged with an alias-analysis scope, and also, with; // a noalias tag for a specific scope:; //; // ... = load %ptr1, !alias.scope !{ !scope1 }; // ... = load %ptr2, !alias.scope !{ !scope1, !scope2 }, !noalias !{ !scope1 }; //; // When evaluating an aliasing query, if one of the instructions is associated; // has a set of noalias scopes in some domain that is a superset of the alias; // scopes in that domain of some other instruction, then the two memory; // accesses are assumed not to alias.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp:1146,Performance,load,load,1146,"//===- ScopedNoAliasAA.cpp - Scoped No-Alias Alias Analysis ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ScopedNoAlias alias-analysis pass, which implements; // metadata-based scoped no-alias support.; //; // Alias-analysis scopes are defined by an id (which can be a string or some; // other metadata node), a domain node, and an optional descriptive string.; // A domain is defined by an id (which can be a string or some other metadata; // node), and an optional descriptive string.; //; // !dom0 = metadata !{ metadata !""domain of foo()"" }; // !scope1 = metadata !{ metadata !scope1, metadata !dom0, metadata !""scope 1"" }; // !scope2 = metadata !{ metadata !scope2, metadata !dom0, metadata !""scope 2"" }; //; // Loads and stores can be tagged with an alias-analysis scope, and also, with; // a noalias tag for a specific scope:; //; // ... = load %ptr1, !alias.scope !{ !scope1 }; // ... = load %ptr2, !alias.scope !{ !scope1, !scope2 }, !noalias !{ !scope1 }; //; // When evaluating an aliasing query, if one of the instructions is associated; // has a set of noalias scopes in some domain that is a superset of the alias; // scopes in that domain of some other instruction, then the two memory; // accesses are assumed not to alias.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp:1194,Performance,load,load,1194,"//===- ScopedNoAliasAA.cpp - Scoped No-Alias Alias Analysis ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ScopedNoAlias alias-analysis pass, which implements; // metadata-based scoped no-alias support.; //; // Alias-analysis scopes are defined by an id (which can be a string or some; // other metadata node), a domain node, and an optional descriptive string.; // A domain is defined by an id (which can be a string or some other metadata; // node), and an optional descriptive string.; //; // !dom0 = metadata !{ metadata !""domain of foo()"" }; // !scope1 = metadata !{ metadata !scope1, metadata !dom0, metadata !""scope 1"" }; // !scope2 = metadata !{ metadata !scope2, metadata !dom0, metadata !""scope 2"" }; //; // Loads and stores can be tagged with an alias-analysis scope, and also, with; // a noalias tag for a specific scope:; //; // ... = load %ptr1, !alias.scope !{ !scope1 }; // ... = load %ptr2, !alias.scope !{ !scope1, !scope2 }, !noalias !{ !scope1 }; //; // When evaluating an aliasing query, if one of the instructions is associated; // has a set of noalias scopes in some domain that is a superset of the alias; // scopes in that domain of some other instruction, then the two memory; // accesses are assumed not to alias.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp:1504,Security,access,accesses,1504,"//===- ScopedNoAliasAA.cpp - Scoped No-Alias Alias Analysis ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ScopedNoAlias alias-analysis pass, which implements; // metadata-based scoped no-alias support.; //; // Alias-analysis scopes are defined by an id (which can be a string or some; // other metadata node), a domain node, and an optional descriptive string.; // A domain is defined by an id (which can be a string or some other metadata; // node), and an optional descriptive string.; //; // !dom0 = metadata !{ metadata !""domain of foo()"" }; // !scope1 = metadata !{ metadata !scope1, metadata !dom0, metadata !""scope 1"" }; // !scope2 = metadata !{ metadata !scope2, metadata !dom0, metadata !""scope 2"" }; //; // Loads and stores can be tagged with an alias-analysis scope, and also, with; // a noalias tag for a specific scope:; //; // ... = load %ptr1, !alias.scope !{ !scope1 }; // ... = load %ptr2, !alias.scope !{ !scope1, !scope2 }, !noalias !{ !scope1 }; //; // When evaluating an aliasing query, if one of the instructions is associated; // has a set of noalias scopes in some domain that is a superset of the alias; // scopes in that domain of some other instruction, then the two memory; // accesses are assumed not to alias.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp:113,Availability,alive,alive,113,"// LiveIn, LiveOut and BitsIn have a different meaning deppends on type.; // ::Maybe true bits represent ""may be alive"" allocas, ::Must true bits; // represent ""may be dead"". After the loop we will convert ::Must bits from; // ""may be dead"" to ""must be alive"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp:253,Availability,alive,alive,253,"// LiveIn, LiveOut and BitsIn have a different meaning deppends on type.; // ::Maybe true bits represent ""may be alive"" allocas, ::Must true bits; // represent ""may be dead"". After the loop we will convert ::Must bits from; // ""may be dead"" to ""must be alive"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp:3,Deployability,Update,Update,3,"// Update block LiveIn set, noting whether it has changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp:11,Availability,alive,alive,11,"// ""may be alive"" is set by lifetime start.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp:3,Deployability,Update,Update,3,"// Update block LiveOut set, noting whether it has changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp:42,Availability,alive,alive,42,"// Convert from ""may be dead"" to ""must be alive"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackLifetime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:46,Safety,safe,safety,46,"//===- StackSafetyAnalysis.cpp - Stack memory safety analysis -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:11,Integrability,wrap,wrapped,11,// Two non-wrapped sets can produce wrapped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:36,Integrability,wrap,wrapped,36,// Two non-wrapped sets can produce wrapped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:3,Security,Access,Access,3,// Access range if the address (alloca or parameters).; // It is allowed to be empty-set when there are no known accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:113,Security,access,accesses,113,// Access range if the address (alloca or parameters).; // It is allowed to be empty-set when there are no known accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:210,Security,access,access,210,"// List of calls which pass address as an argument.; // Value is offset range of address from base address (alloca or calling; // function argument). Range should never set to empty-set, that is an invalid; // access range that can cause empty-set to be propagated with; // ConstantRange::add",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:34,Integrability,depend,depending,34,// TODO: describe return value as depending on one or more of its arguments.; // StackSafetyDataFlowAnalysis counter stored here for faster access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:140,Security,access,access,140,// TODO: describe return value as depending on one or more of its arguments.; // StackSafetyDataFlowAnalysis counter stored here for faster access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:13,Performance,load,loads,13,// Zero-size loads and stores do not access memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:37,Security,access,access,37,// Zero-size loads and stores do not access memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:36,Safety,safe,safe,36,// This only judges whether it is a safe *stack* access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:49,Security,access,access,49,// This only judges whether it is a safe *stack* access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:95,Security,access,access,95,/// The function analyzes all local uses of Ptr (alloca or argument) and; /// calculates local access range and all function calls where it was used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:56,Safety,unsafe,unsafe,56,// Stored the pointer - conservatively assume it may be unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:30,Safety,safe,safe,30,"// ""va-arg"" from a pointer is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:10,Usability,Simpl,Simplify,10,// FIXME: Simplify printing and remove copying here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:183,Energy Efficiency,reduce,reduce,183,"// Parameter accessed by any or unknown offset, represented as FullSet by; // StackSafety, is handled as the parameter for which we have no; // StackSafety info at all. So drop it to reduce summary size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:13,Security,access,accessed,13,"// Parameter accessed by any or unknown offset, represented as FullSet by; // StackSafety, is handled as the parameter for which we have no; // StackSafety info at all. So drop it to reduce summary size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:33,Availability,Alive,Alive,33,"// Reset data for all summaries. Alive and DSO local will be set back from; // of data flow results below. Anything else will not be accessed; // by ThinLTO backend, so we can save on bitcode size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:133,Security,access,accessed,133,"// Reset data for all summaries. Alive and DSO local will be set back from; // of data flow results below. Anything else will not be accessed; // by ThinLTO backend, so we can save on bitcode size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StructuralHash.cpp:37,Security,Hash,Hash,37,"//===- StructuralHash.cpp - Function Hash Printing ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the StructuralHashPrinterPass which is used to show; // the structural hash of all functions in a module and the module itself.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StructuralHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StructuralHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StructuralHash.cpp:472,Security,hash,hash,472,"//===- StructuralHash.cpp - Function Hash Printing ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the StructuralHashPrinterPass which is used to show; // the structural hash of all functions in a module and the module itself.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/StructuralHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StructuralHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp:30,Deployability,update,update,30,"// For nodes in the same SCC, update the counts in two steps:; // 1. Compute the additional count for each node by propagating the counts; // along all incoming edges to the node that originate from within the same; // SCC and summing them up.; // 2. Add the additional counts to the nodes in the SCC.; // This ensures that the order of; // traversal of nodes within the SCC doesn't affect the final result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp:3,Deployability,Update,Update,3,// Update the counts for the nodes in the SCC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp:7,Deployability,update,update,7,// Now update the counts for nodes outside the SCC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp:247,Deployability,update,updates,247,"/// Propgate synthetic entry counts on a callgraph \p CG.; ///; /// This performs a reverse post-order traversal of the callgraph SCC. For each; /// SCC, it first propagates the entry counts to the nodes within the SCC; /// through call edges and updates them in one shot. Then the entry counts are; /// propagated to nodes outside the SCC. This requires \p GraphTraits; /// to have a specialization for \p CallGraphType.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp:73,Performance,perform,performs,73,"/// Propgate synthetic entry counts on a callgraph \p CG.; ///; /// This performs a reverse post-order traversal of the callgraph SCC. For each; /// SCC, it first propagates the entry counts to the nodes within the SCC; /// through call edges and updates them in one shot. Then the entry counts are; /// propagated to nodes outside the SCC. This requires \p GraphTraits; /// to have a specialization for \p CallGraphType.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp:48,Availability,down,down,48,"// The callgraph-scc needs to be visited in top-down order for propagation.; // The scc iterator returns the scc in bottom-up order, so reverse the SCCs; // and call propagateFromSCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:85,Usability,simpl,simplify,85,"// The iOS ABI diverges from the standard in some cases, so for now don't; // try to simplify those calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:26,Availability,avail,available,26,/// Initialize the set of available library functions based on the specified; /// target triple. This should be carefully written so that a missing target; /// triple gets a sane set of defaults.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:59,Availability,avail,available,59,// Set IO unlocked variants as unavailable; // Set them as available per system below,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:34,Availability,avail,available,34,"// memset_pattern{4,8,16} is only available on iOS 3.0 and Mac OS X 10.5 and; // later. All versions of watchOS support it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:3,Availability,avail,available,3,// available IO unlocked variants on Mac OS X,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:318,Integrability,depend,depends,318,"// x86-32 OSX has a scheme where fwrite and fputs (and some other functions; // we don't care about) have two versions; on recent OSX, the one we want; // has a $UNIX2003 suffix. The two implementations are identical except; // for the return value in some edge cases. However, we don't want to; // generate code that depends on the old symbols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:32,Availability,avail,available,32,"// iprintf and friends are only available on XCore, TCE, and Emscripten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:39,Availability,avail,available,39,// __small_printf and friends are only available on Emscripten.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:35,Availability,avail,available,35,"// XXX: The earliest documentation available at the moment is for VS2015/VC19:; // https://docs.microsoft.com/en-us/cpp/c-runtime-library/floating-point-support?view=vs-2015; // XXX: In order to use an MSVCRT older than VC19,; // the specific library version must be explicit in the target triple,; // e.g., x86_64-pc-windows-msvc18.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:70,Availability,avail,available,70,"// Win32 does not support these functions, but; // they are generally available on POSIX-compliant systems.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:26,Availability,avail,available,26,// These functions aren't available in either MSVC or MinGW environments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:28,Availability,avail,available,28,// exp10 and exp10f are not available on OS X until 10.9 and iOS until 7.0; // and their names are __exp10 and __exp10f. exp10l is not available on; // OS X or iOS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:135,Availability,avail,available,135,// exp10 and exp10f are not available on OS X until 10.9 and iOS until 7.0; // and their names are __exp10 and __exp10f. exp10l is not available on; // OS X or iOS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:28,Availability,avail,available,28,"// exp10, exp10f, exp10l is available on Linux (GLIBC) but are extremely; // buggy prior to glibc version 2.18. Until this version is widely deployed; // or we have a reasonable detection strategy, we cannot use exp10 reliably; // on Linux.; //; // Fall through to disable all of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:218,Availability,reliab,reliably,218,"// exp10, exp10f, exp10l is available on Linux (GLIBC) but are extremely; // buggy prior to glibc version 2.18. Until this version is widely deployed; // or we have a reasonable detection strategy, we cannot use exp10 reliably; // on Linux.; //; // Fall through to disable all of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:141,Deployability,deploy,deployed,141,"// exp10, exp10f, exp10l is available on Linux (GLIBC) but are extremely; // buggy prior to glibc version 2.18. Until this version is widely deployed; // or we have a reasonable detection strategy, we cannot use exp10 reliably; // on Linux.; //; // Fall through to disable all of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:178,Safety,detect,detection,178,"// exp10, exp10f, exp10l is available on Linux (GLIBC) but are extremely; // buggy prior to glibc version 2.18. Until this version is widely deployed; // or we have a reasonable detection strategy, we cannot use exp10 reliably; // on Linux.; //; // Fall through to disable all of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:11,Availability,avail,available,11,"// ffsl is available on at least Darwin, Mac OS X, iOS, FreeBSD, and; // Linux (GLIBC):; // http://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man3/ffsl.3.html; // http://svn.freebsd.org/base/head/lib/libc/string/ffsl.c; // http://www.gnu.org/software/gnulib/manual/html_node/ffsl.html",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:12,Availability,avail,available,12,// ffsll is available on at least FreeBSD and Linux (GLIBC):; // http://svn.freebsd.org/base/head/lib/libc/string/ffsll.c; // http://www.gnu.org/software/gnulib/manual/html_node/ffsll.html,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:31,Availability,avail,available,31,// The following functions are available on at least FreeBSD:; // http://svn.freebsd.org/base/head/lib/libc/string/fls.c; // http://svn.freebsd.org/base/head/lib/libc/string/flsl.c; // http://svn.freebsd.org/base/head/lib/libc/string/flsll.c,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:36,Availability,avail,available,36,"// The following functions are only available on GNU/Linux (using glibc).; // Linux variants without glibc (eg: bionic, musl) may have some subset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:3,Availability,avail,available,3,// available IO unlocked variants on GNU/Linux and Android P or later,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:554,Performance,optimiz,optimizations,554,"// As currently implemented in clang, NVPTX code has no standard library to; // speak of. Headers provide a standard-ish library implementation, but many; // of the signatures are wrong -- for example, many libm functions are not; // extern ""C"".; //; // libdevice, an IR library provided by nvidia, is linked in by the front-end,; // but only used functions are provided to llvm. Moreover, most of the; // functions in libdevice don't map precisely to standard library functions.; //; // FIXME: Having no standard library prevents e.g. many fastmath; // optimizations, so this situation should be fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:107,Performance,perform,performance,107,// TODO: We could enable the following two according to [0] but we haven't; // done an evaluation wrt. the performance implications.; // [0]; // https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#dynamic-global-memory-allocation-and-operations; //; // TLI.setAvailable(llvm::LibFunc_memcpy);; // TLI.setAvailable(llvm::LibFunc_memset);,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:193,Usability,guid,guide,193,// TODO: We could enable the following two according to [0] but we haven't; // done an evaluation wrt. the performance implications.; // [0]; // https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#dynamic-global-memory-allocation-and-operations; //; // TLI.setAvailable(llvm::LibFunc_memcpy);; // TLI.setAvailable(llvm::LibFunc_memset);,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:43,Availability,avail,available,43,// These vec_malloc/free routines are only available on AIX.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:25,Integrability,rout,routines,25,// These vec_malloc/free routines are only available on AIX.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:31,Availability,avail,available,31,// Default to everything being available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:31,Availability,avail,available,31,// Default to everything being available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:194,Performance,optimiz,optimizations,194,"// NOTE: These prototypes are target specific and currently support; // ""complex"" passed as an array or discrete real & imaginary parameters.; // Add other calling conventions to enable libcall optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:156,Safety,avoid,avoid,156,"// Intrinsics don't overlap w/libcalls; if our module has a large number of; // intrinsics, this ends up being an interesting compile time win since we; // avoid string normalization and comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:3,Availability,MASK,MASK,3,/* MASK = */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:3,Availability,MASK,MASK,3,/* MASK = */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp:145,Availability,avail,available,145,/// No-op implementation of the TTI interface using the utility base; /// classes.; ///; /// This is used when no target specific information is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp:36,Integrability,interface,interface,36,/// No-op implementation of the TTI interface using the utility base; /// classes.; ///; /// This is used when no target specific information is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp:18,Deployability,update,updated,18,"// If we pass the updated counter back through a phi, we need to know; // which latch the updated value will be coming from.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp:90,Deployability,update,updated,90,"// If we pass the updated counter back through a phi, we need to know; // which latch the updated value will be coming from.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp:117,Energy Efficiency,power,powers,117,// Check for a splat of a constant or for a non uniform vector of constants; // and check if the constant(s) are all powers of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp:101,Integrability,interface,interface,101,"// FIXME: Assert that Opcode is either InsertElement or ExtractElement.; // This is mentioned in the interface description and respected by all; // callers, but never asserted upon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp:10,Testability,Assert,Assert,10,"// FIXME: Assert that Opcode is either InsertElement or ExtractElement.; // This is mentioned in the interface description and respected by all; // callers, but never asserted upon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp:167,Testability,assert,asserted,167,"// FIXME: Assert that Opcode is either InsertElement or ExtractElement.; // This is mentioned in the interface description and respected by all; // callers, but never asserted upon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp:101,Integrability,interface,interface,101,"// FIXME: Assert that Opcode is either InsertElement or ExtractElement.; // This is mentioned in the interface description and respected by all; // callers, but never asserted upon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp:10,Testability,Assert,Assert,10,"// FIXME: Assert that Opcode is either InsertElement or ExtractElement.; // This is mentioned in the interface description and respected by all; // callers, but never asserted upon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp:167,Testability,assert,asserted,167,"// FIXME: Assert that Opcode is either InsertElement or ExtractElement.; // This is mentioned in the interface description and respected by all; // callers, but never asserted upon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TensorSpec.cpp:450,Performance,load,loading,450,"//===- TensorSpec.cpp - tensor type abstraction ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implementation file for the abstraction of a tensor type, and JSON loading; // utils.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TensorSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TensorSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TensorSpec.cpp:55,Availability,error,error,55,"// FIXME: accept a Path as a parameter, and use it for error reporting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TensorSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TensorSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp:18,Integrability,message,messages,18,// INFO and DEBUG messages could be numerous and not particularly interesting,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp:15,Availability,Error,ErrorReporter,15,"// FIXME: make ErrorReporter a member (may also need subclassing; // StatefulErrorReporter) to easily get the latest error status, for; // debugging.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp:117,Availability,error,error,117,"// FIXME: make ErrorReporter a member (may also need subclassing; // StatefulErrorReporter) to easily get the latest error status, for; // debugging.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp:101,Energy Efficiency,allocate,allocates,101,"// We assume the input buffers are valid for the lifetime of the interpreter.; // By default, tflite allocates memory in an arena and will periodically take; // away memory and reallocate it in a different location after evaluations in; // order to improve utilization of the buffers owned in the arena. So, we; // explicitly mark our input buffers as persistent to avoid this behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp:366,Safety,avoid,avoid,366,"// We assume the input buffers are valid for the lifetime of the interpreter.; // By default, tflite allocates memory in an arena and will periodically take; // away memory and reallocate it in a different location after evaluations in; // order to improve utilization of the buffers owned in the arena. So, we; // explicitly mark our input buffers as persistent to avoid this behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp:70,Availability,error,error,70,"// we haven't passed all the required features to the model, throw an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Trace.cpp:538,Performance,optimiz,optimizations,538,"//===- Trace.cpp - Implementation of Trace class --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class represents a single trace of LLVM basic blocks. A trace is a; // single entry, multiple exit, region of code that is often hot. Trace-based; // optimizations treat traces almost like they are a large, strange, basic; // block: because the trace path is assumed to be hot, optimizations for the; // fall-through path are made at the expense of the non-fall-through paths.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Trace.cpp:666,Performance,optimiz,optimizations,666,"//===- Trace.cpp - Implementation of Trace class --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class represents a single trace of LLVM basic blocks. A trace is a; // single entry, multiple exit, region of code that is often hot. Trace-based; // optimizations treat traces almost like they are a large, strange, basic; // block: because the trace path is assumed to be hot, optimizations for the; // fall-through path are made at the expense of the non-fall-through paths.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Trace.cpp:65,Availability,error,error,65,/// dump - Debugger convenience method; writes trace to standard error; /// output stream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Trace.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Trace.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TrainingLogger.cpp:48,Testability,log,logging,48,"//===- TrainingLogger.cpp - mlgo feature/reward logging -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements logging infrastructure for extracting features and; // rewards for mlgo policy training.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TrainingLogger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TrainingLogger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TrainingLogger.cpp:404,Testability,log,logging,404,"//===- TrainingLogger.cpp - mlgo feature/reward logging -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements logging infrastructure for extracting features and; // rewards for mlgo policy training.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TrainingLogger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TrainingLogger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:953,Deployability,upgrade,upgraded,953,"- TypeBasedAliasAnalysis.cpp - Type-Based Alias Analysis -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the TypeBasedAliasAnalysis pass, which implements; // metadata-based TBAA.; //; // In LLVM IR, memory does not have types, so LLVM's own type system is not; // suitable for doing TBAA. Instead, metadata is added to the IR to describe; // a type system of a higher level language. This can be used to implement; // typical C/C++ TBAA, but it can also be used to implement custom alias; // analysis behavior for other languages.; //; // We now support two types of metadata format: scalar TBAA and struct-path; // aware TBAA. After all testing cases are upgraded to use struct-path aware; // TBAA and we can auto-upgrade existing bc files, the support for scalar TBAA; // can be dropped.; //; // The scalar TBAA metadata format is very simple. TBAA MDNodes have up to; // three fields, e.g.:; // !0 = !{ !""an example type tree"" }; // !1 = !{ !""int"", !0 }; // !2 = !{ !""float"", !0 }; // !3 = !{ !""const float"", !2, i64 1 }; //; // The first field is an identity field. It can be any value, usually; // an MDString, which uniquely identifies the type. The most important; // name in the tree is the name of the root node. Two trees with; // different root node names are entirely disjoint, even if they; // have leaves with common names.; //; // The second field identifies the type's parent node in the tree, or; // is null or omitted for a root node. A type is considered to alias; // all of its descendants and all of its ancestors in the tree. Also,; // a type is considered to alias all types in other trees, so that; // bitcode produced from multiple front-ends is handled conservatively.; //; // If th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:1012,Deployability,upgrade,upgrade,1012,"- TypeBasedAliasAnalysis.cpp - Type-Based Alias Analysis -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the TypeBasedAliasAnalysis pass, which implements; // metadata-based TBAA.; //; // In LLVM IR, memory does not have types, so LLVM's own type system is not; // suitable for doing TBAA. Instead, metadata is added to the IR to describe; // a type system of a higher level language. This can be used to implement; // typical C/C++ TBAA, but it can also be used to implement custom alias; // analysis behavior for other languages.; //; // We now support two types of metadata format: scalar TBAA and struct-path; // aware TBAA. After all testing cases are upgraded to use struct-path aware; // TBAA and we can auto-upgrade existing bc files, the support for scalar TBAA; // can be dropped.; //; // The scalar TBAA metadata format is very simple. TBAA MDNodes have up to; // three fields, e.g.:; // !0 = !{ !""an example type tree"" }; // !1 = !{ !""int"", !0 }; // !2 = !{ !""float"", !0 }; // !3 = !{ !""const float"", !2, i64 1 }; //; // The first field is an identity field. It can be any value, usually; // an MDString, which uniquely identifies the type. The most important; // name in the tree is the name of the root node. Two trees with; // different root node names are entirely disjoint, even if they; // have leaves with common names.; //; // The second field identifies the type's parent node in the tree, or; // is null or omitted for a root node. A type is considered to alias; // all of its descendants and all of its ancestors in the tree. Also,; // a type is considered to alias all types in other trees, so that; // bitcode produced from multiple front-ends is handled conservatively.; //; // If th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:3302,Performance,load,load,3302,"ction using; // ""!tbaa"" are called path tag nodes.; //; // The path tag node has 4 fields with the last field being optional.; //; // The first field is the base type node, it can be a struct type node; // or a scalar type node. The second field is the access type node, it; // must be a scalar type node. The third field is the offset into the base type.; // The last field has the same meaning as the last field of our scalar TBAA:; // it's an integer which if equal to 1 indicates that the access is ""constant"".; //; // The struct type node has a name and a list of pairs, one pair for each member; // of the struct. The first element of each pair is a type node (a struct type; // node or a scalar type node), specifying the type of the member, the second; // element of each pair is the offset of the member.; //; // Given an example; // typedef struct {; // short s;; // } A;; // typedef struct {; // uint16_t s;; // A a;; // } B;; //; // For an access to B.a.s, we attach !5 (a path tag node) to the load/store; // instruction. The base type is !4 (struct B), the access type is !2 (scalar; // type short) and the offset is 4.; //; // !0 = !{!""Simple C/C++ TBAA""}; // !1 = !{!""omnipotent char"", !0} // Scalar type node; // !2 = !{!""short"", !1} // Scalar type node; // !3 = !{!""A"", !2, i64 0} // Struct type node; // !4 = !{!""B"", !2, i64 0, !3, i64 4}; // // Struct type node; // !5 = !{!4, !2, i64 4} // Path tag node; //; // The struct type nodes and the scalar type nodes form a type DAG.; // Root (!0); // char (!1) -- edge to Root; // short (!2) -- edge to char; // A (!3) -- edge with offset 0 to short; // B (!4) -- edge with offset 0 to short and edge with offset 4 to A; //; // To check if two tags (tagX and tagY) can alias, we start from the base type; // of tagX, follow the edge with the correct offset in the type DAG and adjust; // the offset until we reach the base type of tagY or until we reach the Root; // node.; // If we reach the base type of tagY, compare the adjusted of",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:4428,Performance,perform,perform,4428,"and a list of pairs, one pair for each member; // of the struct. The first element of each pair is a type node (a struct type; // node or a scalar type node), specifying the type of the member, the second; // element of each pair is the offset of the member.; //; // Given an example; // typedef struct {; // short s;; // } A;; // typedef struct {; // uint16_t s;; // A a;; // } B;; //; // For an access to B.a.s, we attach !5 (a path tag node) to the load/store; // instruction. The base type is !4 (struct B), the access type is !2 (scalar; // type short) and the offset is 4.; //; // !0 = !{!""Simple C/C++ TBAA""}; // !1 = !{!""omnipotent char"", !0} // Scalar type node; // !2 = !{!""short"", !1} // Scalar type node; // !3 = !{!""A"", !2, i64 0} // Struct type node; // !4 = !{!""B"", !2, i64 0, !3, i64 4}; // // Struct type node; // !5 = !{!4, !2, i64 4} // Path tag node; //; // The struct type nodes and the scalar type nodes form a type DAG.; // Root (!0); // char (!1) -- edge to Root; // short (!2) -- edge to char; // A (!3) -- edge with offset 0 to short; // B (!4) -- edge with offset 0 to short and edge with offset 4 to A; //; // To check if two tags (tagX and tagY) can alias, we start from the base type; // of tagX, follow the edge with the correct offset in the type DAG and adjust; // the offset until we reach the base type of tagY or until we reach the Root; // node.; // If we reach the base type of tagY, compare the adjusted offset with; // offset of tagY, return Alias if the offsets are the same, return NoAlias; // otherwise.; // If we reach the Root node, perform the above starting from base type of tagY; // to see if we reach base type of tagX.; //; // If they have different roots, they're part of different potentially; // unrelated type systems, so we return Alias to be conservative.; // If neither node is an ancestor of the other and they have the same root,; // then we say NoAlias.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:2548,Security,access,access,2548,"es are entirely disjoint, even if they; // have leaves with common names.; //; // The second field identifies the type's parent node in the tree, or; // is null or omitted for a root node. A type is considered to alias; // all of its descendants and all of its ancestors in the tree. Also,; // a type is considered to alias all types in other trees, so that; // bitcode produced from multiple front-ends is handled conservatively.; //; // If the third field is present, it's an integer which if equal to 1; // indicates that the type is ""constant"" (meaning pointsToConstantMemory; // should return true; see; // http://llvm.org/docs/AliasAnalysis.html#OtherItfs).; //; // With struct-path aware TBAA, the MDNodes attached to an instruction using; // ""!tbaa"" are called path tag nodes.; //; // The path tag node has 4 fields with the last field being optional.; //; // The first field is the base type node, it can be a struct type node; // or a scalar type node. The second field is the access type node, it; // must be a scalar type node. The third field is the offset into the base type.; // The last field has the same meaning as the last field of our scalar TBAA:; // it's an integer which if equal to 1 indicates that the access is ""constant"".; //; // The struct type node has a name and a list of pairs, one pair for each member; // of the struct. The first element of each pair is a type node (a struct type; // node or a scalar type node), specifying the type of the member, the second; // element of each pair is the offset of the member.; //; // Given an example; // typedef struct {; // short s;; // } A;; // typedef struct {; // uint16_t s;; // A a;; // } B;; //; // For an access to B.a.s, we attach !5 (a path tag node) to the load/store; // instruction. The base type is !4 (struct B), the access type is !2 (scalar; // type short) and the offset is 4.; //; // !0 = !{!""Simple C/C++ TBAA""}; // !1 = !{!""omnipotent char"", !0} // Scalar type node; // !2 = !{!""short"", !1} // Scalar type n",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:2788,Security,access,access,2788,"ted for a root node. A type is considered to alias; // all of its descendants and all of its ancestors in the tree. Also,; // a type is considered to alias all types in other trees, so that; // bitcode produced from multiple front-ends is handled conservatively.; //; // If the third field is present, it's an integer which if equal to 1; // indicates that the type is ""constant"" (meaning pointsToConstantMemory; // should return true; see; // http://llvm.org/docs/AliasAnalysis.html#OtherItfs).; //; // With struct-path aware TBAA, the MDNodes attached to an instruction using; // ""!tbaa"" are called path tag nodes.; //; // The path tag node has 4 fields with the last field being optional.; //; // The first field is the base type node, it can be a struct type node; // or a scalar type node. The second field is the access type node, it; // must be a scalar type node. The third field is the offset into the base type.; // The last field has the same meaning as the last field of our scalar TBAA:; // it's an integer which if equal to 1 indicates that the access is ""constant"".; //; // The struct type node has a name and a list of pairs, one pair for each member; // of the struct. The first element of each pair is a type node (a struct type; // node or a scalar type node), specifying the type of the member, the second; // element of each pair is the offset of the member.; //; // Given an example; // typedef struct {; // short s;; // } A;; // typedef struct {; // uint16_t s;; // A a;; // } B;; //; // For an access to B.a.s, we attach !5 (a path tag node) to the load/store; // instruction. The base type is !4 (struct B), the access type is !2 (scalar; // type short) and the offset is 4.; //; // !0 = !{!""Simple C/C++ TBAA""}; // !1 = !{!""omnipotent char"", !0} // Scalar type node; // !2 = !{!""short"", !1} // Scalar type node; // !3 = !{!""A"", !2, i64 0} // Struct type node; // !4 = !{!""B"", !2, i64 0, !3, i64 4}; // // Struct type node; // !5 = !{!4, !2, i64 4} // Path tag node; //; // Th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:3247,Security,access,access,3247,"m.org/docs/AliasAnalysis.html#OtherItfs).; //; // With struct-path aware TBAA, the MDNodes attached to an instruction using; // ""!tbaa"" are called path tag nodes.; //; // The path tag node has 4 fields with the last field being optional.; //; // The first field is the base type node, it can be a struct type node; // or a scalar type node. The second field is the access type node, it; // must be a scalar type node. The third field is the offset into the base type.; // The last field has the same meaning as the last field of our scalar TBAA:; // it's an integer which if equal to 1 indicates that the access is ""constant"".; //; // The struct type node has a name and a list of pairs, one pair for each member; // of the struct. The first element of each pair is a type node (a struct type; // node or a scalar type node), specifying the type of the member, the second; // element of each pair is the offset of the member.; //; // Given an example; // typedef struct {; // short s;; // } A;; // typedef struct {; // uint16_t s;; // A a;; // } B;; //; // For an access to B.a.s, we attach !5 (a path tag node) to the load/store; // instruction. The base type is !4 (struct B), the access type is !2 (scalar; // type short) and the offset is 4.; //; // !0 = !{!""Simple C/C++ TBAA""}; // !1 = !{!""omnipotent char"", !0} // Scalar type node; // !2 = !{!""short"", !1} // Scalar type node; // !3 = !{!""A"", !2, i64 0} // Struct type node; // !4 = !{!""B"", !2, i64 0, !3, i64 4}; // // Struct type node; // !5 = !{!4, !2, i64 4} // Path tag node; //; // The struct type nodes and the scalar type nodes form a type DAG.; // Root (!0); // char (!1) -- edge to Root; // short (!2) -- edge to char; // A (!3) -- edge with offset 0 to short; // B (!4) -- edge with offset 0 to short and edge with offset 4 to A; //; // To check if two tags (tagX and tagY) can alias, we start from the base type; // of tagX, follow the edge with the correct offset in the type DAG and adjust; // the offset until we reach the base t",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:3366,Security,access,access,3366,"fields with the last field being optional.; //; // The first field is the base type node, it can be a struct type node; // or a scalar type node. The second field is the access type node, it; // must be a scalar type node. The third field is the offset into the base type.; // The last field has the same meaning as the last field of our scalar TBAA:; // it's an integer which if equal to 1 indicates that the access is ""constant"".; //; // The struct type node has a name and a list of pairs, one pair for each member; // of the struct. The first element of each pair is a type node (a struct type; // node or a scalar type node), specifying the type of the member, the second; // element of each pair is the offset of the member.; //; // Given an example; // typedef struct {; // short s;; // } A;; // typedef struct {; // uint16_t s;; // A a;; // } B;; //; // For an access to B.a.s, we attach !5 (a path tag node) to the load/store; // instruction. The base type is !4 (struct B), the access type is !2 (scalar; // type short) and the offset is 4.; //; // !0 = !{!""Simple C/C++ TBAA""}; // !1 = !{!""omnipotent char"", !0} // Scalar type node; // !2 = !{!""short"", !1} // Scalar type node; // !3 = !{!""A"", !2, i64 0} // Struct type node; // !4 = !{!""B"", !2, i64 0, !3, i64 4}; // // Struct type node; // !5 = !{!4, !2, i64 4} // Path tag node; //; // The struct type nodes and the scalar type nodes form a type DAG.; // Root (!0); // char (!1) -- edge to Root; // short (!2) -- edge to char; // A (!3) -- edge with offset 0 to short; // B (!4) -- edge with offset 0 to short and edge with offset 4 to A; //; // To check if two tags (tagX and tagY) can alias, we start from the base type; // of tagX, follow the edge with the correct offset in the type DAG and adjust; // the offset until we reach the base type of tagY or until we reach the Root; // node.; // If we reach the base type of tagY, compare the adjusted offset with; // offset of tagY, return Alias if the offsets are the same, return NoAli",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:935,Testability,test,testing,935,"- TypeBasedAliasAnalysis.cpp - Type-Based Alias Analysis -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the TypeBasedAliasAnalysis pass, which implements; // metadata-based TBAA.; //; // In LLVM IR, memory does not have types, so LLVM's own type system is not; // suitable for doing TBAA. Instead, metadata is added to the IR to describe; // a type system of a higher level language. This can be used to implement; // typical C/C++ TBAA, but it can also be used to implement custom alias; // analysis behavior for other languages.; //; // We now support two types of metadata format: scalar TBAA and struct-path; // aware TBAA. After all testing cases are upgraded to use struct-path aware; // TBAA and we can auto-upgrade existing bc files, the support for scalar TBAA; // can be dropped.; //; // The scalar TBAA metadata format is very simple. TBAA MDNodes have up to; // three fields, e.g.:; // !0 = !{ !""an example type tree"" }; // !1 = !{ !""int"", !0 }; // !2 = !{ !""float"", !0 }; // !3 = !{ !""const float"", !2, i64 1 }; //; // The first field is an identity field. It can be any value, usually; // an MDString, which uniquely identifies the type. The most important; // name in the tree is the name of the root node. Two trees with; // different root node names are entirely disjoint, even if they; // have leaves with common names.; //; // The second field identifies the type's parent node in the tree, or; // is null or omitted for a root node. A type is considered to alias; // all of its descendants and all of its ancestors in the tree. Also,; // a type is considered to alias all types in other trees, so that; // bitcode produced from multiple front-ends is handled conservatively.; //; // If th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:1135,Usability,simpl,simple,1135," under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the TypeBasedAliasAnalysis pass, which implements; // metadata-based TBAA.; //; // In LLVM IR, memory does not have types, so LLVM's own type system is not; // suitable for doing TBAA. Instead, metadata is added to the IR to describe; // a type system of a higher level language. This can be used to implement; // typical C/C++ TBAA, but it can also be used to implement custom alias; // analysis behavior for other languages.; //; // We now support two types of metadata format: scalar TBAA and struct-path; // aware TBAA. After all testing cases are upgraded to use struct-path aware; // TBAA and we can auto-upgrade existing bc files, the support for scalar TBAA; // can be dropped.; //; // The scalar TBAA metadata format is very simple. TBAA MDNodes have up to; // three fields, e.g.:; // !0 = !{ !""an example type tree"" }; // !1 = !{ !""int"", !0 }; // !2 = !{ !""float"", !0 }; // !3 = !{ !""const float"", !2, i64 1 }; //; // The first field is an identity field. It can be any value, usually; // an MDString, which uniquely identifies the type. The most important; // name in the tree is the name of the root node. Two trees with; // different root node names are entirely disjoint, even if they; // have leaves with common names.; //; // The second field identifies the type's parent node in the tree, or; // is null or omitted for a root node. A type is considered to alias; // all of its descendants and all of its ancestors in the tree. Also,; // a type is considered to alias all types in other trees, so that; // bitcode produced from multiple front-ends is handled conservatively.; //; // If the third field is present, it's an integer which if equal to 1; // indicates that the type is ""constant"" (mean",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:3446,Usability,Simpl,Simple,3446," field is the offset into the base type.; // The last field has the same meaning as the last field of our scalar TBAA:; // it's an integer which if equal to 1 indicates that the access is ""constant"".; //; // The struct type node has a name and a list of pairs, one pair for each member; // of the struct. The first element of each pair is a type node (a struct type; // node or a scalar type node), specifying the type of the member, the second; // element of each pair is the offset of the member.; //; // Given an example; // typedef struct {; // short s;; // } A;; // typedef struct {; // uint16_t s;; // A a;; // } B;; //; // For an access to B.a.s, we attach !5 (a path tag node) to the load/store; // instruction. The base type is !4 (struct B), the access type is !2 (scalar; // type short) and the offset is 4.; //; // !0 = !{!""Simple C/C++ TBAA""}; // !1 = !{!""omnipotent char"", !0} // Scalar type node; // !2 = !{!""short"", !1} // Scalar type node; // !3 = !{!""A"", !2, i64 0} // Struct type node; // !4 = !{!""B"", !2, i64 0, !3, i64 4}; // // Struct type node; // !5 = !{!4, !2, i64 4} // Path tag node; //; // The struct type nodes and the scalar type nodes form a type DAG.; // Root (!0); // char (!1) -- edge to Root; // short (!2) -- edge to char; // A (!3) -- edge with offset 0 to short; // B (!4) -- edge with offset 0 to short and edge with offset 4 to A; //; // To check if two tags (tagX and tagY) can alias, we start from the base type; // of tagX, follow the edge with the correct offset in the type DAG and adjust; // the offset until we reach the base type of tagY or until we reach the Root; // node.; // If we reach the base type of tagY, compare the adjusted offset with; // offset of tagY, return Alias if the offsets are the same, return NoAlias; // otherwise.; // If we reach the Root node, perform the above starting from base type of tagY; // to see if we reach base type of tagX.; //; // If they have different roots, they're part of different potentially; // unrelated ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:21,Integrability,wrap,wrapper,21,/// This is a simple wrapper around an MDNode which provides a higher-level; /// interface by hiding the details of how alias analysis information is encoded; /// in its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:81,Integrability,interface,interface,81,/// This is a simple wrapper around an MDNode which provides a higher-level; /// interface by hiding the details of how alias analysis information is encoded; /// in its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:14,Usability,simpl,simple,14,/// This is a simple wrapper around an MDNode which provides a higher-level; /// interface by hiding the details of how alias analysis information is encoded; /// in its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:38,Integrability,wrap,wrapped,38,/// isNewFormat - Return true iff the wrapped type node is in the new; /// size-aware format.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:4,Testability,Test,Test,4,/// Test if this TBAANode represents a type for objects which are; /// not modified (by any means) in the context where this; /// AliasAnalysis is relevant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:29,Integrability,wrap,wrapper,29,/// @}; /// This is a simple wrapper around an MDNode which provides a; /// higher-level interface by hiding the details of how alias analysis; /// information is encoded in its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:89,Integrability,interface,interface,89,/// @}; /// This is a simple wrapper around an MDNode which provides a; /// higher-level interface by hiding the details of how alias analysis; /// information is encoded in its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:22,Usability,simpl,simple,22,/// @}; /// This is a simple wrapper around an MDNode which provides a; /// higher-level interface by hiding the details of how alias analysis; /// information is encoded in its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:38,Integrability,wrap,wrapped,38,/// isNewFormat - Return true iff the wrapped access tag is in the new; /// size-aware format.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:46,Security,access,access,46,/// isNewFormat - Return true iff the wrapped access tag is in the new; /// size-aware format.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:4,Testability,Test,Test,4,/// Test if this TBAAStructTagNode represents a type for objects; /// which are not modified (by any means) in the context where this; /// AliasAnalysis is relevant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:29,Integrability,wrap,wrapper,29,/// @}; /// This is a simple wrapper around an MDNode which provides a; /// higher-level interface by hiding the details of how alias analysis; /// information is encoded in its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:89,Integrability,interface,interface,89,/// @}; /// This is a simple wrapper around an MDNode which provides a; /// higher-level interface by hiding the details of how alias analysis; /// information is encoded in its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:22,Usability,simpl,simple,22,/// @}; /// This is a simple wrapper around an MDNode which provides a; /// higher-level interface by hiding the details of how alias analysis; /// information is encoded in its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:38,Integrability,wrap,wrapped,38,/// isNewFormat - Return true iff the wrapped type node is in the new; /// size-aware format.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:80,Deployability,Update,Update,80,/// Get this TBAAStructTypeNode's field in the type DAG with; /// given offset. Update the offset to be relative to the field type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:39,Security,access,access,39,"// If this is an ""immutable"" type, the access is not observable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:42,Security,access,access,42,"// For struct-path aware TBAA, we use the access type of the tag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:18,Security,access,access,18,"// If there is no access type or the access type is the root node, then; // we don't have any useful access tag to return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:37,Security,access,access,37,"// If there is no access type or the access type is the root node, then; // we don't have any useful access tag to return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:101,Security,access,access,101,"// If there is no access type or the access type is the root node, then; // we don't have any useful access tag to return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:14,Security,access,access,14,// TODO: Take access ranges into account when matching access tags and; // fix this code to generate actual access sizes for generic tags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:55,Security,access,access,55,// TODO: Take access ranges into account when matching access tags and; // fix this code to generate actual access sizes for generic tags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:108,Security,access,access,108,// TODO: Take access ranges into account when matching access tags and; // fix this code to generate actual access sizes for generic tags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:33,Security,access,accesses,33,"/// Return true if for two given accesses, one of the accessed objects may be a; /// subobject of the other. The \p BaseTag and \p SubobjectTag parameters; /// describe the accesses to the base object and the subobject respectively.; /// \p CommonType must be the metadata node describing the common type of the; /// accessed objects. On return, \p MayAlias is set to true iff these accesses; /// may alias and \p Generic, if not null, points to the most generic access; /// tag for the given two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:54,Security,access,accessed,54,"/// Return true if for two given accesses, one of the accessed objects may be a; /// subobject of the other. The \p BaseTag and \p SubobjectTag parameters; /// describe the accesses to the base object and the subobject respectively.; /// \p CommonType must be the metadata node describing the common type of the; /// accessed objects. On return, \p MayAlias is set to true iff these accesses; /// may alias and \p Generic, if not null, points to the most generic access; /// tag for the given two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:173,Security,access,accesses,173,"/// Return true if for two given accesses, one of the accessed objects may be a; /// subobject of the other. The \p BaseTag and \p SubobjectTag parameters; /// describe the accesses to the base object and the subobject respectively.; /// \p CommonType must be the metadata node describing the common type of the; /// accessed objects. On return, \p MayAlias is set to true iff these accesses; /// may alias and \p Generic, if not null, points to the most generic access; /// tag for the given two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:317,Security,access,accessed,317,"/// Return true if for two given accesses, one of the accessed objects may be a; /// subobject of the other. The \p BaseTag and \p SubobjectTag parameters; /// describe the accesses to the base object and the subobject respectively.; /// \p CommonType must be the metadata node describing the common type of the; /// accessed objects. On return, \p MayAlias is set to true iff these accesses; /// may alias and \p Generic, if not null, points to the most generic access; /// tag for the given two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:383,Security,access,accesses,383,"/// Return true if for two given accesses, one of the accessed objects may be a; /// subobject of the other. The \p BaseTag and \p SubobjectTag parameters; /// describe the accesses to the base object and the subobject respectively.; /// \p CommonType must be the metadata node describing the common type of the; /// accessed objects. On return, \p MayAlias is set to true iff these accesses; /// may alias and \p Generic, if not null, points to the most generic access; /// tag for the given two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:463,Security,access,access,463,"/// Return true if for two given accesses, one of the accessed objects may be a; /// subobject of the other. The \p BaseTag and \p SubobjectTag parameters; /// describe the accesses to the base object and the subobject respectively.; /// \p CommonType must be the metadata node describing the common type of the; /// accessed objects. On return, \p MayAlias is set to true iff these accesses; /// may alias and \p Generic, if not null, points to the most generic access; /// tag for the given two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:71,Security,access,access,71,"// If the base object is of the least common type, then this may be an access; // to its subobject.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:10,Security,access,access,10,"// If the access to the base object is through a field of the subobject's; // type, then this may be an access to that field. To check for that we start; // from the base type, follow the edge with the correct offset in the type DAG; // and adjust the offset until we reach the field type or until we reach the; // access type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:104,Security,access,access,104,"// If the access to the base object is through a field of the subobject's; // type, then this may be an access to that field. To check for that we start; // from the base type, follow the edge with the correct offset in the type DAG; // and adjust the offset until we reach the field type or until we reach the; // access type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:315,Security,access,access,315,"// If the access to the base object is through a field of the subobject's; // type, then this may be an access to that field. To check for that we start; // from the base type, follow the edge with the correct offset in the type DAG; // and adjust the offset until we reach the field type or until we reach the; // access type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:40,Security,access,access,40,// With new-format nodes we stop at the access type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:102,Security,access,access,102,"// If the base object has a direct or indirect field of the subobject's type,; // then this may be an access to that field. We need this to check now that; // we support aggregates as access types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:184,Security,access,access,184,"// If the base object has a direct or indirect field of the subobject's type,; // then this may be an access to that field. We need this to check now that; // we support aggregates as access types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:51,Security,access,accesses,51,"/// matchTags - Return true if the given couple of accesses are allowed to; /// overlap. If \arg GenericTag is not null, then on return it points to the; /// most generic access descriptor for the given two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:171,Security,access,access,171,"/// matchTags - Return true if the given couple of accesses are allowed to; /// overlap. If \arg GenericTag is not null, then on return it points to the; /// most generic access descriptor for the given two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:3,Security,Access,Accesses,3,// Accesses with no TBAA information may alias with any other accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:62,Security,access,accesses,62,// Accesses with no TBAA information may alias with any other accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:60,Deployability,upgrade,upgrade,60,// Verify that both input nodes are struct-path aware. Auto-upgrade should; // have taken care of this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:16,Security,access,access,16,"// If the final access types have different roots, they're part of different; // potentially unrelated type systems, so we must be conservative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:17,Security,access,accessed,17,"// If one of the accessed objects may be a subobject of the other, then such; // accesses may alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:81,Security,access,accesses,81,"// If one of the accessed objects may be a subobject of the other, then such; // accesses may alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:31,Security,access,access,31,/// Aliases - Test whether the access represented by tag A may alias the; /// access represented by tag B.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:78,Security,access,access,78,/// Aliases - Test whether the access represented by tag A may alias the; /// access represented by tag B.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:14,Testability,Test,Test,14,/// Aliases - Test whether the access represented by tag A may alias the; /// access represented by tag B.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:183,Availability,error,errors,183,"// The correct behavior here is to add the offset into the TBAA; // struct node offset. The base type, however may not have defined; // a type at this additional offset, resulting in errors. Since; // this method is only used within a given load/store access; // the offset provided is only used to subdivide the previous load; // maintaining the validity of the previous TBAA.; //; // This, however, should be revisited in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:241,Performance,load,load,241,"// The correct behavior here is to add the offset into the TBAA; // struct node offset. The base type, however may not have defined; // a type at this additional offset, resulting in errors. Since; // this method is only used within a given load/store access; // the offset provided is only used to subdivide the previous load; // maintaining the validity of the previous TBAA.; //; // This, however, should be revisited in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:322,Performance,load,load,322,"// The correct behavior here is to add the offset into the TBAA; // struct node offset. The base type, however may not have defined; // a type at this additional offset, resulting in errors. Since; // this method is only used within a given load/store access; // the offset provided is only used to subdivide the previous load; // maintaining the validity of the previous TBAA.; //; // This, however, should be revisited in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:252,Security,access,access,252,"// The correct behavior here is to add the offset into the TBAA; // struct node offset. The base type, however may not have defined; // a type at this additional offset, resulting in errors. Since; // this method is only used within a given load/store access; // the offset provided is only used to subdivide the previous load; // maintaining the validity of the previous TBAA.; //; // This, however, should be revisited in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeMetadataUtils.cpp:33,Performance,load,load,33,// Search for virtual calls that load from VPtr and add them to DevirtCalls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeMetadataUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeMetadataUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeMetadataUtils.cpp:50,Testability,test,test,50,// Find llvm.assume intrinsics for this llvm.type.test call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/TypeMetadataUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeMetadataUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueLatticeUtils.cpp:432,Performance,perform,performing,432,"//===-- ValueLatticeUtils.cpp - Utils for solving lattices ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements common functions useful for performing data-flow; // analyses that propagate values across function boundaries.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueLatticeUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueLatticeUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueLatticeUtils.cpp:35,Modifiability,variab,variable,35,"// Currently all users of a global variable have to be non-volatile loads; // or stores of the global type, and the global cannot be stored itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueLatticeUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueLatticeUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueLatticeUtils.cpp:68,Performance,load,loads,68,"// Currently all users of a global variable have to be non-volatile loads; // or stores of the global type, and the global cannot be stored itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueLatticeUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueLatticeUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:402,Integrability,rout,routines,402,"//===- ValueTracking.cpp - Walk computations to compute properties --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains routines that help analyze properties that chains of; // computations have.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:34,Performance,scalab,scalable,34,"// Since the number of lanes in a scalable vector is unknown at compile time,; // we track one bit which is implicitly broadcast to all lanes. This means; // that all lanes in a scalable vector are considered demanded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:178,Performance,scalab,scalable,178,"// Since the number of lanes in a scalable vector is unknown at compile time,; // we track one bit which is implicitly broadcast to all lanes. This means; // that all lanes in a scalable vector are considered demanded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:24,Availability,mask,mask,24,// Look for an inverted mask: (X & ~M) op (Y & M).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:16,Modifiability,extend,extends,16,// Peek through extends to find a 'not' of the other side:; // (ext Y) op ext(~Y),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:23,Integrability,wrap,wrap,23,"// Only make use of no-wrap flags if we failed to compute the sign bit; // directly. This matters if the multiplication always overflows, in; // which case we prefer to follow the result of the direct computation,; // though as the program is invoking undefined behaviour we can choose; // whatever we like here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:177,Testability,test,test,177,// The instruction defining an assumption's condition itself is always; // considered ephemeral to that assumption (even if it has other; // non-ephemeral users). See r246696's test case for an example.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:256,Safety,avoid,avoid,256,"// The context comes first, but they're both in the same block.; // Make sure there is nothing in between that might interrupt; // the control flow, not even CxtI itself.; // We limit the scan distance between the assume and its context instruction; // to avoid a compile-time explosion. This limit is chosen arbitrarily, so; // it can be adjusted if needed (could be turned into a cl::opt).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:48,Performance,perform,performance,48,// Warning: This loop can end up being somewhat performance sensitive.; // We're running this loop for once for each value queried resulting in a; // runtime of ~O(#assumes * #values).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:99,Testability,log,logic,99,"// Handle comparison of pointer to null explicitly, as it will not be; // covered by the m_APInt() logic below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:14,Availability,Mask,Mask,14,// assume(V & Mask = C),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:19,Availability,Mask,Mask,19,"// For one bits in Mask, we can propagate bits from C to V.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:14,Availability,Mask,Mask,14,// assume(V | Mask = C),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:20,Availability,Mask,Mask,20,"// For zero bits in Mask, we can propagate bits from C to V.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:14,Availability,Mask,Mask,14,// assume(V ^ Mask = C),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:29,Availability,Mask,Mask,29,// Equivalent to assume(V == Mask ^ C),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:36,Energy Efficiency,power,power,36,// assume (V & B != 0) where B is a power of 2,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:94,Deployability,update,updateAffectedValues,94,// Note that the patterns below need to be kept in sync with the code; // in AssumptionCache::updateAffectedValues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:48,Performance,perform,performance,48,// Warning: This loop can end up being somewhat performance sensitive.; // We're running this loop for once for each value queried resulting in a; // runtime of ~O(#assumes * #values).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:17,Testability,test,tests,17,"// The remaining tests are all recursive, so bail out if we hit the limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:160,Energy Efficiency,allocate,allocated,160,"/// Compute known bits from a shift operator, including those with a; /// non-constant shift amount. Known is the output of this function. Known2 is a; /// pre-allocated temporary with the same bit width as Known and on return; /// contains the known bit of the shift value source. KF is an; /// operator-specific function that, given the known-bits and a shift amount,; /// compute the implied known-bits of the shift operator's result respectively; /// for that shift amount. The results from calling KF are conservatively; /// combined for all permitted shift amounts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:41,Usability,clear,clear,41,"// and(x, -x) is common idioms that will clear all but lowest set; // bit. If we have a single known bit in x, we can clear all bits; // above it.; // TODO: instcombine often reassociates independent `and` which can hide; // this pattern. Try to match and(x, and(-x, y)) / and(and(x, y), -x).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:118,Usability,clear,clear,118,"// and(x, -x) is common idioms that will clear all but lowest set; // bit. If we have a single known bit in x, we can clear all bits; // above it.; // TODO: instcombine often reassociates independent `and` which can hide; // this pattern. Try to match and(x, and(-x, y)) / and(and(x, y), -x).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:318,Modifiability,Extend,Extend,318,"// xor(x, x-1) is common idioms that will clear all but lowest set; // bit. If we have a single known bit in x, we can clear all bits; // above it.; // TODO: xor(x, x-1) is often rewritting as xor(x, x-C) where C !=; // -1 but for the purpose of demanded bits (xor(x, x-C) &; // Demanded) == (xor(x, x-1) & Demanded). Extend the xor pattern; // to use arbitrary C if xor(x, x-C) as the same as xor(x, x-1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:42,Usability,clear,clear,42,"// xor(x, x-1) is common idioms that will clear all but lowest set; // bit. If we have a single known bit in x, we can clear all bits; // above it.; // TODO: xor(x, x-1) is often rewritting as xor(x, x-C) where C !=; // -1 but for the purpose of demanded bits (xor(x, x-C) &; // Demanded) == (xor(x, x-1) & Demanded). Extend the xor pattern; // to use arbitrary C if xor(x, x-C) as the same as xor(x, x-1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:119,Usability,clear,clear,119,"// xor(x, x-1) is common idioms that will clear all but lowest set; // bit. If we have a single known bit in x, we can clear all bits; // above it.; // TODO: xor(x, x-1) is often rewritting as xor(x, x-C) where C !=; // -1 but for the purpose of demanded bits (xor(x, x-C) &; // Demanded) == (xor(x, x-1) & Demanded). Extend the xor pattern; // to use arbitrary C if xor(x, x-C) as the same as xor(x, x-1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:53,Usability,clear,clears,53,"// and(x, add (x, -1)) is a common idiom that always clears the low bit;; // xor/or(x, add (x, -1)) is an idiom that will always set the low bit.; // here we handle the more general case of adding any odd number by; // matching the form and/xor/or(x, add(x, y)) where y is odd.; // TODO: This could be generalized to clearing any bit set in y where the; // following bit is known to be unset in y.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:317,Usability,clear,clearing,317,"// and(x, add (x, -1)) is a common idiom that always clears the low bit;; // xor/or(x, add (x, -1)) is an idiom that will always set the low bit.; // here we handle the more general case of adding any odd number by; // matching the form and/xor/or(x, add(x, y)) where y is odd.; // TODO: This could be generalized to clearing any bit set in y where the; // following bit is known to be unset in y.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:34,Usability,Simpl,SimplifyDemandedUseBits,34,// Public so this can be used in `SimplifyDemandedUseBits`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:668,Availability,mask,mask,668,"// Known bits are automatically intersected across demanded elements of a; // vector. So for example, if a bit is computed as known zero, it must be; // zero across all demanded elements of the vector.; //; // For this bitcast, each demanded element of the output is sub-divided; // across a set of smaller vector elements in the source vector. To get; // the known bits for an entire element of the output, compute the known; // bits for each sub-element sequentially. This is done by shifting the; // one-set-bit demanded elements parameter across the sub-elements for; // consecutive calls to computeKnownBits. We are using the demanded; // elements parameter as a mask operator.; //; // The known bits of each sub-element are then inserted into place; // (dependent on endian) to form the full result of known bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:760,Integrability,depend,dependent,760,"// Known bits are automatically intersected across demanded elements of a; // vector. So for example, if a bit is computed as known zero, it must be; // zero across all demanded elements of the vector.; //; // For this bitcast, each demanded element of the output is sub-divided; // across a set of smaller vector elements in the source vector. To get; // the known bits for an entire element of the output, compute the known; // bits for each sub-element sequentially. This is done by shifting the; // one-set-bit demanded elements parameter across the sub-elements for; // consecutive calls to computeKnownBits. We are using the demanded; // elements parameter as a mask operator.; //; // The known bits of each sub-element are then inserted into place; // (dependent on endian) to form the full result of known bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:48,Usability,clear,clear,48,"// If the sign bit of the input is known set or clear, then we know the; // top bits of the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:49,Modifiability,variab,variable,49,// Accumulate the constant indices in a separate variable; // to minimize the number of calls to computeForAddSub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:7,Performance,scalab,scalable,7,// For scalable types the only thing we know about sizeof is; // that this is a multiple of the minimum size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:115,Modifiability,extend,extend,115,"// If the offsets have a different width from the pointer, according; // to the language reference we need to sign-extend or truncate them; // to the width of the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:24,Usability,simpl,simple,24,"// Handle the case of a simple two-predecessor recurrence PHI.; // There's a lot more that could theoretically be done here, but; // this is sufficient to catch some interesting cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:157,Safety,avoid,avoid,157,"// We have matched a recurrence of the form:; // %iv = [R, %entry], [%iv.next, %backedge]; // %iv.next = shift_op %iv, L; // Recurse with the phi context to avoid concern about whether facts; // inferred hold at original context instruction. TODO: It may be; // correct to use the original context. IF warranted, explore and; // add sufficient tests to cover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:344,Testability,test,tests,344,"// We have matched a recurrence of the form:; // %iv = [R, %entry], [%iv.next, %backedge]; // %iv.next = shift_op %iv, L; // Recurse with the phi context to avoid concern about whether facts; // inferred hold at original context instruction. TODO: It may be; // correct to use the original context. IF warranted, explore and; // add sufficient tests to cover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:27,Modifiability,extend,extend,27,// An ashr recurrence will extend the initial sign bit,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:100,Safety,avoid,avoid,100,"// Otherwise take the unions of the known bit sets of the operands,; // taking conservative care to avoid excessive recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:11,Modifiability,extend,extend,11,// TODO: 1-extend would be more precise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:54,Performance,scalab,scalable,54,// FIXME: there's probably *something* we can do with scalable vectors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:207,Performance,optimiz,optimize,207,"/// Determine which bits of V are known to be either zero or one and return; /// them in the Known bit set.; ///; /// NOTE: we cannot consider 'undef' to be ""IsZero"" here. The problem is that; /// we cannot optimize based on the assumption that it is zero without changing; /// it to be an explicit zero. If we don't change it to zero, other code could; /// optimized based on the contradictory assumption that it is non-zero.; /// Because instcombine aggressively folds operations with undef args anyway,; /// this won't lose us code quality.; ///; /// This function is defined on values with integer type, values with pointer; /// type, and vectors of integers. In the case; /// where V is a vector, known zero, and known one values are the; /// same width as the vector element, and the bit is set only if it is true; /// for all of the demanded elements in the vector specified by DemandedElts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:358,Performance,optimiz,optimized,358,"/// Determine which bits of V are known to be either zero or one and return; /// them in the Known bit set.; ///; /// NOTE: we cannot consider 'undef' to be ""IsZero"" here. The problem is that; /// we cannot optimize based on the assumption that it is zero without changing; /// it to be an explicit zero. If we don't change it to zero, other code could; /// optimized based on the contradictory assumption that it is non-zero.; /// Because instcombine aggressively folds operations with undef args anyway,; /// this won't lose us code quality.; ///; /// This function is defined on values with integer type, values with pointer; /// type, and vectors of integers. In the case; /// where V is a vector, known zero, and known one values are the; /// same width as the vector element, and the bit is set only if it is true; /// for all of the demanded elements in the vector specified by DemandedElts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:89,Energy Efficiency,power,power,89,/// Try to detect a recurrence that the value of the induction variable is; /// always a power of two (or zero).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:63,Modifiability,variab,variable,63,/// Try to detect a recurrence that the value of the induction variable is; /// always a power of two (or zero).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:11,Safety,detect,detect,11,/// Try to detect a recurrence that the value of the induction variable is; /// always a power of two (or zero).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:27,Energy Efficiency,power,power,27,// Initial value must be a power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:33,Modifiability,variab,variable,33,"// Except for Mul, the induction variable must be on the left side of the; // increment expression, otherwise its value can be arbitrary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:3,Energy Efficiency,Power,Power,3,// Power of two is closed under multiplication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:79,Energy Efficiency,power,power,79,"// Start value must not be signmask for signed division, so simply being a; // power of two is not sufficient, and it has to be a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:60,Usability,simpl,simply,60,"// Start value must not be signmask for signed division, so simply being a; // power of two is not sufficient, and it has to be a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:21,Energy Efficiency,power,power,21,"// Divisor must be a power of two.; // If OrZero is false, cannot guarantee induction variable is non-zero after; // division, same for Shr, unless it is exact division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:86,Modifiability,variab,variable,86,"// Divisor must be a power of two.; // If OrZero is false, cannot guarantee induction variable is non-zero after; // division, same for Shr, unless it is exact division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:154,Energy Efficiency,power,power,154,/// Return true if the given value is known to have exactly one; /// bit set when defined. For vectors return true if every element is known to; /// be a power of two when defined. Supports values with integer or pointer; /// types and vectors of integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:25,Energy Efficiency,power,power,25,// i1 is by definition a power of 2 or zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:42,Energy Efficiency,power,power-of-two,42,// The vscale_range indicates vscale is a power-of-two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:23,Energy Efficiency,power,power,23,// 1 << X is clearly a power of two if the one is not shifted off the end. If; // it is shifted off the end then the result is undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:13,Usability,clear,clearly,13,// 1 << X is clearly a power of two if the one is not shifted off the end. If; // it is shifted off the end then the result is undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:33,Energy Efficiency,power,power,33,// (signmask) >>l X is clearly a power of two if the one is not shifted off; // the bottom. If it is shifted off the bottom then the result is undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:23,Usability,clear,clearly,23,// (signmask) >>l X is clearly a power of two if the one is not shifted off; // the bottom. If it is shifted off the bottom then the result is undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:17,Testability,test,tests,17,"// The remaining tests are all recursive, so bail out if we hit the limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:5,Energy Efficiency,power,power,5,// A power of two and'd with anything is a power of two or zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:43,Energy Efficiency,power,power,43,// A power of two and'd with anything is a power of two or zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:24,Energy Efficiency,power,power,24,// X & (-X) is always a power of two or zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:12,Energy Efficiency,power,power-of-two,12,"// Adding a power-of-two or zero to the same power-of-two or zero yields; // either the original power-of-two, a larger power-of-two or zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:45,Energy Efficiency,power,power-of-two,45,"// Adding a power-of-two or zero to the same power-of-two or zero yields; // either the original power-of-two, a larger power-of-two or zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:97,Energy Efficiency,power,power-of-two,97,"// Adding a power-of-two or zero to the same power-of-two or zero yields; // either the original power-of-two, a larger power-of-two or zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:120,Energy Efficiency,power,power-of-two,120,"// Adding a power-of-two or zero to the same power-of-two or zero yields; // either the original power-of-two, a larger power-of-two or zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:16,Energy Efficiency,power,power,16,// If i8 V is a power of two or zero:; // ZeroBits: 1 1 1 0 1 1 1 1; // ~ZeroBits: 0 0 0 1 0 0 0 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:17,Energy Efficiency,power,power,17,"// A PHI node is power of two if all incoming values are power of two, or if; // it is an induction variable where in each step its value is a power of; // two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:57,Energy Efficiency,power,power,57,"// A PHI node is power of two if all incoming values are power of two, or if; // it is an induction variable where in each step its value is a power of; // two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:143,Energy Efficiency,power,power,143,"// A PHI node is power of two if all incoming values are power of two, or if; // it is an induction variable where in each step its value is a power of; // two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:100,Modifiability,variab,variable,100,"// A PHI node is power of two if all incoming values are power of two, or if; // it is an induction variable where in each step its value is a power of; // two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:51,Energy Efficiency,power,power,51,// Check if it is an induction variable and always power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:31,Modifiability,variab,variable,31,// Check if it is an induction variable and always power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:12,Energy Efficiency,power,power,12,// Value is power of 2 if it is coming from PHI node itself by induction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:187,Integrability,rout,routine,187,/// Test whether a GEP's result is known to be non-null.; ///; /// Uses properties inherent in a GEP to try to determine whether it is known; /// to be non-null.; ///; /// Currently this routine does not support vector GEPs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:4,Testability,Test,Test,4,/// Test whether a GEP's result is known to be non-null.; ///; /// Uses properties inherent in a GEP to try to determine whether it is known; /// to be non-null.; ///; /// Currently this routine does not support vector GEPs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:187,Integrability,contract,contract,187,"// Walk the GEP operands and see if any operand introduces a non-zero offset.; // If so, then the GEP cannot produce a null pointer, as doing so would; // inherently violate the inbounds contract within address space zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:113,Availability,down,down,113,// Fast path the constant operand case both for efficiency and so we don't; // increment Depth when just zipping down an all-constant GEP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:3,Safety,Avoid,Avoid,3,// Avoid massive lists,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:29,Performance,load,load,29,"// If the value is used as a load/store, then the pointer must be non null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:237,Testability,log,logic,237,"// If a user is an AND, add all its users to the work list. We only; // propagate ""pred != null"" condition through AND because it is only; // correct to assume that all conditions of AND are met in true branch.; // TODO: Support similar logic of OR and EQ predicate?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:137,Modifiability,variab,variables,137,/// Try to detect a recurrence that monotonically increases/decreases from a; /// non-zero starting value. These are common as induction variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:11,Safety,detect,detect,11,/// Try to detect a recurrence that monotonically increases/decreases from a; /// non-zero starting value. These are common as induction variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:64,Integrability,wrap,wrap,64,// Starting from non-zero and stepping away from zero can never wrap back; // to zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:42,Energy Efficiency,power,power,42,// The sum of a non-negative number and a power of two is not zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:223,Safety,Unsafe,Unsafe,223,"// We need to be a bit careful here. We can only peek through the bitcast; // if the scalar size of elements in the operand are smaller than and a; // multiple of the size they are casting too. Take three cases:; //; // 1) Unsafe:; // bitcast <2 x i16> %NonZero to <4 x i8>; //; // %NonZero can have 2 non-zero i16 elements, but isKnownNonZero on a; // <4 x i8> requires that all 4 i8 elements be non-zero which isn't; // guranteed (imagine just sign bit set in the 2 i16 elements).; //; // 2) Unsafe:; // bitcast <4 x i3> %NonZero to <3 x i4>; //; // Even though the scalar size of the src (`i3`) is smaller than the; // scalar size of the dst `i4`, because `i3` is not a multiple of `i4`; // its possible for the `3 x i4` elements to be zero because there are; // some elements in the destination that don't contain any full src; // element.; //; // 3) Safe:; // bitcast <4 x i8> %NonZero to <2 x i16>; //; // This is always safe as non-zero in the 4 i8 elements implies; // non-zero in the combination of any two adjacent ones. Since i8 is a; // multiple of i16, each i16 is guranteed to have 2 full i8 elements.; // This all implies the 2 i16 elements are non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:494,Safety,Unsafe,Unsafe,494,"// We need to be a bit careful here. We can only peek through the bitcast; // if the scalar size of elements in the operand are smaller than and a; // multiple of the size they are casting too. Take three cases:; //; // 1) Unsafe:; // bitcast <2 x i16> %NonZero to <4 x i8>; //; // %NonZero can have 2 non-zero i16 elements, but isKnownNonZero on a; // <4 x i8> requires that all 4 i8 elements be non-zero which isn't; // guranteed (imagine just sign bit set in the 2 i16 elements).; //; // 2) Unsafe:; // bitcast <4 x i3> %NonZero to <3 x i4>; //; // Even though the scalar size of the src (`i3`) is smaller than the; // scalar size of the dst `i4`, because `i3` is not a multiple of `i4`; // its possible for the `3 x i4` elements to be zero because there are; // some elements in the destination that don't contain any full src; // element.; //; // 3) Safe:; // bitcast <4 x i8> %NonZero to <2 x i16>; //; // This is always safe as non-zero in the 4 i8 elements implies; // non-zero in the combination of any two adjacent ones. Since i8 is a; // multiple of i16, each i16 is guranteed to have 2 full i8 elements.; // This all implies the 2 i16 elements are non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:855,Safety,Safe,Safe,855,"// We need to be a bit careful here. We can only peek through the bitcast; // if the scalar size of elements in the operand are smaller than and a; // multiple of the size they are casting too. Take three cases:; //; // 1) Unsafe:; // bitcast <2 x i16> %NonZero to <4 x i8>; //; // %NonZero can have 2 non-zero i16 elements, but isKnownNonZero on a; // <4 x i8> requires that all 4 i8 elements be non-zero which isn't; // guranteed (imagine just sign bit set in the 2 i16 elements).; //; // 2) Unsafe:; // bitcast <4 x i3> %NonZero to <3 x i4>; //; // Even though the scalar size of the src (`i3`) is smaller than the; // scalar size of the dst `i4`, because `i3` is not a multiple of `i4`; // its possible for the `3 x i4` elements to be zero because there are; // some elements in the destination that don't contain any full src; // element.; //; // 3) Safe:; // bitcast <4 x i8> %NonZero to <2 x i16>; //; // This is always safe as non-zero in the 4 i8 elements implies; // non-zero in the combination of any two adjacent ones. Since i8 is a; // multiple of i16, each i16 is guranteed to have 2 full i8 elements.; // This all implies the 2 i16 elements are non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:927,Safety,safe,safe,927,"// We need to be a bit careful here. We can only peek through the bitcast; // if the scalar size of elements in the operand are smaller than and a; // multiple of the size they are casting too. Take three cases:; //; // 1) Unsafe:; // bitcast <2 x i16> %NonZero to <4 x i8>; //; // %NonZero can have 2 non-zero i16 elements, but isKnownNonZero on a; // <4 x i8> requires that all 4 i8 elements be non-zero which isn't; // guranteed (imagine just sign bit set in the 2 i16 elements).; //; // 2) Unsafe:; // bitcast <4 x i3> %NonZero to <3 x i4>; //; // Even though the scalar size of the src (`i3`) is smaller than the; // scalar size of the dst `i4`, because `i3` is not a multiple of `i4`; // its possible for the `3 x i4` elements to be zero because there are; // some elements in the destination that don't contain any full src; // element.; //; // 3) Safe:; // bitcast <4 x i8> %NonZero to <2 x i16>; //; // This is always safe as non-zero in the 4 i8 elements implies; // non-zero in the combination of any two adjacent ones. Since i8 is a; // multiple of i16, each i16 is guranteed to have 2 full i8 elements.; // This all implies the 2 i16 elements are non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:45,Safety,avoid,avoid,45,"// Note that we have to take special care to avoid looking through; // truncating casts, e.g., int2ptr/ptr2int with appropriate sizes, as well; // as casts that can alter the value, e.g., AddrSpaceCasts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:95,Modifiability,extend,extend,95,"// Similar to int2ptr above, we can look through ptr2int here if the cast; // is a no-op or an extend and not a truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:29,Integrability,wrap,wrap,29,"// X + Y.; // If Add has nuw wrap flag, then if either X or Y is non-zero the result is; // non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:5,Performance,Load,Load,5,// A Load tagged with nonnull or dereferenceable with null pointer undefined; // is never null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:252,Performance,perform,perform,252,"/// Return true if the given value is known to be non-zero when defined. For; /// vectors, return true if every demanded element is known to be non-zero when; /// defined. For pointers, if the context instruction and dominator tree are; /// specified, perform context-sensitive analysis and return true if the; /// pointer couldn't possibly be null at the specified instruction.; /// Supports values with integer or pointer type and vectors of integers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:32,Testability,test,test,32,// Must be non-zero due to null test above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:12,Modifiability,variab,variable,12,"// A global variable in address space 0 is non null unless extern weak; // or an absolute symbol reference. Other address spaces may have null as a; // valid address for a global, so we can't assume anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:15,Testability,test,tests,15,"// Some of the tests below are recursive, so bail out if we hit the limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:21,Usability,simpl,simplifications,21,// Check for pointer simplifications.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:21,Testability,log,log,21,"// sdiv X, C -> adds log(C) sign bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:13,Testability,log,log,13,// Add floor(log(C)) bits to the numerator bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:28,Testability,Log,Logical,28,// NOT is handled here.; // Logical binary ops preserve the number of sign bits at the worst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:63,Usability,clear,clear,63,"// If the input is known to be positive (the sign bit is known clear),; // the output of the NEG has the same number of sign bits as the; // input.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:226,Modifiability,extend,extended,226,"// Look through extract element. At the moment we keep this simple and; // skip tracking the specific element. But at least we might find; // information valid for all elements of the vector (for example if vector; // is sign extended, shifted, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:60,Usability,simpl,simple,60,"// Look through extract element. At the moment we keep this simple and; // skip tracking the specific element. But at least we might find; // information valid for all elements of the vector (for example if vector; // is sign extended, shifted, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:18,Energy Efficiency,reduce,reduces,18,// Absolute value reduces number of sign bits by at most 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:138,Availability,avail,available,138,// We are going to infer semantics of a library function based on mapping it; // to an LLVM intrinsic. Check that the library function is available from; // this callbase and in this environment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:86,Testability,test,test,86,"/// Deprecated, use computeKnownFPClass instead.; ///; /// If \p SignBitOnly is true, test for a known 0 sign bit rather than a; /// standard ordered compare. e.g. make -0.0 olt 0.0 be true because of the sign; /// bit despite comparing equal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:60,Usability,simpl,simple,60,// Look through extract element. At the moment we keep this simple and skip; // tracking the specific element. But at least we might find information; // valid for all elements of the vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:131,Availability,mask,masks,131,// Compares with fcNone are only exactly equal to fcZero if input denormals; // are not flushed.; // TODO: Handle DAZ by expanding masks to cover subnormal cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:20,Availability,mask,mask,20,// Compute the test mask that would return true for the ordered comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:15,Testability,test,test,15,// Compute the test mask that would return true for the ordered comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:50,Testability,test,test,50,// First see if we can fold in fabs/fneg into the test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:3,Testability,log,log,3,// log(+inf) -> +inf; // log([+-]0.0) -> -inf; // log(-inf) -> nan; // log(-x) -> nan,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:25,Testability,log,log,25,// log(+inf) -> +inf; // log([+-]0.0) -> -inf; // log(-inf) -> nan; // log(-x) -> nan,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:50,Testability,log,log,50,// log(+inf) -> +inf; // log([+-]0.0) -> -inf; // log(-inf) -> nan; // log(-x) -> nan,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:71,Testability,log,log,71,// log(+inf) -> +inf; // log([+-]0.0) -> -inf; // log(-inf) -> nan; // log(-x) -> nan,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:18,Energy Efficiency,power,power,18,"// If we know the power is <= 0, can't introduce inf",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:18,Energy Efficiency,power,power,18,"// If we know the power is >= 0, can't introduce subnormal or zero",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:100,Safety,avoid,avoid,100,"// Otherwise take the unions of the known bit sets of the operands,; // taking conservative care to avoid excessive recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:147,Safety,detect,detect,147,"// Recurse, but cap the recursion to two levels, because we don't want; // to waste time spinning around in loops. We need at least depth 2 to; // detect known sign bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:57,Modifiability,variab,variables,57,"// All byte-wide stores are splatable, even of arbitrary variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate some space to put the new indices in,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:85,Performance,load,load,85,"// Otherwise, we don't know (such as, extracting from a function return value; // or load instruction)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:9,Availability,down,down,9,"// Drill down into the pointer expression V, ignoring any intervening; // casts, and determine the identity of the object it references along; // with the cumulative byte offset into it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:90,Usability,Simpl,Simply,90,// Off/StartIdx is in the unit of bytes. So we need to convert to number of; // elements. Simply bail out if that isn't possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:232,Safety,detect,detecting,232,"// Return an empty Slice for undersized constants to let callers; // transform even undefined library calls into simpler, well-defined; // expressions. This is preferable to making the calls although it; // prevents sanitizers from detecting such calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:216,Security,sanitiz,sanitizers,216,"// Return an empty Slice for undersized constants to let callers; // transform even undefined library calls into simpler, well-defined; // expressions. This is preferable to making the calls although it; // prevents sanitizers from detecting such calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:113,Usability,simpl,simpler,113,"// Return an empty Slice for undersized constants to let callers; // transform even undefined library calls into simpler, well-defined; // expressions. This is preferable to making the calls although it; // prevents sanitizers from detecting such calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:284,Availability,failure,failure,284,"/// Extract bytes from the initializer of the constant array V, which need; /// not be a nul-terminated string. On success, store the bytes in Str and; /// return true. When TrimAtNul is set, Str will contain only the bytes up; /// to but not including the first nul. Return false on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:71,Safety,safe,safe,71,"// Return a nul-terminated string even for an empty Slice. This is; // safe because all existing SimplifyLibcalls callers require string; // arguments and the behavior of the functions they fold is undefined; // otherwise. Folding the calls this way is preferable to making; // the undefined library calls, even though it prevents sanitizers; // from reporting such calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:331,Security,sanitiz,sanitizers,331,"// Return a nul-terminated string even for an empty Slice. This is; // safe because all existing SimplifyLibcalls callers require string; // arguments and the behavior of the functions they fold is undefined; // otherwise. Folding the calls this way is preferable to making; // the undefined library calls, even though it prevents sanitizers; // from reporting such calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:97,Usability,Simpl,SimplifyLibcalls,97,"// Return a nul-terminated string even for an empty Slice. This is; // safe because all existing SimplifyLibcalls callers require string; // arguments and the behavior of the functions they fold is undefined; // otherwise. Folding the calls this way is preferable to making; // the undefined library calls, even though it prevents sanitizers; // from reporting such calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:110,Deployability,integrat,integrate,110,"// These next two are very similar to the above, but also look through PHI; // nodes.; // TODO: See if we can integrate these two together.; /// If we can compute the length of the string pointed to by; /// the specified pointer, return 'len+1'. If we can't, return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:110,Integrability,integrat,integrate,110,"// These next two are very similar to the above, but also look through PHI; // nodes.; // TODO: See if we can integrate these two together.; /// If we can compute the length of the string pointed to by; /// the specified pointer, return 'len+1'. If we can't, return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:107,Safety,safe,safe,107,"// Search for the first nul character. Return a conservative result even; // when there is no nul. This is safe since otherwise the string function; // being folded such as strlen is undefined, and can be preferable to; // making the undefined library call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:361,Performance,load,loads,361,"// The amdgcn_make_buffer_rsrc function does not alter the address of the; // input pointer (and thus preserve null-ness for the purposes of escape; // analysis, which is where the MustPreserveNullness flag comes in to play).; // However, it will not necessarily map ptr addrspace(N) null to ptr; // addrspace(8) null, aka the ""null descriptor"", which has ""all loads return; // 0, all stores are dropped"" semantics. Given the context of this intrinsic; // list, no one should be relying on such a strict interpretation of; // MustPreserveNullness (and, at time of writing, they are not), but we; // document this fact out of an abundance of caution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:23,Performance,load,loaded,23,"// If a new pointer is loaded in the loop, the pointer references a different; // object in every iteration. E.g.:; // for (i); // int *p = a[i];; // ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:14,Integrability,wrap,wrapper,14,/// This is a wrapper around getUnderlyingObjects and adds support for basic; /// ptrtoint+arithmetic+inttoptr sequences.; /// It returns false if unidentified object is found in getUnderlyingObjects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:115,Safety,safe,safety,115,"// If getUnderlyingObjects fails to find an identifiable object,; // getUnderlyingObjectsForCodeGen also fails for safety.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:15,Performance,load,load,15,// Speculative load may create a race that did not exist in the source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:15,Performance,load,load,15,// Speculative load may load data from dirty regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:24,Performance,load,load,24,// Speculative load may load data from dirty regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:8,Safety,safe,safe,8,// It's safe to hoist if the denominator is not 0 or -1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:59,Safety,safe,safe,59,// At this point we know that the denominator is -1. It is safe to hoist as; // long we know that the numerator is not INT_MIN.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:10,Integrability,depend,dependency,10,// Memory dependency possible,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:136,Safety,safe,safe,136,"// 1) Can't reorder two inf-loop calls, even if readonly; // 2) Also can't reorder an inf-loop call below a instruction which isn't; // safe to speculative execute. (Inverse of above)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:188,Usability,simpl,simplicity,188,// It overflows only when both arguments are negative and the true; // product is exactly the minimum negative number.; // E.g. mul i16 with 17 sign bits: 0xff00 * 0xff80 = 0x8000; // For simplicity we just check if at least one side is not negative.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:38,Availability,avail,available,38,// The remaining code needs Add to be available. Early returns if not so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:180,Usability,simpl,simplify,180,"// X - (X % ?); // The remainder of a value can't have greater magnitude than itself,; // so the subtraction can't overflow.; // X - (X -nuw ?); // In the minimal case, this would simplify to ""?"", so there's no subtract; // at all. But if this analysis is used to peek through casts, for example,; // then determining no-overflow may allow other transforms.; // TODO: There are other patterns like this.; // See simplifyICmpWithBinOpOnLHS() for candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:412,Usability,simpl,simplifyICmpWithBinOpOnLHS,412,"// X - (X % ?); // The remainder of a value can't have greater magnitude than itself,; // so the subtraction can't overflow.; // X - (X -nuw ?); // In the minimal case, this would simplify to ""?"", so there's no subtract; // at all. But if this analysis is used to peek through casts, for example,; // then determining no-overflow may allow other transforms.; // TODO: There are other patterns like this.; // See simplifyICmpWithBinOpOnLHS() for candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:180,Usability,simpl,simplify,180,"// X - (X % ?); // The remainder of a value can't have greater magnitude than itself,; // so the subtraction can't overflow.; // X - (X -nsw ?); // In the minimal case, this would simplify to ""?"", so there's no subtract; // at all. But if this analysis is used to peek through casts, for example,; // then determining no-overflow may allow other transforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:49,Integrability,wrap,wrap,49,// Check if all users of the add are provably no-wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:39,Safety,safe,safe,39,"// Can't tell, just return false to be safe",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:268,Energy Efficiency,allocate,allocated,268,"// Strip cast operations from a pointer value.; // Note that stripPointerCastsSameRepresentation can strip off getelementptr; // inbounds with zero offset. To guarantee that the result isn't poison, the; // stripped pointer is checked as it has to be pointing into an allocated; // object or be null `null` to ensure `inbounds` getelement pointers with a; // zero offset could not produce poison.; // It can strip off addrspacecast that do not change bit representation as; // well. We believe that such addrspacecast is equivalent to no-op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:100,Safety,Safe,Safe,100,"// If we can't analyze propagation through this instruction, just skip it; // and transitive users. Safe as false is a conservative result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:40,Testability,test,test,40,"// For CoreCLR, it just involves a type test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:47,Safety,avoid,avoid,47,"// Limit number of instructions we look at, to avoid scanning through large; // blocks. The current limit is chosen arbitrarily.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:176,Modifiability,extend,extended,176,"/// If the input value is the result of a 'not' op, constant integer, or vector; /// splat of a constant integer, return the bitwise-not source value.; /// TODO: This could be extended to handle non-splat vector integer constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:19,Usability,clear,clear,19,// Is the sign bit clear?; // (X >s -1) ? MINVAL : X ==> (X <u MINVAL) ? MINVAL : X ==> UMAX; // (X >s -1) ? X : MINVAL ==> (X <u MINVAL) ? X : MINVAL ==> UMIN,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:121,Usability,simpl,simple,121,"// When given one NaN and one non-NaN input:; // - maxnum/minnum (C99 fmaxf()/fminf()) return the non-NaN input.; // - A simple C99 (a < b ? a : b) construction will return 'b' (as the; // ordered comparison fails), which could be NaN or non-NaN.; // so here we discover exactly what NaN behavior is required/accepted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:14,Safety,unsafe,unsafe,14,// Completely unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:14,Safety,unsafe,unsafe,14,// Completely unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:8,Modifiability,extend,extending,8,"// Sign-extending LHS does not change its sign, so TrueVal/FalseVal can; // match against either LHS or sext(LHS).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:793,Security,access,accessed,793,"/// Helps to match a select pattern in case of a type mismatch.; ///; /// The function processes the case when type of true and false values of a; /// select instruction differs from type of the cmp instruction operands because; /// of a cast instruction. The function checks if it is legal to move the cast; /// operation after ""select"". If yes, it returns the new second value of; /// ""select"" (with the assumption that cast is moved):; /// 1. As operand of cast instruction when both values of ""select"" are same cast; /// instructions.; /// 2. As restored constant (by applying reverse cast operation) when the first; /// value of the ""select"" is a cast operation and the second value is a; /// constant.; /// NOTE: We return only the new second value because the first value could be; /// accessed as operand of cast instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:353,Modifiability,extend,extended,353,"// Here we have the following case:; //; // %cond = cmp iN %x, CmpConst; // %tr = trunc iN %x to iK; // %narrowsel = select i1 %cond, iK %t, iK C; //; // We can always move trunc after select operation:; //; // %cond = cmp iN %x, CmpConst; // %widesel = select i1 %cond, iN %x, iN CmpConst; // %tr = trunc iN %widesel to iK; //; // Note that C could be extended in any way because we don't care about; // upper bits after truncation. It can't be abs pattern, because it would; // look like:; //; // select i1 %cond, x, -x.; //; // So only min/max pattern could be matched. Such match requires widened C; // == CmpConst. That is why set widened C = CmpConst, condition trunc; // CmpConst == C is checked below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:24,Usability,simpl,simple,24,"// Handle the case of a simple two-predecessor recurrence PHI.; // There's a lot more that could theoretically be done here, but; // this is sufficient to catch some interesting cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:19,Testability,log,logic,19,"// The rest of the logic assumes the LHS condition is true. If that's not the; // case, invert the predicate to make it so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:105,Usability,Simpl,SimplifyQuery,105,"// TODO: This is a poor/cheap way to determine dominance. Should we use a; // dominator tree (eg, from a SimplifyQuery) instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:25,Usability,simpl,simplified,25,// The branch should get simplified. Don't bother simplifying this condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:50,Usability,simpl,simplifying,50,// The branch should get simplified. Don't bother simplifying this condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:100,Integrability,wrap,wraps,100,"// If the caller expects a signed compare, then try to use a signed range.; // Otherwise if both no-wraps are set, use the unsigned range because it; // is never larger than the signed range. Example:; // ""add nuw nsw i8 X, -2"" is unsigned [254,255] vs. signed [-128, 125].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:15,Energy Efficiency,power,power,15,// X & -X is a power of two or zero. So we can cap the value at max power of; // two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:68,Energy Efficiency,power,power,68,// X & -X is a power of two or zero. So we can cap the value at max power of; // two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:18,Usability,clear,clear,18,// Maximum of set/clear bits is the bit width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:45,Security,access,access,45,/// Maximum factor for an interleaved memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:58,Security,access,access,58,"// For fixed-length vector, return undef for out of range access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:29,Modifiability,variab,variable,29,"// If this is an insert to a variable element, we don't know what it is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:30,Availability,mask,mask,30,// Ignore invalid (undefined) mask elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:36,Availability,mask,mask,36,// There can be only 1 non-negative mask element value if this is a splat.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:54,Availability,mask,mask,54,// Initialize the splat index to the 1st non-negative mask element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:94,Availability,mask,mask,94,"// FIXME: We can safely allow undefs here. If Index was specified, we will; // check that the mask elt is defined at the required index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:17,Safety,safe,safely,17,"// FIXME: We can safely allow undefs here. If Index was specified, we will; // check that the mask elt is defined at the required index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:33,Availability,mask,mask,33,// Match a specific element. The mask should be defined at and match the; // specified index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:17,Testability,test,tests,17,"// The remaining tests are all recursive, so bail out if we hit the limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:3,Usability,Simpl,Simple,3,// Simple case of a shuffle with zeroinitializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:37,Availability,down,down,37,// We must map the original elements down evenly to a type with less elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:26,Availability,mask,mask,26,// Step through the input mask by splitting into Scale-sized slices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:14,Availability,mask,mask,14,// A positive mask element must be cleanly divisible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:32,Availability,mask,mask,32,// All elements of the original mask can be scaled down to map to the elements; // of a mask with wider elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:51,Availability,down,down,51,// All elements of the original mask can be scaled down to map to the elements; // of a mask with wider elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:88,Availability,mask,mask,88,// All elements of the original mask can be scaled down to map to the elements; // of a mask with wider elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:135,Availability,mask,mask,135,// Try to perform better estimation of the permutation.; // 1. Split the source/destination vectors into real registers.; // 2. Do the mask analysis to identify which real registers are; // permuted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:10,Performance,perform,perform,10,// Try to perform better estimation of the permutation.; // 1. Split the source/destination vectors into real registers.; // 2. Do the mask analysis to identify which real registers are; // permuted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:17,Availability,mask,mask,17,// Process split mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:17,Availability,mask,mask,17,// Find the only mask with at least single undef mask elem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:49,Availability,mask,mask,49,// Find the only mask with at least single undef mask elem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:13,Availability,mask,mask,13,"// The first mask is a permutation of a single register. Since we have >2; // input registers to shuffle, we merge the masks for 2 first registers; // and generate a shuffle of 2 registers rather than the reordering of the; // first register and then shuffle with the second register. Next,; // generate the shuffles of the resulting register + the remaining; // registers from the list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:119,Availability,mask,masks,119,"// The first mask is a permutation of a single register. Since we have >2; // input registers to shuffle, we merge the masks for 2 first registers; // and generate a shuffle of 2 registers rather than the reordering of the; // first register and then shuffle with the second register. Next,; // generate the shuffles of the resulting register + the remaining; // registers from the list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:49,Performance,load,loaded,49,"// Don't make work for ourselves. If we know the loaded type is legal,; // don't add it to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:10,Performance,load,loads,10,"// Casts, loads and instructions outside of our range terminate a chain; // successfully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:3,Safety,Unsafe,Unsafe,3,"// Unsafe casts terminate a chain unsuccessfully. We can't do anything; // useful with bitcasts, ptrtoints or inttoptrs and it'd be unsafe to; // transform anything that relies on them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:132,Safety,unsafe,unsafe,132,"// Unsafe casts terminate a chain unsuccessfully. We can't do anything; // useful with bitcasts, ptrtoints or inttoptrs and it'd be unsafe to; // transform anything that relies on them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:118,Performance,optimiz,optimize,118,"// Now we've discovered all values, walk them to see if there are; // any users we didn't see. If there are, we can't optimize that; // chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:17,Energy Efficiency,power,power,17,// Round up to a power of 2,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:75,Performance,perform,performed,75,// If any of M's operands demand more bits than MinBW then M cannot be; // performed safely in MinBW.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:85,Safety,safe,safely,85,// If any of M's operands demand more bits than MinBW then M cannot be; // performed safely in MinBW.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:12,Security,access,access,12,/// Add all access groups in @p AccGroups to @p List.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:16,Security,access,access,16,// Interpret an access group as a list containing itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:15,Performance,scalab,scalable,15,// Use set for scalable 'contains' check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:17,Availability,mask,mask,17,// All 1's means mask is not needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:26,Security,access,access,26,// TODO: support reversed access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:3,Safety,Avoid,Avoid,3,// Avoid casts in the loop and make sure we have a reasonable number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:10,Availability,mask,mask,10,"// If the mask chooses an element from operand 1, reduce it to choose from the; // corresponding element of operand 0. Undef mask elements are unchanged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:125,Availability,mask,mask,125,"// If the mask chooses an element from operand 1, reduce it to choose from the; // corresponding element of operand 0. Undef mask elements are unchanged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:50,Energy Efficiency,reduce,reduce,50,"// If the mask chooses an element from operand 1, reduce it to choose from the; // corresponding element of operand 0. Undef mask elements are unchanged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:3,Modifiability,Extend,Extend,3,// Extend with UNDEFs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:31,Performance,load,load,31,"// Since it's desired that the load/store instructions be maintained in; // ""program order"" for the interleaved access analysis, we have to visit the; // blocks in the loop in reverse postorder (i.e., in a topological order).; // Such an ordering will ensure that any load/store that may be executed; // before a second load/store will precede the second load/store in; // AccessStrideInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:268,Performance,load,load,268,"// Since it's desired that the load/store instructions be maintained in; // ""program order"" for the interleaved access analysis, we have to visit the; // blocks in the loop in reverse postorder (i.e., in a topological order).; // Such an ordering will ensure that any load/store that may be executed; // before a second load/store will precede the second load/store in; // AccessStrideInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:320,Performance,load,load,320,"// Since it's desired that the load/store instructions be maintained in; // ""program order"" for the interleaved access analysis, we have to visit the; // blocks in the loop in reverse postorder (i.e., in a topological order).; // Such an ordering will ensure that any load/store that may be executed; // before a second load/store will precede the second load/store in; // AccessStrideInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:355,Performance,load,load,355,"// Since it's desired that the load/store instructions be maintained in; // ""program order"" for the interleaved access analysis, we have to visit the; // blocks in the loop in reverse postorder (i.e., in a topological order).; // Such an ordering will ensure that any load/store that may be executed; // before a second load/store will precede the second load/store in; // AccessStrideInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:112,Security,access,access,112,"// Since it's desired that the load/store instructions be maintained in; // ""program order"" for the interleaved access analysis, we have to visit the; // blocks in the loop in reverse postorder (i.e., in a topological order).; // Such an ordering will ensure that any load/store that may be executed; // before a second load/store will precede the second load/store in; // AccessStrideInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:373,Security,Access,AccessStrideInfo,373,"// Since it's desired that the load/store instructions be maintained in; // ""program order"" for the interleaved access analysis, we have to visit the; // blocks in the loop in reverse postorder (i.e., in a topological order).; // Such an ordering will ensure that any load/store that may be executed; // before a second load/store will precede the second load/store in; // AccessStrideInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:18,Integrability,wrap,wrapping,18,"// We don't check wrapping here because we don't know yet if Ptr will be; // part of a full group or a group with gaps. Checking wrapping for all; // pointers (even those that end up in groups with no gaps) will be overly; // conservative. For full groups, wrapping should be ok since if we would; // wrap around the address space we would do a memory access at nullptr; // even without the transformation. The wrapping checks are therefore; // deferred until after we've formed the interleaved groups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:129,Integrability,wrap,wrapping,129,"// We don't check wrapping here because we don't know yet if Ptr will be; // part of a full group or a group with gaps. Checking wrapping for all; // pointers (even those that end up in groups with no gaps) will be overly; // conservative. For full groups, wrapping should be ok since if we would; // wrap around the address space we would do a memory access at nullptr; // even without the transformation. The wrapping checks are therefore; // deferred until after we've formed the interleaved groups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:257,Integrability,wrap,wrapping,257,"// We don't check wrapping here because we don't know yet if Ptr will be; // part of a full group or a group with gaps. Checking wrapping for all; // pointers (even those that end up in groups with no gaps) will be overly; // conservative. For full groups, wrapping should be ok since if we would; // wrap around the address space we would do a memory access at nullptr; // even without the transformation. The wrapping checks are therefore; // deferred until after we've formed the interleaved groups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:301,Integrability,wrap,wrap,301,"// We don't check wrapping here because we don't know yet if Ptr will be; // part of a full group or a group with gaps. Checking wrapping for all; // pointers (even those that end up in groups with no gaps) will be overly; // conservative. For full groups, wrapping should be ok since if we would; // wrap around the address space we would do a memory access at nullptr; // even without the transformation. The wrapping checks are therefore; // deferred until after we've formed the interleaved groups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:411,Integrability,wrap,wrapping,411,"// We don't check wrapping here because we don't know yet if Ptr will be; // part of a full group or a group with gaps. Checking wrapping for all; // pointers (even those that end up in groups with no gaps) will be overly; // conservative. For full groups, wrapping should be ok since if we would; // wrap around the address space we would do a memory access at nullptr; // even without the transformation. The wrapping checks are therefore; // deferred until after we've formed the interleaved groups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:352,Security,access,access,352,"// We don't check wrapping here because we don't know yet if Ptr will be; // part of a full group or a group with gaps. Checking wrapping for all; // pointers (even those that end up in groups with no gaps) will be overly; // conservative. For full groups, wrapping should be ok since if we would; // wrap around the address space we would do a memory access at nullptr; // even without the transformation. The wrapping checks are therefore; // deferred until after we've formed the interleaved groups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:455,Integrability,depend,dependences,455,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:582,Integrability,depend,dependences,582,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:621,Integrability,depend,dependence,621,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:866,Integrability,depend,dependences,866,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:1329,Integrability,depend,dependences,1329,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:1368,Integrability,depend,dependence,1368,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:1564,Integrability,depend,dependent,1564,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:1721,Integrability,depend,dependences,1721,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:66,Performance,load,load,66,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:141,Performance,load,load,141,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:182,Performance,load,loads,182,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:230,Performance,load,load,230,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:409,Performance,load,load,409,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:746,Performance,load,load,746,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:23,Security,access,accesses,23,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:991,Security,access,accesses,991,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:1155,Security,access,accesses,1155,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:1193,Security,access,accesses,1193,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:1618,Security,access,accesses,1618,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:1236,Usability,simpl,simplify,1236,"// Analyze interleaved accesses and collect them into interleaved load and; // store groups.; //; // When generating code for an interleaved load group, we effectively hoist all; // loads in the group to the location of the first load in program order. When; // generating code for an interleaved store group, we sink all stores to the; // location of the last store. This code motion can change the order of load; // and store instructions and may break dependences.; //; // The code generation strategy mentioned above ensures that we won't violate; // any write-after-read (WAR) dependences.; //; // E.g., for the WAR dependence: a = A[i]; // (1); // A[i] = b; // (2); //; // The store group of (2) is always inserted at or below (2), and the load; // group of (1) is always inserted at or above (1). Thus, the instructions will; // never be reordered. All other dependences are checked to ensure the; // correctness of the instruction reordering.; //; // The algorithm visits all memory accesses in the loop in bottom-up program; // order. Program order is established by traversing the blocks in the loop in; // reverse postorder when collecting the accesses.; //; // We visit the memory accesses in bottom-up order because it can simplify the; // construction of store groups in the presence of write-after-write (WAW); // dependences.; //; // E.g., for the WAW dependence: A[i] = a; // (1); // A[i] = b; // (2); // A[i + 1] = c; // (3); //; // We will first create a store group with (3) and (2). (1) can't be added to; // this group because it and (2) are dependent. However, (1) can be grouped; // with other accesses that may precede it in program order. Note that a; // bottom-up order does not imply that WAW dependences should not be checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:13,Security,access,accesses,13,// Holds all accesses with a constant stride.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:15,Integrability,depend,dependences,15,// Collect the dependences in the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:25,Performance,load,load,25,// Holds all interleaved load groups temporarily.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:578,Integrability,depend,dependences,578,"// Search in bottom-up program order for pairs of accesses (A and B) that can; // form interleaved load or store groups. In the algorithm below, access A; // precedes access B in program order. We initialize a group for B in the; // outer loop of the algorithm, and then in the inner loop, we attempt to; // insert each A into B's group if:; //; // 1. A and B have the same stride,; // 2. A and B have the same memory object size, and; // 3. A belongs in B's group according to its distance from B.; //; // Special care is taken to ensure group formation will not break any; // dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:99,Performance,load,load,99,"// Search in bottom-up program order for pairs of accesses (A and B) that can; // form interleaved load or store groups. In the algorithm below, access A; // precedes access B in program order. We initialize a group for B in the; // outer loop of the algorithm, and then in the inner loop, we attempt to; // insert each A into B's group if:; //; // 1. A and B have the same stride,; // 2. A and B have the same memory object size, and; // 3. A belongs in B's group according to its distance from B.; //; // Special care is taken to ensure group formation will not break any; // dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:50,Security,access,accesses,50,"// Search in bottom-up program order for pairs of accesses (A and B) that can; // form interleaved load or store groups. In the algorithm below, access A; // precedes access B in program order. We initialize a group for B in the; // outer loop of the algorithm, and then in the inner loop, we attempt to; // insert each A into B's group if:; //; // 1. A and B have the same stride,; // 2. A and B have the same memory object size, and; // 3. A belongs in B's group according to its distance from B.; //; // Special care is taken to ensure group formation will not break any; // dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:145,Security,access,access,145,"// Search in bottom-up program order for pairs of accesses (A and B) that can; // form interleaved load or store groups. In the algorithm below, access A; // precedes access B in program order. We initialize a group for B in the; // outer loop of the algorithm, and then in the inner loop, we attempt to; // insert each A into B's group if:; //; // 1. A and B have the same stride,; // 2. A and B have the same memory object size, and; // 3. A belongs in B's group according to its distance from B.; //; // Special care is taken to ensure group formation will not break any; // dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:167,Security,access,access,167,"// Search in bottom-up program order for pairs of accesses (A and B) that can; // form interleaved load or store groups. In the algorithm below, access A; // precedes access B in program order. We initialize a group for B in the; // outer loop of the algorithm, and then in the inner loop, we attempt to; // insert each A into B's group if:; //; // 1. A and B have the same stride,; // 2. A and B have the same memory object size, and; // 3. A belongs in B's group according to its distance from B.; //; // Special care is taken to ensure group formation will not break any; // dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:183,Integrability,depend,dependences,183,"// Initialize a group for B if it has an allowable stride. Even if we don't; // create a group for B, we continue with the bottom-up algorithm to ensure; // we don't break any of B's dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:55,Integrability,depend,dependences,55,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:322,Integrability,depend,dependences,322,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:455,Integrability,depend,dependent,455,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:753,Integrability,depend,dependent,753,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:827,Integrability,depend,dependent,827,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:387,Modifiability,extend,extend,387,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:79,Security,access,accesses,79,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:122,Security,access,accesses,122,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:293,Security,access,accesses,293,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:345,Security,access,accesses,345,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:465,Security,access,accesses,465,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:527,Security,access,accesses,527,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:728,Security,access,accesses,728,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:837,Security,access,access,837,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:36,Availability,toler,tolerable,36,"// If A is a load, dependencies are tolerable, there's nothing to do here.; // If both A and B belong to the same (store) group, they are independent,; // even if dependencies have not been recorded.; // If both GroupA and GroupB are null, there's nothing to do here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:19,Integrability,depend,dependencies,19,"// If A is a load, dependencies are tolerable, there's nothing to do here.; // If both A and B belong to the same (store) group, they are independent,; // even if dependencies have not been recorded.; // If both GroupA and GroupB are null, there's nothing to do here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:163,Integrability,depend,dependencies,163,"// If A is a load, dependencies are tolerable, there's nothing to do here.; // If both A and B belong to the same (store) group, they are independent,; // even if dependencies have not been recorded.; // If both GroupA and GroupB are null, there's nothing to do here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:13,Performance,load,load,13,"// If A is a load, dependencies are tolerable, there's nothing to do here.; // If both A and B belong to the same (store) group, they are independent,; // even if dependencies have not been recorded.; // If both GroupA and GroupB are null, there's nothing to do here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:192,Deployability,release,release,192,"// If GroupB is a load group, we have to compare AI against all; // members of GroupB because if any load within GroupB has a dependency; // on AI, we need to mark GroupB as complete and also release the; // store GroupA (if A belongs to one). The former prevents incorrect; // hoisting of load B above store A while the latter prevents incorrect; // sinking of store A below load B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:126,Integrability,depend,dependency,126,"// If GroupB is a load group, we have to compare AI against all; // members of GroupB because if any load within GroupB has a dependency; // on AI, we need to mark GroupB as complete and also release the; // store GroupA (if A belongs to one). The former prevents incorrect; // hoisting of load B above store A while the latter prevents incorrect; // sinking of store A below load B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:18,Performance,load,load,18,"// If GroupB is a load group, we have to compare AI against all; // members of GroupB because if any load within GroupB has a dependency; // on AI, we need to mark GroupB as complete and also release the; // store GroupA (if A belongs to one). The former prevents incorrect; // hoisting of load B above store A while the latter prevents incorrect; // sinking of store A below load B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:101,Performance,load,load,101,"// If GroupB is a load group, we have to compare AI against all; // members of GroupB because if any load within GroupB has a dependency; // on AI, we need to mark GroupB as complete and also release the; // store GroupA (if A belongs to one). The former prevents incorrect; // hoisting of load B above store A while the latter prevents incorrect; // sinking of store A below load B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:290,Performance,load,load,290,"// If GroupB is a load group, we have to compare AI against all; // members of GroupB because if any load within GroupB has a dependency; // on AI, we need to mark GroupB as complete and also release the; // store GroupA (if A belongs to one). The former prevents incorrect; // hoisting of load B above store A while the latter prevents incorrect; // sinking of store A below load B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:376,Performance,load,load,376,"// If GroupB is a load group, we have to compare AI against all; // members of GroupB because if any load within GroupB has a dependency; // on AI, we need to mark GroupB as complete and also release the; // store GroupA (if A belongs to one). The former prevents incorrect; // hoisting of load B above store A while the latter prevents incorrect; // sinking of store A below load B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:99,Deployability,Release,Release,99,// A has a store dependence on B (or on some load within GroupB) and; // is part of a store group. Release A's group to prevent illegal; // sinking of A below B. A will then be free to form another group; // with instructions that precede it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:17,Integrability,depend,dependence,17,// A has a store dependence on B (or on some load within GroupB) and; // is part of a store group. Release A's group to prevent illegal; // sinking of A below B. A will then be free to form another group; // with instructions that precede it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:45,Performance,load,load,45,// A has a store dependence on B (or on some load within GroupB) and; // is part of a store group. Release A's group to prevent illegal; // sinking of A below B. A will then be free to form another group; // with instructions that precede it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:142,Integrability,Depend,DependentInst,142,"// If B is a load and part of an interleave group, no earlier loads; // can be added to B's interleave group, because this would mean the; // DependentInst would move across store A. Mark the interleave group; // as complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:13,Performance,load,load,13,"// If B is a load and part of an interleave group, no earlier loads; // can be added to B's interleave group, because this would mean the; // DependentInst would move across store A. Mark the interleave group; // as complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:62,Performance,load,loads,62,"// If B is a load and part of an interleave group, no earlier loads; // can be added to B's interleave group, because this would mean the; // DependentInst would move across store A. Mark the interleave group; // as complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:93,Deployability,release,released,93,"// Skip trying to add A to B, continue to look for other conflicting A's; // in groups to be released.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:197,Performance,load,loads,197,"// Ignore A if it's already in a group or isn't the same kind of memory; // operation as B.; // Note that mayReadFromMemory() isn't mutually exclusive to; // mayWriteToMemory in the case of atomic loads. We shouldn't see those; // here, canVectorizeMemory() should have returned false - except for the; // case we asked for optimization remarks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:324,Performance,optimiz,optimization,324,"// Ignore A if it's already in a group or isn't the same kind of memory; // operation as B.; // Note that mayReadFromMemory() isn't mutually exclusive to; // mayWriteToMemory in the case of atomic loads. We shouldn't see those; // here, canVectorizeMemory() should have returned false - except for the; // case we asked for optimization remarks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:17,Performance,load,load,17,// Set the first load in program order as the insert position.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:20,Security,access,accesses,20,// Iteration over A accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:20,Security,access,accesses,20,// Iteration over B accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:69,Integrability,wrap,wrap,69,"// Remove interleaved groups with gaps whose memory; // accesses may wrap around. We have to revisit the getPtrStride analysis,; // this time with ShouldCheckWrap=true, since collectConstStrideAccesses does; // not check wrapping (see documentation there).; // FORNOW we use Assume=false;; // TODO: Change to Assume=true but making sure we don't exceed the threshold; // of runtime SCEV assumptions checks (thereby potentially failing to; // vectorize altogether).; // Additional optional optimizations:; // TODO: If we are peeling the loop and we know that the first pointer doesn't; // wrap then we can deduce that all pointers in the group don't wrap.; // This means that we can forcefully peel the loop in order to only have to; // check the first pointer for no-wrap. When we'll change to use Assume=true; // we'll only need at most one runtime check per interleaved group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:221,Integrability,wrap,wrapping,221,"// Remove interleaved groups with gaps whose memory; // accesses may wrap around. We have to revisit the getPtrStride analysis,; // this time with ShouldCheckWrap=true, since collectConstStrideAccesses does; // not check wrapping (see documentation there).; // FORNOW we use Assume=false;; // TODO: Change to Assume=true but making sure we don't exceed the threshold; // of runtime SCEV assumptions checks (thereby potentially failing to; // vectorize altogether).; // Additional optional optimizations:; // TODO: If we are peeling the loop and we know that the first pointer doesn't; // wrap then we can deduce that all pointers in the group don't wrap.; // This means that we can forcefully peel the loop in order to only have to; // check the first pointer for no-wrap. When we'll change to use Assume=true; // we'll only need at most one runtime check per interleaved group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:588,Integrability,wrap,wrap,588,"// Remove interleaved groups with gaps whose memory; // accesses may wrap around. We have to revisit the getPtrStride analysis,; // this time with ShouldCheckWrap=true, since collectConstStrideAccesses does; // not check wrapping (see documentation there).; // FORNOW we use Assume=false;; // TODO: Change to Assume=true but making sure we don't exceed the threshold; // of runtime SCEV assumptions checks (thereby potentially failing to; // vectorize altogether).; // Additional optional optimizations:; // TODO: If we are peeling the loop and we know that the first pointer doesn't; // wrap then we can deduce that all pointers in the group don't wrap.; // This means that we can forcefully peel the loop in order to only have to; // check the first pointer for no-wrap. When we'll change to use Assume=true; // we'll only need at most one runtime check per interleaved group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:649,Integrability,wrap,wrap,649,"// Remove interleaved groups with gaps whose memory; // accesses may wrap around. We have to revisit the getPtrStride analysis,; // this time with ShouldCheckWrap=true, since collectConstStrideAccesses does; // not check wrapping (see documentation there).; // FORNOW we use Assume=false;; // TODO: Change to Assume=true but making sure we don't exceed the threshold; // of runtime SCEV assumptions checks (thereby potentially failing to; // vectorize altogether).; // Additional optional optimizations:; // TODO: If we are peeling the loop and we know that the first pointer doesn't; // wrap then we can deduce that all pointers in the group don't wrap.; // This means that we can forcefully peel the loop in order to only have to; // check the first pointer for no-wrap. When we'll change to use Assume=true; // we'll only need at most one runtime check per interleaved group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:767,Integrability,wrap,wrap,767,"// Remove interleaved groups with gaps whose memory; // accesses may wrap around. We have to revisit the getPtrStride analysis,; // this time with ShouldCheckWrap=true, since collectConstStrideAccesses does; // not check wrapping (see documentation there).; // FORNOW we use Assume=false;; // TODO: Change to Assume=true but making sure we don't exceed the threshold; // of runtime SCEV assumptions checks (thereby potentially failing to; // vectorize altogether).; // Additional optional optimizations:; // TODO: If we are peeling the loop and we know that the first pointer doesn't; // wrap then we can deduce that all pointers in the group don't wrap.; // This means that we can forcefully peel the loop in order to only have to; // check the first pointer for no-wrap. When we'll change to use Assume=true; // we'll only need at most one runtime check per interleaved group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:489,Performance,optimiz,optimizations,489,"// Remove interleaved groups with gaps whose memory; // accesses may wrap around. We have to revisit the getPtrStride analysis,; // this time with ShouldCheckWrap=true, since collectConstStrideAccesses does; // not check wrapping (see documentation there).; // FORNOW we use Assume=false;; // TODO: Change to Assume=true but making sure we don't exceed the threshold; // of runtime SCEV assumptions checks (thereby potentially failing to; // vectorize altogether).; // Additional optional optimizations:; // TODO: If we are peeling the loop and we know that the first pointer doesn't; // wrap then we can deduce that all pointers in the group don't wrap.; // This means that we can forcefully peel the loop in order to only have to; // check the first pointer for no-wrap. When we'll change to use Assume=true; // we'll only need at most one runtime check per interleaved group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:56,Security,access,accesses,56,"// Remove interleaved groups with gaps whose memory; // accesses may wrap around. We have to revisit the getPtrStride analysis,; // this time with ShouldCheckWrap=true, since collectConstStrideAccesses does; // not check wrapping (see documentation there).; // FORNOW we use Assume=false;; // TODO: Change to Assume=true but making sure we don't exceed the threshold; // of runtime SCEV assumptions checks (thereby potentially failing to; // vectorize altogether).; // Additional optional optimizations:; // TODO: If we are peeling the loop and we know that the first pointer doesn't; // wrap then we can deduce that all pointers in the group don't wrap.; // This means that we can forcefully peel the loop in order to only have to; // check the first pointer for no-wrap. When we'll change to use Assume=true; // we'll only need at most one runtime check per interleaved group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:90,Integrability,wrap,wrap,90,"// Case 1: A full group. Can Skip the checks; For full groups, if the wide; // load would wrap around the address space we would do a memory access at; // nullptr even without the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:79,Performance,load,load,79,"// Case 1: A full group. Can Skip the checks; For full groups, if the wide; // load would wrap around the address space we would do a memory access at; // nullptr even without the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:141,Security,access,access,141,"// Case 1: A full group. Can Skip the checks; For full groups, if the wide; // load would wrap around the address space we would do a memory access at; // nullptr even without the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:56,Integrability,wrap,wrap,56,"// Case 2: If first and last members of the group don't wrap this implies; // that all the pointers in the group don't wrap.; // So we check only group member 0 (which is always guaranteed to exist),; // and group member Factor - 1; If the latter doesn't exist we rely on; // peeling (if it is a non-reversed accsess -- see Case 3).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:119,Integrability,wrap,wrap,119,"// Case 2: If first and last members of the group don't wrap this implies; // that all the pointers in the group don't wrap.; // So we check only group member 0 (which is always guaranteed to exist),; // and group member Factor - 1; If the latter doesn't exist we rely on; // peeling (if it is a non-reversed accsess -- see Case 3).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:38,Performance,load,load,38,"// Case 3: A non-reversed interleaved load group with gaps: We need; // to execute at least one scalar epilogue iteration. This will ensure; // we don't speculatively access memory out-of-bounds. We only need; // to look for a member at index factor - 1, since every group must have; // a member at index zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:167,Security,access,access,167,"// Case 3: A non-reversed interleaved load group with gaps: We need; // to execute at least one scalar epilogue iteration. This will ensure; // we don't speculatively access memory out-of-bounds. We only need; // to look for a member at index factor - 1, since every group must have; // a member at index zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:91,Integrability,wrap,wrap,91,"// Case 1: A full group. Can Skip the checks; For full groups, if the wide; // store would wrap around the address space we would do a memory access at; // nullptr even without the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:142,Security,access,access,142,"// Case 1: A full group. Can Skip the checks; For full groups, if the wide; // store would wrap around the address space we would do a memory access at; // nullptr even without the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:57,Availability,mask,masked,57,// Interleave-store-group with gaps is implemented using masked wide store.; // Remove interleaved store groups with gaps if; // masked-interleaved-accesses are not enabled by the target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:129,Availability,mask,masked-interleaved-accesses,129,// Interleave-store-group with gaps is implemented using masked wide store.; // Remove interleaved store groups with gaps if; // masked-interleaved-accesses are not enabled by the target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:148,Security,access,accesses,148,// Interleave-store-group with gaps is implemented using masked wide store.; // Remove interleaved store groups with gaps if; // masked-interleaved-accesses are not enabled by the target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:323,Availability,mask,masked-store,323,"// Case 2: If first and last members of the group don't wrap this implies; // that all the pointers in the group don't wrap.; // So we check only group member 0 (which is always guaranteed to exist),; // and the last group member. Case 3 (scalar epilog) is not relevant for; // stores with gaps, which are implemented with masked-store (rather than; // speculative access, as in loads).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:56,Integrability,wrap,wrap,56,"// Case 2: If first and last members of the group don't wrap this implies; // that all the pointers in the group don't wrap.; // So we check only group member 0 (which is always guaranteed to exist),; // and the last group member. Case 3 (scalar epilog) is not relevant for; // stores with gaps, which are implemented with masked-store (rather than; // speculative access, as in loads).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:119,Integrability,wrap,wrap,119,"// Case 2: If first and last members of the group don't wrap this implies; // that all the pointers in the group don't wrap.; // So we check only group member 0 (which is always guaranteed to exist),; // and the last group member. Case 3 (scalar epilog) is not relevant for; // stores with gaps, which are implemented with masked-store (rather than; // speculative access, as in loads).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:379,Performance,load,loads,379,"// Case 2: If first and last members of the group don't wrap this implies; // that all the pointers in the group don't wrap.; // So we check only group member 0 (which is always guaranteed to exist),; // and the last group member. Case 3 (scalar epilog) is not relevant for; // stores with gaps, which are implemented with masked-store (rather than; // speculative access, as in loads).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:365,Security,access,access,365,"// Case 2: If first and last members of the group don't wrap this implies; // that all the pointers in the group don't wrap.; // So we check only group member 0 (which is always guaranteed to exist),; // and the last group member. Case 3 (scalar epilog) is not relevant for; // stores with gaps, which are implemented with masked-store (rather than; // speculative access, as in loads).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:3,Deployability,Release,Release,3,// Release groups requiring scalar epilogues. Note that this also removes them; // from InterleaveGroups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-inline-oz-test-model.py:14,Testability,mock,mock,14,"""""""Generate a mock model for LLVM tests. The generated model is not a neural net - it is just a tf.function with the; correct input and output parameters. By construction, the mock model will always; output 1.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-inline-oz-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-inline-oz-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-inline-oz-test-model.py:34,Testability,test,tests,34,"""""""Generate a mock model for LLVM tests. The generated model is not a neural net - it is just a tf.function with the; correct input and output parameters. By construction, the mock model will always; output 1.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-inline-oz-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-inline-oz-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-inline-oz-test-model.py:176,Testability,mock,mock,176,"""""""Generate a mock model for LLVM tests. The generated model is not a neural net - it is just a tf.function with the; correct input and output parameters. By construction, the mock model will always; output 1.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-inline-oz-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-inline-oz-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-inline-oz-test-model.py:22,Testability,mock,mock,22,"""""""Build and save the mock model with the given signature""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-inline-oz-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-inline-oz-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py:14,Testability,mock,mock,14,"""""""Generate a mock model for LLVM tests for Register Allocation.; The generated model is not a neural net - it is just a tf.function with the; correct input and output parameters. By construction, the mock model will always; output the first liverange that can be evicted.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py:34,Testability,test,tests,34,"""""""Generate a mock model for LLVM tests for Register Allocation.; The generated model is not a neural net - it is just a tf.function with the; correct input and output parameters. By construction, the mock model will always; output the first liverange that can be evicted.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py:201,Testability,mock,mock,201,"""""""Generate a mock model for LLVM tests for Register Allocation.; The generated model is not a neural net - it is just a tf.function with the; correct input and output parameters. By construction, the mock model will always; output the first liverange that can be evicted.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py:22,Testability,mock,mock,22,"""""""Build and save the mock model with the given signature.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py:30,Modifiability,variab,variable,30,# We have to set this useless variable in order for the TF C API to correctly; # intake it,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-eviction-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py:14,Testability,mock,mock,14,"""""""Generate a mock model for LLVM tests for Register Allocation.; The generated model is not a neural net - it is just a tf.function with the; correct input and output parameters. ; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py:34,Testability,test,tests,34,"""""""Generate a mock model for LLVM tests for Register Allocation.; The generated model is not a neural net - it is just a tf.function with the; correct input and output parameters. ; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py:24,Testability,mock,mock,24,"## By construction, the mock model will always output the first liverange that can be evicted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py:22,Testability,mock,mock,22,"""""""Build and save the mock model with the given signature.""""""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py:30,Modifiability,variab,variable,30,# We have to set this useless variable in order for the TF C API to correctly; # intake it,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/gen-regalloc-priority-test-model.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py:15,Testability,test,testing,15,"""""""Utility for testing InteractiveModelRunner. Use it from pass-specific tests by providing a main .py which calls this library's; `run_interactive` with an appropriate callback to provide advice. From .ll tests, just call the above-mentioned main as a prefix to the opt/llc; invocation (with the appropriate flags enabling the interactive mode). Examples:; test/Transforms/Inline/ML/interactive-mode.ll; test/CodeGen/MLRegAlloc/interactive-mode.ll; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py:73,Testability,test,tests,73,"""""""Utility for testing InteractiveModelRunner. Use it from pass-specific tests by providing a main .py which calls this library's; `run_interactive` with an appropriate callback to provide advice. From .ll tests, just call the above-mentioned main as a prefix to the opt/llc; invocation (with the appropriate flags enabling the interactive mode). Examples:; test/Transforms/Inline/ML/interactive-mode.ll; test/CodeGen/MLRegAlloc/interactive-mode.ll; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py:206,Testability,test,tests,206,"""""""Utility for testing InteractiveModelRunner. Use it from pass-specific tests by providing a main .py which calls this library's; `run_interactive` with an appropriate callback to provide advice. From .ll tests, just call the above-mentioned main as a prefix to the opt/llc; invocation (with the appropriate flags enabling the interactive mode). Examples:; test/Transforms/Inline/ML/interactive-mode.ll; test/CodeGen/MLRegAlloc/interactive-mode.ll; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py:358,Testability,test,test,358,"""""""Utility for testing InteractiveModelRunner. Use it from pass-specific tests by providing a main .py which calls this library's; `run_interactive` with an appropriate callback to provide advice. From .ll tests, just call the above-mentioned main as a prefix to the opt/llc; invocation (with the appropriate flags enabling the interactive mode). Examples:; test/Transforms/Inline/ML/interactive-mode.ll; test/CodeGen/MLRegAlloc/interactive-mode.ll; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py:405,Testability,test,test,405,"""""""Utility for testing InteractiveModelRunner. Use it from pass-specific tests by providing a main .py which calls this library's; `run_interactive` with an appropriate callback to provide advice. From .ll tests, just call the above-mentioned main as a prefix to the opt/llc; invocation (with the appropriate flags enabling the interactive mode). Examples:; test/Transforms/Inline/ML/interactive-mode.ll; test/CodeGen/MLRegAlloc/interactive-mode.ll; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py:702,Testability,test,testing,702,"""""""Host the compiler.; Args:; temp_rootname: the base file name from which to construct the 2 pipes for; communicating with the compiler.; make_response: a function that, given the current tensor values, provides a; response.; process_and_args: the full commandline for the compiler. It it assumed it; contains a flag poiting to `temp_rootname` so that the InteractiveModeRunner; would attempt communication on the same pair as this function opens. This function sets up the communication with the compiler - via 2 files named; `temp_rootname`.in and `temp_rootname`.out - prints out the received features,; and sends back to the compiler an advice (which it gets from `make_response`).; It's used for testing, and also to showcase how to set up communication in an; interactive ML (""gym"") environment.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/interactive_host.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/log_reader.py:23,Testability,log,log,23,"""""""Reader for training log. See lib/Analysis/TrainingLogger.cpp for a description of the format.; """"""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/models/log_reader.py,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/models/log_reader.py
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:321,Availability,error,error,321,"//===----------------------------------------------------------------------===//; // Helper functions.; //===----------------------------------------------------------------------===//; // atoull - Convert an ascii string of decimal digits into the unsigned long; // long representation... this does not have to do input error checking,; // because we know that the input will be matched by a suitable regex...; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:20,Safety,detect,detected,20,"// Uh, oh, overflow detected!!!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:20,Safety,detect,detected,20,"// Uh, oh, overflow detected!!!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:56,Modifiability,variab,variable,56,/// ReadVarName - Read the rest of a token containing a variable name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:103,Availability,Error,Error,103,"// Lex an ID: [0-9]+. On success, the ID is stored in UIntVal and Token is; // returned, otherwise the Error token is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:91,Safety,avoid,avoid,91,// Check for [us]0x[0-9A-Fa-f]+ which are Hexadecimal constant generated by; // the CFE to avoid forcing it to deal with 64-bit numbers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:30,Availability,error,error,30,"// Bad token, return it as an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:43,Availability,error,error,43,"// Finally, if this isn't known, return an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:30,Availability,error,error,30,"// Bad token, return it as an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:25,Energy Efficiency,Power,PowerPC,25,// PPC128HexFPConstant - PowerPC 128-bit in hexadecimal format (16 bytes),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:34,Safety,safe,safe,34,// White-list intrinsics that are safe to drop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:46,Integrability,wrap,wrappers,46,// Also remove no longer used MetadataAsValue wrappers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:4,Security,validat,validateEndOfModule,4,/// validateEndOfModule - Do final validity and basic correctness checks at the; /// end of the module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:115,Availability,error,error,115,// Don't do anything if the intrinsic is called with different function; // types. This would result in a verifier error anyway.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:61,Deployability,upgrade,upgraded,61,// Look for intrinsic functions and CallInst that need to be upgraded. We use; // make_early_inc_range here because we may remove some functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:75,Security,validat,validated,75,"// Initialize the slot mapping.; // Because by this point we've parsed and validated everything, we can ""steal""; // the mapping from LLParser as it doesn't need it anymore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:184,Modifiability,variab,variable,184,/// parseUnnamedGlobal:; /// OptionalVisibility (ALIAS | IFUNC) ...; /// OptionalLinkage OptionalPreemptionSpecifier OptionalVisibility; /// OptionalDLLStorageClass; /// ... -> global variable; /// GlobalID '=' OptionalVisibility (ALIAS | IFUNC) ...; /// GlobalID '=' OptionalLinkage OptionalPreemptionSpecifier; /// OptionalVisibility; /// OptionalDLLStorageClass; /// ... -> global variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:384,Modifiability,variab,variable,384,/// parseUnnamedGlobal:; /// OptionalVisibility (ALIAS | IFUNC) ...; /// OptionalLinkage OptionalPreemptionSpecifier OptionalVisibility; /// OptionalDLLStorageClass; /// ... -> global variable; /// GlobalID '=' OptionalVisibility (ALIAS | IFUNC) ...; /// GlobalID '=' OptionalLinkage OptionalPreemptionSpecifier; /// OptionalVisibility; /// OptionalDLLStorageClass; /// ... -> global variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:210,Modifiability,variab,variable,210,/// parseNamedGlobal:; /// GlobalVar '=' OptionalVisibility (ALIAS | IFUNC) ...; /// GlobalVar '=' OptionalLinkage OptionalPreemptionSpecifier; /// OptionalVisibility OptionalDLLStorageClass; /// ... -> global variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:133,Testability,log,logic,133,"// parse DIExpressions inline as a special case. They are still MDNodes,; // so they can still appear in named metadata. Remove this logic if they; // become plain Metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:17,Availability,error,error,17,"// Detect common error, from old metadata syntax.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:3,Safety,Detect,Detect,3,"// Detect common error, from old metadata syntax.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:96,Availability,down,down,96,"// Now walk through the parenthesized entry, until the number of open; // parentheses goes back down to 0 (the first '(' was parsed above).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:39,Deployability,update,update,39,"// If there was an explicit dso_local, update GV. In the absence of an explicit; // dso_local we keep the default value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:118,Integrability,Rout,Routines,118,//===----------------------------------------------------------------------===//; // GlobalValue Reference/Resolution Routines.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:113,Integrability,Rout,Routines,113,//===----------------------------------------------------------------------===//; // Comdat Reference/Resolution Routines.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:309,Availability,error,error,309,"//===----------------------------------------------------------------------===//; // Helper Routines.; //===----------------------------------------------------------------------===//; /// parseToken - If the current token has the specified kind, eat it and return; /// success. Otherwise, emit the specified error and return failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:326,Availability,failure,failure,326,"//===----------------------------------------------------------------------===//; // Helper Routines.; //===----------------------------------------------------------------------===//; /// parseToken - If the current token has the specified kind, eat it and return; /// success. Otherwise, emit the specified error and return failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:92,Integrability,Rout,Routines,92,"//===----------------------------------------------------------------------===//; // Helper Routines.; //===----------------------------------------------------------------------===//; /// parseToken - If the current token has the specified kind, eat it and return; /// success. Otherwise, emit the specified error and return failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:30,Availability,mask,masks,30,// TODO: Disallow overlapping masks to avoid copy paste errors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:56,Availability,error,errors,56,// TODO: Disallow overlapping masks to avoid copy paste errors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:39,Safety,avoid,avoid,39,// TODO: Disallow overlapping masks to avoid copy paste errors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:90,Integrability,synchroniz,synchronization,90,"/// parseScope; /// ::= syncscope(""singlethread"" | ""<target scope>"")?; ///; /// This sets synchronization scope ID to the ID of the parsed value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:15,Availability,error,error,15,// Give a nice error for 'ptr*'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:34,Usability,clear,clear,34,"// This type is being defined, so clear the location to indicate this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:34,Usability,clear,clear,34,"// This type is being defined, so clear the location to indicate this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:135,Availability,error,error,135,"// The only other kind of parameter we support is type parameters, which; // must precede the integer parameters. This is therefore an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:94,Deployability,install,installs,94,"/// setInstName - After an instruction is parsed and inserted into its; /// basic block, this installs its name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:103,Availability,error,error,103,"/// defineBB - Define the specified basic block, which is either named or; /// unnamed. If there is an error, this returns null otherwise it returns; /// the block being defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:17,Modifiability,variab,variable,17,// Make a global variable as a placeholder for this reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:29,Modifiability,variab,variable,29,// Make a placeholder global variable as a placeholder for this reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:100,Security,checksum,checksumkind,100,"/// parseDIFileType:; /// ::= !DIFileType(filename: ""path/to/file"", directory: ""/path/to/dir"",; /// checksumkind: CSK_MD5,; /// checksum: ""000102030405060708090a0b0c0d0e0f"",; /// source: ""source file contents"")",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:128,Security,checksum,checksum,128,"/// parseDIFileType:; /// ::= !DIFileType(filename: ""path/to/file"", directory: ""/path/to/dir"",; /// checksumkind: CSK_MD5,; /// checksum: ""000102030405060708090a0b0c0d0e0f"",; /// source: ""source file contents"")",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:37,Security,checksum,checksumkind,37,"// The default constructed value for checksumkind is required, but will never; // be used, as the parser checks if the field was actually Seen before using; // the Val.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:69,Modifiability,config,configMacros,69,"/// parseDIModule:; /// ::= !DIModule(scope: !0, name: ""SomeModule"", configMacros:; /// ""-DNDEBUG"", includePath: ""/usr/include"", apinotes: ""module.apinotes"",; /// file: !1, line: 4, isDecl: false)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:26,Usability,resume,resume,26,/// parseResume; /// ::= 'resume' TypeAndValue,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:24,Performance,load,load,24,"/// parseLoad; /// ::= 'load' 'volatile'? TypeAndValue (',' 'align' i32)?; /// ::= 'load' 'atomic' 'volatile'? TypeAndValue; /// 'singlethread'? AtomicOrdering (',' 'align' i32)?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:84,Performance,load,load,84,"/// parseLoad; /// ::= 'load' 'volatile'? TypeAndValue (',' 'align' i32)?; /// ::= 'load' 'atomic' 'volatile'? TypeAndValue; /// 'singlethread'? AtomicOrdering (',' 'align' i32)?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:3,Deployability,Update,Update,3,// Update consistency checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:73,Security,hash,hash,73,"/// ModuleEntry; /// ::= 'module' ':' '(' 'path' ':' STRINGCONSTANT ',' 'hash' ':' Hash ')'; /// Hash ::= '(' UInt32 ',' UInt32 ',' UInt32 ',' UInt32 ',' UInt32 ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:83,Security,Hash,Hash,83,"/// ModuleEntry; /// ::= 'module' ':' '(' 'path' ':' STRINGCONSTANT ',' 'hash' ':' Hash ')'; /// Hash ::= '(' UInt32 ',' UInt32 ',' UInt32 ',' UInt32 ',' UInt32 ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:97,Security,Hash,Hash,97,"/// ModuleEntry; /// ::= 'module' ':' '(' 'path' ':' STRINGCONSTANT ',' 'hash' ':' Hash ')'; /// Hash ::= '(' UInt32 ',' UInt32 ',' UInt32 ',' UInt32 ',' UInt32 ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:55,Deployability,update,update,55,"// Check if this ID was forward referenced, and if so, update the; // corresponding GUIDs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:84,Usability,GUID,GUIDs,84,"// Check if this ID was forward referenced, and if so, update the; // corresponding GUIDs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:151,Deployability,update,update,151,"// Keep track of the TypeIdCompatibleVtableInfo array index needing a; // forward reference. We will save the location of the ValueInfo needing an; // update, but can only do so once the std::vector is finalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:46,Safety,safe,safe,46,"// Now that the TI vector is finalized, it is safe to save the locations; // of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:55,Deployability,update,update,55,"// Check if this ID was forward referenced, and if so, update the; // corresponding GUIDs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:84,Usability,GUID,GUIDs,84,"// Check if this ID was forward referenced, and if so, update the; // corresponding GUIDs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:80,Deployability,update,updates,80,/// Stores the given Name/GUID and associated summary into the Index.; /// Also updates any forward references to the associated entry ID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:26,Usability,GUID,GUID,26,/// Stores the given Name/GUID and associated summary into the Index.; /// Also updates any forward references to the associated entry ID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:52,Usability,GUID,GUID,52,// First create the ValueInfo utilizing the Name or GUID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:14,Deployability,continuous,continuous,14,// Handle non-continuous numbers (to make test simplification easier).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:42,Testability,test,test,42,// Handle non-continuous numbers (to make test simplification easier).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:47,Usability,simpl,simplification,47,// Handle non-continuous numbers (to make test simplification easier).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:182,Modifiability,Variab,VariableSummary,182,"/// parseGVEntry; /// ::= 'gv' ':' '(' ('name' ':' STRINGCONSTANT | 'guid' ':' UInt64); /// [',' 'summaries' ':' Summary[',' Summary]* ]? ')'; /// Summary ::= '(' (FunctionSummary | VariableSummary | AliasSummary) ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:69,Usability,guid,guid,69,"/// parseGVEntry; /// ::= 'gv' ':' '(' ('name' ':' STRINGCONSTANT | 'guid' ':' UInt64); /// [',' 'summaries' ':' Summary[',' Summary]* ]? ')'; /// Summary ::= '(' (FunctionSummary | VariableSummary | AliasSummary) ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:16,Usability,GUID,GUID,16,// Can't create GUID/ValueInfo until we have the linkage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:17,Integrability,Wrap,Wrap,17,// No summaries. Wrap up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:72,Usability,GUID,GUID,72,"// This was created for a call to an external or indirect target.; // A GUID with no summary came from a VALUE_GUID record, dummy GUID; // created for indirect calls with VP. A Name with no GUID came from; // an external definition. We pass ExternalLinkage since that is only; // used when the GUID must be computed from Name, and in that case; // the symbol must have external linkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:130,Usability,GUID,GUID,130,"// This was created for a call to an external or indirect target.; // A GUID with no summary came from a VALUE_GUID record, dummy GUID; // created for indirect calls with VP. A Name with no GUID came from; // an external definition. We pass ExternalLinkage since that is only; // used when the GUID must be computed from Name, and in that case; // the symbol must have external linkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:190,Usability,GUID,GUID,190,"// This was created for a call to an external or indirect target.; // A GUID with no summary came from a VALUE_GUID record, dummy GUID; // created for indirect calls with VP. A Name with no GUID came from; // an external definition. We pass ExternalLinkage since that is only; // used when the GUID must be computed from Name, and in that case; // the symbol must have external linkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:294,Usability,GUID,GUID,294,"// This was created for a call to an external or indirect target.; // A GUID with no summary came from a VALUE_GUID record, dummy GUID; // created for indirect calls with VP. A Name with no GUID came from; // an external definition. We pass ExternalLinkage since that is only; // used when the GUID must be computed from Name, and in that case; // the symbol must have external linkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:4,Modifiability,Variab,VariableSummary,4,"/// VariableSummary; /// ::= 'variable' ':' '(' 'module' ':' ModuleReference ',' GVFlags; /// [',' OptionalRefs]? ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:30,Modifiability,variab,variable,30,"/// VariableSummary; /// ::= 'variable' ':' '(' 'module' ':' ModuleReference ',' GVFlags; /// [',' OptionalRefs]? ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:125,Deployability,update,update,125,"// Keep track of the Call array index needing a forward reference.; // We will save the location of the ValueInfo needing an update, but; // can only do so once the std::vector is finalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:49,Safety,safe,safe,49,"// Now that the Calls vector is finalized, it is safe to save the locations; // of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:132,Deployability,update,update,132,"// Keep track of the VTableFuncs array index needing a forward reference.; // We will save the location of the ValueInfo needing an update, but; // can only do so once the std::vector is finalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:55,Safety,safe,safe,55,"// Now that the VTableFuncs vector is finalized, it is safe to save the; // locations of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:43,Safety,safe,safe,43,"// Now that the Params is finalized, it is safe to save the locations; // of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:125,Deployability,update,update,125,"// Keep track of the Refs array index needing a forward reference.; // We will save the location of the ValueInfo needing an update, but; // can only do so once the std::vector is finalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:48,Safety,safe,safe,48,"// Now that the Refs vector is finalized, it is safe to save the locations; // of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:125,Deployability,update,update,125,"// Keep track of the TypeTests array index needing a forward reference.; // We will save the location of the GUID needing an update, but; // can only do so once the std::vector is finalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:109,Usability,GUID,GUID,109,"// Keep track of the TypeTests array index needing a forward reference.; // We will save the location of the GUID needing an update, but; // can only do so once the std::vector is finalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:53,Safety,safe,safe,53,"// Now that the TypeTests vector is finalized, it is safe to save the; // locations of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:55,Safety,safe,safe,55,"// Now that the VFuncIdList vector is finalized, it is safe to save the; // locations of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:58,Safety,safe,safe,58,"// Now that the ConstVCallList vector is finalized, it is safe to save the; // locations of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:53,Usability,guid,guid,53,"/// VFuncId; /// ::= 'vFuncId' ':' '(' (SummaryID | 'guid' ':' UInt64) ','; /// 'offset' ':' UInt64 ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:115,Deployability,update,update,115,"// Keep track of the array index needing a forward reference.; // We will save the location of the GUID needing an update, but; // can only do so once the caller's std::vector is finalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:99,Usability,GUID,GUID,99,"// Keep track of the array index needing a forward reference.; // We will save the location of the GUID needing an update, but; // can only do so once the caller's std::vector is finalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:130,Deployability,update,update,130,"// Keep track of the Callsites array index needing a forward reference.; // We will save the location of the ValueInfo needing an update, but; // can only do so once the SmallVector is finalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:53,Safety,safe,safe,53,"// Now that the Callsites vector is finalized, it is safe to save the; // locations of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/Parser.cpp:2,Deployability,Upgrade,UpgradeDebugInfo,2,/*UpgradeDebugInfo*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/Parser.cpp:2,Deployability,Upgrade,UpgradeDebugInfo,2,/*UpgradeDebugInfo*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/Parser.cpp:2,Deployability,Upgrade,UpgradeDebugInfo,2,/*UpgradeDebugInfo*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/Parser.cpp:2,Deployability,Upgrade,UpgradeDebugInfo,2,/*UpgradeDebugInfo*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/AsmParser/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/Dwarf.cpp:3,Security,Access,Accessibility,3,// Accessibility codes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/Dwarf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/Dwarf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/Magic.cpp:19,Integrability,wrap,wraper,19,// 0x0B17C0DE = BC wraper,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/Magic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/Magic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/Magic.cpp:3,Energy Efficiency,Power,PowerPC,3,// PowerPC Windows,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/Magic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/Magic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/Magic.cpp:19,Testability,stub,stub,19,"// Possible MS-DOS stub on Windows PE file, MSF/PDB file or a; // Minidump file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/Magic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/Magic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp:419,Security,expose,exposes,419,"//===-- MsgPackDocument.cpp - MsgPack Document --------------------------*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// This file implements a class that exposes a simple in-memory representation; /// of a document of MsgPack objects, that can be read from MsgPack, written to; /// MsgPack, and inspected and modified in memory. This is intended to be a; /// lighter-weight (in terms of memory allocations) replacement for; /// MsgPackTypes.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp:429,Usability,simpl,simple,429,"//===-- MsgPackDocument.cpp - MsgPack Document --------------------------*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// This file implements a class that exposes a simple in-memory representation; /// of a document of MsgPack objects, that can be read from MsgPack, written to; /// MsgPack, and inspected and modified in memory. This is intended to be a; /// lighter-weight (in terms of memory allocations) replacement for; /// MsgPackTypes.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp:11,Security,access,access,11,/// Member access for MapDocNode. The string data must remain valid for the; /// lifetime of the Document.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp:11,Security,access,access,11,/// Member access for MapDocNode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp:11,Security,access,access,11,/// Member access for MapDocNode for integer key.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp:31,Modifiability,extend,extends,31,/// Array element access. This extends the array if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp:18,Security,access,access,18,/// Array element access. This extends the array if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp:293,Safety,avoid,avoid,293,"// Convenience assignment operators. This only works if the destination; // DocNode has an associated Document, i.e. it was not constructed using the; // default constructor. The string one does not copy, so the string must; // remain valid for the lifetime of the Document. Use fromString to avoid; // that restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp:510,Availability,error,error,510,"// Read a document from a binary msgpack blob, merging into anything already in; // the Document.; // The blob data must remain valid for the lifetime of this Document (because a; // string object in the document contains a StringRef into the original blob).; // If Multi, then this sets root to an array and adds top-level objects to it.; // If !Multi, then it only reads a single top-level object, even if there are; // more, and sets root to that.; // Returns false if failed due to illegal format or merge error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp:24,Availability,Error,Error,24,// FIXME: Propagate the Error to the caller.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocumentYAML.cpp:56,Integrability,interface,interface,56,"//===-- MsgPackDocumentYAML.cpp - MsgPack Document YAML interface -------*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// This file implements YAMLIO on a msgpack::Document.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocumentYAML.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocumentYAML.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocumentYAML.cpp:3,Availability,Toler,Tolerate,3,"// Tolerate signedness of int changing, as tags do not differentiate between; // them anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocumentYAML.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocumentYAML.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocumentYAML.cpp:63,Availability,failure,failure,63,/// Read YAML text into the MsgPack document. Returns false on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocumentYAML.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocumentYAML.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackReader.cpp:419,Integrability,Message,MessagePack,419,"//===- MsgPackReader.cpp - Simple MsgPack reader ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements a MessagePack reader.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackReader.cpp:27,Usability,Simpl,Simple,27,"//===- MsgPackReader.cpp - Simple MsgPack reader ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements a MessagePack reader.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackWriter.cpp:419,Integrability,Message,MessagePack,419,"//===- MsgPackWriter.cpp - Simple MsgPack writer ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements a MessagePack writer.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackWriter.cpp:27,Usability,Simpl,Simple,27,"//===- MsgPackWriter.cpp - Simple MsgPack writer ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements a MessagePack writer.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/XCOFF.cpp:23,Testability,test,test,23,"// TODO: need to add a test case for ""Unknown"" and other SMC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/XCOFF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/XCOFF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/XCOFF.cpp:340,Availability,avail,available,340,"// In the function PPCFunctionInfo::getParmsType(), when there are no vector; // parameters, the 31st bit of ParmsType is always zero even if it indicates a; // floating point parameter. The parameter type information is lost. There; // are only 8 GPRs used for parameters passing, the floating parameters; // also occupy GPRs if there are available, so the 31st bit can never be a; // fixed parameter. At the same time, we also do not know whether the zero of; // the 31st bit indicates a float or double parameter type here. Therefore, we; // ignore the 31st bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/XCOFF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/XCOFF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/XCOFF.cpp:48,Availability,mask,mask,48,// Two of the bits that haven't got used in the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/BinaryFormat/XCOFF.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/XCOFF.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp:16,Integrability,wrap,wrapper,16,"// If we have a wrapper header, parse it and ignore the non-bc file; // contents. The magic number is 0x0B17C0DE stored in little endian.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp:43,Integrability,wrap,wrapper,43,// Use the cursor modified by skipping the wrapper header.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp:83,Security,validat,validate,83,"// If we found a metadata index, let's verify that we had an offset; // before and validate its forward reference offset was correct!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp:24,Security,hash,hash,24,"// If we found a module hash, let's verify that it matches!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp:17,Security,hash,hash,17,// Recompute the hash and compare it to the one in the bitcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:16,Integrability,wrap,wrapper,16,"// If we have a wrapper header, parse it and ignore the non-bc file contents.; // The magic number is 0x0B17C0DE stored in little endian.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:71,Availability,failure,failure,71,"/// Convert a string from a record into an std::string, return true on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:318,Deployability,upgrade,upgrade,318,"/// This represents a constant expression or constant aggregate using a custom; /// structure internal to the bitcode reader. Later, this structure will be; /// expanded by materializeValue() either into a constant expression/aggregate,; /// or into an instruction sequence at the point of use. This allows us to; /// upgrade bitcode using constant expressions even if this kind of constant; /// expression is no longer supported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:53,Safety,avoid,avoid,53,// Value subclass ID: Pick largest possible value to avoid any clashes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:265,Safety,avoid,avoid,265,"// Opcodes used for non-expressions. This includes constant aggregates; // (struct, array, vector) that might need expansion, as well as non-leaf; // constants that don't need expansion (no_cfi, dso_local, blockaddress),; // but still go through BitcodeConstant to avoid different uselist orders; // between the two cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:117,Deployability,upgrade,upgrades,117,/// Track type IDs of contained types. Order is the same as the contained; /// types of a Type*. This is used during upgrades of typed pointer IR in; /// opaque pointer mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:124,Performance,load,loaded,124,/// These are basic blocks forward-referenced by block addresses. They are; /// inserted lazily into functions when they're loaded. The basic block ID is; /// its index into the vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:128,Performance,queue,queue,128,"/// These are Functions that contain BlockAddresses which refer a different; /// Function. When parsing the different Function, queue Functions that refer; /// to the different Function. Those Functions must be materialized in order; /// to resolve their BlockAddress constants before the different Function; /// gets moved into another Module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:73,Availability,error,error,73,/// Main interface to parsing a bitcode buffer.; /// \returns true if an error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:9,Integrability,interface,interface,9,/// Main interface to parsing a bitcode buffer.; /// \returns true if an error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:158,Availability,failure,failure,158,/// Read a value/type pair out of the specified record from slot 'Slot'.; /// Increment Slot past the number of slots used in the record. Return true on; /// failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:173,Availability,error,error,173,/// Read a value out of the specified record from slot 'Slot'. Increment Slot; /// past the number of slots used by the value in the record. Return true if; /// there is an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:79,Availability,error,error,79,"/// Version of getValue that returns ResVal directly, or 0 if there is an; /// error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:4,Deployability,Upgrade,Upgrades,4,/// Upgrades old-style typeless byval/sret/inalloca attributes by adding the; /// corresponding argument's pointee type. Also upgrades intrinsics that now; /// require an elementtype attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:126,Deployability,upgrade,upgrades,126,/// Upgrades old-style typeless byval/sret/inalloca attributes by adding the; /// corresponding argument's pointee type. Also upgrades intrinsics that now; /// require an elementtype attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:162,Availability,error,error,162,"/// Converts alignment exponent (i.e. power of two (or zero)) to the; /// corresponding alignment to use. If alignment is too large, returns; /// a corresponding error code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:38,Energy Efficiency,power,power,38,"/// Converts alignment exponent (i.e. power of two (or zero)) to the; /// corresponding alignment to use. If alignment is too large, returns; /// a corresponding error code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:63,Availability,error,error,63,"/// Indicates whether we have already parsed the VST, used for error checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:354,Usability,GUID,GUID,354,"// Map to save ValueId to ValueInfo association that was recorded in the; // ValueSymbolTable. It is used after the VST is parsed to convert; // call graph edges read from the function summary from referencing; // callees by their ValueId to using the ValueInfo instead, which is how; // they are recorded in the summary index being built.; // We save a GUID which refers to the same global as the ValueInfo, but; // ignoring the linkage, i.e. for values other than local linkage they are; // identical (this is the second tuple member).; // The third tuple member is the real GUID of the ValueInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:577,Usability,GUID,GUID,577,"// Map to save ValueId to ValueInfo association that was recorded in the; // ValueSymbolTable. It is used after the VST is parsed to convert; // call graph edges read from the function summary from referencing; // callees by their ValueId to using the ValueInfo instead, which is how; // they are recorded in the summary index being built.; // We save a GUID which refers to the same global as the ValueInfo, but; // ignoring the linkage, i.e. for values other than local linkage they are; // identical (this is the second tuple member).; // The third tuple member is the real GUID of the ValueInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:130,Modifiability,variab,variable,130,"// Check for a function that isn't materializable to prevent an infinite; // loop. When parsing a blockaddress stored in a global variable, there; // isn't a trivial way to check if a function will have a body without a; // linear search through FunctionsWithBodies, so just check it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:62,Deployability,upgrade,upgrade,62,"// Summary were not emitted before LLVM 3.9, we don't need to upgrade Linkage; // like getDecodedLinkage() above. Any future change to the linkage enum and; // to getDecodedLinkage() will need to be taken into account here as above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:186,Performance,cache,cache,186,"// The cmpxchg return value is the only place we need more than one; // contained type ID, however the second one will always be the same (i1),; // so we don't need to include it in the cache key. This asserts that the; // contained types are indeed as expected and there are no collisions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:202,Testability,assert,asserts,202,"// The cmpxchg return value is the only place we need more than one; // contained type ID, however the second one will always be the same (i1),; // so we don't need to include it in the cache key. This asserts that the; // contained types are indeed as expected and there are no collisions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Performance,Cache,Cache,3,// Cache resolved constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:47,Deployability,upgrade,upgraded,47,"// 1ULL << 49 is InaccessibleMemOnly, which is upgraded separately.; // 1ULL << 50 is InaccessibleMemOrArgMemOnly, which is upgraded separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:124,Deployability,upgrade,upgraded,124,"// 1ULL << 49 is InaccessibleMemOnly, which is upgraded separately.; // 1ULL << 50 is InaccessibleMemOrArgMemOnly, which is upgraded separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:21,Deployability,upgrade,upgraded,21,// Type will be auto-upgraded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:98,Availability,down,down,98,// The alignment is stored as a 16-bit raw value from bits 31--16. We shift; // the bits above 31 down by 11 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade old memory attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Deployability,Upgrade,Upgrade,3,"// Upgrade old-style byval attribute to one with a type, even if it's; // nullptr. We will have to insert the real type when we associate; // this AttributeList with a function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:52,Performance,scalab,scalable,52,"// VECTOR: [numelts, eltty] or; // [numelts, eltty, scalable]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Integrability,Synchroniz,Synchronization,3,// Synchronization scope names are implicitly mapped to synchronization; // scope IDs by their order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:56,Integrability,synchroniz,synchronization,56,// Synchronization scope names are implicitly mapped to synchronization; // scope IDs by their order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:95,Usability,resume,resumed,95,"// Set the LastFunctionBlockBit to point to the last function block.; // Later when parsing is resumed after function materialization,; // we can simply skip that last function block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:146,Usability,simpl,simply,146,"// Set the LastFunctionBlockBit to point to the last function block.; // Later when parsing is resumed after function materialization,; // we can simply skip that last function block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:340,Security,access,access,340,"// Compute the delta between the bitcode indices in the VST (the word offset; // to the word-aligned ENTER_SUBBLOCK for the function block, and that; // expected by the lazy reader. The reader's EnterSubBlock expects to have; // already read the ENTER_SUBBLOCK code (size getAbbrevIDWidth) and BlockID; // (size BlockIDWidth). Note that we access the stream's AbbrevID width here; // just before entering the VST subblock because: 1) the EnterSubBlock; // changes the AbbrevID width; 2) the VST block is nested within the same; // outer MODULE_BLOCK as the FUNCTION_BLOCKs and therefore have the same; // AbbrevID width before calling EnterSubBlock; and 3) when we want to; // jump to the FUNCTION_BLOCK using this offset later, we don't want; // to rely on the stream's AbbrevID width being that of the MODULE_BLOCK.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:112,Deployability,upgrade,upgraded,112,"// Mismatches can happen if the functions are being materialized lazily; // (out-of-order), or a value has been upgraded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Deployability,Upgrade,Upgrade,3,"// Upgrade ""Linker Options"" module flag to ""llvm.linker.options"" module-level; // metadata. Only upgrade if the new option doesn't exist to avoid upgrade; // multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:97,Deployability,upgrade,upgrade,97,"// Upgrade ""Linker Options"" module flag to ""llvm.linker.options"" module-level; // metadata. Only upgrade if the new option doesn't exist to avoid upgrade; // multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:146,Deployability,upgrade,upgrade,146,"// Upgrade ""Linker Options"" module flag to ""llvm.linker.options"" module-level; // metadata. Only upgrade if the new option doesn't exist to avoid upgrade; // multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:140,Safety,avoid,avoid,140,"// Upgrade ""Linker Options"" module flag to ""llvm.linker.options"" module-level; // metadata. Only upgrade if the new option doesn't exist to avoid upgrade; // multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Deployability,Patch,Patch,3,// Patch the initializers for globals and aliases up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:49,Deployability,upgrade,upgraded,49,// Look for intrinsic functions which need to be upgraded at some point; // and functions that need to have their function attributes upgraded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:134,Deployability,upgrade,upgraded,134,// Look for intrinsic functions which need to be upgraded at some point; // and functions that need to have their function attributes upgraded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:19,Modifiability,variab,variables,19,// Look for global variables which need to be renamed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:56,Deployability,upgrade,upgrade,56,// Local linkage must have default visibility.; // auto-upgrade `hidden` and `protected` for old bitcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade any old-style byval or sret without a type by propagating the; // argument's pointee type. There should be no opaque pointers where the byval; // type is implicit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:56,Deployability,upgrade,upgrade,56,// Local linkage must have default visibility.; // auto-upgrade `hidden` and `protected` for old bitcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:56,Deployability,upgrade,upgrade,56,// Local linkage must have default visibility.; // auto-upgrade `hidden` and `protected` for old bitcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:28,Integrability,depend,depend,28,// Parts of bitcode parsing depend on the datalayout. Make sure we; // finalize the datalayout before we run any of that code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:128,Deployability,upgrade,upgrades,128,"// In order to support importing modules with illegal data layout strings,; // delay parsing the data layout string until after upgrades and overrides; // have been applied, allowing to fix illegal data layout strings.; // Initialize to the current module's layout string in case none is specified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:8,Deployability,upgrade,upgrade,8,// Auto-upgrade the layout string,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:223,Usability,Resume,ResumeBit,223,"// If we have a VST forward declaration record, but have already; // parsed the VST (just above, when the first function body was; // encountered here), then we are resuming the parse after; // materializing functions. The ResumeBit points to the; // start of the last function block recorded in the; // DeferredFunctionInfo map. Skip it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:96,Usability,resume,resume,96,"// Suspend parsing when we reach the function bodies. Subsequent; // materialization calls will resume it when necessary. If the bitcode; // file is old, the symbol table will be at the end instead and will not; // have been seen yet. In this case, just finish the parse now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:83,Deployability,upgrade,upgraded,83,"// After the VST has been parsed, we need to make sure intrinsic name; // are auto-upgraded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:707,Availability,failure,failure,707,"// When we have the RARE case of a BlockAddress Constant that is not; // scoped to the Function it refers to, we need to conservatively; // materialize the referred to Function, regardless of whether or not; // that Function will ultimately be linked, otherwise users of; // BitcodeReader might start splicing out Function bodies such that we; // might no longer be able to materialize the BlockAddress since the; // BasicBlock (and entire body of the Function) the BlockAddress refers; // to may have been moved. In the case that the user of BitcodeReader; // decides ultimately not to link the Function body, materializing here; // could be considered wasteful, but it's better than a deserialization; // failure as described. This keeps BitcodeReader unaware of complex; // linkage policy decisions such as those use by LTO, leaving those; // decisions ""one layer up.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:20,Usability,clear,clear,20,// FIXME: It is not clear whether values in the range should be; // compared as signed or unsigned values. The partially; // implemented changes that used this format in the past used; // unsigned comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade the bundles if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Usability,RESUME,RESUME,3,// RESUME: [opval],MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade the bundles if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade explicit blockaddress arguments to label constraints.; // Verify that the last arguments are blockaddress arguments that; // match the indirect destinations. Clang always generates callbr; // in this form. We could support reordering with more effort.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Deployability,Update,Update,3,// Update constraint string to use label constraints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:169,Safety,avoid,avoid,169,"// Phi nodes may contain the same predecessor multiple times, in which; // case the incoming value must be identical. Directly reuse the already; // seen value here, to avoid expanding a constant expression multiple; // times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Performance,LOAD,LOAD,3,"// LOAD: [opty, op, align, vol]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Performance,LOAD,LOADATOMIC,3,"// LOADATOMIC: [opty, op, align, vol, ordering, ssid]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:79,Performance,load,loaded,79,"// Before weak cmpxchgs existed, the instruction simply returned the; // value loaded from memory, so bitcode files from that era will be; // expecting the first component of a modern cmpxchg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:49,Usability,simpl,simply,49,"// Before weak cmpxchgs existed, the instruction simply returned the; // value loaded from memory, so bitcode files from that era will be; // expecting the first component of a modern cmpxchg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade the bundles if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:60,Modifiability,variab,variable,60,// A call or an invoke can be optionally prefixed with some variable; // number of operand bundle blocks. These blocks are read into; // OperandBundles and consumed at the next call or invoke instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:60,Safety,avoid,avoid,60,// We found at least one unresolved value. Nuke them all to avoid leaks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:23,Availability,down,down,23,// Trim the value list down to the size it was before we parsed this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:195,Testability,Assert,Assert,195,"// This is the fallback handling for the old format bitcode that; // didn't contain the function index in the VST, or when we have; // an anonymous function which would not have a VST entry.; // Assert that we have one of those two cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:15,Integrability,synchroniz,synchronization,15,// Map unknown synchronization scopes to system.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade any old intrinsic calls in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:25,Deployability,upgrade,upgrade,25,// Finish fn->subprogram upgrade for materialized functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:4,Deployability,Upgrade,Upgrade,4,"// ""Upgrade"" older incorrect branch weights by dropping them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade any intrinsic calls that slipped through (should not happen!) and; // delete the old functions to clean up. We can't do this unless the entire; // module is materialized because there could always be another function body; // with calls to the old function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:97,Integrability,rout,routine,97,// Parse just the blocks needed for building the index out of the module.; // At the end of this routine the module Index is populated with a map; // from global value id to GlobalValueSummary objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:120,Performance,perform,performing,120,// We might not have a VST if there were no values in the; // summary. An empty summary block generated when we are; // performing ThinLTO compiles so we don't later invoke; // the regular LTO process on them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:114,Modifiability,variab,variables,114,// We can expect to see any number of type ID information records before; // each function summary records; these variables store the information; // collected so far so that it can be used to create the summary object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:36,Integrability,depend,depends,36,// Read a record. The record format depends on whether this; // is a per-module index or a combined index file. In the per-module; // case the records contain the associated value's ID for correlation; // with VST entries. In the combined index the correlation is done; // via the bitcode offset of the summary records (which were saved; // in the combined index VST entries). The records also contain; // information used for ThinLTO renaming and importing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:159,Availability,avail,available,159,"// FS_ALIAS: [valueid, flags, valueid]; // Aliases must be emitted (and parsed) after all FS_PERMODULE entries, as; // they expect all aliasee summaries to be available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:174,Availability,avail,available,174,"// FS_COMBINED_ALIAS: [valueid, modid, flags, valueid]; // Aliases must be emitted (and parsed) after all FS_COMBINED entries, as; // they expect all aliasee summaries to be available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:27,Safety,avoid,avoid,27,// Reset LastSeenModule to avoid overriding the hash unexpectedly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:48,Security,hash,hash,48,// Reset LastSeenModule to avoid overriding the hash unexpectedly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:69,Availability,Error,Error,69,"// FIXME: This class is only here to support the transition to llvm::Error. It; // will be removed once this transition is complete. Clients should prefer to; // deal with the Error value directly, rather than converting to error_code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:176,Availability,Error,Error,176,"// FIXME: This class is only here to support the transition to llvm::Error. It; // will be removed once this transition is complete. Clients should prefer to; // deal with the Error value directly, rather than converting to error_code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:94,Integrability,interface,interface,94,//===----------------------------------------------------------------------===//; // External interface; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:27,Performance,load,loading,27,"/// Get a lazy one-at-time loading module from bitcode.; ///; /// This isn't always used in a lazy context. In particular, it's also used by; /// \a parseModule(). If this is truly lazy, then we need to eagerly pull; /// in forward-referenced functions from block address references.; ///; /// \param[in] MaterializeAll Set to \c true if we should materialize; /// everything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp:193,Availability,error,error,193,"/* Builds a module from the bitcode in the specified memory buffer, returning a; reference to the module via the OutModule parameter. Returns 0 on success.; Optionally returns a human-readable error message via OutMessage. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp:199,Integrability,message,message,199,"/* Builds a module from the bitcode in the specified memory buffer, returning a; reference to the module via the OutModule parameter. Returns 0 on success.; Optionally returns a human-readable error message via OutMessage. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp:196,Availability,error,error,196,"/* Reads a module from the specified path, returning via the OutModule parameter; a module provider which performs lazy deserialization. Returns 0 on success.; Optionally returns a human-readable error message via OutMessage. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp:202,Integrability,message,message,202,"/* Reads a module from the specified path, returning via the OutModule parameter; a module provider which performs lazy deserialization. Returns 0 on success.; Optionally returns a human-readable error message via OutMessage. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp:106,Performance,perform,performs,106,"/* Reads a module from the specified path, returning via the OutModule parameter; a module provider which performs lazy deserialization. Returns 0 on success.; Optionally returns a human-readable error message via OutMessage. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp:3,Deployability,Release,Release,3,// Release the buffer if we didn't take ownership of it since we never owned; // it anyway.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:4,Deployability,Upgrade,Upgrade,4,/// Upgrade a type that had an MDString reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:4,Deployability,Upgrade,Upgrade,4,/// Upgrade a type that had an MDString reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:4,Deployability,Upgrade,Upgrade,4,/// Upgrade a type ref array that may have MDString references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:18,Usability,clear,clearly,18,// Bail out for a clearly invalid value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:3,Deployability,Upgrade,Upgrade,3,"// Upgrade from old type ref arrays. In strange cases, this could add to; // OldTypeRefs.Unknown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:48,Performance,queue,queue,48,"/// Return the list of temporaries nodes in the queue, these need to be; /// loaded before we can flush the queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:77,Performance,load,loaded,77,"/// Return the list of temporaries nodes in the queue, these need to be; /// loaded before we can flush the queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:108,Performance,queue,queue,108,"/// Return the list of temporaries nodes in the queue, these need to be; /// loaded before we can flush the queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:36,Performance,load,loading,36,"/// Cursor associated with the lazy-loading of Metadata. This is the easy way; /// to keep around the right ""context"" (Abbrev list) to be able to jump in; /// the middle of the metadata block and load any record.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:196,Performance,load,load,196,"/// Cursor associated with the lazy-loading of Metadata. This is the easy way; /// to keep around the right ""context"" (Abbrev list) to be able to jump in; /// the middle of the metadata block and load any record.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:14,Performance,load,loading,14,/// On-demand loading of a single MDString. Requires the index above to be; /// populated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:80,Performance,load,loading,80,"/// Cursor position of the start of the global decl attachments, to enable; /// loading using the index built for lazy loading, instead of forward; /// references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:119,Performance,load,loading,119,"/// Cursor position of the start of the global decl attachments, to enable; /// loading using the index built for lazy loading, instead of forward; /// references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:4,Performance,Load,Load,4,"/// Load the global decl attachments, using the index built for lazy loading.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:69,Performance,load,loading,69,"/// Load the global decl attachments, using the index built for lazy loading.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:46,Performance,load,loading,46,"/// Populate the index above to enable lazily loading of metadata, and load; /// the named metadata as well as the transitively referenced global; /// Metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:71,Performance,load,load,71,"/// Populate the index above to enable lazily loading of metadata, and load; /// the named metadata as well as the transitively referenced global; /// Metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:14,Performance,load,loading,14,/// On-demand loading of a single metadata. Requires the index above to be; /// populated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:58,Deployability,update,update,58,"// Keep mapping of seens pair of old-style CU <-> SP, and update pointers to; // point from SP to CU after a block is completly parsed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:4,Deployability,Upgrade,Upgrade,4,/// Upgrade old-style CU <-> SP pointers to point from SP to CU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:4,Deployability,Upgrade,Upgrade,4,/// Upgrade old-style bare DIGlobalVariables to DIGlobalVariableExpressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade list of variables attached to the CUs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:19,Modifiability,variab,variables,19,// Upgrade list of variables attached to the CUs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade variables attached to globals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:11,Modifiability,variab,variables,11,// Upgrade variables attached to globals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:3,Deployability,Update,Update,3,// Update DISubprograms' retainedNodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:4,Deployability,Upgrade,Upgrade,4,/// Upgrade the expression from previous versions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:11,Performance,load,loading,11,"// If lazy-loading is enabled, we try recursively to load the operand; // instead of creating a temporary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:53,Performance,load,load,53,"// If lazy-loading is enabled, we try recursively to load the operand; // instead of creating a temporary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:67,Performance,load,loadable,67,"// Get the abbrevs, and preload record positions to make them lazy-loadable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:85,Performance,load,load,85,"// This is the offset to the index, when we see this we skip all the; // records and load only an index to these.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:46,Performance,load,loaded,46,"// We don't expect to get there, the Index is loaded when we encounter; // the offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:172,Modifiability,Inherit,Inherit,172,"// FIXME: We could use a placeholder here, however NamedMDNode are; // taking MDNode as operand and not using the Metadata infrastructure.; // It is acknowledged by 'TODO: Inherit from Metadata' in the; // NamedMDNode class definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:75,Performance,load,loading,75,"// We don't expect to see any of these, if we see one, give up on; // lazy-loading and fallback.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:3,Performance,Load,Load,3,"// Load the global decl attachments after building the lazy loading index.; // We don't load them ""lazily"" - all global decl attachments must be; // parsed since they aren't materialized on demand. However, by delaying; // their parsing until after the index is created, we can use the index; // instead of creating temporaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:60,Performance,load,loading,60,"// Load the global decl attachments after building the lazy loading index.; // We don't load them ""lazily"" - all global decl attachments must be; // parsed since they aren't materialized on demand. However, by delaying; // their parsing until after the index is created, we can use the index; // instead of creating temporaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:88,Performance,load,load,88,"// Load the global decl attachments after building the lazy loading index.; // We don't load them ""lazily"" - all global decl attachments must be; // parsed since they aren't materialized on demand. However, by delaying; // their parsing until after the index is created, we can use the index; // instead of creating temporaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:90,Performance,load,loading,90,// Use a temporary cursor so that we don't mess up the main Stream cursor or; // the lazy loading IndexCursor (which holds the necessary abbrev ids).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:63,Energy Efficiency,efficient,efficiently,63,// Record the entry position so that we can jump back here and efficiently; // skip the whole block in case we lazy-load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:116,Performance,load,load,116,// Record the entry position so that we can jump back here and efficiently; // skip the whole block in case we lazy-load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:11,Performance,load,load,11,"// We lazy-load module-level metadata: we build an index for each record, and; // then load individual record as needed, starting with the named metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:87,Performance,load,load,87,"// We lazy-load module-level metadata: we build an index for each record, and; // then load individual record as needed, starting with the named metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:60,Performance,load,load,60,// An index was successfully created and we will be able to load metadata; // on-demand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:37,Performance,load,load,37,"// Now that we have built the index, load the global decl attachments; // that were deferred during that process. This avoids creating; // temporaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:119,Safety,avoid,avoids,119,"// Now that we have built the index, load the global decl attachments; // that were deferred during that process. This avoids creating; // temporaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:24,Availability,error,error,24,"// FIXME this drops the error on the floor, which; // ThinLTO/X86/debuginfo-cu-import.ll relies on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:12,Performance,load,load,12,"// Couldn't load an index, fallback to loading all the block ""old-style"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:39,Performance,load,loading,39,"// Couldn't load an index, fallback to loading all the block ""old-style"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:52,Performance,load,loaded,52,// Lookup first if the metadata hasn't already been loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:92,Performance,load,loading,92,/// Ensure that all forward-references and placeholders are resolved.; /// Iteratively lazy-loading metadata on-demand if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:64,Performance,load,loaded,64,// Populate Temporaries with the placeholders that haven't been loaded yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:10,Performance,load,load,10,"// First, load all the temporaries. This can add new placeholders or; // forward references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:11,Performance,load,load,11,"// Second, load the forward-references. This can also add new placeholders; // or forward references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:99,Performance,load,loaded,99,"// At this point we don't have any forward reference remaining, or temporary; // that haven't been loaded. We can safely drop RAUW support and mark cycles; // as resolved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:114,Safety,safe,safely,114,"// At this point we don't have any forward reference remaining, or temporary; // that haven't been loaded. We can safely drop RAUW support and mark cycles; // as resolved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:257,Availability,Error,ErrorInfo,257,"// This is a reference to a no longer supported constant expression.; // Pretend that the constant was deleted, which will replace metadata; // references with undef.; // TODO: This is a rather indirect check. It would be more elegant to use; // a separate ErrorInfo for constant materialization failure and thread; // the error reporting through getValueFwdRef().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:296,Availability,failure,failure,296,"// This is a reference to a no longer supported constant expression.; // Pretend that the constant was deleted, which will replace metadata; // references with undef.; // TODO: This is a rather indirect check. It would be more elegant to use; // a separate ErrorInfo for constant materialization failure and thread; // the error reporting through getValueFwdRef().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:323,Availability,error,error,323,"// This is a reference to a no longer supported constant expression.; // Pretend that the constant was deleted, which will replace metadata; // references with undef.; // TODO: This is a rather indirect check. It would be more elegant to use; // a separate ErrorInfo for constant materialization failure and thread; // the error reporting through getValueFwdRef().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:11,Performance,load,loading,11,"// If lazy-loading is enabled, we try recursively to load the operand; // instead of creating a temporary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:53,Performance,load,load,53,"// If lazy-loading is enabled, we try recursively to load the operand; // instead of creating a temporary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:84,Performance,load,load,84,// Create a temporary for the node that is referencing the operand we; // will lazy-load. It is needed before recursing in case there are; // uniquing cycles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:104,Deployability,upgrade,upgrade,104,"// If this isn't a LocalAsMetadata record, we're dropping it. This used; // to be legal, but there's no upgrade path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:60,Usability,simpl,simplified,60,// This is a hack around preserving template parameters for simplified; // template names - it should probably be replaced with a; // DICompositeType flag specifying whether template parameters are; // required on declarations of this type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:65,Security,Checksum,Checksum,65,"// The BitcodeWriter writes null bytes into Record[3:4] when the Checksum; // is not present. This matches up with the old internal representation,; // and the old encoding for CSK_None in the ChecksumKind. The new; // representation reserves the value 0 in the ChecksumKind to continue to; // encode None in a backwards-compatible way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:193,Security,Checksum,ChecksumKind,193,"// The BitcodeWriter writes null bytes into Record[3:4] when the Checksum; // is not present. This matches up with the old internal representation,; // and the old encoding for CSK_None in the ChecksumKind. The new; // representation reserves the value 0 in the ChecksumKind to continue to; // encode None in a backwards-compatible way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:262,Security,Checksum,ChecksumKind,262,"// The BitcodeWriter writes null bytes into Record[3:4] when the Checksum; // is not present. This matches up with the old internal representation,; // and the old encoding for CSK_None in the ChecksumKind. The new; // representation reserves the value 0 in the ChecksumKind to continue to; // encode None in a backwards-compatible way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:12,Deployability,Upgrade,Upgrade,12,// Move the Upgrade the list of subprograms.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade sp->function mapping to function->sp mapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:106,Availability,avail,available,106,// No upgrade necessary. A null field will be introduced to indicate; // that no parameter information is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:6,Deployability,upgrade,upgrade,6,// No upgrade necessary. A null field will be introduced to indicate; // that no parameter information is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:3,Deployability,Upgrade,Upgrade,3,"// Upgrade old metadata, which stored a global variable reference or a; // ConstantInt here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:47,Modifiability,variab,variable,47,"// Upgrade old metadata, which stored a global variable reference or a; // ConstantInt here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:3,Testability,Test,Test,3,// Test for upgrading !llvm.loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:3,Performance,Load,Load,3,// Load the attachment if it is in the lazy-loadable range and hasn't; // been loaded yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:44,Performance,load,loadable,44,// Load the attachment if it is in the lazy-loadable range and hasn't; // been loaded yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:79,Performance,load,loaded,79,// Load the attachment if it is in the lazy-loadable range and hasn't; // been loaded yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:66,Deployability,upgrade,upgrade,66,"// Drop the attachment. This used to be legal, but there's no; // upgrade path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h:42,Performance,Load,Load,42,"//===-- Bitcode/Reader/MetadataLoader.h - Load Metadatas -------*- C++ -*-====//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class handles loading Metadatas.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h:402,Performance,load,loading,402,"//===-- Bitcode/Reader/MetadataLoader.h - Load Metadatas -------*- C++ -*-====//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class handles loading Metadatas.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h:65,Availability,avail,available,65,/// Helper class that handles loading Metadatas and keeping them available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h:30,Performance,load,loading,30,/// Helper class that handles loading Metadatas and keeping them available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h:43,Performance,load,load,43,/// Set the mode to strip TBAA metadata on load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h:23,Performance,Load,Loader,23,/// Return true if the Loader is stripping TBAA metadata.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h:20,Deployability,upgrade,upgrades,20,/// Perform bitcode upgrades on llvm.dbg.* calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h:4,Performance,Perform,Perform,4,/// Perform bitcode upgrades on llvm.dbg.* calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/ValueList.cpp:18,Usability,clear,clearly,18,// Bail out for a clearly invalid value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/ValueList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/ValueList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/ValueList.cpp:48,Availability,error,error,48,// TODO: We might want to propagate the precise error message here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/ValueList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/ValueList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/ValueList.cpp:54,Integrability,message,message,54,// TODO: We might want to propagate the precise error message here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Reader/ValueList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/ValueList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:46,Usability,GUID,GUIDs,46,"/// Map that holds the correspondence between GUIDs in the summary index,; /// that came from indirect call profiles, and a value id generated by this; /// class to use in the VST and summary block records.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:45,Usability,GUID,GUIDToValueMap,45,/// Tracks the last value id recorded in the GUIDToValueMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:118,Usability,GUID,GUID,118,"// Assign ValueIds to any callee values in the index that came from; // indirect call profiles and were recorded as a GUID not a Value*; // (which would have been assigned an ID by the ValueEnumerator).; // The starting ValueId is just after the number of values in the; // ValueEnumerator, so that they can be emitted in the VST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:34,Usability,GUID,GUID,34,// Examine all summaries for this GUID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:70,Usability,GUID,GUID,70,"// For each call in the function summary, see if the call; // is to a GUID (which means it is for an indirect call,; // otherwise we would have a Value for it). If so, synthesize; // a value id.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:19,Usability,GUID,GUID,19,// Expect that any GUID value had a value Id assigned by an; // earlier call to assignValueId.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:26,Energy Efficiency,allocate,allocated,26,/// Pointer to the buffer allocated by caller for bitcode writing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:21,Security,hash,hash,21,/// True if a module hash record should be written.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:58,Security,hash,hash,58,"/// If non-null, when GenerateHash is true, the resulting hash is written; /// into ModHash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:124,Usability,GUID,GUIDs,124,"/// When writing a subset of the index for distributed backends, client; /// provides a map of modules to the corresponding GUIDs/summaries to write.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:50,Usability,GUID,GUID,50,/// Map that holds the correspondence between the GUID used in the combined; /// index and a value id generated by this class to use in references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:45,Usability,GUID,GUIDToValueMap,45,/// Tracks the last value id recorded in the GUIDToValueMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:130,Usability,GUID,GUID,130,"// Assign unique value ids to all summaries to be written, for use; // in writing out the call graph edges. Save the mapping from GUID; // to the new global value id to use when writing those edges, which; // are currently saved in the index in terms of GUID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:254,Usability,GUID,GUID,254,"// Assign unique value ids to all summaries to be written, for use; // in writing out the call graph edges. Save the mapping from GUID; // to the new global value id to use when writing those edges, which; // are currently saved in the index in terms of GUID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:129,Usability,GUID,GUID,129,"// If the stack id list is empty, this callsite info was synthesized for; // a missing tail call frame. Ensure that the callee's GUID gets a value; // id. Normally we only generate these for defined summaries, which in; // the case of distributed ThinLTO is only the functions already defined; // in the module or that we want to import. We don't bother to include; // all the callee symbols as they aren't normally needed in the backend.; // However, for the synthesized callsite infos we do need the callee; // GUID in the backend so that we can correlate the identified callee; // with this callsite info (which for non-tail calls is done by the; // ordering of the callsite infos and verified via stack ids).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:513,Usability,GUID,GUID,513,"// If the stack id list is empty, this callsite info was synthesized for; // a missing tail call frame. Ensure that the callee's GUID gets a value; // id. Normally we only generate these for defined summaries, which in; // the case of distributed ThinLTO is only the functions already defined; // in the module or that we want to import. We don't bother to include; // all the callee symbols as they aren't normally needed in the backend.; // However, for the synthesized callsite infos we do need the callee; // GUID in the backend so that we can correlate the identified callee; // with this callsite info (which for non-tail calls is done by the; // ordering of the callsite infos and verified via stack ids).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:35,Usability,GUID,GUID,35,/// The below iterator returns the GUID and associated summary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:38,Usability,GUID,GUID,38,/// Calls the callback for each value GUID and summary to be written to; /// bitcode. This hides the details of whether they are being pulled from the; /// entire index or just those in a provided ModuleToSummariesForIndex map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:144,Safety,avoid,avoid,144,"// Since StringMap iteration order isn't guaranteed, order by path string; // first.; // FIXME: Make this a vector of StringMapEntry instead to avoid the later; // map lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:51,Performance,scalab,scalable,51,"// VECTOR [numelts, eltty] or; // [numelts, eltty, scalable]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:202,Deployability,update,updated,202,"// Write a placeholder value in for the offset of the real VST,; // which is written after the function blocks so that it can include; // the offset of each function. The placeholder offset will be; // updated when the real VST is written.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:73,Deployability,patch,patched,73,"// Compute and save the bit offset to the placeholder, which will be; // patched when the real VST is written. We can simply subtract the 32-bit; // fixed size from the current bit number to get the location to backpatch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:118,Usability,simpl,simply,118,"// Compute and save the bit offset to the placeholder, which will be; // patched when the real VST is written. We can simply subtract the 32-bit; // fixed size from the current bit number to get the location to backpatch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:107,Modifiability,variab,variables,107,"/// Emit top-level description of module, including target triple, inline asm,; /// descriptors for global variables, and function prototype info.; /// Returns the bit offset to backpatch with the location of the real VST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:19,Modifiability,variab,variable,19,// Emit the global variable information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:92,Security,Checksum,ChecksumKind,92,// Maintain backwards compatibility with the old internal representation of; // CSK_None in ChecksumKind by writing nulls here when Checksum is None.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:132,Security,Checksum,Checksum,132,// Maintain backwards compatibility with the old internal representation of; // CSK_None in ChecksumKind by writing nulls here when Checksum is None.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:92,Performance,load,load,92,"// Emit all abbrevs upfront, so that the reader can jump in the middle of the; // block and load any metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:198,Deployability,update,updated,198,"// Write a placeholder value in for the offset of the metadata index,; // which is written after the records, so that it can include; // the offset of each entry. The placeholder offset will be; // updated after all records are emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:78,Deployability,patch,patched,78,"// Compute and save the bit offset to the current position, which will be; // patched when we emit the index later. We can simply subtract the 64-bit; // fixed size from the current bit number to get the location to backpatch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:123,Usability,simpl,simply,123,"// Compute and save the bit offset to the current position, which will be; // patched when we emit the index later. We can simply subtract the 64-bit; // fixed size from the current bit number to get the location to backpatch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:162,Energy Efficiency,efficient,efficiently,162,// Now that we have emitted all the records we will emit the index. But; // first; // backpatch the forward reference so that the reader can skip the records; // efficiently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:82,Modifiability,variab,variable,82,"// FIXME: Only store metadata for declarations here, and move data for global; // variable definitions to a separate block (PR28134).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:106,Energy Efficiency,efficient,efficiently,106,/// Write a GlobalValue VST to the module. The purpose of this data structure is; /// to allow clients to efficiently find the function body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:10,Security,Hash,Hash,10,"// Module Hash, 160 bits SHA1. Optionally, emitted after each MST_CODE_ENTRY.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:20,Security,hash,hash,20,// Emit an optional hash for the module now,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:12,Security,hash,hash,12,// Emit the hash record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:31,Testability,test,tests,31,/// Collect type IDs from type tests used by function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:52,Modifiability,variab,variable,52,"// Collect the global value references in the given variable's initializer,; // and emit them in a summary record.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:427,Testability,test,testing,427,"// We don't need to emit the original name if we are writing the index for; // distributed backends (in which case ModuleToSummariesForIndex is; // non-null). The original name is only needed during the thin link, since; // for SamplePGO the indirect call targets for local functions have; // have the original name annotated in profile.; // Continue to emit it when writing out the entire combined index, which is; // used in testing the thin link via llvm-lto.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:85,Performance,load,loaded,85,// Will process aliases as a post-pass because the reader wants all; // global to be loaded first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:204,Security,validat,validation,204,// This can happen in shared index files for distributed ThinLTO if; // the callee function summary is not included. Record 0 which we; // will have to deal with conservatively when doing any kind of; // validation in the ThinLTO backends.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:11,Usability,GUID,GUID,11,"// If this GUID doesn't have a value id, it doesn't have a function; // summary and we don't need to record any calls to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:12,Usability,GUID,GUIDs,12,"// Walk the GUIDs that were referenced, and write the; // corresponding type id records.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:21,Security,hash,hash,21,// Emit the module's hash.; // MODULE_CODE_HASH: [5*i32],MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:20,Security,hash,hash,20,// Save the written hash value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:105,Modifiability,variab,variables,105,"// Emit top-level description of module, including target triple, inline asm,; // descriptors for global variables, and function prototype info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:31,Energy Efficiency,power,powerpc,31,"// Match x86_64-*, i[3-9]86-*, powerpc-*, powerpc64-*, arm-*, thumb-*,; // armv[0-9]-*, thumbv[0-9]-*, armv5te-*, or armv6t2-*. The CPUType is a magic; // number from /usr/include/mach/machine.h. It is ok to reproduce the; // specific constants here because they are implicitly part of the Darwin ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:292,Availability,error,error,292,"// The irsymtab::build function may be unable to create a symbol table if the; // module is malformed (e.g. it contains an invalid alias). Writing a symbol; // table is not required for correctness, but we still want to be able to; // write malformed modules to bitcode files, so swallow the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:19,Modifiability,variab,variable,19,// Emit the global variable information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:16,Security,hash,hash,16,// Write module hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:63,Safety,avoid,avoid,63,// Explicitly sequence get-size and insert-value operations to avoid UB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:19,Performance,cache,cache,19,"// Note: we cannot cache this lookup above, since inserting into the map; // changes the map's size, and thus affects the other IDs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:175,Safety,predict,predictValueUseListOrderImpl,175,"// Initializers of GlobalValues are processed in; // BitcodeReader::ResolveGlobalAndAliasInits(). Match the order there rather; // than ValueEnumerator, and match the code in predictValueUseListOrderImpl(); // by giving IDs in reverse order.; //; // Since GlobalValues never reference each other directly (just through; // initializers), their relative IDs only matter for determining order of; // uses in their initializers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:3,Safety,Predict,Predict,3,// Predict use-list order for this one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:11,Safety,predict,predicted,11,// Already predicted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:17,Safety,predict,prediction,17,// Do the actual prediction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:24,Modifiability,variab,variables,24,// Enumerate the global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:24,Modifiability,variab,variable,24,// Enumerate the global variable initializers and attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:110,Modifiability,variab,variable,110,// FIXME: Pass GV to EnumerateMetadata and arrange for the bitcode writer; // to write metadata to the global variable's own metadata block; // (PR28134).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:3,Performance,Optimiz,Optimize,3,// Optimize constant ordering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:4,Performance,Optimiz,OptimizeConstants,4,/// OptimizeConstants - Reorder constant pool for denser encoding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:3,Performance,Optimiz,Optimizing,3,// Optimizing constants makes the use-list order difficult to predict.; // Disable it for now when trying to preserve the order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:62,Safety,predict,predict,62,// Optimizing constants makes the use-list order difficult to predict.; // Disable it for now when trying to preserve the order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:106,Safety,detect,detect,106,// ConstantAsMetadata doesn't reference anything. We may as well shuffle it; // to the front since we can detect it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:427,Modifiability,variab,variable,427,"// If a constant has operands, enumerate them. This makes sure that if a; // constant has uses (for example an array of const ints), that they are; // inserted also.; // We prefer to enumerate them with values before we enumerate the user; // itself. This makes it more likely that we can avoid forward references; // in the reader. We know that there can be no cycles in the constants; // graph that don't go through a global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:289,Safety,avoid,avoid,289,"// If a constant has operands, enumerate them. This makes sure that if a; // constant has uses (for example an array of const ints), that they are; // inserted also.; // We prefer to enumerate them with values before we enumerate the user; // itself. This makes it more likely that we can avoid forward references; // in the reader. We know that there can be no cycles in the constants; // graph that don't go through a global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:118,Safety,safe,safe,118,"// If it is a non-anonymous struct, mark the type as being visited so that we; // don't recursively visit it. This is safe because we allow forward; // references of these in the bitcode reader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:292,Availability,avail,available,292,"// Check to see if we got the pointer another way. This can happen when; // enumerating recursive types that hit the base case deeper than they start.; //; // If this is actually a struct that we are treating as forward ref'able,; // then emit the definition now that all of its contents are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:3,Performance,Optimiz,Optimize,3,// Optimize the constant layout.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:55,Availability,avail,available,55,// Add the function's parameter attributes so they are available for use in; // the function's instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.h:66,Performance,optimiz,optimization,66,"/// Reorder the reachable metadata.; ///; /// This is not just an optimization, but is mandatory for emitting MDString; /// correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.h:297,Safety,avoid,avoids,297,"/// Enumerate reachable metadata in (almost) post-order.; ///; /// Enumerate all the metadata reachable from MD. We want to minimize the; /// cost of reading bitcode records, and so the primary consideration is that; /// operands of uniqued nodes are resolved before the nodes are read. This; /// avoids re-uniquing them on the context and factors away RAUW support.; ///; /// This algorithm guarantees that subgraphs of uniqued nodes are in; /// post-order. Distinct subgraphs reachable only from a single uniqued node; /// will be in post-order.; ///; /// \note The relative order of a distinct and uniqued node is irrelevant.; /// \a organizeMetadata() will later partition distinct nodes ahead of; /// uniqued ones.; ///{",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitstream/Reader/BitstreamReader.cpp:54,Safety,avoid,avoid,54,"// If we can return a reference to the data, do so to avoid copying it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitstream/Reader/BitstreamReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitstream/Reader/BitstreamReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitstream/Reader/BitstreamReader.cpp:143,Safety,avoid,avoids,143,"// As a special case, handle fixed(0) (i.e., a fixed field with zero bits); // and vbr(0) as a literal zero. This is decoded the same way, and avoids; // a slow path in Read() to have to handle reading zero bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitstream/Reader/BitstreamReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitstream/Reader/BitstreamReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitstream/Reader/BitstreamReader.cpp:20,Deployability,install,installs,20,// ReadAbbrevRecord installs the abbrev in CurAbbrevs. Move it to the; // appropriate BlockInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Bitstream/Reader/BitstreamReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitstream/Reader/BitstreamReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:514,Energy Efficiency,schedul,scheduling,514,"//===- AggressiveAntiDepBreaker.cpp - Anti-dep breaker --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the AggressiveAntiDepBreaker class, which; // implements register anti-dependence breaking during post-RA; // scheduling. It attempts to break all anti-dependencies within a; // block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:475,Integrability,depend,dependence,475,"//===- AggressiveAntiDepBreaker.cpp - Anti-dep breaker --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the AggressiveAntiDepBreaker class, which; // implements register anti-dependence breaking during post-RA; // scheduling. It attempts to break all anti-dependencies within a; // block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:556,Integrability,depend,dependencies,556,"//===- AggressiveAntiDepBreaker.cpp - Anti-dep breaker --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the AggressiveAntiDepBreaker class, which; // implements register anti-dependence breaking during post-RA; // scheduling. It attempts to break all anti-dependencies within a; // block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:146,Energy Efficiency,schedul,scheduled,146,"// If Reg is current live, then mark that it can't be renamed as; // we don't know the extent of its live-range anymore (now that it; // has been scheduled). If it is not live but was defined in the; // previous schedule region, then set its def index to the most; // conservative location (i.e. the beginning of the previous; // schedule region).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:212,Energy Efficiency,schedul,schedule,212,"// If Reg is current live, then mark that it can't be renamed as; // we don't know the extent of its live-range anymore (now that it; // has been scheduled). If it is not live but was defined in the; // previous schedule region, then set its def index to the most; // conservative location (i.e. the beginning of the previous; // schedule region).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:330,Energy Efficiency,schedul,schedule,330,"// If Reg is current live, then mark that it can't be renamed as; // we don't know the extent of its live-range anymore (now that it; // has been scheduled). If it is not live but was defined in the; // previous schedule region, then set its def index to the most; // conservative location (i.e. the beginning of the previous; // schedule region).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:57,Integrability,depend,dependencies,57,/// AntiDepEdges - Return in Edges the anti- and output- dependencies; /// in SU that we want to consider for breaking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:48,Integrability,depend,dependency,48,"// In the case of a latency tie, prefer an anti-dependency edge over; // other types of edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:20,Performance,latency,latency,20,"// In the case of a latency tie, prefer an anti-dependency edge over; // other types of edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:91,Usability,clear,clear,91,"// FIXME: We must leave subregisters of live super registers as live, so that; // we don't clear out the register tracking information for subregisters of; // super registers we're still tracking (and with which we're unioning; // subregister definitions).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:51,Deployability,update,update,51,// Scan the register defs for this instruction and update; // live-ranges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:3,Deployability,Update,Update,3,// Update def for Reg and aliases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:223,Safety,safe,safely,223,"// If MI's uses have special allocation requirement, don't allow; // any use registers to be changed. Also assume all registers; // used in a call must not be changed (ABI).; // Inline Assembly register uses also cannot be safely changed.; // FIXME: The issue with predicated instruction is more complex. We are being; // conservatively here because the kill markers cannot be trusted after; // if-conversion:; // %r6 = LDR %sp, %reg0, 92, 14, %reg0; mem:LD4[FixedStack14]; // ...; // STR %r0, killed %r6, %reg0, 0, 0, %cpsr; mem:ST4[%395]; // %r6 = LDR %sp, %reg0, 100, 0, %cpsr; mem:LD4[FixedStack12]; // STR %r0, killed %r6, %reg0, 0, 14, %reg0; mem:ST4[%396](align=8); //; // The first R6 kill is not really a kill since it's killed by a predicated; // instruction which may not be executed. The second R6 def may or may not; // re-define R6 so it's not safe to change it since the last R6 use cannot be; // changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:858,Safety,safe,safe,858,"// If MI's uses have special allocation requirement, don't allow; // any use registers to be changed. Also assume all registers; // used in a call must not be changed (ABI).; // Inline Assembly register uses also cannot be safely changed.; // FIXME: The issue with predicated instruction is more complex. We are being; // conservatively here because the kill markers cannot be trusted after; // if-conversion:; // %r6 = LDR %sp, %reg0, 92, 14, %reg0; mem:LD4[FixedStack14]; // ...; // STR %r0, killed %r6, %reg0, 0, 0, %cpsr; mem:ST4[%395]; // %r6 = LDR %sp, %reg0, 100, 0, %cpsr; mem:LD4[FixedStack12]; // STR %r0, killed %r6, %reg0, 0, 14, %reg0; mem:ST4[%396](align=8); //; // The first R6 kill is not really a kill since it's killed by a predicated; // instruction which may not be executed. The second R6 def may or may not; // re-define R6 so it's not safe to change it since the last R6 use cannot be; // changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:51,Deployability,update,update,51,"// Scan the register uses for this instruction and update; // live-ranges, groups and RegRefs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:143,Integrability,depend,dependence,143,// Collect all referenced registers in the same group as; // AntiDepReg. These all need to be renamed together if we are to; // break the anti-dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:107,Testability,assert,assert,107,"// FIXME: remove this once PR18663 has been properly fixed. For now,; // return a conservative answer:; // assert(IsSub && ""Expecting group subregister"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:98,Availability,avail,available,98,"// Check each possible rename register for SuperReg in round-robin; // order. If that register is available, and the corresponding; // registers are available for the other group subregisters, then we; // can use those registers to rename.; // FIXME: Using getMinimalPhysRegClass is very conservative. We should; // check every use of the register and find the largest register class; // that can be used in all of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:149,Availability,avail,available,149,"// Check each possible rename register for SuperReg in round-robin; // order. If that register is available, and the corresponding; // registers are available for the other group subregisters, then we; // can use those registers to rename.; // FIXME: Using getMinimalPhysRegClass is very conservative. We should; // check every use of the register and find the largest register class; // that can be used in all of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:86,Safety,safe,safe,86,"// If NewReg is dead and NewReg's most recent def is not before; // Regs's kill, it's safe to replace Reg with NewReg. We; // must also check all aliases of NewReg, because we can't define a; // register when any sub or super is already live.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:29,Availability,avail,available,29,// No registers are free and available!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:72,Energy Efficiency,Schedul,ScheduleDAG,72,/// BreakAntiDependencies - Identifiy anti-dependencies within the; /// ScheduleDAG and break them by renaming registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:43,Integrability,depend,dependencies,43,/// BreakAntiDependencies - Identifiy anti-dependencies within the; /// ScheduleDAG and break them by renaming registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:168,Integrability,depend,dependencies,168,// Track progress along the critical path through the SUnit graph as; // we walk the instructions. This is needed for regclasses that only; // break critical-path anti-dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:176,Availability,avail,available,176,"// Attempt to break anti-dependence edges. Walk the instructions; // from the bottom up, tracking information about liveness as we go; // to help determine which registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:25,Integrability,depend,dependence,25,"// Attempt to break anti-dependence edges. Walk the instructions; // from the bottom up, tracking information about liveness as we go; // to help determine which registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:7,Integrability,depend,dependence,7,// The dependence edges that represent anti- and output-; // dependencies that are candidates for breaking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:61,Integrability,depend,dependencies,61,// The dependence edges that represent anti- and output-; // dependencies that are candidates for breaking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:95,Integrability,depend,dependence,95,// Ignore KILL instructions (they form a group in ScanInstruction; // but don't cause any anti-dependence breaking themselves),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:30,Integrability,depend,dependency,30,// Attempt to break each anti-dependency...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:20,Integrability,depend,dependencies,20,// Don't break anti-dependencies on non-allocatable registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:20,Integrability,depend,dependencies,20,// Don't break anti-dependencies for critical path registers; // if not on the critical path,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:185,Energy Efficiency,schedul,scheduled,185,"// If the SUnit has other dependencies on the SUnit that; // it anti-depends on, don't bother breaking the; // anti-dependency since those edges would prevent such; // units from being scheduled past each other; // regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:26,Integrability,depend,dependencies,26,"// If the SUnit has other dependencies on the SUnit that; // it anti-depends on, don't bother breaking the; // anti-dependency since those edges would prevent such; // units from being scheduled past each other; // regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:69,Integrability,depend,depends,69,"// If the SUnit has other dependencies on the SUnit that; // it anti-depends on, don't bother breaking the; // anti-dependency since those edges would prevent such; // units from being scheduled past each other; // regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:116,Integrability,depend,dependency,116,"// If the SUnit has other dependencies on the SUnit that; // it anti-depends on, don't bother breaking the; // anti-dependency since those edges would prevent such; // units from being scheduled past each other; // regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:254,Integrability,depend,dependencies,254,"// If the SUnit has other dependencies on the SUnit that; // it anti-depends on, don't bother breaking the; // anti-dependency since those edges would prevent such; // units from being scheduled past each other; // regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:322,Integrability,depend,dependency,322,"// If the SUnit has other dependencies on the SUnit that; // it anti-depends on, don't bother breaking the; // anti-dependency since those edges would prevent such; // units from being scheduled past each other; // regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:57,Integrability,depend,dependence,57,// Look for a suitable register to use to break the anti-dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:3,Deployability,Update,Update,3,// Update the references to the old register CurrReg to; // refer to the new register NewReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:39,Deployability,update,updated,39,"// If the SU for the instruction being updated has debug; // information related to the anti-dependency register, make; // sure to update that as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:131,Deployability,update,update,131,"// If the SU for the instruction being updated has debug; // information related to the anti-dependency register, make; // sure to update that as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:93,Integrability,depend,dependency,93,"// If the SU for the instruction being updated has debug; // information related to the anti-dependency register, make; // sure to update that as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h:514,Energy Efficiency,schedul,scheduling,514,"//==- llvm/CodeGen/AggressiveAntiDepBreaker.h - Anti-Dep Support -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the AggressiveAntiDepBreaker class, which; // implements register anti-dependence breaking during post-RA; // scheduling. It attempts to break all anti-dependencies within a; // block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h:475,Integrability,depend,dependence,475,"//==- llvm/CodeGen/AggressiveAntiDepBreaker.h - Anti-Dep Support -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the AggressiveAntiDepBreaker class, which; // implements register anti-dependence breaking during post-RA; // scheduling. It attempts to break all anti-dependencies within a; // block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h:556,Integrability,depend,dependencies,556,"//==- llvm/CodeGen/AggressiveAntiDepBreaker.h - Anti-Dep Support -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the AggressiveAntiDepBreaker class, which; // implements register anti-dependence breaking during post-RA; // scheduling. It attempts to break all anti-dependencies within a; // block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h:47,Integrability,depend,dependence,47,/// The state used to identify and rename anti-dependence registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h:68,Energy Efficiency,Schedul,ScheduleDAG,68,/// Identifiy anti-dependencies along the critical path; /// of the ScheduleDAG and break them by renaming registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h:19,Integrability,depend,dependencies,19,/// Identifiy anti-dependencies along the critical path; /// of the ScheduleDAG and break them by renaming registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h:4,Deployability,Update,Update,4,"/// Update liveness information to account for the current; /// instruction, which will not be scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h:95,Energy Efficiency,schedul,scheduled,95,"/// Update liveness information to account for the current; /// instruction, which will not be scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.cpp:509,Integrability,depend,depends,509,"//===-- llvm/CodeGen/AllocationOrder.cpp - Allocation Order ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements an allocation order for virtual registers.; //; // The preferred allocation order for a virtual register depends on allocation; // hints and target hooks. The AllocationOrder class encapsulates all of that.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.h:509,Integrability,depend,depends,509,"//===-- llvm/CodeGen/AllocationOrder.h - Allocation Order -*- C++ -*-------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements an allocation order for virtual registers.; //; // The preferred allocation order for a virtual register depends on allocation; // hints and target hooks. The AllocationOrder class encapsulates all of that.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.h:301,Safety,avoid,avoid,301,"// How far into the Order we can iterate. This is 0 if the AllocationOrder is; // constructed with HardHints = true, Order.size() otherwise. While; // technically a size_t, it will participate in comparisons with the; // Iterator's Pos, which must be signed, so it's typed here as signed, too, to; // avoid warnings and under the assumption that the size of Order is; // relatively small.; // IterationLimit defines an invalid iterator position.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.h:86,Energy Efficiency,allocate,allocate,86,/// Create a new AllocationOrder for VirtReg.; /// @param VirtReg Virtual register to allocate for.; /// @param VRM Virtual register map for function.; /// @param RegClassInfo Information about reserved and allocatable registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:107,Performance,scalab,scalable,107,"// If the Offsets aren't needed, don't query the struct layout. This allows; // us to support structs with scalable vectors for operations that don't; // need offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:107,Performance,scalab,scalable,107,"// If the Offsets aren't needed, don't query the struct layout. This allows; // us to support structs with scalable vectors for operations that don't; // need offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:370,Deployability,update,updated,370,"/// Look through operations that will be free to find the earliest source of; /// this value.; ///; /// @param ValLoc If V has aggregate type, we will be interested in a particular; /// scalar component. This records its address; the reverse of this list gives a; /// sequence of indices appropriate for an extractvalue to locate the important; /// value. This value is updated during the function and on exit will indicate; /// similar information for the Value returned.; ///; /// @param DataBits If this function looks through truncate instructions, this; /// will record the smallest size attained.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:67,Modifiability,extend,extending,67,"// Look through inttoptr.; // Make sure this isn't a truncating or extending cast. We could; // support this eventually, but don't bother for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:67,Modifiability,extend,extending,67,"// Look through ptrtoint.; // Make sure this isn't a truncating or extending cast. We could; // support this eventually, but don't bother for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:175,Usability,simpl,simple,175,"// Trace the sub-value needed by the return value as far back up the graph as; // possible, in the hope that it will intersect with the value produced by the; // call. In the simple case with no ""returned"" attribute, the hope is actually; // that we end up back at the tail call instruction itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:132,Usability,simpl,simple,132,"// Now do a similar search up through the graph to find where the value; // actually returned by the ""tail call"" comes from. In the simple case without; // a ""returned"" attribute, the search will be blocked immediately and the loop; // a Noop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:87,Performance,Perform,Performs,87,"/// Move the given iterators to the next leaf type in depth first traversal.; ///; /// Performs a depth-first traversal of the type as specified by its arguments,; /// stopping at the next leaf node (which may be a legitimate scalar type or an; /// empty struct or array).; ///; /// @param SubTypes List of the partial components making up the type from; /// outermost to innermost non-empty aggregate. The element currently; /// represented is SubTypes.back()->getTypeAtIndex(Path.back() - 1).; ///; /// @param Path Set of extractvalue indices leading from the outermost type; /// (SubTypes[0]) to the leaf node currently represented.; ///; /// @returns true if a new type was found, false otherwise. Calling this; /// function again on a finished iterator will repeatedly return; /// false. SubTypes.back()->getTypeAtIndex(Path.back()) is either an empty; /// aggregate or a non-aggregate",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:56,Availability,down,down,56,"// We know there's *some* valid leaf now, so march back down the tree picking; // out the left-most element at each node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:186,Energy Efficiency,schedul,scheduled,186,/// Test if the given instruction is in a position to be optimized; /// with a tail-call. This roughly means that it's in a block with; /// a return and there's nothing that needs to be scheduled; /// between it and the return.; ///; /// This function only tests target-independent requirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:57,Performance,optimiz,optimized,57,/// Test if the given instruction is in a position to be optimized; /// with a tail-call. This roughly means that it's in a block with; /// a return and there's nothing that needs to be scheduled; /// between it and the return.; ///; /// This function only tests target-independent requirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:4,Testability,Test,Test,4,/// Test if the given instruction is in a position to be optimized; /// with a tail-call. This roughly means that it's in a block with; /// a return and there's nothing that needs to be scheduled; /// between it and the return.; ///; /// This function only tests target-independent requirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:257,Testability,test,tests,257,/// Test if the given instruction is in a position to be optimized; /// with a tail-call. This roughly means that it's in a block with; /// a return and there's nothing that needs to be scheduled; /// between it and the return.; ///; /// This function only tests target-independent requirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:186,Performance,optimiz,optimization,186,"// The block must end in a return statement or unreachable.; //; // FIXME: Decline tailcall if it's not guaranteed and if the block ends in; // an unreachable, for now. The way tailcall optimization is currently; // implemented means it will add an epilogue followed by a jump. That is; // not profitable. Also, if the callee is a special function (e.g.; // longjmp on x86), it can end up causing miscompilation that has not; // been fully understood.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:60,Performance,optimiz,optimization,60,// Debug info intrinsics do not get in the way of tail call optimization.; // Pseudo probe intrinsics do not block tail call optimization either.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:125,Performance,optimiz,optimization,125,// Debug info intrinsics do not get in the way of tail call optimization.; // Pseudo probe intrinsics do not block tail call optimization either.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:82,Performance,optimiz,optimization,82,"// A lifetime end, assume or noalias.decl intrinsic should not stop tail; // call optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:155,Safety,safe,safe,155,"// If they're still different, there's some facet we don't understand; // (currently only ""inreg"", but in future who knows). It may be OK but the; // only safe option is to reject the tail call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:192,Energy Efficiency,efficient,efficient,192,"// The manipulations performed when we're looking through an insertvalue or; // an extractvalue would happen at the front of the RetPath list, so since; // we have to copy it anyway it's more efficient to create a reversed copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:21,Performance,perform,performed,21,"// The manipulations performed when we're looking through an insertvalue or; // an extractvalue would happen at the front of the RetPath list, so since; // we have to copy it anyway it's more efficient to create a reversed copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:120,Modifiability,variab,variable,120,"/// Option for debugging the pass, determines if the memory location fragment; /// filling happens after generating the variable locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:101,Energy Efficiency,reduce,reduces,101,/// Coalesce adjacent dbg locs describing memory locations that have contiguous; /// fragments. This reduces the cost of LiveDebugValues which does SSA; /// construction for each explicitly stated variable fragment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:197,Modifiability,variab,variable,197,/// Coalesce adjacent dbg locs describing memory locations that have contiguous; /// fragments. This reduces the cost of LiveDebugValues which does SSA; /// construction for each explicitly stated variable fragment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:113,Integrability,wrap,wrapper,113,"// Implicit conversions are disabled for enum class types, so unfortunately we; // need to create a DenseMapInfo wrapper around the specified underlying type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:10,Modifiability,variab,variable,10,/// Get a variable from its \p ID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:20,Modifiability,variab,variable,20,/// Add a def for a variable that is valid for its lifetime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:13,Modifiability,variab,variable,13,// Print the variable table first. TODO: Sorting by variable could make the; // output more stable?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:52,Modifiability,variab,variable,52,// Print the variable table first. TODO: Sorting by variable could make the; // output more stable?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:29,Modifiability,variab,variables,29,// Print the single location variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:27,Modifiability,variab,variables,27,// Add the single-location variables first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:108,Availability,redundant,redundant,108,"// Even though DPV defines a variable location, VarLocsBeforeInst can; // still be empty if that VarLoc was redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:29,Modifiability,variab,variable,29,"// Even though DPV defines a variable location, VarLocsBeforeInst can; // still be empty if that VarLoc was redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:108,Safety,redund,redundant,108,"// Even though DPV defines a variable location, VarLocsBeforeInst can; // still be empty if that VarLoc was redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:12,Modifiability,Variab,Variables,12,// Copy the Variables vector from the builder's UniqueVector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:34,Modifiability,variab,variable,34,/// A whole (unfragmented) source variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:32,Energy Efficiency,reduce,reduces,32,"// Enabling fragment coalescing reduces compiler run time when instruction; // referencing is enabled. However, it may cause LiveDebugVariables to create; // incorrect locations. Since instruction-referencing mode effectively; // bypasses LiveDebugVariables we only enable coalescing if the cl::opt flag; // has not been explicitly set and instruction-referencing is turned on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:631,Availability,recover,recover,631,"/// In dwarf emission, the following sequence; /// 1. dbg.value ... Fragment(0, 64); /// 2. dbg.value ... Fragment(0, 32); /// effectively sets Fragment(32, 32) to undef (each def sets all bits not in; /// the intersection of the fragments to having ""no location""). This makes; /// sense for implicit location values because splitting the computed values; /// could be troublesome, and is probably quite uncommon. When we convert; /// dbg.assigns to dbg.value+deref this kind of thing is common, and describing; /// a location (memory) rather than a value means we don't need to worry about; /// splitting any values, so we try to recover the rest of the fragment; /// location here.; /// This class performs a(nother) dataflow analysis over the function, adding; /// variable locations so that any bits of a variable with a memory location; /// have that location explicitly reinstated at each subsequent variable; /// location definition that that doesn't overwrite those bits. i.e. after a; /// variable location def, insert new defs for the memory location with; /// fragments for the difference of ""all bits currently in memory"" and ""the; /// fragment of the second def"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:768,Modifiability,variab,variable,768,"/// In dwarf emission, the following sequence; /// 1. dbg.value ... Fragment(0, 64); /// 2. dbg.value ... Fragment(0, 32); /// effectively sets Fragment(32, 32) to undef (each def sets all bits not in; /// the intersection of the fragments to having ""no location""). This makes; /// sense for implicit location values because splitting the computed values; /// could be troublesome, and is probably quite uncommon. When we convert; /// dbg.assigns to dbg.value+deref this kind of thing is common, and describing; /// a location (memory) rather than a value means we don't need to worry about; /// splitting any values, so we try to recover the rest of the fragment; /// location here.; /// This class performs a(nother) dataflow analysis over the function, adding; /// variable locations so that any bits of a variable with a memory location; /// have that location explicitly reinstated at each subsequent variable; /// location definition that that doesn't overwrite those bits. i.e. after a; /// variable location def, insert new defs for the memory location with; /// fragments for the difference of ""all bits currently in memory"" and ""the; /// fragment of the second def"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:809,Modifiability,variab,variable,809,"/// In dwarf emission, the following sequence; /// 1. dbg.value ... Fragment(0, 64); /// 2. dbg.value ... Fragment(0, 32); /// effectively sets Fragment(32, 32) to undef (each def sets all bits not in; /// the intersection of the fragments to having ""no location""). This makes; /// sense for implicit location values because splitting the computed values; /// could be troublesome, and is probably quite uncommon. When we convert; /// dbg.assigns to dbg.value+deref this kind of thing is common, and describing; /// a location (memory) rather than a value means we don't need to worry about; /// splitting any values, so we try to recover the rest of the fragment; /// location here.; /// This class performs a(nother) dataflow analysis over the function, adding; /// variable locations so that any bits of a variable with a memory location; /// have that location explicitly reinstated at each subsequent variable; /// location definition that that doesn't overwrite those bits. i.e. after a; /// variable location def, insert new defs for the memory location with; /// fragments for the difference of ""all bits currently in memory"" and ""the; /// fragment of the second def"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:906,Modifiability,variab,variable,906,"/// In dwarf emission, the following sequence; /// 1. dbg.value ... Fragment(0, 64); /// 2. dbg.value ... Fragment(0, 32); /// effectively sets Fragment(32, 32) to undef (each def sets all bits not in; /// the intersection of the fragments to having ""no location""). This makes; /// sense for implicit location values because splitting the computed values; /// could be troublesome, and is probably quite uncommon. When we convert; /// dbg.assigns to dbg.value+deref this kind of thing is common, and describing; /// a location (memory) rather than a value means we don't need to worry about; /// splitting any values, so we try to recover the rest of the fragment; /// location here.; /// This class performs a(nother) dataflow analysis over the function, adding; /// variable locations so that any bits of a variable with a memory location; /// have that location explicitly reinstated at each subsequent variable; /// location definition that that doesn't overwrite those bits. i.e. after a; /// variable location def, insert new defs for the memory location with; /// fragments for the difference of ""all bits currently in memory"" and ""the; /// fragment of the second def"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:998,Modifiability,variab,variable,998,"/// In dwarf emission, the following sequence; /// 1. dbg.value ... Fragment(0, 64); /// 2. dbg.value ... Fragment(0, 32); /// effectively sets Fragment(32, 32) to undef (each def sets all bits not in; /// the intersection of the fragments to having ""no location""). This makes; /// sense for implicit location values because splitting the computed values; /// could be troublesome, and is probably quite uncommon. When we convert; /// dbg.assigns to dbg.value+deref this kind of thing is common, and describing; /// a location (memory) rather than a value means we don't need to worry about; /// splitting any values, so we try to recover the rest of the fragment; /// location here.; /// This class performs a(nother) dataflow analysis over the function, adding; /// variable locations so that any bits of a variable with a memory location; /// have that location explicitly reinstated at each subsequent variable; /// location definition that that doesn't overwrite those bits. i.e. after a; /// variable location def, insert new defs for the memory location with; /// fragments for the difference of ""all bits currently in memory"" and ""the; /// fragment of the second def"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:700,Performance,perform,performs,700,"/// In dwarf emission, the following sequence; /// 1. dbg.value ... Fragment(0, 64); /// 2. dbg.value ... Fragment(0, 32); /// effectively sets Fragment(32, 32) to undef (each def sets all bits not in; /// the intersection of the fragments to having ""no location""). This makes; /// sense for implicit location values because splitting the computed values; /// could be troublesome, and is probably quite uncommon. When we convert; /// dbg.assigns to dbg.value+deref this kind of thing is common, and describing; /// a location (memory) rather than a value means we don't need to worry about; /// splitting any values, so we try to recover the rest of the fragment; /// location here.; /// This class performs a(nother) dataflow analysis over the function, adding; /// variable locations so that any bits of a variable with a memory location; /// have that location explicitly reinstated at each subsequent variable; /// location definition that that doesn't overwrite those bits. i.e. after a; /// variable location def, insert new defs for the memory location with; /// fragments for the difference of ""all bits currently in memory"" and ""the; /// fragment of the second def"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:631,Safety,recover,recover,631,"/// In dwarf emission, the following sequence; /// 1. dbg.value ... Fragment(0, 64); /// 2. dbg.value ... Fragment(0, 32); /// effectively sets Fragment(32, 32) to undef (each def sets all bits not in; /// the intersection of the fragments to having ""no location""). This makes; /// sense for implicit location values because splitting the computed values; /// could be troublesome, and is probably quite uncommon. When we convert; /// dbg.assigns to dbg.value+deref this kind of thing is common, and describing; /// a location (memory) rather than a value means we don't need to worry about; /// splitting any values, so we try to recover the rest of the fragment; /// location here.; /// This class performs a(nother) dataflow analysis over the function, adding; /// variable locations so that any bits of a variable with a memory location; /// have that location explicitly reinstated at each subsequent variable; /// location definition that that doesn't overwrite those bits. i.e. after a; /// variable location def, insert new defs for the memory location with; /// fragments for the difference of ""all bits currently in memory"" and ""the; /// fragment of the second def"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:129,Deployability,update,updated,129,"/// BBInsertBeforeMap holds a description for the set of location defs to be; /// inserted after the analysis is complete. It is updated during the dataflow; /// and the entry for a block is CLEARED each time it is (re-)visited. After; /// the dataflow is complete, each block entry will contain the set of defs; /// calculated during the final (fixed-point) iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:191,Usability,CLEAR,CLEARED,191,"/// BBInsertBeforeMap holds a description for the set of location defs to be; /// inserted after the analysis is complete. It is updated during the dataflow; /// and the entry for a block is CLEARED each time it is (re-)visited. After; /// the dataflow is complete, each block entry will contain the set of defs; /// calculated during the final (fixed-point) iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:72,Performance,perform,performing,72,// This is basically copied from process() and inverted (process is; // performing something like a union whereas this is more of an; // intersect).; // There's no work to do if interval `a` overlaps no fragments in map `B`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:102,Modifiability,variab,variables,102,// Ignore preds that haven't been processed yet. This is essentially the; // same as initialising all variables to implicit top value (⊤) which is; // the identity value for the meet operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:51,Deployability,update,update,51,// If the LiveIn set has changed (expensive check) update it and return; // true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:320,Availability,redundant,redundant,320,// We've inserted the location into the map. The map will have coalesced; // adjacent intervals (variable fragments) that describe the same memory; // location. Use this knowledge to insert a debug location that describes; // that coalesced fragment. This may eclipse other locs we've just; // inserted. This is okay as redundant locs will be cleaned up later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:97,Modifiability,variab,variable,97,// We've inserted the location into the map. The map will have coalesced; // adjacent intervals (variable fragments) that describe the same memory; // location. Use this knowledge to insert a debug location that describes; // that coalesced fragment. This may eclipse other locs we've just; // inserted. This is okay as redundant locs will be cleaned up later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:320,Safety,redund,redundant,320,// We've inserted the location into the map. The map will have coalesced; // adjacent intervals (variable fragments) that describe the same memory; // location. Use this knowledge to insert a debug location that describes; // that coalesced fragment. This may eclipse other locs we've just; // inserted. This is okay as redundant locs will be cleaned up later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:40,Modifiability,variab,variables,40,// Don't bother doing anything for this variables if we know it's fully; // promoted. We're only interested in variables that (sometimes) live on; // the stack here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:111,Modifiability,variab,variables,111,// Don't bother doing anything for this variables if we know it's fully; // promoted. We're only interested in variables that (sometimes) live on; // the stack here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:463,Modifiability,variab,variable,463,"// We will only fill fragments for simple memory-describing dbg.value; // intrinsics. If the fragment offset is the same as the offset from the; // base pointer, do The Thing, otherwise fall back to normal dbg.value; // behaviour. AssignmentTrackingLowering has generated DIExpressions; // written in terms of the base pointer.; // TODO: Remove this condition since the fragment offset doesn't always; // equal the offset from base pointer (e.g. for a SROA-split variable).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:35,Usability,simpl,simple,35,"// We will only fill fragments for simple memory-describing dbg.value; // intrinsics. If the fragment offset is the same as the offset from the; // base pointer, do The Thing, otherwise fall back to normal dbg.value; // behaviour. AssignmentTrackingLowering has generated DIExpressions; // written in terms of the base pointer.; // TODO: Remove this condition since the fragment offset doesn't always; // equal the offset from base pointer (e.g. for a SROA-split variable).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:16,Modifiability,variab,variable,16,// Check if the variable does not exist in the map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:12,Modifiability,variab,variable,12,// Add this variable to the BB map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:7,Modifiability,variab,variable,7,// The variable has an entry in the map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:8,Modifiability,variab,variable,8,"/// Add variable locations to \p FnVarLocs so that any bits of a variable; /// with a memory location have that location explicitly reinstated at each; /// subsequent variable location definition that that doesn't overwrite those; /// bits. i.e. after a variable location def, insert new defs for the memory; /// location with fragments for the difference of ""all bits currently in; /// memory"" and ""the fragment of the second def"". e.g.; ///; /// Before:; ///; /// var x bits 0 to 63: value in memory; /// more instructions; /// var x bits 0 to 31: value is %0; ///; /// After:; ///; /// var x bits 0 to 63: value in memory; /// more instructions; /// var x bits 0 to 31: value is %0; /// var x bits 32 to 61: value in memory ; <-- new loc def; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:65,Modifiability,variab,variable,65,"/// Add variable locations to \p FnVarLocs so that any bits of a variable; /// with a memory location have that location explicitly reinstated at each; /// subsequent variable location definition that that doesn't overwrite those; /// bits. i.e. after a variable location def, insert new defs for the memory; /// location with fragments for the difference of ""all bits currently in; /// memory"" and ""the fragment of the second def"". e.g.; ///; /// Before:; ///; /// var x bits 0 to 63: value in memory; /// more instructions; /// var x bits 0 to 31: value is %0; ///; /// After:; ///; /// var x bits 0 to 63: value in memory; /// more instructions; /// var x bits 0 to 31: value is %0; /// var x bits 32 to 61: value in memory ; <-- new loc def; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:167,Modifiability,variab,variable,167,"/// Add variable locations to \p FnVarLocs so that any bits of a variable; /// with a memory location have that location explicitly reinstated at each; /// subsequent variable location definition that that doesn't overwrite those; /// bits. i.e. after a variable location def, insert new defs for the memory; /// location with fragments for the difference of ""all bits currently in; /// memory"" and ""the fragment of the second def"". e.g.; ///; /// Before:; ///; /// var x bits 0 to 63: value in memory; /// more instructions; /// var x bits 0 to 31: value is %0; ///; /// After:; ///; /// var x bits 0 to 63: value in memory; /// more instructions; /// var x bits 0 to 31: value is %0; /// var x bits 32 to 61: value in memory ; <-- new loc def; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:254,Modifiability,variab,variable,254,"/// Add variable locations to \p FnVarLocs so that any bits of a variable; /// with a memory location have that location explicitly reinstated at each; /// subsequent variable location definition that that doesn't overwrite those; /// bits. i.e. after a variable location def, insert new defs for the memory; /// location with fragments for the difference of ""all bits currently in; /// memory"" and ""the fragment of the second def"". e.g.; ///; /// Before:; ///; /// var x bits 0 to 63: value in memory; /// more instructions; /// var x bits 0 to 31: value is %0; ///; /// After:; ///; /// var x bits 0 to 63: value in memory; /// more instructions; /// var x bits 0 to 31: value is %0; /// var x bits 32 to 61: value in memory ; <-- new loc def; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:3,Performance,Perform,Perform,3,"// Perform the traversal.; //; // This is a standard ""intersect of predecessor outs"" dataflow problem. To; // solve it, we perform meet() and process() using the two worklist method; // until the LiveIn data for each block becomes unchanging.; //; // This dataflow is essentially working on maps of sets and at each meet we; // intersect the maps and the mapped sets. So, initialized live-in maps; // monotonically decrease in value throughout the dataflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:123,Performance,perform,perform,123,"// Perform the traversal.; //; // This is a standard ""intersect of predecessor outs"" dataflow problem. To; // solve it, we perform meet() and process() using the two worklist method; // until the LiveIn data for each block becomes unchanging.; //; // This dataflow is essentially working on maps of sets and at each meet we; // intersect the maps and the mapped sets. So, initialized live-in maps; // monotonically decrease in value throughout the dataflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:132,Performance,queue,queue,132,"// We track what is on the pending worklist to avoid inserting the same; // thing twice. We could avoid this with a custom priority queue, but; // this is probably not worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:47,Safety,avoid,avoid,47,"// We track what is on the pending worklist to avoid inserting the same; // thing twice. We could avoid this with a custom priority queue, but; // this is probably not worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:98,Safety,avoid,avoid,98,"// We track what is on the pending worklist to avoid inserting the same; // thing twice. We could avoid this with a custom priority queue, but; // this is probably not worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:182,Modifiability,variab,variable,182,/// AssignmentTrackingLowering encapsulates a dataflow analysis over a function; /// that interprets assignment tracking debug info metadata and stores in IR to; /// create a map of variable locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:918,Availability,recover,recovered,918,"/// The kind of location in use for a variable, where Mem is the stack home,; /// Val is an SSA value or const, and None means that there is not one single; /// kind (either because there are multiple or because there is none; it may; /// prove useful to split this into two values in the future).; ///; /// LocKind is a join-semilattice with the partial order:; /// None > Mem, Val; ///; /// i.e.; /// join(Mem, Mem) = Mem; /// join(Val, Val) = Val; /// join(Mem, Val) = None; /// join(None, Mem) = None; /// join(None, Val) = None; /// join(None, None) = None; ///; /// Note: the order is not `None > Val > Mem` because we're using DIAssignID; /// to name assignments and are not tracking the actual stored values.; /// Therefore currently there's no way to ensure that Mem values and Val; /// values are the same. This could be a future extension, though it's not; /// clear that many additional locations would be recovered that way in; /// practice as the likelihood of this sitation arising naturally seems; /// incredibly low.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:38,Modifiability,variab,variable,38,"/// The kind of location in use for a variable, where Mem is the stack home,; /// Val is an SSA value or const, and None means that there is not one single; /// kind (either because there are multiple or because there is none; it may; /// prove useful to split this into two values in the future).; ///; /// LocKind is a join-semilattice with the partial order:; /// None > Mem, Val; ///; /// i.e.; /// join(Mem, Mem) = Mem; /// join(Val, Val) = Val; /// join(Mem, Val) = None; /// join(None, Mem) = None; /// join(None, Val) = None; /// join(None, None) = None; ///; /// Note: the order is not `None > Val > Mem` because we're using DIAssignID; /// to name assignments and are not tracking the actual stored values.; /// Therefore currently there's no way to ensure that Mem values and Val; /// values are the same. This could be a future extension, though it's not; /// clear that many additional locations would be recovered that way in; /// practice as the likelihood of this sitation arising naturally seems; /// incredibly low.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:918,Safety,recover,recovered,918,"/// The kind of location in use for a variable, where Mem is the stack home,; /// Val is an SSA value or const, and None means that there is not one single; /// kind (either because there are multiple or because there is none; it may; /// prove useful to split this into two values in the future).; ///; /// LocKind is a join-semilattice with the partial order:; /// None > Mem, Val; ///; /// i.e.; /// join(Mem, Mem) = Mem; /// join(Val, Val) = Val; /// join(Mem, Val) = None; /// join(None, Mem) = None; /// join(None, Val) = None; /// join(None, None) = None; ///; /// Note: the order is not `None > Val > Mem` because we're using DIAssignID; /// to name assignments and are not tracking the actual stored values.; /// Therefore currently there's no way to ensure that Mem values and Val; /// values are the same. This could be a future extension, though it's not; /// clear that many additional locations would be recovered that way in; /// practice as the likelihood of this sitation arising naturally seems; /// incredibly low.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:872,Usability,clear,clear,872,"/// The kind of location in use for a variable, where Mem is the stack home,; /// Val is an SSA value or const, and None means that there is not one single; /// kind (either because there are multiple or because there is none; it may; /// prove useful to split this into two values in the future).; ///; /// LocKind is a join-semilattice with the partial order:; /// None > Mem, Val; ///; /// i.e.; /// join(Mem, Mem) = Mem; /// join(Val, Val) = Val; /// join(Mem, Val) = None; /// join(None, Mem) = None; /// join(None, Val) = None; /// join(None, None) = None; ///; /// Note: the order is not `None > Val > Mem` because we're using DIAssignID; /// to name assignments and are not tracking the actual stored values.; /// Therefore currently there's no way to ensure that Mem values and Val; /// values are the same. This could be a future extension, though it's not; /// clear that many additional locations would be recovered that way in; /// practice as the likelihood of this sitation arising naturally seems; /// incredibly low.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:53,Modifiability,variab,variable,53,"/// An abstraction of the assignment of a value to a variable or memory; /// location.; ///; /// An Assignment is Known or NoneOrPhi. A Known Assignment means we have a; /// DIAssignID ptr that represents it. NoneOrPhi means that we don't (or; /// can't) know the ID of the last assignment that took place.; ///; /// The Status of the Assignment (Known or NoneOrPhi) is another; /// join-semilattice. The partial order is:; /// NoneOrPhi > Known {id_0, id_1, ...id_N}; ///; /// i.e. for all values x and y where x != y:; /// join(x, x) = x; /// join(x, y) = NoneOrPhi",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:25,Modifiability,Variab,VariableID,25,"/// The highest numbered VariableID for partially promoted variables plus 1,; /// the values for which start at 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:59,Modifiability,variab,variables,59,"/// The highest numbered VariableID for partially promoted variables plus 1,; /// the values for which start at 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:10,Modifiability,variab,variable,10,/// Map a variable to the set of variables that it fully contains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:33,Modifiability,variab,variables,33,/// Map a variable to the set of variables that it fully contains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:31,Modifiability,variab,variable,31,/// Map untagged stores to the variable fragments they assign to. Used by; /// processUntaggedInstruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:45,Performance,cache,cached,45,/// Clear the location definitions currently cached for insertion after /p; /// After.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:4,Usability,Clear,Clear,4,/// Clear the location definitions currently cached for insertion after /p; /// After.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:210,Integrability,interface,interface,210,"// emitDbgValue can be called with:; // Source=[AssignRecord|DbgValueInst*|DbgAssignIntrinsic*|DPValue*]; // Since AssignRecord can be cast to one of the latter two types, and all; // other types have a shared interface, we use a template to handle the latter; // three types, and an explicit overload for AssignRecord that forwards to; // the template version with the right type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:15,Modifiability,variab,variables,15,/// The set of variables (VariableID) being tracked in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:26,Modifiability,Variab,VariableID,26,/// The set of variables (VariableID) being tracked in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:45,Modifiability,variab,variable,45,"/// Dominating assignment to memory for each variable, indexed by; /// VariableID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:71,Modifiability,Variab,VariableID,71,"/// Dominating assignment to memory for each variable, indexed by; /// VariableID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:34,Modifiability,variab,variable,34,"/// Dominating assignemnt to each variable, indexed by VariableID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:55,Modifiability,Variab,VariableID,55,"/// Dominating assignemnt to each variable, indexed by VariableID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:27,Modifiability,variab,variable,27,"/// Location kind for each variable. LiveLoc indicates whether the; /// dominating assignment in StackHomeValue (LocKind::Mem), DebugValue; /// (LocKind::Val), or neither (LocKind::None) is valid, in that order of; /// preference. This cannot be derived by inspecting DebugValue and; /// StackHomeValue due to the fact that there's no distinction in; /// Assignment (the class) between whether an assignment is unknown or a; /// merge of multiple assignments (both are Status::NoneOrPhi). In other; /// words, the memory location may well be valid while both DebugValue and; /// StackHomeValue contain Assignments that have a Status of NoneOrPhi.; /// Indexed by VariableID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:663,Modifiability,Variab,VariableID,663,"/// Location kind for each variable. LiveLoc indicates whether the; /// dominating assignment in StackHomeValue (LocKind::Mem), DebugValue; /// (LocKind::Val), or neither (LocKind::None) is valid, in that order of; /// preference. This cannot be derived by inspecting DebugValue and; /// StackHomeValue due to the fact that there's no distinction in; /// Assignment (the class) between whether an assignment is unknown or a; /// merge of multiple assignments (both are Status::NoneOrPhi). In other; /// words, the memory location may well be valid while both DebugValue and; /// StackHomeValue contain Assignments that have a Status of NoneOrPhi.; /// Indexed by VariableID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:58,Modifiability,Variab,VariableIDs,58,/// Set LocKind for \p Var only: does not set LocKind for VariableIDs of; /// fragments contained win \p Var.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:107,Modifiability,Variab,VariableIDs,107,/// Set the assignment in the \p Kind assignment map for \p Var only: does; /// not set the assignment for VariableIDs of fragments contained win \p; /// Var.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:123,Modifiability,Variab,VariableIDs,123,/// Return true if there is an assignment matching \p AV in the \p Kind; /// assignment map. Does consider assignments for VariableIDs of fragments; /// contained win \p Var.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:58,Modifiability,variab,variables,58,/// Clear everything and initialise with ⊤-values for all variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:4,Usability,Clear,Clear,4,/// Clear everything and initialise with ⊤-values for all variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:265,Modifiability,variab,variables,265,"// Join A and B.; //; // Intersect = join(a, b) for a in A, b in B where Var(a) == Var(b); // Difference = join(x, ⊤) for x where Var(x) is in A xor B; // Join = Intersect ∪ Difference; //; // This is achieved by performing a join on elements from A and B with; // variables common to both A and B (join elements indexed by var; // intersect), then adding ⊤-value elements for vars in A xor B. The; // latter part is equivalent to performing join on elements with variables; // in A xor B with the ⊤-value for the map element since join(x, ⊤) = ⊤.; // BlockInfo::init initializes all variable entries to the ⊤ value so we; // don't need to explicitly perform that step as Join.VariableIDsInBlock; // is set to the union of the variables in A and B at the end of this; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:464,Modifiability,variab,variables,464,"// Join A and B.; //; // Intersect = join(a, b) for a in A, b in B where Var(a) == Var(b); // Difference = join(x, ⊤) for x where Var(x) is in A xor B; // Join = Intersect ∪ Difference; //; // This is achieved by performing a join on elements from A and B with; // variables common to both A and B (join elements indexed by var; // intersect), then adding ⊤-value elements for vars in A xor B. The; // latter part is equivalent to performing join on elements with variables; // in A xor B with the ⊤-value for the map element since join(x, ⊤) = ⊤.; // BlockInfo::init initializes all variable entries to the ⊤ value so we; // don't need to explicitly perform that step as Join.VariableIDsInBlock; // is set to the union of the variables in A and B at the end of this; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:584,Modifiability,variab,variable,584,"// Join A and B.; //; // Intersect = join(a, b) for a in A, b in B where Var(a) == Var(b); // Difference = join(x, ⊤) for x where Var(x) is in A xor B; // Join = Intersect ∪ Difference; //; // This is achieved by performing a join on elements from A and B with; // variables common to both A and B (join elements indexed by var; // intersect), then adding ⊤-value elements for vars in A xor B. The; // latter part is equivalent to performing join on elements with variables; // in A xor B with the ⊤-value for the map element since join(x, ⊤) = ⊤.; // BlockInfo::init initializes all variable entries to the ⊤ value so we; // don't need to explicitly perform that step as Join.VariableIDsInBlock; // is set to the union of the variables in A and B at the end of this; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:677,Modifiability,Variab,VariableIDsInBlock,677,"// Join A and B.; //; // Intersect = join(a, b) for a in A, b in B where Var(a) == Var(b); // Difference = join(x, ⊤) for x where Var(x) is in A xor B; // Join = Intersect ∪ Difference; //; // This is achieved by performing a join on elements from A and B with; // variables common to both A and B (join elements indexed by var; // intersect), then adding ⊤-value elements for vars in A xor B. The; // latter part is equivalent to performing join on elements with variables; // in A xor B with the ⊤-value for the map element since join(x, ⊤) = ⊤.; // BlockInfo::init initializes all variable entries to the ⊤ value so we; // don't need to explicitly perform that step as Join.VariableIDsInBlock; // is set to the union of the variables in A and B at the end of this; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:727,Modifiability,variab,variables,727,"// Join A and B.; //; // Intersect = join(a, b) for a in A, b in B where Var(a) == Var(b); // Difference = join(x, ⊤) for x where Var(x) is in A xor B; // Join = Intersect ∪ Difference; //; // This is achieved by performing a join on elements from A and B with; // variables common to both A and B (join elements indexed by var; // intersect), then adding ⊤-value elements for vars in A xor B. The; // latter part is equivalent to performing join on elements with variables; // in A xor B with the ⊤-value for the map element since join(x, ⊤) = ⊤.; // BlockInfo::init initializes all variable entries to the ⊤ value so we; // don't need to explicitly perform that step as Join.VariableIDsInBlock; // is set to the union of the variables in A and B at the end of this; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:213,Performance,perform,performing,213,"// Join A and B.; //; // Intersect = join(a, b) for a in A, b in B where Var(a) == Var(b); // Difference = join(x, ⊤) for x where Var(x) is in A xor B; // Join = Intersect ∪ Difference; //; // This is achieved by performing a join on elements from A and B with; // variables common to both A and B (join elements indexed by var; // intersect), then adding ⊤-value elements for vars in A xor B. The; // latter part is equivalent to performing join on elements with variables; // in A xor B with the ⊤-value for the map element since join(x, ⊤) = ⊤.; // BlockInfo::init initializes all variable entries to the ⊤ value so we; // don't need to explicitly perform that step as Join.VariableIDsInBlock; // is set to the union of the variables in A and B at the end of this; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:431,Performance,perform,performing,431,"// Join A and B.; //; // Intersect = join(a, b) for a in A, b in B where Var(a) == Var(b); // Difference = join(x, ⊤) for x where Var(x) is in A xor B; // Join = Intersect ∪ Difference; //; // This is achieved by performing a join on elements from A and B with; // variables common to both A and B (join elements indexed by var; // intersect), then adding ⊤-value elements for vars in A xor B. The; // latter part is equivalent to performing join on elements with variables; // in A xor B with the ⊤-value for the map element since join(x, ⊤) = ⊤.; // BlockInfo::init initializes all variable entries to the ⊤ value so we; // don't need to explicitly perform that step as Join.VariableIDsInBlock; // is set to the union of the variables in A and B at the end of this; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:651,Performance,perform,perform,651,"// Join A and B.; //; // Intersect = join(a, b) for a in A, b in B where Var(a) == Var(b); // Difference = join(x, ⊤) for x where Var(x) is in A xor B; // Join = Intersect ∪ Difference; //; // This is achieved by performing a join on elements from A and B with; // variables common to both A and B (join elements indexed by var; // intersect), then adding ⊤-value elements for vars in A xor B. The; // latter part is equivalent to performing join on elements with variables; // in A xor B with the ⊤-value for the map element since join(x, ⊤) = ⊤.; // BlockInfo::init initializes all variable entries to the ⊤ value so we; // don't need to explicitly perform that step as Join.VariableIDsInBlock; // is set to the union of the variables in A and B at the end of this; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:40,Modifiability,variab,variables,40,/// Helper for process methods to track variables touched each frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:15,Modifiability,variab,variables,15,/// The set of variables that sometimes are not located in their stack home.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:681,Modifiability,variab,variable,681,"///@name joinMethods; /// Functions that implement `join` (the least upper bound) for the; /// join-semilattice types used in the dataflow. There is an explicit bottom; /// value (⊥) for some types and and explicit top value (⊤) for all types.; /// By definition:; ///; /// Join(A, B) >= A && Join(A, B) >= B; /// Join(A, ⊥) = A; /// Join(A, ⊤) = ⊤; ///; /// These invariants are important for monotonicity.; ///; /// For the map-type functions, all unmapped keys in an empty map are; /// associated with a bottom value (⊥). This represents their values being; /// unknown. Unmapped keys in non-empty maps (joining two maps with a key; /// only present in one) represents either a variable going out of scope or; /// dropped debug info. It is assumed the key is associated with a top value; /// (⊤) in this case (unknown location / assignment).; ///@{",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:73,Deployability,update,update,73,///@name processMethods; /// Methods to process instructions in order to update the LiveSet (current; /// location information).; ///@{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:4,Deployability,Update,Update,4,"/// Update \p LiveSet after encountering an instruction with a DIAssignID; /// attachment, \p I.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:4,Deployability,Update,Update,4,"/// Update \p LiveSet after encountering an instruciton without a DIAssignID; /// attachment, \p I.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:40,Modifiability,variab,variable,40,/// Add an assignment to memory for the variable /p Var.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:29,Modifiability,variab,variable,29,/// Add an assignment to the variable /p Var.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:22,Modifiability,Variab,VariableIDs,22,/// Return the set of VariableIDs corresponding the fragments contained fully; /// within the variable/fragment \p Var.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:94,Modifiability,variab,variable,94,/// Return the set of VariableIDs corresponding the fragments contained fully; /// within the variable/fragment \p Var.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:18,Modifiability,variab,variables,18,/// Emit info for variables that are fully promoted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:29,Modifiability,variab,variable,29,"/// Run the analysis, adding variable location info to \p FnVarLocs. Returns; /// true if any variable locations have been added to FnVarLocs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:94,Modifiability,variab,variable,94,"/// Run the analysis, adding variable location info to \p FnVarLocs. Returns; /// true if any variable locations have been added to FnVarLocs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:3,Deployability,Update,Update,3,// Update the LocKind for all fragments contained within Var.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:85,Modifiability,variab,variables,85,"// Interpret stack stores that are not tagged as an assignment in memory for; // the variables associated with that address. These stores may not be tagged; // because a) the store cannot be represented using dbg.assigns (non-const; // length or offset) or b) the tag was accidentally dropped during; // optimisations. For these stores we fall back to assuming that the stack; // home is a valid location for the variables. The benefit is that this; // prevents us missing an assignment and therefore incorrectly maintaining; // earlier location definitions, and in many cases it should be a reasonable; // assumption. However, this will occasionally lead to slight; // inaccuracies. The value of a hoisted untagged store will be visible; // ""early"", for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:413,Modifiability,variab,variables,413,"// Interpret stack stores that are not tagged as an assignment in memory for; // the variables associated with that address. These stores may not be tagged; // because a) the store cannot be represented using dbg.assigns (non-const; // length or offset) or b) the tag was accidentally dropped during; // optimisations. For these stores we fall back to assuming that the stack; // home is a valid location for the variables. The benefit is that this; // prevents us missing an assignment and therefore incorrectly maintaining; // earlier location definitions, and in many cases it should be a reasonable; // assumption. However, this will occasionally lead to slight; // inaccuracies. The value of a hoisted untagged store will be visible; // ""early"", for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:6,Modifiability,variab,variables,6,// No variables associated with the store destination.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:20,Modifiability,variab,variables,20,"// Iterate over the variables that this store affects, add a NoneOrPhi dbg; // and mem def, set lockind to Mem, and emit a location def for each.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:67,Modifiability,variab,variable,67,// Something has gone wrong if VarsWithStackSlot doesn't contain a variable; // that is linked to a store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:46,Modifiability,variab,variable,46,// The StackHomeValue and DebugValue for this variable match so we can; // emit a stack home location here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:46,Modifiability,variab,variable,46,"// The StackHomeValue and DebugValue for this variable do not match. I.e.; // The value currently stored in the stack is not what we'd expect to; // see, so we cannot use emit a stack home location here. Now we will; // look at the live LocKind for the variable and determine an appropriate; // dbg.value to emit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:253,Modifiability,variab,variable,253,"// The StackHomeValue and DebugValue for this variable do not match. I.e.; // The value currently stored in the stack is not what we'd expect to; // see, so we cannot use emit a stack home location here. Now we will; // look at the live LocKind for the variable and determine an appropriate; // dbg.value to emit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:86,Modifiability,variab,variable,86,"// There's been an assignment to memory that we were using as a; // location for this variable, and the Assignment doesn't match what; // we'd expect to see in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:97,Modifiability,variab,variable,97,// There's been an assignment to memory and we currently are; // not tracking a location for the variable. Do not emit anything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:24,Modifiability,variab,variables,24,// Only bother tracking variables that are at some point stack homed. Other; // variables can be dealt with trivially later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:80,Modifiability,variab,variables,80,// Only bother tracking variables that are at some point stack homed. Other; // variables can be dealt with trivially later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:205,Modifiability,variab,variable,205,"// They match. We can use the stack home because the debug intrinsics; // state that an assignment happened here, and we know that specific; // assignment was the last one to take place in memory for this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:23,Modifiability,variab,variables,23,// Only other tracking variables that are at some point stack homed.; // Other variables can be dealt with trivally later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:79,Modifiability,variab,variables,79,// Only other tracking variables that are at some point stack homed.; // Other variables can be dealt with trivally later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:382,Modifiability,variab,variables,382,"// We have no ID to create an Assignment with so we mark this assignment as; // NoneOrPhi. Note that the dbg.value still exists, we just cannot determine; // the assignment responsible for setting this value.; // This is fine; dbg.values are essentially interchangable with unlinked; // dbg.assigns, and some passes such as mem2reg and instcombine add them to; // PHIs for promoted variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:42,Modifiability,variab,variable,42,// Ignore assignments to zero bits of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:42,Modifiability,variab,variable,42,// Ignore assignments to zero bits of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:300,Modifiability,variab,variables,300,"// II is now a non-debug instruction either with no attached DPValues, or; // with attached processed DPValues. II has not been processed, and all; // debug instructions or DPValues in the frame preceding II have been; // processed.; // We've processed everything in the ""frame"". Now determine which variables; // cannot be represented by a dbg.declare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:8,Modifiability,variab,variable,8,"// If a variable's LocKind is anything other than LocKind::Mem then we; // must note that it cannot be represented with a dbg.declare.; // Note that this check is enough without having to check the result of; // joins() because for join to produce anything other than Mem after; // we've already seen a Mem we'd be joining None or Val with Mem. In that; // case, we've already hit this codepath when we set the LocKind to Val; // or None in that block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:487,Performance,perform,performed,487,"// Source is used to lookup the value + expression in the debug program if; // the stack slot gets assigned a value earlier than expected. Because; // we're only tracking the one dbg.assign, we can't capture debug PHIs.; // It's unlikely that we're losing out on much coverage by avoiding that; // extra work.; // The Source may differ in this situation:; // Pred.1:; // dbg.assign i32 0, ..., !1, ...; // Pred.2:; // dbg.assign i32 1, ..., !1, ...; // Here the same assignment (!1) was performed in both preds in the source,; // but we can't use either one unless they are identical (e.g. .we don't; // want to arbitrarily pick between constant values).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:280,Safety,avoid,avoiding,280,"// Source is used to lookup the value + expression in the debug program if; // the stack slot gets assigned a value earlier than expected. Because; // we're only tracking the one dbg.assign, we can't capture debug PHIs.; // It's unlikely that we're losing out on much coverage by avoiding that; // extra work.; // The Source may differ in this situation:; // Pred.1:; // dbg.assign i32 0, ..., !1, ...; // Pred.2:; // dbg.assign i32 1, ..., !1, ...; // Here the same assignment (!1) was performed in both preds in the source,; // but we can't use either one unless they are identical (e.g. .we don't; // want to arbitrarily pick between constant values).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:116,Modifiability,variab,variables,116,// Don't bother checking if this is an AllocaInst. We know this; // instruction has no tag which means there are no variables associated; // with it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:878,Energy Efficiency,reduce,reduce,878,"/// Build a map of {Variable x: Variables y} where all variable fragments; /// contained within the variable fragment x are in set y. This means that; /// y does not contain all overlaps because partial overlaps are excluded.; ///; /// While we're iterating over the function, add single location defs for; /// dbg.declares to \p FnVarLocs.; ///; /// Variables that are interesting to this pass in are added to; /// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of; /// the last interesting variable plus 1, meaning variables with ID 1; /// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The; /// subsequent variables are either stack homed or fully promoted.; ///; /// Finally, populate UntaggedStoreVars with a mapping of untagged stores to; /// the stored-to variable fragments.; ///; /// These tasks are bundled together to reduce the number of times we need; /// to iterate over the function as they can be achieved together in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:20,Modifiability,Variab,Variable,20,"/// Build a map of {Variable x: Variables y} where all variable fragments; /// contained within the variable fragment x are in set y. This means that; /// y does not contain all overlaps because partial overlaps are excluded.; ///; /// While we're iterating over the function, add single location defs for; /// dbg.declares to \p FnVarLocs.; ///; /// Variables that are interesting to this pass in are added to; /// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of; /// the last interesting variable plus 1, meaning variables with ID 1; /// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The; /// subsequent variables are either stack homed or fully promoted.; ///; /// Finally, populate UntaggedStoreVars with a mapping of untagged stores to; /// the stored-to variable fragments.; ///; /// These tasks are bundled together to reduce the number of times we need; /// to iterate over the function as they can be achieved together in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:32,Modifiability,Variab,Variables,32,"/// Build a map of {Variable x: Variables y} where all variable fragments; /// contained within the variable fragment x are in set y. This means that; /// y does not contain all overlaps because partial overlaps are excluded.; ///; /// While we're iterating over the function, add single location defs for; /// dbg.declares to \p FnVarLocs.; ///; /// Variables that are interesting to this pass in are added to; /// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of; /// the last interesting variable plus 1, meaning variables with ID 1; /// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The; /// subsequent variables are either stack homed or fully promoted.; ///; /// Finally, populate UntaggedStoreVars with a mapping of untagged stores to; /// the stored-to variable fragments.; ///; /// These tasks are bundled together to reduce the number of times we need; /// to iterate over the function as they can be achieved together in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:55,Modifiability,variab,variable,55,"/// Build a map of {Variable x: Variables y} where all variable fragments; /// contained within the variable fragment x are in set y. This means that; /// y does not contain all overlaps because partial overlaps are excluded.; ///; /// While we're iterating over the function, add single location defs for; /// dbg.declares to \p FnVarLocs.; ///; /// Variables that are interesting to this pass in are added to; /// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of; /// the last interesting variable plus 1, meaning variables with ID 1; /// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The; /// subsequent variables are either stack homed or fully promoted.; ///; /// Finally, populate UntaggedStoreVars with a mapping of untagged stores to; /// the stored-to variable fragments.; ///; /// These tasks are bundled together to reduce the number of times we need; /// to iterate over the function as they can be achieved together in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:100,Modifiability,variab,variable,100,"/// Build a map of {Variable x: Variables y} where all variable fragments; /// contained within the variable fragment x are in set y. This means that; /// y does not contain all overlaps because partial overlaps are excluded.; ///; /// While we're iterating over the function, add single location defs for; /// dbg.declares to \p FnVarLocs.; ///; /// Variables that are interesting to this pass in are added to; /// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of; /// the last interesting variable plus 1, meaning variables with ID 1; /// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The; /// subsequent variables are either stack homed or fully promoted.; ///; /// Finally, populate UntaggedStoreVars with a mapping of untagged stores to; /// the stored-to variable fragments.; ///; /// These tasks are bundled together to reduce the number of times we need; /// to iterate over the function as they can be achieved together in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:351,Modifiability,Variab,Variables,351,"/// Build a map of {Variable x: Variables y} where all variable fragments; /// contained within the variable fragment x are in set y. This means that; /// y does not contain all overlaps because partial overlaps are excluded.; ///; /// While we're iterating over the function, add single location defs for; /// dbg.declares to \p FnVarLocs.; ///; /// Variables that are interesting to this pass in are added to; /// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of; /// the last interesting variable plus 1, meaning variables with ID 1; /// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The; /// subsequent variables are either stack homed or fully promoted.; ///; /// Finally, populate UntaggedStoreVars with a mapping of untagged stores to; /// the stored-to variable fragments.; ///; /// These tasks are bundled together to reduce the number of times we need; /// to iterate over the function as they can be achieved together in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:427,Modifiability,Variab,Variables,427,"/// Build a map of {Variable x: Variables y} where all variable fragments; /// contained within the variable fragment x are in set y. This means that; /// y does not contain all overlaps because partial overlaps are excluded.; ///; /// While we're iterating over the function, add single location defs for; /// dbg.declares to \p FnVarLocs.; ///; /// Variables that are interesting to this pass in are added to; /// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of; /// the last interesting variable plus 1, meaning variables with ID 1; /// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The; /// subsequent variables are either stack homed or fully promoted.; ///; /// Finally, populate UntaggedStoreVars with a mapping of untagged stores to; /// the stored-to variable fragments.; ///; /// These tasks are bundled together to reduce the number of times we need; /// to iterate over the function as they can be achieved together in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:517,Modifiability,variab,variable,517,"/// Build a map of {Variable x: Variables y} where all variable fragments; /// contained within the variable fragment x are in set y. This means that; /// y does not contain all overlaps because partial overlaps are excluded.; ///; /// While we're iterating over the function, add single location defs for; /// dbg.declares to \p FnVarLocs.; ///; /// Variables that are interesting to this pass in are added to; /// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of; /// the last interesting variable plus 1, meaning variables with ID 1; /// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The; /// subsequent variables are either stack homed or fully promoted.; ///; /// Finally, populate UntaggedStoreVars with a mapping of untagged stores to; /// the stored-to variable fragments.; ///; /// These tasks are bundled together to reduce the number of times we need; /// to iterate over the function as they can be achieved together in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:542,Modifiability,variab,variables,542,"/// Build a map of {Variable x: Variables y} where all variable fragments; /// contained within the variable fragment x are in set y. This means that; /// y does not contain all overlaps because partial overlaps are excluded.; ///; /// While we're iterating over the function, add single location defs for; /// dbg.declares to \p FnVarLocs.; ///; /// Variables that are interesting to this pass in are added to; /// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of; /// the last interesting variable plus 1, meaning variables with ID 1; /// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The; /// subsequent variables are either stack homed or fully promoted.; ///; /// Finally, populate UntaggedStoreVars with a mapping of untagged stores to; /// the stored-to variable fragments.; ///; /// These tasks are bundled together to reduce the number of times we need; /// to iterate over the function as they can be achieved together in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:658,Modifiability,variab,variables,658,"/// Build a map of {Variable x: Variables y} where all variable fragments; /// contained within the variable fragment x are in set y. This means that; /// y does not contain all overlaps because partial overlaps are excluded.; ///; /// While we're iterating over the function, add single location defs for; /// dbg.declares to \p FnVarLocs.; ///; /// Variables that are interesting to this pass in are added to; /// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of; /// the last interesting variable plus 1, meaning variables with ID 1; /// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The; /// subsequent variables are either stack homed or fully promoted.; ///; /// Finally, populate UntaggedStoreVars with a mapping of untagged stores to; /// the stored-to variable fragments.; ///; /// These tasks are bundled together to reduce the number of times we need; /// to iterate over the function as they can be achieved together in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:812,Modifiability,variab,variable,812,"/// Build a map of {Variable x: Variables y} where all variable fragments; /// contained within the variable fragment x are in set y. This means that; /// y does not contain all overlaps because partial overlaps are excluded.; ///; /// While we're iterating over the function, add single location defs for; /// dbg.declares to \p FnVarLocs.; ///; /// Variables that are interesting to this pass in are added to; /// FnVarLocs->Variables first. TrackedVariablesVectorSize is set to the ID of; /// the last interesting variable plus 1, meaning variables with ID 1; /// (inclusive) to TrackedVariablesVectorSize (exclusive) are interesting. The; /// subsequent variables are either stack homed or fully promoted.; ///; /// Finally, populate UntaggedStoreVars with a mapping of untagged stores to; /// the stored-to variable fragments.; ///; /// These tasks are bundled together to reduce the number of times we need; /// to iterate over the function as they can be achieved together in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:10,Modifiability,Variab,Variable,10,// Map of Variable: [Fragments].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:192,Deployability,update,update,192,// Iterate over all instructions:; // - dbg.declare -> add single location variable record; // - dbg.* -> Add fragments to FragmentMap; // - untagged store -> Add fragments to FragmentMap and update; // UntaggedStoreVars.; // We need to add fragments for untagged stores too so that we can correctly; // clobber overlapped fragment locations later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:75,Modifiability,variab,variable,75,// Iterate over all instructions:; // - dbg.declare -> add single location variable record; // - dbg.* -> Add fragments to FragmentMap; // - untagged store -> Add fragments to FragmentMap and update; // UntaggedStoreVars.; // We need to add fragments for untagged stores too so that we can correctly; // clobber overlapped fragment locations later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:68,Modifiability,variab,variable,68,// Skip this assignment if the affected bits are outside of the; // variable fragment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:118,Modifiability,variab,variable,118,"// FragInfo from calculateFragmentIntersect is nullopt if the; // resultant fragment matches DAI's fragment or entire variable - in; // which case copy the fragment info from DAI. If FragInfo is still; // nullopt after the copy it means ""no fragment info"" instead, which; // is how it is usually interpreted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:3,Performance,Cache,Cache,3,// Cache this info for later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:3,Modifiability,Variab,VariableIDs,3,// VariableIDs are 1-based so the variable-tracking bitvector needs; // NumVariables plus 1 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:34,Modifiability,variab,variable-tracking,34,// VariableIDs are 1-based so the variable-tracking bitvector needs; // NumVariables plus 1 bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:102,Modifiability,variab,variable,102,// The general structure here is inspired by VarLocBasedImpl.cpp; // (LiveDebugValues).; // Build the variable fragment overlap map.; // Note that this pass doesn't handle partial overlaps correctly (FWIW; // neither does LiveDebugVariables) because that is difficult to do and; // appears to be rare occurance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:3,Performance,Perform,Perform,3,"// Perform the traversal.; //; // This is a standard ""union of predecessor outs"" dataflow problem. To solve; // it, we perform join() and process() using the two worklist method until; // the LiveIn data for each block becomes unchanging. The ""proof"" that this; // terminates can be put together by looking at the comments around LocKind,; // Assignment, and the various join methods, which show that all the elements; // involved are made up of join-semilattices; LiveIn(n) can only; // monotonically increase in value throughout the dataflow.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:119,Performance,perform,perform,119,"// Perform the traversal.; //; // This is a standard ""union of predecessor outs"" dataflow problem. To solve; // it, we perform join() and process() using the two worklist method until; // the LiveIn data for each block becomes unchanging. The ""proof"" that this; // terminates can be put together by looking at the comments around LocKind,; // Assignment, and the various join methods, which show that all the elements; // involved are made up of join-semilattices; LiveIn(n) can only; // monotonically increase in value throughout the dataflow.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:47,Safety,avoid,avoid,47,// We track what is on the pending worklist to avoid inserting the same; // thing twice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:45,Modifiability,variab,variables,45,// Identify and add defs for single location variables.; //; // Go through all of the defs that we plan to add. If the aggregate variable; // it's a part of is not in the NotAlwaysStackHomed set we can emit a single; // location def and omit the rest. Add an entry to AlwaysStackHomed so that; // we can identify those uneeded defs later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:129,Modifiability,variab,variable,129,// Identify and add defs for single location variables.; //; // Go through all of the defs that we plan to add. If the aggregate variable; // it's a part of is not in the NotAlwaysStackHomed set we can emit a single; // location def and omit the rest. Add an entry to AlwaysStackHomed so that; // we can identify those uneeded defs later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:195,Energy Efficiency,reduce,reduce,195,"// Skip complex cases such as when different fragments of a variable have; // been split into different allocas. Skipping in this case means falling; // back to using a list of defs (which could reduce coverage, but is no; // less correct).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:60,Modifiability,variab,variable,60,"// Skip complex cases such as when different fragments of a variable have; // been split into different allocas. Skipping in this case means falling; // back to using a list of defs (which could reduce coverage, but is no; // less correct).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:34,Modifiability,variab,variable,34,"// All source assignments to this variable remain and all stores to any; // part of the variable store to the same address (with varying; // offsets). We can just emit a single location for the whole variable.; //; // Unless we've already done so, create the single location def now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:88,Modifiability,variab,variable,88,"// All source assignments to this variable remain and all stores to any; // part of the variable store to the same address (with varying; // offsets). We can just emit a single location for the whole variable.; //; // Unless we've already done so, create the single location def now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:200,Modifiability,variab,variable,200,"// All source assignments to this variable remain and all stores to any; // part of the variable store to the same address (with varying; // offsets). We can just emit a single location for the whole variable.; //; // Unless we've already done so, create the single location def now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:147,Testability,assert,assert,147,// TODO: When more complex cases are handled VarLoc.Expr should be; // built appropriately rather than always using an empty DIExpression.; // The assert below is a reminder.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:11,Modifiability,variab,variable,11,// If this variable is always stack homed then we have already inserted a; // dbg.declare and deleted this dbg.value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:79,Modifiability,variab,variables,79,"// Go through every block, translating debug intrinsics for fully promoted; // variables into FnVarLocs location defs. No analysis required for these.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:8,Modifiability,variab,variables,8,// Skip variables that haven't been promoted - we've dealt with those; // already.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:11,Availability,redundant,redundant,11,/// Remove redundant definitions within sequences of consecutive location defs.; /// This is done using a backward scan to keep the last def describing a; /// specific variable/fragment.; ///; /// This implements removeRedundantDbgInstrsUsingBackwardScan from; /// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with; /// FunctionVarLocsBuilder instead of with intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:168,Modifiability,variab,variable,168,/// Remove redundant definitions within sequences of consecutive location defs.; /// This is done using a backward scan to keep the last def describing a; /// specific variable/fragment.; ///; /// This implements removeRedundantDbgInstrsUsingBackwardScan from; /// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with; /// FunctionVarLocsBuilder instead of with intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:11,Safety,redund,redundant,11,/// Remove redundant definitions within sequences of consecutive location defs.; /// This is done using a backward scan to keep the last def describing a; /// specific variable/fragment.; ///; /// This implements removeRedundantDbgInstrsUsingBackwardScan from; /// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with; /// FunctionVarLocsBuilder instead of with intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:39,Usability,Clear,Clear,39,// Sequence of consecutive defs ended. Clear map for the next one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:20,Modifiability,variab,variables,20,// Cutoff for large variables to prevent expensive bitvector operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:104,Modifiability,variab,variables,104,"// If the size is unknown (0) then keep this location def to be safe.; // Do the same for defs of large variables, which would be expensive; // to represent with a BitVector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:64,Safety,safe,safe,64,"// If the size is unknown (0) then keep this location def to be safe.; // Do the same for defs of large variables, which would be expensive; // to represent with a BitVector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:3,Availability,Redundant,Redundant,3,"// Redundant def found: throw it away. Since the wedge of defs is being; // rebuilt, doing nothing is the same as deleting an entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:3,Safety,Redund,Redundant,3,"// Redundant def found: throw it away. Since the wedge of defs is being; // rebuilt, doing nothing is the same as deleting an entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:11,Availability,redundant,redundant,11,/// Remove redundant location defs using a forward scan. This can remove a; /// location definition that is redundant due to indicating that a variable has; /// the same value as is already being indicated by an earlier def.; ///; /// This implements removeRedundantDbgInstrsUsingForwardScan from; /// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with; /// FunctionVarLocsBuilder instead of with intrinsics,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:108,Availability,redundant,redundant,108,/// Remove redundant location defs using a forward scan. This can remove a; /// location definition that is redundant due to indicating that a variable has; /// the same value as is already being indicated by an earlier def.; ///; /// This implements removeRedundantDbgInstrsUsingForwardScan from; /// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with; /// FunctionVarLocsBuilder instead of with intrinsics,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:143,Modifiability,variab,variable,143,/// Remove redundant location defs using a forward scan. This can remove a; /// location definition that is redundant due to indicating that a variable has; /// the same value as is already being indicated by an earlier def.; ///; /// This implements removeRedundantDbgInstrsUsingForwardScan from; /// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with; /// FunctionVarLocsBuilder instead of with intrinsics,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:11,Safety,redund,redundant,11,/// Remove redundant location defs using a forward scan. This can remove a; /// location definition that is redundant due to indicating that a variable has; /// the same value as is already being indicated by an earlier def.; ///; /// This implements removeRedundantDbgInstrsUsingForwardScan from; /// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with; /// FunctionVarLocsBuilder instead of with intrinsics,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:108,Safety,redund,redundant,108,/// Remove redundant location defs using a forward scan. This can remove a; /// location definition that is redundant due to indicating that a variable has; /// the same value as is already being indicated by an earlier def.; ///; /// This implements removeRedundantDbgInstrsUsingForwardScan from; /// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with; /// FunctionVarLocsBuilder instead of with intrinsics,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:3,Deployability,Update,Update,3,"// Update the map if we found a new value/expression describing the; // variable, or if the variable wasn't mapped already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:72,Modifiability,variab,variable,72,"// Update the map if we found a new value/expression describing the; // variable, or if the variable wasn't mapped already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:92,Modifiability,variab,variable,92,"// Update the map if we found a new value/expression describing the; // variable, or if the variable wasn't mapped already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:421,Modifiability,Variab,Variable,421,"// Do extra work to ensure that we remove semantically unimportant undefs.; //; // This is to work around the fact that SelectionDAG will hoist dbg.values; // using argument values to the top of the entry block. That can move arg; // dbg.values before undef and constant dbg.values which they previously; // followed. The easiest thing to do is to just try to feed SelectionDAG; // input it's happy with.; //; // Map of {Variable x: Fragments y} where the fragments y of variable x have; // have at least one non-undef location defined already. Don't use directly,; // instead call DefineBits and HasDefinedBits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:471,Modifiability,variab,variable,471,"// Do extra work to ensure that we remove semantically unimportant undefs.; //; // This is to work around the fact that SelectionDAG will hoist dbg.values; // using argument values to the top of the entry block. That can move arg; // dbg.values before undef and constant dbg.values which they previously; // followed. The easiest thing to do is to just try to feed SelectionDAG; // input it's happy with.; //; // Map of {Variable x: Fragments y} where the fragments y of variable x have; // have at least one non-undef location defined already. Don't use directly,; // instead call DefineBits and HasDefinedBits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:7,Modifiability,variab,variable,7,"// Any variable linked to an instruction is considered; // interesting. Ideally we only need to check Allocas, however, a; // DIAssignID might get dropped from an alloca but not stores. In that; // case, we need to consider the variable interesting for NFC behaviour; // with this change. TODO: Consider only looking at allocas.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:228,Modifiability,variab,variable,228,"// Any variable linked to an instruction is considered; // interesting. Ideally we only need to check Allocas, however, a; // DIAssignID might get dropped from an alloca but not stores. In that; // case, we need to consider the variable interesting for NFC behaviour; // with this change. TODO: Consider only looking at allocas.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:59,Modifiability,variab,variables,59,"// The analysis will generate location definitions for all variables, but we; // only need to perform a dataflow on the set of variables which have a stack; // slot. Find those now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:127,Modifiability,variab,variables,127,"// The analysis will generate location definitions for all variables, but we; // only need to perform a dataflow on the set of variables which have a stack; // slot. Find those now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:94,Performance,perform,perform,94,"// The analysis will generate location definitions for all variables, but we; // only need to perform a dataflow on the set of variables which have a stack; // slot. Find those now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:101,Energy Efficiency,reduce,reduce,101,// Use a scope block to clean up AssignmentTrackingLowering before running; // MemLocFragmentFill to reduce peak memory consumption.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:120,Energy Efficiency,consumption,consumption,120,// Use a scope block to clean up AssignmentTrackingLowering before running; // MemLocFragmentFill to reduce peak memory consumption.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:10,Availability,redundant,redundant,10,"// Remove redundant entries. As well as reducing memory consumption and; // avoiding waiting cycles later by burning some now, this has another; // important job. That is to work around some SelectionDAG quirks. See; // removeRedundantDbgLocsUsingForwardScan comments for more info on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:56,Energy Efficiency,consumption,consumption,56,"// Remove redundant entries. As well as reducing memory consumption and; // avoiding waiting cycles later by burning some now, this has another; // important job. That is to work around some SelectionDAG quirks. See; // removeRedundantDbgLocsUsingForwardScan comments for more info on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:10,Safety,redund,redundant,10,"// Remove redundant entries. As well as reducing memory consumption and; // avoiding waiting cycles later by burning some now, this has another; // important job. That is to work around some SelectionDAG quirks. See; // removeRedundantDbgLocsUsingForwardScan comments for more info on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:76,Safety,avoid,avoiding,76,"// Remove redundant entries. As well as reducing memory consumption and; // avoiding waiting cycles later by burning some now, this has another; // important job. That is to work around some SelectionDAG quirks. See; // removeRedundantDbgLocsUsingForwardScan comments for more info on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:3,Usability,Clear,Clear,3,// Clear previous results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:656,Performance,load,load-linked,656,"//===- AtomicExpandPass.cpp - Expand atomic instructions ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass (at IR level) to replace atomic instructions with; // __atomic_* library calls, or target specific instruction which implement the; // same semantics in a way which better fits the target backend. This can; // include the use of (intrinsic-based) load-linked/store-conditional loops,; // AtomicCmpXchg, or type coercions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:73,Modifiability,extend,extend,73,"// TODO: when we're ready to make the change at the IR level, we can; // extend convertCmpXchgToInteger for floating point too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:141,Availability,failure,failure,141,"// If a compare and swap is lowered to LL/SC, we can do smarter fence; // insertion, with a stronger one on the success path than on the; // failure path. As a result, fence insertion is directly done by; // expandAtomicCmpXchg in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:76,Performance,load,load,76,// There are two different ways of expanding RMW instructions:; // - into a load if it is idempotent; // - into a Cmpxchg/LL-SC loop otherwise; // we try them in that order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:22,Performance,load,load,22,/// Convert an atomic load of a non-integral type to an integer load of the; /// equivalent bitwidth. See the function comment on; /// convertAtomicStoreToIntegerType for background.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:64,Performance,load,load,64,/// Convert an atomic load of a non-integral type to an integer load of the; /// equivalent bitwidth. See the function comment on; /// convertAtomicStoreToIntegerType for background.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:26,Performance,load,load-linked,26,"// On some architectures, load-linked instructions are atomic for larger; // sizes than normal loads. For example, the only 64-bit load guaranteed; // to be single-copy atomic by ARM is an ldrexd (A3.5.3).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:95,Performance,load,loads,95,"// On some architectures, load-linked instructions are atomic for larger; // sizes than normal loads. For example, the only 64-bit load guaranteed; // to be single-copy atomic by ARM is an ldrexd (A3.5.3).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:131,Performance,load,load,131,"// On some architectures, load-linked instructions are atomic for larger; // sizes than normal loads. For example, the only 64-bit load guaranteed; // to be single-copy atomic by ARM is an ldrexd (A3.5.3).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:196,Usability,learn,learned,196,"/// Convert an atomic store of a non-integral type to an integer store of the; /// equivalent bitwidth. We used to not support floating point or vector; /// atomics in the IR at all. The backends learned to deal with the bitcast; /// idiom because that was the only way of expressing the notion of a atomic; /// float or vector store. The long term plan is to teach each backend to; /// instruction select from the original atomic store, but as a migration; /// mechanism, we convert back to the old format which the backends understand.; /// Each backend will need individual work to recognize the new format.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:256,Availability,mask,masks,256,"// end anonymous namespace; /// This is a helper function which builds instructions to provide; /// values necessary for partword atomic operations. It takes an; /// incoming address, Addr, and ValueType, and constructs the address,; /// shift-amounts and masks needed to work with a larger value of size; /// WordSize.; ///; /// AlignedAddr: Addr rounded down to a multiple of WordSize; ///; /// ShiftAmt: Number of bits to right-shift a WordSize value loaded; /// from AlignAddr for it to have the same value as if; /// ValueType was loaded from Addr.; ///; /// Mask: Value to mask with the value loaded from AlignAddr to; /// include only the part that would've been loaded from Addr.; ///; /// Inv_Mask: The inverse of Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:356,Availability,down,down,356,"// end anonymous namespace; /// This is a helper function which builds instructions to provide; /// values necessary for partword atomic operations. It takes an; /// incoming address, Addr, and ValueType, and constructs the address,; /// shift-amounts and masks needed to work with a larger value of size; /// WordSize.; ///; /// AlignedAddr: Addr rounded down to a multiple of WordSize; ///; /// ShiftAmt: Number of bits to right-shift a WordSize value loaded; /// from AlignAddr for it to have the same value as if; /// ValueType was loaded from Addr.; ///; /// Mask: Value to mask with the value loaded from AlignAddr to; /// include only the part that would've been loaded from Addr.; ///; /// Inv_Mask: The inverse of Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:564,Availability,Mask,Mask,564,"// end anonymous namespace; /// This is a helper function which builds instructions to provide; /// values necessary for partword atomic operations. It takes an; /// incoming address, Addr, and ValueType, and constructs the address,; /// shift-amounts and masks needed to work with a larger value of size; /// WordSize.; ///; /// AlignedAddr: Addr rounded down to a multiple of WordSize; ///; /// ShiftAmt: Number of bits to right-shift a WordSize value loaded; /// from AlignAddr for it to have the same value as if; /// ValueType was loaded from Addr.; ///; /// Mask: Value to mask with the value loaded from AlignAddr to; /// include only the part that would've been loaded from Addr.; ///; /// Inv_Mask: The inverse of Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:579,Availability,mask,mask,579,"// end anonymous namespace; /// This is a helper function which builds instructions to provide; /// values necessary for partword atomic operations. It takes an; /// incoming address, Addr, and ValueType, and constructs the address,; /// shift-amounts and masks needed to work with a larger value of size; /// WordSize.; ///; /// AlignedAddr: Addr rounded down to a multiple of WordSize; ///; /// ShiftAmt: Number of bits to right-shift a WordSize value loaded; /// from AlignAddr for it to have the same value as if; /// ValueType was loaded from Addr.; ///; /// Mask: Value to mask with the value loaded from AlignAddr to; /// include only the part that would've been loaded from Addr.; ///; /// Inv_Mask: The inverse of Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:723,Availability,Mask,Mask,723,"// end anonymous namespace; /// This is a helper function which builds instructions to provide; /// values necessary for partword atomic operations. It takes an; /// incoming address, Addr, and ValueType, and constructs the address,; /// shift-amounts and masks needed to work with a larger value of size; /// WordSize.; ///; /// AlignedAddr: Addr rounded down to a multiple of WordSize; ///; /// ShiftAmt: Number of bits to right-shift a WordSize value loaded; /// from AlignAddr for it to have the same value as if; /// ValueType was loaded from Addr.; ///; /// Mask: Value to mask with the value loaded from AlignAddr to; /// include only the part that would've been loaded from Addr.; ///; /// Inv_Mask: The inverse of Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:454,Performance,load,loaded,454,"// end anonymous namespace; /// This is a helper function which builds instructions to provide; /// values necessary for partword atomic operations. It takes an; /// incoming address, Addr, and ValueType, and constructs the address,; /// shift-amounts and masks needed to work with a larger value of size; /// WordSize.; ///; /// AlignedAddr: Addr rounded down to a multiple of WordSize; ///; /// ShiftAmt: Number of bits to right-shift a WordSize value loaded; /// from AlignAddr for it to have the same value as if; /// ValueType was loaded from Addr.; ///; /// Mask: Value to mask with the value loaded from AlignAddr to; /// include only the part that would've been loaded from Addr.; ///; /// Inv_Mask: The inverse of Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:536,Performance,load,loaded,536,"// end anonymous namespace; /// This is a helper function which builds instructions to provide; /// values necessary for partword atomic operations. It takes an; /// incoming address, Addr, and ValueType, and constructs the address,; /// shift-amounts and masks needed to work with a larger value of size; /// WordSize.; ///; /// AlignedAddr: Addr rounded down to a multiple of WordSize; ///; /// ShiftAmt: Number of bits to right-shift a WordSize value loaded; /// from AlignAddr for it to have the same value as if; /// ValueType was loaded from Addr.; ///; /// Mask: Value to mask with the value loaded from AlignAddr to; /// include only the part that would've been loaded from Addr.; ///; /// Inv_Mask: The inverse of Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:599,Performance,load,loaded,599,"// end anonymous namespace; /// This is a helper function which builds instructions to provide; /// values necessary for partword atomic operations. It takes an; /// incoming address, Addr, and ValueType, and constructs the address,; /// shift-amounts and masks needed to work with a larger value of size; /// WordSize.; ///; /// AlignedAddr: Addr rounded down to a multiple of WordSize; ///; /// ShiftAmt: Number of bits to right-shift a WordSize value loaded; /// from AlignAddr for it to have the same value as if; /// ValueType was loaded from Addr.; ///; /// Mask: Value to mask with the value loaded from AlignAddr to; /// include only the part that would've been loaded from Addr.; ///; /// Inv_Mask: The inverse of Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:670,Performance,load,loaded,670,"// end anonymous namespace; /// This is a helper function which builds instructions to provide; /// values necessary for partword atomic operations. It takes an; /// incoming address, Addr, and ValueType, and constructs the address,; /// shift-amounts and masks needed to work with a larger value of size; /// WordSize.; ///; /// AlignedAddr: Addr rounded down to a multiple of WordSize; ///; /// ShiftAmt: Number of bits to right-shift a WordSize value loaded; /// from AlignAddr for it to have the same value as if; /// ValueType was loaded from Addr.; ///; /// Mask: Value to mask with the value loaded from AlignAddr to; /// include only the part that would've been loaded from Addr.; ///; /// Inv_Mask: The inverse of Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:27,Availability,mask,masked,27,"/// Emit IR to implement a masked version of a given atomicrmw; /// operation. (That is, only the bits under the Mask should be; /// affected by the operation)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:113,Availability,Mask,Mask,113,"/// Emit IR to implement a masked version of a given atomicrmw; /// operation. (That is, only the bits under the Mask should be; /// affected by the operation)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:80,Availability,Mask,MaskedMerge,80,// TODO: update to use; // https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge in order; // to merge bits from two values without requiring PMV.Inv_Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:9,Deployability,update,update,9,// TODO: update to use; // https://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge in order; // to merge bits from two values without requiring PMV.Inv_Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:39,Availability,mask,masked,39,// The other arithmetic ops need to be masked into place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:66,Availability,down,down,66,"// Finally, other ops will operate on the full value, so truncate down to; // the original size, and expand out again after doing the; // operation. Bitcasts will be inserted for FP values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:258,Availability,failure,failure,258,"// The basic idea here is that we're expanding a cmpxchg of a; // smaller memory size up to a word-sized cmpxchg. To do this, we; // need to add a retry-loop for strong cmpxchg, so that; // modifications to other parts of the word don't cause a spurious; // failure.; // This generates code like the following:; // [[Setup mask values PMV.*]]; // %NewVal_Shifted = shl i32 %NewVal, %PMV.ShiftAmt; // %Cmp_Shifted = shl i32 %Cmp, %PMV.ShiftAmt; // %InitLoaded = load i32* %addr; // %InitLoaded_MaskOut = and i32 %InitLoaded, %PMV.Inv_Mask; // br partword.cmpxchg.loop; // partword.cmpxchg.loop:; // %Loaded_MaskOut = phi i32 [ %InitLoaded_MaskOut, %entry ],; // [ %OldVal_MaskOut, %partword.cmpxchg.failure ]; // %FullWord_NewVal = or i32 %Loaded_MaskOut, %NewVal_Shifted; // %FullWord_Cmp = or i32 %Loaded_MaskOut, %Cmp_Shifted; // %NewCI = cmpxchg i32* %PMV.AlignedAddr, i32 %FullWord_Cmp,; // i32 %FullWord_NewVal success_ordering failure_ordering; // %OldVal = extractvalue { i32, i1 } %NewCI, 0; // %Success = extractvalue { i32, i1 } %NewCI, 1; // br i1 %Success, label %partword.cmpxchg.end,; // label %partword.cmpxchg.failure; // partword.cmpxchg.failure:; // %OldVal_MaskOut = and i32 %OldVal, %PMV.Inv_Mask; // %ShouldContinue = icmp ne i32 %Loaded_MaskOut, %OldVal_MaskOut; // br i1 %ShouldContinue, label %partword.cmpxchg.loop,; // label %partword.cmpxchg.end; // partword.cmpxchg.end:; // %tmp1 = lshr i32 %OldVal, %PMV.ShiftAmt; // %FinalOldVal = trunc i32 %tmp1 to i8; // %tmp2 = insertvalue { i8, i1 } undef, i8 %FinalOldVal, 0; // %Res = insertvalue { i8, i1 } %25, i1 %Success, 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:323,Availability,mask,mask,323,"// The basic idea here is that we're expanding a cmpxchg of a; // smaller memory size up to a word-sized cmpxchg. To do this, we; // need to add a retry-loop for strong cmpxchg, so that; // modifications to other parts of the word don't cause a spurious; // failure.; // This generates code like the following:; // [[Setup mask values PMV.*]]; // %NewVal_Shifted = shl i32 %NewVal, %PMV.ShiftAmt; // %Cmp_Shifted = shl i32 %Cmp, %PMV.ShiftAmt; // %InitLoaded = load i32* %addr; // %InitLoaded_MaskOut = and i32 %InitLoaded, %PMV.Inv_Mask; // br partword.cmpxchg.loop; // partword.cmpxchg.loop:; // %Loaded_MaskOut = phi i32 [ %InitLoaded_MaskOut, %entry ],; // [ %OldVal_MaskOut, %partword.cmpxchg.failure ]; // %FullWord_NewVal = or i32 %Loaded_MaskOut, %NewVal_Shifted; // %FullWord_Cmp = or i32 %Loaded_MaskOut, %Cmp_Shifted; // %NewCI = cmpxchg i32* %PMV.AlignedAddr, i32 %FullWord_Cmp,; // i32 %FullWord_NewVal success_ordering failure_ordering; // %OldVal = extractvalue { i32, i1 } %NewCI, 0; // %Success = extractvalue { i32, i1 } %NewCI, 1; // br i1 %Success, label %partword.cmpxchg.end,; // label %partword.cmpxchg.failure; // partword.cmpxchg.failure:; // %OldVal_MaskOut = and i32 %OldVal, %PMV.Inv_Mask; // %ShouldContinue = icmp ne i32 %Loaded_MaskOut, %OldVal_MaskOut; // br i1 %ShouldContinue, label %partword.cmpxchg.loop,; // label %partword.cmpxchg.end; // partword.cmpxchg.end:; // %tmp1 = lshr i32 %OldVal, %PMV.ShiftAmt; // %FinalOldVal = trunc i32 %tmp1 to i8; // %tmp2 = insertvalue { i8, i1 } undef, i8 %FinalOldVal, 0; // %Res = insertvalue { i8, i1 } %25, i1 %Success, 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:698,Availability,failure,failure,698,"// The basic idea here is that we're expanding a cmpxchg of a; // smaller memory size up to a word-sized cmpxchg. To do this, we; // need to add a retry-loop for strong cmpxchg, so that; // modifications to other parts of the word don't cause a spurious; // failure.; // This generates code like the following:; // [[Setup mask values PMV.*]]; // %NewVal_Shifted = shl i32 %NewVal, %PMV.ShiftAmt; // %Cmp_Shifted = shl i32 %Cmp, %PMV.ShiftAmt; // %InitLoaded = load i32* %addr; // %InitLoaded_MaskOut = and i32 %InitLoaded, %PMV.Inv_Mask; // br partword.cmpxchg.loop; // partword.cmpxchg.loop:; // %Loaded_MaskOut = phi i32 [ %InitLoaded_MaskOut, %entry ],; // [ %OldVal_MaskOut, %partword.cmpxchg.failure ]; // %FullWord_NewVal = or i32 %Loaded_MaskOut, %NewVal_Shifted; // %FullWord_Cmp = or i32 %Loaded_MaskOut, %Cmp_Shifted; // %NewCI = cmpxchg i32* %PMV.AlignedAddr, i32 %FullWord_Cmp,; // i32 %FullWord_NewVal success_ordering failure_ordering; // %OldVal = extractvalue { i32, i1 } %NewCI, 0; // %Success = extractvalue { i32, i1 } %NewCI, 1; // br i1 %Success, label %partword.cmpxchg.end,; // label %partword.cmpxchg.failure; // partword.cmpxchg.failure:; // %OldVal_MaskOut = and i32 %OldVal, %PMV.Inv_Mask; // %ShouldContinue = icmp ne i32 %Loaded_MaskOut, %OldVal_MaskOut; // br i1 %ShouldContinue, label %partword.cmpxchg.loop,; // label %partword.cmpxchg.end; // partword.cmpxchg.end:; // %tmp1 = lshr i32 %OldVal, %PMV.ShiftAmt; // %FinalOldVal = trunc i32 %tmp1 to i8; // %tmp2 = insertvalue { i8, i1 } undef, i8 %FinalOldVal, 0; // %Res = insertvalue { i8, i1 } %25, i1 %Success, 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1126,Availability,failure,failure,1126,"// The basic idea here is that we're expanding a cmpxchg of a; // smaller memory size up to a word-sized cmpxchg. To do this, we; // need to add a retry-loop for strong cmpxchg, so that; // modifications to other parts of the word don't cause a spurious; // failure.; // This generates code like the following:; // [[Setup mask values PMV.*]]; // %NewVal_Shifted = shl i32 %NewVal, %PMV.ShiftAmt; // %Cmp_Shifted = shl i32 %Cmp, %PMV.ShiftAmt; // %InitLoaded = load i32* %addr; // %InitLoaded_MaskOut = and i32 %InitLoaded, %PMV.Inv_Mask; // br partword.cmpxchg.loop; // partword.cmpxchg.loop:; // %Loaded_MaskOut = phi i32 [ %InitLoaded_MaskOut, %entry ],; // [ %OldVal_MaskOut, %partword.cmpxchg.failure ]; // %FullWord_NewVal = or i32 %Loaded_MaskOut, %NewVal_Shifted; // %FullWord_Cmp = or i32 %Loaded_MaskOut, %Cmp_Shifted; // %NewCI = cmpxchg i32* %PMV.AlignedAddr, i32 %FullWord_Cmp,; // i32 %FullWord_NewVal success_ordering failure_ordering; // %OldVal = extractvalue { i32, i1 } %NewCI, 0; // %Success = extractvalue { i32, i1 } %NewCI, 1; // br i1 %Success, label %partword.cmpxchg.end,; // label %partword.cmpxchg.failure; // partword.cmpxchg.failure:; // %OldVal_MaskOut = and i32 %OldVal, %PMV.Inv_Mask; // %ShouldContinue = icmp ne i32 %Loaded_MaskOut, %OldVal_MaskOut; // br i1 %ShouldContinue, label %partword.cmpxchg.loop,; // label %partword.cmpxchg.end; // partword.cmpxchg.end:; // %tmp1 = lshr i32 %OldVal, %PMV.ShiftAmt; // %FinalOldVal = trunc i32 %tmp1 to i8; // %tmp2 = insertvalue { i8, i1 } undef, i8 %FinalOldVal, 0; // %Res = insertvalue { i8, i1 } %25, i1 %Success, 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1155,Availability,failure,failure,1155,"// The basic idea here is that we're expanding a cmpxchg of a; // smaller memory size up to a word-sized cmpxchg. To do this, we; // need to add a retry-loop for strong cmpxchg, so that; // modifications to other parts of the word don't cause a spurious; // failure.; // This generates code like the following:; // [[Setup mask values PMV.*]]; // %NewVal_Shifted = shl i32 %NewVal, %PMV.ShiftAmt; // %Cmp_Shifted = shl i32 %Cmp, %PMV.ShiftAmt; // %InitLoaded = load i32* %addr; // %InitLoaded_MaskOut = and i32 %InitLoaded, %PMV.Inv_Mask; // br partword.cmpxchg.loop; // partword.cmpxchg.loop:; // %Loaded_MaskOut = phi i32 [ %InitLoaded_MaskOut, %entry ],; // [ %OldVal_MaskOut, %partword.cmpxchg.failure ]; // %FullWord_NewVal = or i32 %Loaded_MaskOut, %NewVal_Shifted; // %FullWord_Cmp = or i32 %Loaded_MaskOut, %Cmp_Shifted; // %NewCI = cmpxchg i32* %PMV.AlignedAddr, i32 %FullWord_Cmp,; // i32 %FullWord_NewVal success_ordering failure_ordering; // %OldVal = extractvalue { i32, i1 } %NewCI, 0; // %Success = extractvalue { i32, i1 } %NewCI, 1; // br i1 %Success, label %partword.cmpxchg.end,; // label %partword.cmpxchg.failure; // partword.cmpxchg.failure:; // %OldVal_MaskOut = and i32 %OldVal, %PMV.Inv_Mask; // %ShouldContinue = icmp ne i32 %Loaded_MaskOut, %OldVal_MaskOut; // br i1 %ShouldContinue, label %partword.cmpxchg.loop,; // label %partword.cmpxchg.end; // partword.cmpxchg.end:; // %tmp1 = lshr i32 %OldVal, %PMV.ShiftAmt; // %FinalOldVal = trunc i32 %tmp1 to i8; // %tmp2 = insertvalue { i8, i1 } undef, i8 %FinalOldVal, 0; // %Res = insertvalue { i8, i1 } %25, i1 %Success, 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:461,Performance,load,load,461,"// The basic idea here is that we're expanding a cmpxchg of a; // smaller memory size up to a word-sized cmpxchg. To do this, we; // need to add a retry-loop for strong cmpxchg, so that; // modifications to other parts of the word don't cause a spurious; // failure.; // This generates code like the following:; // [[Setup mask values PMV.*]]; // %NewVal_Shifted = shl i32 %NewVal, %PMV.ShiftAmt; // %Cmp_Shifted = shl i32 %Cmp, %PMV.ShiftAmt; // %InitLoaded = load i32* %addr; // %InitLoaded_MaskOut = and i32 %InitLoaded, %PMV.Inv_Mask; // br partword.cmpxchg.loop; // partword.cmpxchg.loop:; // %Loaded_MaskOut = phi i32 [ %InitLoaded_MaskOut, %entry ],; // [ %OldVal_MaskOut, %partword.cmpxchg.failure ]; // %FullWord_NewVal = or i32 %Loaded_MaskOut, %NewVal_Shifted; // %FullWord_Cmp = or i32 %Loaded_MaskOut, %Cmp_Shifted; // %NewCI = cmpxchg i32* %PMV.AlignedAddr, i32 %FullWord_Cmp,; // i32 %FullWord_NewVal success_ordering failure_ordering; // %OldVal = extractvalue { i32, i1 } %NewCI, 0; // %Success = extractvalue { i32, i1 } %NewCI, 1; // br i1 %Success, label %partword.cmpxchg.end,; // label %partword.cmpxchg.failure; // partword.cmpxchg.failure:; // %OldVal_MaskOut = and i32 %OldVal, %PMV.Inv_Mask; // %ShouldContinue = icmp ne i32 %Loaded_MaskOut, %OldVal_MaskOut; // br i1 %ShouldContinue, label %partword.cmpxchg.loop,; // label %partword.cmpxchg.end; // partword.cmpxchg.end:; // %tmp1 = lshr i32 %OldVal, %PMV.ShiftAmt; // %FinalOldVal = trunc i32 %tmp1 to i8; // %tmp2 = insertvalue { i8, i1 } undef, i8 %FinalOldVal, 0; // %Res = insertvalue { i8, i1 } %25, i1 %Success, 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:37,Availability,mask,mask,37,"// Load the entire current word, and mask into place the expected and new; // values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:3,Performance,Load,Load,3,"// Load the entire current word, and mask into place the expected and new; // values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:3,Availability,Mask,Mask,3,// Mask/Or the expected and new values into place in the loaded word.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:57,Performance,load,loaded,57,// Mask/Or the expected and new values into place in the loaded word.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:20,Availability,failure,failure,20,// partword.cmpxchg.failure:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:8,Availability,failure,failure,8,"// Upon failure, verify that the masked-out part of the loaded value; // has been modified. If it didn't, abort the cmpxchg, since the; // masked-in part must've.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:33,Availability,mask,masked-out,33,"// Upon failure, verify that the masked-out part of the loaded value; // has been modified. If it didn't, abort the cmpxchg, since the; // masked-in part must've.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:139,Availability,mask,masked-in,139,"// Upon failure, verify that the masked-out part of the loaded value; // has been modified. If it didn't, abort the cmpxchg, since the; // masked-in part must've.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:56,Performance,load,loaded,56,"// Upon failure, verify that the masked-out part of the loaded value; // has been modified. If it didn't, abort the cmpxchg, since the; // masked-in part must've.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:106,Safety,abort,abort,106,"// Upon failure, verify that the masked-out part of the loaded value; // has been modified. If it didn't, abort the cmpxchg, since the; // masked-in part must've.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:34,Modifiability,extend,extended,34,"// The value operand must be sign-extended for signed min/max so that the; // target's signed comparison instructions can be used. Otherwise, just; // zero-ext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:139,Performance,load,loaded,139,"// Given: atomicrmw some_op iN* %addr, iN %incr ordering; //; // The standard expansion we produce is:; // [...]; // atomicrmw.start:; // %loaded = @load.linked(%addr); // %new = some_op iN %loaded, %incr; // %stored = @store_conditional(%new, %addr); // %try_again = icmp i32 ne %stored, 0; // br i1 %try_again, label %loop, label %atomicrmw.end; // atomicrmw.end:; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:149,Performance,load,load,149,"// Given: atomicrmw some_op iN* %addr, iN %incr ordering; //; // The standard expansion we produce is:; // [...]; // atomicrmw.start:; // %loaded = @load.linked(%addr); // %new = some_op iN %loaded, %incr; // %stored = @store_conditional(%new, %addr); // %try_again = icmp i32 ne %stored, 0; // br i1 %try_again, label %loop, label %atomicrmw.end; // atomicrmw.end:; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:191,Performance,load,loaded,191,"// Given: atomicrmw some_op iN* %addr, iN %incr ordering; //; // The standard expansion we produce is:; // [...]; // atomicrmw.start:; // %loaded = @load.linked(%addr); // %new = some_op iN %loaded, %incr; // %stored = @store_conditional(%new, %addr); // %try_again = icmp i32 ne %stored, 0; // br i1 %try_again, label %loop, label %atomicrmw.end; // atomicrmw.end:; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:286,Deployability,update,update,286,"/// Convert an atomic cmpxchg of a non-integral type to an integer cmpxchg of; /// the equivalent bitwidth. We used to not support pointer cmpxchg in the; /// IR. As a migration step, we convert back to what use to be the standard; /// way to represent a pointer cmpxchg so that we can update backends one by; /// one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:425,Availability,down,down,425,"// In implementations which use a barrier to achieve release semantics, we can; // delay emitting this barrier until we know a store is actually going to be; // attempted. The cost of this delay is that we need 2 copies of the block; // emitting the load-linked, affecting code size.; //; // Ideally, this logic would be unconditional except for the minsize check; // since in other cases the extra blocks naturally collapse down to the; // minimal loop. Unfortunately, this puts too much stress on later; // optimisations so we avoid emitting the extra logic in those cases too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:53,Deployability,release,release,53,"// In implementations which use a barrier to achieve release semantics, we can; // delay emitting this barrier until we know a store is actually going to be; // attempted. The cost of this delay is that we need 2 copies of the block; // emitting the load-linked, affecting code size.; //; // Ideally, this logic would be unconditional except for the minsize check; // since in other cases the extra blocks naturally collapse down to the; // minimal loop. Unfortunately, this puts too much stress on later; // optimisations so we avoid emitting the extra logic in those cases too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:250,Performance,load,load-linked,250,"// In implementations which use a barrier to achieve release semantics, we can; // delay emitting this barrier until we know a store is actually going to be; // attempted. The cost of this delay is that we need 2 copies of the block; // emitting the load-linked, affecting code size.; //; // Ideally, this logic would be unconditional except for the minsize check; // since in other cases the extra blocks naturally collapse down to the; // minimal loop. Unfortunately, this puts too much stress on later; // optimisations so we avoid emitting the extra logic in those cases too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:529,Safety,avoid,avoid,529,"// In implementations which use a barrier to achieve release semantics, we can; // delay emitting this barrier until we know a store is actually going to be; // attempted. The cost of this delay is that we need 2 copies of the block; // emitting the load-linked, affecting code size.; //; // Ideally, this logic would be unconditional except for the minsize check; // since in other cases the extra blocks naturally collapse down to the; // minimal loop. Unfortunately, this puts too much stress on later; // optimisations so we avoid emitting the extra logic in those cases too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:306,Testability,log,logic,306,"// In implementations which use a barrier to achieve release semantics, we can; // delay emitting this barrier until we know a store is actually going to be; // attempted. The cost of this delay is that we need 2 copies of the block; // emitting the load-linked, affecting code size.; //; // Ideally, this logic would be unconditional except for the minsize check; // since in other cases the extra blocks naturally collapse down to the; // minimal loop. Unfortunately, this puts too much stress on later; // optimisations so we avoid emitting the extra logic in those cases too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:554,Testability,log,logic,554,"// In implementations which use a barrier to achieve release semantics, we can; // delay emitting this barrier until we know a store is actually going to be; // attempted. The cost of this delay is that we need 2 copies of the block; // emitting the load-linked, affecting code size.; //; // Ideally, this logic would be unconditional except for the minsize check; // since in other cases the extra blocks naturally collapse down to the; // minimal loop. Unfortunately, this puts too much stress on later; // optimisations so we avoid emitting the extra logic in those cases too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:39,Deployability,release,release,39,"// There's no overhead for sinking the release barrier in a weak cmpxchg, so; // do it even on minsize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:877,Availability,failure,failure,877,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1149,Availability,failure,failure,1149,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1417,Availability,failure,failure,1417,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1437,Availability,failure,failure,1437,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1550,Availability,failure,failure,1550,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1667,Availability,failure,failure,1667,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:602,Deployability,release,releasedload,602,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:625,Deployability,release,releasedload,625,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:644,Deployability,update,updated,644,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:726,Deployability,update,updated,726,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:855,Deployability,release,releasedload,855,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:897,Deployability,release,releasedload,897,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:916,Deployability,release,releasedload,916,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:964,Deployability,release,releasedload,964,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1007,Deployability,release,releasedload,1007,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1049,Deployability,release,releasedload,1049,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1303,Deployability,release,releasedload,1303,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1330,Deployability,release,releasedload,1330,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:197,Performance,load,load,197,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:530,Performance,load,loaded,530,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:676,Performance,load,loaded,676,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:932,Performance,load,load,932,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1241,Performance,load,loaded,1241,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1505,Performance,load,loaded,1505,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1525,Performance,load,loaded,1525,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1566,Performance,load,loaded,1566,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1681,Performance,load,loaded,1681,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1710,Performance,load,loaded,1710,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1770,Performance,load,loaded,1770,"// Given: cmpxchg some_op iN* %addr, iN %desired, iN %new success_ord fail_ord; //; // The full expansion we produce is:; // [...]; // %aligned.addr = ...; // cmpxchg.start:; // %unreleasedload = @load.linked(%aligned.addr); // %unreleasedload.extract = extract value from %unreleasedload; // %should_store = icmp eq %unreleasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.releasingstore,; // label %cmpxchg.nostore; // cmpxchg.releasingstore:; // fence?; // br label cmpxchg.trystore; // cmpxchg.trystore:; // %loaded.trystore = phi [%unreleasedload, %cmpxchg.releasingstore],; // [%releasedload, %cmpxchg.releasedload]; // %updated.new = insert %new into %loaded.trystore; // %stored = @store_conditional(%updated.new, %aligned.addr); // %success = icmp eq i32 %stored, 0; // br i1 %success, label %cmpxchg.success,; // label %cmpxchg.releasedload/%cmpxchg.failure; // cmpxchg.releasedload:; // %releasedload = @load.linked(%aligned.addr); // %releasedload.extract = extract value from %releasedload; // %should_store = icmp eq %releasedload.extract, %desired; // br i1 %should_store, label %cmpxchg.trystore,; // label %cmpxchg.failure; // cmpxchg.success:; // fence?; // br label %cmpxchg.end; // cmpxchg.nostore:; // %loaded.nostore = phi [%unreleasedload, %cmpxchg.start],; // [%releasedload,; // %cmpxchg.releasedload/%cmpxchg.trystore]; // @load_linked_fail_balance()?; // br label %cmpxchg.failure; // cmpxchg.failure:; // fence?; // br label %cmpxchg.end; // cmpxchg.end:; // %loaded.exit = phi [%loaded.nostore, %cmpxchg.failure],; // [%loaded.trystore, %cmpxchg.trystore]; // %success = phi i1 [true, %cmpxchg.success], [false, %cmpxchg.failure]; // %loaded = extract value from %loaded.exit; // %restmp = insertvalue { iN, i1 } undef, iN %loaded, 0; // %res = insertvalue { iN, i1 } %restmp, i1 %success, 1; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:3,Deployability,Update,Update,3,// Update PHI node in TryStoreBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:198,Energy Efficiency,monitor,monitor,198,"// In the failing case, where we don't execute the store-conditional, the; // target might want to balance out the load-linked with a dedicated; // instruction (e.g., on ARM, clearing the exclusive monitor).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:115,Performance,load,load-linked,115,"// In the failing case, where we don't execute the store-conditional, the; // target might want to balance out the load-linked with a dedicated; // instruction (e.g., on ARM, clearing the exclusive monitor).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:175,Usability,clear,clearing,175,"// In the failing case, where we don't execute the store-conditional, the; // target might want to balance out the load-linked with a dedicated; // instruction (e.g., on ARM, clearing the exclusive monitor).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:171,Performance,load,loaded,171,"// Finally, we have control-flow based knowledge of whether the cmpxchg; // succeeded or not. We expose this to later passes by converting any; // subsequent ""icmp eq/ne %loaded, %oldval"" into a use of an appropriate; // PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:97,Security,expose,expose,97,"// Finally, we have control-flow based knowledge of whether the cmpxchg; // succeeded or not. We expose this to later passes by converting any; // subsequent ""icmp eq/ne %loaded, %oldval"" into a use of an appropriate; // PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:65,Performance,load,loaded,65,"// Look for any users of the cmpxchg that are just comparing the loaded value; // against the desired one, and replace them with the CFG-derived version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:132,Performance,load,load,132,"// Given: atomicrmw some_op iN* %addr, iN %incr ordering; //; // The standard expansion we produce is:; // [...]; // %init_loaded = load atomic iN* %addr; // br label %loop; // loop:; // %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; // %new = some_op iN %loaded, %incr; // %pair = cmpxchg iN* %addr, iN %loaded, iN %new; // %new_loaded = extractvalue { iN, i1 } %pair, 0; // %success = extractvalue { iN, i1 } %pair, 1; // br i1 %success, label %atomicrmw.end, label %loop; // atomicrmw.end:; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:188,Performance,load,loaded,188,"// Given: atomicrmw some_op iN* %addr, iN %incr ordering; //; // The standard expansion we produce is:; // [...]; // %init_loaded = load atomic iN* %addr; // br label %loop; // loop:; // %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; // %new = some_op iN %loaded, %incr; // %pair = cmpxchg iN* %addr, iN %loaded, iN %new; // %new_loaded = extractvalue { iN, i1 } %pair, 0; // %success = extractvalue { iN, i1 } %pair, 1; // br i1 %success, label %atomicrmw.end, label %loop; // atomicrmw.end:; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:276,Performance,load,loaded,276,"// Given: atomicrmw some_op iN* %addr, iN %incr ordering; //; // The standard expansion we produce is:; // [...]; // %init_loaded = load atomic iN* %addr; // br label %loop; // loop:; // %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; // %new = some_op iN %loaded, %incr; // %pair = cmpxchg iN* %addr, iN %loaded, iN %new; // %new_loaded = extractvalue { iN, i1 } %pair, 0; // %success = extractvalue { iN, i1 } %pair, 1; // br i1 %success, label %atomicrmw.end, label %loop; // atomicrmw.end:; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:325,Performance,load,loaded,325,"// Given: atomicrmw some_op iN* %addr, iN %incr ordering; //; // The standard expansion we produce is:; // [...]; // %init_loaded = load atomic iN* %addr; // br label %loop; // loop:; // %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; // %new = some_op iN %loaded, %incr; // %pair = cmpxchg iN* %addr, iN %loaded, iN %new; // %new_loaded = extractvalue { iN, i1 } %pair, 0; // %success = extractvalue { iN, i1 } %pair, 1; // br i1 %success, label %atomicrmw.end, label %loop; // atomicrmw.end:; // [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:108,Performance,load,load,108,"// The split call above ""helpfully"" added a branch at the end of BB (to the; // wrong place), but we want a load. It's easiest to just remove; // the branch entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:26,Security,expose,exposed,26,// Note: This function is exposed externally by AtomicExpandUtils.h,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:358,Availability,reliab,reliable,358,"// TODO: ""LargestSize"" is an approximation for ""largest type that; // you can express in C"". It seems to be the case that int128 is; // supported on all 64-bit platforms, otherwise only up to 64-bit; // integers are supported. If we get this wrong, then we'll try to; // call a sized libcall that doesn't actually exist. There should; // really be some more reliable way in LLVM of determining integer; // sizes which are valid in the target's C ABI...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:26,Availability,avail,available,26,// No atomic libcalls are available for max/min/umax/umin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:12,Integrability,rout,routine,12,"// A helper routine for the above expandAtomic*ToLibcall functions.; //; // 'Libcalls' contains an array of enum values for the particular; // ATOMIC libcalls to be emitted. All of the other arguments besides; // 'I' are extracted from the Instruction subclass by the; // caller. Depending on the particular call, some will be null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:280,Integrability,Depend,Depending,280,"// A helper routine for the above expandAtomic*ToLibcall functions.; //; // 'Libcalls' contains an array of enum values for the particular; // ATOMIC libcalls to be emitted. All of the other arguments besides; // 'I' are extracted from the Instruction subclass by the; // caller. Depending on the particular call, some will be null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1088,Integrability,depend,depending,1088,"// Build up the function call. There's two kinds. First, the sized; // variants. These calls are going to be one of the following (with; // N=1,2,4,8,16):; // iN __atomic_load_N(iN *ptr, int ordering); // void __atomic_store_N(iN *ptr, iN val, int ordering); // iN __atomic_{exchange|fetch_*}_N(iN *ptr, iN val, int ordering); // bool __atomic_compare_exchange_N(iN *ptr, iN *expected, iN desired,; // int success_order, int failure_order); //; // Note that these functions can be used for non-integer atomic; // operations, the values just need to be bitcast to integers on the; // way in and out.; //; // And, then, the generic variants. They look like the following:; // void __atomic_load(size_t size, void *ptr, void *ret, int ordering); // void __atomic_store(size_t size, void *ptr, void *val, int ordering); // void __atomic_exchange(size_t size, void *ptr, void *val, void *ret,; // int ordering); // bool __atomic_compare_exchange(size_t size, void *ptr, void *expected,; // void *desired, int success_order,; // int failure_order); //; // The different signatures are built up depending on the; // 'UseSizedLibcall', 'CASExpected', 'ValueOperand', and 'HasResult'; // variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:1179,Modifiability,variab,variables,1179,"// Build up the function call. There's two kinds. First, the sized; // variants. These calls are going to be one of the following (with; // N=1,2,4,8,16):; // iN __atomic_load_N(iN *ptr, int ordering); // void __atomic_store_N(iN *ptr, iN val, int ordering); // iN __atomic_{exchange|fetch_*}_N(iN *ptr, iN val, int ordering); // bool __atomic_compare_exchange_N(iN *ptr, iN *expected, iN desired,; // int success_order, int failure_order); //; // Note that these functions can be used for non-integer atomic; // operations, the values just need to be bitcast to integers on the; // way in and out.; //; // And, then, the generic variants. They look like the following:; // void __atomic_load(size_t size, void *ptr, void *ret, int ordering); // void __atomic_store(size_t size, void *ptr, void *val, int ordering); // void __atomic_exchange(size_t size, void *ptr, void *val, void *ret,; // int ordering); // bool __atomic_compare_exchange(size_t size, void *ptr, void *expected,; // void *desired, int success_order,; // int failure_order); //; // The different signatures are built up depending on the; // 'UseSizedLibcall', 'CASExpected', 'ValueOperand', and 'HasResult'; // variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:191,Modifiability,extend,extend,191,"// 'ptr' argument.; // note: This assumes all address spaces share a common libfunc; // implementation and that addresses are convertable. For systems without; // that property, we'd need to extend this mechanism to support AS-specific; // families of atomic intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:37,Performance,load,load,37,"// The final result from the CAS is {load of 'expected' alloca, bool result; // from call}",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockPathCloning.cpp:3,Safety,Avoid,Avoid,3,"// Avoid cloning when the block contains non-duplicable instructions.; // CFI instructions are marked as non-duplicable only because of Darwin,; // so we exclude them from this check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockPathCloning.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockPathCloning.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:1089,Performance,optimiz,optimized,1089,"Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // BasicBlockSections implementation.; //; // The purpose of this pass is to assign sections to basic blocks when; // -fbasic-block-sections= option is used. Further, with profile information; // only the subset of basic blocks with profiles are placed in separate sections; // and the rest are grouped in a cold section. The exception handling blocks are; // treated specially to ensure they are all in one seciton.; //; // Basic Block Sections; // ====================; //; // With option, -fbasic-block-sections=list, every function may be split into; // clusters of basic blocks. Every cluster will be emitted into a separate; // section with its basic blocks sequenced in the given order. To get the; // optimized performance, the clusters must form an optimal BB layout for the; // function. We insert a symbol at the beginning of every cluster's section to; // allow the linker to reorder the sections in any arbitrary sequence. A global; // order of these sections would encapsulate the function layout.; // For example, consider the following clusters for a function foo (consisting; // of 6 basic blocks 0, 1, ..., 5).; //; // 0 2; // 1 3 5; //; // * Basic blocks 0 and 2 are placed in one section with symbol `foo`; // referencing the beginning of this section.; // * Basic blocks 1, 3, 5 are placed in a separate section. A new symbol; // `foo.__part.1` will reference the beginning of this section.; // * Basic block 4 (note that it is not referenced in the list) is placed in; // one section, and a new symbol `foo.cold` will point to it.; //; // There are a couple of challenges to be addressed:; //; // 1. The last basic block of every cluster should not have any implicit; // fallthrough to its next basic block, as it can be re",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:1099,Performance,perform,performance,1099,"Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // BasicBlockSections implementation.; //; // The purpose of this pass is to assign sections to basic blocks when; // -fbasic-block-sections= option is used. Further, with profile information; // only the subset of basic blocks with profiles are placed in separate sections; // and the rest are grouped in a cold section. The exception handling blocks are; // treated specially to ensure they are all in one seciton.; //; // Basic Block Sections; // ====================; //; // With option, -fbasic-block-sections=list, every function may be split into; // clusters of basic blocks. Every cluster will be emitted into a separate; // section with its basic blocks sequenced in the given order. To get the; // optimized performance, the clusters must form an optimal BB layout for the; // function. We insert a symbol at the beginning of every cluster's section to; // allow the linker to reorder the sections in any arbitrary sequence. A global; // order of these sections would encapsulate the function layout.; // For example, consider the following clusters for a function foo (consisting; // of 6 basic blocks 0, 1, ..., 5).; //; // 0 2; // 1 3 5; //; // * Basic blocks 0 and 2 are placed in one section with symbol `foo`; // referencing the beginning of this section.; // * Basic blocks 1, 3, 5 are placed in a separate section. A new symbol; // `foo.__part.1` will reference the beginning of this section.; // * Basic block 4 (note that it is not referenced in the list) is placed in; // one section, and a new symbol `foo.cold` will point to it.; //; // There are a couple of challenges to be addressed:; //; // 1. The last basic block of every cluster should not have any implicit; // fallthrough to its next basic block, as it can be re",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:3419,Testability,log,logic,3419,"ing the beginning of this section.; // * Basic blocks 1, 3, 5 are placed in a separate section. A new symbol; // `foo.__part.1` will reference the beginning of this section.; // * Basic block 4 (note that it is not referenced in the list) is placed in; // one section, and a new symbol `foo.cold` will point to it.; //; // There are a couple of challenges to be addressed:; //; // 1. The last basic block of every cluster should not have any implicit; // fallthrough to its next basic block, as it can be reordered by the linker.; // The compiler should make these fallthroughs explicit by adding; // unconditional jumps..; //; // 2. All inter-cluster branch targets would now need to be resolved by the; // linker as they cannot be calculated during compile time. This is done; // using static relocations. Further, the compiler tries to use short branch; // instructions on some ISAs for small branch offsets. This is not possible; // for inter-cluster branches as the offset is not determined at compile; // time, and therefore, long branch instructions have to be used for those.; //; // 3. Debug Information (DebugInfo) and Call Frame Information (CFI) emission; // needs special handling with basic block sections. DebugInfo needs to be; // emitted with more relocations as basic block sections can break a; // function into potentially several disjoint pieces, and CFI needs to be; // emitted per cluster. This also bloats the object file and binary sizes.; //; // Basic Block Labels; // ==================; //; // With -fbasic-block-sections=labels, we encode the offsets of BB addresses of; // every function into the .llvm_bb_addr_map section. Along with the function; // symbols, this allows for mapping of virtual addresses in PMU profiles back to; // the corresponding basic blocks. This logic is implemented in AsmPrinter. This; // pass only assigns the BBSectionType of every function to ``labels``.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:98,Performance,optimiz,optimizations,98,"// Placing the cold clusters in a separate section mitigates against poor; // profiles and allows optimizations such as hugepage mapping to be applied at a; // section granularity. Defaults to "".text.split."" which is recognized by lld; // via the `-z keep-text-section-prefix` flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:17,Deployability,update,updates,17,// This function updates and optimizes the branching instructions of every basic; // block in a given function to account for changes in the layout.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:29,Performance,optimiz,optimizes,29,// This function updates and optimizes the branching instructions of every basic; // block in a given function to account for changes in the layout.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:13,Performance,optimiz,optimize,13,"// We do not optimize branches for machine basic blocks ending sections, as; // their adjacent block might be reordered by the linker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:27,Performance,optimiz,optimize,27,// It might be possible to optimize branches by flipping the branch; // condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:8,Modifiability,variab,variable,8,"// This variable stores the section ID of the cluster containing eh_pads (if; // all eh_pads are one cluster). If more than one cluster contain eh_pads, we; // set it equal to ExceptionSectionID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:67,Deployability,update,updated,67,"// If we already have one cluster containing eh_pads, this must be updated; // to ExceptionSectionID. Otherwise, we set it equal to the current; // section ID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:42,Deployability,update,update,42,"// After reordering basic blocks, we must update basic block branches to; // insert explicit fallthrough branches when required and optimize branches; // when possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:132,Performance,optimiz,optimize,132,"// After reordering basic blocks, we must update basic block branches to; // insert explicit fallthrough branches when required and optimize branches; // when possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:91,Performance,optimiz,optimizing,91,"// Check for source drift. If the source has changed since the profiles; // were obtained, optimizing basic blocks might be sub-optimal.; // This only applies to BasicBlockSection::List as it creates; // clusters of basic blocks using basic block ids. Source drift can; // invalidate these groupings leading to sub-optimal code generation with; // regards to performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:359,Performance,perform,performance,359,"// Check for source drift. If the source has changed since the profiles; // were obtained, optimizing basic blocks might be sub-optimal.; // This only applies to BasicBlockSection::List as it creates; // clusters of basic blocks using basic block ids. Source drift can; // invalidate these groupings leading to sub-optimal code generation with; // regards to performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:59,Security,access,accessing,59,// Renumber blocks before sorting them. This is useful for accessing the; // original layout positions and finding the original fallthroughs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp:10,Availability,error,error,10,// Report error when multiple profiles have been specified for the same; // function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp:52,Safety,avoid,avoid,52,// We won't need DIFilename anymore. Clean it up to avoid its application; // on the next function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp:10,Availability,error,error,10,// Report error when multiple profiles have been specified for the same; // function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp:719,Performance,load,loaded,719,"// Basic Block Sections can be enabled for a subset of machine basic blocks.; // This is done by passing a file containing names of functions for which basic; // block sections are desired. Additionally, machine basic block ids of the; // functions can also be specified for a finer granularity. Moreover, a cluster; // of basic blocks could be assigned to the same section.; // Optionally, a debug-info filename can be specified for each function to allow; // distinguishing internal-linkage functions of the same name.; // A file with basic block sections for all of function main and three blocks; // for function foo (of which 1 and 2 are placed in a cluster) looks like this:; // (Profile for function foo is only loaded when its debug-info filename; // matches 'path/to/foo_file.cc').; // ----------------------------; // list.txt:; // !main; // !foo M=path/to/foo_file.cc; // !!1 2; // !!4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp:50,Availability,down,downstream,50,// TODO: Deprecate V0 once V1 is fully integrated downstream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp:39,Deployability,integrat,integrated,39,// TODO: Deprecate V0 once V1 is fully integrated downstream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp:39,Integrability,integrat,integrated,39,// TODO: Deprecate V0 once V1 is fully integrated downstream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicTargetTransformInfo.cpp:643,Integrability,interface,interface,643,"//===- BasicTargetTransformInfo.cpp - Basic target-independent TTI impl ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file provides the implementation of a basic TargetTransformInfo pass; /// predicated on the target abstractions present in the target independent; /// code generator. It uses these (primarily TargetLowering) to model as much; /// of the TTI query interface as possible. It is included by most targets so; /// that they can specialize only a small subset of the query space.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BasicTargetTransformInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicTargetTransformInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:3,Performance,Throttle,Throttle,3,// Throttle for huge numbers of predecessors (compile speed problems),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:23,Integrability,Wrap,Wrap,23,/// BranchFolderPass - Wrap branch folder in a machine function pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:3,Safety,Avoid,Avoid,3,// Avoid matching if this pointer gets reused.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:3,Deployability,Update,Update,3,// Update call site info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:195,Security,Hash,HashMachineInstr,195,//===----------------------------------------------------------------------===//; // Tail Merging of Blocks; //===----------------------------------------------------------------------===//; /// HashMachineInstr - Compute a hash value for MI and its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:224,Security,hash,hash,224,//===----------------------------------------------------------------------===//; // Tail Merging of Blocks; //===----------------------------------------------------------------------===//; /// HashMachineInstr - Compute a hash value for MI and its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:138,Security,hash,hash,138,// Merge in bits from the operand if easy. We can't use MachineOperand's; // hash_code here because it's not deterministic and we sort by hash value; // later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:4,Security,Hash,HashEndOfMBB,4,/// HashEndOfMBB - Hash the last instruction in the MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:19,Security,Hash,Hash,19,/// HashEndOfMBB - Hash the last instruction in the MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:213,Performance,optimiz,optimizations,213,// FIXME: This check is dubious. It's used to get around a problem where; // people incorrectly expect inline asm directives to remain in the same; // relative order. This is untenable because normal compiler; // optimizations (like this one) may reorder and/or merge these; // directives.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:10,Modifiability,inherit,inherits,10,// NewMBB inherits CurMBB's block frequency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:199,Performance,optimiz,optimize,199,"// CurMBB needs to add an unconditional branch to SuccMBB (we removed these; // branches temporarily for tail merging). In the case where CurMBB ends; // with a conditional branch to the next block, optimize by reversing the; // test and conditionally branching to SuccMBB instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:229,Testability,test,test,229,"// CurMBB needs to add an unconditional branch to SuccMBB (we removed these; // branches temporarily for tail merging). In the case where CurMBB ends; // with a conditional branch to the next block, optimize by reversing the; // test and conditionally branching to SuccMBB instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:892,Usability,undo,undoing,892,"/// ProfitableToMerge - Check if two machine basic blocks have a common tail; /// and decide if it would be profitable to merge those tails. Return the; /// length of the common tail and iterators to the first common instruction; /// in each block.; /// MBB1, MBB2 The blocks to check; /// MinCommonTailLength Minimum size of tail block to be merged.; /// CommonTailLen Out parameter to record the size of the shared tail between; /// MBB1 and MBB2; /// I1, I2 Iterator references that will be changed to point to the first; /// instruction in the common tail shared by MBB1,MBB2; /// SuccBB A common successor of MBB1, MBB2 which are in a canonical form; /// relative to SuccBB; /// PredBB The layout predecessor of SuccBB, if any.; /// EHScopeMembership map from block to EH scope #.; /// AfterPlacement True if we are merging blocks after layout. Stricter; /// thresholds apply to prevent undoing tail-duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:116,Safety,avoid,avoid,116,// Move the iterators to the beginning of the MBB if we only got debug; // instructions before the tail. This is to avoid splitting a block when we; // only got debug instructions before the tail (to be invariant on -g).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:334,Energy Efficiency,reduce,reduce,334,"// If these are identical non-return blocks with no successors, merge them.; // Such blocks are typically cold calls to noreturn functions like abort, and; // are unlikely to become a fallthrough target after machine block placement.; // Tail merging these blocks is unlikely to create additional unconditional; // branches, and will reduce the size of this cold code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:144,Safety,abort,abort,144,"// If these are identical non-return blocks with no successors, merge them.; // Such blocks are typically cold calls to noreturn functions like abort, and; // are unlikely to become a fallthrough target after machine block placement.; // Tail merging these blocks is unlikely to create additional unconditional; // branches, and will reduce the size of this cold code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:188,Integrability,depend,depends,188,"// If both blocks are identical and end in a branch, merge them unless they; // both have a fallthrough predecessor and successor.; // We can only do this after block placement because it depends on whether; // there are fallthroughs, and we don't know until after layout.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:13,Performance,optimiz,optimizing,13,"// If we are optimizing for code size, 2 instructions in common is enough if; // we don't have to split a block. At worst we will be introducing 1 new; // branch instruction, which is likely to be smaller than the 2; // instructions that would be deleted in the merge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:111,Testability,log,logic,111,// Skip the register if we are about to add one of its super registers.; // TODO: Common this up with the same logic in addLineIns().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:11,Security,hash,hash,11,// Sort by hash value so that blocks with identical end sequences sort; // together.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:60,Security,hash,hash,60,"// Build SameTails, identifying the set of blocks with this hash code; // and with the maximum number of instructions in common.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:124,Security,hash,hash,124,"// If we didn't find any pair that has at least MinCommonTailLength; // instructions in common, remove all blocks with this hash code and retry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:31,Safety,avoid,avoid,31,"// If this is a large problem, avoid visiting the same basic blocks; // multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:725,Performance,Optimiz,OptimizeBranches,725,"// Look at blocks (IBB) with multiple predecessors (PBB).; // We change each predecessor to a canonical form, by; // (1) temporarily removing any unconditional branch from the predecessor; // to IBB, and; // (2) alter conditional branches so they branch to the other block; // not IBB; this may require adding back an unconditional branch to IBB; // later, where there wasn't one coming in. E.g.; // Bcc IBB; // fallthrough to QBB; // here becomes; // Bncc QBB; // with a conceptual B to IBB after that, which never actually exists.; // With those changes, we see whether the predecessors' tails match,; // and merge them if so. We change things out of canonical form and; // back to the way they were later in the process. (OptimizeBranches; // would undo some of this, but we can't use it, because we'd get into; // a compile-time infinite loop repeatedly doing and undoing the same; // transformations.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:752,Usability,undo,undo,752,"// Look at blocks (IBB) with multiple predecessors (PBB).; // We change each predecessor to a canonical form, by; // (1) temporarily removing any unconditional branch from the predecessor; // to IBB, and; // (2) alter conditional branches so they branch to the other block; // not IBB; this may require adding back an unconditional branch to IBB; // later, where there wasn't one coming in. E.g.; // Bcc IBB; // fallthrough to QBB; // here becomes; // Bncc QBB; // with a conceptual B to IBB after that, which never actually exists.; // With those changes, we see whether the predecessors' tails match,; // and merge them if so. We change things out of canonical form and; // back to the way they were later in the process. (OptimizeBranches; // would undo some of this, but we can't use it, because we'd get into; // a compile-time infinite loop repeatedly doing and undoing the same; // transformations.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:868,Usability,undo,undoing,868,"// Look at blocks (IBB) with multiple predecessors (PBB).; // We change each predecessor to a canonical form, by; // (1) temporarily removing any unconditional branch from the predecessor; // to IBB, and; // (2) alter conditional branches so they branch to the other block; // not IBB; this may require adding back an unconditional branch to IBB; // later, where there wasn't one coming in. E.g.; // Bcc IBB; // fallthrough to QBB; // here becomes; // Bncc QBB; // with a conceptual B to IBB after that, which never actually exists.; // With those changes, we see whether the predecessors' tails match,; // and merge them if so. We change things out of canonical form and; // back to the way they were later in the process. (OptimizeBranches; // would undo some of this, but we can't use it, because we'd get into; // a compile-time infinite loop repeatedly doing and undoing the same; // transformations.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:401,Modifiability,flexible,flexible,401,"// Bail if merging after placement and IBB is the loop header because; // -- If merging predecessors that belong to the same loop as IBB, the; // common tail of merged predecessors may become the loop top if block; // placement is called again and the predecessors may branch to this common; // tail and require more branches. This can be relaxed if; // MachineBlockPlacement::findBestLoopTop is more flexible.; // --If merging predecessors that do not belong to the same loop as IBB, the; // loop info of IBB's loop and the other loops may be affected. Calling the; // block placement again may make big change to the layout and eliminate the; // reason to do tail merging here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:31,Safety,avoid,avoid,31,"// If this is a large problem, avoid visiting the same basic blocks multiple; // times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:92,Performance,Optimiz,Optimization,92,//===----------------------------------------------------------------------===//; // Branch Optimization; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:53,Usability,clear,clearly,53,"/// IsBetterFallthrough - Return true if it would be clearly better to; /// fall-through to MBB1 than to fall through into MBB2. This has to return; /// a strict ordering, returning true for both (MBB1,MBB2) and (MBB2,MBB1) will; /// result in infinite loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:148,Performance,optimiz,optimize,148,"// Right now, we use a simple heuristic. If MBB2 ends with a call, and; // MBB1 doesn't, we prefer to fall through into MBB1. This allows us to; // optimize branches that branch to either a return block or an assert block; // into a fallthrough to the return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:209,Testability,assert,assert,209,"// Right now, we use a simple heuristic. If MBB2 ends with a call, and; // MBB1 doesn't, we prefer to fall through into MBB1. This allows us to; // optimize branches that branch to either a return block or an assert block; // into a fallthrough to the return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:23,Usability,simpl,simple,23,"// Right now, we use a simple heuristic. If MBB2 ends with a call, and; // MBB1 doesn't, we prefer to fall through into MBB1. This allows us to; // optimize branches that branch to either a return block or an assert block; // into a fallthrough to the return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:17,Usability,clear,clear,17,// If there is a clear successor ordering we make sure that one block; // will fall through to the next,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:261,Usability,simpl,simple,261,"// Try to salvage DBG_VALUE instructions from an otherwise empty block. If such; // a basic block is removed we would lose the debug information unless we have; // copied the information to a predecessor/successor.; //; // TODO: This function only handles some simple cases. An alternative would be; // to run a heavier analysis, such as the LiveDebugValues pass, before we do; // branch folding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:230,Performance,optimiz,optimized,230,"// If this block is empty, make everyone use its fall-through, not the block; // explicitly. Landing pads should not do this since the landing-pad table; // points to this block. Blocks with their addresses taken shouldn't be; // optimized away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:9,Usability,Simpl,Simplify,9,// TODO: Simplify preds to not branch here if possible!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:9,Modifiability,rewrite,rewrite,9,"// Don't rewrite to a landing pad fallthough. That could lead to the case; // where a BB jumps to more than one landing pad.; // TODO: Is it ever worth rewriting predecessors which don't already; // jump to a landing pad, and so can safely jump to the fallthrough?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:233,Safety,safe,safely,233,"// Don't rewrite to a landing pad fallthough. That could lead to the case; // where a BB jumps to more than one landing pad.; // TODO: Is it ever worth rewriting predecessors which don't already; // jump to a landing pad, and so can safely jump to the fallthrough?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite all predecessors of the old block to go to the fallthrough; // instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:42,Deployability,update,update,42,"// If MBB was the target of a jump table, update jump tables to go to the; // fallthrough instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:26,Usability,simpl,simplify,26,// Check to see if we can simplify the terminator of the block before this; // one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:206,Usability,Simpl,SimplifyCFG,206,"// If the previous block unconditionally falls through to this block and; // this block has no other predecessors, move the contents of this block; // into the prior block. This doesn't usually happen when SimplifyCFG; // has been used, but it can happen if tail merging splits a fall-through; // predecessor of a block.; // This has to check PrevBB->succ_size() because EH edges are ignored by; // analyzeBranch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:10,Availability,redundant,redundant,10,// Remove redundant DBG_VALUEs first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:10,Safety,redund,redundant,10,// Remove redundant DBG_VALUEs first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:115,Safety,abort,abort,115,"// If this block has no successors (e.g. it is a return block or ends with; // a call to a no-return function like abort or __cxa_throw) and if the pred; // falls through into this block, and if it would otherwise fall through; // into the block after this, move this block to the end of the function.; //; // We consider it more likely that execution will stay in the function (e.g.; // due to loops) than it is to exit it. This asserts in loops etc, moving; // the assert condition out of the loop body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:430,Testability,assert,asserts,430,"// If this block has no successors (e.g. it is a return block or ends with; // a call to a no-return function like abort or __cxa_throw) and if the pred; // falls through into this block, and if it would otherwise fall through; // into the block after this, move this block to the end of the function.; //; // We consider it more likely that execution will stay in the function (e.g.; // due to loops) than it is to exit it. This asserts in loops etc, moving; // the assert condition out of the loop body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:467,Testability,assert,assert,467,"// If this block has no successors (e.g. it is a return block or ends with; // a call to a no-return function like abort or __cxa_throw) and if the pred; // falls through into this block, and if it would otherwise fall through; // into the block after this, move this block to the end of the function.; //; // We consider it more likely that execution will stay in the function (e.g.; // due to loops) than it is to exit it. This asserts in loops etc, moving; // the assert condition out of the loop body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:259,Usability,clear,clearly,259,"// We have to be careful that the succs of PredBB aren't both no-successor; // blocks. If neither have successors and if PredBB is the second from; // last block in the function, we'd just keep swapping the two blocks for; // last. Only do the swap if one is clearly better to fall through than; // the other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:251,Safety,risk,risk,251,"// If the predecessor is falling through to this block, we could reverse; // the branch condition and fold the tail call into that. However, after; // that we might have to re-arrange the CFG to fall through to the other; // block and there is a high risk of regressing code size rather than; // improving it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:95,Deployability,update,updates,95,"// If the prior block falls through into us, turn it into an; // explicit branch to us to make updates simpler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:103,Usability,simpl,simpler,103,"// If the prior block falls through into us, turn it into an; // explicit branch to us to make updates simpler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:226,Safety,avoid,avoid,226,"// If the current block doesn't fall through, just move it.; // If the current block can fall through and does not end with a; // conditional branch, we need to append an unconditional jump to; // the (current) next block. To avoid a possible compile-time; // infinite loop, move blocks only backward in this case.; // Also, if there are already 2 branches here, we cannot add a third;; // this means we have the case; // Bcc next; // B elsewhere; // next:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:294,Performance,perform,perform,294,"// Okay, there is no really great place to put this block. If, however,; // the block before this one would be a fall-through if this block were; // removed, move this block to the end of the function. There is no real; // advantage in ""falling through"" to an EH block, so we don't want to; // perform this transformation for that case.; //; // Also, Windows EH introduced the possibility of an arbitrary number of; // successors to a given block. The analyzeBranch call does not consider; // exception handling and so we can get in a state where a block; // containing a call is followed by multiple EH blocks that would be; // rotated infinitely at the end of the function if the transformation; // below were performed for EH ""FallThrough"" blocks. Therefore, even if; // that appears not to be happening anymore, we should assume that it is; // possible and not remove the ""!FallThrough()->isEHPad"" condition below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:712,Performance,perform,performed,712,"// Okay, there is no really great place to put this block. If, however,; // the block before this one would be a fall-through if this block were; // removed, move this block to the end of the function. There is no real; // advantage in ""falling through"" to an EH block, so we don't want to; // perform this transformation for that case.; //; // Also, Windows EH introduced the possibility of an arbitrary number of; // successors to a given block. The analyzeBranch call does not consider; // exception handling and so we can get in a state where a block; // containing a call is followed by multiple EH blocks that would be; // rotated infinitely at the end of the function if the transformation; // below were performed for EH ""FallThrough"" blocks. Therefore, even if; // that appears not to be happening anymore, we should assume that it is; // possible and not remove the ""!FallThrough()->isEHPad"" condition below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:509,Safety,safe,safety,509,"/// findHoistingInsertPosAndDeps - Find the location to move common instructions; /// in successors to. The location is usually just before the terminator,; /// however if the terminator is a conditional branch and its previous; /// instruction is the flag setting instruction, the previous instruction is; /// the preferred location. This function also gathers uses and defs of the; /// instructions from the insertion point to the end of the block. The data is; /// used by HoistCommonCodeInSuccs to ensure safety.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:132,Safety,safe,safely,132,"// If the terminator is the only instruction in the block and Uses is not; // empty (or we would have returned above), we can still safely hoist; // instructions just before the terminator as long as the Defs/Uses are not; // violated (which is checked in HoistCommonCodeInSuccs).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:209,Performance,optimiz,optimization,209,"// Be conservative, don't insert instruction above something that may have; // side-effects. And since it's potentially bad to separate flag setting; // instruction from the conditional branch, just abort the optimization; // completely.; // Also avoid moving code above predicated instruction since it's hard to; // reason about register liveness with predicated instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:199,Safety,abort,abort,199,"// Be conservative, don't insert instruction above something that may have; // side-effects. And since it's potentially bad to separate flag setting; // instruction from the conditional branch, just abort the optimization; // completely.; // Also avoid moving code above predicated instruction since it's hard to; // reason about register liveness with predicated instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:247,Safety,avoid,avoid,247,"// Be conservative, don't insert instruction above something that may have; // side-effects. And since it's potentially bad to separate flag setting; // instruction from the conditional branch, just abort the optimization; // completely.; // Also avoid moving code above predicated instruction since it's hard to; // reason about register liveness with predicated instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:47,Integrability,rout,routine,47,// Find out what registers are live. Note this routine is ignoring other live; // registers which are only used by instructions in successor blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:16,Performance,optimiz,optimization,16,"// Restrict the optimization to cases where MBB is the only predecessor,; // it is an obvious win.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:53,Availability,mask,masks,53,// Don't attempt to hoist instructions with register masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:3,Safety,Avoid,Avoid,3,// Avoid clobbering a register that's used by the instruction at; // the point of insertion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:30,Deployability,update,update,30,// Track local defs so we can update liveins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h:55,Performance,optimiz,optimizations,55,"/// Perhaps branch folding, tail merging and other CFG optimizations on the; /// given function. Block placement changes the layout and may create new; /// tail merging opportunities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h:61,Security,hash,hash,61,/// Look through all the blocks in MergePotentials that have hash CurHash; /// (guaranteed to match the last element). Build the vector SameTails of; /// all those that have the (same) largest number of instructions in common; /// of any pair of these blocks. SameTails entries contain an iterator into; /// MergePotentials (from which the MachineBasicBlock can be found) and a; /// MachineBasicBlock::iterator into that MBB indicating the instruction; /// where the matching code sequence begins. Order of elements in SameTails; /// is the reverse of the order in which those blocks appear in; /// MergePotentials (where they are not necessarily consecutive).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h:27,Security,hash,hash,27,"/// Remove all blocks with hash CurHash from MergePotentials, restoring; /// branches at ends of blocks as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h:16,Performance,optimiz,optimize,16,/// Analyze and optimize control flow related to the specified block. This; /// is never called on the entry block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:107,Deployability,Update,Update,107,"/// Split the basic block containing MI into two blocks, which are joined by; /// an unconditional branch. Update data structures and renumber blocks to; /// account for this change and returns the newly created block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:164,Availability,avail,available,164,// Add an unconditional branch from OrigBB to NewBB.; // Note the new unconditional branch is not being recorded.; // There doesn't seem to be meaningful DebugInfo available; this doesn't; // correspond to anything in the source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:76,Deployability,update,updateTerminator,76,// Cleanup potential unconditional branch to successor block.; // Note that updateTerminator may change the size of the blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:93,Safety,avoid,avoid,93,"// Since cross-section conditional branches to the cold section are rarely; // taken, try to avoid inverting the condition. Instead, add a ""trampoline; // branch"", which unconditionally branches to the branch destination. Place; // the trampoline branch at the end of the function and retarget the; // conditional branch to the trampoline.; // tbz L1; // =>; // tbz L1Trampoline; // ...; // L1Trampoline: b L1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:3,Deployability,Update,Update,3,// Update the successor lists to include the trampoline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:56,Usability,simpl,simply,56,// Last MI in the BB is an unconditional branch. We can simply invert the; // condition and swap destinations:; // beq L1; // b L2; // =>; // bne L2; // b L1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:3,Deployability,Update,Update,3,"// Update the succesor lists according to the transformation to follow.; // Do it here since if there's no split, no update is needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:117,Deployability,update,update,117,"// Update the succesor lists according to the transformation to follow.; // Do it here since if there's no split, no update is needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:3,Deployability,Update,Update,3,// Update the successor lists according to the transformation to follow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:3,Deployability,Update,Update,3,// Update successors and predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:3,Deployability,Update,Update,3,// Update the offset starting from the previous block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:215,Safety,avoid,avoid,215,"// Expand the unconditional branch first if necessary. If there is a; // conditional branch, this will end up changing the branch destination of; // it to be over the newly inserted indirect branch block, which may avoid; // the need to try expanding the conditional branch first, saving an extra; // jump.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:52,Integrability,Depend,Dependency,52,"//==- llvm/CodeGen/BreakFalseDeps.cpp - Break False Dependency Fix -*- C++ -*==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Break False Dependency pass.; ///; /// Some instructions have false dependencies which cause unnecessary stalls.; /// For example, instructions may write part of a register and implicitly; /// need to read the other parts of the register. This may cause unwanted; /// stalls preventing otherwise unrelated instructions from executing in; /// parallel in an out-of-order CPU.; /// This pass is aimed at identifying and avoiding these dependencies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:403,Integrability,Depend,Dependency,403,"//==- llvm/CodeGen/BreakFalseDeps.cpp - Break False Dependency Fix -*- C++ -*==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Break False Dependency pass.; ///; /// Some instructions have false dependencies which cause unnecessary stalls.; /// For example, instructions may write part of a register and implicitly; /// need to read the other parts of the register. This may cause unwanted; /// stalls preventing otherwise unrelated instructions from executing in; /// parallel in an out-of-order CPU.; /// This pass is aimed at identifying and avoiding these dependencies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:459,Integrability,depend,dependencies,459,"//==- llvm/CodeGen/BreakFalseDeps.cpp - Break False Dependency Fix -*- C++ -*==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Break False Dependency pass.; ///; /// Some instructions have false dependencies which cause unnecessary stalls.; /// For example, instructions may write part of a register and implicitly; /// need to read the other parts of the register. This may cause unwanted; /// stalls preventing otherwise unrelated instructions from executing in; /// parallel in an out-of-order CPU.; /// This pass is aimed at identifying and avoiding these dependencies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:824,Integrability,depend,dependencies,824,"//==- llvm/CodeGen/BreakFalseDeps.cpp - Break False Dependency Fix -*- C++ -*==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Break False Dependency pass.; ///; /// Some instructions have false dependencies which cause unnecessary stalls.; /// For example, instructions may write part of a register and implicitly; /// need to read the other parts of the register. This may cause unwanted; /// stalls preventing otherwise unrelated instructions from executing in; /// parallel in an out-of-order CPU.; /// This pass is aimed at identifying and avoiding these dependencies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:809,Safety,avoid,avoiding,809,"//==- llvm/CodeGen/BreakFalseDeps.cpp - Break False Dependency Fix -*- C++ -*==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Break False Dependency pass.; ///; /// Some instructions have false dependencies which cause unnecessary stalls.; /// For example, instructions may write part of a register and implicitly; /// need to read the other parts of the register. This may cause unwanted; /// stalls preventing otherwise unrelated instructions from executing in; /// parallel in an out-of-order CPU.; /// This pass is aimed at identifying and avoiding these dependencies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:4,Deployability,Update,Update,4,/// Update def-ages for registers defined by MI.; /// Also break dependencies on partial defs and undef uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:65,Integrability,depend,dependencies,65,/// Update def-ages for registers defined by MI.; /// Also break dependencies on partial defs and undef uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:22,Integrability,depend,dependencies,22,"/// Helps avoid false dependencies on undef registers by updating the; /// machine instructions' undef operand to use a register that the instruction; /// is truly dependent on, or use a register with clearance higher than Pref.; /// Returns true if it was able to find a true dependency, thus not requiring; /// a dependency breaking instruction regardless of clearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:164,Integrability,depend,dependent,164,"/// Helps avoid false dependencies on undef registers by updating the; /// machine instructions' undef operand to use a register that the instruction; /// is truly dependent on, or use a register with clearance higher than Pref.; /// Returns true if it was able to find a true dependency, thus not requiring; /// a dependency breaking instruction regardless of clearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:277,Integrability,depend,dependency,277,"/// Helps avoid false dependencies on undef registers by updating the; /// machine instructions' undef operand to use a register that the instruction; /// is truly dependent on, or use a register with clearance higher than Pref.; /// Returns true if it was able to find a true dependency, thus not requiring; /// a dependency breaking instruction regardless of clearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:315,Integrability,depend,dependency,315,"/// Helps avoid false dependencies on undef registers by updating the; /// machine instructions' undef operand to use a register that the instruction; /// is truly dependent on, or use a register with clearance higher than Pref.; /// Returns true if it was able to find a true dependency, thus not requiring; /// a dependency breaking instruction regardless of clearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:10,Safety,avoid,avoid,10,"/// Helps avoid false dependencies on undef registers by updating the; /// machine instructions' undef operand to use a register that the instruction; /// is truly dependent on, or use a register with clearance higher than Pref.; /// Returns true if it was able to find a true dependency, thus not requiring; /// a dependency breaking instruction regardless of clearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:201,Usability,clear,clearance,201,"/// Helps avoid false dependencies on undef registers by updating the; /// machine instructions' undef operand to use a register that the instruction; /// is truly dependent on, or use a register with clearance higher than Pref.; /// Returns true if it was able to find a true dependency, thus not requiring; /// a dependency breaking instruction regardless of clearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:361,Usability,clear,clearance,361,"/// Helps avoid false dependencies on undef registers by updating the; /// machine instructions' undef operand to use a register that the instruction; /// is truly dependent on, or use a register with clearance higher than Pref.; /// Returns true if it was able to find a true dependency, thus not requiring; /// a dependency breaking instruction regardless of clearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:46,Integrability,depend,dependence,46,/// Return true to if it makes sense to break dependence on a partial; /// def or undef use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:16,Integrability,depend,dependencies,16,"/// Break false dependencies on undefined register reads.; /// Walk the block backward computing precise liveness. This is expensive, so; /// we only do it on demand. Note that the occurrence of undefined register; /// reads that should be broken is very rare, but when they occur we may have; /// many in a single block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:3,Deployability,Update,Update,3,// Update only undef operands that have reg units that are mapped to one root.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:33,Integrability,depend,dependency,33,"// If the instruction has a true dependency, we can hide the false depdency; // behind it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:19,Integrability,depend,dependency,19,// We found a true dependency - replace the undef register with the true; // dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:77,Integrability,depend,dependency,77,// We found a true dependency - replace the undef register with the true; // dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:82,Usability,clear,clearance,82,// Go over all registers in the register class and find the register with; // max clearance or clearance higher than Pref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:95,Usability,clear,clearance,95,// Go over all registers in the register class and find the register with; // max clearance or clearance higher than Pref.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:3,Deployability,Update,Update,3,// Update the operand if we found a register with better clearance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:57,Usability,clear,clearance,57,// Update the operand if we found a register with better clearance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:9,Integrability,depend,dependence,9,// Break dependence on undef uses. Do this before updating LiveRegs below.; // This can remove a false dependence with no additional instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:103,Integrability,depend,dependence,103,// Break dependence on undef uses. Do this before updating LiveRegs below.; // This can remove a false dependence with no additional instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:181,Availability,avail,available,181,// We don't need to bother trying to break a dependency if this; // instruction has a true dependency on that register through another; // operand - we'll have to wait for it to be available regardless.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:45,Integrability,depend,dependency,45,// We don't need to bother trying to break a dependency if this; // instruction has a true dependency on that register through another; // operand - we'll have to wait for it to be available regardless.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:91,Integrability,depend,dependency,91,// We don't need to bother trying to break a dependency if this; // instruction has a true dependency on that register through another; // operand - we'll have to wait for it to be available regardless.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:81,Integrability,depend,dependence,81,"// The code below allows the target to create a new instruction to break the; // dependence. That opposes the goal of minimizing size, so bail out now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:43,Deployability,update,updates,43,// Check clearance before partial register updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:9,Usability,clear,clearance,9,// Check clearance before partial register updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:81,Integrability,depend,dependence,81,"// The code below allows the target to create a new instruction to break the; // dependence. That opposes the goal of minimizing size, so bail out now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:3,Deployability,Update,Update,3,"// Update liveness, including the current instruction's defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:247,Integrability,depend,dependencies,247,"// If this block is not done, it makes little sense to make any decisions; // based on clearance information. We need to make a second pass anyway,; // and by then we'll have better information, so we can avoid doing the work; // to try and break dependencies now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:205,Safety,avoid,avoid,205,"// If this block is not done, it makes little sense to make any decisions; // based on clearance information. We need to make a second pass anyway,; // and by then we'll have better information, so we can avoid doing the work; // to try and break dependencies now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:87,Usability,clear,clearance,87,"// If this block is not done, it makes little sense to make any decisions; // based on clearance information. We need to make a second pass anyway,; // and by then we'll have better information, so we can avoid doing the work; // to try and break dependencies now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp:10,Deployability,update,update,10,// Do not update future local split artifacts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp:66,Deployability,update,update,66,// Give extra weight to what looks like a loop induction variable update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp:57,Modifiability,variab,variable,57,// Give extra weight to what looks like a loop induction variable update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp:98,Availability,mask,mask,98,"// Mark li as unspillable if all live ranges are tiny and the interval; // is not live at any reg mask. If the interval is live at a reg mask; // spilling may be required. If li is live as use in statepoint instruction; // spilling may be required due to if we mark interval with use in statepoint; // as not spillable we are risky to end up with no register to allocate.; // At the same time STATEPOINT instruction is perfectly fine to have this; // operand on stack, so spilling such interval and folding its load from stack; // into instruction itself makes perfect sense.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp:137,Availability,mask,mask,137,"// Mark li as unspillable if all live ranges are tiny and the interval; // is not live at any reg mask. If the interval is live at a reg mask; // spilling may be required. If li is live as use in statepoint instruction; // spilling may be required due to if we mark interval with use in statepoint; // as not spillable we are risky to end up with no register to allocate.; // At the same time STATEPOINT instruction is perfectly fine to have this; // operand on stack, so spilling such interval and folding its load from stack; // into instruction itself makes perfect sense.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp:362,Energy Efficiency,allocate,allocate,362,"// Mark li as unspillable if all live ranges are tiny and the interval; // is not live at any reg mask. If the interval is live at a reg mask; // spilling may be required. If li is live as use in statepoint instruction; // spilling may be required due to if we mark interval with use in statepoint; // as not spillable we are risky to end up with no register to allocate.; // At the same time STATEPOINT instruction is perfectly fine to have this; // operand on stack, so spilling such interval and folding its load from stack; // into instruction itself makes perfect sense.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp:511,Performance,load,load,511,"// Mark li as unspillable if all live ranges are tiny and the interval; // is not live at any reg mask. If the interval is live at a reg mask; // spilling may be required. If li is live as use in statepoint instruction; // spilling may be required due to if we mark interval with use in statepoint; // as not spillable we are risky to end up with no register to allocate.; // At the same time STATEPOINT instruction is perfectly fine to have this; // operand on stack, so spilling such interval and folding its load from stack; // into instruction itself makes perfect sense.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp:326,Safety,risk,risky,326,"// Mark li as unspillable if all live ranges are tiny and the interval; // is not live at any reg mask. If the interval is live at a reg mask; // spilling may be required. If li is live as use in statepoint instruction; // spilling may be required due to if we mark interval with use in statepoint; // as not spillable we are risky to end up with no register to allocate.; // At the same time STATEPOINT instruction is perfectly fine to have this; // operand on stack, so spilling such interval and folding its load from stack; // into instruction itself makes perfect sense.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp:1535,Usability,simpl,simpler,1535,"//===-- CallBrPrepare - Prepare callbr for code generation ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass lowers callbrs in LLVM IR in order to to assist SelectionDAG's; // codegen.; //; // In particular, this pass assists in inserting register copies for the output; // values of a callbr along the edges leading to the indirect target blocks.; // Though the output SSA value is defined by the callbr instruction itself in; // the IR representation, the value cannot be copied to the appropriate virtual; // registers prior to jumping to an indirect label, since the jump occurs; // within the user-provided assembly blob.; //; // Instead, those copies must occur separately at the beginning of each; // indirect target. That requires that we create a separate SSA definition in; // each of them (via llvm.callbr.landingpad), and may require splitting; // critical edges so we have a location to place the intrinsic. Finally, we; // remap users of the original callbr output SSA value to instead point to the; // appropriate llvm.callbr.landingpad value.; //; // Ideally, this could be done inside SelectionDAG, or in the; // MachineInstruction representation, without the use of an IR-level intrinsic.; // But, within the current framework, it’s simpler to implement as an IR pass.; // (If support for callbr in GlobalISel is implemented, it’s worth considering; // whether this is still required.); //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp:9,Modifiability,rewrite,rewrite,9,// Don't rewrite the use in the newly inserted intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp:180,Availability,avail,available,180,"// It's highly likely that most programs do not contain CallBrInsts. Follow a; // similar pattern from SafeStackLegacyPass::runOnFunction to reuse previous; // domtree analysis if available, otherwise compute it lazily. This avoids; // forcing Dominator Tree Construction at -O0 for programs that likely do not; // contain CallBrInsts. It does pessimize programs with callbr at higher; // optimization levels, as the DominatorTree created here is not reused by; // subsequent passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp:389,Performance,optimiz,optimization,389,"// It's highly likely that most programs do not contain CallBrInsts. Follow a; // similar pattern from SafeStackLegacyPass::runOnFunction to reuse previous; // domtree analysis if available, otherwise compute it lazily. This avoids; // forcing Dominator Tree Construction at -O0 for programs that likely do not; // contain CallBrInsts. It does pessimize programs with callbr at higher; // optimization levels, as the DominatorTree created here is not reused by; // subsequent passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp:103,Safety,Safe,SafeStackLegacyPass,103,"// It's highly likely that most programs do not contain CallBrInsts. Follow a; // similar pattern from SafeStackLegacyPass::runOnFunction to reuse previous; // domtree analysis if available, otherwise compute it lazily. This avoids; // forcing Dominator Tree Construction at -O0 for programs that likely do not; // contain CallBrInsts. It does pessimize programs with callbr at higher; // optimization levels, as the DominatorTree created here is not reused by; // subsequent passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp:225,Safety,avoid,avoids,225,"// It's highly likely that most programs do not contain CallBrInsts. Follow a; // similar pattern from SafeStackLegacyPass::runOnFunction to reuse previous; // domtree analysis if available, otherwise compute it lazily. This avoids; // forcing Dominator Tree Construction at -O0 for programs that likely do not; // contain CallBrInsts. It does pessimize programs with callbr at higher; // optimization levels, as the DominatorTree created here is not reused by; // subsequent passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate space on the stack large enough to pass an argument by value.; /// The size and alignment information of the argument is encoded in; /// its parameter attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp:46,Energy Efficiency,allocate,allocated,46,/// Mark a register and all of its aliases as allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp:86,Performance,perform,performed,86,"/// Analyze the return values of a function, returning true if the return can; /// be performed without sret-demotion and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate something of this value type repeatedly until we get assigned a; // location in memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp:84,Energy Efficiency,allocate,allocated,84,"// Clear the assigned values and stack memory. We leave the registers marked; // as allocated so that future queries don't return the same registers, i.e.; // when i64 and f64 are both passed in GPRs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp:3,Usability,Clear,Clear,3,"// Clear the assigned values and stack memory. We leave the registers marked; // as allocated so that future queries don't return the same registers, i.e.; // when i64 and f64 are both passed in GPRs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CFIFixup.cpp:3230,Availability,down,down,3230,"/ has not executed any epilogue; // - ""does not have a call frame"", if the function has not executed the; // prologue, or has executed an epilogue; // which can be computed by a single RPO traversal.; // The location of the prologue is determined by finding the first block in the; // reverse traversal which contains CFI instructions.; // In order to accommodate backends which do not generate unwind info in; // epilogues we compute an additional property ""strong no call frame on entry"",; // which is set for the entry point of the function and for every block; // reachable from the entry along a path that does not execute the prologue. If; // this property holds, it takes precedence over the ""has a call frame""; // property.; // From the point of view of the unwind tables, the ""has/does not have call; // frame"" state at beginning of each block is determined by the state at the end; // of the previous block, in layout order. Where these states differ, we insert; // compensating CFI instructions, which come in two flavours:; // - CFI instructions, which reset the unwind table state to the initial one.; // This is done by a target specific hook and is expected to be trivial; // to implement, for example it could be:; // .cfi_def_cfa <sp>, 0; // .cfi_same_value <rN>; // .cfi_same_value <rN-1>; // ...; // where <rN> are the callee-saved registers.; // - CFI instructions, which reset the unwind table state to the one; // created by the function prologue. These are; // .cfi_restore_state; // .cfi_remember_state; // In this case we also insert a `.cfi_remember_state` after the last CFI; // instruction in the function prologue.; //; // Known limitations:; // * the pass cannot handle an epilogue preceding the prologue in the basic; // block layout; // * the pass does not handle functions where SP is used as a frame pointer and; // SP adjustments up and down are done in different basic blocks (TODO); //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CFIFixup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CFIFixup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CFIFixup.cpp:72,Modifiability,inherit,inherits,72,"// Walk the blocks of the function in ""physical"" order.; // Every block inherits the frame state (as recorded in the unwind tables); // of the previous block. If the intended frame state is different, insert; // compensating CFI instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CFIFixup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CFIFixup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CFIInstrInserter.cpp:4,Deployability,Update,Update,4,/// Update in/out cfa offset and register values for successors of the basic; /// block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CFIInstrInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CFIInstrInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CFIInstrInserter.cpp:3,Deployability,Update,Update,3,// Update outgoing CFA info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CFIInstrInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CFIInstrInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CFIInstrInserter.cpp:3,Deployability,Update,Update,3,// Update outgoing CSR info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CFIInstrInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CFIInstrInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGen.cpp:430,Integrability,rout,routines,430,"//===-- CodeGen.cpp -------------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the common initialization routines for the; // CodeGen library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenCommonISel.cpp:33,Testability,test,tests,33,// Pick the direction with fewer tests; // TODO: Handle more combinations of cases that can be handled together,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenCommonISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenCommonISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenCommonISel.cpp:151,Performance,perform,performance,151,"// These are arbitrary chosen limits on the maximum number of values and the; // maximum size of a debug expression we can salvage up to, used for; // performance reasons.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenCommonISel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenCommonISel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPassBuilder.cpp:401,Integrability,interface,interfaces,401,"//===--- CodeGenPassBuilder.cpp --------------------------------------- ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines interfaces to access the target independent code; // generation passes provided by the LLVM backend.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPassBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPassBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPassBuilder.cpp:415,Security,access,access,415,"//===--- CodeGenPassBuilder.cpp --------------------------------------- ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines interfaces to access the target independent code; // generation passes provided by the LLVM backend.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPassBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPassBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:135,Deployability,update,update,135,"/// As we scan instructions optimizing them, this is the next instruction; /// to optimize. Transforms that can invalidate this should update it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:28,Performance,optimiz,optimizing,28,"/// As we scan instructions optimizing them, this is the next instruction; /// to optimize. Transforms that can invalidate this should update it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:82,Performance,optimiz,optimize,82,"/// As we scan instructions optimizing them, this is the next instruction; /// to optimize. Transforms that can invalidate this should update it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:157,Performance,load,load,157,/// Keeps track of non-local addresses that have been sunk into a block.; /// This allows us to avoid inserting duplicate code for blocks with; /// multiple load/stores of the same address. The usage of WeakTrackingVH; /// enables SunkAddrs to be treated as a cache whose entries can be; /// invalidated if a sunken address computation has been erased.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:260,Performance,cache,cache,260,/// Keeps track of non-local addresses that have been sunk into a block.; /// This allows us to avoid inserting duplicate code for blocks with; /// multiple load/stores of the same address. The usage of WeakTrackingVH; /// enables SunkAddrs to be treated as a cache whose entries can be; /// invalidated if a sunken address computation has been erased.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:96,Safety,avoid,avoid,96,/// Keeps track of non-local addresses that have been sunk into a block.; /// This allows us to avoid inserting duplicate code for blocks with; /// multiple load/stores of the same address. The usage of WeakTrackingVH; /// enables SunkAddrs to be treated as a cache whose entries can be; /// invalidated if a sunken address computation has been erased.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:23,Security,access,accessing,23,/// Keep track of GEPs accessing the same data structures such as structs or; /// arrays that are candidates to be split later because of their large; /// size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:86,Deployability,update,update,86,"/// Building the dominator tree can be expensive, so we only build it; /// lazily and update it when required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:48,Deployability,update,updated,48,"/// FreshBBs is like worklist, it collected the updated BBs which need; /// to be optimized again.; /// Note: Consider building time in this pass, when a BB updated, we need; /// to insert such BB into FreshBBs for huge function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:157,Deployability,update,updated,157,"/// FreshBBs is like worklist, it collected the updated BBs which need; /// to be optimized again.; /// Note: Consider building time in this pass, when a BB updated, we need; /// to insert such BB into FreshBBs for huge function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:82,Performance,optimiz,optimized,82,"/// FreshBBs is like worklist, it collected the updated BBs which need; /// to be optimized again.; /// Note: Consider building time in this pass, when a BB updated, we need; /// to insert such BB into FreshBBs for huge function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Usability,Clear,Clear,3,// Clear per function information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:36,Usability,simpl,simplifications,36,"// Substituting can cause recursive simplifications, which can invalidate; // our iterator. Use a WeakTrackingVH to hold onto it in case this; // happens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:9,Performance,optimiz,optimization,9,"/// This optimization identifies DIV instructions that can be; /// profitably bypassed and carried out with a shorter, faster divide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:79,Performance,optimiz,optimization,79,"// bypassSlowDivision may create new BBs, but we don't want to reapply the; // optimization to those blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:16,Deployability,update,updated,16,"// If the BB is updated, it may still has chance to be optimized.; // This usually happen at sink optimization.; // For example:; //; // bb0：; // %and = and i32 %a, 4; // %cmp = icmp eq i32 %and, 0; //; // If the %cmp sink to other BB, the %and will has chance to sink.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:55,Performance,optimiz,optimized,55,"// If the BB is updated, it may still has chance to be optimized.; // This usually happen at sink optimization.; // For example:; //; // bb0：; // %and = and i32 %a, 4; // %cmp = icmp eq i32 %and, 0; //; // If the %cmp sink to other BB, the %and will has chance to sink.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:98,Performance,optimiz,optimization,98,"// If the BB is updated, it may still has chance to be optimized.; // This usually happen at sink optimization.; // For example:; //; // bb0：; // %and = and i32 %a, 4; // %cmp = icmp eq i32 %and, 0; //; // If the %cmp sink to other BB, the %and will has chance to sink.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:23,Deployability,update,updated,23,// Verify BFI has been updated correctly by recomputing BFI and comparing them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:100,Safety,avoid,avoid,100,"// Scan all of the blocks in the function, except for the entry block.; // Use a temporary array to avoid iterator being invalidated when; // deleting blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Deployability,Update,Update,3,// Update FreshBBs to optimize the merged BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:22,Performance,optimiz,optimize,22,// Update FreshBBs to optimize the merged BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:66,Availability,redundant,redundant,66,// (Repeatedly) merging blocks into their predecessors can create redundant; // debug intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:66,Safety,redund,redundant,66,// (Repeatedly) merging blocks into their predecessors can create redundant; // debug intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:41,Safety,avoid,avoid,41,// Copy blocks into a temporary array to avoid iterator invalidation issues; // as we remove them.; // Note that this intentionally skips the entry block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:12,Usability,simpl,simple,12,"// We use a simple cost heuristic which determine skipping merging is; // profitable if the cost of skipping merging is less than the cost of; // merging : Cost(skipping merging) < Cost(merging BB), where the; // Cost(skipping merging) is Freq(BB) * (Cost(Copy) + Cost(Branch)), and; // the Cost(merging BB) is Freq(Pred) * Cost(Copy).; // Assuming Cost(Copy) == Cost(Branch), we could simplify it to :; // Freq(Pred) / Freq(BB) > 2.; // Note that if there are multiple empty blocks sharing the same incoming; // value for the PHIs in the DestBB, we consider them together. In such; // case, Cost(merging BB) will be the sum of their frequencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:386,Usability,simpl,simplify,386,"// We use a simple cost heuristic which determine skipping merging is; // profitable if the cost of skipping merging is less than the cost of; // merging : Cost(skipping merging) < Cost(merging BB), where the; // Cost(skipping merging) is Freq(BB) * (Cost(Copy) + Cost(Branch)), and; // the Cost(merging BB) is Freq(Pred) * Cost(Copy).; // Assuming Cost(Copy) == Cost(Branch), we could simplify it to :; // Freq(Pred) / Freq(BB) > 2.; // Note that if there are multiple empty blocks sharing the same incoming; // value for the PHIs in the DestBB, we consider them together. In such; // case, Cost(merging BB) will be the sum of their frequencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:184,Safety,avoid,avoid,184,// If User is inside DestBB block and it is a PHINode then check; // incoming value. If incoming value is not from BB then this is; // a complex condition (e.g. preheaders) we want to avoid here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:53,Deployability,update,updated,53,"/// Replace all old uses with new ones, and push the updated BBs into FreshBBs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Deployability,Update,Update,3,// Update FreshBBs to optimize the merged BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:22,Performance,optimiz,optimize,22,// Update FreshBBs to optimize the merged BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:51,Deployability,Update,Update,51,"// Otherwise, we have multiple predecessors of BB. Update the PHIs in DestBB; // to handle the new incoming edges it is about to have.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:20,Deployability,update,updated,20,"// The PHIs are now updated, change everything that refers to BB to use; // DestBB and remove BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:395,Performance,optimiz,optimization,395,// We must ensure the relocation of derived pointer is defined after; // relocation of base pointer. If we find a relocation corresponding to base; // defined earlier than relocation of base then we move relocation of base; // right before found relocation. We consider only relocation in the same; // basic block as relocation of base. Relocations from other basic block will; // be skipped by optimization and we do not care about them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:836,Performance,optimiz,optimized,836,"// If gc_relocate does not match the actual type, cast it to the right type.; // In theory, there must be a bitcast after gc_relocate if the type does not; // match, and we should reuse it to get the derived pointer. But it could be; // cases like this:; // bb1:; // ...; // %g1 = call coldcc i8 addrspace(1)*; // @llvm.experimental.gc.relocate.p1i8(...) br label %merge; //; // bb2:; // ...; // %g2 = call coldcc i8 addrspace(1)*; // @llvm.experimental.gc.relocate.p1i8(...) br label %merge; //; // merge:; // %p1 = phi i8 addrspace(1)* [ %g1, %bb1 ], [ %g2, %bb2 ]; // %cast = bitcast i8 addrspace(1)* %p1 in to i32 addrspace(1)*; //; // In this case, we can not find the bitcast any more. So we insert a new; // bitcast no matter there is already one or not. In this way, we can handle; // all cases, and the extra bitcast should be optimized away in later; // passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:218,Performance,load,load,218,"// Turns this:; //; // %base = ...; // %ptr = gep %base + 15; // %tok = statepoint (%fun, i32 0, i32 0, i32 0, %base, %ptr); // %base' = relocate(%tok, i32 4, i32 4); // %ptr' = relocate(%tok, i32 4, i32 5); // %val = load %ptr'; //; // into this:; //; // %base = ...; // %ptr = gep %base + 15; // %tok = statepoint (%fun, i32 0, i32 0, i32 0, %base, %ptr); // %base' = gc.relocate(%tok, i32 4, i32 4); // %ptr' = gep %base' + 15; // %val = load %ptr'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:441,Performance,load,load,441,"// Turns this:; //; // %base = ...; // %ptr = gep %base + 15; // %tok = statepoint (%fun, i32 0, i32 0, i32 0, %base, %ptr); // %base' = relocate(%tok, i32 4, i32 4); // %ptr' = relocate(%tok, i32 4, i32 5); // %val = load %ptr'; //; // into this:; //; // %base = ...; // %ptr = gep %base + 15; // %tok = statepoint (%fun, i32 0, i32 0, i32 0, %base, %ptr); // %base' = gc.relocate(%tok, i32 4, i32 4); // %ptr' = gep %base' + 15; // %val = load %ptr'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:161,Energy Efficiency,reduce,reduce,161,"/// If the specified cast instruction is a noop copy (e.g. it's casting from; /// one pointer type to another, i32->i8 on PPC), sink it into user blocks to; /// reduce the number of virtual registers that must be created and coalesced.; ///; /// Return true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:11,Usability,simpl,simple,11,"// Match a simple increment by constant operation. Note that if a sub is; // matched, the step is negated (as if the step had been canonicalized to; // an add, even though we leave the instruction alone.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:35,Modifiability,variab,variable,35,"/// If given \p PN is an inductive variable with value IVInc coming from the; /// backedge, and on each iteration it gets increased by Step, return pair; /// <IVInc, Step>. Otherwise, return std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:10,Safety,risk,risk,10,// Do not risk on moving increment into a child loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:61,Performance,optimiz,optimization,61,"// We used to use a dominator tree here to allow multi-block optimization.; // But that was problematic because:; // 1. It could cause a perf regression by hoisting the math op into the; // critical path.; // 2. It could cause a perf regression by creating a value that was live; // across multiple blocks and increasing register pressure.; // 3. Use of a dominator tree could cause large compile-time regression.; // This is because we recompute the DT on every change in the main CGP; // run-loop. The recomputing is probably unnecessary in many cases, so if; // that was fixed, using a DT here would be ok.; //; // There is one important particular case we still want to handle: if BO is; // the IV increment. Important properties that make it profitable:; // - We can speculate IV increment anywhere in the loop (as long as the; // indvar Phi is its only user);; // - Upon computing Cmp, we effectively compute something equivalent to the; // IV increment (despite it loops differently in the IR). So moving it up; // to the cmp point does not really increase register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:26,Modifiability,variab,variable,26,// Check the users of the variable operand of the compare looking for an add; // with the adjusted constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:35,Usability,simpl,simplify,35,// Convert (A u> B) to (A u< B) to simplify pattern matching.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:23,Modifiability,variab,variable,23,"// Walk the users of a variable operand of a compare looking for a subtract or; // add with that same operand. Also match the 2nd operand of the compare to; // the add/sub, but that may be a negated constant operand of an add.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:47,Energy Efficiency,reduce,reduce,47,"/// Sink the given CmpInst into user blocks to reduce the number of virtual; /// registers that must be created and coalesced. This is a clear win except on; /// targets with multiple condition code registers (PowerPC), where it might; /// lose; some adjustment may be wanted there.; ///; /// Return true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:210,Energy Efficiency,Power,PowerPC,210,"/// Sink the given CmpInst into user blocks to reduce the number of virtual; /// registers that must be created and coalesced. This is a clear win except on; /// targets with multiple condition code registers (PowerPC), where it might; /// lose; some adjustment may be wanted there.; ///; /// Return true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:137,Usability,clear,clear,137,"/// Sink the given CmpInst into user blocks to reduce the number of virtual; /// registers that must be created and coalesced. This is a clear win except on; /// targets with multiple condition code registers (PowerPC), where it might; /// lose; some adjustment may be wanted there.; ///; /// Return true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Safety,Avoid,Avoid,3,"// Avoid sinking soft-FP comparisons, since this can move them into a loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:384,Energy Efficiency,Power,PowerPC,384,"/// For pattern like:; ///; /// DomCond = icmp sgt/slt CmpOp0, CmpOp1 (might not be in DomBB); /// ...; /// DomBB:; /// ...; /// br DomCond, TrueBB, CmpBB; /// CmpBB: (with DomBB being the single predecessor); /// ...; /// Cmp = icmp eq CmpOp0, CmpOp1; /// ...; ///; /// It would use two comparison on targets that lowering of icmp sgt/slt is; /// different from lowering of icmp eq (PowerPC). This function try to convert; /// 'Cmp = icmp eq CmpOp0, CmpOp1' to ' Cmp = icmp slt/sgt CmpOp0, CmpOp1'.; /// After that, DomCond and Cmp can use the same comparison so reduce one; /// comparison.; ///; /// Return true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:564,Energy Efficiency,reduce,reduce,564,"/// For pattern like:; ///; /// DomCond = icmp sgt/slt CmpOp0, CmpOp1 (might not be in DomBB); /// ...; /// DomBB:; /// ...; /// br DomCond, TrueBB, CmpBB; /// CmpBB: (with DomBB being the single predecessor); /// ...; /// Cmp = icmp eq CmpOp0, CmpOp1; /// ...; ///; /// It would use two comparison on targets that lowering of icmp sgt/slt is; /// different from lowering of icmp eq (PowerPC). This function try to convert; /// 'Cmp = icmp eq CmpOp0, CmpOp1' to ' Cmp = icmp slt/sgt CmpOp0, CmpOp1'.; /// After that, DomCond and Cmp can use the same comparison so reduce one; /// comparison.; ///; /// Return true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:117,Availability,redundant,redundant,117,"// If icmp eq has users other than BranchInst and SelectInst, converting it to; // icmp slt/sgt would introduce more redundant LLVM IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:117,Safety,redund,redundant,117,"// If icmp eq has users other than BranchInst and SelectInst, converting it to; // icmp slt/sgt would introduce more redundant LLVM IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Safety,Avoid,Avoid,3,// Avoid walking many users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:41,Performance,optimiz,optimize,41,// Double-check that we're not trying to optimize an instruction that was; // already optimized by some other part of this pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:86,Performance,optimiz,optimized,86,// Double-check that we're not trying to optimize an instruction that was; // already optimized by some other part of this pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:10,Safety,avoid,avoid,10,// Try to avoid cases where sinking/duplicating is likely to increase register; // pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:163,Availability,mask,mask,163,"/// Check if the candidates could be combined with a shift instruction, which; /// includes:; /// 1. Truncate instruction; /// 2. And instruction and the imm is a mask of the low bits:; /// imm & (imm+1) == 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:544,Performance,perform,performed,544,"/// If counting leading or trailing zeros is an expensive operation and a zero; /// input is defined, add a check for zero to avoid calling the intrinsic.; ///; /// We want to transform:; /// %z = call i64 @llvm.cttz.i64(i64 %A, i1 false); ///; /// into:; /// entry:; /// %cmpz = icmp eq i64 %A, 0; /// br i1 %cmpz, label %cond.end, label %cond.false; /// cond.false:; /// %z = call i64 @llvm.cttz.i64(i64 %A, i1 true); /// br label %cond.end; /// cond.end:; /// %ctz = phi i64 [ 64, %entry ], [ %z, %cond.false ]; ///; /// If the transform is performed, return true and set ModifiedDT to true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:126,Safety,avoid,avoid,126,"/// If counting leading or trailing zeros is an expensive operation and a zero; /// input is defined, add a check for zero to avoid calling the intrinsic.; ///; /// We want to transform:; /// %z = call i64 @llvm.cttz.i64(i64 %A, i1 false); ///; /// into:; /// entry:; /// %cmpz = icmp eq i64 %A, 0; /// br i1 %cmpz, label %cond.end, label %cond.false; /// cond.false:; /// %z = call i64 @llvm.cttz.i64(i64 %A, i1 true); /// br label %cond.end; /// cond.end:; /// %ctz = phi i64 [ 64, %entry ], [ %z, %cond.false ]; ///; /// If the transform is performed, return true and set ModifiedDT to true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Deployability,Update,Update,3,// Update the LoopInfo. The new blocks are in the same loop as the start; // block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Safety,Avoid,Avoid,3,// Avoid introducing branch on poison. This also replaces the ctz operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Safety,Avoid,Avoid,3,// Avoid invalidating the iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Safety,Avoid,Avoid,3,"// Avoid processing instructions out of order, which could cause; // reuse before a value is defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:10,Modifiability,variab,variables,10,"// Global variables can only be aligned if they are defined in this; // object (i.e. they are uniquely initialized in this object), and; // over-aligning global variables that have an explicit section is; // forbidden.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:161,Modifiability,variab,variables,161,"// Global variables can only be aligned if they are defined in this; // object (i.e. they are uniquely initialized in this object), and; // over-aligning global variables that have an explicit section is; // forbidden.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:129,Performance,load,loads,129,"// If we have a cold call site, try to sink addressing computation into the; // cold block. This interacts with our handling for loads and stores to; // ensure that we can fold all uses of a potential addressing computation; // into their uses. TODO: generalize this to work over profiling data",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:65,Performance,optimiz,optimizations,65,"// Mark this instruction as ""inserted by CGP"", so that other; // optimizations don't touch it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:42,Safety,avoid,avoid,42,"// If counting zeros is expensive, try to avoid it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:104,Performance,optimiz,optimizations,104,"/// Look for opportunities to duplicate return instructions to the predecessor; /// to enable tail call optimizations. The case it is currently looking for is:; /// @code; /// bb0:; /// %tmp0 = tail call i32 @f0(); /// br label %return; /// bb1:; /// %tmp1 = tail call i32 @f1(); /// br label %return; /// bb2:; /// %tmp2 = tail call i32 @f2(); /// br label %return; /// return:; /// %retval = phi i32 [ %tmp0, %bb0 ], [ %tmp1, %bb1 ], [ %tmp2, %bb2 ]; /// ret i32 %retval; /// @endcode; ///; /// =>; ///; /// @code; /// bb0:; /// %tmp0 = tail call i32 @f0(); /// ret i32 %tmp0; /// bb1:; /// %tmp1 = tail call i32 @f1(); /// ret i32 %tmp1; /// bb2:; /// %tmp2 = tail call i32 @f2(); /// ret i32 %tmp2; /// @endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:92,Performance,Optimiz,Optimization,92,//===----------------------------------------------------------------------===//; // Memory Optimization; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:15,Modifiability,extend,extended,15,/// This is an extended version of TargetLowering::AddrMode; /// which holds actual Value*'s for register values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:163,Availability,rollback,rollback,163,"/// This class provides transaction based operation on the IR.; /// Every change made through this class is recorded in the internal state and; /// can be undone (rollback) until commit is called.; /// CGP does not check if instructions could be speculatively executed when; /// moved. Preserving the original location would pessimize the debugging; /// experience, as well as negatively impact the quality of sample PGO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:163,Deployability,rollback,rollback,163,"/// This class provides transaction based operation on the IR.; /// Every change made through this class is recorded in the internal state and; /// can be undone (rollback) until commit is called.; /// CGP does not check if instructions could be speculatively executed when; /// moved. Preserving the original location would pessimize the debugging; /// experience, as well as negatively impact the quality of sample PGO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:155,Usability,undo,undone,155,"/// This class provides transaction based operation on the IR.; /// Every change made through this class is recorded in the internal state and; /// can be undone (rollback) until commit is called.; /// CGP does not check if instructions could be speculatively executed when; /// moved. Preserving the original location would pessimize the debugging; /// experience, as well as negatively impact the quality of sample PGO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:31,Integrability,interface,interface,31,/// This represents the common interface of the individual transaction.; /// Each class implements the logic for doing one specific modification on; /// the IR via the TypePromotionTransaction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:103,Testability,log,logic,103,/// This represents the common interface of the individual transaction.; /// Each class implements the logic for doing one specific modification on; /// the IR via the TypePromotionTransaction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:52,Performance,perform,performs,52,/// Constructor of the action.; /// The constructor performs the related action on the IR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:4,Usability,Undo,Undo,4,"/// Undo the modification done by this action.; /// When this method is called, the IR must be in the same state as it was; /// before this action was applied.; /// \pre Undoing the action works if and only if the IR is in the exact same; /// state as it was directly after this action was applied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:170,Usability,Undo,Undoing,170,"/// Undo the modification done by this action.; /// When this method is called, the IR must be in the same state as it was; /// before this action was applied.; /// \pre Undoing the action works if and only if the IR is in the exact same; /// state as it was directly after this action was applied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:47,Usability,undo,undo,47,/// Keep track of the new value so that we can undo it by replacing; /// instances of the new value with the original value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:116,Usability,undo,undoing,116,"// RAUW has replaced all original uses with references to the new value,; // including the debug uses. Since we are undoing the replacements,; // the original debug uses must also be reinstated to maintain the; // correctness and utility of debug value instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Testability,test,tested,3,// tested by transaction-test I'm adding,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:25,Testability,test,test,25,// tested by transaction-test I'm adding,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:70,Performance,optimiz,optimizeBlock,70,/// The instructions removed here will be freed after completing; /// optimizeBlock() for all blocks as we need to keep track of the; /// removed instructions during promotion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:4,Usability,Undo,Undo,4,/// Undo all the changes made after the given point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:64,Availability,rollback,rollback,64,/// \name API for IR modification with state keeping to support rollback.; /// @{; /// Same as Instruction::setOperand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:64,Deployability,rollback,rollback,64,/// \name API for IR modification with state keeping to support rollback.; /// @{; /// Same as Instruction::setOperand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:82,Testability,log,logic,82,/// A helper class for matching addressing modes.; ///; /// This encapsulates the logic for matching the target-legal addressing modes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:4,Security,Access,AccessTy,4,/// AccessTy/MemoryInst - This is the type for the access (e.g. double) and; /// the memory instruction that we're computing this address for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:51,Security,access,access,51,/// AccessTy/MemoryInst - This is the type for the access (e.g. double) and; /// the memory instruction that we're computing this address for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:54,Performance,optimiz,optimizations,54,/// The instructions inserted by other CodeGenPrepare optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:19,Performance,optimiz,optimizing,19,/// True if we are optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:44,Performance,load,load,44,"/// Find the maximal addressing mode that a load/store of V can fold,; /// give an access type of AccessTy. This returns a list of involved; /// instructions in AddrModeInsts.; /// \p InsertedInsts The instructions inserted by other CodeGenPrepare; /// optimizations.; /// \p PromotedInsts maps the instructions to their type before promotion.; /// \p The ongoing transaction where every action should be registered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:253,Performance,optimiz,optimizations,253,"/// Find the maximal addressing mode that a load/store of V can fold,; /// give an access type of AccessTy. This returns a list of involved; /// instructions in AddrModeInsts.; /// \p InsertedInsts The instructions inserted by other CodeGenPrepare; /// optimizations.; /// \p PromotedInsts maps the instructions to their type before promotion.; /// \p The ongoing transaction where every action should be registered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:83,Security,access,access,83,"/// Find the maximal addressing mode that a load/store of V can fold,; /// give an access type of AccessTy. This returns a list of involved; /// instructions in AddrModeInsts.; /// \p InsertedInsts The instructions inserted by other CodeGenPrepare; /// optimizations.; /// \p PromotedInsts maps the instructions to their type before promotion.; /// \p The ongoing transaction where every action should be registered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:98,Security,Access,AccessTy,98,"/// Find the maximal addressing mode that a load/store of V can fold,; /// give an access type of AccessTy. This returns a list of involved; /// instructions in AddrModeInsts.; /// \p InsertedInsts The instructions inserted by other CodeGenPrepare; /// optimizations.; /// \p PromotedInsts maps the instructions to their type before promotion.; /// \p The ongoing transaction where every action should be registered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:184,Performance,perform,performance,184,"/// Keeps a set of PHINodes.; ///; /// This is a minimal set implementation for a specific use case:; /// It is very fast when there are very few elements, but also provides good; /// performance when there are many. It is similar to SmallPtrSet, but also; /// provides iteration by insertion order, which is deterministic and stable; /// across runs. It is also similar to SmallSetVector, but provides removing; /// elements in O(1) time. This is achieved by not actually removing the element; /// from the underlying vector, so comes at the cost of using more memory, but; /// that is fine, since PhiNodeSets are used as short lived objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:29,Usability,clear,clears,29,/// Removes all elements and clears the collection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:4,Deployability,Update,Updates,4,"/// Updates the CurrentIndex so that it will point to a valid element.; ///; /// If the element of NodeList at CurrentIndex is valid, it does not; /// change it. If there are no more valid elements, it updates CurrentIndex; /// to point to the end of the NodeList.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:202,Deployability,update,updates,202,"/// Updates the CurrentIndex so that it will point to a valid element.; ///; /// If the element of NodeList at CurrentIndex is valid, it does not; /// change it. If there are no more valid elements, it updates CurrentIndex; /// to point to the end of the NodeList.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:18,Usability,simpl,simplification,18,/// Keep track of simplification of Phi nodes.; /// Accept the set of all phi nodes and erase phi node from this set; /// if it is simplified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:131,Usability,simpl,simplified,131,/// Keep track of simplification of Phi nodes.; /// Accept the set of all phi nodes and erase phi node from this set; /// if it is simplified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:7,Safety,safe,safe,7,"// For safe erasing, replace the uses with dummy value first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:4,Usability,Simpl,SimplifyQuery,4,/// SimplifyQuery for simplifyInstruction utility.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:22,Usability,simpl,simplifyInstruction,22,/// SimplifyQuery for simplifyInstruction utility.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:68,Safety,detect,detect,68,"// Take note of if we have any non-trivial AddrModes, as we need to detect; // when all AddrModes are trivial as then we would introduce a phi or select; // which just duplicates what's already there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:65,Deployability,install,installed,65,// We also must reject the case when GV is different and BaseReg installed; // due to we want to use base reg as a merge of GV values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:693,Performance,load,load,693,"/// We have mapping between value A and other value B where B was a field in; /// addressing mode represented by A. Also we have an original value C; /// representing an address we start with. Traversing from C through phi and; /// selects we ended up with A's in a map. This utility function tries to find; /// a value V which is a field in addressing mode C and traversing through phi; /// nodes and selects we will end up in corresponded values B in a map.; /// The utility will create a new Phi/Selects if needed.; // The simple example looks as follows:; // BB1:; // p1 = b1 + 40; // br cond BB2, BB3; // BB2:; // p2 = b2 + 40; // br BB3; // BB3:; // p = phi [p1, BB1], [p2, BB2]; // v = load p; // Map is; // p1 -> b1; // p2 -> b2; // Request is; // p -> ?; // The function tries to find or build phi [b1, BB1], [b2, BB2] in BB3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:526,Usability,simpl,simple,526,"/// We have mapping between value A and other value B where B was a field in; /// addressing mode represented by A. Also we have an original value C; /// representing an address we start with. Traversing from C through phi and; /// selects we ended up with A's in a map. This utility function tries to find; /// a value V which is a field in addressing mode C and traversing through phi; /// nodes and selects we will end up in corresponded values B in a map.; /// The utility will create a new Phi/Selects if needed.; // The simple example looks as follows:; // BB1:; // p1 = b1 + 40; // br cond BB2, BB3; // BB2:; // p2 = b2 + 40; // br BB3; // BB3:; // p = phi [p1, BB1], [p2, BB2]; // v = load p; // Map is; // p1 -> b1; // p2 -> b2; // Request is; // p -> ?; // The function tries to find or build phi [b1, BB1], [b2, BB2] in BB3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:14,Usability,simpl,simplification,14,"// Tracks the simplification of newly created phi nodes. The reason we use; // this mapping is because we will add new created Phi nodes in AddrToBase.; // Simplification of Phi nodes is recursive, so some Phi node may; // be simplified after we added it to AddrToBase. In reality this; // simplification is possible only if original phi/selects were not; // simplified yet.; // Using this mapping we can find the current value in AddrToBase.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:156,Usability,Simpl,Simplification,156,"// Tracks the simplification of newly created phi nodes. The reason we use; // this mapping is because we will add new created Phi nodes in AddrToBase.; // Simplification of Phi nodes is recursive, so some Phi node may; // be simplified after we added it to AddrToBase. In reality this; // simplification is possible only if original phi/selects were not; // simplified yet.; // Using this mapping we can find the current value in AddrToBase.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:226,Usability,simpl,simplified,226,"// Tracks the simplification of newly created phi nodes. The reason we use; // this mapping is because we will add new created Phi nodes in AddrToBase.; // Simplification of Phi nodes is recursive, so some Phi node may; // be simplified after we added it to AddrToBase. In reality this; // simplification is possible only if original phi/selects were not; // simplified yet.; // Using this mapping we can find the current value in AddrToBase.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:290,Usability,simpl,simplification,290,"// Tracks the simplification of newly created phi nodes. The reason we use; // this mapping is because we will add new created Phi nodes in AddrToBase.; // Simplification of Phi nodes is recursive, so some Phi node may; // be simplified after we added it to AddrToBase. In reality this; // simplification is possible only if original phi/selects were not; // simplified yet.; // Using this mapping we can find the current value in AddrToBase.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:359,Usability,simpl,simplified,359,"// Tracks the simplification of newly created phi nodes. The reason we use; // this mapping is because we will add new created Phi nodes in AddrToBase.; // Simplification of Phi nodes is recursive, so some Phi node may; // be simplified after we added it to AddrToBase. In reality this; // simplification is possible only if original phi/selects were not; // simplified yet.; // Using this mapping we can find the current value in AddrToBase.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:52,Usability,simpl,simplify,52,"// Second Step, fill new nodes by merged values and simplify if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:43,Usability,Simpl,SimplificationTracker,43,/// For the given set of PHI nodes (in the SimplificationTracker) try; /// to find their equivalents.; /// Returns false if this matching fails and creation of new Phi is disabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:60,Usability,simpl,simplify,60,/// Fill the placeholders with values from predecessors and simplify them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:111,Deployability,update,update,111,"// end anonymous namespace; /// Try adding ScaleReg*Scale to the current addressing mode.; /// Return true and update AddrMode if this addr mode is legal for the target,; /// false if not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:89,Availability,avail,available,89,"// If we already have a scale of this value, we can add to it, otherwise, we; // need an available scale field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:198,Availability,avail,available,198,"// Okay, we decided that we can add ScaleReg+Scale to AddrMode. Check now; // to see if ScaleReg is actually X+C. If so, we can turn this into adding; // X*Scale + C*Scale to addr mode. If we found available IV increment, do not; // go any further: we can reuse it and cannot eliminate it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:377,Safety,avoid,avoid,377,"// TODO: The result of the intrinsics above is two-complement. However when; // IV inc is expressed as add or sub, iv.next is potentially a poison value.; // If it has nuw or nsw flags, we need to make sure that these flags are; // inferrable at the point of memory instruction. Otherwise we are replacing; // well-defined two-complement computation with poison. Currently, to avoid; // potentially complex analysis needed to prove this, we reject such cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:156,Availability,avail,available,156,"// Try to account for the following special case:; // 1. ScaleReg is an inductive variable;; // 2. We use it with non-zero offset;; // 3. IV's increment is available at the point of memory instruction.; //; // In this case, we may reuse the IV increment instead of the IV Phi to; // achieve the following advantages:; // 1. If IV step matches the offset, we will have no need in the offset;; // 2. Even if they don't match, we will reduce the overlap of living IV; // and IV increment, that will potentially lead to better register; // assignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:432,Energy Efficiency,reduce,reduce,432,"// Try to account for the following special case:; // 1. ScaleReg is an inductive variable;; // 2. We use it with non-zero offset;; // 3. IV's increment is available at the point of memory instruction.; //; // In this case, we may reuse the IV increment instead of the IV Phi to; // achieve the following advantages:; // 1. If IV step matches the offset, we will have no need in the offset;; // 2. Even if they don't match, we will reduce the overlap of living IV; // and IV increment, that will potentially lead to better register; // assignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:82,Modifiability,variab,variable,82,"// Try to account for the following special case:; // 1. ScaleReg is an inductive variable;; // 2. We use it with non-zero offset;; // 3. IV's increment is available at the point of memory instruction.; //; // In this case, we may reuse the IV increment instead of the IV Phi to; // achieve the following advantages:; // 1. If IV step matches the offset, we will have no need in the offset;; // 2. Even if they don't match, we will reduce the overlap of living IV; // and IV increment, that will potentially lead to better register; // assignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:17,Testability,assert,assert,17,"// The following assert is important to ensure a lack of infinite loops.; // This transforms is (intentionally) the inverse of the one just above.; // If they don't agree on the definition of an increment, we'd alternate; // back and forth indefinitely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:117,Performance,load,load,117,"/// This is a little filter, which returns true if an addressing computation; /// involving I might be folded into a load/store accessing it.; /// This doesn't need to be perfect, but needs to accept at least; /// the set of instructions that MatchOperationAddr can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:128,Security,access,accessing,128,"/// This is a little filter, which returns true if an addressing computation; /// involving I might be folded into a load/store accessing it.; /// This doesn't need to be perfect, but needs to accept at least; /// the set of instructions that MatchOperationAddr can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:20,Performance,perform,perform,20,/// Hepler class to perform type promotion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:22,Modifiability,extend,extend,22,"/// Given a sign/zero extend instruction \p Ext, return the appropriate; /// action to promote the operand of \p Ext instead of using Ext.; /// \return NULL if no promotable action is possible with the current; /// sign extension.; /// \p InsertedInsts keeps track of all the instructions inserted by the; /// other CodeGenPrepare optimizations. This information is important; /// because we do not want to promote these instructions as CodeGenPrepare; /// will reinsert them later. Thus creating an infinite loop: create/remove.; /// \p PromotedInsts maps the instructions to their type before promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:331,Performance,optimiz,optimizations,331,"/// Given a sign/zero extend instruction \p Ext, return the appropriate; /// action to promote the operand of \p Ext instead of using Ext.; /// \return NULL if no promotable action is possible with the current; /// sign extension.; /// \p InsertedInsts keeps track of all the instructions inserted by the; /// other CodeGenPrepare optimizations. This information is important; /// because we do not want to promote these instructions as CodeGenPrepare; /// will reinsert them later. Thus creating an infinite loop: create/remove.; /// \p PromotedInsts maps the instructions to their type before promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:157,Modifiability,extend,extend,157,"// The promotion helper does not know how to deal with vector types yet.; // To be able to fix that, we would need to fix the places where we; // statically extend, e.g., constants and such.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:36,Usability,simpl,simplification,36,// Check if we can do the following simplification.; // ext(trunc(opnd)) --> ext(opnd),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:181,Testability,log,logic,181,"// If the operand of the truncate is not an instruction, we will not have; // any information on the dropped bits.; // (Actually we could for constant but it is not worth the extra logic).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:91,Modifiability,extend,extended,91,"// Check if the source of the type is narrow enough.; // I.e., check that trunc just drops extended bits of the same kind of; // the extension.; // #1 get the type of the operand and check the kind of the extended bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:205,Modifiability,extend,extended,205,"// Check if the source of the type is narrow enough.; // I.e., check that trunc just drops extended bits of the same kind of; // the extension.; // #1 get the type of the operand and check the kind of the extended bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:41,Modifiability,extend,extended,41,// #2 check that the truncate just drops extended bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:109,Performance,optimiz,optimization,109,"// Do not promote if the operand has been added by codegenprepare.; // Otherwise, it means we are undoing an optimization that is likely to be; // redone, thus causing potential infinite loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:98,Usability,undo,undoing,98,"// Do not promote if the operand has been added by codegenprepare.; // Otherwise, it means we are undoing an optimization that is likely to be; // redone, thus causing potential infinite loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:28,Safety,Abort,Abort,28,// Regular instruction.; // Abort early if we will have to insert non-free instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:106,Safety,avoid,avoid,106,// Restore the operand of Ext (which has been replaced by the previous call; // to replaceAllUsesWith) to avoid creating a cycle trunc <-> sext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:39,Deployability,Update,Update,39,// Get through the Instruction:; // 1. Update its type.; // 2. Replace the uses of Ext by Inst.; // 3. Extend each operand that needs to be extended.; // Remember the original type of the instruction before promotion.; // This is useful to know that the high bits are sign extended bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:103,Modifiability,Extend,Extend,103,// Get through the Instruction:; // 1. Update its type.; // 2. Replace the uses of Ext by Inst.; // 3. Extend each operand that needs to be extended.; // Remember the original type of the instruction before promotion.; // This is useful to know that the high bits are sign extended bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:140,Modifiability,extend,extended,140,// Get through the Instruction:; // 1. Update its type.; // 2. Replace the uses of Ext by Inst.; // 3. Extend each operand that needs to be extended.; // Remember the original type of the instruction before promotion.; // This is useful to know that the high bits are sign extended bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:273,Modifiability,extend,extended,273,// Get through the Instruction:; // 1. Update its type.; // 2. Replace the uses of Ext by Inst.; // 3. Extend each operand that needs to be extended.; // Remember the original type of the instruction before promotion.; // This is useful to know that the high bits are sign extended bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:30,Modifiability,extend,extend,30,// Check if we can statically extend the operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:55,Modifiability,extend,extend,55,"// UndefValue are typed, so we have to statically sign extend them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:40,Modifiability,extend,extend,40,// Otherwise we have to explicitly sign extend the operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:78,Performance,load,loads,78,// The promotion is neutral but it may help folding the sign extension in; // loads for instance.; // Check that we did not create an illegal instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:114,Deployability,update,update,114,"/// Given an instruction or constant expr, see if we can fold the operation; /// into the addressing mode. If so, update the addressing mode and return; /// true, otherwise return false without modifying AddrMode.; /// If \p MovedAway is not NULL, it contains the information of whether or; /// not AddrInst has to be folded into the addressing mode on success.; /// If \p MovedAway == true, \p AddrInst will not be part of the addressing; /// because it has been moved away.; /// Thus AddrInst must not be added in the matched instructions.; /// This state can happen when AddrInst is a sext, since it may be moved away.; /// Therefore, AddrInst may not be valid when MovedAway is true and it must; /// not be referenced anymore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Safety,Avoid,Avoid,3,// Avoid exponential behavior on extremely deep expression trees.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:136,Usability,undo,undo,136,"// Start a transaction at this point.; // The LHS may match but not the RHS.; // Therefore, we need a higher level restoration point to undo partially; // matched operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:81,Modifiability,variab,variable,81,// Scan the GEP. We check it if it contains constant offsets and at most; // one variable offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:21,Modifiability,variab,variable,21,// We only allow one variable index at the moment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:16,Modifiability,variab,variable,16,// Remember the variable index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:238,Security,access,access,238,// Record GEPs with non-zero offsets as candidates for splitting in; // the event that the offset cannot fit into the r+i addressing mode.; // Simple and common case that only one GEP is used in calculating the; // address for the memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:143,Usability,Simpl,Simple,143,// Record GEPs with non-zero offsets as candidates for splitting in; // the event that the offset cannot fit into the r+i addressing mode.; // Simple and common case that only one GEP is used in calculating the; // address for the memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:23,Modifiability,variab,variable,23,// Match the remaining variable portion of the GEP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:50,Availability,rollback,rollback,50,// Start a transaction at this point that we will rollback if the matching; // fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:50,Deployability,rollback,rollback,50,// Start a transaction at this point that we will rollback if the matching; // fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:23,Modifiability,variab,variable,23,"// If this is a global variable, try to fold it into the addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:125,Safety,avoid,avoid,125,"// Okay, it's possible to fold this. Check to see if it is actually; // *profitable* to do so. We use a simple cost model to avoid increasing; // register pressure too much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:104,Usability,simpl,simple,104,"// Okay, it's possible to fold this. Check to see if it is actually; // *profitable* to do so. We use a simple cost model to avoid increasing; // register pressure too much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:144,Security,access,accessed,144,"/// Recursively walk all the uses of I until we find a memory use.; /// If we find an obviously non-foldable instruction, return true.; /// Add accessed addresses and types to MemoryUses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:96,Safety,avoid,avoids,96,// Conservatively return true if we're seeing a large number or a deep chain; // of users. This avoids excessive compilation times in pathological cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:94,Performance,optimiz,optimizeCallInst,94,"// If this is a cold call, we can sink the addressing calculation into; // the cold path. See optimizeCallInst",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:104,Performance,load,load,104,"/// It is possible for the addressing mode of the machine to fold the specified; /// instruction into a load or store that ultimately uses it.; /// However, the specified instruction has multiple uses.; /// Given this, it may actually increase register pressure to fold it; /// into the load. For example, consider this code:; ///; /// X = ...; /// Y = X+1; /// use(Y) -> nonload/store; /// Z = Y+1; /// load Z; ///; /// In this case, Y has multiple uses, and can be folded into the load of Z; /// (yielding load [X+2]). However, doing this will cause both ""X"" and ""X+1"" to; /// be live at the use(Y) line. If we don't fold Y into load Z, we use one; /// fewer register. Since Y can't be folded into ""use(Y)"" we don't increase the; /// number of computations either.; ///; /// Note that this (like most of CodeGenPrepare) is just a rough heuristic. If; /// X was live across 'load Z' for other reasons, we actually *would* want to; /// fold the addressing mode in the Z case. This would make Y die earlier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:287,Performance,load,load,287,"/// It is possible for the addressing mode of the machine to fold the specified; /// instruction into a load or store that ultimately uses it.; /// However, the specified instruction has multiple uses.; /// Given this, it may actually increase register pressure to fold it; /// into the load. For example, consider this code:; ///; /// X = ...; /// Y = X+1; /// use(Y) -> nonload/store; /// Z = Y+1; /// load Z; ///; /// In this case, Y has multiple uses, and can be folded into the load of Z; /// (yielding load [X+2]). However, doing this will cause both ""X"" and ""X+1"" to; /// be live at the use(Y) line. If we don't fold Y into load Z, we use one; /// fewer register. Since Y can't be folded into ""use(Y)"" we don't increase the; /// number of computations either.; ///; /// Note that this (like most of CodeGenPrepare) is just a rough heuristic. If; /// X was live across 'load Z' for other reasons, we actually *would* want to; /// fold the addressing mode in the Z case. This would make Y die earlier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:404,Performance,load,load,404,"/// It is possible for the addressing mode of the machine to fold the specified; /// instruction into a load or store that ultimately uses it.; /// However, the specified instruction has multiple uses.; /// Given this, it may actually increase register pressure to fold it; /// into the load. For example, consider this code:; ///; /// X = ...; /// Y = X+1; /// use(Y) -> nonload/store; /// Z = Y+1; /// load Z; ///; /// In this case, Y has multiple uses, and can be folded into the load of Z; /// (yielding load [X+2]). However, doing this will cause both ""X"" and ""X+1"" to; /// be live at the use(Y) line. If we don't fold Y into load Z, we use one; /// fewer register. Since Y can't be folded into ""use(Y)"" we don't increase the; /// number of computations either.; ///; /// Note that this (like most of CodeGenPrepare) is just a rough heuristic. If; /// X was live across 'load Z' for other reasons, we actually *would* want to; /// fold the addressing mode in the Z case. This would make Y die earlier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:483,Performance,load,load,483,"/// It is possible for the addressing mode of the machine to fold the specified; /// instruction into a load or store that ultimately uses it.; /// However, the specified instruction has multiple uses.; /// Given this, it may actually increase register pressure to fold it; /// into the load. For example, consider this code:; ///; /// X = ...; /// Y = X+1; /// use(Y) -> nonload/store; /// Z = Y+1; /// load Z; ///; /// In this case, Y has multiple uses, and can be folded into the load of Z; /// (yielding load [X+2]). However, doing this will cause both ""X"" and ""X+1"" to; /// be live at the use(Y) line. If we don't fold Y into load Z, we use one; /// fewer register. Since Y can't be folded into ""use(Y)"" we don't increase the; /// number of computations either.; ///; /// Note that this (like most of CodeGenPrepare) is just a rough heuristic. If; /// X was live across 'load Z' for other reasons, we actually *would* want to; /// fold the addressing mode in the Z case. This would make Y die earlier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:508,Performance,load,load,508,"/// It is possible for the addressing mode of the machine to fold the specified; /// instruction into a load or store that ultimately uses it.; /// However, the specified instruction has multiple uses.; /// Given this, it may actually increase register pressure to fold it; /// into the load. For example, consider this code:; ///; /// X = ...; /// Y = X+1; /// use(Y) -> nonload/store; /// Z = Y+1; /// load Z; ///; /// In this case, Y has multiple uses, and can be folded into the load of Z; /// (yielding load [X+2]). However, doing this will cause both ""X"" and ""X+1"" to; /// be live at the use(Y) line. If we don't fold Y into load Z, we use one; /// fewer register. Since Y can't be folded into ""use(Y)"" we don't increase the; /// number of computations either.; ///; /// Note that this (like most of CodeGenPrepare) is just a rough heuristic. If; /// X was live across 'load Z' for other reasons, we actually *would* want to; /// fold the addressing mode in the Z case. This would make Y die earlier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:631,Performance,load,load,631,"/// It is possible for the addressing mode of the machine to fold the specified; /// instruction into a load or store that ultimately uses it.; /// However, the specified instruction has multiple uses.; /// Given this, it may actually increase register pressure to fold it; /// into the load. For example, consider this code:; ///; /// X = ...; /// Y = X+1; /// use(Y) -> nonload/store; /// Z = Y+1; /// load Z; ///; /// In this case, Y has multiple uses, and can be folded into the load of Z; /// (yielding load [X+2]). However, doing this will cause both ""X"" and ""X+1"" to; /// be live at the use(Y) line. If we don't fold Y into load Z, we use one; /// fewer register. Since Y can't be folded into ""use(Y)"" we don't increase the; /// number of computations either.; ///; /// Note that this (like most of CodeGenPrepare) is just a rough heuristic. If; /// X was live across 'load Z' for other reasons, we actually *would* want to; /// fold the addressing mode in the Z case. This would make Y die earlier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:876,Performance,load,load,876,"/// It is possible for the addressing mode of the machine to fold the specified; /// instruction into a load or store that ultimately uses it.; /// However, the specified instruction has multiple uses.; /// Given this, it may actually increase register pressure to fold it; /// into the load. For example, consider this code:; ///; /// X = ...; /// Y = X+1; /// use(Y) -> nonload/store; /// Z = Y+1; /// load Z; ///; /// In this case, Y has multiple uses, and can be folded into the load of Z; /// (yielding load [X+2]). However, doing this will cause both ""X"" and ""X+1"" to; /// be live at the use(Y) line. If we don't fold Y into load Z, we use one; /// fewer register. Since Y can't be folded into ""use(Y)"" we don't increase the; /// number of computations either.; ///; /// Note that this (like most of CodeGenPrepare) is just a rough heuristic. If; /// X was live across 'load Z' for other reasons, we actually *would* want to; /// fold the addressing mode in the Z case. This would make Y die earlier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:470,Availability,avail,available,470,"// AMBefore is the addressing mode before this instruction was folded into it,; // and AMAfter is the addressing mode after the instruction was folded. Get; // the set of registers referenced by AMAfter and subtract out those; // referenced by AMBefore: this is the set of values which folding in this; // address extends the lifetime of.; //; // Note that there are only two potential values being referenced here,; // BaseReg and ScaleReg (global addresses are always available, as are any; // folded immediates).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:314,Modifiability,extend,extends,314,"// AMBefore is the addressing mode before this instruction was folded into it,; // and AMAfter is the addressing mode after the instruction was folded. Get; // the set of registers referenced by AMAfter and subtract out those; // referenced by AMBefore: this is the set of values which folding in this; // address extends the lifetime of.; //; // Note that there are only two potential values being referenced here,; // BaseReg and ScaleReg (global addresses are always available, as are any; // folded immediates).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:98,Modifiability,extend,extended,98,"// If the BaseReg or ScaledReg was referenced by the previous addrmode, their; // lifetime wasn't extended by adding this instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:58,Modifiability,extend,extend,58,"// If folding this instruction (and it's subexprs) didn't extend any live; // ranges, we're ok with it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:1093,Energy Efficiency,reduce,reduce,1093,"/// Sink addressing mode computation immediate before MemoryInst if doing so; /// can be done without increasing register pressure. The need for the; /// register pressure constraint means this can end up being an all or nothing; /// decision for all uses of the same addressing computation.; ///; /// Load and Store Instructions often have addressing modes that can do; /// significant amounts of computation. As such, instruction selection will try; /// to get the load or store to do as much computation as possible for the; /// program. The problem is that isel can only see within a single block. As; /// such, we sink as much legal addressing mode work into the block as possible.; ///; /// This method is used to optimize both load/store and inline asms with memory; /// operands. It's also used to sink addressing computations feeding into cold; /// call sites into their (cold) basic block.; ///; /// The motivation for handling sinking into cold blocks is that doing so can; /// both enable other address mode sinking (by satisfying the register pressure; /// constraint above), and reduce register pressure globally (by removing the; /// addressing mode computation from the fast path entirely.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:302,Performance,Load,Load,302,"/// Sink addressing mode computation immediate before MemoryInst if doing so; /// can be done without increasing register pressure. The need for the; /// register pressure constraint means this can end up being an all or nothing; /// decision for all uses of the same addressing computation.; ///; /// Load and Store Instructions often have addressing modes that can do; /// significant amounts of computation. As such, instruction selection will try; /// to get the load or store to do as much computation as possible for the; /// program. The problem is that isel can only see within a single block. As; /// such, we sink as much legal addressing mode work into the block as possible.; ///; /// This method is used to optimize both load/store and inline asms with memory; /// operands. It's also used to sink addressing computations feeding into cold; /// call sites into their (cold) basic block.; ///; /// The motivation for handling sinking into cold blocks is that doing so can; /// both enable other address mode sinking (by satisfying the register pressure; /// constraint above), and reduce register pressure globally (by removing the; /// addressing mode computation from the fast path entirely.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:467,Performance,load,load,467,"/// Sink addressing mode computation immediate before MemoryInst if doing so; /// can be done without increasing register pressure. The need for the; /// register pressure constraint means this can end up being an all or nothing; /// decision for all uses of the same addressing computation.; ///; /// Load and Store Instructions often have addressing modes that can do; /// significant amounts of computation. As such, instruction selection will try; /// to get the load or store to do as much computation as possible for the; /// program. The problem is that isel can only see within a single block. As; /// such, we sink as much legal addressing mode work into the block as possible.; ///; /// This method is used to optimize both load/store and inline asms with memory; /// operands. It's also used to sink addressing computations feeding into cold; /// call sites into their (cold) basic block.; ///; /// The motivation for handling sinking into cold blocks is that doing so can; /// both enable other address mode sinking (by satisfying the register pressure; /// constraint above), and reduce register pressure globally (by removing the; /// addressing mode computation from the fast path entirely.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:720,Performance,optimiz,optimize,720,"/// Sink addressing mode computation immediate before MemoryInst if doing so; /// can be done without increasing register pressure. The need for the; /// register pressure constraint means this can end up being an all or nothing; /// decision for all uses of the same addressing computation.; ///; /// Load and Store Instructions often have addressing modes that can do; /// significant amounts of computation. As such, instruction selection will try; /// to get the load or store to do as much computation as possible for the; /// program. The problem is that isel can only see within a single block. As; /// such, we sink as much legal addressing mode work into the block as possible.; ///; /// This method is used to optimize both load/store and inline asms with memory; /// operands. It's also used to sink addressing computations feeding into cold; /// call sites into their (cold) basic block.; ///; /// The motivation for handling sinking into cold blocks is that doing so can; /// both enable other address mode sinking (by satisfying the register pressure; /// constraint above), and reduce register pressure globally (by removing the; /// addressing mode computation from the fast path entirely.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:734,Performance,load,load,734,"/// Sink addressing mode computation immediate before MemoryInst if doing so; /// can be done without increasing register pressure. The need for the; /// register pressure constraint means this can end up being an all or nothing; /// decision for all uses of the same addressing computation.; ///; /// Load and Store Instructions often have addressing modes that can do; /// significant amounts of computation. As such, instruction selection will try; /// to get the load or store to do as much computation as possible for the; /// program. The problem is that isel can only see within a single block. As; /// such, we sink as much legal addressing mode work into the block as possible.; ///; /// This method is used to optimize both load/store and inline asms with memory; /// operands. It's also used to sink addressing computations feeding into cold; /// call sites into their (cold) basic block.; ///; /// The motivation for handling sinking into cold blocks is that doing so can; /// both enable other address mode sinking (by satisfying the register pressure; /// constraint above), and reduce register pressure globally (by removing the; /// addressing mode computation from the fast path entirely.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:64,Usability,undo,undo,64,// Try to collapse single-value PHI nodes. This is necessary to undo; // unprofitable PRE transformations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:510,Safety,safe,safely,510,"// We allow traversing cyclic Phi nodes.; // In case of success after this loop we ensure that traversing through; // Phi nodes ends up with all cases to compute address of the form; // BaseGV + Base + Scale * Index + Offset; // where Scale and Offset are constans and BaseGV, Base and Index; // are exactly the same Values in all cases.; // It means that BaseGV, Scale and Offset dominate our memory instruction; // and have the same value as they had in address computation represented; // as Phi. So we can safely sink address computation to memory instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:99,Integrability,depend,depending,99,"// For non-PHIs, determine the addressing mode being computed. Note that; // the result may differ depending on what other uses our candidate; // addressing instructions might have.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:50,Energy Efficiency,reduce,reduce,50,"// If splitting the underlying data structure can reduce the offset of a; // GEP, collect the GEP. Skip the GEPs that are the new bases of; // previously split data structures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:182,Performance,load,load,182,"// Now that we determined the addressing expression we want to use and know; // that we have to sink it into this block. Check to see if we have already; // done this for some other load/store instr in this block. If so, reuse; // the computation. Before attempting reuse, check if the address is valid; // as it may have been erased.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:27,Modifiability,extend,extend,27,// It is only safe to sign extend the BaseReg if we know that the math; // required to create it did not overflow before we extend it. Since; // the original IR value was tossed in favor of a constant back when; // the AddrMode was created we need to bail out gracefully if widths; // do not match instead of extending it.; //; // (See below for code to add the scale.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:124,Modifiability,extend,extend,124,// It is only safe to sign extend the BaseReg if we know that the math; // required to create it did not overflow before we extend it. Since; // the original IR value was tossed in favor of a constant back when; // the AddrMode was created we need to bail out gracefully if widths; // do not match instead of extending it.; //; // (See below for code to add the scale.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:309,Modifiability,extend,extending,309,// It is only safe to sign extend the BaseReg if we know that the math; // required to create it did not overflow before we extend it. Since; // the original IR value was tossed in favor of a constant back when; // the AddrMode was created we need to bail out gracefully if widths; // do not match instead of extending it.; //; // (See below for code to add the scale.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:14,Safety,safe,safe,14,// It is only safe to sign extend the BaseReg if we know that the math; // required to create it did not overflow before we extend it. Since; // the original IR value was tossed in favor of a constant back when; // the AddrMode was created we need to bail out gracefully if widths; // do not match instead of extending it.; //; // (See below for code to add the scale.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:89,Performance,load,load,89,// We need to add this separately from the scale above to help with; // SDAG consecutive load/store merging.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:36,Availability,down,down,36,"// We'd require a ptrtoint/inttoptr down the line, which we can't do for; // non-integral pointers, so in that case bail out now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:27,Modifiability,extend,extend,27,// It is only safe to sign extend the BaseReg if we know that the math; // required to create it did not overflow before we extend it. Since; // the original IR value was tossed in favor of a constant back when; // the AddrMode was created we need to bail out gracefully if widths; // do not match instead of extending it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:124,Modifiability,extend,extend,124,// It is only safe to sign extend the BaseReg if we know that the math; // required to create it did not overflow before we extend it. Since; // the original IR value was tossed in favor of a constant back when; // the AddrMode was created we need to bail out gracefully if widths; // do not match instead of extending it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:309,Modifiability,extend,extending,309,// It is only safe to sign extend the BaseReg if we know that the math; // required to create it did not overflow before we extend it. Since; // the original IR value was tossed in favor of a constant back when; // the AddrMode was created we need to bail out gracefully if widths; // do not match instead of extending it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:14,Safety,safe,safe,14,// It is only safe to sign extend the BaseReg if we know that the math; // required to create it did not overflow before we extend it. Since; // the original IR value was tossed in favor of a constant back when; // the AddrMode was created we need to bail out gracefully if widths; // do not match instead of extending it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:45,Performance,cache,cache,45,"// Store the newly computed address into the cache. In the case we reused a; // value, this should be idempotent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite GEP input to gather/scatter to enable SelectionDAGBuilder to find; /// a uniform base to use for ISD::MGATHER/MSCATTER. SelectionDAGBuilder can; /// only handle a 2 operand GEP in the same basic block or a splat constant; /// vector. The 2 operands to the GEP must have a scalar pointer and a vector; /// index.; ///; /// If the existing GEP has a vector base pointer that is splat, we can look; /// through the splat to find the scalar pointer. If we can't find a scalar; /// pointer there's nothing we can do.; ///; /// If we have a GEP with more than 2 indices where the middle indices are all; /// zeroes, we can replace it with 2 GEPs where the second has 2 operands.; ///; /// If the final index isn't a vector or is a splat, we can emit a scalar GEP; /// followed by a GEP with an all zeroes vector index. This will enable; /// SelectionDAGBuilder to use the scalar GEP as the uniform base and have a; /// zero index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:9,Performance,optimiz,optimize,9,// Don't optimize GEPs that don't have indices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:66,Performance,optimiz,optimize,66,"// If the GEP and the gather/scatter aren't in the same BB, don't optimize.; // FIXME: We should support this by sinking the GEP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:42,Performance,Optimiz,OptimizeMemoryInst,42,"/// If there are any memory operands, use OptimizeMemoryInst to sink their; /// address computing into the block when possible / profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:41,Modifiability,extend,extend,41,"// This is a ZExt, maybe this is free to extend from one type to another.; // In that case, we would not account for a different use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:39,Performance,load,load,39,// Early check if we directly have ext(load).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:172,Performance,load,load,172,// Check whether or not we want to do any promotion. The reason we have; // this check inside the for loop is to catch the case where an extension; // is directly fed by a load because in such case the extension can be moved; // up without any promotion on its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:21,Performance,perform,perform,21,// Get the action to perform the promotion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:53,Performance,load,load,53,"// We would be able to merge only one extension in a load.; // Therefore, if we have more than 1 new extension we heuristically; // cut this search path, because it means we degrade the code quality.; // With exactly 2, the transformation is neutral, because we will merge; // one extension but leave one. However, we optimistically keep going,; // because the new extension may be removed too. Also avoid replacing a; // single free extension with multiple extensions, as this increases the; // number of IR instructions while not providing any savings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:400,Safety,avoid,avoid,400,"// We would be able to merge only one extension in a load.; // Therefore, if we have more than 1 new extension we heuristically; // cut this search path, because it means we degrade the code quality.; // With exactly 2, the transformation is neutral, because we will merge; // one extension but leave one. However, we optimistically keep going,; // because the new extension may be removed too. Also avoid replacing a; // single free extension with multiple extensions, as this increases the; // number of IR instructions while not providing any savings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:37,Availability,rollback,rollback,37,"// This promotion is not profitable, rollback to the previous state, and; // save the current extension in ProfitablyMovedExts as the latest; // speculative promotion turned out to be unprofitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:37,Deployability,rollback,rollback,37,"// This promotion is not profitable, rollback to the previous state, and; // save the current extension in ProfitablyMovedExts as the latest; // speculative promotion turned out to be unprofitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:27,Performance,load,load,27,"// If we have reached to a load, we need this extra profitability check; // as it could potentially be merged into an ext(load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:122,Performance,load,load,122,"// If we have reached to a load, we need this extra profitability check; // as it could potentially be merged into an ext(load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:64,Availability,rollback,rollback,64,"// If none of speculative promotions for NewExts is profitable, rollback; // and save the current extension (I) as the last profitable extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:64,Deployability,rollback,rollback,64,"// If none of speculative promotions for NewExts is profitable, rollback; // and save the current extension (I) as the last profitable extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:12,Availability,redundant,redundant,12,/// Merging redundant sexts when one is dominating the other.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:12,Safety,redund,redundant,12,/// Merging redundant sexts when one is dominating the other.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:441,Performance,load,load,441,"// Splitting large data structures so that the GEPs accessing them can have; // smaller offsets so that they can be sunk to the same blocks as their users.; // For example, a large struct starting from %base is split into two parts; // where the second part starts from %new_base.; //; // Before:; // BB0:; // %base =; //; // BB1:; // %gep0 = gep %base, off0; // %gep1 = gep %base, off1; // %gep2 = gep %base, off2; //; // BB2:; // %load1 = load %gep0; // %load2 = load %gep1; // %load3 = load %gep2; //; // After:; // BB0:; // %base =; // %new_base = gep %base, off0; //; // BB1:; // %new_gep0 = %new_base; // %new_gep1 = gep %new_base, off1 - off0; // %new_gep2 = gep %new_base, off2 - off0; //; // BB2:; // %load1 = load i32, i32* %new_gep0; // %load2 = load i32, i32* %new_gep1; // %load3 = load i32, i32* %new_gep2; //; // %new_gep1 and %new_gep2 can be sunk to BB2 now after the splitting because; // their offsets are smaller enough to fit into the addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:465,Performance,load,load,465,"// Splitting large data structures so that the GEPs accessing them can have; // smaller offsets so that they can be sunk to the same blocks as their users.; // For example, a large struct starting from %base is split into two parts; // where the second part starts from %new_base.; //; // Before:; // BB0:; // %base =; //; // BB1:; // %gep0 = gep %base, off0; // %gep1 = gep %base, off1; // %gep2 = gep %base, off2; //; // BB2:; // %load1 = load %gep0; // %load2 = load %gep1; // %load3 = load %gep2; //; // After:; // BB0:; // %base =; // %new_base = gep %base, off0; //; // BB1:; // %new_gep0 = %new_base; // %new_gep1 = gep %new_base, off1 - off0; // %new_gep2 = gep %new_base, off2 - off0; //; // BB2:; // %load1 = load i32, i32* %new_gep0; // %load2 = load i32, i32* %new_gep1; // %load3 = load i32, i32* %new_gep2; //; // %new_gep1 and %new_gep2 can be sunk to BB2 now after the splitting because; // their offsets are smaller enough to fit into the addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:489,Performance,load,load,489,"// Splitting large data structures so that the GEPs accessing them can have; // smaller offsets so that they can be sunk to the same blocks as their users.; // For example, a large struct starting from %base is split into two parts; // where the second part starts from %new_base.; //; // Before:; // BB0:; // %base =; //; // BB1:; // %gep0 = gep %base, off0; // %gep1 = gep %base, off1; // %gep2 = gep %base, off2; //; // BB2:; // %load1 = load %gep0; // %load2 = load %gep1; // %load3 = load %gep2; //; // After:; // BB0:; // %base =; // %new_base = gep %base, off0; //; // BB1:; // %new_gep0 = %new_base; // %new_gep1 = gep %new_base, off1 - off0; // %new_gep2 = gep %new_base, off2 - off0; //; // BB2:; // %load1 = load i32, i32* %new_gep0; // %load2 = load i32, i32* %new_gep1; // %load3 = load i32, i32* %new_gep2; //; // %new_gep1 and %new_gep2 can be sunk to BB2 now after the splitting because; // their offsets are smaller enough to fit into the addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:719,Performance,load,load,719,"// Splitting large data structures so that the GEPs accessing them can have; // smaller offsets so that they can be sunk to the same blocks as their users.; // For example, a large struct starting from %base is split into two parts; // where the second part starts from %new_base.; //; // Before:; // BB0:; // %base =; //; // BB1:; // %gep0 = gep %base, off0; // %gep1 = gep %base, off1; // %gep2 = gep %base, off2; //; // BB2:; // %load1 = load %gep0; // %load2 = load %gep1; // %load3 = load %gep2; //; // After:; // BB0:; // %base =; // %new_base = gep %base, off0; //; // BB1:; // %new_gep0 = %new_base; // %new_gep1 = gep %new_base, off1 - off0; // %new_gep2 = gep %new_base, off2 - off0; //; // BB2:; // %load1 = load i32, i32* %new_gep0; // %load2 = load i32, i32* %new_gep1; // %load3 = load i32, i32* %new_gep2; //; // %new_gep1 and %new_gep2 can be sunk to BB2 now after the splitting because; // their offsets are smaller enough to fit into the addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:757,Performance,load,load,757,"// Splitting large data structures so that the GEPs accessing them can have; // smaller offsets so that they can be sunk to the same blocks as their users.; // For example, a large struct starting from %base is split into two parts; // where the second part starts from %new_base.; //; // Before:; // BB0:; // %base =; //; // BB1:; // %gep0 = gep %base, off0; // %gep1 = gep %base, off1; // %gep2 = gep %base, off2; //; // BB2:; // %load1 = load %gep0; // %load2 = load %gep1; // %load3 = load %gep2; //; // After:; // BB0:; // %base =; // %new_base = gep %base, off0; //; // BB1:; // %new_gep0 = %new_base; // %new_gep1 = gep %new_base, off1 - off0; // %new_gep2 = gep %new_base, off2 - off0; //; // BB2:; // %load1 = load i32, i32* %new_gep0; // %load2 = load i32, i32* %new_gep1; // %load3 = load i32, i32* %new_gep2; //; // %new_gep1 and %new_gep2 can be sunk to BB2 now after the splitting because; // their offsets are smaller enough to fit into the addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:795,Performance,load,load,795,"// Splitting large data structures so that the GEPs accessing them can have; // smaller offsets so that they can be sunk to the same blocks as their users.; // For example, a large struct starting from %base is split into two parts; // where the second part starts from %new_base.; //; // Before:; // BB0:; // %base =; //; // BB1:; // %gep0 = gep %base, off0; // %gep1 = gep %base, off1; // %gep2 = gep %base, off2; //; // BB2:; // %load1 = load %gep0; // %load2 = load %gep1; // %load3 = load %gep2; //; // After:; // BB0:; // %base =; // %new_base = gep %base, off0; //; // BB1:; // %new_gep0 = %new_base; // %new_gep1 = gep %new_base, off1 - off0; // %new_gep2 = gep %new_base, off2 - off0; //; // BB2:; // %load1 = load i32, i32* %new_gep0; // %load2 = load i32, i32* %new_gep1; // %load3 = load i32, i32* %new_gep2; //; // %new_gep1 and %new_gep2 can be sunk to BB2 now after the splitting because; // their offsets are smaller enough to fit into the addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:52,Security,access,accessing,52,"// Splitting large data structures so that the GEPs accessing them can have; // smaller offsets so that they can be sunk to the same blocks as their users.; // For example, a large struct starting from %base is split into two parts; // where the second part starts from %new_base.; //; // Before:; // BB0:; // %base =; //; // BB1:; // %gep0 = gep %base, off0; // %gep1 = gep %base, off1; // %gep2 = gep %base, off2; //; // BB2:; // %load1 = load %gep0; // %load2 = load %gep1; // %load3 = load %gep2; //; // After:; // BB0:; // %base =; // %new_base = gep %base, off0; //; // BB1:; // %new_gep0 = %new_base; // %new_gep1 = gep %new_base, off1 - off0; // %new_gep2 = gep %new_base, off2 - off0; //; // BB2:; // %load1 = load i32, i32* %new_gep0; // %load2 = load i32, i32* %new_gep1; // %load3 = load i32, i32* %new_gep2; //; // %new_gep1 and %new_gep2 can be sunk to BB2 now after the splitting because; // their offsets are smaller enough to fit into the addressing mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:70,Security,access,access,70,// The result type of the GEP might not be the type of the memory; // access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:90,Performance,load,loads,90,"// We are looking for a collection on interconnected phi nodes that together; // only use loads/bitcasts and are used by stores/bitcasts, and the bitcasts; // are of the same type. Convert the whole set of nodes to the type of the; // bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:47,Performance,load,load,47,// This works by adding extra bitcasts between load/stores and removing; // existing bicasts. If we have a phi(bitcast(load)) or a store(bitcast(phi)); // we can get in the situation where we remove a bitcast in one iteration; // just to add it again in the next. We need to ensure that at least one; // bitcast we remove are anchored to something that will not change back.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:119,Performance,load,load,119,// This works by adding extra bitcasts between load/stores and removing; // existing bicasts. If we have a phi(bitcast(load)) or a store(bitcast(phi)); // we can get in the situation where we remove a bitcast in one iteration; // just to add it again in the next. We need to ensure that at least one; // bitcast we remove are anchored to something that will not change back.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:65,Performance,load,loads,65,"// Create all the new phi nodes of the new type, and bitcast any loads to the; // correct type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:14,Performance,optimiz,optimize,14,// Attempt to optimize all the phis in the functions to the correct type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:27,Performance,load,load,27,"/// Return true, if an ext(load) can be formed from an extension in; /// \p MovedExts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:159,Modifiability,extend,extend,159,"/// Move a zext or sext fed by a load into the same basic block as the load,; /// unless conditions are unfavorable. This allows SelectionDAG to fold the; /// extend into the load.; ///; /// E.g.,; /// \code; /// %ld = load i32* %addr; /// %add = add nuw i32 %ld, 4; /// %zext = zext i32 %add to i64; // \endcode; /// =>; /// \code; /// %ld = load i32* %addr; /// %zext = zext i32 %ld to i64; /// %add = add nuw i64 %zext, 4; /// \encode; /// Note that the promotion in %add to i64 is done in tryToPromoteExts(), which; /// allow us to match zext(load i32*) to i64.; ///; /// Also, try to promote the computations used to obtain a sign extended; /// value used into memory accesses.; /// E.g.,; /// \code; /// a = add nsw i32 b, 3; /// d = sext i32 a to i64; /// e = getelementptr ..., i64 d; /// \endcode; /// =>; /// \code; /// f = sext i32 b to i64; /// a = add nsw i64 f, 3; /// e = getelementptr ..., i64 a; /// \endcode; ///; /// \p Inst[in/out] the extension may be modified during the process if some; /// promotions apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:636,Modifiability,extend,extended,636,"/// Move a zext or sext fed by a load into the same basic block as the load,; /// unless conditions are unfavorable. This allows SelectionDAG to fold the; /// extend into the load.; ///; /// E.g.,; /// \code; /// %ld = load i32* %addr; /// %add = add nuw i32 %ld, 4; /// %zext = zext i32 %add to i64; // \endcode; /// =>; /// \code; /// %ld = load i32* %addr; /// %zext = zext i32 %ld to i64; /// %add = add nuw i64 %zext, 4; /// \encode; /// Note that the promotion in %add to i64 is done in tryToPromoteExts(), which; /// allow us to match zext(load i32*) to i64.; ///; /// Also, try to promote the computations used to obtain a sign extended; /// value used into memory accesses.; /// E.g.,; /// \code; /// a = add nsw i32 b, 3; /// d = sext i32 a to i64; /// e = getelementptr ..., i64 d; /// \endcode; /// =>; /// \code; /// f = sext i32 b to i64; /// a = add nsw i64 f, 3; /// e = getelementptr ..., i64 a; /// \endcode; ///; /// \p Inst[in/out] the extension may be modified during the process if some; /// promotions apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:33,Performance,load,load,33,"/// Move a zext or sext fed by a load into the same basic block as the load,; /// unless conditions are unfavorable. This allows SelectionDAG to fold the; /// extend into the load.; ///; /// E.g.,; /// \code; /// %ld = load i32* %addr; /// %add = add nuw i32 %ld, 4; /// %zext = zext i32 %add to i64; // \endcode; /// =>; /// \code; /// %ld = load i32* %addr; /// %zext = zext i32 %ld to i64; /// %add = add nuw i64 %zext, 4; /// \encode; /// Note that the promotion in %add to i64 is done in tryToPromoteExts(), which; /// allow us to match zext(load i32*) to i64.; ///; /// Also, try to promote the computations used to obtain a sign extended; /// value used into memory accesses.; /// E.g.,; /// \code; /// a = add nsw i32 b, 3; /// d = sext i32 a to i64; /// e = getelementptr ..., i64 d; /// \endcode; /// =>; /// \code; /// f = sext i32 b to i64; /// a = add nsw i64 f, 3; /// e = getelementptr ..., i64 a; /// \endcode; ///; /// \p Inst[in/out] the extension may be modified during the process if some; /// promotions apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:71,Performance,load,load,71,"/// Move a zext or sext fed by a load into the same basic block as the load,; /// unless conditions are unfavorable. This allows SelectionDAG to fold the; /// extend into the load.; ///; /// E.g.,; /// \code; /// %ld = load i32* %addr; /// %add = add nuw i32 %ld, 4; /// %zext = zext i32 %add to i64; // \endcode; /// =>; /// \code; /// %ld = load i32* %addr; /// %zext = zext i32 %ld to i64; /// %add = add nuw i64 %zext, 4; /// \encode; /// Note that the promotion in %add to i64 is done in tryToPromoteExts(), which; /// allow us to match zext(load i32*) to i64.; ///; /// Also, try to promote the computations used to obtain a sign extended; /// value used into memory accesses.; /// E.g.,; /// \code; /// a = add nsw i32 b, 3; /// d = sext i32 a to i64; /// e = getelementptr ..., i64 d; /// \endcode; /// =>; /// \code; /// f = sext i32 b to i64; /// a = add nsw i64 f, 3; /// e = getelementptr ..., i64 a; /// \endcode; ///; /// \p Inst[in/out] the extension may be modified during the process if some; /// promotions apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:175,Performance,load,load,175,"/// Move a zext or sext fed by a load into the same basic block as the load,; /// unless conditions are unfavorable. This allows SelectionDAG to fold the; /// extend into the load.; ///; /// E.g.,; /// \code; /// %ld = load i32* %addr; /// %add = add nuw i32 %ld, 4; /// %zext = zext i32 %add to i64; // \endcode; /// =>; /// \code; /// %ld = load i32* %addr; /// %zext = zext i32 %ld to i64; /// %add = add nuw i64 %zext, 4; /// \encode; /// Note that the promotion in %add to i64 is done in tryToPromoteExts(), which; /// allow us to match zext(load i32*) to i64.; ///; /// Also, try to promote the computations used to obtain a sign extended; /// value used into memory accesses.; /// E.g.,; /// \code; /// a = add nsw i32 b, 3; /// d = sext i32 a to i64; /// e = getelementptr ..., i64 d; /// \endcode; /// =>; /// \code; /// f = sext i32 b to i64; /// a = add nsw i64 f, 3; /// e = getelementptr ..., i64 a; /// \endcode; ///; /// \p Inst[in/out] the extension may be modified during the process if some; /// promotions apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:219,Performance,load,load,219,"/// Move a zext or sext fed by a load into the same basic block as the load,; /// unless conditions are unfavorable. This allows SelectionDAG to fold the; /// extend into the load.; ///; /// E.g.,; /// \code; /// %ld = load i32* %addr; /// %add = add nuw i32 %ld, 4; /// %zext = zext i32 %add to i64; // \endcode; /// =>; /// \code; /// %ld = load i32* %addr; /// %zext = zext i32 %ld to i64; /// %add = add nuw i64 %zext, 4; /// \encode; /// Note that the promotion in %add to i64 is done in tryToPromoteExts(), which; /// allow us to match zext(load i32*) to i64.; ///; /// Also, try to promote the computations used to obtain a sign extended; /// value used into memory accesses.; /// E.g.,; /// \code; /// a = add nsw i32 b, 3; /// d = sext i32 a to i64; /// e = getelementptr ..., i64 d; /// \endcode; /// =>; /// \code; /// f = sext i32 b to i64; /// a = add nsw i64 f, 3; /// e = getelementptr ..., i64 a; /// \endcode; ///; /// \p Inst[in/out] the extension may be modified during the process if some; /// promotions apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:343,Performance,load,load,343,"/// Move a zext or sext fed by a load into the same basic block as the load,; /// unless conditions are unfavorable. This allows SelectionDAG to fold the; /// extend into the load.; ///; /// E.g.,; /// \code; /// %ld = load i32* %addr; /// %add = add nuw i32 %ld, 4; /// %zext = zext i32 %add to i64; // \endcode; /// =>; /// \code; /// %ld = load i32* %addr; /// %zext = zext i32 %ld to i64; /// %add = add nuw i64 %zext, 4; /// \encode; /// Note that the promotion in %add to i64 is done in tryToPromoteExts(), which; /// allow us to match zext(load i32*) to i64.; ///; /// Also, try to promote the computations used to obtain a sign extended; /// value used into memory accesses.; /// E.g.,; /// \code; /// a = add nsw i32 b, 3; /// d = sext i32 a to i64; /// e = getelementptr ..., i64 d; /// \endcode; /// =>; /// \code; /// f = sext i32 b to i64; /// a = add nsw i64 f, 3; /// e = getelementptr ..., i64 a; /// \endcode; ///; /// \p Inst[in/out] the extension may be modified during the process if some; /// promotions apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:547,Performance,load,load,547,"/// Move a zext or sext fed by a load into the same basic block as the load,; /// unless conditions are unfavorable. This allows SelectionDAG to fold the; /// extend into the load.; ///; /// E.g.,; /// \code; /// %ld = load i32* %addr; /// %add = add nuw i32 %ld, 4; /// %zext = zext i32 %add to i64; // \endcode; /// =>; /// \code; /// %ld = load i32* %addr; /// %zext = zext i32 %ld to i64; /// %add = add nuw i64 %zext, 4; /// \encode; /// Note that the promotion in %add to i64 is done in tryToPromoteExts(), which; /// allow us to match zext(load i32*) to i64.; ///; /// Also, try to promote the computations used to obtain a sign extended; /// value used into memory accesses.; /// E.g.,; /// \code; /// a = add nsw i32 b, 3; /// d = sext i32 a to i64; /// e = getelementptr ..., i64 d; /// \endcode; /// =>; /// \code; /// f = sext i32 b to i64; /// a = add nsw i64 f, 3; /// e = getelementptr ..., i64 a; /// \endcode; ///; /// \p Inst[in/out] the extension may be modified during the process if some; /// promotions apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:673,Security,access,accesses,673,"/// Move a zext or sext fed by a load into the same basic block as the load,; /// unless conditions are unfavorable. This allows SelectionDAG to fold the; /// extend into the load.; ///; /// E.g.,; /// \code; /// %ld = load i32* %addr; /// %add = add nuw i32 %ld, 4; /// %zext = zext i32 %add to i64; // \endcode; /// =>; /// \code; /// %ld = load i32* %addr; /// %zext = zext i32 %ld to i64; /// %add = add nuw i64 %zext, 4; /// \encode; /// Note that the promotion in %add to i64 is done in tryToPromoteExts(), which; /// allow us to match zext(load i32*) to i64.; ///; /// Also, try to promote the computations used to obtain a sign extended; /// value used into memory accesses.; /// E.g.,; /// \code; /// a = add nsw i32 b, 3; /// d = sext i32 a to i64; /// e = getelementptr ..., i64 d; /// \endcode; /// =>; /// \code; /// f = sext i32 b to i64; /// a = add nsw i64 f, 3; /// e = getelementptr ..., i64 a; /// \endcode; ///; /// \p Inst[in/out] the extension may be modified during the process if some; /// promotions apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:172,Security,access,accesses,172,"/// See if it is an interesting sext operations for the address type; /// promotion before trying to promote it, e.g., the ones with the right; /// type and used in memory accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:25,Modifiability,extend,extended,25,// Look for a load being extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:14,Performance,load,load,14,// Look for a load being extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:65,Modifiability,extend,extended,65,// Try to promote a chain of computation if it allows to form an extended; // load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:78,Performance,load,load,78,// Try to promote a chain of computation if it allows to form an extended; // load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:12,Modifiability,extend,extend,12,// Move the extend into the same block as the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:46,Performance,load,load,46,// Move the extend into the same block as the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:53,Integrability,depend,depending,53,// Continue promoting SExts if known as considerable depending on targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:165,Modifiability,extend,extended,165,"// Perform address type promotion if doing so is profitable.; // If AllowPromotionWithoutCommonHeader == false, we should find other sext; // instructions that sign extended the same initial value. However, if; // AllowPromotionWithoutCommonHeader == true, we expect promoting the; // extension is just profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Performance,Perform,Perform,3,"// Perform address type promotion if doing so is profitable.; // If AllowPromotionWithoutCommonHeader == false, we should find other sext; // instructions that sign extended the same initial value. However, if; // AllowPromotionWithoutCommonHeader == true, we expect promoting the; // extension is just profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Deployability,Update,Update,3,// Update Inst as promotion happen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:65,Modifiability,rewrite,rewrite,65,"// If the result of a {s|z}ext and its source are both live out, rewrite all; // other uses of the source with result of extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:16,Performance,perform,perform,16,// Only safe to perform the optimization if the source is also defined in; // this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:28,Performance,optimiz,optimization,28,// Only safe to perform the optimization if the source is also defined in; // this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:8,Safety,safe,safe,8,// Only safe to perform the optimization if the source is also defined in; // this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:91,Performance,load,load,91,// Be conservative. We don't want this xform to end up introducing; // reloads just before load / store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:44,Modifiability,Rewrite,Rewrite,44,// Both src and def are live in this block. Rewrite the use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:297,Availability,redundant,redundant,297,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:8,Performance,load,loads,8,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:46,Performance,load,loaded,46,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:99,Performance,load,load,99,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:252,Performance,load,loaded,252,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:424,Performance,load,load,424,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:535,Performance,load,load,535,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:631,Performance,load,load,631,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:730,Performance,load,load,730,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:764,Performance,load,load,764,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:861,Performance,optimiz,optimizeLoadExt,861,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:886,Performance,load,load,886,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:914,Performance,load,load,914,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:971,Performance,load,load,971,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:297,Safety,redund,redundant,297,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:8,Performance,load,loads,8,// Skip loads we've already transformed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:23,Performance,Load,Load,23,"// Look at all uses of Load, looking through phis, to determine how many bits; // of the loaded value are needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:89,Performance,load,loaded,89,"// Look at all uses of Load, looking through phis, to determine how many bits; // of the loaded value are needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:39,Performance,optimiz,optimize,39,"// If the BitWidth is 0, do not try to optimize the type",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:32,Availability,mask,mask,32,// Keep track of the widest and mask we see.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:596,Availability,mask,mask,596,"// Avoid hoisting (and (load x) 1) since it is unlikely to be folded by the; // target even if isLoadExtLegal says an i1 EXTLOAD is valid. For example,; // for the AArch64 target isLoadExtLegal(ZEXTLOAD, i32, i1) returns true, but; // (and (load x) 1) is not matched as a single instruction, rather as a LDR; // followed by an AND.; // TODO: Look into removing this restriction by fixing backends to either; // return false for isLoadExtLegal for i1 or have them select this pattern to; // a single instruction.; //; // Also avoid hoisting if we didn't see any ands with the exact DemandBits; // mask, since these are the only ands that will be removed by isel.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:24,Performance,load,load,24,"// Avoid hoisting (and (load x) 1) since it is unlikely to be folded by the; // target even if isLoadExtLegal says an i1 EXTLOAD is valid. For example,; // for the AArch64 target isLoadExtLegal(ZEXTLOAD, i32, i1) returns true, but; // (and (load x) 1) is not matched as a single instruction, rather as a LDR; // followed by an AND.; // TODO: Look into removing this restriction by fixing backends to either; // return false for isLoadExtLegal for i1 or have them select this pattern to; // a single instruction.; //; // Also avoid hoisting if we didn't see any ands with the exact DemandBits; // mask, since these are the only ands that will be removed by isel.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:241,Performance,load,load,241,"// Avoid hoisting (and (load x) 1) since it is unlikely to be folded by the; // target even if isLoadExtLegal says an i1 EXTLOAD is valid. For example,; // for the AArch64 target isLoadExtLegal(ZEXTLOAD, i32, i1) returns true, but; // (and (load x) 1) is not matched as a single instruction, rather as a LDR; // followed by an AND.; // TODO: Look into removing this restriction by fixing backends to either; // return false for isLoadExtLegal for i1 or have them select this pattern to; // a single instruction.; //; // Also avoid hoisting if we didn't see any ands with the exact DemandBits; // mask, since these are the only ands that will be removed by isel.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Safety,Avoid,Avoid,3,"// Avoid hoisting (and (load x) 1) since it is unlikely to be folded by the; // target even if isLoadExtLegal says an i1 EXTLOAD is valid. For example,; // for the AArch64 target isLoadExtLegal(ZEXTLOAD, i32, i1) returns true, but; // (and (load x) 1) is not matched as a single instruction, rather as a LDR; // followed by an AND.; // TODO: Look into removing this restriction by fixing backends to either; // return false for isLoadExtLegal for i1 or have them select this pattern to; // a single instruction.; //; // Also avoid hoisting if we didn't see any ands with the exact DemandBits; // mask, since these are the only ands that will be removed by isel.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:525,Safety,avoid,avoid,525,"// Avoid hoisting (and (load x) 1) since it is unlikely to be folded by the; // target even if isLoadExtLegal says an i1 EXTLOAD is valid. For example,; // for the AArch64 target isLoadExtLegal(ZEXTLOAD, i32, i1) returns true, but; // (and (load x) 1) is not matched as a single instruction, rather as a LDR; // followed by an AND.; // TODO: Look into removing this restriction by fixing backends to either; // return false for isLoadExtLegal for i1 or have them select this pattern to; // a single instruction.; //; // Also avoid hoisting if we didn't see any ands with the exact DemandBits; // mask, since these are the only ands that will be removed by isel.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:65,Performance,optimiz,optimizations,65,"// Mark this instruction as ""inserted by CGP"", so that other; // optimizations don't touch it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:23,Performance,load,load,23,// Replace all uses of load with new and (except for the use of load in the; // new and itself).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:64,Performance,load,load,64,// Replace all uses of load with new and (except for the use of load in the; // new and itself).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:44,Availability,redundant,redundant,44,// Remove any and instructions that are now redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:44,Safety,redund,redundant,44,// Remove any and instructions that are now redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:22,Availability,mask,mask,22,// Check that the and mask is the same as the one we decided to put on the; // new and.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:11,Safety,safe,safe,11,"// If it's safe to speculatively execute, then it should not have side; // effects; therefore, it's safe to sink and possibly *not* execute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:100,Safety,safe,safe,100,"// If it's safe to speculatively execute, then it should not have side; // effects; therefore, it's safe to sink and possibly *not* execute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:13,Safety,predict,predictable,13,"// If even a predictable select is cheap, then a branch can't be cheaper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:195,Safety,predict,predictable,195,"// FIXME: This should use the same heuristics as IfConversion to determine; // whether a select is better represented as a branch.; // If metadata tells us that the select condition is obviously predictable,; // then we want to replace the select with a branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:18,Safety,predict,predictable,18,"// If a branch is predictable, an out-of-order CPU can avoid blocking on its; // comparison condition. If the compare has more than one use, there's; // probably another cmov or setcc around, so it's not worth emitting a branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:55,Safety,avoid,avoid,55,"// If a branch is predictable, an out-of-order CPU can avoid blocking on its; // comparison condition. If the compare has more than one use, there's; // probably another cmov or setcc around, so it's not worth emitting a branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:64,Safety,predict,prediction,64,"/// If we have a SelectInst that will likely profit from branch prediction,; /// turn it into a branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:68,Performance,optimiz,optimized,68,"// If the SelectOptimize pass is enabled, selects have already been optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:163,Availability,mainten,maintenence,163,"// Examine debug-info attached to the consecutive select instructions. They; // won't be individually optimised by optimizeInst, so we need to perform; // DPValue maintenence here instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:115,Performance,optimiz,optimizeInst,115,"// Examine debug-info attached to the consecutive select instructions. They; // won't be individually optimised by optimizeInst, so we need to perform; // DPValue maintenence here instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:143,Performance,perform,perform,143,"// Examine debug-info attached to the consecutive select instructions. They; // won't be individually optimised by optimizeInst, so we need to perform; // DPValue maintenence here instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:229,Performance,optimiz,optimized,229,// The DominatorTree needs to be rebuilt by any consumers after this; // transformation. We simply reset here rather than setting the ModifiedDT; // flag to avoid restarting the function walk in runOnFunction for each; // select optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:157,Safety,avoid,avoid,157,// The DominatorTree needs to be rebuilt by any consumers after this; // transformation. We simply reset here rather than setting the ModifiedDT; // flag to avoid restarting the function walk in runOnFunction for each; // select optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:92,Usability,simpl,simply,92,// The DominatorTree needs to be rebuilt by any consumers after this; // transformation. We simply reset here rather than setting the ModifiedDT; // flag to avoid restarting the function walk in runOnFunction for each; // select optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:746,Performance,optimiz,optimized,746,"// Transform a sequence like this:; // start:; // %cmp = cmp uge i32 %a, %b; // %sel = select i1 %cmp, i32 %c, i32 %d; //; // Into:; // start:; // %cmp = cmp uge i32 %a, %b; // %cmp.frozen = freeze %cmp; // br i1 %cmp.frozen, label %select.true, label %select.false; // select.true:; // br label %select.end; // select.false:; // br label %select.end; // select.end:; // %sel = phi i32 [ %c, %select.true ], [ %d, %select.false ]; //; // %cmp should be frozen, otherwise it may introduce undefined behavior.; // In addition, we may sink instructions that produce %c or %d from; // the entry block into the destination(s) of the new branch.; // If the true or false blocks do not contain a sunken instruction, that; // block and its branch may be optimized away. In that case, one side of the; // first branch will point directly to select.end, and the corresponding PHI; // predecessor block will be the start block.; // Collect values that go on the true side and the values that go on the false; // side.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:62,Safety,avoid,avoid,62,// Sink expensive instructions into the conditional blocks to avoid executing; // them speculatively.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:12,Performance,Optimiz,OptimizeBlock,12,// Instruct OptimizeBlock to skip to the next block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:133,Performance,optimiz,optimization,133,"// Now we clone an instruction, its operands' defs may sink to this BB; // now. So we put the operands defs' BBs into FreshBBs to do optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Deployability,Update,Update,3,"// Update the use for the new instruction, making sure that we update the; // sunk instruction uses, if it is part of a chain that has already been; // sunk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:63,Deployability,update,update,63,"// Update the use for the new instruction, making sure that we update the; // sunk instruction uses, if it is part of a chain that has already been; // sunk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:281,Modifiability,extend,extended,281,"// If the register width is greater than the type width, expand the condition; // of the switch instruction and each case constant to the width of the; // register. By widening the type of the switch condition, subsequent; // comparisons (for case comparisons) will not need to be extended to the; // preferred register width, so we will potentially eliminate N-1 extends,; // where N is the number of cases in the switch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:364,Modifiability,extend,extends,364,"// If the register width is greater than the type width, expand the condition; // of the switch instruction and each case constant to the width of the; // register. By widening the type of the switch condition, subsequent; // comparisons (for case comparisons) will not need to be extended to the; // preferred register width, so we will potentially eliminate N-1 extends,; // where N is the number of cases in the switch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:211,Availability,mask,mask,211,"// Extend the switch condition and case constants using the target preferred; // extend unless the switch condition is a function argument with an extend; // attribute. In that case, we can avoid an unnecessary mask/extension by; // matching the argument extension instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Modifiability,Extend,Extend,3,"// Extend the switch condition and case constants using the target preferred; // extend unless the switch condition is a function argument with an extend; // attribute. In that case, we can avoid an unnecessary mask/extension by; // matching the argument extension instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:81,Modifiability,extend,extend,81,"// Extend the switch condition and case constants using the target preferred; // extend unless the switch condition is a function argument with an extend; // attribute. In that case, we can avoid an unnecessary mask/extension by; // matching the argument extension instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:147,Modifiability,extend,extend,147,"// Extend the switch condition and case constants using the target preferred; // extend unless the switch condition is a function argument with an extend; // attribute. In that case, we can avoid an unnecessary mask/extension by; // matching the argument extension instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:190,Safety,avoid,avoid,190,"// Extend the switch condition and case constants using the target preferred; // extend unless the switch condition is a function argument with an extend; // attribute. In that case, we can avoid an unnecessary mask/extension by; // matching the argument extension instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:12,Performance,optimiz,optimization,12,"// The SCCP optimization tends to produce code like this:; // switch(x) { case 42: phi(42, ...) }; // Materializing the constant for the phi-argument needs instructions; So we; // change the code to:; // switch(x) { case 42: phi(x, ...) }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Safety,Avoid,Avoid,3,// Avoid endless loop in degenerate case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:13,Performance,optimiz,optimize,13,// We cannot optimize if there are multiple case labels jumping to; // this block. This check may get expensive when there are many; // case labels so we test for it last.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:154,Testability,test,test,154,// We cannot optimize if there are multiple case labels jumping to; // this block. This check may get expensive when there are many; // case labels so we test for it last.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:96,Availability,down,downward,96,"/// Helper class to promote a scalar operation to a vector one.; /// This class is used to move downward extractelement transition.; /// E.g.,; /// a = vector_op <2 x i32>; /// b = extractelement <2 x i32> a, i32 0; /// c = scalar_op b; /// store c; ///; /// =>; /// a = vector_op <2 x i32>; /// c = vector_op a (equivalent to scalar_op on the related lane); /// * d = extractelement <2 x i32> c, i32 0; /// * store d; /// Assuming both extractelement and store can be combine, we get rid of the; /// transition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:12,Performance,perform,perform,12,/// Used to perform some checks on the legality of vector operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:31,Availability,down,downwards,31,/// The transition being moved downwards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:45,Availability,down,downward,45,"/// Promote \p ToBePromoted by moving \p Def downward through.; /// I.e., we have the following sequence:; /// Def = Transition <ty1> a to <ty2>; /// b = ToBePromoted <ty2> Def, ...; /// =>; /// b = ToBePromoted <ty1> a, ...; /// Def = Transition <ty1> ToBePromoted to <ty2>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:15,Safety,safe,safe,15,// This is not safe to introduce undef when the operand is on; // the right hand side of a division-like instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:72,Availability,down,downward,72,/// Check if it is profitable to promote \p ToBePromoted; /// by moving downward the transition through.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:248,Availability,down,down,248,"// At this point, we know that all the operands of ToBePromoted but Def; // can be statically promoted.; // For Def, we need to use its parameter in ToBePromoted:; // b = ToBePromoted ty1 a; // Def = Transition ty1 b to ty2; // Move the transition down.; // 1. Replace all uses of the promoted operation by the transition.; // = ... b => = ... Def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:6,Deployability,Update,Update,6,// 2. Update the type of the uses.; // b = ToBePromoted ty2 Def => b = ToBePromoted ty1 Def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:6,Deployability,Update,Update,6,// 3. Update all the operands of the promoted operation with promoted; // operands.; // b = ToBePromoted ty1 Def => b = ToBePromoted ty1 a.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:37,Safety,safe,safe,37,// Use a splat constant if it is not safe to use undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:88,Availability,down,down,88,"// At this point we know that Inst is a vector to scalar transition.; // Try to move it down the def-use chain, until:; // - We can combine the transition with its single use; // => we got rid of the transition.; // - We escape the current basic block; // => we would need to check that we are moving it at a cheaper place and; // we do not do that for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:165,Energy Efficiency,efficient,efficient,165,"/// For the instruction sequence of store below, F and I values; /// are bundled together as an i64 value before being stored into memory.; /// Sometimes it is more efficient to generate separate stores for F and I,; /// which can remove the bitwise instructions or sink them to colder places.; ///; /// (store (or (zext (bitcast F to i32) to i64),; /// (shl (zext I to i64), 32)), addr) -->; /// (store F, addr) and (store I, addr+4); ///; /// Similarly, splitting for other merged store can also be beneficial, like:; /// For pair of {i32, i32}, i64 store --> two i32 stores.; /// For pair of {i32, i16}, i64 store --> two i32 stores.; /// For pair of {i16, i16}, i32 store --> two i16 stores.; /// For pair of {i16, i8}, i32 store --> two i16 stores.; /// For pair of {i8, i8}, i16 store --> two i8 stores.; ///; /// We allow each target to determine specifically which kind of splitting is; /// supported.; ///; /// The store patterns are commonly seen from the simple code snippet below; /// if only std::make_pair(...) is sroa transformed before inlined into hoo.; /// void goo(const std::pair<int, float> &);; /// hoo() {; /// ...; /// goo(std::make_pair(tmp, ftmp));; /// ...; /// }; ///; /// Although we already have similar splitting in DAG Combine, we duplicate; /// it in CodeGenPrepare to catch the case in which pattern is across; /// multiple BBs. The logic in DAG Combine is kept to catch case generated; /// during code expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:1367,Testability,log,logic,1367,"/// For the instruction sequence of store below, F and I values; /// are bundled together as an i64 value before being stored into memory.; /// Sometimes it is more efficient to generate separate stores for F and I,; /// which can remove the bitwise instructions or sink them to colder places.; ///; /// (store (or (zext (bitcast F to i32) to i64),; /// (shl (zext I to i64), 32)), addr) -->; /// (store F, addr) and (store I, addr+4); ///; /// Similarly, splitting for other merged store can also be beneficial, like:; /// For pair of {i32, i32}, i64 store --> two i32 stores.; /// For pair of {i32, i16}, i64 store --> two i32 stores.; /// For pair of {i16, i16}, i32 store --> two i16 stores.; /// For pair of {i16, i8}, i32 store --> two i16 stores.; /// For pair of {i8, i8}, i16 store --> two i8 stores.; ///; /// We allow each target to determine specifically which kind of splitting is; /// supported.; ///; /// The store patterns are commonly seen from the simple code snippet below; /// if only std::make_pair(...) is sroa transformed before inlined into hoo.; /// void goo(const std::pair<int, float> &);; /// hoo() {; /// ...; /// goo(std::make_pair(tmp, ftmp));; /// ...; /// }; ///; /// Although we already have similar splitting in DAG Combine, we duplicate; /// it in CodeGenPrepare to catch the case in which pattern is across; /// multiple BBs. The logic in DAG Combine is kept to catch case generated; /// during code expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:966,Usability,simpl,simple,966,"/// For the instruction sequence of store below, F and I values; /// are bundled together as an i64 value before being stored into memory.; /// Sometimes it is more efficient to generate separate stores for F and I,; /// which can remove the bitwise instructions or sink them to colder places.; ///; /// (store (or (zext (bitcast F to i32) to i64),; /// (shl (zext I to i64), 32)), addr) -->; /// (store F, addr) and (store I, addr+4); ///; /// Similarly, splitting for other merged store can also be beneficial, like:; /// For pair of {i32, i32}, i64 store --> two i32 stores.; /// For pair of {i32, i16}, i64 store --> two i32 stores.; /// For pair of {i16, i16}, i32 store --> two i16 stores.; /// For pair of {i16, i8}, i32 store --> two i16 stores.; /// For pair of {i8, i8}, i16 store --> two i8 stores.; ///; /// We allow each target to determine specifically which kind of splitting is; /// supported.; ///; /// The store patterns are commonly seen from the simple code snippet below; /// if only std::make_pair(...) is sroa transformed before inlined into hoo.; /// void goo(const std::pair<int, float> &);; /// hoo() {; /// ...; /// goo(std::make_pair(tmp, ftmp));; /// ...; /// }; ///; /// Although we already have similar splitting in DAG Combine, we duplicate; /// it in CodeGenPrepare to catch the case in which pattern is across; /// multiple BBs. The logic in DAG Combine is kept to catch case generated; /// during code expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:10,Usability,simpl,simple,10,// Handle simple but common cases only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:76,Performance,scalab,scalable,76,"// The code below assumes shifting a value by <number of bits>,; // whereas scalable vectors would have to be shifted by; // <2log(vscale) + number of bits> in order to store the; // low/high parts. Bailing out for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:555,Availability,alive,alive,555,"// Try unmerging GEPs to reduce liveness interference (register pressure) across; // IndirectBr edges. Since IndirectBr edges tend to touch on many blocks,; // reducing liveness interference across those edges benefits global register; // allocation. Currently handles only certain cases.; //; // For example, unmerge %GEPI and %UGEPI as below.; //; // ---------- BEFORE ----------; // SrcBlock:; // ...; // %GEPIOp = ...; // ...; // %GEPI = gep %GEPIOp, Idx; // ...; // indirectbr ... [ label %DstB0, label %DstB1, ... label %DstBi ... ]; // (* %GEPI is alive on the indirectbr edges due to other uses ahead); // (* %GEPIOp is alive on the indirectbr edges only because of it's used by; // %UGEPI); //; // DstB0: ... (there may be a gep similar to %UGEPI to be unmerged); // DstB1: ... (there may be a gep similar to %UGEPI to be unmerged); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPIOp, UIdx; // ...; // ---------------------------; //; // ---------- AFTER ----------; // SrcBlock:; // ... (same as above); // (* %GEPI is still alive on the indirectbr edges); // (* %GEPIOp is no longer alive on the indirectbr edges as a result of the; // unmerging); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPI, (UIdx-Idx); // ...; // ---------------------------; //; // The register pressure on the IndirectBr edges is reduced because %GEPIOp is; // no longer alive on them.; //; // We try to unmerge GEPs here in CodGenPrepare, as opposed to limiting merging; // of GEPs in the first place in InstCombiner::visitGetElementPtrInst() so as; // not to disable further simplications and optimizations as a result of GEP; // merging.; //; // Note this unmerging may increase the length of the data flow critical path; // (the path from %GEPIOp to %UGEPI would go through %GEPI), which is a tradeoff; // between the register pressure and the length of data-flow critical; // path. Restricting this to the uncommon IndirectBr case would minimize the; // impact of potentially longer critical path, if ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:628,Availability,alive,alive,628,"// Try unmerging GEPs to reduce liveness interference (register pressure) across; // IndirectBr edges. Since IndirectBr edges tend to touch on many blocks,; // reducing liveness interference across those edges benefits global register; // allocation. Currently handles only certain cases.; //; // For example, unmerge %GEPI and %UGEPI as below.; //; // ---------- BEFORE ----------; // SrcBlock:; // ...; // %GEPIOp = ...; // ...; // %GEPI = gep %GEPIOp, Idx; // ...; // indirectbr ... [ label %DstB0, label %DstB1, ... label %DstBi ... ]; // (* %GEPI is alive on the indirectbr edges due to other uses ahead); // (* %GEPIOp is alive on the indirectbr edges only because of it's used by; // %UGEPI); //; // DstB0: ... (there may be a gep similar to %UGEPI to be unmerged); // DstB1: ... (there may be a gep similar to %UGEPI to be unmerged); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPIOp, UIdx; // ...; // ---------------------------; //; // ---------- AFTER ----------; // SrcBlock:; // ... (same as above); // (* %GEPI is still alive on the indirectbr edges); // (* %GEPIOp is no longer alive on the indirectbr edges as a result of the; // unmerging); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPI, (UIdx-Idx); // ...; // ---------------------------; //; // The register pressure on the IndirectBr edges is reduced because %GEPIOp is; // no longer alive on them.; //; // We try to unmerge GEPs here in CodGenPrepare, as opposed to limiting merging; // of GEPs in the first place in InstCombiner::visitGetElementPtrInst() so as; // not to disable further simplications and optimizations as a result of GEP; // merging.; //; // Note this unmerging may increase the length of the data flow critical path; // (the path from %GEPIOp to %UGEPI would go through %GEPI), which is a tradeoff; // between the register pressure and the length of data-flow critical; // path. Restricting this to the uncommon IndirectBr case would minimize the; // impact of potentially longer critical path, if ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:1039,Availability,alive,alive,1039,"interference (register pressure) across; // IndirectBr edges. Since IndirectBr edges tend to touch on many blocks,; // reducing liveness interference across those edges benefits global register; // allocation. Currently handles only certain cases.; //; // For example, unmerge %GEPI and %UGEPI as below.; //; // ---------- BEFORE ----------; // SrcBlock:; // ...; // %GEPIOp = ...; // ...; // %GEPI = gep %GEPIOp, Idx; // ...; // indirectbr ... [ label %DstB0, label %DstB1, ... label %DstBi ... ]; // (* %GEPI is alive on the indirectbr edges due to other uses ahead); // (* %GEPIOp is alive on the indirectbr edges only because of it's used by; // %UGEPI); //; // DstB0: ... (there may be a gep similar to %UGEPI to be unmerged); // DstB1: ... (there may be a gep similar to %UGEPI to be unmerged); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPIOp, UIdx; // ...; // ---------------------------; //; // ---------- AFTER ----------; // SrcBlock:; // ... (same as above); // (* %GEPI is still alive on the indirectbr edges); // (* %GEPIOp is no longer alive on the indirectbr edges as a result of the; // unmerging); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPI, (UIdx-Idx); // ...; // ---------------------------; //; // The register pressure on the IndirectBr edges is reduced because %GEPIOp is; // no longer alive on them.; //; // We try to unmerge GEPs here in CodGenPrepare, as opposed to limiting merging; // of GEPs in the first place in InstCombiner::visitGetElementPtrInst() so as; // not to disable further simplications and optimizations as a result of GEP; // merging.; //; // Note this unmerging may increase the length of the data flow critical path; // (the path from %GEPIOp to %UGEPI would go through %GEPI), which is a tradeoff; // between the register pressure and the length of data-flow critical; // path. Restricting this to the uncommon IndirectBr case would minimize the; // impact of potentially longer critical path, if any, and the impact on compile; // time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:1098,Availability,alive,alive,1098,"interference (register pressure) across; // IndirectBr edges. Since IndirectBr edges tend to touch on many blocks,; // reducing liveness interference across those edges benefits global register; // allocation. Currently handles only certain cases.; //; // For example, unmerge %GEPI and %UGEPI as below.; //; // ---------- BEFORE ----------; // SrcBlock:; // ...; // %GEPIOp = ...; // ...; // %GEPI = gep %GEPIOp, Idx; // ...; // indirectbr ... [ label %DstB0, label %DstB1, ... label %DstBi ... ]; // (* %GEPI is alive on the indirectbr edges due to other uses ahead); // (* %GEPIOp is alive on the indirectbr edges only because of it's used by; // %UGEPI); //; // DstB0: ... (there may be a gep similar to %UGEPI to be unmerged); // DstB1: ... (there may be a gep similar to %UGEPI to be unmerged); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPIOp, UIdx; // ...; // ---------------------------; //; // ---------- AFTER ----------; // SrcBlock:; // ... (same as above); // (* %GEPI is still alive on the indirectbr edges); // (* %GEPIOp is no longer alive on the indirectbr edges as a result of the; // unmerging); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPI, (UIdx-Idx); // ...; // ---------------------------; //; // The register pressure on the IndirectBr edges is reduced because %GEPIOp is; // no longer alive on them.; //; // We try to unmerge GEPs here in CodGenPrepare, as opposed to limiting merging; // of GEPs in the first place in InstCombiner::visitGetElementPtrInst() so as; // not to disable further simplications and optimizations as a result of GEP; // merging.; //; // Note this unmerging may increase the length of the data flow critical path; // (the path from %GEPIOp to %UGEPI would go through %GEPI), which is a tradeoff; // between the register pressure and the length of data-flow critical; // path. Restricting this to the uncommon IndirectBr case would minimize the; // impact of potentially longer critical path, if any, and the impact on compile; // time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:1366,Availability,alive,alive,1366,"interference (register pressure) across; // IndirectBr edges. Since IndirectBr edges tend to touch on many blocks,; // reducing liveness interference across those edges benefits global register; // allocation. Currently handles only certain cases.; //; // For example, unmerge %GEPI and %UGEPI as below.; //; // ---------- BEFORE ----------; // SrcBlock:; // ...; // %GEPIOp = ...; // ...; // %GEPI = gep %GEPIOp, Idx; // ...; // indirectbr ... [ label %DstB0, label %DstB1, ... label %DstBi ... ]; // (* %GEPI is alive on the indirectbr edges due to other uses ahead); // (* %GEPIOp is alive on the indirectbr edges only because of it's used by; // %UGEPI); //; // DstB0: ... (there may be a gep similar to %UGEPI to be unmerged); // DstB1: ... (there may be a gep similar to %UGEPI to be unmerged); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPIOp, UIdx; // ...; // ---------------------------; //; // ---------- AFTER ----------; // SrcBlock:; // ... (same as above); // (* %GEPI is still alive on the indirectbr edges); // (* %GEPIOp is no longer alive on the indirectbr edges as a result of the; // unmerging); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPI, (UIdx-Idx); // ...; // ---------------------------; //; // The register pressure on the IndirectBr edges is reduced because %GEPIOp is; // no longer alive on them.; //; // We try to unmerge GEPs here in CodGenPrepare, as opposed to limiting merging; // of GEPs in the first place in InstCombiner::visitGetElementPtrInst() so as; // not to disable further simplications and optimizations as a result of GEP; // merging.; //; // Note this unmerging may increase the length of the data flow critical path; // (the path from %GEPIOp to %UGEPI would go through %GEPI), which is a tradeoff; // between the register pressure and the length of data-flow critical; // path. Restricting this to the uncommon IndirectBr case would minimize the; // impact of potentially longer critical path, if any, and the impact on compile; // time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:25,Energy Efficiency,reduce,reduce,25,"// Try unmerging GEPs to reduce liveness interference (register pressure) across; // IndirectBr edges. Since IndirectBr edges tend to touch on many blocks,; // reducing liveness interference across those edges benefits global register; // allocation. Currently handles only certain cases.; //; // For example, unmerge %GEPI and %UGEPI as below.; //; // ---------- BEFORE ----------; // SrcBlock:; // ...; // %GEPIOp = ...; // ...; // %GEPI = gep %GEPIOp, Idx; // ...; // indirectbr ... [ label %DstB0, label %DstB1, ... label %DstBi ... ]; // (* %GEPI is alive on the indirectbr edges due to other uses ahead); // (* %GEPIOp is alive on the indirectbr edges only because of it's used by; // %UGEPI); //; // DstB0: ... (there may be a gep similar to %UGEPI to be unmerged); // DstB1: ... (there may be a gep similar to %UGEPI to be unmerged); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPIOp, UIdx; // ...; // ---------------------------; //; // ---------- AFTER ----------; // SrcBlock:; // ... (same as above); // (* %GEPI is still alive on the indirectbr edges); // (* %GEPIOp is no longer alive on the indirectbr edges as a result of the; // unmerging); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPI, (UIdx-Idx); // ...; // ---------------------------; //; // The register pressure on the IndirectBr edges is reduced because %GEPIOp is; // no longer alive on them.; //; // We try to unmerge GEPs here in CodGenPrepare, as opposed to limiting merging; // of GEPs in the first place in InstCombiner::visitGetElementPtrInst() so as; // not to disable further simplications and optimizations as a result of GEP; // merging.; //; // Note this unmerging may increase the length of the data flow critical path; // (the path from %GEPIOp to %UGEPI would go through %GEPI), which is a tradeoff; // between the register pressure and the length of data-flow critical; // path. Restricting this to the uncommon IndirectBr case would minimize the; // impact of potentially longer critical path, if ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:1325,Energy Efficiency,reduce,reduced,1325,"interference (register pressure) across; // IndirectBr edges. Since IndirectBr edges tend to touch on many blocks,; // reducing liveness interference across those edges benefits global register; // allocation. Currently handles only certain cases.; //; // For example, unmerge %GEPI and %UGEPI as below.; //; // ---------- BEFORE ----------; // SrcBlock:; // ...; // %GEPIOp = ...; // ...; // %GEPI = gep %GEPIOp, Idx; // ...; // indirectbr ... [ label %DstB0, label %DstB1, ... label %DstBi ... ]; // (* %GEPI is alive on the indirectbr edges due to other uses ahead); // (* %GEPIOp is alive on the indirectbr edges only because of it's used by; // %UGEPI); //; // DstB0: ... (there may be a gep similar to %UGEPI to be unmerged); // DstB1: ... (there may be a gep similar to %UGEPI to be unmerged); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPIOp, UIdx; // ...; // ---------------------------; //; // ---------- AFTER ----------; // SrcBlock:; // ... (same as above); // (* %GEPI is still alive on the indirectbr edges); // (* %GEPIOp is no longer alive on the indirectbr edges as a result of the; // unmerging); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPI, (UIdx-Idx); // ...; // ---------------------------; //; // The register pressure on the IndirectBr edges is reduced because %GEPIOp is; // no longer alive on them.; //; // We try to unmerge GEPs here in CodGenPrepare, as opposed to limiting merging; // of GEPs in the first place in InstCombiner::visitGetElementPtrInst() so as; // not to disable further simplications and optimizations as a result of GEP; // merging.; //; // Note this unmerging may increase the length of the data flow critical path; // (the path from %GEPIOp to %UGEPI would go through %GEPI), which is a tradeoff; // between the register pressure and the length of data-flow critical; // path. Restricting this to the uncommon IndirectBr case would minimize the; // impact of potentially longer critical path, if any, and the impact on compile; // time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:1590,Performance,optimiz,optimizations,1590,"interference (register pressure) across; // IndirectBr edges. Since IndirectBr edges tend to touch on many blocks,; // reducing liveness interference across those edges benefits global register; // allocation. Currently handles only certain cases.; //; // For example, unmerge %GEPI and %UGEPI as below.; //; // ---------- BEFORE ----------; // SrcBlock:; // ...; // %GEPIOp = ...; // ...; // %GEPI = gep %GEPIOp, Idx; // ...; // indirectbr ... [ label %DstB0, label %DstB1, ... label %DstBi ... ]; // (* %GEPI is alive on the indirectbr edges due to other uses ahead); // (* %GEPIOp is alive on the indirectbr edges only because of it's used by; // %UGEPI); //; // DstB0: ... (there may be a gep similar to %UGEPI to be unmerged); // DstB1: ... (there may be a gep similar to %UGEPI to be unmerged); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPIOp, UIdx; // ...; // ---------------------------; //; // ---------- AFTER ----------; // SrcBlock:; // ... (same as above); // (* %GEPI is still alive on the indirectbr edges); // (* %GEPIOp is no longer alive on the indirectbr edges as a result of the; // unmerging); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPI, (UIdx-Idx); // ...; // ---------------------------; //; // The register pressure on the IndirectBr edges is reduced because %GEPIOp is; // no longer alive on them.; //; // We try to unmerge GEPs here in CodGenPrepare, as opposed to limiting merging; // of GEPs in the first place in InstCombiner::visitGetElementPtrInst() so as; // not to disable further simplications and optimizations as a result of GEP; // merging.; //; // Note this unmerging may increase the length of the data flow critical path; // (the path from %GEPIOp to %UGEPI would go through %GEPI), which is a tradeoff; // between the register pressure and the length of data-flow critical; // path. Restricting this to the uncommon IndirectBr case would minimize the; // impact of potentially longer critical path, if any, and the impact on compile; // time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:1572,Usability,simpl,simplications,1572,"interference (register pressure) across; // IndirectBr edges. Since IndirectBr edges tend to touch on many blocks,; // reducing liveness interference across those edges benefits global register; // allocation. Currently handles only certain cases.; //; // For example, unmerge %GEPI and %UGEPI as below.; //; // ---------- BEFORE ----------; // SrcBlock:; // ...; // %GEPIOp = ...; // ...; // %GEPI = gep %GEPIOp, Idx; // ...; // indirectbr ... [ label %DstB0, label %DstB1, ... label %DstBi ... ]; // (* %GEPI is alive on the indirectbr edges due to other uses ahead); // (* %GEPIOp is alive on the indirectbr edges only because of it's used by; // %UGEPI); //; // DstB0: ... (there may be a gep similar to %UGEPI to be unmerged); // DstB1: ... (there may be a gep similar to %UGEPI to be unmerged); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPIOp, UIdx; // ...; // ---------------------------; //; // ---------- AFTER ----------; // SrcBlock:; // ... (same as above); // (* %GEPI is still alive on the indirectbr edges); // (* %GEPIOp is no longer alive on the indirectbr edges as a result of the; // unmerging); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPI, (UIdx-Idx); // ...; // ---------------------------; //; // The register pressure on the IndirectBr edges is reduced because %GEPIOp is; // no longer alive on them.; //; // We try to unmerge GEPs here in CodGenPrepare, as opposed to limiting merging; // of GEPs in the first place in InstCombiner::visitGetElementPtrInst() so as; // not to disable further simplications and optimizations as a result of GEP; // merging.; //; // Note this unmerging may increase the length of the data flow critical path; // (the path from %GEPIOp to %UGEPI would go through %GEPI), which is a tradeoff; // between the register pressure and the length of data-flow critical; // path. Restricting this to the uncommon IndirectBr case would minimize the; // impact of potentially longer critical path, if any, and the impact on compile; // time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:24,Usability,simpl,simple,24,// Check that GEPI is a simple gep with a single constant index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:58,Availability,alive,alive,58,"// Check that GEP is used outside the block, meaning it's alive on the; // IndirectBr edge(s).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:73,Availability,alive,alive,73,// Check each user of GEPIOp to check if unmerging would make GEPIOp not alive; // on IndirectBr edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:23,Usability,simpl,simple,23,"// Check if UGEPI is a simple gep with a single constant index and GEPIOp is; // the pointer operand to it. If so, record it in the vector. If not, give; // up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:86,Safety,avoid,avoid,86,"// If GEPI is not inbounds but UGEPI is inbounds, change UGEPI to not; // inbounds to avoid UB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:82,Availability,alive,alive,82,"// After unmerging, verify that GEPIOp is actually only used in SrcBlock (not; // alive on IndirectBr edges).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:54,Performance,optimiz,optimizations,54,// Bail out if we inserted the instruction to prevent optimizations from; // stepping on each other's toes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:38,Performance,optimiz,optimizations,38,"// It is possible for very late stage optimizations (such as SimplifyCFG); // to introduce PHI nodes too late to be cleaned up. If we detect such a; // trivial PHI, go ahead and zap it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:134,Safety,detect,detect,134,"// It is possible for very late stage optimizations (such as SimplifyCFG); // to introduce PHI nodes too late to be cleaned up. If we detect such a; // trivial PHI, go ahead and zap it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:61,Usability,Simpl,SimplifyCFG,61,"// It is possible for very late stage optimizations (such as SimplifyCFG); // to introduce PHI nodes too late to be cleaned up. If we detect such a; // trivial PHI, go ahead and zap it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:76,Energy Efficiency,efficient,efficient,76,"// freeze(icmp a, const)) -> icmp (freeze a), const; // This helps generate efficient conditional jumps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:96,Modifiability,rewrite,rewrite,96,// In this pass we look for GEP and cast instructions that are used; // across basic blocks and rewrite them to improve basic-block-at-a-time; // selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:136,Performance,optimiz,optimize,136,// For huge function we tend to quickly go though the inner optmization; // opportunities in the BB. So we go back to the BB head to re-optimize; // each instruction instead of go back to the function head.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:12,Performance,optimiz,optimizations,12,// Some CGP optimizations may move or alter what's computed in a block. Check; // whether a dbg.value intrinsic could be pointed at a more appropriate operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:122,Deployability,update,update,122,"// Point dbg.value at locally computed address, which should give the best; // opportunity to be accurately lowered. This update may change the type; // of pointer being referred to; however this makes no difference to; // debugging information, and we can't generate bitcasts that may affect; // codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:122,Deployability,update,update,122,"// Point dbg.value at locally computed address, which should give the best; // opportunity to be accurately lowered. This update may change the type; // of pointer being referred to; however this makes no difference to; // debugging information, and we can't generate bitcasts that may affect; // codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:75,Performance,optimiz,optimizations,75,"// A llvm.dbg.value may be using a value before its definition, due to; // optimizations in this pass and others. Scan for such dbg.values, and rescue; // them by moving the dbg.value to immediately after the value definition.; // FIXME: Ideally this should never be necessary, and this has the potential; // to re-order dbg.value intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:17,Integrability,depend,depend,17,"// This item may depend on multiple instructions, complicating any; // potential sink. This block takes the defensive approach, opting to; // ""undef"" the item if it has more than one instruction and any of them do; // not dominate iem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:9,Integrability,depend,depend,9,"// If we depend on multiple instructions and any of them doesn't; // dominate this DVI, we probably can't salvage it: moving it to; // after any of the instructions could cause us to lose the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:103,Integrability,depend,dependencies,103,// Group scattered pseudo probes in a block to favor SelectionDAG. Scattered; // probes can be chained dependencies of other regular DAG nodes and block DAG; // combine optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:169,Performance,optimiz,optimizations,169,// Group scattered pseudo probes in a block to favor SelectionDAG. Scattered; // probes can be chained dependencies of other regular DAG nodes and block DAG; // combine optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:10,Availability,down,down,10,/// Scale down both weights to fit into uint32_t.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:519,Performance,optimiz,optimizations,519,"/// Some targets prefer to split a conditional branch like:; /// \code; /// %0 = icmp ne i32 %a, 0; /// %1 = icmp ne i32 %b, 0; /// %or.cond = or i1 %0, %1; /// br i1 %or.cond, label %TrueBB, label %FalseBB; /// \endcode; /// into multiple branch instructions like:; /// \code; /// bb1:; /// %0 = icmp ne i32 %a, 0; /// br i1 %0, label %TrueBB, label %bb2; /// bb2:; /// %1 = icmp ne i32 %b, 0; /// br i1 %1, label %TrueBB, label %FalseBB; /// \endcode; /// This usually allows instruction selection to do even further optimizations; /// and combine the compare with the branch instruction. Currently this is; /// applied for targets which have ""cheap"" jump instructions.; ///; /// FIXME: Remove the (equivalent?) implementation in SelectionDAG.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Deployability,Update,Update,3,// Update original basic block by using the first condition directly by the; // branch instruction and removing the no longer needed and/or instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Integrability,Depend,Depending,3,// Depending on the condition we have to either replace the true or the; // false successor of the original branch instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Deployability,Update,Update,3,"// Update PHI nodes in both successors. The original BB needs to be; // replaced in one successor's PHI nodes, because the branch comes now from; // the newly generated BB (NewBB). In the other successor we need to add one; // incoming edge to the PHI nodes, because both branch instructions target; // now the same successor. Depending on the original branch condition; // (and/or) we have to swap the successors (TrueDest, FalseDest), so that; // we perform the correct update for the PHI nodes.; // This doesn't change the successor order of the just created branch; // instruction (or any other instruction).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:472,Deployability,update,update,472,"// Update PHI nodes in both successors. The original BB needs to be; // replaced in one successor's PHI nodes, because the branch comes now from; // the newly generated BB (NewBB). In the other successor we need to add one; // incoming edge to the PHI nodes, because both branch instructions target; // now the same successor. Depending on the original branch condition; // (and/or) we have to swap the successors (TrueDest, FalseDest), so that; // we perform the correct update for the PHI nodes.; // This doesn't change the successor order of the just created branch; // instruction (or any other instruction).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:327,Integrability,Depend,Depending,327,"// Update PHI nodes in both successors. The original BB needs to be; // replaced in one successor's PHI nodes, because the branch comes now from; // the newly generated BB (NewBB). In the other successor we need to add one; // incoming edge to the PHI nodes, because both branch instructions target; // now the same successor. Depending on the original branch condition; // (and/or) we have to swap the successors (TrueDest, FalseDest), so that; // we perform the correct update for the PHI nodes.; // This doesn't change the successor order of the just created branch; // instruction (or any other instruction).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:452,Performance,perform,perform,452,"// Update PHI nodes in both successors. The original BB needs to be; // replaced in one successor's PHI nodes, because the branch comes now from; // the newly generated BB (NewBB). In the other successor we need to add one; // incoming edge to the PHI nodes, because both branch instructions target; // now the same successor. Depending on the original branch condition; // (and/or) we have to swap the successors (TrueDest, FalseDest), so that; // we perform the correct update for the PHI nodes.; // This doesn't change the successor order of the just created branch; // instruction (or any other instruction).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Deployability,Update,Update,3,// Update the branch weights (from SelectionDAGBuilder::; // FindMergedConditions).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CommandFlags.cpp:46,Integrability,Interface,Interface,46,"//===-- CommandFlags.cpp - Command Line Flags Interface ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains codegen-specific flags that are shared between different; // command line tools. The tools ""llc"" and ""opt"" both use this file to prevent; // flag duplication.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CommandFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CommandFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CommandFlags.cpp:35,Security,expose,expose,35,// FIXME: Command line flag should expose separate input/output modes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CommandFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CommandFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CommandFlags.cpp:35,Security,expose,expose,35,// FIXME: Command line flag should expose separate input/output modes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CommandFlags.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CommandFlags.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:668,Availability,mask,mask,668,"//===- ComplexDeinterleavingPass.cpp --------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Identification:; // This step is responsible for finding the patterns that can be lowered to; // complex instructions, and building a graph to represent the complex; // structures. Starting from the ""Converging Shuffle"" (a shuffle that; // reinterleaves the complex components, with a mask of <0, 2, 1, 3>), the; // operands are evaluated and identified as ""Composite Nodes"" (collections of; // instructions that can potentially be lowered to a single complex; // instruction). This is performed by checking the real and imaginary components; // and tracking the data flow for each component while following the operand; // pairs. Validity of each node is expected to be done upon creation, and any; // validation errors should halt traversal and prevent further graph; // construction.; // Instead of relying on Shuffle operations, vector interleaving and; // deinterleaving can be represented by vector.interleave2 and; // vector.deinterleave2 intrinsics. Scalable vectors can be represented only by; // these intrinsics, whereas, fixed-width vectors are recognized for both; // shufflevector instruction and intrinsics.; //; // Replacement:; // This step traverses the graph built up by identification, delegating to the; // target to validate and generate the correct intrinsics, and plumbs them; // together connecting each end of the new intrinsics graph to the existing; // use-def chain. This step is assumed to finish successfully, as all; // information is expected to be correct by this point.; //; //; // Internal data structure:; // ComplexDeinterleavingGraph:; // Keeps references to all the valid Compos",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:1097,Availability,error,errors,1097,"rt of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Identification:; // This step is responsible for finding the patterns that can be lowered to; // complex instructions, and building a graph to represent the complex; // structures. Starting from the ""Converging Shuffle"" (a shuffle that; // reinterleaves the complex components, with a mask of <0, 2, 1, 3>), the; // operands are evaluated and identified as ""Composite Nodes"" (collections of; // instructions that can potentially be lowered to a single complex; // instruction). This is performed by checking the real and imaginary components; // and tracking the data flow for each component while following the operand; // pairs. Validity of each node is expected to be done upon creation, and any; // validation errors should halt traversal and prevent further graph; // construction.; // Instead of relying on Shuffle operations, vector interleaving and; // deinterleaving can be represented by vector.interleave2 and; // vector.deinterleave2 intrinsics. Scalable vectors can be represented only by; // these intrinsics, whereas, fixed-width vectors are recognized for both; // shufflevector instruction and intrinsics.; //; // Replacement:; // This step traverses the graph built up by identification, delegating to the; // target to validate and generate the correct intrinsics, and plumbs them; // together connecting each end of the new intrinsics graph to the existing; // use-def chain. This step is assumed to finish successfully, as all; // information is expected to be correct by this point.; //; //; // Internal data structure:; // ComplexDeinterleavingGraph:; // Keeps references to all the valid CompositeNodes formed as part of the; // transformation, and every Instruction contained within ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:869,Performance,perform,performed,869,"//===- ComplexDeinterleavingPass.cpp --------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Identification:; // This step is responsible for finding the patterns that can be lowered to; // complex instructions, and building a graph to represent the complex; // structures. Starting from the ""Converging Shuffle"" (a shuffle that; // reinterleaves the complex components, with a mask of <0, 2, 1, 3>), the; // operands are evaluated and identified as ""Composite Nodes"" (collections of; // instructions that can potentially be lowered to a single complex; // instruction). This is performed by checking the real and imaginary components; // and tracking the data flow for each component while following the operand; // pairs. Validity of each node is expected to be done upon creation, and any; // validation errors should halt traversal and prevent further graph; // construction.; // Instead of relying on Shuffle operations, vector interleaving and; // deinterleaving can be represented by vector.interleave2 and; // vector.deinterleave2 intrinsics. Scalable vectors can be represented only by; // these intrinsics, whereas, fixed-width vectors are recognized for both; // shufflevector instruction and intrinsics.; //; // Replacement:; // This step traverses the graph built up by identification, delegating to the; // target to validate and generate the correct intrinsics, and plumbs them; // together connecting each end of the new intrinsics graph to the existing; // use-def chain. This step is assumed to finish successfully, as all; // information is expected to be correct by this point.; //; //; // Internal data structure:; // ComplexDeinterleavingGraph:; // Keeps references to all the valid Compos",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:1341,Performance,Scalab,Scalable,1341,"sible for finding the patterns that can be lowered to; // complex instructions, and building a graph to represent the complex; // structures. Starting from the ""Converging Shuffle"" (a shuffle that; // reinterleaves the complex components, with a mask of <0, 2, 1, 3>), the; // operands are evaluated and identified as ""Composite Nodes"" (collections of; // instructions that can potentially be lowered to a single complex; // instruction). This is performed by checking the real and imaginary components; // and tracking the data flow for each component while following the operand; // pairs. Validity of each node is expected to be done upon creation, and any; // validation errors should halt traversal and prevent further graph; // construction.; // Instead of relying on Shuffle operations, vector interleaving and; // deinterleaving can be represented by vector.interleave2 and; // vector.deinterleave2 intrinsics. Scalable vectors can be represented only by; // these intrinsics, whereas, fixed-width vectors are recognized for both; // shufflevector instruction and intrinsics.; //; // Replacement:; // This step traverses the graph built up by identification, delegating to the; // target to validate and generate the correct intrinsics, and plumbs them; // together connecting each end of the new intrinsics graph to the existing; // use-def chain. This step is assumed to finish successfully, as all; // information is expected to be correct by this point.; //; //; // Internal data structure:; // ComplexDeinterleavingGraph:; // Keeps references to all the valid CompositeNodes formed as part of the; // transformation, and every Instruction contained within said nodes. It also; // holds onto a reference to the root Instruction, and the root node that should; // replace it.; //; // ComplexDeinterleavingCompositeNode:; // A CompositeNode represents a single transformation point; each node should; // transform into a single complex instruction (ignoring vector splitting, which; // would",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:1086,Security,validat,validation,1086,"rt of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Identification:; // This step is responsible for finding the patterns that can be lowered to; // complex instructions, and building a graph to represent the complex; // structures. Starting from the ""Converging Shuffle"" (a shuffle that; // reinterleaves the complex components, with a mask of <0, 2, 1, 3>), the; // operands are evaluated and identified as ""Composite Nodes"" (collections of; // instructions that can potentially be lowered to a single complex; // instruction). This is performed by checking the real and imaginary components; // and tracking the data flow for each component while following the operand; // pairs. Validity of each node is expected to be done upon creation, and any; // validation errors should halt traversal and prevent further graph; // construction.; // Instead of relying on Shuffle operations, vector interleaving and; // deinterleaving can be represented by vector.interleave2 and; // vector.deinterleave2 intrinsics. Scalable vectors can be represented only by; // these intrinsics, whereas, fixed-width vectors are recognized for both; // shufflevector instruction and intrinsics.; //; // Replacement:; // This step traverses the graph built up by identification, delegating to the; // target to validate and generate the correct intrinsics, and plumbs them; // together connecting each end of the new intrinsics graph to the existing; // use-def chain. This step is assumed to finish successfully, as all; // information is expected to be correct by this point.; //; //; // Internal data structure:; // ComplexDeinterleavingGraph:; // Keeps references to all the valid CompositeNodes formed as part of the; // transformation, and every Instruction contained within ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:1621,Security,validat,validate,1621,"complex components, with a mask of <0, 2, 1, 3>), the; // operands are evaluated and identified as ""Composite Nodes"" (collections of; // instructions that can potentially be lowered to a single complex; // instruction). This is performed by checking the real and imaginary components; // and tracking the data flow for each component while following the operand; // pairs. Validity of each node is expected to be done upon creation, and any; // validation errors should halt traversal and prevent further graph; // construction.; // Instead of relying on Shuffle operations, vector interleaving and; // deinterleaving can be represented by vector.interleave2 and; // vector.deinterleave2 intrinsics. Scalable vectors can be represented only by; // these intrinsics, whereas, fixed-width vectors are recognized for both; // shufflevector instruction and intrinsics.; //; // Replacement:; // This step traverses the graph built up by identification, delegating to the; // target to validate and generate the correct intrinsics, and plumbs them; // together connecting each end of the new intrinsics graph to the existing; // use-def chain. This step is assumed to finish successfully, as all; // information is expected to be correct by this point.; //; //; // Internal data structure:; // ComplexDeinterleavingGraph:; // Keeps references to all the valid CompositeNodes formed as part of the; // transformation, and every Instruction contained within said nodes. It also; // holds onto a reference to the root Instruction, and the root node that should; // replace it.; //; // ComplexDeinterleavingCompositeNode:; // A CompositeNode represents a single transformation point; each node should; // transform into a single complex instruction (ignoring vector splitting, which; // would generate more instructions per node). They are identified in a; // depth-first manner, traversing and identifying the operands of each; // instruction in the order they appear in the IR.; // Each node maintains a refer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:21,Availability,mask,mask,21,"/// Checks the given mask, and determines whether said mask is interleaving.; ///; /// To be interleaving, a mask must alternate between `i` and `i + (Length /; /// 2)`, and must contain all numbers within the range of `[0..Length)` (e.g. a; /// 4x vector interleaving mask would be <0, 2, 1, 3>).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:55,Availability,mask,mask,55,"/// Checks the given mask, and determines whether said mask is interleaving.; ///; /// To be interleaving, a mask must alternate between `i` and `i + (Length /; /// 2)`, and must contain all numbers within the range of `[0..Length)` (e.g. a; /// 4x vector interleaving mask would be <0, 2, 1, 3>).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:109,Availability,mask,mask,109,"/// Checks the given mask, and determines whether said mask is interleaving.; ///; /// To be interleaving, a mask must alternate between `i` and `i + (Length /; /// 2)`, and must contain all numbers within the range of `[0..Length)` (e.g. a; /// 4x vector interleaving mask would be <0, 2, 1, 3>).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:269,Availability,mask,mask,269,"/// Checks the given mask, and determines whether said mask is interleaving.; ///; /// To be interleaving, a mask must alternate between `i` and `i + (Length /; /// 2)`, and must contain all numbers within the range of `[0..Length)` (e.g. a; /// 4x vector interleaving mask would be <0, 2, 1, 3>).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:21,Availability,mask,mask,21,"/// Checks the given mask, and determines whether said mask is deinterleaving.; ///; /// To be deinterleaving, a mask must increment in steps of 2, and either start; /// with 0 or 1.; /// (e.g. an 8x vector deinterleaving mask would be either <0, 2, 4, 6> or; /// <1, 3, 5, 7>).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:55,Availability,mask,mask,55,"/// Checks the given mask, and determines whether said mask is deinterleaving.; ///; /// To be deinterleaving, a mask must increment in steps of 2, and either start; /// with 0 or 1.; /// (e.g. an 8x vector deinterleaving mask would be either <0, 2, 4, 6> or; /// <1, 3, 5, 7>).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:113,Availability,mask,mask,113,"/// Checks the given mask, and determines whether said mask is deinterleaving.; ///; /// To be deinterleaving, a mask must increment in steps of 2, and either start; /// with 0 or 1.; /// (e.g. an 8x vector deinterleaving mask would be either <0, 2, 4, 6> or; /// <1, 3, 5, 7>).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:222,Availability,mask,mask,222,"/// Checks the given mask, and determines whether said mask is deinterleaving.; ///; /// To be deinterleaving, a mask must increment in steps of 2, and either start; /// with 0 or 1.; /// (e.g. an 8x vector deinterleaving mask would be either <0, 2, 4, 6> or; /// <1, 3, 5, 7>).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:72,Usability,simpl,simple,72,"/// When examining a basic block for complex deinterleaving, if it is a simple; /// one-block loop, then the only incoming block is 'Incoming' and the; /// 'BackEdge' block is the block itself.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:399,Energy Efficiency,reduce,reduce,399,"/// ReductionInfo maps from %ReductionOp to %PHInode and Instruction; /// %OutsideUser as it is shown in the IR:; ///; /// vector.body:; /// %PHInode = phi <vector type> [ zeroinitializer, %entry ],; /// [ %ReductionOp, %vector.body ]; /// ...; /// %ReductionOp = fadd i64 ...; /// ...; /// br i1 %condition, label %vector.body, %middle.block; ///; /// middle.block:; /// %OutsideUser = llvm.vector.reduce.fadd(..., %ReductionOp); ///; /// %OutsideUser can be `llvm.vector.reduce.fadd` or `fadd` preceding; /// `llvm.vector.reduce.fadd` when unroll factor isn't one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:473,Energy Efficiency,reduce,reduce,473,"/// ReductionInfo maps from %ReductionOp to %PHInode and Instruction; /// %OutsideUser as it is shown in the IR:; ///; /// vector.body:; /// %PHInode = phi <vector type> [ zeroinitializer, %entry ],; /// [ %ReductionOp, %vector.body ]; /// ...; /// %ReductionOp = fadd i64 ...; /// ...; /// br i1 %condition, label %vector.body, %middle.block; ///; /// middle.block:; /// %OutsideUser = llvm.vector.reduce.fadd(..., %ReductionOp); ///; /// %OutsideUser can be `llvm.vector.reduce.fadd` or `fadd` preceding; /// `llvm.vector.reduce.fadd` when unroll factor isn't one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:524,Energy Efficiency,reduce,reduce,524,"/// ReductionInfo maps from %ReductionOp to %PHInode and Instruction; /// %OutsideUser as it is shown in the IR:; ///; /// vector.body:; /// %PHInode = phi <vector type> [ zeroinitializer, %entry ],; /// [ %ReductionOp, %vector.body ]; /// ...; /// %ReductionOp = fadd i64 ...; /// ...; /// br i1 %condition, label %vector.body, %middle.block; ///; /// middle.block:; /// %OutsideUser = llvm.vector.reduce.fadd(..., %ReductionOp); ///; /// %OutsideUser can be `llvm.vector.reduce.fadd` or `fadd` preceding; /// `llvm.vector.reduce.fadd` when unroll factor isn't one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:22,Safety,detect,detecting,22,"/// In the process of detecting a reduction, we consider a pair of; /// %ReductionOP, which we refer to as real and imag (or vice versa), and; /// traverse the use-tree to detect complex operations. As this is a reduction; /// operation, it will eventually reach RealPHI and ImagPHI, which corresponds; /// to the %ReductionOPs that we suspect to be complex.; /// RealPHI and ImagPHI are used by the identifyPHINode method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:172,Safety,detect,detect,172,"/// In the process of detecting a reduction, we consider a pair of; /// %ReductionOP, which we refer to as real and imag (or vice versa), and; /// traverse the use-tree to detect complex operations. As this is a reduction; /// operation, it will eventually reach RealPHI and ImagPHI, which corresponds; /// to the %ReductionOPs that we suspect to be complex.; /// RealPHI and ImagPHI are used by the identifyPHINode method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:84,Safety,detect,detection,84,/// Set this flag to true if RealPHI and ImagPHI were reached during reduction; /// detection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:421,Performance,scalab,scalable,421,/// Identifies the Deinterleave operation applied to a vector containing; /// complex numbers. There are two ways to represent the Deinterleave; /// operation:; /// * Using two shufflevectors with even indices for /pReal instruction and; /// odd indices for /pImag instructions (only for fixed-width vectors); /// * Using two extractvalue instructions applied to `vector.deinterleave2`; /// intrinsic (for both fixed and scalable vectors),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:248,Availability,mask,mask,248,/// identifying the operation that represents a complex number repeated in a; /// Splat vector. There are two possible types of splats: ConstantExpr with; /// the opcode ShuffleVector and ShuffleVectorInstr. Both should have an; /// initialization mask with all values set to zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:73,Availability,mask,masks,73,/// Identifies SelectInsts in a loop that has reduction with predication masks; /// and/or predicated tail folding,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:4,Performance,Perform,Perform,4,/// Perform the actual replacement of the underlying instruction graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:53,Availability,mask,mask,53,"// If the size is not even, it's not an interleaving mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:3,Safety,Detect,Detect,3,// Detect 0 and 180 degrees rotation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:3,Safety,Detect,Detect,3,// Detect 90 and 270 degrees rotation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:12,Usability,simpl,simple,12,// Identify simple one-block loop,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:33,Energy Efficiency,reduce,reduced,33,// Check if final instruction is reduced outside of current block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:38,Integrability,depend,depending,38,// Splats are represented differently depending on whether the repeated; // value is a constant or an Instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:77,Energy Efficiency,reduce,reduced,77,// Deinterleave complex vector outside of loop so that it can be finally; // reduced,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:541,Energy Efficiency,schedul,scheduler,541,"//===- CriticalAntiDepBreaker.cpp - Anti-dep breaker ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the CriticalAntiDepBreaker class, which; // implements register anti-dependence breaking along a blocks; // critical path during post-RA scheduler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:473,Integrability,depend,dependence,473,"//===- CriticalAntiDepBreaker.cpp - Anti-dep breaker ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the CriticalAntiDepBreaker class, which; // implements register anti-dependence breaking along a blocks; // critical path during post-RA scheduler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:3,Usability,Clear,Clear,3,// Clear out the register class data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:3,Usability,Clear,Clear,3,"// Clear ""do not change"" set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:148,Energy Efficiency,schedul,scheduled,148,"// If Reg is currently live, then mark that it can't be renamed as; // we don't know the extent of its live-range anymore (now that it; // has been scheduled).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:54,Energy Efficiency,schedul,scheduling,54,"// Any register which was defined within the previous scheduling region; // may have been rescheduled and its lifetime may overlap with registers; // in ways not reflected in our current liveness state. For each such; // register, adjust the liveness state to be conservatively correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:115,Energy Efficiency,schedul,scheduled,115,"// Move the def index to the end of the previous region, to reflect; // that the def could theoretically have been scheduled at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:48,Integrability,depend,dependency,48,"// In the case of a latency tie, prefer an anti-dependency edge over; // other types of edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:20,Performance,latency,latency,20,"// In the case of a latency tie, prefer an anti-dependency edge over; // other types of edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:12,Safety,safe,safe,12,"// It's not safe to change register allocation for source operands of; // instructions that have special allocation requirements. Also assume all; // registers used in a call must not be changed (ABI).; // FIXME: The issue with predicated instruction is more complex. We are being; // conservative here because the kill markers cannot be trusted after; // if-conversion:; // %r6 = LDR %sp, %reg0, 92, 14, %reg0; mem:LD4[FixedStack14]; // ...; // STR %r0, killed %r6, %reg0, 0, 0, %cpsr; mem:ST4[%395]; // %r6 = LDR %sp, %reg0, 100, 0, %cpsr; mem:LD4[FixedStack12]; // STR %r0, killed %r6, %reg0, 0, 14, %reg0; mem:ST4[%396](align=8); //; // The first R6 kill is not really a kill since it's killed by a predicated; // instruction which may not be executed. The second R6 def may or may not; // re-define R6 so it's not safe to change it since the last R6 use cannot be; // changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:819,Safety,safe,safe,819,"// It's not safe to change register allocation for source operands of; // instructions that have special allocation requirements. Also assume all; // registers used in a call must not be changed (ABI).; // FIXME: The issue with predicated instruction is more complex. We are being; // conservative here because the kill markers cannot be trusted after; // if-conversion:; // %r6 = LDR %sp, %reg0, 92, 14, %reg0; mem:LD4[FixedStack14]; // ...; // STR %r0, killed %r6, %reg0, 0, 0, %cpsr; mem:ST4[%395]; // %r6 = LDR %sp, %reg0, 100, 0, %cpsr; mem:LD4[FixedStack12]; // STR %r0, killed %r6, %reg0, 0, 14, %reg0; mem:ST4[%396](align=8); //; // The first R6 kill is not really a kill since it's killed by a predicated; // instruction which may not be executed. The second R6 def may or may not; // re-define R6 so it's not safe to change it since the last R6 use cannot be; // changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:55,Deployability,update,update,55,// Scan the register operands for this instruction and update; // Classes and RegRefs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:3,Deployability,Update,Update,3,"// Update liveness.; // Proceeding upwards, registers that are defed but not used in this; // instruction are now dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:80,Deployability,update,updates,80,"// Predicated defs are modeled as read + write, i.e. similar to two; // address updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:39,Deployability,update,update,39,"// For the reg itself and all subregs: update the def to current;; // reset the kill state, any restrictions, and references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:448,Performance,load,loads,448,"// Check all machine operands that reference the antidependent register and must; // be replaced by NewReg. Return true if any of their parent instructions may; // clobber the new register.; //; // Note: AntiDepReg may be referenced by a two-address instruction such that; // it's use operand is tied to a def operand. We guard against the case in which; // the two-address instruction also defines NewReg, as may happen with; // pre/postincrement loads. In this case, both the use and def operands are in; // RegRefs because the def is inserted by PrescanInstruction and not erased; // during ScanInstruction. So checking for an instruction with definitions of; // both NewReg and AntiDepReg covers it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:198,Performance,optimiz,optimizing,198,"// Don't allow the instruction defining AntiDepReg to earlyclobber its; // operands, in case they may be assigned to NewReg. In this case antidep; // breaking must fail, but it's too rare to bother optimizing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:63,Availability,repair,repair,63,"// Don't replace a register with one that was recently used to repair; // an anti-dependence with this AntiDepReg, because that would; // re-introduce that anti-dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:82,Integrability,depend,dependence,82,"// Don't replace a register with one that was recently used to repair; // an anti-dependence with this AntiDepReg, because that would; // re-introduce that anti-dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:161,Integrability,depend,dependence,161,"// Don't replace a register with one that was recently used to repair; // an anti-dependence with this AntiDepReg, because that would; // re-introduce that anti-dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:92,Safety,safe,safe,92,"// If NewReg is dead and NewReg's most recent def is not before; // AntiDepReg's kill, it's safe to replace AntiDepReg with NewReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:29,Availability,avail,available,29,// No registers are free and available!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:176,Energy Efficiency,Schedul,ScheduleDAGInstrs,176,// Keep a map of the MachineInstr*'s back to the SUnit representing them.; // This is used for updating debug information.; //; // FIXME: Replace this with the existing map in ScheduleDAGInstrs::MISUnitMap,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:675,Availability,repair,repair,675,"// Consider this pattern:; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // There are three anti-dependencies here, and without special care,; // we'd break all of them using the same register:; // A = ...; // ... = A; // B = ...; // ... = B; // B = ...; // ... = B; // B = ...; // ... = B; // because at each anti-dependence, B is the first register that; // isn't A which is free. This re-introduces anti-dependencies; // at all but one of the original anti-dependencies that we were; // trying to break. To avoid this, keep track of the most recent; // register that each register was replaced with, avoid; // using it to repair an anti-dependence on the same register.; // This lets us produce this:; // A = ...; // ... = A; // B = ...; // ... = B; // C = ...; // ... = C; // B = ...; // ... = B; // This still has an anti-dependence on B, but at least it isn't on the; // original critical path.; //; // TODO: If we tracked more than one register here, we could potentially; // fix that remaining critical edge too. This is a little more involved,; // because unlike the most recent register, less recent registers should; // still be considered, though only if no other registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
